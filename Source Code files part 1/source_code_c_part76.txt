			DWORD* pdwSecondNoneCount,
											bool* pbBothNonePossible);

};
    
class COrNode : public CNodeWithImplications
{
protected:
    CUniquePointerArray<CEvalNode> m_apBranches;

    void operator=(const COrNode& Other);

public:
    COrNode(){}
    COrNode(const COrNode& Other) {*this = Other;}
    virtual ~COrNode(){}
    HRESULT AddBranch(CEvalNode* pNewBranch);
    
    virtual int GetType() {return EVAL_NODE_TYPE_OR;}
    virtual CEvalNode* Clone() const {return new COrNode(*this);}

    virtual HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes);
    virtual int Compare(CEvalNode* pOther);
    virtual DWORD ApplyPredicate(CLeafPredicate* pPred);
    virtual void Dump(FILE* f, int nOffset);
    virtual HRESULT Evaluate(CObjectInfo& Info, CSortedArray& trueIDs);
    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    HRESULT Project(CContextMetaData* pMeta, CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode);

protected:
    HRESULT CombineWithOrNode(COrNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes);
};


class ESSCLI_POLARITY CEvalTree
{
protected:
    long m_lRef;
    CCritSec m_cs;

    CEvalNode* m_pStart;
    CObjectInfo m_ObjectInfo;
    int m_nNumValues;

protected:
    class CRemoveIndexPredicate : public CLeafPredicate
    {
    protected:
        int m_nIndex;
    public:
        CRemoveIndexPredicate(int nIndex) : m_nIndex(nIndex){}
        DWORD operator()(CValueNode* pLeaf);
    };

    class CRemoveFailureAtIndexPredicate : public CLeafPredicate
    {
    protected:
        int m_nIndex;
    public:
        CRemoveFailureAtIndexPredicate(int nIndex) : m_nIndex(nIndex){}
        DWORD operator()(CValueNode* pLeaf);
    };

    class CRebasePredicate : public CLeafPredicate
    {
    public:
        CRebasePredicate(QueryID newBase) :
            m_newBase(newBase)
            {}

        virtual DWORD operator()(class CValueNode* pLeaf);

    private:
        QueryID m_newBase;
    };


protected:
    static HRESULT InnerCombine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications,
                        bool bDeleteArg1, bool bDeleteArg2, CEvalNode** ppRes);
public:
    CEvalTree();
    CEvalTree(const CEvalTree& Other);
    ~CEvalTree();
    void operator=(const CEvalTree& Other);

    bool SetBool(BOOL bVal);
    bool IsFalse();
    bool IsValid();

    HRESULT CreateFromQuery(CContextMetaData* pNamespace, 
                            LPCWSTR wszQuery, 
                            long lFlags, 
                            long lMaxTokens = MAX_TOKENS_IN_DNF );

    HRESULT CreateFromQuery(CContextMetaData* pNamespace, 
                            QL_LEVEL_1_RPN_EXPRESSION* pQuery, long lFlags,
                            long lMaxTokens = MAX_TOKENS_IN_DNF );

    HRESULT CreateFromQuery(CContextMetaData* pNamespace, 
                            LPCWSTR wszClassName, int nNumTokens, 
                            QL_LEVEL_1_TOKEN* apTokens, long lFlags,
                            long lMaxTokens = MAX_TOKENS_IN_DNF );

    static HRESULT CreateFromConjunction(CContextMetaData* pNamespace, 
                                  CImplicationList& Implications,
                                  CConjunction* pConj,
                                  CEvalNode** ppRes);
    HRESULT CreateFromDNF(CContextMetaData* pNamespace, 
                                  CImplicationList& Implications,
                                  CDNFExpression* pDNF,
                                  CEvalNode** ppRes);
    HRESULT CombineWith(CEvalTree& Other, CContextMetaData* pNamespace, 
                        int nOp, long lFlags = 0);

    HRESULT Optimize(CContextMetaData* pNamespace);
    HRESULT Evaluate(IWbemObjectAccess* pObj, CSortedArray& aTrues);
    static HRESULT Evaluate(CObjectInfo& Info, CEvalNode* pStart, 
                                CSortedArray& trueIDs);
    static HRESULT Combine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications,
                        bool bDeleteArg1, bool bDeleteArg2, CEvalNode** ppRes);
    static HRESULT CombineInOrder(CBranchingNode* pArg1, CEvalNode* pArg2,
                        int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications,
                        bool bDeleteArg1, bool bDeleteArg2,
                        CEvalNode** ppRes);
    static HRESULT IsMergeAdvisable(CEvalNode* pArg1, CEvalNode* pArg2, 
                                    CImplicationList& Implications);
    static HRESULT BuildFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes);

    static HRESULT BuildTwoPropFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes);


    static int Compare(CEvalNode* pArg1, CEvalNode* pArg2);

    HRESULT RemoveIndex(int nIndex);
    HRESULT UtilizeGuarantee(CEvalTree& Guaranteed, 
                                CContextMetaData* pNamespace);
    HRESULT ApplyPredicate(CLeafPredicate* pPred);
    static inline bool IsNotEmpty(CEvalNode* pNode);

    void Rebase(QueryID newBase);

    HRESULT CreateProjection(CEvalTree& Old, CContextMetaData* pMeta,
                            CProjectionFilter* pFilter, 
                            EProjectionType eType, bool bDeleteOld);
    static HRESULT Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications, 
                            CEvalNode* pOldNode, CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteOld,
                            CEvalNode** ppNewNode);
    bool Clear();
    void Dump(FILE* f);
#ifdef CHECK_TREES
	void CheckNodes(CTreeChecker *pCheck);
#endif

protected:
    static HRESULT CombineLeafWithBranch(CValueNode* pArg1, 
                            CBranchingNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes);
    
};

class ESSCLI_POLARITY CPropertyProjectionFilter : public CProjectionFilter
{
    CUniquePointerArray<CPropertyName>* m_papProperties;
public:
    CPropertyProjectionFilter();
    ~CPropertyProjectionFilter();
    virtual bool IsInSet(CEvalNode* pNode);

    bool AddProperty(const CPropertyName& Prop);
};

//#include "evaltree.inl"
HRESULT CoreGetNumParents(_IWmiObject* pClass, ULONG *plNumParents);
RELEASE_ME _IWmiObject* CoreGetEmbeddedObj(_IWmiObject* pObj, long lHandle);
INTERNAL CCompressedString* CoreGetPropertyString(_IWmiObject* pObj, 
                                long lHandle);
INTERNAL CCompressedString* CoreGetClassInternal(_IWmiObject* pObj);
INTERNAL CCompressedString* CoreGetParentAtIndex(_IWmiObject* pObj, 
                                long lIndex);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\filtprox.h ===
//******************************************************************************
//
//  FILTPROX.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_FILTER_PROXY__H_
#define __WBEM_FILTER_PROXY__H_

#include <evaltree.h>
#include <TimeKeeper.h>

class CWrappingMetaData : public CMetaData
{
protected:
    IWbemMetaData* m_pDest;
public:
    CWrappingMetaData(IWbemMetaData* pDest) : m_pDest(pDest)
        {m_pDest->AddRef();}
    ~CWrappingMetaData()
        {m_pDest->Release();}

    STDMETHOD(GetClass)(LPCWSTR wszName, IWbemContext* pContext,
                            IWbemClassObject** ppClass)
        {return m_pDest->GetClass(wszName, pContext, ppClass);}

    virtual HRESULT GetClass(LPCWSTR wszName, IWbemContext* pContext,
                            _IWmiObject** ppClass);
};

class CEventBatch
{
public:
    CEventBatch();
    ~CEventBatch();

    BOOL EnsureAdditionalSize(DWORD nAdditionalNeeded);
    BOOL AddEvent(IWbemClassObject *pObj, CSortedArray *pTrues);
    void RemoveAll();

    void SetItemCount(DWORD nItems) { m_nItems = nItems; }
    DWORD GetItemCount() { return m_nItems; }
    IWbemClassObject **GetObjs() { return m_ppObjs; }
    WBEM_REM_TARGETS *GetTargets() { return m_pTargets; }

protected:
    DWORD            m_nItems,
                     m_dwSize;
    IWbemClassObject **m_ppObjs;
    WBEM_REM_TARGETS *m_pTargets;
};

class CFilterProxyManager;
class CFilterProxy : public IWbemEventSink, public IMarshal
{
protected:
    long m_lRef;
    CFilterProxyManager* m_pManager;
    CWrappingMetaData* m_pMetaData;

    CEvalTree m_SourceDefinition;
    CEvalTree m_Filter;
    WORD m_wSourceVersion;
    WORD m_wAppliedSourceVersion;

    long m_lSDLength;
    BYTE* m_pSD;

    IWbemEventProvider* m_pProvider;
    IWbemEventProviderQuerySink* m_pQuerySink;
    bool m_bRunning;
    bool m_bUtilizeGuarantee;

    CCritSec m_cs;

    static CTimeKeeper mstatic_TimeKeeper;

    /////////////////////////////////////////////////////////////////////////
    // Batching members
    
    void BatchEvent(IWbemClassObject *pObj, CSortedArray *pTrues);
    HRESULT BatchMany(long nEvents, IUnknown **ppObjects);
    BOOL IsBatching() { return m_bBatching; }
    
    WBEM_BATCH_TYPE m_typeBatch;
    DWORD           m_dwCurrentBufferSize,
                    m_dwMaxBufferSize,
                    m_dwMaxSendLatency,
                    m_dwLastSentStamp;
    BOOL            m_bBatching;


public:
    static BYTE mstatic_EmptySD;

    HRESULT Lock();
    HRESULT Unlock();
    HRESULT AddFilter(IWbemContext* pContext, LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT RemoveFilter(IWbemContext* pContext, 
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT RemoveAllFilters(IWbemContext* pContext);
    HRESULT AddDefinitionQuery(IWbemContext* pContext, LPCWSTR wszQuery);
    HRESULT RemoveAllDefinitionQueries(IWbemContext* pContext);

    HRESULT AllowUtilizeGuarantee();
    HRESULT TransferFiltersFromMain(CFilterProxy* pMain);
    HRESULT FilterEvent( _IWmiObject* pEvent, CSortedArray& raTrues );

public:
    CFilterProxy(CFilterProxyManager* pManager, IUnknown* pCallback = NULL);
    ~CFilterProxy();

    HRESULT SetRunning();

    // IUnknown

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    // IWbemObjectSink

    HRESULT STDMETHODCALLTYPE Indicate(long lNumObjects, 
                                        IWbemClassObject** apObjects);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj);

    HRESULT STDMETHODCALLTYPE IndicateWithSD(
                long lNumObjects,
                IUnknown** apObjects,
                long lSDLength,
                BYTE* pSD);

    HRESULT STDMETHODCALLTYPE SetSinkSecurity(
                long lSDLength,
                BYTE* pSD);

    HRESULT STDMETHODCALLTYPE IsActive();

    HRESULT STDMETHODCALLTYPE GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink);

    HRESULT STDMETHODCALLTYPE SetBatchingParameters(
                LONG lFlags,
                DWORD dwMaxBufferSize,
                DWORD dwMaxSendLatency);

    // IMarshal

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv)
            {return E_NOTIMPL;}
    STDMETHOD(ReleaseMarshalData)(IStream* pStream)
            {return E_NOTIMPL;}
    STDMETHOD(DisconnectObject)(DWORD dwReserved)
            {return E_NOTIMPL;}

protected:
    HRESULT ProcessOne(IUnknown* pObj, long lSDLength, BYTE* pSD);
    HRESULT ProcessMany(long lNumObjects, IUnknown** apObjects, 
                        long lSDLength, BYTE* pSD);
    static void SetGenerationTime(_IWmiObject* pObj);
};

class CFilterProxyManagerBase
{
    CLifeControl* m_pControl;
    
public:

    CFilterProxyManagerBase( CLifeControl* pControl ) : m_pControl(pControl)
    {
        if( m_pControl != NULL )
        {
            m_pControl->ObjectCreated( (IUnknown*)this );
        }
    }

    ~CFilterProxyManagerBase()
    {
       if( m_pControl != NULL )
       {
           m_pControl->ObjectDestroyed( (IUnknown*)this );
       }
    }
};

class CFilterProxyManager : public IMarshal, CFilterProxyManagerBase
{
protected:
    long m_lRef;
    long m_lExtRef;

    IWbemMultiTarget* m_pMultiTarget; 
    CWrappingMetaData* m_pMetaData;
    IWbemFilterStub* m_pStub;
    IWbemContext* m_pSpecialContext;

    CCritSec m_cs;
    CWbemCriticalSection m_Lock;

    CUniquePointerArray<CFilterProxy> m_apProxies;

    typedef std::map< WBEM_REMOTE_TARGET_ID_TYPE, 
                      WString, 
                      std::less< WBEM_REMOTE_TARGET_ID_TYPE >, 
                      wbem_allocator< WString > > TMap;
    typedef TMap::iterator TIterator;
    TMap m_mapQueries;

    /////////////////////////////////////////////////////////////////////////
    // Protected batching members
    typedef std::map< CFilterProxy*, 
                      DWORD, 
                      std::less< CFilterProxy* >, 
                      wbem_allocator< DWORD > > CLatencyMap;
    typedef CLatencyMap::iterator CLatencyMapItor;

    CLatencyMap m_mapLatencies;
    HANDLE      m_heventDone,
                m_hthreadSend,
                m_heventEventsPending,
                m_heventBufferNotFull,
                m_heventBufferFull;
    DWORD       m_dwMaxSendLatency,
                m_dwLastSentStamp;
    CCritSec    m_csBuffer;
    CEventBatch m_batch;
    IStream     *m_pMultiTargetStream;

    void LockBatching() { EnterCriticalSection(&m_csBuffer); }
    void UnlockBatching() { LeaveCriticalSection(&m_csBuffer); }
    BOOL IsBatching() { return m_hthreadSend != NULL; }
    CEventBatch *GetBatch(LPBYTE pSD, DWORD dwLength);
    void CalcMaxSendLatency();

    static DWORD WINAPI SendThreadProc(CFilterProxyManager *pThis);

    BOOL StartSendThread();
    void StopSendThread();

protected:

    class XProxy : public IWbemLocalFilterProxy
    {
    protected:
        CFilterProxyManager* m_pObject;
    public:

        XProxy(CFilterProxyManager* pObject) : m_pObject(pObject){}

        // IUnknown
    
        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    
        // IWbemFilterProxy
    
        HRESULT STDMETHODCALLTYPE Initialize(IWbemMetaData* pMetaData,
                            IWbemMultiTarget* pMultiTarget);
        HRESULT STDMETHODCALLTYPE Lock();
        HRESULT STDMETHODCALLTYPE Unlock();
        HRESULT STDMETHODCALLTYPE AddFilter(IWbemContext* pContext, 
                            LPCWSTR wszQuery, 
                            WBEM_REMOTE_TARGET_ID_TYPE Id);
        HRESULT STDMETHODCALLTYPE RemoveFilter(IWbemContext* pContext, 
                            WBEM_REMOTE_TARGET_ID_TYPE Id);
        HRESULT STDMETHODCALLTYPE RemoveAllFilters(IWbemContext* pContext);
    
        HRESULT STDMETHODCALLTYPE AddDefinitionQuery(IWbemContext* pContext, 
                            LPCWSTR wszQuery);
        HRESULT STDMETHODCALLTYPE RemoveAllDefinitionQueries(
                            IWbemContext* pContext);
        HRESULT STDMETHODCALLTYPE AllowUtilizeGuarantee();
        HRESULT STDMETHODCALLTYPE Disconnect();

        HRESULT STDMETHODCALLTYPE SetStub(IWbemFilterStub* pStub);
        HRESULT STDMETHODCALLTYPE LocalAddFilter(IWbemContext* pContext, 
                        LPCWSTR wszQuery, 
                        void* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
        HRESULT STDMETHODCALLTYPE GetMainSink(IWbemEventSink** ppSink);
    } m_XProxy;

    IWbemContext* GetProperContext(IWbemContext* pCurrentContext);
public:
    CFilterProxyManager(CLifeControl* pControl = NULL);
    ~CFilterProxyManager();

    HRESULT SetStub(IWbemFilterStub* pStub);
    HRESULT AddFilter(IWbemContext* pContext, LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id);

    INTERNAL IWbemEventSink* GetMainProxy();
    HRESULT RemoveProxy(CFilterProxy* pProxy);
    HRESULT GetMetaData(RELEASE_ME CWrappingMetaData** ppMeta);
    HRESULT DeliverEvent(long lNumToSend, IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                        long lSDLength, BYTE* pSD);
    HRESULT DeliverEventMT(long lNumToSend, IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                        long lSDLength, BYTE* pSD,
                                        IWbemMultiTarget *pMultiTarget);

    ULONG STDMETHODCALLTYPE AddRefProxy();
    ULONG STDMETHODCALLTYPE ReleaseProxy();

    HRESULT SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj);

    // Batching
    void AddEvent(IWbemClassObject *pObj, CSortedArray *pTrues);
    HRESULT SetProxyLatency(CFilterProxy *pProxy, DWORD dwLatency);
    void RemoveProxyLatency(CFilterProxy *pProxy);
    DWORD GetLastSentStamp();
    void WaitForEmptyBatch();

    // IUnknown

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    // IWbemFilterProxy

    HRESULT STDMETHODCALLTYPE Initialize(IWbemMetaData* pMetaData,
                        IWbemMultiTarget* pMultiTarget);
    HRESULT STDMETHODCALLTYPE Lock();
    HRESULT STDMETHODCALLTYPE Unlock();
    HRESULT STDMETHODCALLTYPE AddFilter(IWbemContext* pContext, 
                        LPCWSTR wszQuery, 
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT STDMETHODCALLTYPE RemoveFilter(IWbemContext* pContext, 
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT STDMETHODCALLTYPE RemoveAllFilters(IWbemContext* pContext);

    HRESULT STDMETHODCALLTYPE AddDefinitionQuery(IWbemContext* pContext, 
                        LPCWSTR wszQuery);
    HRESULT STDMETHODCALLTYPE RemoveAllDefinitionQueries(
                        IWbemContext* pContext);
    HRESULT STDMETHODCALLTYPE AllowUtilizeGuarantee();
    HRESULT STDMETHODCALLTYPE Disconnect();

    HRESULT STDMETHODCALLTYPE GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink);

    // IMarshal

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\filtprox.cpp ===
//******************************************************************************
//
//  FILTPROX.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include <wbemcomn.h>
#include "filtprox.h"
#include <eventrep.h>
#include <evtools.h>
#include <wbemdcpl.h>
#include <newnew.h>
#include <winntsec.h>

#ifdef DBG
#define _ESSCLI_ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _ESSCLI_ASSERT(X)
#endif

CTempMemoryManager g_TargetsManager;

bool TempSetTargets(WBEM_REM_TARGETS* pTargets, CSortedArray* pTrues)
{
    int nSize = pTrues->Size();
    pTargets->m_lNumTargets = nSize;
    pTargets->m_aTargets = (WBEM_REMOTE_TARGET_ID_TYPE*)
                                g_TargetsManager.Allocate(
                                    sizeof(WBEM_REMOTE_TARGET_ID_TYPE) * nSize);
    if(pTargets->m_aTargets == NULL)
        return false;

    for(int i = 0; i < nSize; i++)
    {
        pTargets->m_aTargets[i] = (WBEM_REMOTE_TARGET_ID_TYPE)pTrues->GetAt(i);
    }

    return true;
}

void TempClearTargets(WBEM_REM_TARGETS* pTargets)
{
    g_TargetsManager.Free(pTargets->m_aTargets,
                 sizeof(WBEM_REMOTE_TARGET_ID_TYPE) * pTargets->m_lNumTargets);
}


//******************************************************************************
//******************************************************************************
//                      META DATA
//******************************************************************************
//******************************************************************************


HRESULT CWrappingMetaData::GetClass(LPCWSTR wszName, IWbemContext* pContext, 
                                        _IWmiObject** ppClass)
{
    HRESULT hres;
    IWbemClassObject* pObj;
    
    *ppClass = NULL;
    
    hres = m_pDest->GetClass(wszName, pContext, &pObj);
    
    if ( FAILED(hres) )
    {
        return hres;
    }

    CReleaseMe rm1(pObj);
    return pObj->QueryInterface(IID__IWmiObject, (void**)ppClass);
}

//******************************************************************************
//******************************************************************************
//                      FILTER PROXY MANAGER
//******************************************************************************
//******************************************************************************


CFilterProxyManager::CFilterProxyManager(CLifeControl* pControl)
      : CFilterProxyManagerBase( pControl ), m_lRef(0), m_pStub(NULL), 
        m_pMetaData(NULL), m_pMultiTarget(NULL), m_pSpecialContext(NULL),
        m_XProxy(this), m_lExtRef(0),
        m_hthreadSend(NULL), 
        m_heventDone(NULL), 
        m_heventBufferNotFull(NULL),
        m_heventBufferFull(NULL), 
        m_heventEventsPending(NULL),
        m_dwLastSentStamp(0),
        m_pMultiTargetStream( NULL )
{
}

CFilterProxyManager::~CFilterProxyManager()
{
    StopSendThread();

    if(m_pMetaData)
        m_pMetaData->Release();
    if(m_pStub)
        m_pStub->Release();
    if(m_pMultiTarget)
        m_pMultiTarget->Release();
}
    

ULONG STDMETHODCALLTYPE CFilterProxyManager::AddRef()
{
    // This is an AddRef from a client. Increment a special counter as well
    // ====================================================================
    InterlockedIncrement(&m_lExtRef);

    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFilterProxyManager::Release()
{
    // This is a Release from a client. Check if the client has released all 
    // references to the proxy, in which case we need to disconnect ourselves
    // ======================================================================

    if(InterlockedDecrement(&m_lExtRef) == 0)
    {
        EnterCriticalSection(&m_cs);
        IWbemFilterStub* pStub = m_pStub;
        InterlockedIncrement(&m_lRef);
        LeaveCriticalSection(&m_cs);
        
        if(pStub)
            pStub->UnregisterProxy(&m_XProxy);

        InterlockedDecrement(&m_lRef);
        
    }

    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

ULONG STDMETHODCALLTYPE CFilterProxyManager::AddRefProxy()
{
    // AddRef from proxy.
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFilterProxyManager::ReleaseProxy()
{
    // Release from proxy.
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if(riid == IID_IMarshal)
        *ppv = (IMarshal*)this;
    else if(riid == IID_IWbemFilterProxy || riid == IID_IWbemLocalFilterProxy)
        *ppv = (IWbemLocalFilterProxy*)&m_XProxy;
    else
        return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CFilterProxyManager::Initialize(IWbemMetaData* pMetaData,
                    IWbemMultiTarget* pMultiTarget)
{
    CInCritSec ics(&m_cs);

    if(m_pMetaData)
        m_pMetaData->Release();
    m_pMetaData = new CWrappingMetaData(pMetaData);
    if(m_pMetaData)
        m_pMetaData->AddRef();
    else
        return WBEM_E_OUT_OF_MEMORY;

    if(m_pMultiTarget)
        m_pMultiTarget->Release();
    m_pMultiTarget = pMultiTarget;
    if(m_pMultiTarget)
        m_pMultiTarget->AddRef();

    if(GetMainProxy() == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return S_OK;
}

HRESULT CFilterProxyManager::SetStub(IWbemFilterStub* pStub)
{
    if(m_pStub)
        m_pStub->Release();
    m_pStub = pStub;
    if(m_pStub)
        m_pStub->AddRef();

    // Initialize ourselves
    // ====================

    HRESULT hres = m_pStub->RegisterProxy(&m_XProxy);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to register proxy with stub: %X\n", hres));
        return hres;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::Lock()
{
    if(m_Lock.Enter()) // old implementation: == WAIT_OBJECT_0)
    {
        return S_OK;
    }
    else
        return WBEM_E_CRITICAL_ERROR;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::Unlock()
{
    m_Lock.Leave();
    return S_OK;
}
    

HRESULT STDMETHODCALLTYPE CFilterProxyManager::AddFilter(IWbemContext* pContext,
                        LPCWSTR wszQuery, 
                        WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    // Parse the query
    // ===============

    CTextLexSource Source((LPWSTR)wszQuery);
    QL1_Parser Parser(&Source);
    QL_LEVEL_1_RPN_EXPRESSION* pExp;
    if(Parser.Parse(&pExp) != QL1_Parser::SUCCESS)
    {
        ERRORTRACE((LOG_ESS, "Filter proxy unable to parse %S\n", wszQuery));
        return WBEM_E_UNPARSABLE_QUERY;
    }

    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExp);
    return AddFilter(pContext, wszQuery, pExp, idFilter);
}
    
HRESULT CFilterProxyManager::AddFilter(IWbemContext* pContext,
                        LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    CInCritSec ics(&m_cs);

    //
    // Record the filter in our array
    //

    m_mapQueries[idFilter] = wszQuery;

    //
    // Add the filter to all our subproxies
    //

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres;
        if(m_apProxies[i] == NULL)
            continue;
        hres = m_apProxies[i]->AddFilter(GetProperContext(pContext), 
                                            wszQuery, pExp, idFilter);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to add filter %S to sub-proxy in "
                "process %d.\n", wszQuery, GetCurrentProcessId()));
            hresGlobal = hres;
        }
    }
    return hresGlobal;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::RemoveFilter(
                                            IWbemContext* pContext, 
                                            WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    CInCritSec ics(&m_cs);

    //
    // Remove the filter from our array
    //

    m_mapQueries.erase(idFilter);

    //
    // Remove the filter from all our subproxies
    //

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres;
        if(m_apProxies[i] == NULL)
            continue;
        hres = m_apProxies[i]->RemoveFilter(GetProperContext(pContext), 
                                            idFilter);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove filter from sub-proxy in "
                "process %d.\n", GetCurrentProcessId()));
            hresGlobal = hres;
        }
    }
    return hresGlobal;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::RemoveAllFilters(IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);

    //
    // Clear our filter array
    //

    m_mapQueries.clear();

    //
    // Remove all filters from all our subproxies
    //

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres;
        if(m_apProxies[i] == NULL)
            continue;
        hres = m_apProxies[i]->RemoveAllFilters(GetProperContext(pContext));
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove all filters from sub-proxy "
                "in process %d.\n", GetCurrentProcessId()));
            hresGlobal = hres;
        }
    }
    return hresGlobal;
}
    
HRESULT STDMETHODCALLTYPE CFilterProxyManager::AllowUtilizeGuarantee()
{
    CInCritSec ics(&m_cs);

    //  
    // Definition queries should be sent to the main (first) proxy only
    // 

    if(m_apProxies.GetSize() == 0)
        return WBEM_E_UNEXPECTED;

    if(m_apProxies[0] == NULL)
        return WBEM_S_FALSE;

    return m_apProxies[0]->AllowUtilizeGuarantee();
}
 
HRESULT STDMETHODCALLTYPE CFilterProxyManager::AddDefinitionQuery(
                                      IWbemContext* pContext, LPCWSTR wszQuery)
{
    CInCritSec ics(&m_cs);

    //  
    // Definition queries should be sent to the main (first) proxy only
    // 

    if(m_apProxies.GetSize() == 0)
        return WBEM_E_UNEXPECTED;
    if(m_apProxies[0] == NULL)
        return WBEM_S_FALSE;
    return m_apProxies[0]->AddDefinitionQuery(GetProperContext(pContext), 
                                                wszQuery);
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::RemoveAllDefinitionQueries(
                                            IWbemContext* pContext)
{
    //  
    // Definition queries should be sent to the main (first) proxy only
    //

    if(m_apProxies.GetSize() == 0)
        return WBEM_E_UNEXPECTED;
    if(m_apProxies[0] == NULL)
        return WBEM_S_FALSE;

    return m_apProxies[0]->RemoveAllDefinitionQueries(
                                    GetProperContext(pContext));
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::Disconnect()
{
    // We must make sure that once Disconnect returns, no events will be
    // delivered
    // =================================================================

    CInLock<CFilterProxyManager> il(this);
    {
        CInCritSec ics(&m_cs);
    
        if(m_pMetaData)
            m_pMetaData->Release();
        m_pMetaData = NULL;
    
        if(m_pStub)
            m_pStub->Release();
        m_pStub = NULL;
    
        if(m_pMultiTarget)
            m_pMultiTarget->Release();
        m_pMultiTarget = NULL;
    }

    return WBEM_S_NO_ERROR;
}


IWbemContext* CFilterProxyManager::GetProperContext(IWbemContext* pCurrentContext)
{
    // If we are a real, out-of-proc, proxy, we should not use this context,
    // because the thread that owns it is currently stuck in an RPC call to us
    // and will not be able to process dependent requests.  Instead, we must
    // use the "special" context that will cause the thread pool to always 
    // create a new thread if needed
    // =======================================================================

    if(m_pSpecialContext)
        return m_pSpecialContext;
    else
        return pCurrentContext;
}


HRESULT CFilterProxyManager::SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj)
{
    HRESULT hres;
    

    CWbemPtr<IWbemMultiTarget> pMultiTarget;

    {
        CInLock<CFilterProxyManager> il(this);

        if(m_pMultiTarget == NULL)
            return WBEM_E_UNEXPECTED;

        pMultiTarget = m_pMultiTarget;
    }

    // 
    // There is only one reason we support this call: to re-check all
    // subscriptions for validity/security
    //

    if(lFlags != WBEM_STATUS_REQUIREMENTS || 
        hResult != WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Retrieve "special" interface we use for this purpose
    //

    IWbemEventProviderRequirements* pReq = NULL;
    hres = pMultiTarget->QueryInterface(IID_IWbemEventProviderRequirements,
                                            (void**)&pReq);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pReq);
    
    return pReq->DeliverProviderRequest(hResult);
}

STDMETHODIMP CFilterProxyManager::GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink)
{
    // Basic parameter validation

    if(lNumQueries < 1)
        return WBEM_E_INVALID_PARAMETER;
    if(ppSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *ppSink = NULL;
    HRESULT hres;
    
    //
    // Construct a new filter proxy
    //

    CFilterProxy* pNewProxy = new CFilterProxy(this, pCallback);
    if(pNewProxy == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Add all the definition queries
    //

    for(long i = 0; i < lNumQueries; i++)
    {
        LPCWSTR wszQuery = awszQueries[i];
        if(wszQuery == NULL)
        {
            delete pNewProxy;
            return WBEM_E_INVALID_PARAMETER;
        }

        hres = pNewProxy->AddDefinitionQuery(NULL, wszQuery);
        if(FAILED(hres))
        {
            delete pNewProxy;
            return hres;
        }
    }

    //
    // if we made it here, then all definition queries were correctly added 
    // and we can now utilize these definitions for optimizing the filter.
    //
    pNewProxy->AllowUtilizeGuarantee();

    {
        CInCritSec ics(&m_cs);
        
        for(TIterator it = m_mapQueries.begin(); it != m_mapQueries.end(); it++)
        {
            // Parse the query
            // ===============
        
            LPCWSTR wszQuery = it->second;
            WBEM_REMOTE_TARGET_ID_TYPE idFilter = it->first;

            CTextLexSource Source(wszQuery);
            QL1_Parser Parser(&Source);
            QL_LEVEL_1_RPN_EXPRESSION* pExp;
            if(Parser.Parse(&pExp) != QL1_Parser::SUCCESS)
            {
                ERRORTRACE((LOG_ESS, "Filter proxy unable to parse %S\n", 
                    wszQuery));
                continue;
            }
        
            CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExp);
            pNewProxy->AddFilter(NULL, wszQuery, pExp, idFilter);
        }

        if(m_apProxies.Add(pNewProxy) < 0)
        {
            delete pNewProxy;
            return WBEM_E_OUT_OF_MEMORY;
        }

        pNewProxy->SetRunning();
    }
   
    return pNewProxy->QueryInterface(IID_IWbemEventSink, (void**)ppSink);
}

STDMETHODIMP CFilterProxyManager::GetUnmarshalClass(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        CLSID* pClsid)
{
    *pClsid = CLSID_WbemFilterProxy;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxyManager::GetMarshalSizeMax(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        ULONG* plSize)
{
    return CoGetMarshalSizeMax(plSize, IID_IWbemFilterStub, m_pStub, 
                                dwDestContext, pvReserved, mshlFlags);
}

STDMETHODIMP CFilterProxyManager::MarshalInterface(IStream* pStream, REFIID riid, 
                        void* pv, DWORD dwDestContext, void* pvReserved, 
                        DWORD mshlFlags)
{
    return CoMarshalInterface(pStream, IID_IWbemFilterStub, 
                                m_pStub, dwDestContext, pvReserved, mshlFlags);
}

STDMETHODIMP CFilterProxyManager::UnmarshalInterface(IStream* pStream, REFIID riid, 
                        void** ppv)
{
    //
    // before unmarshaling, we must first check we are unmarshaling due to 
    // a call from wmi ( or local system rather ).  Because we're going to 
    // be calling back 'blindly' to the passed in reference, we need to 
    // ensure we're not going to 'give away the farm'.   Remember that this 
    // custom marshaler can be used in any DCOM server, so we must ensure 
    // that it can't be misused to get an arbitrary process to call you back 
    // at potentially impersonate level. 
    //
    
    CWbemPtr<IServerSecurity> pSec;
    HRESULT hr = CoGetCallContext( IID_IServerSecurity, (void**)&pSec );
    if ( SUCCEEDED(hr) )
    {
        CNtSid ProcessSid( CNtSid::CURRENT_USER );
        if ( ProcessSid.GetStatus() != CNtSid::NoError )
            return WBEM_E_ACCESS_DENIED;
        
        hr = pSec->ImpersonateClient();
        if ( FAILED(hr) )
            return hr;

        CNtSid CallerSid( CNtSid::CURRENT_THREAD );
        pSec->RevertToSelf();

        if ( CallerSid.GetStatus() != CNtSid::NoError )
            return WBEM_E_ACCESS_DENIED;
        
        PSID pLocalSystemSid;

        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
        if ( AllocateAndInitializeSid( &id, 
                                       1,
                                       SECURITY_LOCAL_SYSTEM_RID,
                                       0,0,0,0,0,0,0, 
                                       &pLocalSystemSid ) )
        {
            BOOL bOk = EqualSid( CallerSid.GetPtr(), pLocalSystemSid ) ||
                       EqualSid( CallerSid.GetPtr(), ProcessSid.GetPtr() );
            
            FreeSid( pLocalSystemSid );

            if ( !bOk )
                return WBEM_E_ACCESS_DENIED;                                   
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // Unmarshal the stub pointer
    // ==========================

    HRESULT hres = CoUnmarshalInterface(pStream, IID_IWbemFilterStub, 
                        (void**)&m_pStub);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to unmarshal filter stub: %X\n", hres));
        return hres;
    }

    // Since we are unmarshalling, this must be a real proxy.  Real proxies 
    // should use a "special" context when calling back into CIMOM to make sure
    // that they do not cause a deadlock, because a thread in CIMOM is stuck in
    // an RPC call to this proxy and is not processing dependent requests.
    // ========================================================================

    IWbemCausalityAccess* pCausality = NULL;
    hres = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
                            IID_IWbemCausalityAccess, (void**)&pCausality);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create a context object in proxy: "
            "error code 0x%X\n", hres));
        return hres;
    }
    CReleaseMe rm1(pCausality);

    hres = pCausality->MakeSpecial();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to construct special context object in "
            "proxy: error code 0x%X\n", hres));
        return hres;
    }
    
    hres = pCausality->QueryInterface(IID_IWbemContext, 
                                        (void**)&m_pSpecialContext);
    if(FAILED(hres))
    {
        // Out of memory?
        // ==============
        return hres;
    }
    
    // Initialize ourselves
    // ====================

    hres = m_pStub->RegisterProxy(&m_XProxy);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to register proxy with stub: %X\n", hres));
        return hres;
    }

    //
    // What we must return is our main proxy
    //
    
    if(GetMainProxy())
        return GetMainProxy()->QueryInterface(riid, ppv);
    else
        return WBEM_E_CRITICAL_ERROR;
}

INTERNAL IWbemEventSink* CFilterProxyManager::GetMainProxy()
{
	//
	// We are being asked for the sink to give to the provider.  It is possible
	// that we do not have a sink --- that will be the case if the provider
	// has unloaded.  In that case, we must be sure to create it!
	//

    if(m_apProxies.GetSize() == 0)
	{
		CFilterProxy* pMainProxy = new CFilterProxy(this);
		if(pMainProxy == NULL)
			return NULL;
        pMainProxy->SetRunning();

		if(m_apProxies.Add(pMainProxy) < 0)
		{
			delete pMainProxy;
			return NULL;
		}
		return pMainProxy;
	}
    else
	{
		if(m_apProxies[0] == NULL)
		{
			CFilterProxy* pMainProxy = new CFilterProxy(this);
			if(pMainProxy == NULL)
				return NULL;
            pMainProxy->SetRunning();

			m_apProxies.SetAt(0, pMainProxy);
		}
        return m_apProxies[0];
	}
}

HRESULT CFilterProxyManager::GetMetaData(RELEASE_ME CWrappingMetaData** ppMeta)
{
    *ppMeta = m_pMetaData;
    (*ppMeta)->AddRef();
    return S_OK;
}

HRESULT CFilterProxyManager::RemoveProxy(CFilterProxy* pProxy)
{
    //
    // Called when a proxy is fully released by the client, and calls on the
    // manager to self-destruct
    //

    CFilterProxy* pOldProxy = NULL;

    {
        CInCritSec ics(&m_cs);
    
        for(int i = 0; i < m_apProxies.GetSize(); i++)
        {
            if(m_apProxies[i] == pProxy)
            {
                RemoveProxyLatency(pProxy);
                m_apProxies.RemoveAt(i, &pOldProxy);
                break;
            }
        }
    }
            
    if(pOldProxy)
    {
        // We don't do a release because pProxy's refcount is already 0 (which
        // is why we're in this function).  Normally RemoveAt would have
        // deleted it, but since we passed in &pOldProxy, it didn't.  We do this
        // so pOldProxy doesn't do its final release of the manager which could
        // destruct the manager while we're holding onto the manager's lock.
        delete pOldProxy;

        return WBEM_S_NO_ERROR;
    }
    else
        return WBEM_E_NOT_FOUND;
}

STDMETHODIMP CFilterProxyManager::ReleaseMarshalData(IStream* pStream)
{
    return CoReleaseMarshalData(pStream);
}

STDMETHODIMP CFilterProxyManager::DisconnectObject(DWORD dwReserved)
{
    // BUGBUG
    return WBEM_E_UNEXPECTED;
}

HRESULT CFilterProxyManager::DeliverEvent(long lNumToSend, 
                                            IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                        long lSDLength, BYTE* pSD)
{
    //
    // we need to hold the proxy lock when signalling an event.
    // the reason for this is that when a call to disconnect() returns, 
    // we can be absolutely sure that no events will be delivered to the 
    // stub.  Without locking here, just after the check for multitarget, 
    // disconnect could be called setting multitarget to null and then 
    // returning, however, just after the DeliverEvent call is made.
    //

    CInLock<CFilterProxyManager> il(this);

    if(m_pMultiTarget)
        return m_pMultiTarget->DeliverEvent(lNumToSend, apEvents, aTargets, 
                                        lSDLength, pSD);
    else
        return CO_E_OBJNOTCONNECTED;
}


HRESULT CFilterProxyManager::DeliverEventMT(long lNumToSend, 
                                            IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                            long lSDLength, BYTE* pSD,
                                            IWbemMultiTarget * pMultiTarget)
{
    //
    // we need to hold the proxy lock when signalling an event.  There are 
    // two reasons for this.  The first is that during resync of ess, it 
    // must ensure that no events are delivered, else they would be lost.  
    // the way ess ensures this is by grabbing the locks of all the proxies.
    // The other reason is so that when a call to disconnect() returns, 
    // we can be absolutely sure that no events will be delivered to the 
    // stub.  Without locking here, just after the check for multitarget, 
    // disconnect could be called setting multitarget to null and then 
    // returning, however, just after the DeliverEvent call is made.
    //

    // This assertion is for this func to be called in other place than
    // SendThreadProc in the future. 

    _DBG_ASSERT( pMultiTarget );

    CInLock<CFilterProxyManager> il(this);

    return pMultiTarget->DeliverEvent(lNumToSend, apEvents, aTargets, lSDLength, pSD);
}


ULONG CFilterProxyManager::XProxy::AddRef()
{
    return m_pObject->AddRefProxy();
}

ULONG CFilterProxyManager::XProxy::Release()
{
    return m_pObject->ReleaseProxy();
}

HRESULT CFilterProxyManager::XProxy::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemFilterProxy ||
        riid == IID_IWbemLocalFilterProxy)
    {
        *ppv = (IWbemLocalFilterProxy*)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

HRESULT CFilterProxyManager::XProxy::Initialize(IWbemMetaData* pMetaData,
                    IWbemMultiTarget* pMultiTarget)
{
    ENTER_API_CALL

    return m_pObject->Initialize(pMetaData, pMultiTarget);

    EXIT_API_CALL    
}
HRESULT CFilterProxyManager::XProxy::Lock()     // Deprecated ? 
{
    ENTER_API_CALL

    return m_pObject->Lock();

    EXIT_API_CALL    
}
HRESULT CFilterProxyManager::XProxy::Unlock()   // Deprecated ? 
{

    ENTER_API_CALL

    return m_pObject->Unlock();

    EXIT_API_CALL    
}
HRESULT CFilterProxyManager::XProxy::AddFilter(IWbemContext* pContext, 
                    LPCWSTR wszQuery, 
                    WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    ENTER_API_CALL

    return m_pObject->AddFilter(pContext, wszQuery, idFilter);

    EXIT_API_CALL    
}
HRESULT CFilterProxyManager::XProxy::RemoveFilter(IWbemContext* pContext, 
                    WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    ENTER_API_CALL

    return m_pObject->RemoveFilter(pContext, idFilter);
   
    EXIT_API_CALL    
}
HRESULT CFilterProxyManager::XProxy::RemoveAllFilters(IWbemContext* pContext)
{
    ENTER_API_CALL

    return m_pObject->RemoveAllFilters(pContext);

    EXIT_API_CALL    
}

HRESULT CFilterProxyManager::XProxy::AddDefinitionQuery(IWbemContext* pContext, 
                    LPCWSTR wszQuery)
{
    ENTER_API_CALL

    return m_pObject->AddDefinitionQuery(pContext, wszQuery);

    EXIT_API_CALL    
}

HRESULT CFilterProxyManager::XProxy::AllowUtilizeGuarantee()
{
    ENTER_API_CALL

    return m_pObject->AllowUtilizeGuarantee();

    EXIT_API_CALL    
}

HRESULT CFilterProxyManager::XProxy::RemoveAllDefinitionQueries(
                    IWbemContext* pContext)
{
    ENTER_API_CALL

    return m_pObject->RemoveAllDefinitionQueries(pContext);

    EXIT_API_CALL    
}
HRESULT CFilterProxyManager::XProxy::Disconnect()
{
    ENTER_API_CALL

    return m_pObject->Disconnect();

    EXIT_API_CALL    
}

HRESULT CFilterProxyManager::XProxy::SetStub(IWbemFilterStub* pStub)
{
    return m_pObject->SetStub(pStub);
}

HRESULT CFilterProxyManager::XProxy::LocalAddFilter(IWbemContext* pContext, 
                        LPCWSTR wszQuery, 
                        void* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id)
{
    return m_pObject->AddFilter(pContext, wszQuery, 
                                (QL_LEVEL_1_RPN_EXPRESSION*)pExp, Id);
}

HRESULT CFilterProxyManager::XProxy::GetMainSink(IWbemEventSink** ppSink)
{
    *ppSink = m_pObject->GetMainProxy();
    if(*ppSink)
    {
        (*ppSink)->AddRef();
        return S_OK;
    }
    else
        return E_UNEXPECTED;
}

void CFilterProxyManager::CalcMaxSendLatency()
{
    LockBatching();

    DWORD dwLatency = 0xFFFFFFFF;

    for (CLatencyMapItor i = m_mapLatencies.begin();
        i != m_mapLatencies.end();
        i++)
    {
        if ((*i).second < dwLatency)
            dwLatency = (*i).second;
    }

    m_dwMaxSendLatency = dwLatency;

    UnlockBatching();
}


HRESULT CFilterProxyManager::SetProxyLatency(CFilterProxy *pProxy, DWORD dwLatency)
{
    LockBatching();

    BOOL bWasEmpty = m_mapLatencies.size() == 0;
    
    // Add this proxy.
    m_mapLatencies[pProxy] = dwLatency;

    HRESULT hr = S_OK;

    // If our map was previously empty, start the send thread.
    if ( bWasEmpty )
    {
        m_dwMaxSendLatency = dwLatency;

        _DBG_ASSERT( NULL == m_hthreadSend );

        if ( NULL == m_hthreadSend )
        {
            _DBG_ASSERT( NULL == m_pMultiTargetStream );

            //
            // IWbemMultiTarget interface pointer is mashaled to make the 
            // interface pointer available for cross apartment access
            //

            hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemMultiTarget,
                                                        m_pMultiTarget,
                                                        &m_pMultiTargetStream );

            if ( SUCCEEDED( hr ) )
            {
                if ( FALSE == StartSendThread( ) )
                {
                    ERRORTRACE((LOG_ESS, "Failed to set proxy latency due to thread creation error : 0x%X\n", GetLastError( ) ) );
                    m_pMultiTargetStream->Release( );
                    m_pMultiTargetStream = NULL;
                    hr = E_FAIL;
                }
            }
            else
            {
                m_pMultiTargetStream = NULL;
                ERRORTRACE((LOG_ESS, "Failed to set proxy latency due to marshaling error : 0x%X\n", hr ) );
            }
        }
    }
    else
    {
        // If dwLatency is smaller than m_dwMaxSendLatency, set 
        // m_dwMaxSendLatency to the new smallest value.
        if (dwLatency < m_dwMaxSendLatency)
            m_dwMaxSendLatency = dwLatency;
    }
    
    UnlockBatching();

    return hr;
}

void CFilterProxyManager::RemoveProxyLatency(CFilterProxy *pProxy)
{
    LockBatching();

    // Try to find the proxy.
    CLatencyMapItor item = m_mapLatencies.find(pProxy);

    // Did we find it?
    if (item != m_mapLatencies.end())
    {
        // Remove it.
        m_mapLatencies.erase(item);

        // If there are no more proxies that care about batching, stop the
        // send thread.
        if (m_mapLatencies.size() == 0)
            StopSendThread();
        else
        {
            DWORD dwLatency = (*item).second;

            // If the latency value we just removed is the same as 
            // m_dwMaxSendLatency, recalc m_dwMaxSendLatency.
            if (dwLatency == m_dwMaxSendLatency)
                CalcMaxSendLatency();
        }
    }

    UnlockBatching();
}


BOOL CFilterProxyManager::StartSendThread()
{
    LockBatching();

    if ( NULL == m_hthreadSend )
    {
        DWORD dwID;

        do
        {
            m_heventDone = CreateEvent( NULL, FALSE, FALSE, NULL );
            if ( NULL == m_heventDone )
            {
                break;
            }

            m_heventBufferNotFull = CreateEvent( NULL, TRUE, TRUE, NULL );
            if ( NULL == m_heventBufferNotFull ) 
            {
                break;
            }

            m_heventBufferFull = CreateEvent( NULL, TRUE, FALSE, NULL );
            if ( NULL == m_heventBufferFull )
            {
                break;
            }

            m_heventEventsPending = CreateEvent( NULL, TRUE, FALSE, NULL );
            if ( NULL == m_heventEventsPending )
            {
                break;
            }

            m_hthreadSend = CreateThread( NULL, 
                                          0, 
                                          (LPTHREAD_START_ROUTINE) SendThreadProc,
                                          this,
                                          0,
                                          &dwID );
        }
        while( FALSE );

        if ( NULL == m_hthreadSend )
        {
            if (m_heventDone)
            {
                CloseHandle(m_heventDone);
                m_heventDone = NULL;
            }

            if (m_heventBufferNotFull)
            {
                CloseHandle(m_heventBufferNotFull);
                m_heventBufferNotFull = NULL;
            }

            if (m_heventBufferFull)
            {
                CloseHandle(m_heventBufferFull);
                m_heventBufferFull = NULL;
            }

            if (m_heventEventsPending)
            {
                CloseHandle(m_heventEventsPending);
                m_heventEventsPending = NULL;
            }
        }
    }

    UnlockBatching();

    return ( NULL != m_hthreadSend );
}

void CFilterProxyManager::StopSendThread()
{
    LockBatching();

    if (m_hthreadSend && m_heventDone)
    {
        SetEvent(m_heventDone);
        WaitForSingleObject(m_hthreadSend, 3000);
        CloseHandle(m_hthreadSend);
        m_hthreadSend = NULL;
    }

    if (m_heventDone)
    {
        CloseHandle(m_heventDone);
        m_heventDone = NULL;
    }

    if (m_heventBufferNotFull)
    {
        CloseHandle(m_heventBufferNotFull);
        m_heventBufferNotFull = NULL;
    }

    if (m_heventBufferFull)
    {
        CloseHandle(m_heventBufferFull);
        m_heventBufferFull = NULL;
    }

    if (m_heventEventsPending)
    {
        CloseHandle(m_heventEventsPending);
        m_heventEventsPending = NULL;
    }

    UnlockBatching();
}


DWORD WINAPI CFilterProxyManager::SendThreadProc(CFilterProxyManager *pThis)
{
    HANDLE  hWait[2] = { pThis->m_heventDone, pThis->m_heventEventsPending },
            hwaitSendLatency[2] = { pThis->m_heventDone, pThis->m_heventBufferFull },
            heventBufferNotFull = pThis->m_heventBufferNotFull;
    HRESULT hres;
    IWbemMultiTarget * pMultiTarget = NULL;

    _DBG_ASSERT( pThis->m_pMultiTargetStream );

    if ( NULL == pThis->m_pMultiTargetStream )
    {
        return 1;
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //
    // IWbemMultiTarget interface pointer is unmarshaled to use in this
    // thread (in case of cross apartment).
    //

    hres = CoGetInterfaceAndReleaseStream( pThis->m_pMultiTargetStream,
                                           IID_IWbemMultiTarget,
                                           ( void ** )&pMultiTarget );

    if( FAILED( hres ) )
    {
        ERRORTRACE((LOG_ESS, "Failed to run batching thread due to unmarshaling errors: 0x%X\n", hres));
        // pThis->m_pMultiTargetStream->Release( );
        pThis->m_pMultiTargetStream = NULL;
        CoUninitialize( );
        return 1;
    }

    pThis->m_pMultiTargetStream = NULL;

    _DBG_ASSERT( pMultiTarget );

    while (WaitForMultipleObjects(2, hWait, FALSE, INFINITE) != 0)
    {
        // If we have a send latency, wait for that time or until the send 
        // buffer is full.  If the done event fires, get out.
        if (pThis->m_dwMaxSendLatency)
        {
            if (WaitForMultipleObjects(2, hwaitSendLatency, FALSE, 
                pThis->m_dwMaxSendLatency) == 0)
                break;

            // Reset m_heventBufferFull.
            ResetEvent(hwaitSendLatency[1]);
        }

        CInCritSec csBuffer(&pThis->m_csBuffer);
        int        nItems = pThis->m_batch.GetItemCount();
        
        hres = pThis->DeliverEventMT(
                    nItems, 
                    pThis->m_batch.GetObjs(), 
                    pThis->m_batch.GetTargets(),
                    0, 
                    &CFilterProxy::mstatic_EmptySD,
                    pMultiTarget);

        // Increment this so the filter proxies will know to clear out their
        // buffer size when they next get an event to batch.
        pThis->m_dwLastSentStamp++; 

        pThis->m_batch.RemoveAll();

        SetEvent(heventBufferNotFull);

        // Reset m_heventEventsPending
        ResetEvent(hWait[1]);
    }

    // Make sure our batch buffer is empty before we exit.
    CInCritSec csBuffer(&pThis->m_csBuffer);
    int        nItems = pThis->m_batch.GetItemCount();
    
    if ( nItems )
    {
        pThis->DeliverEventMT(
            nItems, 
            pThis->m_batch.GetObjs(), 
            pThis->m_batch.GetTargets(),
            0, 
            &CFilterProxy::mstatic_EmptySD,
            pMultiTarget);
    }

    CoUninitialize( );

    return 0;
}

DWORD CFilterProxyManager::GetLastSentStamp()
{
    return m_dwLastSentStamp;
}

//*****************************************************************************
//*****************************************************************************
//
//                  FILTER PROXY
//
//*****************************************************************************
//*****************************************************************************

CTimeKeeper CFilterProxy::mstatic_TimeKeeper;
BYTE CFilterProxy::mstatic_EmptySD = 0;

CFilterProxy::CFilterProxy(CFilterProxyManager* pManager, IUnknown* pCallback) 
    : m_lRef(0), m_pManager(pManager), m_pMetaData(NULL),
        m_lSDLength(0), m_pSD(&mstatic_EmptySD), m_pProvider(NULL),
        m_pQuerySink(NULL), m_bRunning(false),
        m_typeBatch(WBEM_FLAG_MUST_NOT_BATCH), m_bUtilizeGuarantee(false),
        m_dwCurrentBufferSize(0), m_bBatching(FALSE),
        m_wSourceVersion(0), m_wAppliedSourceVersion(0)
{
    m_SourceDefinition.SetBool(FALSE);
    if(m_pManager)
    {
        m_pManager->AddRef();
        m_pManager->GetMetaData(&m_pMetaData);
    }

    if(pCallback)
    {
        pCallback->QueryInterface(IID_IWbemEventProvider, (void**)&m_pProvider);
        pCallback->QueryInterface(IID_IWbemEventProviderQuerySink, 
                                    (void**)&m_pQuerySink);
    }
}

CFilterProxy::~CFilterProxy()
{
    if (m_pMetaData)
        m_pMetaData->Release();

    if (m_pManager)
        m_pManager->Release();
}
    

ULONG STDMETHODCALLTYPE CFilterProxy::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFilterProxy::Release()
{
    //
    // CFilterProxy is deleted by CFilterProxyManager --- it never goes away
    // on a Release
    //

    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        //
        // Inform the manager that we are no longer needed.  This call can 
        // destroy this object!
        //

        m_pManager->RemoveProxy(this);
    }

    return lRef;
}

HRESULT STDMETHODCALLTYPE CFilterProxy::QueryInterface(REFIID riid, void** ppv)
{
    if( riid == IID_IUnknown || 
        riid == IID_IWbemObjectSink ||
        riid == IID_IWbemEventSink)
    {
        *ppv = (IWbemEventSink*)this;
    }
    else if(riid == IID_IMarshal)
    {
        *ppv = (IMarshal*)this;
    }
    else
        return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}
        
HRESULT CFilterProxy::Lock()
{
    return m_pManager->Lock();
}

HRESULT CFilterProxy::Unlock()
{
    return m_pManager->Unlock();
}

HRESULT CFilterProxy::SetRunning()
{
    HRESULT hres;

    bool bActive = false;
    IWbemEventProvider* pProvider = NULL; 

    {
        CInCritSec ics(&m_cs);

        if(m_bRunning)
            return WBEM_S_FALSE;
        else
        {
            m_bRunning = true;
            if(m_pProvider)
            {
                bActive = (IsActive() == WBEM_S_NO_ERROR);
                pProvider = m_pProvider;
                pProvider->AddRef();
            }
        }
    }

    //
    // If here, we are just now marking it for running. Notify the callback if
    // there are any sinks
    //
    
    if(bActive && pProvider)
    {
        hres = pProvider->ProvideEvents(NULL, WBEM_FLAG_START_PROVIDING);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused to stop "
                "error code 0x%X\n", hres));
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::AddFilter(IWbemContext* pContext,
                        LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    HRESULT hres;


    // Compile the query
    // =================

    CContextMetaData MetaData(m_pMetaData, pContext);

    CEvalTree Tree;
    hres = Tree.CreateFromQuery( &MetaData, pExp, WBEM_FLAG_MANDATORY_MERGE );
                                
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Filter proxy unable to parse %S, "
            "error code: %X\n", wszQuery, hres));
        return hres;
    }
        
    //
    // merge the query into the rest of the filter.
    //
    
    {
        CInCritSec ics(&m_cs);

        if ( m_bUtilizeGuarantee )
        {
            //
            // Utilize source definition
            // =========================
            
            //
            // assert that our source definition hasn't changed since the last 
            // time a filter was added.  This would be bad, since the tree 
            // doesn't account for the new source queries. Also assert that 
            // the source tree is valid and is not empty. ( These last two may
            // have to be removed in the future. For now they shouldn't be 
            // false )
            //
            
            _ESSCLI_ASSERT( m_wAppliedSourceVersion == 0 || 
                            m_wAppliedSourceVersion == m_wSourceVersion );
            _ESSCLI_ASSERT( m_SourceDefinition.IsValid() );	
            _ESSCLI_ASSERT( !m_SourceDefinition.IsFalse() );
            
            hres = Tree.UtilizeGuarantee(m_SourceDefinition, &MetaData);
        
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS, 
                            "Filter proxy unable to utilize guarantee for %S, "
                            "error code: %X\n", wszQuery, hres));
                return hres;
            }

            //
            // Check if anything is left of it
            //

            if(!Tree.IsValid())
            {
                //
                // Utilization of the guarantee shows that this filter cannot 
                // be satisftied by events coming through this proxy
                //
                
                return WBEM_S_FALSE;
            }
        }

        //
        // Add consumer information to it
        //

        Tree.Rebase((QueryID)idFilter);

    #ifdef DUMP_DEBUG_TREES
        FILE* f = fopen("c:\\try.log", "a");
        fprintf(f, "\n\nAdding filter\n");
        Tree.Dump(f);
        fprintf(f, " to existing filter: \n");
        m_Filter.Dump(f);
    #endif

        hres = m_Filter.CombineWith(Tree, &MetaData, EVAL_OP_COMBINE);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter proxy unable to combine %S with the "
                "rest, error code: %X\n", wszQuery, hres));
            return hres;
        }

        m_wAppliedSourceVersion = m_wSourceVersion;
    }


    //
    // Now, we need to notify the provider of a new filter being issued
    //

    IWbemEventProviderQuerySink* pQuerySink = NULL;
    IWbemEventProvider* pProvider = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pQuerySink)
        {
            pQuerySink = m_pQuerySink;
            pQuerySink->AddRef();
        }

        if(m_pProvider)
        {
            pProvider = m_pProvider;
            pProvider->AddRef();
        }
    }

    //
    // Call provider's NewQuery, if supported
    //

    if(pQuerySink)
    {
        hres = pQuerySink->NewQuery(idFilter, L"WQL", (LPWSTR)wszQuery);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused consumer "
                "registration query %S: error code 0x%X\n", 
                wszQuery, hres));

            // Too bad --- restricted sinks cannot veto subscriptions
        }
    }

    //
    // If we are adding this filter to a running proxy, and this is the very
    // first filter on it, we should call ProvideEvents immediately. Not so if
    // we are configuring a proxy that is not running yet --- in that case, we
    // need to wait until all outstanding filters have been put in place
    //

    if(m_bRunning && (IsActive() == WBEM_S_FALSE) && pProvider)
    {
        hres = pProvider->ProvideEvents((IWbemObjectSink*)this, 
                                        WBEM_FLAG_START_PROVIDING);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused a call to "
                    "ProvideEvents with 0x%X\n", hres));
        }
    }

#ifdef DUMP_DEBUG_TREES
    fprintf(f, " to obtain: \n");
    m_Filter.Dump(f);
    fclose(f);
#endif

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::RemoveFilter(IWbemContext* pContext, 
                                            WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    HRESULT hres;

    IWbemEventProviderQuerySink* pQuerySink = NULL;
    IWbemEventProvider* pProvider = NULL;

    bool bActive;
    {
        CInCritSec ics(&m_cs);

        if(m_pQuerySink)
        {
            pQuerySink = m_pQuerySink;
            pQuerySink->AddRef();
        }

        if(m_pProvider)
        {
            pProvider = m_pProvider;
            pProvider->AddRef();
        }
            
        hres = m_Filter.RemoveIndex(idFilter);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove index %d from the filter "
                        "proxy\n", idFilter));
            return hres;
        }
    
        CContextMetaData MetaData(m_pMetaData, pContext);

        hres = m_Filter.Optimize(&MetaData);
        if(FAILED(hres))
            return hres;

        bActive = (IsActive() == WBEM_S_NO_ERROR);
    }

    //
    // Call provider's NewQuery, if supported
    //

    if(pQuerySink)
    {
        hres = pQuerySink->CancelQuery(idFilter);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused consumer "
                "registration query cancellation: error code 0x%X\n", 
                hres));
        }
    }

    //
    // If we are left with no queries, notify provider of that fact
    //

    if(!bActive && pProvider)
    {
        hres = pProvider->ProvideEvents(NULL, WBEM_FLAG_STOP_PROVIDING);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused to stop "
                "error code 0x%X\n", hres));
        }
    }
        
#ifdef DUMP_DEBUG_TREES
    FILE* f = fopen("c:\\try.log", "a");
    fprintf(f, "Removed at %d to obtain: \n", idFilter);
    m_Filter.Dump(f);
    fclose(f);
#endif
    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::RemoveAllFilters(IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);
    m_wAppliedSourceVersion = 0;
    if(!m_Filter.Clear())
        return WBEM_E_OUT_OF_MEMORY;
    
    return WBEM_S_NO_ERROR;
}
    
HRESULT CFilterProxy::AllowUtilizeGuarantee()
{
    //
    // ess shouldn't be calling this function if the tree is invalid.
    // 
    _DBG_ASSERT( m_SourceDefinition.IsValid() );

    //
    // ess thinks its o.k. to utilize the guarantee, however there are cases
    // where the soruce definition could still be false ( e.g. when there are
    // no source definition queries or when all of the source definition 
    // queries are contradictions ).  
    // 

    CInCritSec ics(&m_cs);

    if ( !m_SourceDefinition.IsFalse() )
    {    
        m_bUtilizeGuarantee = true;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::AddDefinitionQuery( IWbemContext* pContext, 
                                          LPCWSTR wszQuery )
{
    HRESULT hres;

    // Compile the query
    // =================

    CContextMetaData MetaData(m_pMetaData, pContext);

    CEvalTree Tree;
    hres = Tree.CreateFromQuery( &MetaData, 
                                 wszQuery, 
                                 WBEM_FLAG_MANDATORY_MERGE,
                                 0x7FFFFFFF ); // no limit
    if(FAILED(hres))
    {
        return hres;
    }

    {
        CInCritSec ics(&m_cs);

        //
        // we shouldn't be adding definition queries when there are currently
        // existing filters. 
        //
        _ESSCLI_ASSERT( m_Filter.IsFalse() );

        // Merge the query into the rest
        // =============================
    
        hres = m_SourceDefinition.CombineWith(Tree, &MetaData, EVAL_OP_OR, 
                                                WBEM_FLAG_MANDATORY_MERGE);
        if(FAILED(hres))
            return hres;

        m_wSourceVersion++;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::RemoveAllDefinitionQueries( IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);

    m_wSourceVersion = 0;
    m_SourceDefinition.SetBool(FALSE);
    m_bUtilizeGuarantee = false;

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::ProcessOne( IUnknown* pUnk, 
                                  long lSDLength, 
                                  BYTE* pSD )
{
    // 
    // NOTE: not in a critical section yet
    //

    HRESULT hres;

    //
    // Check overall validity
    //
    
    if( pUnk == NULL )
    {
        ERRORTRACE((LOG_ESS, "Event provider returned a NULL event!\n"));
        return WBEM_E_INVALID_PARAMETER;
    }
    
    CWbemObject* pObj = (CWbemObject*)(IWbemClassObject*)pUnk;
    
    if( pObj->IsObjectInstance() != WBEM_S_NO_ERROR )
    {
        ERRORTRACE((LOG_ESS, "CLASS object received from event provider!\n"));
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Run the event through the filter
    //

    CSortedArray aTrues, aSourceTrues;
    CFilterProxyManager* pManager = NULL;

    {
        CInCritSec ics(&m_cs);
        
        hres = FilterEvent( pObj, aTrues );

        if ( hres == WBEM_S_NO_ERROR )
        {
            _DBG_ASSERT( aTrues.Size() > 0 );
        }
        else
        {
            return hres;
        }

        pManager = m_pManager;
        
        if( pManager )
        {
            pManager->AddRef();
        }
        else
        {
            return WBEM_S_FALSE;
        }
    }

    CReleaseMe rm2(pManager);

    //
    // the event has made it through the filter ..
    // 

    SetGenerationTime(pObj);

    if (IsBatching())
    {
        BatchEvent((IWbemClassObject*) pUnk, &aTrues);

        hres = S_OK;
    }
    else
    {
        // Some delivery is required --- construct the blob and the targets
        // ================================================================

        WBEM_REM_TARGETS RemTargets;
        if(!TempSetTargets(&RemTargets, &aTrues))
            return WBEM_E_OUT_OF_MEMORY;
        
        hres = pManager->DeliverEvent(1, (IWbemClassObject**)&pObj, 
                                      &RemTargets, lSDLength, pSD);
        TempClearTargets(&RemTargets);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter stub failed to process an event: "
                        "0x%X\n", hres));
        }
    }

    return hres;
}



void CFilterProxy::SetGenerationTime(_IWmiObject* pObj)
{
    mstatic_TimeKeeper.DecorateObject(pObj);
}

void CFilterProxyManager::AddEvent(
    IWbemClassObject *pObj, 
    CSortedArray *pTrues)
{
    LockBatching();

    BOOL bWasEmpty = m_batch.GetItemCount() == 0;

    m_batch.AddEvent(pObj, pTrues);

    if (bWasEmpty)
        SetEvent(m_heventEventsPending);

    UnlockBatching();
}

void CFilterProxyManager::WaitForEmptyBatch()
{
    LockBatching();

    // Once we get the lock and the batch has already been cleared out, we 
    // don't need to do anything else.
    if (m_batch.GetItemCount() == 0)
    {
        UnlockBatching();

        return;
    }

    // We need to wait for the send thread to finish sending what's 
    // in our buffer.

    // Wake up the send latency thread if necessary.
    if (m_dwMaxSendLatency)
        SetEvent(m_heventBufferFull);
                
    // So we'll block until the send thread sets the event.
    ResetEvent(m_heventBufferNotFull);

    UnlockBatching();

    WaitForSingleObject(m_heventBufferNotFull, INFINITE);
}

void CFilterProxy::BatchEvent(
    IWbemClassObject *pObj, 
    CSortedArray *pTrues)
{
    BOOL        bRet = FALSE;
    _IWmiObject *pWmiObj = (_IWmiObject*) pObj;
    DWORD       dwObjSize = 0;

    pWmiObj->GetObjectMemory(
        NULL,
        0,
        &dwObjSize);

    CInCritSec ics(&m_cs);

    // See if the manager has sent off its batch of events since we last
    // batched an event.
    if (m_dwLastSentStamp != m_pManager->GetLastSentStamp())
        m_dwCurrentBufferSize = 0;

    // See if we have enough room to add our event.
    if (m_dwCurrentBufferSize >= m_dwMaxBufferSize)
    {
        m_pManager->WaitForEmptyBatch();
        m_dwCurrentBufferSize = 0;
    }

    m_dwCurrentBufferSize += dwObjSize;

    m_dwLastSentStamp = m_pManager->GetLastSentStamp();
    m_pManager->AddEvent(pObj, pTrues);
}

HRESULT CFilterProxy::FilterEvent( _IWmiObject* pObj, CSortedArray& raTrues )
{            
    HRESULT hr;    

    //
    // evaluate 
    //

    try 
    {
        //
        // this code is in a try catch because if a provider generates 
        // events that it has not registered to, then we do bad things to 
        // class objects.  A potential fix could be do extra checking on 
        // our part, but is expensive when using the public interfaces. A
        // more advantageous fix should be making the class object code 
        // perform the checking for us ( e.g. when we ask for a property 
        // using an invalid handle, etc ).  It can do this checking much 
        // faster. When this checking is performed by the class object 
        // code, we should remove this try catch. see RAID 166026
        // 

        hr = m_Filter.Evaluate( pObj, raTrues );
    }
    catch( ... )
    {
        //
        // check to see if the provider is generating an event its not 
        // supposed to.  If so, then handle AV and return error, else  
        // rethrow - there's something else wrong. 
        //

        CSortedArray aSourceTrues; 

        hr = m_SourceDefinition.Evaluate( pObj, aSourceTrues );
        
        if ( SUCCEEDED(hr) && aSourceTrues.Size() == 0 )
        {
            ERRORTRACE((LOG_ESS, "Filter Proxy encountered case where "
                        "event provider is signaling events that are not "
                        "covered by its registration!!\n"));        
            
            hr = WBEM_E_INVALID_OBJECT;
        }
        else
        {
            throw;
        }
    }

    //
    // check events that make it through the filter against source definition.
    // if we're not utilizing guarantee, then there's no need to check the
    // event against the source definition because its already factored into
    // the filter.
    //

    if (SUCCEEDED(hr) && raTrues.Size() == 0 )
    {
        hr = WBEM_S_FALSE;
    }
    else if ( SUCCEEDED(hr) && m_bUtilizeGuarantee )
    {
        //
        // run the event through the source tree to ensure that the 
        // provider is providing the events its supposed to.
        // 

        CSortedArray aSourceTrues; 

        hr = m_SourceDefinition.Evaluate( pObj, aSourceTrues );

        if ( SUCCEEDED(hr) && aSourceTrues.Size() == 0 )
        {
            ERRORTRACE((LOG_ESS, "Filter Proxy encountered case where "
                        "event provider is signaling events that are not "
                        "covered by its registration!!\n"));        
            
            hr = WBEM_E_INVALID_OBJECT;
        }
    }

    return hr;
}

HRESULT CFilterProxy::BatchMany(long nEvents, IUnknown **ppObjects)
{
    HRESULT hr = S_OK;

    for ( long i = 0; i < nEvents && SUCCEEDED(hr); i++ )
    {    
        //
        // Check overall validity
        //
    
        if( ppObjects[i] == NULL )
        {
            ERRORTRACE((LOG_ESS, "Event provider returned a NULL event!\n"));
            return WBEM_E_INVALID_PARAMETER;
        }
    
        CWbemObject *pObj = (CWbemObject*)(IWbemClassObject*)ppObjects[i];
    
        if( pObj->IsObjectInstance() != WBEM_S_NO_ERROR )
        {
            ERRORTRACE((LOG_ESS, "CLASS object received from event provider!\n"));
            return WBEM_E_INVALID_PARAMETER;
        }

        //
        // Run the event through the filter
        //

        CInCritSec   ics(&m_cs);
        CSortedArray aTrues;
            
        hr = FilterEvent( pObj, aTrues );
        
        if ( hr == WBEM_S_NO_ERROR )
        {
            _DBG_ASSERT( aTrues.Size() > 0 );

            //
            // Delivery is required --- add this event to the list
            //

            SetGenerationTime(pObj);
            BatchEvent(pObj, &aTrues);
        }
    }

    return hr;
}

class CDeleteTargetsArray
{
protected:
    WBEM_REM_TARGETS *m_pData;
	int              *m_piSize;

public:
    CDeleteTargetsArray(WBEM_REM_TARGETS *pData, int *piSize) : 
		m_pData(pData),
		m_piSize(piSize)
	{
	}

    ~CDeleteTargetsArray() 
	{
		int nSize = *m_piSize;

		for (DWORD i = 0; i < nSize; i++)
            TempClearTargets(m_pData + i);
	}
};

HRESULT CFilterProxy::ProcessMany(long lNumObjects, 
                                    IUnknown** apObjects,
                                    long lSDLength, BYTE* pSD)
{
    //
    // NOTE: not in critical section
    //

    HRESULT hres;

    if (IsBatching())
        return BatchMany(lNumObjects, apObjects);

    //
    // Allocate appropriate arrays on the stack
    //

    CTempArray<IWbemClassObject*> apEventsToSend;
    INIT_TEMP_ARRAY(apEventsToSend, lNumObjects);
    if(apEventsToSend == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CTempArray<WBEM_REM_TARGETS> aTargetsToSend;
    INIT_TEMP_ARRAY(aTargetsToSend, lNumObjects);
    if(aTargetsToSend == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    int lNumToSend = 0;

    // Make sure the array gets cleaned up.
	CDeleteTargetsArray deleteMe(aTargetsToSend, &lNumToSend);
	
	// 
    // Iterate over events supplied and move those that need to be delivered
    // into delivery arrays
    //

    CFilterProxyManager* pManager = NULL;
    {
        //
        // We could choose a smaller window, but I am betting that the cost of
        // entering and exiting the cs many times will outweigh the benefits
        // of slightly smaller windows
        //

        CInCritSec ics(&m_cs);
    
        for(long i = 0; i < lNumObjects; i++)
        {        
            //
            // Check overall validity
            //
            
            if( apObjects[i] == NULL )
            {
                ERRORTRACE((LOG_ESS, "Event provider returned a NULL event!\n"));
                return WBEM_E_INVALID_PARAMETER;
            }
    
            CWbemObject *pObj = (CWbemObject*)(IWbemClassObject*)apObjects[i];
            
            if( pObj->IsObjectInstance() != WBEM_S_NO_ERROR )
            {
                ERRORTRACE((LOG_ESS, "CLASS object received from event provider!\n"));
                return WBEM_E_INVALID_PARAMETER;
            }

            //
            // Run the event through the filter
            //
        
            CSortedArray aTrues;
            
            hres = FilterEvent( pObj, aTrues );

            if ( hres == WBEM_S_FALSE )
            {
                ;
            }
            else if ( hres == WBEM_S_NO_ERROR )
            {
                _DBG_ASSERT( aTrues.Size() > 0 );

                //
                // Delivery is required --- add this event to the list
                //
    
                SetGenerationTime(pObj);
        
                apEventsToSend[lNumToSend] = pObj;

                if(!TempSetTargets(aTargetsToSend + lNumToSend, &aTrues))
                    return WBEM_E_OUT_OF_MEMORY;
            
                lNumToSend++;
            }
            else
            {
                return hres;
            }
        }
    
        //
        // If any events need to be delivered, get the delivery pointer
        //

        if(lNumToSend > 0)
        {
            pManager = m_pManager;
            if(pManager)
                pManager->AddRef();
            else
                return WBEM_S_FALSE;
        }
    }
        
    CReleaseMe rm1(pManager);

    //
    // If any events need to be delivered, deliver
    //

    if(lNumToSend > 0)
    {
        hres = pManager->DeliverEvent(lNumToSend, apEventsToSend, 
                                            aTargetsToSend,
                                            lSDLength, pSD);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter stub failed to process an event: "
                    "error code %X\n", hres));
        }

        return hres;
    }

    return WBEM_S_FALSE;
}

HRESULT STDMETHODCALLTYPE CFilterProxy::Indicate(long lNumObjects, 
                                        IWbemClassObject** apObjects)
{
    return IndicateWithSD(lNumObjects, (IUnknown**)apObjects, 
                            m_lSDLength, m_pSD);
}

HRESULT STDMETHODCALLTYPE CFilterProxy::SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj)
{
    return m_pManager->SetStatus(lFlags, hResult, strResult, pErrorObj);
}

STDMETHODIMP CFilterProxy::IndicateWithSD(long lNumObjects,
                IUnknown** apObjects, long lSDLength, BYTE* pSD)
{
    if(lNumObjects <= 0 || apObjects == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(pSD == NULL)
    {
        //
        // Use proxy defaults
        //
    
        lSDLength = m_lSDLength;
        pSD = m_pSD;
    }

    try
    {
        //
        // Special-case single event
        //

        if(lNumObjects == 1)
            return ProcessOne(*apObjects, lSDLength, pSD);
        else 
            return ProcessMany(lNumObjects, apObjects, lSDLength, pSD);

    }
    catch(...)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}
    

STDMETHODIMP CFilterProxy::IsActive()
{
    CInCritSec ics(&m_cs);

    return (m_Filter.IsFalse()?WBEM_S_FALSE:WBEM_S_NO_ERROR);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxy::SetSinkSecurity(
                long lSDLength,
                BYTE* pSD)
{
    CInCritSec ics(&m_cs);

    //
    // Check for validity
    //

    if(lSDLength < 0)
        return WBEM_E_INVALID_PARAMETER;

    if(lSDLength > 0)
    {
        SECURITY_DESCRIPTOR* pDesc = (SECURITY_DESCRIPTOR*)pSD;
        if(!IsValidSecurityDescriptor(pDesc))
            return WBEM_E_INVALID_PARAMETER;
    
        if(pDesc->Owner == NULL || pDesc->Group == NULL)
            return WBEM_E_INVALID_PARAMETER;
    
        if(GetSecurityDescriptorLength(pSD) != (DWORD)lSDLength)
            return WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        if(pSD != NULL)
            return WBEM_E_INVALID_PARAMETER;
    }
        
    //
    // Store the SD in the proxy
    //

    if(m_pSD && m_pSD != &mstatic_EmptySD)
        delete [] m_pSD;

    if(lSDLength)
    {
        m_pSD = new BYTE[lSDLength];
        if(m_pSD == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    
        memcpy(m_pSD, pSD, lSDLength);
    }
    else
    {
        //
        // Cannot let m_pSD be NULL 
        //
        m_pSD = &mstatic_EmptySD;
    }
    m_lSDLength = lSDLength;

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxy::GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink)
{
    return m_pManager->GetRestrictedSink(lNumQueries, awszQueries, 
                                                pCallback, ppSink);
}

STDMETHODIMP CFilterProxy::SetBatchingParameters(
    LONG lFlags,
    DWORD dwMaxBufferSize,
    DWORD dwMaxSendLatency)
{
    HRESULT    hr = S_OK;
    CInCritSec ics(&m_cs);

    switch(lFlags)
    {
	    // TODO: WBEM_FLAG_BATCH_IF_NEEDED currently works the same as
        // WBEM_FLAG_MUST_NOT_BATCH.  At some point this needs allow 
        // subscriptions to determine the batching behavior.
        case WBEM_FLAG_BATCH_IF_NEEDED:
	    case WBEM_FLAG_MUST_NOT_BATCH:
            m_typeBatch = (WBEM_BATCH_TYPE) lFlags;
            m_pManager->RemoveProxyLatency(this);
            m_bBatching = FALSE;
            break;

	    case WBEM_FLAG_MUST_BATCH:
            m_typeBatch = (WBEM_BATCH_TYPE) lFlags;
            m_dwMaxSendLatency = dwMaxSendLatency;
            m_dwMaxBufferSize = dwMaxBufferSize;
            m_dwLastSentStamp = m_pManager->GetLastSentStamp();
            hr = m_pManager->SetProxyLatency(this, dwMaxSendLatency);
            m_bBatching = TRUE;
            break;

        default:
            hr = WBEM_E_INVALID_PARAMETER;
            break;
    }

    return hr;
}

// Assumes pMainProxy is locked
HRESULT CFilterProxy::TransferFiltersFromMain(CFilterProxy* pMain)
{
    HRESULT hres;

    //
    // Move all the normal filters
    //

    try
    {
        m_Filter = pMain->m_Filter;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
   
    if ( m_bUtilizeGuarantee )
    {
        // Utilize source definition
        // =========================
	
        CContextMetaData MetaData(m_pMetaData, NULL);
        hres = m_Filter.UtilizeGuarantee(m_SourceDefinition, &MetaData);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter proxy unable to utilize guarantee for"
            " a new proxy; error code: %X\n", hres));
            return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxy::GetUnmarshalClass(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        CLSID* pClsid)
{
    return m_pManager->GetUnmarshalClass(riid, pv, dwDestContext, pvReserved,
                        mshlFlags, pClsid);
}

STDMETHODIMP CFilterProxy::GetMarshalSizeMax(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        ULONG* plSize)
{
    return m_pManager->GetMarshalSizeMax(riid, pv, dwDestContext, pvReserved,
                        mshlFlags, plSize);
}

STDMETHODIMP CFilterProxy::MarshalInterface(IStream* pStream, REFIID riid, 
                        void* pv, DWORD dwDestContext, void* pvReserved, 
                        DWORD mshlFlags)
{
    return m_pManager->MarshalInterface(pStream, riid, pv, dwDestContext, 
                        pvReserved, mshlFlags);
}

/////////////////////////////////////////////////////////////////////////////
// CEventBatch

#define INIT_SIZE   32
#define GROW_SIZE   32

CEventBatch::CEventBatch() :
    m_ppObjs(NULL),
    m_pTargets(NULL),
    m_nItems(0),
    m_dwSize(0)
{
    m_ppObjs = new IWbemClassObject*[INIT_SIZE];   
    if (!m_ppObjs)
        throw CX_MemoryException();

    m_pTargets = new WBEM_REM_TARGETS[INIT_SIZE];
    if (!m_pTargets)
        throw CX_MemoryException();

    m_dwSize = INIT_SIZE;
}

CEventBatch::~CEventBatch()
{
    RemoveAll();

    if (m_ppObjs)
        delete [] m_ppObjs;

    if (m_pTargets)
        delete [] m_pTargets;
}

BOOL CEventBatch::EnsureAdditionalSize(DWORD nAdditionalNeeded)
{
    if (m_nItems + nAdditionalNeeded > m_dwSize)
    {
        DWORD            nNewSize = m_nItems + nAdditionalNeeded + GROW_SIZE;
        IWbemClassObject **ppNewObjs;
        WBEM_REM_TARGETS *pNewTargets;

        ppNewObjs = new IWbemClassObject*[nNewSize];
        if (!ppNewObjs)
            throw CX_MemoryException();

        pNewTargets = new WBEM_REM_TARGETS[nNewSize];
        if (!pNewTargets)
        {
            delete [] ppNewObjs;
            throw CX_MemoryException();
        }

        // Copy the data from the old pointers to the new pointers.
        memcpy(ppNewObjs, m_ppObjs, m_nItems * sizeof(ppNewObjs[0]));
        memcpy(pNewTargets, m_pTargets, m_nItems * sizeof(pNewTargets[0]));

        // Get rid of the old pointers.
        delete [] m_ppObjs;
        delete [] m_pTargets;

        // Set our member pointers with the new pointers.
        m_ppObjs = ppNewObjs;
        m_pTargets = pNewTargets;

        m_dwSize = nNewSize;
    }

    return TRUE;
}

BOOL CEventBatch::AddEvent(IWbemClassObject *pObj, CSortedArray *pTrues)
{
    BOOL bRet = FALSE;

    if (EnsureAdditionalSize(1))
    {
        if (SUCCEEDED(pObj->Clone(&m_ppObjs[m_nItems])))
        {
            if(!TempSetTargets(m_pTargets + m_nItems, pTrues))
                return FALSE;

            m_nItems++;

            bRet = TRUE;
        }
    }

    return bRet;
}

void CEventBatch::RemoveAll()
{
    for (DWORD i = 0; i < m_nItems; i++)
    {
        m_ppObjs[i]->Release();
        
        TempClearTargets(m_pTargets + i);
    }

    m_nItems = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\evaltree.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DUMBNODE.H

Abstract:

    WBEM Evaluation Tree

History:

--*/

template<class TPropType>
CFullCompareNode<TPropType>::CFullCompareNode(
                                    const CFullCompareNode<TPropType>& Other,
                                    BOOL bChildren)
    : CPropertyNode(Other, FALSE), // copy without children
      m_pRightMost(NULL)  
{
    if(bChildren)
    {
        // Need to copy the children.  Iterate over our test point array
        // =============================================================

        for(TConstTestPointIterator it = Other.m_aTestPoints.Begin(); 
                it != Other.m_aTestPoints.End(); it++)
        {
            CTestPoint<TPropType> NewPoint;
            NewPoint.m_Test = it->m_Test;

            // Make copies of the child branches
            // =================================

            NewPoint.m_pLeftOf = CEvalNode::CloneNode(it->m_pLeftOf);
            NewPoint.m_pAt = CEvalNode::CloneNode(it->m_pAt);

            // Add the test point to the array
            // ===============================

            m_aTestPoints.Append(NewPoint);
        }

        // Copy right-most
        // ===============

        m_pRightMost = CEvalNode::CloneNode(Other.m_pRightMost);
    }
}


template<class TPropType>
HRESULT CFullCompareNode<TPropType>::SetTest(VARIANT& v)
{
    try
    {
        CTokenValue Value;
        if(!Value.SetVariant(v))
            return WBEM_E_OUT_OF_MEMORY;
        m_aTestPoints.Begin()->m_Test = Value;
    
        return WBEM_S_NO_ERROR;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}
    
template<class TPropType>
CFullCompareNode<TPropType>::~CFullCompareNode()
{
    delete m_pRightMost;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::InsertMatching(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications, bool bDeleteArg2)
{
    //=====================================================================
    // 'it' points to the node in 'this' that has the same value as the one 
    // 'it2' points to in pArg2. 'itLast' points to the last unhandled node
    // in 'this' (looking left from 'it').
    //=====================================================================

    CEvalNode* pNew;
    HRESULT hres;

    // Merge our at-values
    // ===================

    hres = CEvalTree::Combine(it->m_pAt, it2->m_pAt, nOp, pNamespace, 
                Implications, true, bDeleteArg2, &pNew);
    if(FAILED(hres))
        return hres;

    if(bDeleteArg2)
        it2->m_pAt = NULL;

    it->m_pAt = pNew;

    // Merge our left-ofs
    // ==================

    hres = CEvalTree::Combine(it->m_pLeftOf, it2->m_pLeftOf, nOp, pNamespace, 
                Implications, true, bDeleteArg2, &pNew);
    if(FAILED(hres))
        return hres;

    if(bDeleteArg2)
        it2->m_pLeftOf = NULL;

    it->m_pLeftOf = pNew;

    //
    // At this point, we need to merge the LeftOf of it2 with all the branches
    // in this that are between the current insertion point and the previous
    // insertion point.  However, we do not need to do this if it2's LeftOf node
    // is a noop for this operation (e.g. TRUE for an AND)
    //

    if(it != itLast && !CEvalNode::IsNoop(it2->m_pLeftOf, nOp))
    {
        hres = CombineWithBranchesToLeft(it, itLast, it2->m_pLeftOf, nOp,
                    pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    }

    // Move first unhandled iterator to the node beyond itLast
    // =======================================================

    itLast = it;
    itLast++;

    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::InsertLess(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications, bool bDeleteArg2)
{
    //
    // 'it' points to the node in 'this' that has a slightly larger value than
    // the one 'it2' points to in pArg2. 'itLast' points to the last unhandled 
    // node in 'this' (looking left from 'it').
    //

    HRESULT hres;

    // Check if 'it' is point to the end of the list --- in that case it's
    // "left-of" is actually right-most
    // ===================================================================

    CEvalNode* pItLeft = NULL;
    if(it == m_aTestPoints.End())
        pItLeft = m_pRightMost;
    else
        pItLeft = it->m_pLeftOf;
    

    // First of all, we need to insert the node at it2 into 'this' list, just 
    // before 'it'.
    // ======================================================================

    CTestPoint<TPropType> NewNode = *it2;
    
    // It's at branch is the combination of our left and arg2 at
    // =========================================================

    hres = CEvalTree::Combine(pItLeft, it2->m_pAt, nOp, pNamespace, 
                Implications, false, bDeleteArg2, &NewNode.m_pAt);
    if(FAILED(hres))
        return hres;

    if(bDeleteArg2)
        it2->m_pAt = NULL;

    // It's left-of branch is the combination of our left and arg2 left
    // ================================================================

    // We can reuse it2->Left iff every node left of 'it' in 'this' has been 
    // handled
    // =====================================================================

    bool bDeleteIt2Left = (bDeleteArg2 && (it == itLast));

    hres = CEvalTree::Combine(pItLeft, it2->m_pLeftOf, nOp, pNamespace, 
                Implications, false, bDeleteIt2Left, &NewNode.m_pLeftOf);
    if(FAILED(hres))
        return hres;

    if(bDeleteIt2Left)
        it2->m_pLeftOf = NULL;

    // IMPORTANT: Once we insert the new node, all the iterators into 'this'
    // will be invalidated --- that includes it and itLast. So, we need to do
    // out left-walk before we actually insert.
    // ===================================================

    //
    // At this point, we need to merge the LeftOf of it2 with all the branches
    // in this that are between the current insertion point and the previous
    // insertion point.  However, we do not need to do this if it2's LeftOf node
    // is a noop for this operation (e.g. TRUE for an AND)
    //

    if(it != itLast && !CEvalNode::IsNoop(it2->m_pLeftOf, nOp))
    {
        //
        // Note to self: bDeleteIt2Left could not have been true, so 
        // it2->m_pLeftOf could not have been deleted.  We are OK here
        //

        hres = CombineWithBranchesToLeft(it, itLast, it2->m_pLeftOf, nOp,
                    pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    }

    // Now we can actually insert
    // ==========================

    TTestPointIterator itNew = m_aTestPoints.Insert(it, NewNode);

    // Move first unhandled iterator to the node just right of insertion
    // =================================================================

    itLast = itNew;
    itLast++;

    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::CombineWithBranchesToLeft(
            TTestPointIterator itWalk, TTestPointIterator itLast,
            CEvalNode* pArg2,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications)
{
    HRESULT hres;
    CEvalNode* pNew = NULL;

    // Walk left until we reach the first unhandled node
    // =================================================

    do
    {
        if(itWalk == m_aTestPoints.Begin())
            break;

        itWalk--;

        // Merge at-value
        // ==============
    
        hres = CEvalTree::Combine(itWalk->m_pAt, pArg2, nOp, 
                    pNamespace, Implications, true, false, &pNew);
        if(FAILED(hres))
            return hres;
    
        itWalk->m_pAt = pNew;
    
        // Merge left-ofs
        // ==============
    
        hres = CEvalTree::Combine(itWalk->m_pLeftOf, pArg2, nOp, 
                    pNamespace, Implications, true, false, &pNew);
        if(FAILED(hres))
            return hres;
    
        itWalk->m_pLeftOf = pNew;
    }
    while(itWalk != itLast);

    return WBEM_S_NO_ERROR;
}
                

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::CombineBranchesWith(
            CBranchingNode* pRawArg2, int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications, 
            bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes)
{
    HRESULT hres;
    CFullCompareNode<TPropType>* pArg2 = (CFullCompareNode<TPropType>*)pRawArg2;
    *ppRes = NULL;

    // Check which one is larger
    // =========================

    if(m_aTestPoints.GetSize() < pArg2->m_aTestPoints.GetSize())
    {
        return pArg2->CombineBranchesWith(this, FlipEvalOp(nOp), pNamespace,
                            Implications, bDeleteArg2, bDeleteThis, ppRes);
    }

    if(!bDeleteThis)
    {
        // Damn. Clone. 
        // ============

        return ((CFullCompareNode<TPropType>*)Clone())->CombineBranchesWith(
            pRawArg2, nOp, pNamespace, Implications, true, // reuse clone!
            bDeleteArg2, ppRes);
    }
    
    CEvalNode* pNew = NULL;

    TTestPointIterator itLast = m_aTestPoints.Begin();
    
    // 
    // itLast points to the left-most location in our list of test points that 
    // we have not considered yet --- it is guaranteed that any further 
    // insertions from the second list will occur after this point
    //

    //
    // it2, on the other hand, iterates simply over the second list of test 
    // points, inserting each one into the combined list one by one
    //

    for(TTestPointIterator it2 = pArg2->m_aTestPoints.Begin();
        it2 != pArg2->m_aTestPoints.End(); it2++)
    {
        
        //
        // First, we search for the location in our list of test points of the
        // insertion point for the value of it2.  bMatch is set to true if the
        // same test point exists, and false if it does not and the returned
        // iterator points to the element to the right of the insertion point.
        //

        TTestPointIterator it;
        bool bMatch = m_aTestPoints.Find(it2->m_Test, &it);
        if(bMatch)
        {
            hres = InsertMatching(it, it2, itLast, nOp, pNamespace,
                        Implications, bDeleteArg2);
        }
        else
        {
            hres = InsertLess(it, it2, itLast, nOp, pNamespace,
                        Implications, bDeleteArg2);
            // invalidates 'it'!
        }

        if(FAILED(hres))
            return hres;
    }
        
    //
    // At this point, we need to merge the RightMost of arg2 with all the 
    // branches in this that come after the last insertion point.
    // However, we do not need to do this if arg2's RightMost node
    // is a noop for this operation (e.g. TRUE for an AND)
    //

    if(itLast != m_aTestPoints.End() && 
        !CEvalNode::IsNoop(pArg2->m_pRightMost, nOp))
    {
        hres = CombineWithBranchesToLeft(m_aTestPoints.End(), itLast, 
                    pArg2->m_pRightMost, nOp, pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    }

    hres = CEvalTree::Combine(m_pRightMost, pArg2->m_pRightMost, nOp, 
                    pNamespace, Implications, true, bDeleteArg2, 
                    &pNew);
    if(FAILED(hres))
        return hres;

    m_pRightMost = pNew;

    if(bDeleteArg2)
        pArg2->m_pRightMost = NULL;

    // Merge the nulls
    // ===============

    CEvalTree::Combine(m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                        pNamespace, Implications, true, bDeleteArg2, 
                        &pNew);
    m_pNullBranch = pNew;

    // Reset them in deleted versions
    // ==============================

    if(bDeleteArg2)
        pArg2->m_pNullBranch = NULL;

    // Delete what needs deleting
    // ==========================

    if(bDeleteArg2)
        delete pArg2;

    *ppRes = this;
    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = Clone();
    if(*ppRes == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFullCompareNode<TPropType>* pNew = (CFullCompareNode<TPropType>*)*ppRes;

    try
    {
        CImplicationList Implications(OrigImplications);
        hres = pNew->AdjustCompile(pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    
        CEvalNode* pNewBranch = NULL;
    
        for(TTestPointIterator it = pNew->m_aTestPoints.Begin(); 
            it != pNew->m_aTestPoints.End(); it++)
        {
            // Combine our At-branch with pArg2
            // ================================
    
            hres = CEvalTree::Combine(it->m_pAt, pArg2, nOp, pNamespace, 
                Implications, true, false, &pNewBranch);
            if(FAILED(hres))
            {
                delete pNew;
                return hres;
            }
            it->m_pAt = pNewBranch;
    
            // Now do the same for our left-of branch
            // ======================================
    
            hres = CEvalTree::Combine(it->m_pLeftOf, pArg2, nOp, pNamespace, 
                Implications, true, false, &pNewBranch);
            if(FAILED(hres))
            {
                delete pNew;
                return hres;
            }
            it->m_pLeftOf = pNewBranch;
        }
    
        hres = CEvalTree::Combine(pNew->m_pRightMost, pArg2, nOp, pNamespace, 
            Implications, true, false, &pNewBranch);
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }
    
        pNew->m_pRightMost = pNewBranch;
    
        hres = CEvalTree::Combine(pNew->m_pNullBranch, pArg2, nOp, pNamespace, 
            Implications, true, false, &pNewBranch);
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }
    
        pNew->m_pNullBranch = pNewBranch;
    
        if(bDeleteThis)
            delete this;
        if(bDeleteArg2)
            delete pArg2;
        return WBEM_S_NO_ERROR;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

template<class TPropType>
int CFullCompareNode<TPropType>::SubCompare(CEvalNode* pRawOther)
{
    CFullCompareNode<TPropType>* pOther = 
        (CFullCompareNode<TPropType>*)pRawOther;

    // Compare handles
    // ===============

    int nCompare;
    nCompare = m_lPropHandle - pOther->m_lPropHandle;
    if(nCompare)
        return nCompare;

    // Compare array sizes
    // ===================

    nCompare = m_aTestPoints.GetSize() - pOther->m_aTestPoints.GetSize();
    if(nCompare)
        return nCompare;

    // Compare all points
    // ==================

    TTestPointIterator it;
    TTestPointIterator itOther;
    for(it = m_aTestPoints.Begin(), itOther = pOther->m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++, itOther++)
    {
        if(it->m_Test < itOther->m_Test)
            return -1;
        else if(it->m_Test > itOther->m_Test)
            return 1;
    }

    // Compare all branches
    // ====================

    for(it = m_aTestPoints.Begin(), itOther = pOther->m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++, itOther++)
    {
        nCompare = CEvalTree::Compare(it->m_pLeftOf, itOther->m_pLeftOf);
        if(nCompare)
            return nCompare;

        nCompare = CEvalTree::Compare(it->m_pAt, itOther->m_pAt);
        if(nCompare)
            return nCompare;
    }

    return 0;
}
    
template<class TPropType>
HRESULT CFullCompareNode<TPropType>::OptimizeSelf()
{
    TTestPointIterator it = m_aTestPoints.Begin();
    while(it != m_aTestPoints.End())
    {
        TTestPointIterator itPrev = it;
        it++;

        CEvalNode** ppLeft = &itPrev->m_pLeftOf;
        CEvalNode** ppMiddle = &itPrev->m_pAt;
        CEvalNode** ppRight = it != m_aTestPoints.End() ? 
                                       &it->m_pLeftOf : &m_pRightMost;

        //
        // compare all three test point nodes.  If all the same then we 
        // can optimize the test point out.  Also, two nodes are treated 
        // the same if at least one of them is the invalid node.
        // 

        if ( !CEvalNode::IsInvalid( *ppLeft ) )
        {
            if ( !CEvalNode::IsInvalid( *ppMiddle ) )
            {     
                if( CEvalTree::Compare( *ppLeft, *ppMiddle ) != 0 )
                {
                    continue;
                }
            }
            else
            {
                ppMiddle = ppLeft;
            }
        }

        if ( !CEvalNode::IsInvalid( *ppMiddle ) )
        {
            if ( !CEvalNode::IsInvalid( *ppRight ) )
            {       
                if( CEvalTree::Compare( *ppMiddle, *ppRight ) != 0 )
                {
                    continue;
                }    
            }
                
            //
            // we're going to optimize the test point out, but first 
            // make sure to set rightmost to point to the middle branch. 
            // Make sure to unhook appropriate pointers before removing 
            // the test node, since it owns the memory for them.
            //
 
            delete *ppRight;
            *ppRight = *ppMiddle;
            *ppMiddle = NULL;
        }

        //
        // optimize the test point out.
        // 
        it = m_aTestPoints.Remove( itPrev );
    }

    return S_OK;
}

template<class TPropType>
DWORD CFullCompareNode<TPropType>::ApplyPredicate(CLeafPredicate* pPred)
{
    DWORD dwRes;
    for(TTestPointIterator it = m_aTestPoints.Begin();
        it != m_aTestPoints.End(); it++)
    {
        if (it->m_pLeftOf)
        {
            dwRes = it->m_pLeftOf->ApplyPredicate(pPred);
            if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
            {
                delete it->m_pLeftOf;
                it->m_pLeftOf = NULL;
            }
            else if ( dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE )
            {
                delete it->m_pLeftOf;
                it->m_pLeftOf = CValueNode::GetStandardInvalid();
            }
        }

        if (it->m_pAt)
        {
            dwRes = it->m_pAt->ApplyPredicate(pPred);
            if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
            {
                delete it->m_pAt;
                it->m_pAt = NULL;
            }
            else if ( dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE )
            {
                delete it->m_pAt;
                it->m_pAt = CValueNode::GetStandardInvalid();
            }
        }
    }

    if (m_pRightMost)
    {
        dwRes = m_pRightMost->ApplyPredicate(pPred);
        if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
        {
            delete m_pRightMost;
            m_pRightMost = NULL;
        }
        else if ( dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE )
        {
            delete m_pRightMost;
            m_pRightMost = CValueNode::GetStandardInvalid();
        }
    }

    return CBranchingNode::ApplyPredicate(pPred);
}

        
    
template<class TPropType>
HRESULT CFullCompareNode<TPropType>::Optimize(CContextMetaData* pNamespace, 
                                                CEvalNode** ppNew)
{
    CEvalNode* pNew = NULL;
    HRESULT hres;

    // Optimize all branches
    // =====================

    for(TTestPointIterator it = m_aTestPoints.Begin();
        it != m_aTestPoints.End(); it++)
    {
        if (it->m_pLeftOf)
        {
            hres = it->m_pLeftOf->Optimize(pNamespace, &pNew);
            if(FAILED(hres))
                return hres;

            if(pNew != it->m_pLeftOf)
            {
                delete it->m_pLeftOf;
                it->m_pLeftOf = pNew;
            }
        }

        if (it->m_pAt)
        {
            hres = it->m_pAt->Optimize(pNamespace, &pNew);

            if(FAILED(hres))
                return hres;

            if(pNew != it->m_pAt)
            {
                delete it->m_pAt;
                it->m_pAt = pNew;
            }
        }
    }

    if (m_pRightMost)
    {
        hres = m_pRightMost->Optimize(pNamespace, &pNew);
        if(FAILED(hres))
            return hres;

        if(pNew != m_pRightMost)
        {
            delete m_pRightMost;
            m_pRightMost = pNew;
        }
    }

    if (m_pNullBranch)
    {
        hres = m_pNullBranch->Optimize(pNamespace, &pNew);
   
        if(FAILED(hres))
            return hres;

        if(pNew != m_pNullBranch)
        {
            delete m_pNullBranch;
            m_pNullBranch = pNew;
        }
    }


    // Optimize ourselves
    // ==================

    hres = OptimizeSelf();
    if(FAILED(hres))
        return hres;
    
    *ppNew = this;

    //
    // Check if this node has become superflous
    // 

    if( m_aTestPoints.GetSize() == 0 )
    {
        if ( !CEvalNode::IsInvalid( m_pRightMost ) )
        {
            if ( !CEvalNode::IsInvalid( m_pNullBranch ) )
            {
                if ( CEvalTree::Compare(m_pNullBranch, m_pRightMost) == 0 ) 
                {
                    // 
                    // both the null and rightmost are the same.  Optimize 
                    // this node out and return the rightmost branch.
                    // 
                    *ppNew = m_pRightMost;

                    //
                    // Untie m_pRightMost (so it is not deleted when we are)
                    //
                    m_pRightMost = NULL;
                }
            }
            else if ( m_pRightMost == NULL )
            {
                //
                // the right branch is false and the null branch is invalid.  
                // Optimize this node to false.
                //                 
                *ppNew = NULL;
            }
        }
        else if ( m_pNullBranch == NULL )
        {
            //
            // the null branch is false and the rightmost is invalid.  
            // Optimize this node to false. 
            // 
            *ppNew = NULL;
        }
        else if ( CEvalNode::IsInvalid( m_pNullBranch ) )
        {       
            //
            // both are invalid, but we can't invalidate the whole node 
            // because we're not sure what we optimized out in the test
            // points, so just optimize this node to false.
            //
            *ppNew = NULL;
        }
    }

    return S_OK;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::SetNullTest(int nOperator)
{
    if(nOperator == QL1_OPERATOR_EQUALS)
    {
        m_pRightMost = CValueNode::GetStandardFalse();

        CEvalNode* pNode = CValueNode::GetStandardTrue();
        if(pNode == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        SetNullBranch(pNode);
    }
    else if(nOperator == QL1_OPERATOR_NOTEQUALS)
    {
        m_pRightMost = CValueNode::GetStandardTrue();
        if(m_pRightMost == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        SetNullBranch(CValueNode::GetStandardFalse());
    }
    else
        return WBEM_E_INVALID_QUERY;

    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::SetOperator(int nOperator)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    #define GET_STD_TRUE CValueNode::GetStandardTrue()
    #define GET_STD_FALSE CValueNode::GetStandardFalse()

    #define SET_TRUE(NODE) { \
            NODE = GET_STD_TRUE; \
            if(NODE == NULL) { \
                hr = WBEM_E_OUT_OF_MEMORY; \
                break; } }

    #define SET_FALSE(NODE) {NODE = GET_STD_FALSE;}

    CTestPoint<TPropType> NewNode;
    
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        SET_FALSE(NewNode.m_pLeftOf);
        SET_TRUE(NewNode.m_pAt);
        SET_FALSE(m_pRightMost);
        break;

    case QL1_OPERATOR_NOTEQUALS:
        SET_TRUE(NewNode.m_pLeftOf);
        SET_FALSE(NewNode.m_pAt);
        SET_TRUE(m_pRightMost);
        break;

    case QL1_OPERATOR_LESS:
        SET_TRUE(NewNode.m_pLeftOf);
        SET_FALSE(NewNode.m_pAt);
        SET_FALSE(m_pRightMost);
        break;
        
    case QL1_OPERATOR_GREATER:
        SET_FALSE(NewNode.m_pLeftOf);
        SET_FALSE(NewNode.m_pAt);
        SET_TRUE(m_pRightMost);
        break;
    
    case QL1_OPERATOR_LESSOREQUALS:
        SET_TRUE(NewNode.m_pLeftOf);
        SET_TRUE(NewNode.m_pAt);
        SET_FALSE(m_pRightMost);
        break;

    case QL1_OPERATOR_GREATEROREQUALS:
        SET_FALSE(NewNode.m_pLeftOf);
        SET_TRUE(NewNode.m_pAt);
        SET_TRUE(m_pRightMost);
        break;
    default:
        hr = WBEM_E_CRITICAL_ERROR;
    }

    if ( SUCCEEDED(hr) )
    {       
        m_aTestPoints.Append(NewNode);
    }
    else
    {        
        NewNode.Destruct();
    }

    return hr;
}


//******************************************************************************
//******************************************************************************
//                  SCALAR PROPERTY NODE
//******************************************************************************
//******************************************************************************

template<class TPropType>
HRESULT CScalarPropNode<TPropType>::Evaluate(CObjectInfo& ObjInfo, 
                                                INTERNAL CEvalNode** ppNext)
{
    HRESULT hres;
    _IWmiObject* pObj;
    hres = GetContainerObject(ObjInfo, &pObj);
    if(FAILED(hres)) return hres;

    // Get the property from the object
    // ================================

    long lRead;
    TPropType Value;
    hres = pObj->ReadPropertyValue(m_lPropHandle, sizeof(TPropType), 
                                            &lRead, (BYTE*)&Value);
    if( S_OK != hres )
    {
        if(hres == WBEM_S_FALSE)
        {
            *ppNext = m_pNullBranch;
            return WBEM_S_NO_ERROR;
        }
        else
        {
            return hres;
        }
    }
    
    // Search for the value
    // ====================

    TTestPointIterator it;
    bool bMatch = m_aTestPoints.Find(Value, &it);
    if(bMatch)
        *ppNext = it->m_pAt;
    else if(it == m_aTestPoints.End())
        *ppNext = m_pRightMost;
    else
        *ppNext = it->m_pLeftOf;
        
    return WBEM_S_NO_ERROR;
}

template<class TPropType>
void CScalarPropNode<TPropType>::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);
    PrintOffset(f, nOffset);
    fprintf(f, "LastPropName = (0x%x), size=%d\n", 
        m_lPropHandle, sizeof(TPropType));

   TConstTestPointIterator it;
   for(it = m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++)
    {
        PrintOffset(f, nOffset);
        if (it != m_aTestPoints.Begin())
        {
            TConstTestPointIterator itPrev(it);
            itPrev--;
            fprintf(f, "%d < ", (int)(itPrev->m_Test));
        }
        fprintf(f, "X < %d\n", (int)(it->m_Test));
        DumpNode(f, nOffset+1, it->m_pLeftOf);

        PrintOffset(f, nOffset);
        fprintf(f, "X = %d\n", (int)(it->m_Test));
        DumpNode(f, nOffset+1, it->m_pAt);
    }    
    
    PrintOffset(f, nOffset);
    if (it != m_aTestPoints.Begin())
    {
        TConstTestPointIterator itPrev(it);
        itPrev--;
        fprintf(f, "X > %d\n", (int)(itPrev->m_Test));
    }
    else
        fprintf(f, "ANY\n");
    DumpNode(f, nOffset+1, m_pRightMost);


    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\groupsforuser.h ===
//****************************************************************************
//
//  Copyright (C) 1999 Microsoft Corporation
//
//  GROUPSFORUSER.H
//
//****************************************************************************

#ifndef __Groups_For_User_Compiled__
#define __Groups_For_User_Compiled__

#include <authz.h>
#include "esscpol.h"
#include <NTSECAPI.H>

// you'll need to link to netapi32.lib for this to fly

// retireves access mask corresponding to permissions granted
// by dacl to account denoted by pSid
NTSTATUS ESSCLI_POLARITY GetAccessMask( PSID pSid, PACL pDacl, DWORD *pAccessMask );

// returns STATUS_SUCCESS if user is in group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
NTSTATUS ESSCLI_POLARITY IsUserInGroup( PSID pSidUser, PSID pSidGroup );
NTSTATUS ESSCLI_POLARITY IsUserAdministrator( PSID pSidUser );


#ifndef __AUTHZ_H__

#include <wbemcli.h>
#include <winntsec.h>
#include "esscpol.h"
#include <NTSECAPI.H>


// given a SID & server name
// will return all groups of which user is a member
// callers responsibility to HeapFree apSids & the memory to which they point.
// pdwCount points to dword to receive count of group sids returned.
// serverName may be NULL, in which case this function will look up 
// the sid on the local computer, and query the DC if required.
NTSTATUS ESSCLI_POLARITY EnumGroupsForUser( LPCWSTR userName, 
                                            LPCWSTR domainName, 
                                            LPCWSTR serverName, 
                                            PSID **apGroupSids, 
                                            DWORD *pdwCount );

// much the same as above except we are
// given user name, domain name & server name
// server name must not be NULL, it can, however
// be the name of the local computer
NTSTATUS ESSCLI_POLARITY EnumGroupsForUser( PSID pSid, 
                                            LPCWSTR serverName, 
                                            PSID **apGroupSids, 
                                            DWORD *pdwCount ); 

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\main.cpp ===
#include "precomp.h"
#include <wmiauthz.h>
#include <commain.h>
#include <clsfac.h>
#include "filtprox.h"
#include "wmiauthz.h"

class CEssProxyServer : public CComServer
{
protected:
	
    HRESULT Initialize()
    {
        AddClassInfo( CLSID_WbemFilterProxy,
            new CSimpleClassFactory<CFilterProxyManager>(GetLifeControl()), 
            __TEXT("Event filter marshaling proxy"), TRUE);
        AddClassInfo( CLSID_WbemTokenCache,
            new CSimpleClassFactory<CWmiAuthz>(GetLifeControl()), 
            __TEXT("Wbem Token Cache"), TRUE );
        
        return S_OK;
    }
    void Register()
    {
        // this is for WbemFilterProxyto be used as a marshaler nf NO_CUSTOM_MARSHAL is set
        HKEY hKey;
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
            TEXT("software\\classes\\CLSID\\{6c19be35-7500-11d1-ad94-00c04fd8fdff}\\")
            TEXT("Implemented Categories\\{00000003-0000-0000-C000-000000000046}"),
            &hKey))
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\groupsforuser.cpp ===
//****************************************************************************
//
//  Copyright (C) 1999 Microsoft Corporation
//
//  GROUPSFORUSER.CPP
//
//****************************************************************************

// This is done in the sources file: WIN32_WIN32_WINNT=0x0400
//#define _WIN32_WINNT 0x0400

#include "precomp.h"
#include <wbemcomn.h>
#include "wmiauthz.h"
#include "GroupsForUser.h"


//
// Store the error status of CWmiAuthzWrapper and CAdminSID class initialization.
// They are set to ERROR_INVALID_ACCESS error status initially.
//

static DWORD    g_dwWmiAuthzError = ERROR_INVALID_ACCESS;
static DWORD    g_dwAdminSIDError = ERROR_INVALID_ACCESS;


//
// Class definition of CWmiAuthzWrapper class.
// This class wraps CWmiAuthz class:
//  - It creates an instance of CWmiAuthz class in its 
//    constructor and deletes it in descrutor.  
//  - Sets g_dwWmiAuthzError global in case of error otherwise
//    sets it to 0 ( ERROR_SUCCESS )
//

class CWmiAuthzWrapper
{
    // Private member variables
    CWmiAuthz   *m_pWmiAuthz;

public:
    // Constructor 
    CWmiAuthzWrapper( )
    {
        m_pWmiAuthz = new CWmiAuthz( NULL );
        if ( NULL == m_pWmiAuthz )
        {
            g_dwWmiAuthzError = ERROR_OUTOFMEMORY;
        }
        else
        {
            m_pWmiAuthz->AddRef( );
            g_dwWmiAuthzError = ERROR_SUCCESS;
        }
    }

    // Destructor 
    ~CWmiAuthzWrapper( )
    {
        if ( m_pWmiAuthz )
        {
            m_pWmiAuthz->Release( );
        }
    }

    // Accessor method to CWmiClass instance
    CWmiAuthz * GetWmiAuthz( ) const
    {
        return m_pWmiAuthz;
    }

};


//
// Class definition of CAdminSID class.
// - Allocates Admin SID in its constructor and
//   frees it in destructor.
// - Sets g_dwAdminSIDError global in case of error otherwise
//    sets it to 0 ( ERROR_SUCCESS )
//

class CAdminSID
{
    PSID         m_pSIDAdmin;

public:
    // Constructor
    CAdminSID( )
    {
        //
        // Create a System Identifier for the Admin group.
        //

        SID_IDENTIFIER_AUTHORITY    SystemSidAuthority = SECURITY_NT_AUTHORITY;

        if ( FALSE == AllocateAndInitializeSid ( &SystemSidAuthority, 
                                                 2, 
                                                 SECURITY_BUILTIN_DOMAIN_RID, 
                                                 DOMAIN_ALIAS_RID_ADMINS,
                                                 0, 0, 0, 0, 0, 0, 
                                                 &m_pSIDAdmin ) )
        {
            g_dwAdminSIDError = GetLastError( );
            ERRORTRACE( ( LOG_ESS, "AllocateAndInitializeSid failed, error 0x%X\n", g_dwAdminSIDError ) );
            m_pSIDAdmin = NULL;
        }
        else
        {
            g_dwAdminSIDError = ERROR_SUCCESS;
        }
    }

    // Destructor
    ~CAdminSID( )
    {
        if ( m_pSIDAdmin )
        {
            FreeSid ( m_pSIDAdmin );
        }
    }

    // Accessor method to Admin SID
    PSID GetAdminSID( ) const
    {
        return m_pSIDAdmin;
    }
};


//
// Static glabal declaration of CWmiAuthsWrapper class.
//

static CWmiAuthzWrapper g_wmiAuthzWrapper;


//
// Static glabal declaration of CAdminSID class.
//

static CAdminSID g_adminSID;


//
// Returns SD and DACL with a given Access Mask and SID
//

DWORD GetSDAndACLFromSID( DWORD dwAccessMask, PSID pSID, 
                          BYTE **ppNewDACL, 
                          BYTE **ppNewSD )
{
    DWORD   dwError = 0,
            dwDACLLength = sizeof ( ACL ) + 
                           sizeof ( ACCESS_ALLOWED_ACE ) - 
                           sizeof ( DWORD ) + 
                           GetLengthSid ( pSID );
    // 
    // Get memory needed for new DACL
    //

    *ppNewDACL = new BYTE[ dwDACLLength ];
    if ( !*ppNewDACL )
    {
        *ppNewSD = NULL;
        return E_OUTOFMEMORY;
    }

    //
    // Get memory for new SD
    //

    *ppNewSD = new BYTE[ sizeof( SECURITY_DESCRIPTOR ) ];
    if ( !*ppNewSD )
    {
        delete[] *ppNewDACL;
        *ppNewDACL = NULL;
        return E_OUTOFMEMORY;
    }

    do
    {
        //
        // Initialize new SD
        //

        if ( FALSE == InitializeSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                     SECURITY_DESCRIPTOR_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Initialize new DACL
        //

        if ( FALSE == InitializeAcl ( ( PACL )*ppNewDACL, 
                                      dwDACLLength, 
                                      ACL_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Get DACL using Access Mask and SID
        //

        if ( FALSE == AddAccessAllowedAce ( ( PACL )*ppNewDACL, 
                                            ACL_REVISION, 
                                            dwAccessMask, 
                                            pSID ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidAcl ( ( PACL )*ppNewDACL ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set DACL to the SD
        //

        if ( FALSE == SetSecurityDescriptorDacl ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                  TRUE, ( PACL )*ppNewDACL, 
                                                  FALSE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Group to the SD
        //

        if ( FALSE == SetSecurityDescriptorGroup ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   pSID, 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Owner to the SD
        //

        if ( FALSE == SetSecurityDescriptorOwner ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   pSID, 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD ) )
        {
            dwError = GetLastError( );
            break;
        }
    }
    while( FALSE );

    //
    // Delete the stuff in case of error
    //

    if ( dwError )
    {
        delete[] *ppNewDACL;
        delete[] *ppNewSD;
        *ppNewDACL = NULL;
        *ppNewSD = NULL;
    }

    return dwError;
}


//
// Returns SD  with a given DACL
//

DWORD GetSDFromACL( PACL pNewDACL, BYTE **ppNewSD )
{
    //
    // Return if error occured during initialization of Admin SID
    // in CAdminSID static global class declaration;
    //

    _DBG_ASSERT( !g_dwAdminSIDError );

    if ( g_dwAdminSIDError )
    {
        *ppNewSD = NULL;
        return g_dwAdminSIDError;
    }

    //
    // Get memory for new SD
    //

    *ppNewSD = new BYTE[ sizeof( SECURITY_DESCRIPTOR ) ];
    if ( !*ppNewSD )
    {
        return E_OUTOFMEMORY;
    }

    DWORD   dwError = 0;

    do
    {
        //
        // Initialize new SD
        //

        if ( FALSE == InitializeSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                     SECURITY_DESCRIPTOR_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set DACL to the SD
        //

        if ( FALSE == SetSecurityDescriptorDacl ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                  TRUE, pNewDACL, FALSE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Group to the SD with Admin SID
        //

        if ( FALSE == SetSecurityDescriptorGroup ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   g_adminSID.GetAdminSID( ), 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Owner to the SD
        //

        if ( FALSE == SetSecurityDescriptorOwner ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   g_adminSID.GetAdminSID( ), 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }
        
        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD ) )
        {
            dwError = GetLastError( );
            break;
        }
    }
    while( FALSE );

    //
    // Delete the security descriptor in case of error
    //

    if ( dwError )
    {
        delete[] *ppNewSD;
        *ppNewSD = NULL;
    }

    return dwError;
}

//
// Returns STATUS_SUCCESS if user is in group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
//

NTSTATUS IsUserInGroup( PSID pSidUser, PSID pSidGroup )
{
    _DBG_ASSERT( IsValidSid( pSidUser ) );
    _DBG_ASSERT( IsValidSid( pSidGroup ) );

    //
    // Return if error occured during creation of CWmiAuthz class
    // in static global CWmiAuthzWrapper class declaration.
    //

    _DBG_ASSERT( !g_dwWmiAuthzError );

    if ( g_dwWmiAuthzError )
    {
        return g_dwWmiAuthzError;
    }

    IWbemToken  *pToken = NULL;
    HRESULT     hr = g_wmiAuthzWrapper.GetWmiAuthz( )->GetToken( ( BYTE * )pSidUser, &pToken );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    BYTE        *pDACL = NULL;
    BYTE        *pSD = NULL;
    DWORD       dwAccess = 0;
    NTSTATUS    stat = GetSDAndACLFromSID( STANDARD_RIGHTS_EXECUTE, 
                                           pSidGroup, 
                                           &pDACL, 
                                           &pSD );

    if ( stat )
    {
        pToken->Release( );
        return stat;
    }

    hr = pToken->AccessCheck( STANDARD_RIGHTS_EXECUTE, pSD, &dwAccess );

    pToken->Release( );

    //
    // Delete allocated memory in GetSDAndACLFromSID
    //

    delete[] pSD;
    delete[] pDACL;

    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( STANDARD_RIGHTS_EXECUTE & dwAccess )
    {
        return STATUS_SUCCESS;
    }

    return STATUS_ACCESS_DENIED;
}


//
// Returns STATUS_SUCCESS if user is in admin group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
//

NTSTATUS IsUserAdministrator( PSID pSidUser )
{
    _DBG_ASSERT( IsValidSid( pSidUser ) );

    //
    // Return if error occured during initialization of Admin SID
    // in CAdminSID static global class declaration;
    //

    _DBG_ASSERT( !g_dwAdminSIDError );

    if ( g_dwAdminSIDError )
    {
        return g_dwAdminSIDError;
    }

    //
    // Call IsUserInGroup with Administrators group SID
    //

    return IsUserInGroup( pSidUser, g_adminSID.GetAdminSID( ) );
}


//
// Retireves access mask corresponding to permissions granted
// by dacl to account denoted in pSid
// only deals with the ACCESS_ALLOWED/DENIED type aces 
// including the ACCESS_ALLOWED/DENIED_OBJECT_ACEs
// - will error out if it finds a SYSTEM_AUDIT or unrecognized type.
//

NTSTATUS GetAccessMask( PSID pSid, PACL pDacl, DWORD *pdwAccessMask )
{
    if ( NULL == pDacl )
    {
        *pdwAccessMask = 0xFFFFFFFF;
        return STATUS_SUCCESS;
    }
    
    _DBG_ASSERT( IsValidSid( pSid ) );
    _DBG_ASSERT( IsValidAcl( pDacl ) );

    *pdwAccessMask = NULL;

    //
    // Return if error occured during creation of CWmiAuthz class
    // in static global CWmiAuthzWrapper class declaration.
    //

    _DBG_ASSERT( !g_dwWmiAuthzError );

    if ( g_dwWmiAuthzError )
    {
        return g_dwWmiAuthzError;
    }

    IWbemToken  *pToken = NULL;
    HRESULT     hr = g_wmiAuthzWrapper.GetWmiAuthz( )->GetToken( ( BYTE * )pSid, &pToken );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    BYTE        *pSD = NULL;
    NTSTATUS    stat = GetSDFromACL( pDacl, &pSD );

    if ( stat )
    {
        pToken->Release( );
        return stat;
    }

    //
    // Requested DesiredAccessMask should be MAXIMUM_ALLOWED
    // to be able to retrieve all the accesses with replied
    // access mask
    //

    hr = pToken->AccessCheck( MAXIMUM_ALLOWED, pSD, pdwAccessMask );

    pToken->Release( );

    //
    // Delete allocated memory in GetSDFromACL
    //

    delete[] pSD;

    if ( FAILED( hr ) )
    {
        return hr;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\precomp.h ===
#define COREPROX_POLARITY __declspec( dllimport )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <ole2.h>
#include <oleauto.h>

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\timekeeper.cpp ===
#include "precomp.h"
#include <TimeKeeper.h>
#include <wbemutil.h>


//#define DUMP_DEBUG_TREES 1
bool CTimeKeeper::DecorateObject(_IWmiObject* pObj)
{
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    
    {
        CInCritSec ics(&m_cs);

        if(ft.dwLowDateTime == m_ftLastEvent.dwLowDateTime &&
           ft.dwHighDateTime == m_ftLastEvent.dwHighDateTime)
        {
            //
            // This event has the same timestamp as the previous one ---
            // let's add the counter to it.  
            //

            if(0xFFFFFFFF - ft.dwLowDateTime > m_dwEventCount)
            {
                ft.dwLowDateTime += m_dwEventCount++;
            }
            else
            {
                ft.dwLowDateTime += m_dwEventCount++;
                ft.dwHighDateTime++;
            }
        }
        else
        {
            //
            // Different timestamp --- reset the counter
            //

            m_dwEventCount = 1; // 0 has been used by us
            m_ftLastEvent = ft;
        }
    }

    __int64 i64Stamp = ft.dwLowDateTime + ((__int64)ft.dwHighDateTime << 32);
    if(m_lTimeHandle == 0 && !m_bHandleInit)
    {
        HRESULT hres = 
            pObj->GetPropertyHandleEx(L"TIME_CREATED", 0, NULL, &m_lTimeHandle);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to retrieve TIME_CREATED handle: 0x%X\n",
                hres));
            m_lTimeHandle=0;
        }
        m_bHandleInit = true;
    }

    if(m_lTimeHandle)
    {
        pObj->SetPropByHandle(m_lTimeHandle, 0, sizeof(__int64), 
                                &i64Stamp);
        return true;
    }
    else
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\timekeeper.h ===
#ifndef __WBEM_TIME_KEEPER__H_
#define __WBEM_TIME_KEEPER__H_

#include <esscpol.h>
#include <sync.h>
#include <wbemint.h>


class ESSCLI_POLARITY CTimeKeeper
{
protected:
    CCritSec m_cs;
    FILETIME m_ftLastEvent;
    DWORD m_dwEventCount;
    long m_lTimeHandle;
    bool m_bHandleInit;

public:
    CTimeKeeper() : m_dwEventCount(0), m_lTimeHandle(0), m_bHandleInit(false)
    {
        m_ftLastEvent.dwLowDateTime = m_ftLastEvent.dwHighDateTime = 0;
    }

    bool DecorateObject(_IWmiObject* pObj);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\newnew.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

   NEWNEW.H

Abstract:

   CReuseMemoryManager

History:

--*/

#ifndef __WBEM_NEW_NEW__H_
#define __WBEM_NEW_NEW__H_

#include "esscpol.h"
#include <stack>

class ESSCLI_POLARITY CReuseMemoryManager
{
protected:
    CCritSec m_cs;
    CFlexQueue m_Available;
    int m_nSize;
    int m_nMaxQueued;
public:
    CReuseMemoryManager(size_t nSize, size_t nMaxQueued = 0 )
      : m_nSize(nSize)
    {
        m_nMaxQueued = nMaxQueued == 0 ? 256 : nMaxQueued;
    }

    ~CReuseMemoryManager()
    {
        Clear();
    }

    void* Allocate()
    {
        CInCritSec ics(&m_cs);

        if(m_Available.GetQueueSize() == 0)
        {
            return new BYTE[m_nSize];
        }
        else
        {
            void* p = m_Available.Unqueue();
            return p;
        }
    }
    
    void Free(void* p)
    {
        CInCritSec ics(&m_cs);

        if ( m_Available.GetQueueSize() < m_nMaxQueued )
        {
            m_Available.Enqueue(p);
        }
        else
        {
            delete [] (BYTE*)p;
        }
    }
        
    void Clear()
    {
        CInCritSec ics(&m_cs);

        while(m_Available.GetQueueSize())
        {
            delete [] (BYTE*)m_Available.Unqueue();
        }
    }
};

#define DWORD_ALIGNED(x)    (((x) + 3) & ~3)
#define QWORD_ALIGNED(x)    (((x) + 7) & ~7)

#ifdef _WIN64
#define DEF_ALIGNED         QWORD_ALIGNED
#else
#define DEF_ALIGNED         DWORD_ALIGNED
#endif

class ESSCLI_POLARITY CTempMemoryManager
{
protected:
    CCritSec m_cs;
    
    class CAllocation
    {
    private:
        size_t m_dwAllocationSize;
        size_t m_dwUsed;
        size_t m_dwFirstFree;

        static inline size_t GetHeaderSize() {return sizeof(CAllocation);}
        inline byte* GetStart() {return ((byte*)this) + GetHeaderSize();}
        inline byte* GetEnd() {return ((byte*)this) + m_dwAllocationSize;}

    public:
        size_t GetAllocationSize() {return m_dwAllocationSize;}
        size_t GetUsedSize() {return m_dwUsed;}
        static size_t GetMinAllocationSize(size_t dwBlock)
            {return dwBlock + GetHeaderSize();}

        void Init(size_t dwAllocationSize);
        void* Alloc(size_t nBlockSize);
        bool Contains(void* p);
        bool Free(size_t nBlockSize);
        void Destroy();
    };

    CPointerArray<CAllocation>* m_pAllocations;
    DWORD m_dwTotalUsed;
    DWORD m_dwTotalAllocated;
    DWORD m_dwNumAllocations;
    DWORD m_dwNumMisses;

protected:
    inline size_t RoundUp(size_t nSize) {return DEF_ALIGNED(nSize);}

public:
    CTempMemoryManager();
    ~CTempMemoryManager();

    void* Allocate(size_t nBlockSize);
    void Free(void* p, size_t nBlockSize);
    void Clear();
};

#define MAX_ALLOCA_USE 100

template <class TArg>
class CTempArray
{
protected:
    BYTE* m_a;
    BOOL m_bStack;
    int m_nByteSize;

    TArg* GetArray() {return (TArg*)m_a;}
    const TArg* GetArray() const {return (const TArg*)m_a;}
public:
    inline CTempArray() : m_a(NULL), m_bStack(TRUE), m_nByteSize(0){}

    inline ~CTempArray()
    {
        if(!m_bStack)
            delete [] m_a;
    }

    operator TArg*() {return (TArg*)m_a;}
    operator const TArg*() const {return (const TArg*)m_a;}

    TArg& operator[](int nIndex) {return GetArray()[nIndex];}
    const TArg& operator[](int nIndex) const {return GetArray()[nIndex];}
    TArg& operator[](long lIndex) {return GetArray()[lIndex];}
    const TArg& operator[](long lIndex) const {return GetArray()[lIndex];}

    void SetMem(void* p) {m_a = (BYTE*)p;}
    BOOL SetSize(int nSize)
    {
        m_nByteSize = nSize * sizeof(TArg);
        if(m_nByteSize < MAX_ALLOCA_USE)
        {
            m_bStack = TRUE;
            return TRUE;
        }
        else
        {
            m_bStack = FALSE;
            return FALSE;
        }
    }
    int GetByteSize() {return m_nByteSize;}
    BOOL IsNull() {return (m_a == NULL);}
};

    
// This macro initializes the CTempArray with a given size.  First it "sets" the
// size into the array, which returns TRUE if _alloca can be used.  If so, it
// uses alloca on the now-computed byte size of the array.

#define INIT_TEMP_ARRAY(ARRAY, SIZE) \
        ((ARRAY.SetMem(                         \
            (ARRAY.SetSize(SIZE)) ?             \
                _alloca(ARRAY.GetByteSize()) :  \
                new BYTE[ARRAY.GetByteSize()]   \
                     )                          \
        ), !ARRAY.IsNull())                     \

    

        

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\newnew.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

   NEWNEW.CPP

Abstract:

   CReuseMemoryManager

History:

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include <sync.h>
#include "newnew.h"

const int constMinAllocationSize = 4096;
const int constMaxAllocationSize = 1024 * 1024;
const double constNextAllocationFactor = 2.0;

void CTempMemoryManager::CAllocation::Init(size_t dwAllocationSize)
{
    m_dwAllocationSize = dwAllocationSize;
    m_dwUsed = 0;
    m_dwFirstFree = GetHeaderSize();
}
    
void* CTempMemoryManager::CAllocation::Alloc(size_t nBlockSize)
{
    if(m_dwFirstFree + nBlockSize <= m_dwAllocationSize)
    {
        m_dwUsed += nBlockSize;
        void* p = ((byte*)this) + m_dwFirstFree;
        m_dwFirstFree += nBlockSize;
        return p;
    }
    else 
        return NULL;
}

bool CTempMemoryManager::CAllocation::Contains(void* p)
{
    return (p > this && p <= GetEnd());
}

void CTempMemoryManager::CAllocation::Destroy()
{
    VirtualFree(this, 0, MEM_RELEASE);
}

bool CTempMemoryManager::CAllocation::Free(size_t nBlockSize)
{
    m_dwUsed -= nBlockSize;
    if(m_dwUsed== 0)
    {
		m_dwFirstFree = GetHeaderSize();
        return true;
    }
    else
        return false;
}



void* CTempMemoryManager::Allocate(size_t nBlockSize)
{
    //
    // Add the space for the length of the block
    //

    nBlockSize += DEF_ALIGNED(sizeof(DWORD));
    nBlockSize = RoundUp(nBlockSize);

    CInCritSec ics(&m_cs);

    // 
    // Check if the last allocation has room
    //

    int nAllocations = m_pAllocations->GetSize();
    CAllocation* pLast = NULL;
    if(nAllocations)
    {
        pLast = (*m_pAllocations)[nAllocations-1];
        void* p = pLast->Alloc(nBlockSize);
        if(p)
        {
            *(DWORD*)p = nBlockSize;
            m_dwTotalUsed += nBlockSize;
            m_dwNumAllocations++;
            return ((BYTE*)p) + DEF_ALIGNED(sizeof(DWORD));
        }
        else if(pLast->GetUsedSize() == 0)
        {
            //
            // The last allocation record is actually empty --- we don't want
            // to leave it there, as it will just dangle
            //

            m_dwTotalAllocated -= pLast->GetAllocationSize();
            pLast->Destroy();
            (*m_pAllocations).RemoveAt(nAllocations-1);
        }
    }
    
    //
    // No room:  need a new allocation.  The size shall be double the previous
    // size, or 1M if too large
    //

    size_t dwAllocationSize = 0;
    if(nAllocations == 0)
    {
        //
        // First time: constant size
        //

        dwAllocationSize = constMinAllocationSize;
    }
    else
    {
        //
        // Not first time: allocation constant factor of the total, but not
        // larger that a constant.
        //

        dwAllocationSize = m_dwTotalUsed * constNextAllocationFactor;

        if(dwAllocationSize > constMaxAllocationSize)
            dwAllocationSize = constMaxAllocationSize;

        if(dwAllocationSize < constMinAllocationSize)
            dwAllocationSize = constMinAllocationSize;
    }

    if(dwAllocationSize < CAllocation::GetMinAllocationSize(nBlockSize))
    {
        dwAllocationSize = CAllocation::GetMinAllocationSize(nBlockSize);
    }

    // 
    // VirtualAlloc it and read back the actual size of the allocation
    //
    
    CAllocation* pAlloc = (CAllocation*)
        VirtualAlloc(NULL, dwAllocationSize, MEM_COMMIT, PAGE_READWRITE);
    if(pAlloc == NULL)
        return NULL;

    MEMORY_BASIC_INFORMATION info;
    VirtualQuery(pAlloc, &info, sizeof(MEMORY_BASIC_INFORMATION));
            
    //
    // Initialize it, and add it to the list of allocations
    //

    pAlloc->Init(info.RegionSize);
    m_pAllocations->Add(pAlloc);
    m_dwTotalAllocated += dwAllocationSize;
    m_dwNumAllocations++;
    m_dwNumMisses++;

    //
    // Allocation memory from it
    //

    void* p = pAlloc->Alloc(nBlockSize);
    if(p)
    {
        *(DWORD*)p = nBlockSize;
        m_dwTotalUsed += nBlockSize;
        return ((BYTE*)p) + DEF_ALIGNED(sizeof(DWORD));
    }
    else
        return NULL;
}
    
void CTempMemoryManager::Free(void* p, size_t nBlockSize)
{
	if (p == NULL)
		return;

    CInCritSec ics(&m_cs);

    //
    // Figure out the size of the allocation
    //

    nBlockSize = *(DWORD*)((BYTE*)p - DEF_ALIGNED(sizeof(DWORD)));

    // 
    // Search for it in the allocations
    //

    for(int i = 0; i < m_pAllocations->GetSize(); i++)
    {
        CAllocation* pAlloc = (*m_pAllocations)[i];
        if(pAlloc->Contains(p))
        {
            //
            // Found it.  Remove and deallocate block if last.  Except that we
            // do not want to deallocate the last minimal block --- otherwise
            // small allocations will just keep VirtualAllocing all the time
            //

            m_dwTotalUsed -= nBlockSize;
        
            bool bLastInAlloc = pAlloc->Free(nBlockSize);
            if(!bLastInAlloc)
                return;

            bool bDestroy = false;
            if(m_pAllocations->GetSize() != i+1)
            {
                //
                // This is not the last record. Destroy it
                //

                bDestroy = true;
            }
            else
            {
                //
                // This is the last record.  Do more tests
                //

                if(m_pAllocations->GetSize() > 1)
                    bDestroy = true;
                else if((*m_pAllocations)[0]->GetAllocationSize() != 
                        constMinAllocationSize)
                    bDestroy = true;
            }

            if(bDestroy)
            {
                m_dwTotalAllocated -= pAlloc->GetAllocationSize();
                pAlloc->Destroy();
                (*m_pAllocations).RemoveAt(i);
            }
            return;
        }
    }

    // 
    // Bad news: freeing something we don't own!
    //

    return;
}

void CTempMemoryManager::Clear()
{
    for(int i = 0; i < m_pAllocations->GetSize(); i++)
    {
        CAllocation* pAlloc = (*m_pAllocations)[i];
        pAlloc->Destroy();
    }
    m_pAllocations->RemoveAll();
}

CTempMemoryManager::CTempMemoryManager() : 
    m_dwTotalUsed(0), m_dwTotalAllocated(0), m_dwNumAllocations(0),
    m_dwNumMisses(0), m_pAllocations(NULL)
{
    m_pAllocations = new CPointerArray<CAllocation>;
}

CTempMemoryManager::~CTempMemoryManager()
{
    Clear();
    delete m_pAllocations;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\twopropnode.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TWOPROPNODE.CPP

Abstract:

    Two Prop Node

History:

--*/


// classes to support a two-property node for the eval tree
// this will be much like the CPropertyNode defined in EvalTree.h
// but it will compare a property against another property
// rather than a property to a constant

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "TwoPropNode.h"

// warning about performance hits when converting an int to a bool
#pragma warning(disable: 4800)

// this is only a test
// TTwoScalarPropNode<int> foolishMortal;


// set offset into object for the right property
// "tell me which property I'm operating on"

void CTwoPropNode::SetRightPropertyInfo(LPCWSTR wszPropName, long lPropHandle)
{
    m_lRightPropHandle = lPropHandle;
}



void CTwoPropNode::SetRightEmbeddingInfo(const CEmbeddingInfo* pInfo)
{
    try
    {
        if (pInfo && !pInfo->IsEmpty())
        {
            if (!m_pRightInfo)
                m_pRightInfo = new CEmbeddingInfo(*pInfo);
            else
                *m_pRightInfo = *pInfo;
        }
        else
        {
            delete m_pRightInfo;
            m_pRightInfo = NULL;
        }
    }
    catch(CX_MemoryException)
    {
    }
}



HRESULT CTwoPropNode::GetRightContainerObject(CObjectInfo& ObjInfo, 
                                 INTERNAL _IWmiObject** ppInst)
{
    if (!m_pRightInfo)
    {
        *ppInst = ObjInfo.GetObjectAt(0);
        return WBEM_S_NO_ERROR;
    }                
    else
        return m_pRightInfo->GetContainerObject(ObjInfo, ppInst);
}


HRESULT CTwoPropNode::CompileRightEmbeddingPortion(CContextMetaData* pNamespace, 
                                                              CImplicationList& Implications,
                                                              _IWmiObject** ppResultClass)
{
    if (!m_pRightInfo)
        return WBEM_E_FAILED;
    else
        return m_pRightInfo->Compile(pNamespace, Implications, ppResultClass);
}


void CTwoPropNode::SetRightEmbeddedObjPropName(CPropertyName& Name) 
{ 
    if (m_pRightInfo)
        m_pRightInfo->SetEmbeddedObjPropName(Name);
}


void CTwoPropNode::MixInJumpsRightObj(const CEmbeddingInfo* pParent)
{                                               
    if (pParent && m_pRightInfo)
        m_pRightInfo->MixInJumps(pParent);
}


CPropertyName* CTwoPropNode::GetRightEmbeddedObjPropName() 
{
    if (!m_pRightInfo)
        return NULL;
    else                
        return m_pRightInfo->GetEmbeddedObjPropName();
}

// compare precedence of this node to that node

int CTwoPropNode::ComparePrecedence(CBranchingNode* pOther)
{
    int nCompare;
    nCompare = GetSubType() - pOther->GetSubType();
    if(nCompare) return nCompare;

    CTwoPropNode* pOtherNode = (CTwoPropNode*)pOther;

    nCompare = m_pRightInfo->ComparePrecedence(pOtherNode->m_pRightInfo);
    if (nCompare == 0)
    {
        nCompare = CPropertyNode::ComparePrecedence(pOther);
        if (nCompare == 0)
            nCompare = m_lRightPropHandle - pOtherNode->m_lRightPropHandle;
    }
    
    return nCompare;
}


HRESULT CTwoPropNode::AdjustCompile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
{   
    HRESULT hRes;

    if (SUCCEEDED(hRes = CBranchingNode::AdjustCompile(pNamespace, Implications)))
        if (m_pRightInfo)
            hRes = m_pRightInfo->Compile(pNamespace, Implications, NULL);
        else
            hRes = WBEM_E_FAILED;

    return hRes;
}


HRESULT CTwoPropNode::OptimizeSelf()
{
    // can't combine our three branches - nothing to do.
    return WBEM_S_NO_ERROR;
}


HRESULT CTwoPropNode::SetTest(VARIANT& v)
{
    // again, nothing to do, our test is determined by the Right side property
    // (this should never be called, but doesn't hurt anything)
    return WBEM_S_NO_ERROR;
}


void CTwoPropNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);

    if (m_pInfo)
        m_pInfo->Dump(f);

    if (m_pRightInfo)
        m_pRightInfo->Dump(f);

    fprintf(f, ", LeftPropHandle = (0x%x)\n", m_lPropHandle);
    fprintf(f, ", RightPropHandle = (0x%x)\n", m_lRightPropHandle);

    fprintf(f, "Branches:\n");    
    PrintOffset(f, nOffset);

    // "i = (Operations)((int)(i) + 1)" is basically i++, with all the BS needed to make the compiler happy.
    // thank you K&R for saddling us with a nearly useless enum type!
    for (Operations i = LT; i < NOperations; i = (Operations)((int)(i) + 1))
    {
        DumpNode(f, nOffset+1, m_apBranches[i]);
        fprintf(f, "\n");    
    }

    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}
                               

int CTwoPropNode::SubCompare(CEvalNode* pRawOther)
{
    CTwoPropNode* pOther = 
        (CTwoPropNode*)pRawOther;

    int nCompare;
    nCompare = m_lPropHandle - pOther->m_lPropHandle;
    if(nCompare)
        return nCompare;

    nCompare = m_lRightPropHandle - pOther->m_lRightPropHandle;
    if(nCompare)
        return nCompare;

    nCompare = m_apBranches.GetSize() - pOther->m_apBranches.GetSize();
    if(nCompare)
        return nCompare;

    return TRUE;
}

HRESULT CTwoPropNode::CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes)
{
    // step one, determine whether we can reuse a node
    CTwoPropNode* pNewNode     = NULL;
    CTwoPropNode* pDeleteMe    = NULL;

    if (bDeleteThis && bDeleteArg2)
    {
        pNewNode = this;
        pDeleteMe = (CTwoPropNode*) pArg2;
    }
    else if (bDeleteThis)
        pNewNode = this;
    else if (bDeleteArg2)
        pNewNode = (CTwoPropNode*) pArg2;
    else
        pNewNode = CloneSelfWithoutChildren();


    HRESULT hRes = WBEM_S_NO_ERROR;
    CTwoPropNode* pOther = (CTwoPropNode*)pArg2;

    for (int i = LT; i < NOperations && SUCCEEDED(hRes); i++)
    {
        CEvalNode* pNewChildNode = NULL;
        hRes = CEvalTree::Combine( m_apBranches[i], pOther->m_apBranches[i],
                                   nOp, pNamespace, Implications, bDeleteThis,
                                   bDeleteArg2, &pNewChildNode);
        if ( FAILED(hRes) )
            break;
        if (bDeleteArg2)
            pOther->m_apBranches.Discard(i);
        if (bDeleteThis)
            m_apBranches.Discard(i);

        pNewNode->m_apBranches.Discard(i);
        pNewNode->m_apBranches.SetAt(i, pNewChildNode);
    }

    if (SUCCEEDED(hRes))
    {
        if(pDeleteMe)
        {
            pDeleteMe->m_pNullBranch = NULL;
            delete pDeleteMe;
        }
        
        *ppRes = pNewNode;
    }
    else
    {
        *ppRes = NULL;
    }
    
    return hRes;
}

// given a property handle, will retrieve proper property, probably.
CVar* CTwoPropNode::GetPropVariant(_IWmiObject* pObj, long lHandle, CIMTYPE* pct)
{
    CVar *pVar = NULL;
    BSTR bstrName;

    if (SUCCEEDED(pObj->GetPropertyInfoByHandle(lHandle, &bstrName, pct)))
    {
        CSysFreeMe sfm(bstrName);

        //
        // Get it into a VARIANT
        //

        VARIANT v;
        if(FAILED(pObj->Get(bstrName, 0, &v, NULL, NULL)))
            return NULL;

        // Convert it to a CVar

        if (pVar = new CVar)
            pVar->SetVariant(&v);

        VariantClear( &v );
    }

    return pVar;
}


//    ***************************
//  ****  Two String Prop Node ****
//    ***************************


CEvalNode* CTwoStringPropNode::Clone() const
{
    return (CEvalNode *) new CTwoStringPropNode(*this, true);
}

CTwoPropNode* CTwoStringPropNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoStringPropNode(*this, false);
}

long CTwoStringPropNode::GetSubType()
{
    return EVAL_NODE_TYPE_TWO_STRINGS;
}

HRESULT CTwoStringPropNode::Evaluate(CObjectInfo& ObjInfo, 
                        INTERNAL CEvalNode** ppNext)
{
    HRESULT herslut = WBEM_S_NO_ERROR;

    _IWmiObject* pLeftObj;
    _IWmiObject* pRightObj;

    if(SUCCEEDED(herslut = GetContainerObject(ObjInfo, &pLeftObj))
        &&
       SUCCEEDED(herslut = GetRightContainerObject(ObjInfo, &pRightObj)))
    {
        CCompressedString* pLeftStr;
        CCompressedString* pRightStr;
        
        pLeftStr  = CoreGetPropertyString(pLeftObj, m_lPropHandle);
        pRightStr = CoreGetPropertyString(pRightObj, m_lRightPropHandle); 

        if ((pLeftStr == NULL) || (pRightStr == NULL))
        {
            *ppNext = m_pNullBranch;

            herslut = WBEM_S_NO_ERROR;
        }
        else
        {               
            int nCompare = pLeftStr->CheapCompare(*pRightStr);

            // TODO: check to see if CheapCompare is guaranteed to return -1,0,1
            // if so, then the multiple else if becomes
            // *ppNext = m_apBranches[EQ + nCompare];

            if (nCompare < 0)
                *ppNext = m_apBranches[LT];
            else if (nCompare > 0)
                *ppNext = m_apBranches[GT];
            else 
                *ppNext = m_apBranches[EQ];                     

            herslut = WBEM_S_NO_ERROR;
        }
    }
        
    return herslut;
}

//    *******************************
//  ****  Two Mismatched Prop Node ****
//    *******************************

HRESULT CTwoMismatchedPropNode::Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext)
{
    CVar *pLeftVar  = NULL;
    CVar *pRightVar = NULL;
    *ppNext = NULL;

    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    CIMTYPE ct;

    _IWmiObject* pLeftObj  = NULL;
    _IWmiObject* pRightObj = NULL;

    // if we can get the objects and variants...
    if ((SUCCEEDED(hr = GetContainerObject(ObjInfo, &pLeftObj))
            &&
         SUCCEEDED(hr = GetRightContainerObject(ObjInfo, &pRightObj))) 
            &&
        (pLeftVar  = GetPropVariant(pLeftObj, m_lPropHandle, &ct))
            &&
        (pRightVar = GetPropVariant(pRightObj, m_lRightPropHandle, &ct)) )
    {
        if (pLeftVar->IsDataNull() || pRightVar->IsDataNull())
        {
            *ppNext = m_pNullBranch;
            hr      = WBEM_S_NO_ERROR;
        }
        else 
            hr = Evaluate(pLeftVar, pRightVar, ppNext);                        
    }
    else if (SUCCEEDED(hr))
        // if we got here, it's because one of the GetPropVariant's didn't
        hr = WBEM_E_INVALID_PARAMETER;

    delete pLeftVar;
    delete pRightVar;

    return hr;
}
    
//    **************************************
//  ****  Two Mismatched String Prop Node ****
//    **************************************
    
CEvalNode* CTwoMismatchedStringNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedStringNode(*this, true);
}

CTwoPropNode* CTwoMismatchedStringNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedStringNode(*this, false);
}

// type identification
long CTwoMismatchedStringNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_STRINGS;
}

// string evaluation: promote them all to strings
// and do a lexagraphic compare..
HRESULT CTwoMismatchedStringNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    if (pLeftVar->ChangeTypeTo(VT_BSTR) && pRightVar->ChangeTypeTo(VT_BSTR))    
    {
        int nCompare = wcscmp(pLeftVar->GetLPWSTR(), pRightVar->GetLPWSTR());

        if (nCompare < 0)
            *ppNext = m_apBranches[LT];
        else if (nCompare > 0)
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }
    else 
        hr = WBEM_E_FAILED;

    return hr;
}
    

//    ************************************
//  ****  Two Mismatched UINT Prop Node ****
//    ************************************

CEvalNode* CTwoMismatchedUIntNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedUIntNode(*this, true);
}

CTwoPropNode* CTwoMismatchedUIntNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedUIntNode(*this, false);
}

// type identification
long CTwoMismatchedUIntNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedUIntNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    bool bLeftChanged, bRightChanged;

    bLeftChanged = pLeftVar->ChangeTypeTo(VT_UI4);
    bRightChanged = pRightVar->ChangeTypeTo(VT_UI4);
       
    if (bLeftChanged && bRightChanged)
    {
        if (pLeftVar->GetDWORD() < pRightVar->GetDWORD())
            *ppNext = m_apBranches[LT];
        else if (pLeftVar->GetDWORD() > pRightVar->GetDWORD())
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }
    // attempt to handle signed/unsigned mismatches
    else if (bLeftChanged && 
             pRightVar->ChangeTypeTo(VT_I4) &&
             pRightVar->GetLong() < 0)
    {
        *ppNext = m_apBranches[GT];
        hr = WBEM_S_NO_ERROR;            
    }
    else if (bRightChanged && 
             pLeftVar->ChangeTypeTo(VT_I4) &&
             pLeftVar->GetLong() < 0)
    {
        *ppNext = m_apBranches[LT];
        hr = WBEM_S_NO_ERROR;            
    }

    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}
    

        

//    ***********************************
//  ****  Two Mismatched int Prop Node ****
//    ***********************************
    
CEvalNode* CTwoMismatchedIntNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedIntNode(*this, true);
}

CTwoPropNode* CTwoMismatchedIntNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedIntNode(*this, false);
}

// type identification
long CTwoMismatchedIntNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedIntNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    bool bLeftChanged, bRightChanged;

    bLeftChanged = pLeftVar->ChangeTypeTo(VT_I4);
    bRightChanged = pRightVar->ChangeTypeTo(VT_I4);

    if (bLeftChanged && bRightChanged)
    {
        if (pLeftVar->GetLong() < pRightVar->GetLong())
            *ppNext = m_apBranches[LT];
        else if (pLeftVar->GetLong() > pRightVar->GetLong())
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }
    // attempt to handle signed/unsigned mismatches
    else if (bLeftChanged && 
             pRightVar->ChangeTypeTo(VT_UI4) &&
             pRightVar->GetDWORD() > _I32_MAX)
    {
        *ppNext = m_apBranches[LT];
        hr = WBEM_S_NO_ERROR;            
    }
    else if (bRightChanged && 
             pLeftVar->ChangeTypeTo(VT_UI4) &&
             pLeftVar->GetDWORD() > _I32_MAX)
    {
        *ppNext = m_apBranches[GT];
        hr = WBEM_S_NO_ERROR;            
    }
    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}
    
//    **************************************
//  ****  Two Mismatched int 64 Prop Node ****
//    **************************************
    
CEvalNode* CTwoMismatchedInt64Node::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedInt64Node(*this, true);
}

CTwoPropNode* CTwoMismatchedInt64Node::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedInt64Node(*this, false);
}

// type identification
long CTwoMismatchedInt64Node::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedInt64Node::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    __int64 i64Left, i64Right;
    unsigned __int64 ui64;

    if (pLeftVar->ChangeTypeTo(VT_BSTR) && 
        pRightVar->ChangeTypeTo(VT_BSTR))
    {        
        if ((pLeftVar->GetLPWSTR() == NULL) || (pRightVar->GetLPWSTR() == NULL))
            *ppNext = m_pNullBranch;
        else
        {        
            bool bReadLeft, bReadRight;

            bReadLeft =  ReadI64(pLeftVar->GetLPWSTR(),  i64Left);
            bReadRight = ReadI64(pRightVar->GetLPWSTR(), i64Right);

            if (bReadLeft && bReadRight)
            {
                if (i64Left < i64Right)
                    *ppNext = m_apBranches[LT];
                else if (i64Left > i64Right)
                    *ppNext = m_apBranches[GT];
                else 
                    *ppNext = m_apBranches[EQ];                     
                hr = WBEM_S_NO_ERROR;            
            }
            // try to cover ourselves with signed/unsigned mismatches
            // note that this is a redundant check - if the other side
            // were a unsigned int 64, this node should have been a UInt64 node.
            else if (bReadLeft &&
                     ReadUI64(pRightVar->GetLPWSTR(), ui64)
                     && (ui64 >= _I64_MAX))
            {
                *ppNext = m_apBranches[LT];
                hr = WBEM_S_NO_ERROR;            
            }
            else if (bReadRight &&
                     ReadUI64(pLeftVar->GetLPWSTR(), ui64)
                     && (ui64 >= _I64_MAX))
            {
                *ppNext = m_apBranches[GT];
                hr = WBEM_S_NO_ERROR;            
            }
            else
                hr = WBEM_E_TYPE_MISMATCH;
        } // if ((pLeftVar->GetLPWSTR() == NULL)...
    } // if (pLeftVar->ChangeTypeTo(VT_BSTR) 
    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}

//    ***********************************************
//  ****  Two Mismatched unsigned int 64 Prop Node ****
//    ***********************************************
    
CEvalNode* CTwoMismatchedUInt64Node::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedUInt64Node(*this, true);
}

CTwoPropNode* CTwoMismatchedUInt64Node::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedUInt64Node(*this, false);
}

// type identification
long CTwoMismatchedUInt64Node::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedUInt64Node::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    unsigned __int64 i64Left, i64Right;
    __int64 i64;

    if (pLeftVar->ChangeTypeTo(VT_BSTR) && 
        pRightVar->ChangeTypeTo(VT_BSTR))
    {        
        if ((pLeftVar->GetLPWSTR() == NULL) || (pRightVar->GetLPWSTR() == NULL))
            *ppNext = m_pNullBranch;
        else
        {        
            bool bReadLeft, bReadRight;

            bReadLeft =  ReadUI64(pLeftVar->GetLPWSTR(),  i64Left);
            bReadRight = ReadUI64(pRightVar->GetLPWSTR(), i64Right);

            if (bReadLeft && bReadRight)
            {
                if (i64Left < i64Right)
                    *ppNext = m_apBranches[LT];
                else if (i64Left > i64Right)
                    *ppNext = m_apBranches[GT];
                else 
                    *ppNext = m_apBranches[EQ];                     

                hr = WBEM_S_NO_ERROR;            
            }
            // try to cover ourselves with signed/unsigned mismatches
            else if (bReadLeft &&
                     ReadI64(pRightVar->GetLPWSTR(), i64)
                     && (i64 < 0))
            {
                *ppNext = m_apBranches[GT];
                hr = WBEM_S_NO_ERROR;            
            }
            else if (bReadRight &&
                     ReadI64(pLeftVar->GetLPWSTR(), i64)
                     && (i64 < 0))
            {
                *ppNext = m_apBranches[LT];
                hr = WBEM_S_NO_ERROR;            
            }
            else
                hr = WBEM_E_TYPE_MISMATCH;
        }
    }
    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}

    
//    *************************************
//  ****  Two Mismatched Float Prop Node ****
//    *************************************
    
CEvalNode* CTwoMismatchedFloatNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedFloatNode(*this, true);
}

CTwoPropNode* CTwoMismatchedFloatNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedFloatNode(*this, false);
}

// type identification
long CTwoMismatchedFloatNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_FLOATS; 
}

HRESULT CTwoMismatchedFloatNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    HRESULT hr = WBEM_E_TYPE_MISMATCH; // guilty until proven innocent
    if (pLeftVar->ChangeTypeTo(VT_R8) && pRightVar->ChangeTypeTo(VT_R8))    
    {
        if (pLeftVar->GetDouble() < pRightVar->GetDouble())
            *ppNext = m_apBranches[LT];
        else if (pLeftVar->GetDouble() > pRightVar->GetDouble())
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }

    return hr;
}
    



#pragma warning(default: 4800)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\twopropnode.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TWOPROPNODE.INL

Abstract:

    Two Prop Node Inlines

History:

--*/

// inline support for templates for TwoPropNode

// silly warning about performance hits when converting an int to a bool
#pragma warning(disable: 4800)

// evaluate data in ObjInfo, decide which node (branch) should be evaluated next
template<class TPropType>
HRESULT TTwoScalarPropNode<TPropType>::Evaluate(CObjectInfo& ObjInfo, 
					  INTERNAL CEvalNode** ppNext)
{
	HRESULT herslut = WBEM_S_NO_ERROR;

    _IWmiObject* pLeftObj;
    _IWmiObject* pRightObj;

    if(SUCCEEDED(herslut = GetContainerObject(ObjInfo, &pLeftObj))
		&&
	   SUCCEEDED(herslut = GetRightContainerObject(ObjInfo, &pRightObj)))
	{
	    long lRead;
		TPropType lValue, rValue;

		// ugly compare: "if we get both properties"
		if (SUCCEEDED(herslut = pLeftObj->ReadPropertyValue(m_lPropHandle, sizeof(TPropType), &lRead, (BYTE*)&lValue))
			 &&
			SUCCEEDED(herslut = pRightObj->ReadPropertyValue(m_lRightPropHandle, sizeof(TPropType), &lRead, (BYTE*)&rValue)))
		{
			herslut = WBEM_S_NO_ERROR;
			if (lValue < rValue)
				*ppNext = m_apBranches[LT];
			else if (lValue > rValue)
				*ppNext = m_apBranches[GT];
			else 
				*ppNext = m_apBranches[EQ];						
		}
	}
	
	return herslut;
}

template<class TPropType>
CEvalNode* TTwoScalarPropNode<TPropType>::Clone() const
{
    return (CBranchingNode*) new TTwoScalarPropNode<TPropType>(*this, true);
}

template<class TPropType>
CTwoPropNode* TTwoScalarPropNode<TPropType>::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode*) new TTwoScalarPropNode<TPropType>(*this, false);
}


template<class TPropType>
long TTwoScalarPropNode<TPropType>::GetSubType()
{
    return EVAL_NODE_TYPE_TWO_SCALARS;
}


#pragma warning(default: 4800)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\wbemdnf.h ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    WBEMDNF.H

Abstract:

    WBEM Evaluation Tree

History:

--*/

#ifndef __WBEM_DNF__H_
#define __WBEM_DNF__H_

#include "esscpol.h"
#include <parmdefs.h>
#include <ql.h>
#include <wbemcomn.h>
#include <sync.h>
#include <newnew.h>

class CTokenFilter
{
 public:
    CTokenFilter(){}
    virtual ~CTokenFilter(){}
    virtual BOOL IsRelevant(QL_LEVEL_1_TOKEN* pToken) = 0;
};

class CConjunction
{
protected:
    CUniquePointerArray<QL_LEVEL_1_TOKEN> m_apTokens;
    static CReuseMemoryManager mstatic_Manager;

public:
    CConjunction();
    CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate);
    CConjunction(CConjunction& Other);
    CConjunction(CConjunction& Other1, CConjunction& Other2);
    
    long GetNumTokens() {return m_apTokens.GetSize();}
    INTERNAL QL_LEVEL_1_TOKEN* GetTokenAt(int nIndex) 
        {return m_apTokens[nIndex];}
    BOOL AddToken(ACQUIRE QL_LEVEL_1_TOKEN* pNew)
        { return m_apTokens.Add(pNew); }

    void Sort();

    HRESULT GetNecessaryProjection( CTokenFilter* pFilter, 
                                    CConjunction** ppResult);

    static int NegateOperator(int nOperator);
    void *operator new(size_t nBlock);
    void operator delete(void* p);
};

class CDNFExpression
{
protected:
    CUniquePointerArray<CConjunction> m_apTerms;

protected:
    BOOL CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate);
    HRESULT CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2, 
                        long& lMaxTokens);
    HRESULT CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2, 
                    long& lMaxTokens);

public:
    long GetNumTerms() {return m_apTerms.GetSize();}
    INTERNAL CConjunction* GetTermAt(int nIndex) 
        {return m_apTerms[nIndex];}
    void AddTerm(ACQUIRE CConjunction* pNew)
        {m_apTerms.Add(pNew);}

    HRESULT CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken, BOOL bNegate,
                            long& lMaxTokens);
            
    void Sort();
            
public:

    HRESULT GetNecessaryProjection(CTokenFilter* pFilter, 
                                    CDNFExpression** ppResult);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\wbemdnf.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WBEMDNF.CPP

Abstract:

    WBEM Evaluation Tree

History:

--*/

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include <wbemdnf.h>

HRESULT CDNFExpression::CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken, 
                                        BOOL bNegate, long& lTokensAllowed)
{
    HRESULT hres;

    if(lTokensAllowed < 0)
        return WBEM_E_QUOTA_VIOLATION;
    
    lTokensAllowed--;
    
    QL_LEVEL_1_TOKEN& Head = *pLastToken;
    if(Head.nTokenType == QL1_OP_EXPRESSION)
    {
        if(!CreateFromToken(Head, bNegate))
            return WBEM_E_OUT_OF_MEMORY;

        pLastToken--;
        return WBEM_S_NO_ERROR;
    }

    // Build arguments
    // ===============

    pLastToken--;

    if(Head.nTokenType == QL1_NOT)
    {
        hres = CreateFromTokens(pLastToken, !bNegate, lTokensAllowed);
        return hres;
    }

    long lChildCount = lTokensAllowed;

    CDNFExpression Arg1;
    hres = Arg1.CreateFromTokens(pLastToken, bNegate, lChildCount);
    if(FAILED(hres))
        return hres;

    CDNFExpression Arg2;
    hres = Arg2.CreateFromTokens(pLastToken, bNegate, lChildCount);
    if(FAILED(hres))
        return hres;

    if( Head.nTokenType == QL1_AND )
    {
        if ( !bNegate )
        {
            hres = CreateAnd( Arg1, Arg2, lTokensAllowed );
        }
        else 
        {
            hres = CreateOr( Arg1, Arg2, lTokensAllowed );
        }
    }
    else
    {
        if ( !bNegate )
        {
            hres = CreateOr( Arg1, Arg2, lTokensAllowed );
        }
        else
        {
            hres = CreateAnd( Arg1, Arg2, lTokensAllowed );
        }
    }

    return hres;
}

HRESULT CDNFExpression::CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2,
                                long& lTokensAllowed)
{
    for(long lFirst = 0; lFirst < Arg1.GetNumTerms(); lFirst++)
    {
        for(long lSecond = 0; lSecond < Arg2.GetNumTerms(); lSecond++)
        {
            CConjunction* pNewTerm = NULL;
            try
            {
                pNewTerm = new CConjunction(*Arg1.GetTermAt(lFirst), 
                                    *Arg2.GetTermAt(lSecond));
            }
            catch(...)
            {
                pNewTerm = NULL;
            }
            if(pNewTerm == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            long lTokens = pNewTerm->GetNumTokens();
            if(lTokens > lTokensAllowed)
            {
                delete pNewTerm;
                return WBEM_E_QUOTA_VIOLATION;
            }
            else
            {
                lTokensAllowed -= lTokens;
            }

            m_apTerms.Add(pNewTerm);
        }
    }

    return S_OK;
}

HRESULT CDNFExpression::CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2,
                                long& lTokensAllowed)
{
    int i;
    for(i = 0; i < Arg1.GetNumTerms(); i++)
    {
        CConjunction* pConj = NULL;
        try
        {
            pConj = new CConjunction(*Arg1.GetTermAt(i));
        }
        catch(...)
        {
            pConj = NULL;
        }
        if(pConj == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        long lTokens = pConj->GetNumTokens();
        if(lTokens > lTokensAllowed)
        {
            delete pConj;
            return WBEM_E_QUOTA_VIOLATION;
        }
        else
        {
            lTokensAllowed -= lTokens;
        }

        m_apTerms.Add(pConj);
    }

    for(i = 0; i < Arg2.GetNumTerms(); i++)
    {
        CConjunction* pConj = NULL;
        try
        {
            pConj = new CConjunction(*Arg2.GetTermAt(i));
        }
        catch(...)
        {
            pConj = NULL;
        }
        if(pConj == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        long lTokens = pConj->GetNumTokens();
        if(lTokens > lTokensAllowed)
        {
            delete pConj;
            return WBEM_E_QUOTA_VIOLATION;
        }
        else
        {
            lTokensAllowed -= lTokens;
        }

        m_apTerms.Add(pConj);
    }

    return S_OK;
}

BOOL CDNFExpression::CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    try
    {
        CConjunction* pConj = new CConjunction(Token, bNegate);
        if(pConj == NULL)
            return FALSE;
        if(m_apTerms.Add(pConj) < 0)
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }
    return TRUE;
}


void CDNFExpression::Sort()
{
    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        m_apTerms[i]->Sort();
    }
}

HRESULT CDNFExpression::GetNecessaryProjection(CTokenFilter* pFilter, 
                                    CDNFExpression** ppResult)
{
    *ppResult = NULL;
    CDNFExpression* pResult = new CDNFExpression;
    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        CConjunction* pConj = NULL;
        HRESULT hres = m_apTerms[i]->GetNecessaryProjection(pFilter, &pConj);
        if(FAILED(hres))
        {
            delete pResult;
            return hres;
        }

        if(pConj->GetNumTokens() == 0)
        {
            // 
            // This conjunction is empty, meaning that no necessary condition
            // exists for the projection in question.  That means that the 
            // entire projection is empty as well --- no restrictions.
            //

            pResult->m_apTerms.RemoveAll();
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pResult->m_apTerms.Add(pConj);
        }
    }
    
    *ppResult = pResult;
    return WBEM_S_NO_ERROR;
}

CReuseMemoryManager CConjunction::mstatic_Manager(sizeof CConjunction);

void *CConjunction::operator new(size_t nBlock)
{
    return mstatic_Manager.Allocate();
}
void CConjunction::operator delete(void* p)
{
    mstatic_Manager.Free(p);
}

CConjunction::CConjunction()
{
}

CConjunction::CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( Token );
    
    if ( NULL == pToken )
    {
        throw CX_MemoryException();
    }

    m_apTokens.Add( pToken );

    if(bNegate)
    {
        m_apTokens[0]->nOperator = NegateOperator(m_apTokens[0]->nOperator);
    }
}

CConjunction::CConjunction(CConjunction& Other)
{
    for(int i = 0; i < Other.GetNumTokens(); i++)
    {
        QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( *Other.GetTokenAt( i ) );

        if ( NULL == pToken )
        {
            throw CX_MemoryException();
        }

        m_apTokens.Add( pToken );
    }
}

CConjunction::CConjunction(CConjunction& Other1, CConjunction& Other2)
{
    int i;
    for(i = 0; i < Other1.GetNumTokens(); i++)
    {
        QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( *Other1.GetTokenAt( i ) );

        if ( NULL == pToken )
        {
            throw CX_MemoryException();
        }

        m_apTokens.Add( pToken );
    }

    for(i = 0; i < Other2.GetNumTokens(); i++)
    {
        QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( *Other2.GetTokenAt( i ) );

        if ( NULL == pToken )
        {
            throw CX_MemoryException();
        }

        m_apTokens.Add( pToken );
    }
}

int CConjunction::NegateOperator(int nOperator)
{
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_ISNOTA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_INV_ISA;
    }

    return nOperator;
}


#pragma optimize("", off)

void CConjunction::Sort()
{
    int i = 0;

    while(i < m_apTokens.GetSize() - 1)
    {
        int nLeft = m_apTokens[i]->PropertyName.GetNumElements();
        int nRight = m_apTokens[i+1]->PropertyName.GetNumElements();
        if(nLeft > nRight)
        {
            m_apTokens.Swap(i, i+1);
            if(i != 0) 
            {
                i--;
            }
        }
        else 
        {
            i++;
        }
    }
}
#pragma optimize("", on)


// returns an empty conjunction if no necessary condition exists
HRESULT CConjunction::GetNecessaryProjection(CTokenFilter* pFilter, 
                                    CConjunction** ppResult)
{
    *ppResult = NULL;
    CConjunction* pResult = new CConjunction;
    if(pResult == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    for(int i = 0; i < m_apTokens.GetSize(); i++)
    {
        if(pFilter->IsRelevant(m_apTokens[i]))
        {
            if(!pResult->AddToken(m_apTokens[i]))
            {
                delete pResult;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    *ppResult = pResult;
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\wbemmeta.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemmeta.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>

HRESULT STDMETHODCALLTYPE CMetaData::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemMetaData)
        *ppv = (void*)(IWbemMetaData*)this;
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CMetaData::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CMetaData::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT CMetaData::GetClass(LPCWSTR wszName, IWbemContext* pContext, 
                            IWbemClassObject** ppClass)
{
    ENTER_API_CALL
    	
    _IWmiObject* pClass = NULL;
    HRESULT hres = GetClass(wszName, pContext, &pClass);
    *ppClass = pClass;
    return hres;

    EXIT_API_CALL
}


CContextMetaData::CContextMetaData(CMetaData* pMeta, IWbemContext* pContext)
    : m_pMeta(pMeta), m_pContext(pContext)
{
    if(m_pMeta)
        m_pMeta->AddRef();
    if(m_pContext)
        m_pContext->AddRef();
}

CContextMetaData::~CContextMetaData()
{
    if(m_pMeta)
        m_pMeta->Release();
    if(m_pContext)
        m_pContext->Release();
}

HRESULT CContextMetaData::GetClass(LPCWSTR wszName, _IWmiObject** ppClass)
{
    ENTER_API_CALL
    	
    _IWmiObject* pObj = NULL;
    HRESULT hres = m_pMeta->GetClass(wszName, m_pContext, &pObj);
    *ppClass = pObj;
    return hres;

    EXIT_API_CALL
}

CStandardMetaData::CStandardMetaData(IWbemServices* pNamespace) 
    : m_pNamespace(pNamespace)
{
    if(m_pNamespace)
        m_pNamespace->AddRef();
}

CStandardMetaData::~CStandardMetaData() 
{
    if(m_pNamespace)
        m_pNamespace->Release();
}

void CStandardMetaData::Clear() 
{
    if(m_pNamespace)
        m_pNamespace->Release();
    m_pNamespace = NULL;
}

HRESULT CStandardMetaData::GetClass(LPCWSTR wszName, IWbemContext* pContext, 
                                        _IWmiObject** ppObj)
{
    ENTER_API_CALL

	    BSTR strName = SysAllocString(wszName);
	    CSysFreeMe sfm(strName);

	    IWbemClassObject* pObj = NULL;
	    HRESULT hres = m_pNamespace->GetObject(strName, 0, pContext, &pObj, NULL);
	    if(FAILED(hres))
	        return hres;
	    CReleaseMe rm1(pObj);

	    return pObj->QueryInterface(IID__IWmiObject, (void**)ppObj);

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\twopropnode.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TWOPROPNODE.H

Abstract:

    Two Prop Node

History:

--*/


// classes to support a two-property node for the eval tree
// this will be much like the CPropertyNode defined in EvalTree.h
// but it will compare a property against another property
// rather than a property to a constant

#ifndef _WBEM_TWOPROPNODE_H_
#define _WBEM_TWOPROPNODE_H_

#include "EvalTree.h"

// virtual base class, good stuff derives from this
class CTwoPropNode : public CPropertyNode
{
public:
    // various methods to create a new thingie.
	CTwoPropNode() : m_lRightPropHandle(-1), m_pRightInfo(NULL)
	{}

    CTwoPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE)
        : CPropertyNode(Other, bChildren), m_lRightPropHandle(Other.m_lRightPropHandle)
	{
	    if (Other.m_pRightInfo)
		    m_pRightInfo = new CEmbeddingInfo(*(Other.m_pRightInfo));
	    else
			m_pRightInfo = NULL;
	}
    virtual CTwoPropNode* CloneSelfWithoutChildren() const =0;

    // evaluate
    virtual int SubCompare(CEvalNode* pNode);


    // integrating and combining into tree structure
    void			SetRightPropertyInfo(LPCWSTR wszRightPropName, long lRightPropHandle);
    virtual int		ComparePrecedence(CBranchingNode* pOther);
    HRESULT         OptimizeSelf(void);
    HRESULT         SetTest(VARIANT& v);

	
	// Right-side embedding info access
	void			SetRightEmbeddingInfo(const CEmbeddingInfo* pInfo);
	HRESULT			GetRightContainerObject(CObjectInfo& ObjInfo, 
								 INTERNAL _IWmiObject** ppInst);
	HRESULT			CompileRightEmbeddingPortion(CContextMetaData* pNamespace, 
								CImplicationList& Implications,
								_IWmiObject** ppResultClass);
    void            SetRightEmbeddedObjPropName(CPropertyName& Name); 
    void            MixInJumpsRightObj(const CEmbeddingInfo* pParent);
    CPropertyName*  GetRightEmbeddedObjPropName(); 

    // any or all embedding info
    HRESULT AdjustCompile(CContextMetaData* pNamespace, 
                          CImplicationList& Implications);

   // debugging
   virtual void Dump(FILE* f, int nOffset);

   // property access
   CVar* GetPropVariant(_IWmiObject* pObj, long lHandle, CIMTYPE* pct);


protected:
	// order is important: must match the way the branches array is constructed
	enum Operations {LT, EQ, GT, NOperations};

	// the right hand property we hold onto,
	// we inherit the left hand prop from CPropertyNode
	// we will assume that we always can write something akin to:
	// Prop < RightProp
	// at merge time, must take a RightProp < Prop
	// and turn it into: Prop >= RightProp
    long m_lRightPropHandle;
    CEmbeddingInfo* m_pRightInfo;

    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes);

private:

};


template<class TPropType>
class TTwoScalarPropNode : public CTwoPropNode
{
public:
    TTwoScalarPropNode() {}

    TTwoScalarPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;


    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, 
                            INTERNAL CEvalNode** ppNext);

    // type identification
    virtual long GetSubType();

};


class CTwoStringPropNode : public CTwoPropNode
{
public:
    CTwoStringPropNode() {}

    CTwoStringPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();


    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, 
                            INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedPropNode : public CTwoPropNode
{
public:
    CTwoMismatchedPropNode() {}
    CTwoMismatchedPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                            CTwoPropNode(Other, bChildren)
                            {}
 
    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext) = 0;
};

class CTwoMismatchedIntNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedIntNode() {}

    CTwoMismatchedIntNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                          CTwoMismatchedPropNode(Other, bChildren)
                          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

// TODO: when COM catches up with us, support INT64's as numeric types
//       right now, we store & m anipulate them as strings
class CTwoMismatchedInt64Node : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedInt64Node() {}

    CTwoMismatchedInt64Node(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                          CTwoMismatchedPropNode(Other, bChildren)
                          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedFloatNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedFloatNode() {}

    CTwoMismatchedFloatNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                            CTwoMismatchedPropNode(Other, bChildren)
                            {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedUIntNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedUIntNode() {}

    CTwoMismatchedUIntNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoMismatchedPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

// TODO: when COM catches up with us, support INT64's as numeric types
//       right now, we store & manipulate them as strings
class CTwoMismatchedUInt64Node : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedUInt64Node() {}

    CTwoMismatchedUInt64Node(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoMismatchedPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedStringNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedStringNode() {}

    CTwoMismatchedStringNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                             CTwoMismatchedPropNode(Other, bChildren)
                             {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();


protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

#include "TwoPropNode.inl"


#endif _WBEM_TWOPROPNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\wbemmeta.h ===
#ifndef __WBEM_METADATA__H_
#define __WBEM_METADATA__H_

#include "esscpol.h"
#include <parmdefs.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>

class ESSCLI_POLARITY CMetaData : public IWbemMetaData
{
protected:
    long m_lRef;

public:
    CMetaData() : m_lRef(0){}
    virtual ~CMetaData(){}

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    STDMETHOD(GetClass)(LPCWSTR wszName, IWbemContext* pContext, 
                            IWbemClassObject** ppClass);

public:
    virtual HRESULT GetClass(LPCWSTR wszName, IWbemContext* pContext,
                            _IWmiObject** ppClass) = 0;
};

class ESSCLI_POLARITY CStandardMetaData : public CMetaData
{
protected:
    IWbemServices* m_pNamespace;
public:
    CStandardMetaData(IWbemServices* pNamespace);
    ~CStandardMetaData();

    virtual HRESULT GetClass(LPCWSTR wszName, IWbemContext* pContext,
                            _IWmiObject** ppClass);
    void Clear();
};


class ESSCLI_POLARITY CContextMetaData
{
protected:
    CMetaData* m_pMeta;
    IWbemContext* m_pContext;
public:
    CContextMetaData(CMetaData* pMeta, IWbemContext* pContext);
    ~CContextMetaData();

    HRESULT GetClass(LPCWSTR wszName, _IWmiObject** ppClass);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\wmiauthz.cpp ===
#include "precomp.h"
#include "wmiauthz.h"



/**************************************************************************
  Win32 Authz prototypes
***************************************************************************/

typedef BOOL (WINAPI*PAuthzAccessCheck)(
    IN DWORD Flags,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN AUTHZ_AUDIT_EVENT_HANDLE AuditInfo OPTIONAL,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE pAuthzHandle OPTIONAL );

typedef BOOL (WINAPI*PAuthzInitializeResourceManager)(
    IN DWORD AuthzFlags,
    IN PFN_AUTHZ_DYNAMIC_ACCESS_CHECK pfnAccessCheck OPTIONAL,
    IN PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN PFN_AUTHZ_FREE_DYNAMIC_GROUPS pfnFreeDynamicGroups OPTIONAL,
    IN PCWSTR szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE pAuthzResourceManager
    );

typedef BOOL (WINAPI*PAuthzInitializeContextFromSid)(
    IN DWORD Flags,
    IN PSID UserSid,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    );

typedef BOOL (WINAPI*PAuthzInitializeContextFromToken)(
    IN HANDLE TokenHandle,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    );

typedef BOOL (WINAPI*PAuthzFreeContext)( AUTHZ_CLIENT_CONTEXT_HANDLE );
typedef BOOL (WINAPI*PAuthzFreeResourceManager)( AUTHZ_RESOURCE_MANAGER_HANDLE );

BOOL WINAPI ComputeDynamicGroups(
                  IN  AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
                  IN  PVOID                       Args,
                  OUT PSID_AND_ATTRIBUTES         *pSidAttrArray,
                  OUT PDWORD                      pSidCount,
                  OUT PSID_AND_ATTRIBUTES         *pRestrictedSidAttrArray,
                  OUT PDWORD                      pRestrictedSidCount
                  )
{
    BOOL bRet;
    *pRestrictedSidAttrArray = NULL;
    *pRestrictedSidCount = 0;

    //
    // if sid is not local system, then don't need to do anything.
    // 

    *pSidAttrArray = NULL;
    *pSidCount = 0;

    if ( !*(BOOL*)(Args) )
    {
        bRet = TRUE;
    }
    else
    {
        //
        // need to add authenticated users and everyone groups.
        // 
    
        PSID_AND_ATTRIBUTES psa = new SID_AND_ATTRIBUTES[2];
    
        if ( psa != NULL )
        {
            ZeroMemory( psa, sizeof(SID_AND_ATTRIBUTES)*2 );

            SID_IDENTIFIER_AUTHORITY wid = SECURITY_WORLD_SID_AUTHORITY;
            SID_IDENTIFIER_AUTHORITY ntid = SECURITY_NT_AUTHORITY;
       
            if ( bRet = AllocateAndInitializeSid( &wid,
                                                  1,
                                                  SECURITY_WORLD_RID,
                                                  0,0,0,0,0,0,0,
                                                  &psa[0].Sid ) )
            {
                if ( bRet = AllocateAndInitializeSid( &ntid,
                                                      1,
                                              SECURITY_AUTHENTICATED_USER_RID,
                                                      0,0,0,0,0,0,0,
                                                      &psa[1].Sid ) )
                {
                    *pSidCount = 2;
                    *pSidAttrArray = psa;
                }
                else
                {
                    FreeSid( &psa[0].Sid );
                    delete [] psa;
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
            else
            {
                delete [] psa;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }
        }
        else
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            bRet = FALSE;
        }
    }

    return bRet;
}
    
void WINAPI FreeDynamicGroups( PSID_AND_ATTRIBUTES psa )
{
    if ( psa != NULL )
    {
        FreeSid( psa[0].Sid );
        FreeSid( psa[1].Sid );
        delete [] psa;
    }
}

/**************************************************************************
  CWmiAuthzApi
***************************************************************************/

#define FUNCMEMBER(FUNC) P ## FUNC m_fp ## FUNC;

class CWmiAuthzApi
{
    HMODULE m_hMod;
    
public:

    FUNCMEMBER(AuthzInitializeContextFromToken)
    FUNCMEMBER(AuthzInitializeContextFromSid)
    FUNCMEMBER(AuthzInitializeResourceManager)
    FUNCMEMBER(AuthzAccessCheck)
    FUNCMEMBER(AuthzFreeContext)
    FUNCMEMBER(AuthzFreeResourceManager)

    CWmiAuthzApi() { ZeroMemory( this, sizeof(CWmiAuthzApi) ); }
    ~CWmiAuthzApi() { if ( m_hMod != NULL ) FreeLibrary( m_hMod ); }
   
    HRESULT Initialize();
};

#define SETFUNC(FUNC) \
    m_fp ## FUNC = (P ## FUNC) GetProcAddress( m_hMod, #FUNC ); \
    if ( m_fp ## FUNC == NULL ) return WBEM_E_NOT_SUPPORTED;  

HRESULT CWmiAuthzApi::Initialize()
{
    m_hMod = LoadLibrary( TEXT("authz") );

    if ( m_hMod == NULL )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    SETFUNC(AuthzInitializeContextFromToken)
    SETFUNC(AuthzInitializeResourceManager)
    SETFUNC(AuthzInitializeContextFromSid)
    SETFUNC(AuthzInitializeContextFromToken)
    SETFUNC(AuthzAccessCheck)
    SETFUNC(AuthzFreeContext)
    SETFUNC(AuthzFreeResourceManager)

    return WBEM_S_NO_ERROR;
};
    
/**************************************************************************
  CWmiAuthz
***************************************************************************/

#define CALLFUNC(API,FUNC) (*API->m_fp ## FUNC)

CWmiAuthz::CWmiAuthz( CLifeControl* pControl )
: CUnkBase<IWbemTokenCache,&IID_IWbemTokenCache>( pControl ), 
  m_hResMgr(NULL), m_pApi(NULL), m_pAdministratorsSid(NULL), 
  m_pLocalSystemSid(NULL)
{

}

HRESULT CWmiAuthz::EnsureInitialized()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );
        
    if ( m_hResMgr != NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    //
    // try to create the API object. 
    // 
    
    if ( m_pApi == NULL )
    {
        m_pApi = new CWmiAuthzApi;

        if ( m_pApi == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    
        hr = m_pApi->Initialize();
    
        if ( FAILED(hr) )
        {
            delete m_pApi;
            m_pApi = NULL;
            return hr;
        }
    }

    //
    // initialize the authz res mgr.
    //

    if ( !CALLFUNC(m_pApi,AuthzInitializeResourceManager)
            ( AUTHZ_RM_FLAG_NO_AUDIT,
              NULL, 
              ComputeDynamicGroups, 
              FreeDynamicGroups, 
              NULL, 
              &m_hResMgr ) )

    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // allocate and initialize well known sids for authz special casing.
    //

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    
    if ( !AllocateAndInitializeSid( &id, 
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID, 
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,0,0,0,0,0, 
                                    &m_pAdministratorsSid) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( !AllocateAndInitializeSid( &id, 
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0,0,0,0,0,0,0, 
                                    &m_pLocalSystemSid) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiAuthz::Shutdown()
{
    return WBEM_S_NO_ERROR;
}

CWmiAuthz::~CWmiAuthz()
{
    if ( m_hResMgr != NULL )
    {
        CALLFUNC(m_pApi,AuthzFreeResourceManager)( m_hResMgr );
    }

    if ( m_pApi != NULL )
    {
        delete m_pApi;
    }

    if ( m_pAdministratorsSid != NULL )
    {
        FreeSid( m_pAdministratorsSid );
    }

    if ( m_pLocalSystemSid != NULL )
    {
        FreeSid( m_pLocalSystemSid );
    }
}

STDMETHODIMP CWmiAuthz::GetToken( const BYTE* pSid, IWbemToken** ppToken )
{
    HRESULT hr;

    *ppToken = NULL;

    hr = EnsureInitialized();

    if ( SUCCEEDED( hr ) )
    {
        AUTHZ_CLIENT_CONTEXT_HANDLE hCtx = NULL;
        LUID luid;

        ZeroMemory( &luid, sizeof(LUID) );
        
        DWORD dwFlags = 0;
        BOOL bLocalSystem = FALSE;

        if ( EqualSid( PSID(pSid), m_pAdministratorsSid ) )
        {
            //
            // this is a group sid, so specify this in the flags so 
            // authz can handle it properly.
            // 
            dwFlags = AUTHZ_SKIP_TOKEN_GROUPS;
        }
        else if ( EqualSid( PSID(pSid), m_pLocalSystemSid ) )
        {
            //
            // authz doesn't handle local system so have to workaround 
            // by disabling authz's group computation and do it ourselves.
            // 
            bLocalSystem = TRUE;
            dwFlags = AUTHZ_SKIP_TOKEN_GROUPS;
        }

        if ( !CALLFUNC(m_pApi,AuthzInitializeContextFromSid)( dwFlags,
                                                              PSID(pSid), 
                                                              m_hResMgr,
                                                              NULL,
                                                              luid,
                                                              &bLocalSystem,
                                                              &hCtx ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        *ppToken = new CWmiAuthzToken( this, hCtx );

        if ( *ppToken == NULL )
        {
            CALLFUNC(m_pApi,AuthzFreeContext)(hCtx);
            return WBEM_E_OUT_OF_MEMORY;
        }

        (*ppToken)->AddRef();
    
        return WBEM_S_NO_ERROR;
    }

    return hr;
}

/***************************************************************************
  CWmiAuthzToken
****************************************************************************/

CWmiAuthzToken::CWmiAuthzToken( CWmiAuthz* pOwner, AUTHZ_CLIENT_CONTEXT_HANDLE hCtx )
: CUnkBase<IWbemToken,&IID_IWbemToken>(NULL), m_hCtx(hCtx), m_pOwner(pOwner)
{
    //
    // we want to keep the owner alive, in case the caller has released theirs
    // 
    m_pOwner->AddRef();
}

CWmiAuthzToken::~CWmiAuthzToken()
{
    CWmiAuthzApi* pApi = m_pOwner->GetApi();
    CALLFUNC(pApi,AuthzFreeContext)(m_hCtx);
    m_pOwner->Release();
}

STDMETHODIMP CWmiAuthzToken::AccessCheck( DWORD dwDesiredAccess,
                                          const BYTE* pSD, 
                                          DWORD* pdwGrantedAccess )       
{
    HRESULT hr;

    AUTHZ_ACCESS_REQUEST AccessReq;
    ZeroMemory( &AccessReq, sizeof(AUTHZ_ACCESS_REQUEST) );
    AccessReq.DesiredAccess = dwDesiredAccess;
    
    AUTHZ_ACCESS_REPLY AccessRep;
    DWORD dwError;
 
    ZeroMemory( &AccessRep, sizeof(AUTHZ_ACCESS_REPLY) );
    AccessRep.GrantedAccessMask = pdwGrantedAccess;
    AccessRep.ResultListLength = 1;
    AccessRep.Error = &dwError;
    AccessRep.SaclEvaluationResults = NULL;

    CWmiAuthzApi* pApi = m_pOwner->GetApi();

    if ( !CALLFUNC(pApi,AuthzAccessCheck)( 0,
                                           m_hCtx, 
                                           &AccessReq, 
                                           NULL, 
                                           PSECURITY_DESCRIPTOR(pSD), 
                                           NULL, 
                                           NULL, 
                                           &AccessRep, 
                                           NULL ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\precomp.h ===
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <ole2.h>
#include <windows.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\wmiauthz.h ===
#ifndef __WMIAUTHZ_H__
#define __WMIAUTHZ_H__

#include <wbemint.h>
#include <authz.h>
#include <unk.h>
#include <sync.h>

    
class CWmiAuthzApi;

/**************************************************************************
  CWmiAuthz
***************************************************************************/

class CWmiAuthz : public CUnkBase<IWbemTokenCache, &IID_IWbemTokenCache>
{
    CCritSec m_cs;
    BOOL m_bInit;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_hResMgr;
    CWmiAuthzApi* m_pApi;
    PSID m_pLocalSystemSid, m_pAdministratorsSid;
    
    HRESULT EnsureInitialized();

public:

    CWmiAuthz( CLifeControl* pControl );
    ~CWmiAuthz();

    CWmiAuthzApi* GetApi() { return m_pApi; }

    STDMETHOD(GetToken)( const BYTE* pSid, IWbemToken** ppToken );
    STDMETHOD(Shutdown)();
};

/***************************************************************************
  CWmiAuthzToken
****************************************************************************/

class CWmiAuthzToken : public CUnkBase<IWbemToken, &IID_IWbemToken>
{
    AUTHZ_CLIENT_CONTEXT_HANDLE m_hCtx;
    CWmiAuthz* m_pOwner;

public:
    
    CWmiAuthzToken( CWmiAuthz* pOwner, AUTHZ_CLIENT_CONTEXT_HANDLE hCtx );
    ~CWmiAuthzToken();

    STDMETHOD(AccessCheck)( DWORD dwDesiredAccess, 
                            const BYTE* pSD, 
                            DWORD* pdwGrantedAccess);        
};

/****************************************************************************
  WILL NOT BE COMPILED IN PRESENCE OF AUTHZ LIBRARY
*****************************************************************************/


#ifndef __AUTHZ_H__


/***************************************************************************
  CWmiNoAuthzToken
****************************************************************************/


class CWmiNoAuthzToken : public CUnkBase<IWbemToken, &IID_IWbemToken>
{
    CNtSid m_Sid;

public:

    CWmiNoAuthzToken( PSID pSid ) : m_Sid( pSid ) {}

    STDMETHOD( AccessCheck )( DWORD dwDesiredAccess, 
                              const BYTE* pSD, 
                              DWORD* pdwGrantedAccess );        
};


#endif
 
#endif __WMIAUTHZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\scenarios\makefile.inc ===
$(O)\crlntmpl.mof $(O)\crlntmpl.mfl :
    mofcomp -amendment:ms_409 -MOF:$(O)\crlntmpl.mof -MFL:$(O)\crlntmpl.mfl crlntmpl.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplassc.cpp ===
#include "precomp.h"
#include <assert.h>
#include <pathutl.h>
#include <arrtempl.h>
#include "tmplassc.h"

const LPCWSTR g_wszTmplAssocClass = L"MSFT_TemplateToTargetAssociation";
const LPCWSTR g_wszAssocTarget = L"Target";
const LPCWSTR g_wszAssocTmpl = L"Template";
const LPCWSTR g_wszTmplInfoClass = L"MSFT_TemplateInfo";
const LPCWSTR g_wszInfoTmpl = L"Tmpl";
const LPCWSTR g_wszInfoName = L"Name";
const LPCWSTR g_wszInfoTargets =  L"Targets";
const LPCWSTR g_wszQueryLang = L"WQL";
const LPCWSTR g_wszTmplInfoQuery = L"SELECT * FROM MSFT_TemplateInfo";

HRESULT CTemplateAssocProvider::Init( IWbemServices* pSvc, 
                                      LPWSTR wszNamespace,
                                      IWbemProviderInitSink* pInitSink )
{
    HRESULT hr;

    hr = pSvc->GetObject( CWbemBSTR(g_wszTmplAssocClass), 
                          0, 
                          NULL, 
                          &m_pTmplAssocClass, 
                          NULL );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    m_pSvc = pSvc;
    m_wsNamespace = wszNamespace;

    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
}

HRESULT CTemplateAssocProvider::GetObject( BSTR bstrPath, 
                                           IWbemObjectSink* pResHndlr )
{
    CRelativeObjectPath RelPath;
 
    if ( !RelPath.Parse( bstrPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ParsedObjectPath* pPath = RelPath.m_pPath;

    assert( pPath->m_pClass != NULL );

    if ( wbem_wcsicmp( pPath->m_pClass, g_wszTmplAssocClass ) != 0 )
    {
        return WBEM_E_NOT_FOUND;
    }

    if ( pPath->m_dwNumKeys != 2 ||
         wbem_wcsicmp( pPath->m_paKeys[0]->m_pName, g_wszAssocTmpl ) != 0  ||
         wbem_wcsicmp( pPath->m_paKeys[1]->m_pName, g_wszAssocTarget ) != 0 || 
         V_VT(&pPath->m_paKeys[0]->m_vValue) != VT_BSTR ||
         V_VT(&pPath->m_paKeys[1]->m_vValue) != VT_BSTR )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    CRelativeObjectPath TemplatePath, TargetPath;

    //
    // we need to normalize the paths before calling GetInstances.
    //

    if ( !TemplatePath.Parse( V_BSTR(&pPath->m_paKeys[0]->m_vValue)) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    if ( !TargetPath.Parse( V_BSTR(&pPath->m_paKeys[1]->m_vValue)) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // the tmpl obj path can be a fully qualified path, so make sure to add
    // the namespace back on if necessary.  We should not add it back on
    // if the namespace is specified, but does not name this namespace.
    //

    WString wsTargetPath;
    LPCWSTR wszTargetPath = TargetPath.GetPath();
    LPCWSTR wszNamespace = TargetPath.m_pPath->GetNamespacePart();

/*
    if ( wszNamespace != NULL && wbem_wcsicmp( wszNamespace, m_wsNamespace ) != 0 )
    {
        wsTmplObjPath = L"\\\\";
        wsTmplObjPath += wszNamespace;
        wsTmplObjPath += L":";
        wsTmplObjPath += wszTmplObjPath;
        wszTmplObjPath = wsTmplObjPath;
    }
*/
    
    HRESULT hr = GetInstances( TemplatePath.GetPath(),
                               wszTargetPath, 
                               pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

//
// wszTemplate is used to scope the query for the Assoc Info objects.(optional)
// wszTmplObjPath is used to filter the returned objects. (optional).
//
HRESULT CTemplateAssocProvider::GetInstances( LPCWSTR wszTemplate, 
                                              LPCWSTR wszTargetPath,
                                              IWbemObjectSink* pResHndlr )
{
    HRESULT hr;
    
    CWbemBSTR bsTmplInfoQuery = g_wszTmplInfoQuery;

    CWbemPtr<IEnumWbemClassObject> pTmplInfoObjs;

    if ( wszTemplate != NULL )
    {
        WString wsTmp = wszTemplate;
        WString wsTmp2 = wsTmp.EscapeQuotes();
        bsTmplInfoQuery += L" WHERE Id = \"";
        bsTmplInfoQuery += wsTmp2;
        bsTmplInfoQuery += L"\"";
    }
           
    hr = m_pSvc->ExecQuery( CWbemBSTR(g_wszQueryLang),
                            bsTmplInfoQuery,
                            WBEM_FLAG_FORWARD_ONLY,
                            NULL,
                            &pTmplInfoObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }

    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
	assert( cObjs ==  1 );
        
        //
        // enumerate all of the instantiated refs and create the associations. 
        //

        CPropVar vTargets;

        hr = pTmplInfo->Get( g_wszInfoTargets, 0, &vTargets, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vTargets.CheckType(VT_BSTR|VT_ARRAY)) )
        {
            return hr;
        }

        CPropSafeArray<BSTR> saTargets( V_ARRAY(&vTargets) );

        CPropVar vName;

        hr = pTmplInfo->Get( g_wszInfoName, 0, &vName, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vName.CheckType( VT_BSTR )) )
        {
            return hr;
        }

        for( ULONG i=0; i < saTargets.Length(); i++ )
        {
            //
            // Perform filtering if necessary 
            //

            if ( wszTargetPath != NULL && 
                 wbem_wcsicmp( wszTargetPath, saTargets[i] ) != 0 )
            {
                continue;
            }
         
            //
            // now can create the association instance.
            //

            CWbemPtr<IWbemClassObject> pAssoc;  

            hr = m_pTmplAssocClass->SpawnInstance( 0, &pAssoc );

            if ( FAILED(hr) )
            {
                return hr;
            }

            VARIANT var;
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = saTargets[i];

            hr = pAssoc->Put( g_wszAssocTarget, 0, &var, NULL );

            if ( FAILED(hr) )
            {
                return hr;
            }

            hr = pAssoc->Put( g_wszAssocTmpl, 0, &vName, NULL );

            if ( FAILED(hr) )
            {
                return hr;
            }

            hr = pResHndlr->Indicate( 1, &pAssoc );
            
            if ( FAILED(hr) )
            {
                return hr;
            }

            if ( wszTargetPath != NULL )
            {
                return WBEM_S_NO_ERROR;
            }
        }

        if ( wszTargetPath != NULL )
        {
            return WBEM_S_NO_ERROR;
        }

        hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );
    }

    return hr;
}

HRESULT 
CTemplateAssocProvider::GetAllInstances( LPWSTR wszClassname,
                                         IWbemObjectSink* pResHndlr )
{
    HRESULT hr = GetInstances( NULL, NULL, pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

CTemplateAssocProvider::CTemplateAssocProvider( CLifeControl* pCtl, 
                                                IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}

void* CTemplateAssocProvider::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }

    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CTemplateAssocProvider::XServices::XServices(CTemplateAssocProvider* pProv)
: CImpl< IWbemServices, CTemplateAssocProvider> ( pProv )
{

}

CTemplateAssocProvider::XInitialize::XInitialize(CTemplateAssocProvider* pProv)
: CImpl< IWbemProviderInit, CTemplateAssocProvider> ( pProv )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplassc.h ===
#ifndef __TMPLASSC_H__
#define __TMPLASSC_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <unk.h>
#include "tmplprov.h"

class CTemplateAssocProvider : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl<IWbemProviderInit,CTemplateAssocProvider>
    {
        XInitialize( CTemplateAssocProvider* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, wszNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl<IWbemServices, CTemplateAssocProvider>
    {
        XServices( CTemplateAssocProvider* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetObject( strObjectPath, pResponseHandler );
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetAllInstances( strClass, pResponseHandler );
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    CWbemPtr<IWbemServices> m_pSvc;    
    WString m_wsNamespace;
    CWbemPtr<IWbemClassObject> m_pTmplAssocClass;
    
public:
    
    CTemplateAssocProvider( CLifeControl* pCtl = NULL, IUnknown* pUnk = NULL );
    void* GetInterface( REFIID riid );

    HRESULT GetInstances( LPCWSTR wszTemplatePath,
                          LPCWSTR wszTmplObjPath, 
                          IWbemObjectSink* pRespHndlr );
public:

    HRESULT Init( IWbemServices* pSvc, 
                  LPWSTR wszNamespace, 
                  IWbemProviderInitSink* pInitSink );

    HRESULT GetObject( BSTR bstrPath, IWbemObjectSink* pResponseHndlr );

    HRESULT GetAllInstances( LPWSTR wszClassname,
                             IWbemObjectSink* pResponseHndlr );
};

#endif // __TMPLASSC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplcomn.cpp ===
#include "precomp.h"
#include <pathutl.h>
#include "tmplcomn.h"

/****************************************************************************
  GetTemplateName() - Fetches value for specified prop name.  Value can be 
  taken from the template object or from an instantiated target object.
*****************************************************************************/

const LPCWSTR g_wszBuilderAlias = L"__BUILDER";

HRESULT GetTemplateValue( LPCWSTR wszPropName,
                          IWbemClassObject* pTmpl,
                          BuilderInfoSet& rBldrInfoSet,
                          VARIANT* pvValue )
{
    HRESULT hr;

    VariantInit( pvValue );

    //
    // This property may exist on the template obejct or it may exist on the
    // instantiated target from this template.  The presence of the builder
    // alias will tell us which one it is.
    //

    WCHAR* pwch = wcschr( wszPropName, '.' );

    if ( pwch == NULL )
    {
        return pTmpl->Get( wszPropName, 0, pvValue, NULL, NULL );
    }
 
    int cAliasName = pwch - wszPropName;
    int cBldrAliasName = wcslen( g_wszBuilderAlias );

    if ( cAliasName != cBldrAliasName || 
         wbem_wcsnicmp( wszPropName, g_wszBuilderAlias, cAliasName ) != 0 )
    {
        //
        // TODO : support embedded object template arguments.
        //
        return WBEM_E_NOT_SUPPORTED;
    }

    LPCWSTR wszBldrName = pwch + 1;
        
    pwch = wcschr( wszBldrName, '.' );

    if ( pwch == NULL )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    int cBldrName = pwch - wszBldrName;

    // 
    // find the builder info using the name.
    //
    
    BuilderInfoSetIter Iter;

    for( Iter = rBldrInfoSet.begin(); Iter != rBldrInfoSet.end(); Iter++ )
    {
        BuilderInfo& rInfo = (BuilderInfo&)*Iter;

        if ( rInfo.m_wsName.Length() != cBldrName || 
             wbem_wcsnicmp( wszBldrName, rInfo.m_wsName, cBldrName ) != 0 )
        {
            continue;
        }

        if ( rInfo.m_wsNewTargetPath.Length() == 0 )
        {
            //
            // this will happen when the builders aren't ordered correctly
            //
            return WBEM_E_NOT_FOUND;
        }

        LPCWSTR wszName = pwch + 1;

        if ( wbem_wcsicmp( wszName, L"__RELPATH" ) == 0 )
        {
            V_VT(pvValue) = VT_BSTR;
            V_BSTR(pvValue) = SysAllocString( rInfo.m_wsNewTargetPath );

            if ( V_BSTR(pvValue) == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            return WBEM_S_NO_ERROR;
        }

        //
        // the name currently must identify a key propery.
        //

        CRelativeObjectPath TargetPath;
        
        if ( !TargetPath.Parse( rInfo.m_wsNewTargetPath ) )
        {
            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        ParsedObjectPath* pTargetPath = TargetPath.m_pPath;

        //
        // look through the keys until we find one that matches propname,
        // then take its value.
        //
        
        for( DWORD i=0; i < pTargetPath->m_dwNumKeys; i++ )
        {
            LPCWSTR wszKey = pTargetPath->m_paKeys[i]->m_pName;
            
            //
            // TODO, if no prop name in key, then we should consult the 
            // target object we have in the builder info.
            // 

            if ( wszKey == NULL || wbem_wcsicmp( wszKey, pwch ) == 0 )
            {
                hr = VariantCopy(pvValue, &pTargetPath->m_paKeys[i]->m_vValue);
                
                if ( FAILED(hr) ) 
                {
                    return hr;
                }

                return WBEM_S_NO_ERROR;
            }
        }

        return WBEM_E_NOT_FOUND;
    }

    return WBEM_E_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplcomn.h ===
#ifndef __TMPLCOMN_H__
#define __TMPLCOMN_H__

#include <wstring.h>
#include <wbemcli.h>
#include <comutl.h>
#include <set>
#include <wstlallc.h>

struct ErrorInfo
{
    WString m_wsErrProp;
    WString m_wsErrStr;
    CWbemPtr<IWbemClassObject> m_pBuilder;
    CWbemPtr<IWbemClassObject> m_pTarget;
    CWbemPtr<IWbemClassObject> m_pExtErr;
};

struct BuilderInfo 
{ 
    CWbemPtr<IWbemClassObject> m_pBuilder;
    CWbemPtr<IWbemClassObject> m_pTarget;
    CWbemPtr<IWbemServices> m_pTargetSvc;
    WString m_wsName;
    WString m_wsTargetNamespace;
    WString m_wsExistingTargetPath;
    WString m_wsNewTargetPath;
    ULONG m_ulOrder;
};

typedef std::set<BuilderInfo,std::less<BuilderInfo>,wbem_allocator<BuilderInfo> > BuilderInfoSet;
typedef BuilderInfoSet::iterator BuilderInfoSetIter;

HRESULT GetTemplateValue( LPCWSTR wszPropName,
                          IWbemClassObject* pTmpl,
                          BuilderInfoSet& rBldrInfoSet,
                          VARIANT* pvValue );
 
#endif __TMPLCOMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplprov.h ===
#ifndef __TMPLPROV_H__
#define __TMPLPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>
#include <comutl.h>
#include <wstring.h>
#include "tmplcomn.h"

/***************************************************************************
  CTemplateProvider
****************************************************************************/

class CTemplateProvider : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl< IWbemProviderInit, CTemplateProvider>
    {
        XInitialize( CTemplateProvider* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, wszNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl< IWbemServices, CTemplateProvider>
    {
        XServices( CTemplateProvider* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetObject( strObjectPath, pResponseHandler );
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return m_pObject->PutInstance( pInst, lFlags, pResponseHandler );
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->DeleteInstance( strObjectPath, pResponseHandler);
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetAllInstances( strClass, pResponseHandler );
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    WString m_wsNamespace;
    WString m_wsFullNamespace;
    
    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemObjectSink> m_pEventSink;
    CWbemPtr<IWbemDecoupledBasicEventProvider> m_pDES;
    
    CWbemPtr<IWbemClassObject> m_pTargetAssocClass;
    CWbemPtr<IWbemClassObject> m_pTmplInfoClass;
    CWbemPtr<IWbemClassObject> m_pErrorInfoClass;
    CWbemPtr<IWbemClassObject> m_pModifyEventClass;
    CWbemPtr<IWbemClassObject> m_pCreateEventClass;
    CWbemPtr<IWbemClassObject> m_pDeleteEventClass;

    HRESULT GetErrorObj( ErrorInfo& rInfo, IWbemClassObject** ppErrObj );

    HRESULT FireIntrinsicEvent( IWbemClassObject* pClass, 
                                IWbemClassObject* pTarget,
                                IWbemClassObject* pPrev );

    HRESULT StoreTmplInfo( BSTR bstrTmplPath, 
                           IWbemClassObject* pTmpl,
                           BuilderInfoSet& rBldrInfoSet );
    
    HRESULT DeleteTargets( LPCWSTR wszTmplPath, 
                           LPWSTR* wszTargetPaths,
                           ULONG cTargetPaths );

    HRESULT ValidateTemplate( IWbemClassObject* pTmpl, ErrorInfo& rErrInfo );

    HRESULT PutTarget( IWbemClassObject* pTmpl, 
                       BSTR bstrTmplPath,
                       BuilderInfo& rBldrInfo,
                       ErrorInfo& rErrInfo ); 

    HRESULT CheckOptimization( BuilderInfo& rBldrInfo );

    HRESULT DeriveTmplInfoPath( IWbemClassObject* pTmpl,
                                CWbemBSTR& rbstrTmplInfoPath, 
                                CWbemBSTR& rbstrTmplPath );

    HRESULT TmplInfoFromTmplPath( BSTR bstrTmplPath,IWbemClassObject** ppTmpl);

    HRESULT PutInstance( IWbemClassObject* pObj,
                         long lFlags,
                         CWbemBSTR& rbsTmplPath,
                         ErrorInfo& rErrInfo );

public:
    
    CTemplateProvider( CLifeControl* pCtl = NULL, IUnknown* pUnk = NULL );
    void* GetInterface( REFIID riid );
    ~CTemplateProvider();

    HRESULT Init( IWbemServices* pSvc, 
                  LPWSTR wszNamespace, 
                  IWbemProviderInitSink* pInitSink );

    HRESULT DeleteInstance( BSTR bstrPath, IWbemObjectSink* pRspHndlr );

    HRESULT PutInstance( IWbemClassObject* pObj, 
                         long lFlags, 
                         IWbemObjectSink* pRspHndlr );
    
    HRESULT GetObject( BSTR bstrPath, IWbemObjectSink* pResponseHndlr );
    HRESULT GetAllInstances( LPWSTR wszClassname,
                             IWbemObjectSink* pResponseHndlr );
};

#endif // __TMPLPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsinst.h ===
#ifndef __TRANSIENT_INSTANCE__H_
#define __TRANSIENT_INSTANCE__H_

class CTransientInstance
{
protected:
    IWbemObjectAccess* m_pObj;

public:
    CTransientInstance(){}
    ~CTransientInstance()
    {
        if(m_pObj)
            m_pObj->Release();
    }

    void* operator new(size_t stReal, size_t stExtra)
    {
        void* p = ::operator new(stReal + stExtra);
        memset(p, 0, stReal + stExtra);
        return p;
    }
    void operator delete(void* p, size_t)
    {
        ::operator delete(p);
    }

    INTERNAL IWbemObjectAccess* GetObjectPtr() {return m_pObj;}
    void SetObjectPtr(IWbemObjectAccess* pObj)
    {
        if(m_pObj) m_pObj->Release();
        m_pObj = pObj;
        if(m_pObj) m_pObj->AddRef();
    }

    void* GetOffset(size_t nOffset)
    {
        return ((BYTE*)this) + sizeof(CTransientInstance) + nOffset;
    }
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplprov.cpp ===
#include "precomp.h"
#include <pathutl.h>
#include <arrtempl.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemutil.h>
#include <winntsec.h>
#include "tmplprov.h"
#include "tmplassc.h"
#include "tmplsubs.h"

// Function pointer type used with LoadMofFiles entrypoint in wbemupgd.dll
typedef BOOL ( WINAPI *PFN_LOAD_MOF_FILES )(wchar_t* pComponentName, const char* rgpszMofFilename[]);

class CAutoRevert
{
public:
    ~CAutoRevert() { CoRevertToSelf(); }
};


const LPCWSTR g_wszQueryLang = L"WQL";
const LPCWSTR g_wszRelpath = L"__RelPath";
const LPCWSTR g_wszClass = L"__Class";
const LPCWSTR g_wszIndicationRelated = L"__IndicationRelated";
const LPCWSTR g_wszCreatorSid = L"CreatorSID";
const LPCWSTR g_wszTargetAssoc = L"MSFT_TargetToTemplateAssociation";
const LPCWSTR g_wszTmplInfo = L"MSFT_TemplateInfo";
const LPCWSTR g_wszTmplBldr = L"MSFT_TemplateBuilder";
const LPCWSTR g_wszNamespaceProp = L"NamespaceProperty";
const LPCWSTR g_wszControllingProp = L"ControllingProperty";
const LPCWSTR g_wszName = L"Name";
const LPCWSTR g_wszOrder = L"Order";
const LPCWSTR g_wszTarget = L"Target";
const LPCWSTR g_wszTmplPropQualifier = L"tmpl_prop_val";
const LPCWSTR g_wszTmplSubstQualifier = L"tmpl_subst_str";
const LPCWSTR g_wszTmplNotNullQualifier = L"notnull";
const LPCWSTR g_wszAssocTmpl = L"Template";
const LPCWSTR g_wszAssocTarget = L"Target";
const LPCWSTR g_wszInfoTmpl = L"Template";
const LPCWSTR g_wszInfoName = L"Name";
const LPCWSTR g_wszInfoTargets =  L"Targets";
const LPCWSTR g_wszInfoBuilders =  L"Builders";
const LPCWSTR g_wszActive =  L"Active";

const LPCWSTR g_wszBldrQuery =
     L"SELECT * FROM MSFT_TemplateBuilder WHERE Template = '";
const LPCWSTR g_wszTmplInfoQuery = 
     L"SELECT * FROM MSFT_TemplateInfo WHERE Template ISA '";

const LPCWSTR g_wszModifyEvent = L"__InstanceModificationEvent";
const LPCWSTR g_wszDeleteEvent = L"__InstanceDeletionEvent";
const LPCWSTR g_wszCreateEvent = L"__InstanceCreationEvent";
const LPCWSTR g_wszTargetInstance = L"TargetInstance";
const LPCWSTR g_wszPreviousInstance = L"PreviousInstance";
const LPCWSTR g_wszErrInfoClass = L"MSFT_TemplateErrorStatus";
const LPCWSTR g_wszErrProp = L"Property";
const LPCWSTR g_wszErrStr = L"ErrorStr";
const LPCWSTR g_wszErrBuilder = L"Builder";
const LPCWSTR g_wszErrTarget = L"Target";
const LPCWSTR g_wszErrExtStatus = L"ExtendedStatus";

const LPCWSTR g_wszTmplEventProvName= L"Microsoft WMI Template Event Provider";

#define SUBST_STRING_DELIM '%'

/****************************************************************************
  Utility Functions
*****************************************************************************/

bool operator< ( const BuilderInfo& rA, const BuilderInfo& rB )
{
    if ( rA.m_ulOrder == rB.m_ulOrder )
    {
        return wbem_wcsicmp( rA.m_wsName, rB.m_wsName ) < 0;
    }
    return rA.m_ulOrder < rB.m_ulOrder;
}

inline HRESULT ClassObjectFromVariant( VARIANT* pv, IWbemClassObject** ppObj )
{
    return V_UNKNOWN(pv)->QueryInterface(IID_IWbemClassObject, (void**)ppObj );
}
   
inline void InfoPathFromTmplPath(WString wsTmplPath, CWbemBSTR& bstrInfoPath)
{    
    WString wsTmp = wsTmplPath.EscapeQuotes();
    bstrInfoPath += g_wszTmplInfo;
    bstrInfoPath += L"=\"";
    bstrInfoPath += wsTmp;
    bstrInfoPath += L"\"";
}

HRESULT GetServicePtr( LPCWSTR wszNamespace, IWbemServices** ppSvc )
{
    HRESULT hr;
    *ppSvc = NULL;

    CWbemPtr<IWbemLocator> pLocator;
    
    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWbemLocator, 
                           (void**)&pLocator );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pLocator->ConnectServer( (LPWSTR)wszNamespace, NULL, NULL, 
                                    NULL, 0, NULL, NULL, ppSvc );
}

//
// This method performs substitution on the specified string.
//

HRESULT FixupString( IWbemClassObject* pTmpl,
                     BuilderInfoSet& rBldrInfoSet,
                     LPCWSTR wszSubstStr,
                     ErrorInfo& rErrInfo,
                     BSTR* pbstrOut )
{
    HRESULT hr;
    
    *pbstrOut = NULL;

    CTextLexSource LexSrc( wszSubstStr );
    CTemplateStrSubstitution Parser( LexSrc, pTmpl, rBldrInfoSet );
    
    hr = Parser.Parse( pbstrOut );
    
    if ( FAILED(hr) )
    {
        if ( Parser.GetTokenText() != NULL )
        {
            rErrInfo.m_wsErrStr = Parser.GetTokenText();
        }
    }

    return hr;
}
 
HRESULT HandleTmplPropQualifier( IWbemClassObject* pTmpl,
                                 BuilderInfoSet& rBldrInfoSet,
                                 VARIANT* pvarArgName,
                                 VARIANT* pvarValue,
                                 ErrorInfo& rErrInfo )
{
    HRESULT hr;

    if ( V_VT(pvarArgName) != VT_BSTR )
    {
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    }
    
    hr = GetTemplateValue( V_BSTR(pvarArgName), 
                           pTmpl, 
                           rBldrInfoSet, 
                           pvarValue );
    
    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrStr = V_BSTR(pvarArgName);
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT HandleTmplSubstQualifier( IWbemClassObject* pTmpl,
                                  BuilderInfoSet& rBldrInfoSet,
                                  CIMTYPE CimType,
                                  VARIANT* pvarSubstStr,
                                  VARIANT* pvarValue,
                                  ErrorInfo& rErrInfo )
{
    HRESULT hr;
    BSTR bstrOut;

    if ( V_VT(pvarSubstStr) == VT_BSTR && CimType == CIM_STRING )
    {
        hr = FixupString( pTmpl, 
                          rBldrInfoSet,
                          V_BSTR(pvarSubstStr), 
                          rErrInfo, 
                          &bstrOut );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        V_VT(pvarValue) = VT_BSTR;
        V_BSTR(pvarValue) = bstrOut;
        
        return hr;
    }

    //
    // we have an array of strings to resolve.
    //

    if ( V_VT(pvarSubstStr) != (VT_BSTR | VT_ARRAY) )
    {
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    }

    CPropSafeArray<BSTR> saSubstStr( V_ARRAY(pvarSubstStr) );
    BSTR* abstrValue;

    V_VT(pvarValue) = VT_ARRAY | VT_BSTR;
    V_ARRAY(pvarValue) = SafeArrayCreateVector(VT_BSTR,0,saSubstStr.Length());
    hr = SafeArrayAccessData( V_ARRAY(pvarValue), (void**)&abstrValue );
    _DBG_ASSERT( SUCCEEDED(hr) );

    for( long i=0; i < saSubstStr.Length(); i++ )
    {    
        hr = FixupString( pTmpl, 
                          rBldrInfoSet,
                          saSubstStr[i], 
                          rErrInfo, 
                          &bstrOut );

        if ( FAILED(hr) )
        {
            break;
        }

        abstrValue[i] = bstrOut;
    }

    SafeArrayUnaccessData( V_ARRAY(pvarValue) );

    if ( FAILED(hr) )
    {
        VariantClear( pvarValue );
        return hr;
    }

    return WBEM_S_NO_ERROR;
}
 
HRESULT GetExistingTargetRefs( IWbemClassObject* pTmplInfo,
                               BuilderInfoSet& rBldrInfoSet,
                               CWStringArray& rOrphanedTargets )  
{
    HRESULT hr;

    CPropVar vBldrNames, vTargetRefs;

    hr = pTmplInfo->Get( g_wszInfoBuilders, 0, &vBldrNames, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vBldrNames.CheckType(VT_BSTR | VT_ARRAY) ))
    {
        return hr;
    }

    hr = pTmplInfo->Get( g_wszInfoTargets, 0, &vTargetRefs, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTargetRefs.CheckType(VT_BSTR | VT_ARRAY) ))
    {
        return hr;
    }

    CPropSafeArray<BSTR> saBldrNames( V_ARRAY(&vBldrNames) );
    CPropSafeArray<BSTR> saTargetRefs( V_ARRAY(&vTargetRefs) );

    if ( saBldrNames.Length() != saTargetRefs.Length() )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // try to match each bldr name with one in the BldrInfoSet 
    //

    for( ULONG i=0; i < saBldrNames.Length(); i++ )
    {
        BuilderInfoSetIter Iter;

        for( Iter = rBldrInfoSet.begin(); Iter != rBldrInfoSet.end(); Iter++ )
        {
            BuilderInfo& rInfo = (BuilderInfo&)*Iter;

            if ( *saTargetRefs[i] == '\0' )
            {
                // 
                // this happens when the an error occurred on instantiation
                // preventing the entire target set to be instantiated.
                // there will be no more refs in the list and there's nothing
                // more that can be done.
                // 
                return WBEM_S_NO_ERROR;
            }

            if ( wbem_wcsicmp( saBldrNames[i], rInfo.m_wsName ) == 0 )
            {
                rInfo.m_wsExistingTargetPath = saTargetRefs[i];
                break;
            }
        }

        if ( Iter == rBldrInfoSet.end() )
        {
            if ( rOrphanedTargets.Add( saTargetRefs[i] ) < 0 )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT GetBuilderInfo( IWbemClassObject* pTmpl,
                        IWbemClassObject* pBuilder,
                        IWbemServices* pDefaultSvc,
                        BuilderInfo& rBldrInfo,
                        ErrorInfo& rErrInfo )
{
    HRESULT hr;

    rBldrInfo.m_pBuilder = pBuilder;

    //
    // Target Object
    //
    
    CPropVar vTarget;
    
    hr = pBuilder->Get( g_wszTarget, 0, &vTarget, NULL, NULL );
    
    if ( FAILED(hr) || FAILED(hr=vTarget.CheckType(VT_UNKNOWN)))
    {
        return hr;
    }

    hr = ClassObjectFromVariant( &vTarget, &rBldrInfo.m_pTarget ); 

    if ( FAILED(hr) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Builder Name
    //

    CPropVar vName;
    
    hr = pBuilder->Get( g_wszName, 0, &vName, NULL, NULL );
    
    if ( FAILED(hr) || FAILED(hr=vName.CheckType(VT_BSTR)))
    {
        return hr;
    }

    rBldrInfo.m_wsName = V_BSTR(&vName);

    //
    // Builder Order
    //
    
    CPropVar vOrder;
    
    hr = pBuilder->Get( g_wszOrder, 0, &vOrder, NULL, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    if ( V_VT(&vOrder) != VT_NULL )
    {
        if ( FAILED(hr=vOrder.SetType(VT_UI4)) )
        {
            return hr;
        }

        rBldrInfo.m_ulOrder = V_UI4(&vOrder);
    }
    else
    {
        rBldrInfo.m_ulOrder = 0;
    }

    //
    // Target Namespace 
    //

    CPropVar vNamespace, vNamespaceProp;

    hr = pBuilder->Get( g_wszNamespaceProp, 0, &vNamespaceProp, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vNamespaceProp) == VT_NULL )
    {
        //
        // no namespace prop, target will go in this namespace.
        //
        rBldrInfo.m_pTargetSvc = pDefaultSvc;
        return WBEM_S_NO_ERROR;
    }
    else if ( V_VT(&vNamespaceProp) != VT_BSTR )
    {
        return WBEM_E_CRITICAL_ERROR;
    }
        
    //
    // Get the target namespace using the namespace prop
    //

    hr = pTmpl->Get( V_BSTR(&vNamespaceProp), 0, &vNamespace, NULL, NULL );

    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrStr = V_BSTR(&vNamespaceProp);
        return hr;
    }

    if ( V_VT(&vNamespace) == VT_NULL )
    {
        rBldrInfo.m_pTargetSvc = pDefaultSvc;
        return WBEM_S_NO_ERROR;
    }
    else if ( V_VT(&vNamespace) != VT_BSTR )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // there is specified namespace.  obtain a connection to it.
    //

    hr = GetServicePtr( V_BSTR(&vNamespace), &rBldrInfo.m_pTargetSvc );

    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrStr = V_BSTR(&vNamespace);
        return hr;
    }

    rBldrInfo.m_wsTargetNamespace = V_BSTR(&vNamespace);

    return WBEM_S_NO_ERROR;
}

HRESULT GetEffectiveBuilders( IWbemClassObject* pTmpl,
                              IWbemServices* pSvc,
                              BuilderInfoSet& rBldrInfoSet,
                              ErrorInfo& rErrInfo )
{
    HRESULT hr;

    //
    // Get the name of the template class
    //
    
    CPropVar vTmplName;

    hr = pTmpl->Get( g_wszClass, 0, &vTmplName, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTmplName.CheckType( VT_BSTR ) ) )
    {
        return hr;
    }

    //
    // obtain the template builder objects associated with the template.
    //
    
    CWbemPtr<IEnumWbemClassObject> pBldrObjs;
    CWbemBSTR bstrQuery = g_wszBldrQuery;                        
    
    bstrQuery += V_BSTR(&vTmplName);
    bstrQuery += L"'";

    long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;

    hr = pSvc->ExecQuery( CWbemBSTR(g_wszQueryLang), 
                          bstrQuery, 
                          lFlags,
                          NULL, 
                          &pBldrObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }
        
    //
    // go through the builder objects and add them to the BuilderInfoSet. 
    // this data structure orders entries based on the order prop on the 
    // builder objects.
    //

    CWbemPtr<IWbemClassObject> pBuilder;
    CWbemPtr<IWbemClassObject> pTarget;
    ULONG cObjs;

    hr = pBldrObjs->Next( WBEM_INFINITE, 1, &pBuilder, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs == 1 );
     
        CPropVar vControlProp;

        // 
        // ignore builder objects where the value of any controlling 
        // property is either null or is a boolean and is false.
        //

        hr = pBuilder->Get(g_wszControllingProp, 0, &vControlProp, NULL, NULL);

        if ( FAILED(hr) )
        {
            return hr;
        }

        BOOL bUseBuilder = TRUE;

        if ( V_VT(&vControlProp) != VT_NULL )
        {
            if ( V_VT(&vControlProp) != VT_BSTR )
            {
                return WBEM_E_CRITICAL_ERROR;
            }

            CPropVar vControl;

            // 
            // now get the property from the template args using this name.
            //

            hr = pTmpl->Get( V_BSTR(&vControlProp), 0, &vControl, NULL, NULL );

            if ( FAILED(hr) )
            {
                rErrInfo.m_wsErrStr = V_BSTR(&vControlProp);
                rErrInfo.m_pBuilder = pBuilder;
                return hr;
            }
            
            if ( V_VT(&vControl) == VT_NULL || 
                 ( V_VT(&vControl) == VT_BOOL && 
                   V_BOOL(&vControl) == VARIANT_FALSE ) )
            {
                bUseBuilder = FALSE;
            }
        }

        if ( bUseBuilder )
        {
            BuilderInfo BldrInfo;
            
            hr = GetBuilderInfo( pTmpl, pBuilder, pSvc, BldrInfo, rErrInfo );
            
            if ( FAILED(hr) )
            {
                return hr;
            }
            
            rBldrInfoSet.insert( BldrInfo );
        }

        pBuilder.Release();

        hr = pBldrObjs->Next( WBEM_INFINITE, 1, &pBuilder, &cObjs );
    }

    return hr;
}

HRESULT ResolveParameterizedProps( IWbemClassObject* pTmpl,
                                   BuilderInfo& rBuilderInfo,
                                   BuilderInfoSet& rBldrInfoSet,
                                   ErrorInfo& rErrInfo )
{
    HRESULT hr;

    IWbemClassObject* pTarget = rBuilderInfo.m_pTarget;

    //
    // enumerate all props looking for ones with the tmpl qualifiers.
    // 

    hr = pTarget->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CIMTYPE CimType;
    CWbemBSTR bsProp;
    CPropVar vProp;

    hr = pTarget->Next( 0, &bsProp, &vProp, &CimType, NULL );

    while( hr == WBEM_S_NO_ERROR )
    {   
        CWbemPtr<IWbemQualifierSet> pQualSet;

        hr = pTarget->GetPropertyQualifierSet( bsProp, &pQualSet );
 
        if ( FAILED(hr) )
        {
            break;
        }

        CPropVar vQProp;

        hr = pQualSet->Get( g_wszTmplPropQualifier, 0, &vQProp, NULL );

        if ( hr == WBEM_S_NO_ERROR )
        {
            VariantClear( &vProp );

            hr = HandleTmplPropQualifier( pTmpl, 
                                          rBldrInfoSet,
                                          &vQProp, 
                                          &vProp, 
                                          rErrInfo );
 
            pQualSet->Delete( g_wszTmplPropQualifier );
        }
        else if ( hr == WBEM_E_NOT_FOUND )
        {
            hr = pQualSet->Get( g_wszTmplSubstQualifier, 0, &vQProp, NULL );

            if ( hr == WBEM_S_NO_ERROR )
            {
                VariantClear( &vProp );

                hr = HandleTmplSubstQualifier( pTmpl, 
                                               rBldrInfoSet,
                                               CimType, 
                                               &vQProp, 
                                               &vProp, 
                                               rErrInfo );

                pQualSet->Delete( g_wszTmplSubstQualifier );
            }
            else if ( hr == WBEM_E_NOT_FOUND )
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
        
        if ( FAILED(hr) )
        {
            break;
        }

        // 
        // only assign if not null.
        //
        if ( V_VT(&vProp) != VT_NULL )
        {
            _DBG_ASSERT( V_VT(&vProp) != VT_EMPTY );

            hr = pTarget->Put( bsProp, 0, &vProp, 0 );
            
            if ( FAILED(hr) )
            {
                break;
            }

            VariantClear( &vProp );
        }

        bsProp.Free();

        hr = pTarget->Next( 0, &bsProp, &vProp, &CimType, NULL );
    }

    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrProp = bsProp;
        return hr;
    }


    return WBEM_S_NO_ERROR;
}

HRESULT CreateTargetAssociation( LPCWSTR wszTmplRef,
                                 LPCWSTR wszTargetRef,
                                 IWbemClassObject* pTmplAssocClass,
                                 IWbemServices* pSvc )
{
    HRESULT hr;

    CWbemPtr<IWbemClassObject> pAssoc;
    hr = pTmplAssocClass->SpawnInstance( 0, &pAssoc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    VARIANT var;
    
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)wszTmplRef;
    
    hr = pAssoc->Put( g_wszAssocTmpl, 0, &var, NULL ); 
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    V_BSTR(&var) = (BSTR)wszTargetRef;

    hr = pAssoc->Put( g_wszAssocTarget, 0, &var, NULL ); 
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // before creating the association, see if one already exists.  
    // Again, this is a hack optimization to get around the slowness of
    // core and ess on instance operation events for static instances.

    //
    // BEGINHACK
    //

    CPropVar vRelpath;

    hr = pAssoc->Get( g_wszRelpath, 0, &vRelpath, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vRelpath.CheckType( VT_BSTR ) ) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pExisting;

    hr = pSvc->GetObject( V_BSTR(&vRelpath), 0, NULL, &pExisting, NULL );

    if ( hr == WBEM_S_NO_ERROR )
    {
        return hr;
    }

    //
    // ENDHACK
    //

    return pSvc->PutInstance( pAssoc, 0, NULL, NULL );
}

/****************************************************************************
  CTemplateProvider
*****************************************************************************/

HRESULT CTemplateProvider::GetErrorObj( ErrorInfo& rInfo, 
                                        IWbemClassObject** ppErrObj )
{
    HRESULT hr;
    VARIANT var;

    CWbemPtr<IWbemClassObject> pErrObj;

    hr = m_pErrorInfoClass->SpawnInstance( 0, &pErrObj );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    if ( rInfo.m_wsErrProp.Length() > 0 )
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = rInfo.m_wsErrProp;

        hr = pErrObj->Put( g_wszErrProp, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_wsErrStr.Length() > 0 )
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = rInfo.m_wsErrStr;

        hr = pErrObj->Put( g_wszErrStr, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_pBuilder != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = rInfo.m_pBuilder;

        hr = pErrObj->Put( g_wszErrBuilder, 0, &var, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_pTarget != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = rInfo.m_pTarget;

        hr = pErrObj->Put( g_wszErrTarget, 0, &var, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_pExtErr != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = rInfo.m_pExtErr;
        
        hr = pErrObj->Put( g_wszErrExtStatus, 0, &var, NULL );
    }

    pErrObj->AddRef();
    *ppErrObj = pErrObj;

    return hr;
}

HRESULT CTemplateProvider::ValidateTemplate( IWbemClassObject* pTmpl, 
                                             ErrorInfo& rErrInfo )
{
    HRESULT hr;

    //
    // for now, we need just need to check that 'notnull' props don't have
    // null values.
    // 

    //
    // first need to fetch class object.
    //

    CPropVar vClassName;
    CWbemPtr<IWbemClassObject> pTmplClass;

    hr = pTmpl->Get( g_wszClass, 0, &vClassName, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vClassName.CheckType( VT_BSTR ) ) )
    {
        return hr;
    }
      
    hr = m_pSvc->GetObject(V_BSTR(&vClassName), 0, NULL, &pTmplClass, NULL);
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pTmplClass->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemBSTR bsProp;
    
    hr = pTmplClass->Next( 0, &bsProp, NULL, NULL, NULL );

    while( hr == WBEM_S_NO_ERROR )
    {   
        CWbemPtr<IWbemQualifierSet> pQualSet;

        hr = pTmplClass->GetPropertyQualifierSet( bsProp, &pQualSet );
 
        if ( FAILED(hr) )
        {
            break;
        }

        hr = pQualSet->Get( g_wszTmplNotNullQualifier, 0, NULL, NULL );

        if ( hr == WBEM_S_NO_ERROR )
        {
            VARIANT varValue;

            hr = pTmpl->Get( bsProp, 0, &varValue, NULL, NULL );
            
            if ( FAILED(hr) )
            {
                break;
            }

            if ( V_VT(&varValue) == VT_NULL )
            {
                rErrInfo.m_wsErrStr = bsProp;
                return WBEM_E_ILLEGAL_NULL;
            }

            VariantClear( &varValue );
        }
        else if ( hr != WBEM_E_NOT_FOUND )
        {
            break;
        }

        bsProp.Free();

        hr = pTmplClass->Next( 0, &bsProp, NULL, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CTemplateProvider::Init( IWbemServices* pSvc, 
                                 LPWSTR wszNamespace,
                                 IWbemProviderInitSink* pInitSink )
{
    ENTER_API_CALL

    HRESULT hr;
    
    hr = pSvc->GetObject( CWbemBSTR(g_wszTmplInfo), 
                          0, 
                          NULL, 
                          &m_pTmplInfoClass, 
                          NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszTargetAssoc), 
                          0, 
                          NULL, 
                          &m_pTargetAssocClass, 
                          NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszModifyEvent), 
                          0, 
                          NULL, 
                          &m_pModifyEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszCreateEvent), 
                          0, 
                          NULL, 
                          &m_pCreateEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszDeleteEvent), 
                          0, 
                          NULL, 
                          &m_pDeleteEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszErrInfoClass), 
                          0, 
                          NULL, 
                          &m_pErrorInfoClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }


    m_pSvc = pSvc;
    m_wsNamespace = wszNamespace;

    //
    // register our decoupled event provider 
    //

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Register( 0,
                           NULL,
                           NULL,
                           NULL,
                           wszNamespace,
                           g_wszTmplEventProvName,
                           NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the decoupled event sink
    //

    hr = m_pDES->GetSink( 0, NULL, &m_pEventSink );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // also need to store namespace with server name.
    //

    WCHAR awchBuff[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG cBuff = MAX_COMPUTERNAME_LENGTH + 1;

    BOOL bRes = GetComputerNameW( awchBuff, &cBuff );
    
    if ( FALSE == bRes )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    m_wsFullNamespace = L"\\\\";
    m_wsFullNamespace += awchBuff;
    m_wsFullNamespace += L"\\";
    m_wsFullNamespace += m_wsNamespace;

    return pInitSink->SetStatus( WBEM_S_INITIALIZED , 0 );

    EXIT_API_CALL
}


HRESULT CTemplateProvider::StoreTmplInfo( BSTR bstrTmplPath,
                                          IWbemClassObject* pTmpl,
                                          BuilderInfoSet& rBldrInfoSet )     
{
    HRESULT hr;
    VARIANT var;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    //
    // create both the target and builder safe arrays. We need to 
    // discover how many builders actually have paths for created targets 
    // because those are the only target and builder info elements that we 
    // want to store.
    // 

    int cElem = 0;
    BuilderInfoSetIter Iter;

    for( Iter=rBldrInfoSet.begin(); Iter!=rBldrInfoSet.end(); Iter++)
    {
        BuilderInfo& rInfo = (BuilderInfo&)*Iter;

        if ( rInfo.m_wsNewTargetPath.Length() > 0 )
        {
            cElem++;
        }
    }
    
    SAFEARRAY *psaTargets, *psaBuilders; 

    psaTargets = SafeArrayCreateVector( VT_BSTR, 0, cElem );

    if ( psaTargets == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    psaBuilders = SafeArrayCreateVector( VT_BSTR, 0, cElem );

    if ( psaBuilders == NULL )
    {
        SafeArrayDestroy( psaTargets );
        return WBEM_E_OUT_OF_MEMORY;
    }

    CPropVar vTargets, vBuilders;
    V_VT(&vTargets) = VT_BSTR | VT_ARRAY;
    V_VT(&vBuilders) = VT_BSTR | VT_ARRAY;
    V_ARRAY(&vTargets) = psaTargets;
    V_ARRAY(&vBuilders) = psaBuilders;

    //
    // copy the refs into the arrays.
    //

    CPropSafeArray<BSTR> saTargets( psaTargets );
    CPropSafeArray<BSTR> saBuilders( psaBuilders );

    int iElem = 0;

    for( Iter=rBldrInfoSet.begin(); Iter!=rBldrInfoSet.end(); Iter++ )
    {
        BuilderInfo& rInfo = (BuilderInfo&)*Iter;

        if ( rInfo.m_wsNewTargetPath.Length() > 0 )
        {
            _DBG_ASSERT( iElem < cElem );

            saBuilders[iElem] = SysAllocString( rInfo.m_wsName);
            saTargets[iElem] = SysAllocString( rInfo.m_wsNewTargetPath );

            if ( saBuilders[iElem] == NULL || saTargets[iElem] == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            iElem++;
        }
    }
    
    //
    // set the tmpl info props
    //

    hr = m_pTmplInfoClass->SpawnInstance( 0, &pTmplInfo );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    hr = pTmplInfo->Put( g_wszInfoTargets, 0, &vTargets, 0 );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pTmplInfo->Put( g_wszInfoBuilders, 0, &vBuilders, 0 );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrTmplPath;

    hr = pTmplInfo->Put( g_wszInfoName, 0, &var, 0 );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pTmpl;
    
    hr = pTmplInfo->Put( g_wszInfoTmpl, 0, &var, 0 );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
 
    return m_pSvc->PutInstance( pTmplInfo, 0, NULL, NULL );
}    


HRESULT CTemplateProvider::FireIntrinsicEvent( IWbemClassObject* pClass,
                                               IWbemClassObject* pTarget, 
                                               IWbemClassObject* pPrev )
{
    HRESULT hr;

    //  
    // Spawn an instance
    //

    CWbemPtr<IWbemClassObject> pEvent;
    hr = pClass->SpawnInstance( 0, &pEvent );
    
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Set target instance
    //

    VARIANT var;
 
    _DBG_ASSERT( pTarget != NULL );

    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pTarget;

    hr = pEvent->Put( g_wszTargetInstance, 0, &var, 0 );
    
    if( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // Set previous instance
    //

    if( pPrev != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = pPrev;
        
        hr = pEvent->Put( g_wszPreviousInstance, 0, &var, 0);
        
        if( FAILED(hr) )
        {
            return hr;
        }
    }

    //  
    // Fire it off
    //

    return m_pEventSink->Indicate( 1, &pEvent );
}

HRESULT CTemplateProvider::CheckOptimization( BuilderInfo& rBldrInfo )
{
    HRESULT hr;

    //
    // first fetch any existing object, if not there, then no optimization
    // can be performed.  
    //

    if ( rBldrInfo.m_wsExistingTargetPath.Length() == 0 )
    {
        return WBEM_S_FALSE;
    }

    IWbemClassObject* pTarget = rBldrInfo.m_pTarget;
    
    //
    // now fetch the existing object. 
    //

    
    CWbemPtr<IWbemClassObject> pOldTarget;
    
    hr = rBldrInfo.m_pTargetSvc->GetObject( rBldrInfo.m_wsExistingTargetPath, 
                                            0, 
                                            NULL, 
                                            &pOldTarget, 
                                            NULL );
    if ( FAILED(hr) )
    {
        //
        // it doesn't exist.  normally this shouldn't happen, but someone 
        // may have removed the object behind the scenes. 
        // 
        return WBEM_S_FALSE;
    }

    //
    // now we need to see if the target object has key holes.  If so, then 
    // we will steal the values from the existing object.  This is acceptable
    // because either the target object will assume the identity of the 
    // existing object or the existing object will be orphaned and removed.
    // We want to try to avoid orphan-ing objects if possible so we try to 
    // reuse identity where appropriate.
    //

    hr = pTarget->BeginEnumeration( WBEM_FLAG_KEYS_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemBSTR bsKey;
    CPropVar vKey;

    hr = pTarget->Next( 0, &bsKey, &vKey, NULL, NULL );

    while( hr == WBEM_S_NO_ERROR )
    {
        if ( V_VT(&vKey) == VT_NULL )
        {
            //
            // don't need to check values here. will catch in CompareTo().
            // the two instances may not even be of the same class, so 
            // don't error check here.  
            //
            pOldTarget->Get( bsKey, 0, &vKey, 0, NULL );
            pTarget->Put( bsKey, 0, &vKey, NULL );
        }

        bsKey.Free();
        VariantClear(&vKey);

        hr = pTarget->Next( 0, &bsKey, &vKey, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropVar vClass;
    hr = pOldTarget->Get( g_wszClass, 0, &vClass, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vClass.CheckType(VT_BSTR)) )
    {
        return hr;
    }

    if ( wbem_wcsicmp( V_BSTR(&vClass), L"__FilterToConsumerBinding" ) == 0 || 
         wbem_wcsicmp( V_BSTR(&vClass), L"__EventFilter" ) == 0 || 
         pOldTarget->InheritsFrom( L"__EventConsumer" ) == WBEM_S_NO_ERROR )
    {
        //
        // This is a major HACK, but then so is this whole function -  
        // Core should be fast enough to handle a 'redundant' PutInstance().  
        // Anyways, we have to be able to perform the CompareTo and 
        // ignore system props as well as the SID on Event Registration 
        // classes.  CompareTo will handle the system props, but it won't 
        // treat the creator sid as a system prop.
        //

        VARIANT varSid;
        PSID pOldSid;
        CNtSid CallerSid( CNtSid::CURRENT_THREAD );

        if ( CallerSid.GetStatus() != CNtSid::NoError )
            return WBEM_E_OUT_OF_MEMORY;

        hr = pOldTarget->Get( g_wszCreatorSid, 0, &varSid, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        _DBG_ASSERT( V_VT(&varSid) == (VT_ARRAY | VT_UI1) );
        hr = SafeArrayAccessData( V_ARRAY(&varSid), &pOldSid );
        _DBG_ASSERT( SUCCEEDED(hr) );

        BOOL bRes = EqualSid( pOldSid, CallerSid.GetPtr() );
        
        SafeArrayUnaccessData( V_ARRAY(&varSid) );
        VariantClear( &varSid );

        if ( !bRes )
        {
            return WBEM_S_FALSE;
        }

        //
        // Sids are the same, NULL out the sid prop so CompareTo() will work.
        //
    
        V_VT(&varSid) = VT_NULL;
        
        hr = pOldTarget->Put( g_wszCreatorSid, 0, &varSid, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pTarget->Put( g_wszCreatorSid, 0, &varSid, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // now compare them to see if they are the same ...
    //

    long lFlags = WBEM_FLAG_IGNORE_OBJECT_SOURCE |
                  WBEM_FLAG_IGNORE_QUALIFIERS |
                  WBEM_FLAG_IGNORE_FLAVOR |
                  WBEM_FLAG_IGNORE_CASE ;

    hr = pOldTarget->CompareTo( lFlags, pTarget );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( hr == WBEM_S_DIFFERENT )
    {
        return WBEM_S_FALSE;
    }

    return WBEM_S_NO_ERROR;
}


//
// wszTmplPath is assumed to be Relative. 
//

HRESULT CTemplateProvider::DeleteTargets( LPCWSTR wszTmplPath,
                                          LPWSTR* awszTargetPaths,
                                          ULONG cTargetPaths )
{    
    HRESULT hr;

    //
    // Make sure we go in reverse order, since this array was orinally 
    // built up during construction of these objects (which happens in 
    // ascending order).
    //

    //
    // Now construct the path for the association inst that will accompany
    // the target.  This assoc allows us to go from the target to 
    // the tmpl. We want to delete this along with our target.
    // 

    //
    // The path that identifies the target is always relative.  
    // this is because the assoc inst will always live in the same namespace
    // as the target. The path that identifies the tmpl is always 
    // fully qualified.  
    // 

    WString wsTmplPath = m_wsFullNamespace;
    wsTmplPath += L":";
    wsTmplPath += wszTmplPath;
    
    WString wsTmplRelPath = wszTmplPath;
    WString wsEscTmplRelPath = wsTmplRelPath.EscapeQuotes();
    WString wsEscTmplPath = wsTmplPath.EscapeQuotes();

    for( long i=cTargetPaths-1; i >= 0; i-- )
    {
        //
        // start constructing the assoc path.  It will depend on whether
        // the assoc lives in the same or another namespace.
        //

        CWbemBSTR bstrAssocPath = g_wszTargetAssoc;
    
        bstrAssocPath += L".";
        bstrAssocPath += g_wszAssocTmpl;
        bstrAssocPath += L"=\"";

        //
        // determine if the ref is in our namespace. If not then we 
        // have to get the svc ptr for that namespace. Make sure that
        // the path ends up being relative though.
        // 

        CRelativeObjectPath RelPath;

        if ( !RelPath.Parse( (LPWSTR)awszTargetPaths[i] ) )
        {
            // 
            // this should never happen (unless the db is corrupted)
            //
            return WBEM_E_INVALID_OBJECT_PATH;
        }

        CWbemPtr<IWbemServices> pSvc = m_pSvc;

        LPCWSTR wszNamespace = RelPath.m_pPath->GetNamespacePart();

        if ( wszNamespace == NULL )
        {
            bstrAssocPath += wsEscTmplRelPath;
        }
        else
        {
            bstrAssocPath += wsEscTmplPath;

            hr = GetServicePtr( wszNamespace, &pSvc );
            
            if ( FAILED(hr) )
            {
                return hr;            
            }
        }

        CWbemBSTR bstrRelPath = RelPath.GetPath();
        
        hr = pSvc->DeleteInstance( bstrRelPath, 0, NULL, NULL ); 
        
        //
        // don't check ... try to delete as many as possible.
        //

        //
        // finish constructing the path for the association now. 
        //
        
        bstrAssocPath += L"\",";
        bstrAssocPath += g_wszAssocTarget;
        bstrAssocPath += L"=\"";
        
        WString tmp2 = RelPath.GetPath();
        WString tmp = tmp2.EscapeQuotes();

        bstrAssocPath += tmp;
        bstrAssocPath += L"\"";

        //
        // also delete the association as well... 
        //

        hr = pSvc->DeleteInstance( bstrAssocPath, 0, NULL, NULL );

        //
        // again, don't check ..
        //
    }

    return WBEM_S_NO_ERROR;
}
 
HRESULT CTemplateProvider::DeleteInstance( BSTR bstrTmplPath, 
                                           IWbemObjectSink* pResponseHndlr )
{
    ENTER_API_CALL

    HRESULT hr;
    CWbemBSTR bstrInfoPath;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        return hr;
    }

    CAutoRevert ar;

    //
    // Get the associated tmpl info object.
    //

    CRelativeObjectPath RelPath;

    if ( !RelPath.Parse( bstrTmplPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    InfoPathFromTmplPath( RelPath.GetPath(), bstrInfoPath );

    hr = m_pSvc->GetObject( bstrInfoPath, 0, NULL, &pTmplInfo, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropVar vTargetPaths;
    
    hr = pTmplInfo->Get( g_wszInfoTargets, 0, &vTargetPaths, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTargetPaths.CheckType(VT_ARRAY|VT_BSTR)) )
    {
        return hr;
    }

    CPropSafeArray<BSTR> saTargetPaths( V_ARRAY(&vTargetPaths) );

    //
    // delete the tmpl info object and all of its associated instances.
    //
    
    hr = DeleteTargets( RelPath.GetPath(), 
                        saTargetPaths.GetArray(), 
                        saTargetPaths.Length() );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->DeleteInstance( bstrInfoPath, 0, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now get the tmpl obj from the info obj. Use this to send an 
    // intrinsic event ...
    //

    CPropVar vTmpl;
    CWbemPtr<IWbemClassObject> pTmpl;

    hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vTmpl, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    ClassObjectFromVariant( &vTmpl, &pTmpl );

    hr = FireIntrinsicEvent( m_pDeleteEventClass, pTmpl, NULL );

    return pResponseHndlr->SetStatus( WBEM_STATUS_COMPLETE, hr, NULL, NULL );

    EXIT_API_CALL
}

HRESULT CTemplateProvider::GetObject( BSTR bstrTmplPath, 
                                      IWbemObjectSink* pResHndlr )
{
    ENTER_API_CALL

    HRESULT hr;
    VARIANT var;
    CWbemBSTR bstrInfoPath;
    CWbemPtr<IWbemClassObject> pTmpl;
    CWbemPtr<IWbemClassObject> pTmplInfo;

    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        return hr;
    }

    CAutoRevert ar;
    
    //
    // Get the associated tmpl info object 
    //

    CRelativeObjectPath RelPath;

    if ( !RelPath.Parse( bstrTmplPath ) )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    InfoPathFromTmplPath( RelPath.GetPath(), bstrInfoPath );

    hr = m_pSvc->GetObject( bstrInfoPath, 0, NULL, &pTmplInfo, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Get the embedded tmpl object from it. 
    //

    CPropVar vTmpl;

    hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vTmpl, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    ClassObjectFromVariant( &vTmpl, &pTmpl );

    hr = pResHndlr->Indicate( 1, &pTmpl );

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, hr, NULL, NULL );

    EXIT_API_CALL
}

HRESULT CTemplateProvider::PutTarget( IWbemClassObject* pTmpl, 
                                      BSTR bstrTmplPath,
                                      BuilderInfo& rBldrInfo,
                                      ErrorInfo& rErrInfo )
{ 
    HRESULT hr;

    //
    // See if the activation even needs to be performed.
    //
    
    hr = CheckOptimization( rBldrInfo );

    if ( hr == WBEM_S_NO_ERROR )
    {
        rBldrInfo.m_wsNewTargetPath = rBldrInfo.m_wsExistingTargetPath;
        return hr;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }
       
    CWbemPtr<IWbemCallResult> pCallResult;
          
    hr = rBldrInfo.m_pTargetSvc->PutInstance( rBldrInfo.m_pTarget, 
                                              WBEM_FLAG_RETURN_IMMEDIATELY, 
                                              NULL, 
                                              &pCallResult );            
    if ( SUCCEEDED(hr) )
    {
        HRESULT hr2 = pCallResult->GetCallStatus( INFINITE, &hr );

        if ( FAILED(hr2) )
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }
       
    if ( FAILED(hr) )
    {
        // 
        // see if there is an accompanying error object.
        //
        
        CWbemPtr<IErrorInfo> pErrorInfo;
        
        if ( ::GetErrorInfo( 0, &pErrorInfo ) == S_OK )
        {
            pErrorInfo->QueryInterface( IID_IWbemClassObject,
                                        (void**)&rErrInfo.m_pExtErr );
        }
        
        return hr;
    }
    
    CWbemBSTR bsTargetPath;

    //
    // if the provider doesn't retrun a path, then we'll get it from
    // from the tmpl object (which may not always be possible either)
    // if neither approach works, then return error.
    //

    hr = pCallResult->GetResultString( WBEM_INFINITE, &bsTargetPath );
    
    if ( FAILED(hr) )
    {
        CPropVar vRelpath;

        hr = pTmpl->Get( g_wszRelpath, 0, &vRelpath, NULL, NULL );

        if ( FAILED(hr) )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        if ( FAILED(hr=vRelpath.CheckType( VT_BSTR) ) )
        {
            return hr;
        }

        bsTargetPath = V_BSTR(&vRelpath);
    }

    CRelativeObjectPath TargetPath;
    
    if ( !TargetPath.Parse( bsTargetPath ) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    rBldrInfo.m_wsNewTargetPath = TargetPath.GetPath();

    //
    // now prefix targetpath with the appropriate namespace if necessary.  
    // This is part of the normalization process. 
    // This will only occur if there a namespace prop on the 
    // builder object.
    // 
    
    //
    // here we will also prepare the necessary paths for the association
    // which accompanies the template instance.  This assoc allows us to
    // go from the instance back to the template instance.  This assoc
    // will live in the same namespace as the instance. 
    //
    
    // 
    // if the assoc is in a different namespace than our namespace
    // we must make the tmpl path fully qualified.
    //
    
    CWbemPtr<IWbemClassObject> pTargetAssocClass;
    WString wsTmplPath;
    WString wsTargetPath;
    
    if ( rBldrInfo.m_wsTargetNamespace.Length() == 0  ) 
    {           
        //
        // when local namespace is used
        //
        pTargetAssocClass = m_pTargetAssocClass;
        wsTargetPath = TargetPath.GetPath();
        wsTmplPath = bstrTmplPath;
    }
    else
    {
        hr = rBldrInfo.m_pTargetSvc->GetObject( CWbemBSTR(g_wszTargetAssoc), 
                                                0, 
                                                NULL,
                                                &pTargetAssocClass, 
                                                NULL );
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        wsTargetPath += rBldrInfo.m_wsTargetNamespace;
        wsTargetPath += L":";
        wsTargetPath += TargetPath.GetPath();
        
        wsTmplPath = m_wsFullNamespace;
        wsTmplPath += L":";
        wsTmplPath += bstrTmplPath;
    }
    
    //
    // now create the static association between the tmpl object and 
    // tmpl. The reason for the static association is so we can assoc 
    // in the direction of template object --> template.  Remember that
    // we don't need the fully qualified path to the inst in the 
    // assoc obj since it will reside in the same namespace.
    //
    
    hr = CreateTargetAssociation( (LPCWSTR)wsTmplPath,
                                  TargetPath.GetPath(), 
                                  pTargetAssocClass,
                                  rBldrInfo.m_pTargetSvc );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateProvider::DeriveTmplInfoPath( IWbemClassObject* pTmpl,
                                               CWbemBSTR& rbstrTmplInfoPath, 
                                               CWbemBSTR& rbstrTmplPath )
{
    HRESULT hr;
    VARIANT var;

    hr = pTmpl->Get( g_wszRelpath, 0, &var, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&var) == VT_NULL )
    {
        // 
        // generate a key here ..
        //
        
        GUID guid;
        CoCreateGuid( &guid );
        CWbemBSTR bstrGuid( 256 );

        if ( StringFromGUID2( guid, bstrGuid, 256 ) == 0 )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // now go through key props ... 
        
        hr = pTmpl->BeginEnumeration( WBEM_FLAG_KEYS_ONLY  );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CWbemBSTR bstrName;
        CIMTYPE CimType;
        hr = pTmpl->Next( 0, &bstrName, NULL, &CimType, NULL );

        while( hr == WBEM_S_NO_ERROR )
        {
            if ( CimType != CIM_STRING )
            {       
                return WBEM_E_INVALID_OBJECT;
            }

            VARIANT var2;
            V_VT(&var2) = VT_BSTR;
            V_BSTR(&var2) = bstrGuid;
  
            hr = pTmpl->Put( bstrName, 0, &var2, NULL );
            
            if ( FAILED(hr) )
            {
                return hr;
            }

            bstrName.Free();
            hr = pTmpl->Next( 0, &bstrName, NULL, &CimType, NULL );
        }

        hr = pTmpl->Get( g_wszRelpath, 0, &var, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    _DBG_ASSERT( V_VT(&var) == VT_BSTR );

    //
    // normalize the path
    //

    CRelativeObjectPath RelPath;
    BOOL bRes = RelPath.Parse( V_BSTR(&var) );

    VariantClear( &var );

    if ( !bRes )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    rbstrTmplPath = RelPath.GetPath();

    InfoPathFromTmplPath( (BSTR)rbstrTmplPath, rbstrTmplInfoPath );

    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateProvider::PutInstance( IWbemClassObject* pTmpl, 
                                        long lFlags,
                                        IWbemObjectSink* pHndlr )
{
    ENTER_API_CALL

    HRESULT hr;
    ErrorInfo ErrInfo;
    CWbemPtr<IWbemClassObject> pErrObj;
    CWbemBSTR bsTmplPath;

    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        return hr;
    }

    CAutoRevert ar;
    
    hr = PutInstance( pTmpl, lFlags, bsTmplPath, ErrInfo );

    if ( FAILED(hr) )
    {
        GetErrorObj( ErrInfo, &pErrObj );
    }

    return pHndlr->SetStatus(WBEM_STATUS_COMPLETE, hr, bsTmplPath, pErrObj); 

    EXIT_API_CALL
}

HRESULT CTemplateProvider::PutInstance( IWbemClassObject* pTmpl, 
                                        long lFlags,
                                        CWbemBSTR& rbsTmplPath,
                                        ErrorInfo& rErrInfo )
{
    HRESULT hr;

    CWbemPtr<IWbemClassObject> pErrObj;

    lFlags &= 0x3; // only care about create/update flags...
 
    //
    // before doing anything else, validate the template ..
    //

    hr = ValidateTemplate( pTmpl, rErrInfo );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // obtain the normalized path to the template and while we're at it,
    // form the path of the associated template info object.
    //

    CWbemBSTR bsTmplInfoPath;

    hr = DeriveTmplInfoPath( pTmpl, bsTmplInfoPath, rbsTmplPath );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // see if there is already a tmpl obj existing
    //

    CWbemPtr<IWbemClassObject> pTmplInfo;

    hr = m_pSvc->GetObject( bsTmplInfoPath, 0, NULL, &pTmplInfo, NULL );

    //
    // check flags
    //

    if ( SUCCEEDED(hr) )
    {
        if ( lFlags & WBEM_FLAG_CREATE_ONLY )
        {
            return WBEM_E_ALREADY_EXISTS;
        }
    }
    else if ( hr == WBEM_E_NOT_FOUND )
    {
        if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
        {
            return WBEM_E_NOT_FOUND;
        }
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now see if the active property is set, if so, activate.
    // if this fails then the template is not derived from TemplateBase
    // ( which is allowed ).
    //

    CPropVar vActive;

    hr = pTmpl->Get( g_wszActive, 0, &vActive, NULL, NULL );

    if ( FAILED(hr) )
    {
        V_VT(&vActive) = VT_BOOL;
        V_BOOL(&vActive) = VARIANT_TRUE;
    }
    else if ( FAILED(hr=vActive.CheckType( VT_BOOL ) ) )
    {
        return hr;
    }

    BuilderInfoSet BldrInfoSet;
    
    if ( V_BOOL(&vActive) == VARIANT_TRUE )
    {
        // 
        // we first want to establish the effective template builder objects.
        // These are the bldrs that do not have a controlling tmpl arg or 
        // ones that do and it is true or not null.
        //

        hr = GetEffectiveBuilders( pTmpl, m_pSvc, BldrInfoSet, rErrInfo );

        if ( FAILED(hr) )
        { 
            return hr;
        }
    }

    //
    // get any existing references and while we're at it determine the
    // oprhaned targets.  Note that there is more than one way for a target
    // to be orphaned.  This can happen when a previously active builder 
    // becomes inactive for whatever reason.  It can also happen when the 
    // the same builder puts an object that has different key values than the
    // one it previously put.  In the next step we will only detect the former.
    // When we actually put the target, we will check for the latter case and
    // add it to the orphaned targets if necessary.
    // 

    CWStringArray awsOrphanedTargets;
    
    if ( pTmplInfo != NULL )
    {
        hr = GetExistingTargetRefs( pTmplInfo, 
                                    BldrInfoSet, 
                                    awsOrphanedTargets );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // activate each builder
    //
    
    BuilderInfoSetIter Iter;

    for( Iter = BldrInfoSet.begin(); Iter != BldrInfoSet.end(); Iter++ )
    {
        BuilderInfo& rBldrInfo = (BuilderInfo&)*Iter;
        
        //
        // first resolve the properties of the target object.
        //

        hr = ResolveParameterizedProps( pTmpl, 
                                        rBldrInfo, 
                                        BldrInfoSet, 
                                        rErrInfo );
        
        if ( SUCCEEDED(hr) )
        {
            hr = PutTarget( pTmpl, rbsTmplPath, rBldrInfo, rErrInfo );
        }

        if ( SUCCEEDED(hr) )
        {
            //
            // see if any previous target was orphaned in this last step.
            // we are guaranteed that the refs here are already normalized,
            // so o.k. to do a string compare.
            //
            
            if( rBldrInfo.m_wsExistingTargetPath.Length() != 0 && 
                rBldrInfo.m_wsNewTargetPath.Length() != 0 && 
                wbem_wcsicmp( rBldrInfo.m_wsExistingTargetPath, 
                          rBldrInfo.m_wsNewTargetPath ) != 0 )
            {
                awsOrphanedTargets.Add( rBldrInfo.m_wsExistingTargetPath );
            }
        }

        if ( FAILED(hr) )
        {
            rErrInfo.m_pBuilder = rBldrInfo.m_pBuilder;
            rErrInfo.m_pTarget = rBldrInfo.m_pTarget;
            break;
        }
    }

    //
    // delete the orphaned instances
    //
    
    LPCWSTR* awszOrhanedTargets = awsOrphanedTargets.GetArrayPtr();
    ULONG cOrhanedTargets = awsOrphanedTargets.Size();    
    DeleteTargets( rbsTmplPath, (LPWSTR*)awszOrhanedTargets, cOrhanedTargets );

    // 
    // store the information about the instatiated objs in the 
    // tmpl info object.  We do this regardless of the outcome of 
    // instantiating targets.  This is so the user can see how far they
    // got in the template, and also, so we can clean the existing instances
    // up every time.
    //

    HRESULT hr2 = StoreTmplInfo( rbsTmplPath, pTmpl, BldrInfoSet );

    if ( FAILED(hr) )
    {
        return hr;
    }
    else if ( FAILED(hr2) )
    {
        return hr2;
    }

    //
    // if this is a modification to a template instance, then remove any 
    // stale instances and fire instmod event.  If not, then just fire a 
    // creation event.
    //

    if ( pTmplInfo.m_pObj != NULL )
    {
        CPropVar vExistingTmpl;        
        CWbemPtr<IWbemClassObject> pExistingTmpl;

        hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vExistingTmpl, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vExistingTmpl.CheckType(VT_UNKNOWN)) )
        {
            return hr;
        }

        ClassObjectFromVariant( &vExistingTmpl, &pExistingTmpl );
        
        hr = FireIntrinsicEvent( m_pModifyEventClass, pTmpl, pExistingTmpl );
    }
    else
    {
        hr = FireIntrinsicEvent( m_pCreateEventClass, pTmpl, NULL );
    }
    
    return hr;
}

HRESULT CTemplateProvider::GetAllInstances( LPWSTR wszClassname, 
                                            IWbemObjectSink* pResponseHndlr )
{
    ENTER_API_CALL

    HRESULT hr; 
    CWbemPtr<IEnumWbemClassObject> pTmplInfoObjs;

    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        return hr;
    }

    CAutoRevert ar;

    CWbemBSTR bstrQuery = g_wszTmplInfoQuery;
    bstrQuery += wszClassname;
    bstrQuery += L"'";
    
    hr = m_pSvc->ExecQuery( CWbemBSTR(g_wszQueryLang), 
                            bstrQuery, 
                            WBEM_FLAG_FORWARD_ONLY, 
                            NULL, 
                            &pTmplInfoObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemPtr<IWbemClassObject> pTmplInfo;
    ULONG cObjs;

    hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {   
        _DBG_ASSERT( cObjs ==  1 );
        
        CWbemPtr<IWbemClassObject> pTmpl;
       
        CPropVar vTmpl;
        hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vTmpl, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vTmpl.CheckType( VT_UNKNOWN )) )
        {
            return hr;
        }

        ClassObjectFromVariant( &vTmpl, &pTmpl );

        hr = pResponseHndlr->Indicate( 1, &pTmpl );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResponseHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                      WBEM_S_NO_ERROR, 
                                      NULL, 
                                      NULL );

    EXIT_API_CALL
}

CTemplateProvider::CTemplateProvider( CLifeControl* pCtl, IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}

CTemplateProvider::~CTemplateProvider()
{
    if ( m_pDES != NULL )
    {
        m_pDES->UnRegister();
    }
}

void* CTemplateProvider::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }

    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CTemplateProvider::XServices::XServices( CTemplateProvider* pProv )
: CImpl< IWbemServices, CTemplateProvider> ( pProv )
{

}

CTemplateProvider::XInitialize::XInitialize( CTemplateProvider* pProv )
: CImpl< IWbemProviderInit, CTemplateProvider> ( pProv )
{

}

// {C486ABD2-27F6-11d3-865E-00C04F63049B}
static const CLSID CLSID_TemplateProvider =
{ 0xc486abd2, 0x27f6, 0x11d3, {0x86, 0x5e, 0x0, 0xc0, 0x4f, 0x63, 0x4, 0x9b} };
 
// {FD18A1B2-9E61-4e8e-8501-DB0B07846396}
static const CLSID CLSID_TemplateAssocProvider = 
{ 0xfd18a1b2, 0x9e61, 0x4e8e, {0x85, 0x1, 0xdb, 0xb, 0x7, 0x84, 0x63, 0x96} };

class CTemplateProviderServer : public CComServer
{
protected:

    HRESULT Initialize()
    {
        ENTER_API_CALL

        HRESULT hr;
        CWbemPtr<CBaseClassFactory> pFactory;
        
        pFactory = new CClassFactory<CTemplateProvider>( GetLifeControl() );

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_TemplateProvider,
                           pFactory,
                           TEXT("Template Provider"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

#if ( _WIN32_WINNT < 0x0501 )
        pFactory = new CClassFactory<CTemplateAssocProvider>(GetLifeControl());
        
        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        hr = AddClassInfo( CLSID_TemplateAssocProvider,
                           pFactory,
                           _T("Template Assoc Provider"), 
                           TRUE );

#endif

        return hr;

        EXIT_API_CALL
    }

    void Register()
    {
        //
        //  Load mofs and mfls during registration
        //
        HINSTANCE hinstWbemupgd = LoadLibrary(L"wbemupgd.dll");
        if (hinstWbemupgd)
        {
            PFN_LOAD_MOF_FILES pfnLoadMofFiles = (PFN_LOAD_MOF_FILES) GetProcAddress(hinstWbemupgd, "LoadMofFiles"); // no wide version of GetProcAddress
            if (pfnLoadMofFiles)
            {
                wchar_t*    wszComponentName = L"Tmplprov";
                const char* rgpszMofFilename[] = 
                {
                    "tmplprov.mof",
                    "tmplprov.mfl",
                    NULL
                };
                
                pfnLoadMofFiles(wszComponentName, rgpszMofFilename);
            }

            FreeLibrary(hinstWbemupgd);
        }
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplsubs.h ===
#ifndef __TMPLSUBS_H__
#define __TMPLSUBS_H__

#include <wstring.h>
#include <genlex.h>
#include <comutl.h>
#include <wbemcli.h>
#include "tmplcomn.h"

#define MAXARGS 2

class CTemplateStrSubstitution
{
    BOOL m_abArgListString[MAXARGS];
    WString m_awsArgList[MAXARGS];
    int m_cArgList;
    int m_nCurrentToken;
    LPWSTR m_wszTokenText;
    LPWSTR m_wszSubstTokenText;

    WString m_wsOutput;
    CGenLexer m_Lexer;
    CGenLexer* m_pSubstLexer; 
    CWbemPtr<IWbemClassObject> m_pTmplArgs;
    BuilderInfoSet& m_rBldrInfoSet;

    HRESULT Next();
    HRESULT SubstNext();

    HRESULT HandleConditionalSubstitution();
    HRESULT HandlePrefixedWhereSubstitution();
    HRESULT HandleTargetKeySubstitution();
    HRESULT HandleTmplArgSubstitution();

    HRESULT parse();
    HRESULT subst_string();
    HRESULT arglist();
    HRESULT arglist2();
    HRESULT arglist3();

public:

    CTemplateStrSubstitution( CGenLexSource& rLexer, 
                              IWbemClassObject* pTmplArgs,
                              BuilderInfoSet& rBldrInfoSet );

    LPCWSTR GetTokenText() { return m_wszTokenText; }
    
    HRESULT Parse( BSTR* pbstrOutput );
};


#endif // __TMPLSUBS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplsubs.cpp ===
#include "precomp.h"
#include <genlex.h>
#include <stdio.h>
#include <ql.h>
#include <arrtempl.h>
#include <assert.h>
#include <pathutl.h>
#include "tmplsubs.h"

/***************************************************************************
  Lex Table Defined for CTemplateStrSubstitution
****************************************************************************/

#define ST_SUBST1   3
#define ST_SUBST2   5
#define ST_NONSUBST 9

#define ST_EXTEN     13
#define ST_IDENT     16
#define ST_STRING1   23
#define ST_STRING2   26

#define TMPL_TOK_SUBST_STR                           256
#define TMPL_TOK_NONSUBST_STR                        257

#define TMPL_TOK_STRING                              258
#define TMPL_TOK_EXTENSION_IDENT                     259
#define TMPL_TOK_IDENT                               260
#define TMPL_TOK_OPEN_PAREN                          261
#define TMPL_TOK_CLOSE_PAREN                         262
#define TMPL_TOK_COMMA                               263
#define TMPL_TOK_EOF                                 264
#define TMPL_TOK_ERROR                               265

#define TMPL_CONDITIONAL_EXTENSION        L"ConditionalSubstitution"
#define TMPL_PREFIXED_WHERE_EXTENSION     L"PrefixedWhereClause"

#define TMPL_TOK_CONDITIONAL_EXTENSION               266
#define TMPL_TOK_PREFIXED_WHERE_EXTENSION            267

//
// The Tmpl_StrLexTable identifies Substitutable and Non-Substitutable
// tokens of an input string.
//

LexEl Tmpl_StrLexTable[] = 
{
// State    First   Last       New state,   Return tok,         Instruction
// =======================================================================

/* 0 */  '%',      GLEX_EMPTY, ST_SUBST1,    0,                 GLEX_CONSUME,
/* 1 */  0,        GLEX_EMPTY, 0,            TMPL_TOK_EOF,      GLEX_ACCEPT,
/* 2 */  GLEX_ANY, GLEX_EMPTY, ST_NONSUBST,  0,                 GLEX_ACCEPT,

    // -------------------------------------------------------------------
    // ST_SUBST1
    // 
     
/* 3 */  '%',      GLEX_EMPTY, 0,     TMPL_TOK_NONSUBST_STR,    GLEX_ACCEPT,
/* 4 */  GLEX_ANY, GLEX_EMPTY, ST_SUBST2,     0,                GLEX_PUSHBACK,

    // -------------------------------------------------------------------
    // ST_SUBST2
    //

/* 5 */  '%',      GLEX_EMPTY, 0,        TMPL_TOK_SUBST_STR,    GLEX_CONSUME,
/* 6 */  0,        GLEX_EMPTY, 0,        TMPL_TOK_ERROR,        GLEX_RETURN,
/* 7 */  '\n',     GLEX_EMPTY, 0,        TMPL_TOK_ERROR,        GLEX_RETURN,
/* 8 */  GLEX_ANY, GLEX_EMPTY, ST_SUBST2,     0,                GLEX_ACCEPT,

    // -------------------------------------------------------------------
    // ST_NONSUBST
    //

/* 9 */  '%',      GLEX_EMPTY, 0,        TMPL_TOK_NONSUBST_STR, GLEX_PUSHBACK,
/* 10 */  0,        GLEX_EMPTY, 0,        TMPL_TOK_NONSUBST_STR, GLEX_PUSHBACK,
/* 11 */ GLEX_ANY, GLEX_EMPTY, ST_NONSUBST,   0,                GLEX_ACCEPT

};

//
// This table drives the lexer for the substitutable strings.
//

LexEl Tmpl_SubstLexTable[] =
{

// State    First   Last      New state,  Return tok,         Instructions
// =======================================================================

/* 0 */  'A',    'Z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 1 */  'a',    'z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 2 */  0x80,  0xfffd,     ST_IDENT,   0,                     GLEX_ACCEPT,
/* 3 */  '!',   GLEX_EMPTY, ST_EXTEN,   0,                     GLEX_CONSUME,
/* 4 */  '(',   GLEX_EMPTY, 0,        TMPL_TOK_OPEN_PAREN,     GLEX_ACCEPT,
/* 5 */  ')',   GLEX_EMPTY, 0,        TMPL_TOK_CLOSE_PAREN,    GLEX_ACCEPT,
/* 6 */  ',',   GLEX_EMPTY, 0,        TMPL_TOK_COMMA,          GLEX_ACCEPT,   
/* 7 */  '"',    GLEX_EMPTY, ST_STRING1,  0,                   GLEX_CONSUME,
/* 8 */  ' ',    GLEX_EMPTY, 0,           0,                   GLEX_CONSUME,
/* 9 */  0,      GLEX_EMPTY, 0,       TMPL_TOK_EOF,            GLEX_ACCEPT,
/* 10 */ '_',   GLEX_EMPTY,  ST_IDENT,    0,                   GLEX_ACCEPT,
/* 11 */ '\'',  GLEX_EMPTY,  ST_STRING2,  0,                   GLEX_CONSUME,
/* 12 */ GLEX_ANY, GLEX_EMPTY, 0,     TMPL_TOK_ERROR, GLEX_CONSUME|GLEX_RETURN,

    // -------------------------------------------------------------------
    // ST_EXTEN

/* 13 */  'a',   'z',          ST_EXTEN,   0,                  GLEX_ACCEPT,
/* 14 */  'A',   'Z',          ST_EXTEN,   0,                  GLEX_ACCEPT,
/* 15 */  GLEX_ANY,GLEX_EMPTY, 0,     TMPL_TOK_EXTENSION_IDENT,GLEX_PUSHBACK,


    // -------------------------------------------------------------------
    // ST_IDENT

/* 16 */  'a',   'z',         ST_IDENT,    0,             GLEX_ACCEPT,
/* 17 */  'A',   'Z',         ST_IDENT,    0,             GLEX_ACCEPT,
/* 18 */  '_',   GLEX_EMPTY,  ST_IDENT,    0,             GLEX_ACCEPT,
/* 19 */  '0',   '9',         ST_IDENT,    0,             GLEX_ACCEPT,
/* 20 */  0x80,   0xfffd,     ST_IDENT,    0,             GLEX_ACCEPT,
/* 21 */  '.',   GLEX_EMPTY,  ST_IDENT,    0,             GLEX_ACCEPT,
/* 22 */  GLEX_ANY,GLEX_EMPTY, 0,      TMPL_TOK_IDENT,    GLEX_PUSHBACK, 

    // ------------------------------------------------------------------
    // ST_STRING1

/* 23 */ '"',  GLEX_EMPTY,      0,     TMPL_TOK_STRING,     GLEX_CONSUME,
/* 24 */ GLEX_ANY, GLEX_EMPTY, ST_STRING1,  0,              GLEX_ACCEPT,
/* 25 */ 0,   GLEX_EMPTY,      0,     TMPL_TOK_ERROR,       GLEX_ACCEPT, 

    // ------------------------------------------------------------------
    // ST_STRING2

/* 26 */ '\'',  GLEX_EMPTY,      0,     TMPL_TOK_STRING,    GLEX_CONSUME,
/* 27 */ GLEX_ANY, GLEX_EMPTY, ST_STRING2,  0,              GLEX_ACCEPT,
/* 28 */ 0,   GLEX_EMPTY,      0,     TMPL_TOK_ERROR,       GLEX_ACCEPT 


};

/***************************************************************************
  CTemplateStrSubstitution
****************************************************************************/

CTemplateStrSubstitution::CTemplateStrSubstitution(CGenLexSource& rLexSrc,
                                                   IWbemClassObject* pTmplArgs,
                                                   BuilderInfoSet& rInfoSet )
: m_Lexer( Tmpl_StrLexTable, &rLexSrc ), m_rBldrInfoSet( rInfoSet ),
  m_pSubstLexer( NULL ), m_pTmplArgs(pTmplArgs), m_cArgList(0)
{
}

inline void PrefixPropertyName( CPropertyName& rProp, WString& rwsPrefix )
{
    CPropertyName PropCopy = rProp;
    rProp.Empty();
    rProp.AddElement(rwsPrefix);
    
    for( long i=0; i < PropCopy.GetNumElements(); i++ )
    {
        rProp.AddElement( PropCopy.GetStringAt( i ) );
    }
}

HRESULT CTemplateStrSubstitution::SubstNext()
{
    assert( m_pSubstLexer != NULL );

    m_nCurrentToken = m_pSubstLexer->NextToken();
    
    if ( m_nCurrentToken == TMPL_TOK_ERROR )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    m_wszSubstTokenText = m_pSubstLexer->GetTokenText();

    if ( m_nCurrentToken == TMPL_TOK_EXTENSION_IDENT )
    {
        if ( wbem_wcsicmp( m_wszSubstTokenText,
                       TMPL_CONDITIONAL_EXTENSION ) == 0 )
        {
            m_nCurrentToken = TMPL_TOK_CONDITIONAL_EXTENSION;
        }
        else if ( wbem_wcsicmp( m_wszSubstTokenText,
                            TMPL_PREFIXED_WHERE_EXTENSION) == 0 )
        {
            m_nCurrentToken = TMPL_TOK_PREFIXED_WHERE_EXTENSION;
        }
        else
        {
            m_nCurrentToken = TMPL_TOK_ERROR;
        }
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::Next()
{
    m_nCurrentToken = m_Lexer.NextToken();
    
    if ( m_nCurrentToken == TMPL_TOK_ERROR )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    if ( m_nCurrentToken == TMPL_TOK_NONSUBST_STR ||
         m_nCurrentToken == TMPL_TOK_SUBST_STR ) 
    {
        m_wszTokenText = m_Lexer.GetTokenText();
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::Parse( BSTR* pbstrOut )
{
    HRESULT hr;
    
    hr = Next();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = parse();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken != TMPL_TOK_EOF ) 
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    *pbstrOut = SysAllocString( m_wsOutput );

    if ( *pbstrOut == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CTemplateStrSubstitution::parse()
{
    HRESULT hr;

    if ( m_nCurrentToken == TMPL_TOK_NONSUBST_STR )
    {
        m_wsOutput += m_wszTokenText;
        
        hr = Next();

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        return parse();
    }
    else if ( m_nCurrentToken == TMPL_TOK_SUBST_STR )
    {
        hr = subst_string();

        if ( FAILED(hr) )
        {
            return hr;
        }

        return parse();
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::subst_string()
{
    HRESULT hr;

    CTextLexSource SubstLexSrc( m_wszTokenText );
    CGenLexer SubstLexer( Tmpl_SubstLexTable, &SubstLexSrc );
    
    m_pSubstLexer = &SubstLexer;

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken == TMPL_TOK_IDENT )
    {
        hr = HandleTmplArgSubstitution();

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = SubstNext();
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        if ( m_nCurrentToken != TMPL_TOK_EOF )
        {
            return WBEM_E_INVALID_PROPERTY;
        }

        return Next();
    }

    int nCurrentToken = m_nCurrentToken;

    // advance the lexer so we can parse the args before calling the 
    // extension function ... 

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = arglist();
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken != TMPL_TOK_EOF )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    if ( nCurrentToken == TMPL_TOK_CONDITIONAL_EXTENSION )
    {    
        hr = HandleConditionalSubstitution();
    }
    else if ( nCurrentToken == TMPL_TOK_PREFIXED_WHERE_EXTENSION  )
    {
        hr = HandlePrefixedWhereSubstitution();
    }
    else
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    // reset the arglist ...

    m_cArgList = 0;

    if ( FAILED(hr) )
    {
        return hr;
    }

    return Next();
}

HRESULT CTemplateStrSubstitution::arglist()
{
    HRESULT hr;

    if ( m_nCurrentToken != TMPL_TOK_OPEN_PAREN )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = arglist2();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken != TMPL_TOK_CLOSE_PAREN )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    return SubstNext();
}

HRESULT CTemplateStrSubstitution::arglist2()
{
    HRESULT hr;

    if ( m_nCurrentToken != TMPL_TOK_IDENT && 
         m_nCurrentToken != TMPL_TOK_STRING )
    {
        return WBEM_S_NO_ERROR;
    }

    //
    // add the argument to the argument list
    //

    if ( m_cArgList >= MAXARGS ) 
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    m_abArgListString[m_cArgList] = 
        m_nCurrentToken == TMPL_TOK_IDENT ? FALSE : TRUE; 
    
    m_awsArgList[m_cArgList++] = m_wszSubstTokenText;

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    return arglist3();
}

HRESULT CTemplateStrSubstitution::arglist3()
{
    HRESULT hr;

    if ( m_nCurrentToken != TMPL_TOK_COMMA )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    return arglist2();
}

HRESULT CTemplateStrSubstitution::HandleConditionalSubstitution()
{
    HRESULT hr;

    //
    // Extension Function : Input Arg1:String, Arg2:Ident
    // Substitute Arg1 if Tmpl Args Prop specified by Arg2 is not NULL.
    //

    if ( m_cArgList != 2 || 
         m_abArgListString[0] != TRUE ||
         m_abArgListString[1] != FALSE )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    CPropVar var;
    CWbemBSTR bstrPropName = m_awsArgList[1];

    hr = m_pTmplArgs->Get( bstrPropName, 0, &var, NULL, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    if ( V_VT(&var) == VT_NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    m_wsOutput += m_awsArgList[0];

    return WBEM_S_NO_ERROR;
}


HRESULT CTemplateStrSubstitution::HandlePrefixedWhereSubstitution()
{
    HRESULT hr;

    //
    // Extension Function : Input Arg1:Ident, Arg2:Ident
    // Substitute where clause of query property of TmplArgs 
    // specified by Arg2.  Prefix each identifier in clause with Arg1.
    // If prop specified by Arg2 is NULL, then this function is a No-Op.
    //

    if ( m_cArgList != 2 || 
         m_abArgListString[0] != FALSE ||
         m_abArgListString[1] != FALSE )
    {
        return WBEM_E_INVALID_PROPERTY;
    }
    
    CWbemBSTR bstrPropName = m_awsArgList[1];

    VARIANT var;

    hr = m_pTmplArgs->Get( bstrPropName, 0, &var, NULL, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    CClearMe cmvar( &var );

    if ( V_VT(&var) == VT_NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    if ( V_VT(&var) != VT_BSTR )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    //
    // Have to add the following so it will parse ..
    //

    WString wsQuery = "SELECT * FROM A WHERE ";
    wsQuery += V_BSTR(&var);

    // 
    // Now need to parse this and go through RPN expression ...
    //

    CTextLexSource TextSource( wsQuery );

    CAbstractQl1Parser Parser( &TextSource );
    QL_LEVEL_1_RPN_EXPRESSION Tokens;

    if ( Parser.Parse( &Tokens, CAbstractQl1Parser::FULL_PARSE ) 
            != QL1_Parser::SUCCESS )
    {
        return WBEM_E_INVALID_QUERY;
    }

    if ( Tokens.nNumTokens < 1 )
    {
        return WBEM_S_NO_ERROR;
    }
        
    for( int i=0; i < Tokens.nNumTokens; i++ )
    {
        QL_LEVEL_1_TOKEN& rToken = Tokens.pArrayOfTokens[i];

        if ( rToken.nTokenType != QL_LEVEL_1_TOKEN::OP_EXPRESSION )
        {
            continue;
        }
    
        if ( rToken.PropertyName.GetNumElements() > 0 )
        {
            PrefixPropertyName( rToken.PropertyName, m_awsArgList[0] );
        }
        
        if ( rToken.m_bPropComp )
        {
            assert( rToken.PropertyName2.GetNumElements() > 0 );
            PrefixPropertyName( rToken.PropertyName2, m_awsArgList[0] );
        }
    }

    //
    // now we have to pull off the select * from classname where ....
    //

    LPWSTR wszText = Tokens.GetText();

    // from peeking at the source, look for substring 'where'(case-insensitive)

    WCHAR* wszWhere = wcsstr( wszText, L"where" );

    if ( wszWhere == NULL )
    {
        delete wszText;
        return WBEM_E_INVALID_OBJECT;
    }

    wszWhere += 5;
    m_wsOutput += wszWhere;
    delete wszText;
 
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::HandleTmplArgSubstitution()
{
    HRESULT hr; 

    //
    // Substitute Tmpl Args Prop specified by Arg1.
    // No-Op if prop value is NULL.
    //

    LPCWSTR wszPropName = m_wszSubstTokenText;

    CPropVar vValue;

    hr = GetTemplateValue( wszPropName,
                           m_pTmplArgs, 
                           m_rBldrInfoSet, 
                           &vValue );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vValue) == VT_NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = vValue.SetType( VT_BSTR );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    m_wsOutput += V_BSTR(&vValue);

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\main.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <trnsprov.h>
#include <commain.h>
#include <comutl.h>

// Function pointer type used with LoadMofFiles entrypoint in wbemupgd.dll
typedef BOOL ( WINAPI *PFN_LOAD_MOF_FILES )(wchar_t* pComponentName, const char* rgpszMofFilename[]);

// {405595AA-1E14-11d3-B33D-00105A1F4AAF}
static const GUID CLSID_TransientProvider = 
{ 0x405595aa, 0x1e14, 0x11d3, { 0xb3, 0x3d, 0x0, 0x10, 0x5a, 0x1f, 0x4a, 0xaf } };

// {405595AB-1E14-11d3-B33D-00105A1F4AAF}
static const GUID CLSID_TransientEventProvider = 
{ 0x405595ab, 0x1e14, 0x11d3, { 0xb3, 0x3d, 0x0, 0x10, 0x5a, 0x1f, 0x4a, 0xaf } };

class CMyServer : public CComServer
{
public:

    HRESULT Initialize()
    {
        ENTER_API_CALL

        HRESULT hr;
        CWbemPtr<CBaseClassFactory> pFactory;

        hr = CTransientProvider::ModuleInitialize();

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CClassFactory<CTransientProvider>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_TransientProvider, 
                           pFactory,
                           TEXT("Transient Instance Provider"),
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory= new CClassFactory<CTransientEventProvider>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }


        hr = AddClassInfo( CLSID_TransientEventProvider, 
                           pFactory,
                           TEXT("Transient Instance Reboot Event Provider"),
                           TRUE );

        return hr;

        EXIT_API_CALL
    }

    void Uninitialize()
    {
        CTransientProvider::ModuleUninitialize();
    }

    void Register()
    {
        //
        //  Load mofs and mfls during registration
        //
        HINSTANCE hinstWbemupgd = LoadLibrary(L"wbemupgd.dll");
        if (hinstWbemupgd)
        {
            PFN_LOAD_MOF_FILES pfnLoadMofFiles = (PFN_LOAD_MOF_FILES) GetProcAddress(hinstWbemupgd, "LoadMofFiles"); // no wide version of GetProcAddress
            if (pfnLoadMofFiles)
            {
                wchar_t*    wszComponentName = L"Trnsprov";
                const char* rgpszMofFilename[] = 
                {
                    "trnsprov.mof",
                    "trnsprov.mfl",
                    NULL
                };
                
                pfnLoadMofFiles(wszComponentName, rgpszMofFilename);
            }

            FreeLibrary(hinstWbemupgd);
        }
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnscls.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <trnscls.h>
#include <trnsprov.h>
#include <malloc.h>

CTransientClass::CTransientClass(CTransientProvider* pProv) 
    : m_wszName(NULL), m_apProperties(NULL), m_lNumProperties(0),
        m_pProvider(pProv)
{
    // 
    // Provider is held without reference --- it owns this object
    //
}

HRESULT CTransientClass::Initialize(IWbemObjectAccess* pClass, LPCWSTR wszName)
{
    HRESULT hres;

    //
    // Copy the name
    //

    m_wszName = new WCHAR[wcslen(wszName)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchCopyW(m_wszName, wcslen(wszName)+1, wszName);

    //
    // Allocate the space for all the properties
    //

    VARIANT v;
    hres = pClass->Get(L"__PROPERTY_COUNT", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&v) != VT_I4)
        return WBEM_E_INVALID_CLASS;

    _DBG_ASSERT( m_lNumProperties == 0 );

    long lNumProperties = V_I4(&v);
    VariantClear(&v);

    m_apProperties = new CTransientProperty*[lNumProperties];

    if ( m_apProperties == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Enumerate all the properties
    //

    m_nDataSpace = 0;
    pClass->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    BSTR strProp;
    while((hres = pClass->Next(0, &strProp, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strProp);
        hres = CTransientProperty::CreateNew(m_apProperties + m_lNumProperties,
                                            pClass, 
                                            strProp);
        if(FAILED(hres))
        {
            pClass->EndEnumeration();
            return hres;
        }
        
        //
        // Inform the property of the provider pointer
        //

        m_apProperties[m_lNumProperties]->SetClass(this);

        //
        // See how much data this property will need to store in the instance
        //

        m_apProperties[m_lNumProperties]->SetInstanceDataOffset(m_nDataSpace);
        m_nDataSpace += m_apProperties[m_lNumProperties]->GetInstanceDataSize();
        m_lNumProperties++;
    }
        
    pClass->EndEnumeration();
    return WBEM_S_NO_ERROR;
}

CTransientClass::~CTransientClass()
{
    delete [] m_wszName;
    for(long i = 0; i < m_lNumProperties; i++)
        delete m_apProperties[i];
    delete [] m_apProperties;
}

IWbemObjectAccess* CTransientClass::Clone(IWbemObjectAccess* pInst)
{
    IWbemClassObject* pClone;
    HRESULT hres = pInst->Clone(&pClone);
    if(FAILED(hres))
        return NULL;
    CReleaseMe rm1(pClone);

    IWbemObjectAccess* pCloneAccess;
    pClone->QueryInterface(IID_IWbemObjectAccess, (void**)&pCloneAccess);
    return pCloneAccess;
}

HRESULT CTransientClass::Put(IWbemObjectAccess* pInst, LPCWSTR wszDbKey,
                                long lFlags,
                                IWbemObjectAccess** ppOld,
                                IWbemObjectAccess** ppNew)
{
    //
    // Check if it is already in the map
    //

    CInCritSec ics(&m_cs);

    TIterator it = m_mapInstances.find(wszDbKey);
        
    if( it != m_mapInstances.end() )
    {
        //
        // Check if update is allowed by the flags
        //

        if(lFlags & WBEM_FLAG_CREATE_ONLY)
            return WBEM_E_ALREADY_EXISTS;

        CTransientInstance* pOldInstData = it->second.get();

        if(ppOld)
        {
            Postprocess(pOldInstData);
            *ppOld = Clone(pOldInstData->GetObjectPtr());
        }

        //
        // Update all properties appropriately in the old instance
        // TBD: need to clean up every now and then, or the blob will grow out 
        // of control.  But I don't want to touch pInst --- let the caller 
        // reuse it!
        //
    
        for(long i = 0; i < m_lNumProperties; i++)
        {
            HRESULT hres = m_apProperties[i]->Update(pOldInstData, pInst);
            if(FAILED(hres))
            {
                //
                // Restore the instance to its pre-update state!
                //

                if(ppOld)
                {
                  pOldInstData->SetObjectPtr(*ppOld);
                  (*ppOld)->Release();
                  *ppOld = NULL;
                }
                
                return hres;
            }
        }

        if(ppNew)
        {
            Postprocess(pOldInstData);
            *ppNew = Clone(pOldInstData->GetObjectPtr());

            if ( *ppNew == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else
    {
        //
        // Check if creation is allowed by the flags
        //

        if(lFlags & WBEM_FLAG_UPDATE_ONLY)
            return WBEM_E_NOT_FOUND;

        //
        // Create a new instance data structure
        //

        CTransientInstance* pInstData = new (m_nDataSpace) CTransientInstance;

        if ( pInstData == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // Clone the object
        //
        
        IWbemObjectAccess* pClone = Clone(pInst);
        if(pClone == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CReleaseMe rm2(pClone);

        //
        // Configure the data with the object
        //

        pInstData->SetObjectPtr(pClone);

        //
        // Init all the properties
        //

        for(long i = 0; i < m_lNumProperties; i++)
        {
            m_apProperties[i]->Create(pInstData);
        }

        m_mapInstances[wszDbKey] = TElement(pInstData);

        //
        // AddRef the provider to make sure we are not unloaded while we have
        // instances
        //

        m_pProvider->AddRef();

        if(ppOld)
            *ppOld = NULL;

        if(ppNew)
        {
            Postprocess(pInstData);
            *ppNew = Clone(pInstData->GetObjectPtr());

            if ( *ppNew == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientClass::Delete(LPCWSTR wszDbKey, IWbemObjectAccess** ppOld)
{
    CInCritSec ics(&m_cs);

    // 
    // Find it in the map
    //

    TIterator it = m_mapInstances.find(wszDbKey);
    if(it == m_mapInstances.end())
        return WBEM_E_NOT_FOUND;

    CTransientInstance* pInstData = it->second.get();
    if(ppOld)
    {
        Postprocess(pInstData);
        *ppOld = Clone(pInstData->GetObjectPtr());
    }

    //
    // Clean up all the properties
    //

    for(long i = 0; i < m_lNumProperties; i++)
    {
        m_apProperties[i]->Delete(pInstData);
    }
    
    //
    // Remove it from the map
    //

    m_mapInstances.erase(it);

    //
    // Release the provider to make sure that when we are left with no 
    // instances, we can unload
    //

    m_pProvider->Release();

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientClass::Get(LPCWSTR wszDbKey, IWbemObjectAccess** ppInst)
{
    CInCritSec ics(&m_cs);

    // 
    // Find it in the map
    //

    TIterator it = m_mapInstances.find(wszDbKey);
    if(it == m_mapInstances.end())
        return WBEM_E_NOT_FOUND;

    //
    // Apply all the properties
    //

    CTransientInstance* pInstData = it->second.get();
    Postprocess(pInstData);

    //
    // Addref and return it
    //

    IWbemClassObject* pInst;

    HRESULT hr = pInstData->GetObjectPtr()->Clone( &pInst );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CReleaseMe rmInst( pInst );

    return pInst->QueryInterface( IID_IWbemObjectAccess, (void**)ppInst );
}

HRESULT CTransientClass::Postprocess(CTransientInstance* pInstData)
{
    for(long i = 0; i < m_lNumProperties; i++)
    {
        m_apProperties[i]->Get(pInstData);
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CTransientClass::Enumerate(IWbemObjectSink* pSink)
{
    CInCritSec ics(&m_cs);

    //
    // Enumerate everything in the map
    //

    for(TIterator it = m_mapInstances.begin(); it != m_mapInstances.end(); it++)
    {
        CTransientInstance* pInstData = it->second.get();
        
        // 
        // Apply all the properties
        //

        for(long i = 0; i < m_lNumProperties; i++)
        {
            m_apProperties[i]->Get(pInstData);
        }

        //
        // Indicate it back to WinMgmt
        //

        IWbemClassObject* pActualInst = pInstData->GetObjectPtr();
        if(pActualInst == NULL)
            return WBEM_E_CRITICAL_ERROR;

        IWbemClassObject* pInst;
        HRESULT hr = pActualInst->Clone( &pInst );

        if( FAILED(hr) )
        {
            return hr;
        }

        CReleaseMe rm1(pInst);

        hr = pSink->Indicate(1, &pInst);
        if( FAILED(hr) )
        {
            //
            // Call cancelled
            //
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CTransientClass::FireEvent(IWbemClassObject* pEvent)
{
    return m_pProvider->FireEvent(pEvent);
}

INTERNAL IWbemClassObject* CTransientClass::GetEggTimerClass()
{
    return m_pProvider->GetEggTimerClass();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnscls.h ===
#ifndef __WMI_TRANSIENT_CLASS__H_
#define __WMI_TRANSIENT_CLASS__H_

#pragma warning(disable: 4786)

#include <map>
#include <sync.h>
#include <wstlallc.h>
#include "trnsprop.h"
#include "trnsinst.h"

class CObjectPtr
{
protected:
    IWbemObjectAccess* m_p;
public:
    CObjectPtr(IWbemObjectAccess* p = NULL) : m_p(p)
    {
        if(m_p) m_p->AddRef();
    }

    CObjectPtr(const CObjectPtr& Ptr) : m_p(Ptr.m_p)
    {
        if(m_p) m_p->AddRef();
    }
    void operator=(const CObjectPtr& Ptr)
    {
        if(this == &Ptr)
            return;
        if(m_p) m_p->Release();
        m_p = Ptr.m_p;
        if(m_p) m_p->AddRef();
    }

    ~CObjectPtr()
    {
        if(m_p) m_p->Release();
    }

    operator IWbemObjectAccess*() {return m_p;}
};

class CTransientProvider;
class CTransientClass : public CUnk
{
protected:
    LPWSTR m_wszName;
    CTransientProvider* m_pProvider;

    typedef std::map<WString, std::auto_ptr<CTransientInstance>,WSiless, wbem_allocator< std::auto_ptr<CTransientInstance> > > TMap;
    typedef TMap::iterator TIterator;
    typedef TMap::referent_type TElement;

    TMap m_mapInstances;
    CCritSec m_cs;
    CTransientProperty** m_apProperties;
    long m_lNumProperties;
    size_t m_nDataSpace;

    void* GetInterface( REFIID ) { return NULL; }

protected:
    IWbemObjectAccess* Clone(IWbemObjectAccess* pInst);

public:
    CTransientClass(CTransientProvider* pProvider);
    ~CTransientClass();
    LPCWSTR GetName() const {return m_wszName;}

    HRESULT Initialize(IWbemObjectAccess* pClass, LPCWSTR wszName);

    HRESULT Put(IWbemObjectAccess* pInst, LPCWSTR wszDbKey, long lFlags,
                IWbemObjectAccess** ppOld,
                IWbemObjectAccess** ppNew);
    HRESULT Delete(LPCWSTR wszDbKey,
                IWbemObjectAccess** ppOld = NULL);
    HRESULT Get(LPCWSTR wszDbKey, IWbemObjectAccess** ppInst);
    HRESULT Enumerate(IWbemObjectSink* pSink);
    
    HRESULT FireEvent(IWbemClassObject* pEvent);
    INTERNAL IWbemClassObject* GetEggTimerClass();

    HRESULT Postprocess(CTransientInstance* pInstData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprop.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <trnsprop.h>
#include <malloc.h>
#include <trnscls.h>
#include <trnsschm.h>
#include <buffer.h>


#define PROPERTY_LENGTH_TRESHOLD    128

//void* operator new(size_t st, void* p); 

//******************************************************************************
//
//          TRANSIENT PROPERTY --- BASE
//
//******************************************************************************

CTransientProperty::CTransientProperty()
    : m_wszName(NULL), m_lHandle(0)
{
}

CTransientProperty::~CTransientProperty()
{
    delete [] m_wszName;
}

HRESULT CTransientProperty::Initialize( IWbemObjectAccess* pObj, 
                                        LPCWSTR wszName)
{
    //
    // Copy the name
    //

    m_wszName = new WCHAR[wcslen(wszName)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchCopyW(m_wszName, wcslen(wszName)+1, wszName);

    //
    // see if the property is defaulted.  If so, then don't use the handle 
    // to obtain the value ( because the interface doesn't tell us if 
    // the property is defaulted or not. ) RAID 164064.  Note that timer 
    // and time avg properties don't support default properties right now, 
    // but they will fail later on in initialization when they notice that the
    // handle is invalid.
    // 

    VARIANT v;
    HRESULT hres = pObj->Get( wszName, 0, &v, &m_ct, NULL );

    if ( FAILED(hres) )
    {
        return hres;
    }

    m_lHandle = -1;

    if ( V_VT(&v) == VT_NULL )
    {
        //
        // Get the handle
        //
        
        long lHandle;
     
        if( SUCCEEDED(pObj->GetPropertyHandle(wszName, &m_ct, &lHandle)) )
        {
            m_lHandle = lHandle;
        }
    }
    else
    {
        VariantClear( &v );
    }

    return hres;
}

HRESULT CTransientProperty::Create(CTransientInstance* pInstData)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProperty::Update(CTransientInstance* pInstData, 
                                    IWbemObjectAccess* pNew)
{
    HRESULT hres;

    //
    // If the value in the new instance is not NULL and is not defaulted, 
    // update it in the old
    //

    if(m_lHandle != -1)
    {    
        BYTE    Buffer[ PROPERTY_LENGTH_TRESHOLD ];
        CBuffer Data( Buffer, PROPERTY_LENGTH_TRESHOLD, FALSE );

        long lRead;
        hres = pNew->ReadPropertyValue(m_lHandle, PROPERTY_LENGTH_TRESHOLD, 
                                &lRead, Data.GetRawData() );

        if ( WBEM_E_BUFFER_TOO_SMALL == hres )
        {
            hres = Data.SetSize( lRead );
            if ( FAILED( hres ) )
            {
                return hres;
            }

            hres = pNew->ReadPropertyValue(m_lHandle, lRead, &lRead, Data.GetRawData() );
        }

        if(FAILED(hres))
            return hres;
        
        if(hres == WBEM_S_NO_ERROR)
        {
            // 
            // Not NULL --- write back into pOld
            //
    
            hres = pInstData->GetObjectPtr()->WritePropertyValue( m_lHandle, lRead, Data.GetRawData()  );
        }
    }
    else
    {
        //
        // Use the name
        //

        VARIANT v;
        IWbemClassObject* pNewObj = NULL;
        pNew->QueryInterface(IID_IWbemClassObject, (void**)&pNewObj);
        CReleaseMe rm1(pNewObj);

        long lFlavor;
        hres = pNewObj->Get(m_wszName, 0, &v, NULL, &lFlavor);
        if(FAILED(hres))
            return hres;

        CClearMe cmv(&v);

        if( V_VT(&v) != VT_NULL && lFlavor == WBEM_FLAVOR_ORIGIN_LOCAL )
        {
            IWbemClassObject* pOldObj = NULL;
            pInstData->GetObjectPtr()->QueryInterface(IID_IWbemClassObject, 
                                                    (void**)&pOldObj);
            CReleaseMe rm2(pOldObj);
            
            hres = pOldObj->Put(m_wszName, 0, &v, 0);
        }
    }

    return hres;
}

HRESULT CTransientProperty::Get(CTransientInstance* pInstData)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProperty::Delete(CTransientInstance* pInstData)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProperty::CreateNew(CTransientProperty** ppProp, 
                                IWbemObjectAccess* pClass, 
                                LPCWSTR wszName)
{
    //
    // Get the qualifier set
    //

    IWbemQualifierSet* pSet = NULL;
    HRESULT hres = pClass->GetPropertyQualifierSet(wszName, &pSet);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pSet);

    //
    // Create the right kind of node
    //

    hres = CreateNode( ppProp, pSet );

    if(FAILED(hres))
        return hres;
    if(*ppProp == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    
    // 
    //
    // Initialize it
    //

    return (*ppProp)->Initialize(pClass, wszName);
}

HRESULT CTransientProperty::CreateNode(CTransientProperty** ppProp, 
                                        IWbemQualifierSet* pSet)
{
    HRESULT hres; 

    //
    // Check for the standard qualifiers
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pSet->Get(EGGTIMER_QUALIFIER, 0, &v, NULL);

    if ( FAILED(hres) )
    {
        hres = pSet->Get(TIMEAVERAGE_QUALIFIER, 0, &v, NULL);

        if(FAILED(hres))
        {
            *ppProp = new CTransientProperty;
        }
        else
        {
            *ppProp = new CTimeAverageProperty;
        }
    }
    else
    {
        *ppProp = new CTimerProperty;
    }

    return (*ppProp != NULL) ? WBEM_S_NO_ERROR : WBEM_E_OUT_OF_MEMORY;
}


//******************************************************************************
//
//                          EGG TIMER 
//
//******************************************************************************

CTimerGenerator CTimerProperty::mstatic_Generator;

CTimerProperty::~CTimerProperty()
{
}

void CTimerProperty::SetClass(CTransientClass* pClass)
{
    m_pClass = pClass;
}

HRESULT CTimerProperty::Initialize( IWbemObjectAccess* pObj, 
                                    LPCWSTR wszName)
{
    //
    // Initialize like every other
    //

    HRESULT hres = CTransientProperty::Initialize(pObj, wszName);
    if(FAILED(hres))
        return hres;

    if(m_lHandle == -1)
        return WBEM_E_INVALID_PROPERTY_TYPE;

    //
    // Make sure that the type is SINT32, UINT32, REAL32 or DATETIME
    //

    if( m_ct != CIM_SINT32 && m_ct != CIM_UINT32 && 
        m_ct != CIM_DATETIME && m_ct != CIM_REAL32 )
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CTimerProperty::Create(CTransientInstance* pInstData)
{
    //
    // Initialize our data
    //

    CTimerPropertyData* pData = 
    (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    new (pData) CTimerPropertyData;
    
    return Set(pInstData, pInstData->GetObjectPtr());
}

HRESULT CTimerProperty::Set(CTransientInstance* pInstData, 
                            IWbemObjectAccess* pObj)
{
    HRESULT hres;

    CTimerPropertyData* pData = 
    (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    //
    // need to hold this cs because we will be referencing the timer inst 
    // and we don't want a timer to fire and bash it.
    //
    CInCritSec ics(&pData->m_cs); 

    //
    // Check if we are actually being written
    //

    BYTE    Buffer[ PROPERTY_LENGTH_TRESHOLD ];
    CBuffer Data( Buffer, PROPERTY_LENGTH_TRESHOLD, FALSE );

    long lRead;
    hres = pObj->ReadPropertyValue(m_lHandle, PROPERTY_LENGTH_TRESHOLD, &lRead, Data.GetRawData( ) );

    if ( WBEM_E_BUFFER_TOO_SMALL == hres )
    {
        hres = Data.SetSize( lRead );
        if ( FAILED( hres ) )
        {
            return hres;
        }
        hres = pObj->ReadPropertyValue(m_lHandle, lRead, &lRead, Data.GetRawData() );
    }

    if(FAILED(hres))
        return hres;

    if(hres == WBEM_S_FALSE)
        return WBEM_S_NO_ERROR;

    //
    // Cancel the previous instruction
    //

    if(pData->m_pCurrentInst)
    {
        CIdentityTest Test(pData->m_pCurrentInst);
        hres = mstatic_Generator.Remove(&Test);
        if(FAILED(hres))
        return hres;
        pData->m_pCurrentInst->Release();
        pData->m_pCurrentInst = NULL;
    }

    // Extract the value of the interval

    if(m_ct == CIM_DATETIME)
    {
        DWORD dwDays, dwHours, dwMinutes, dwSeconds;
        
        if(swscanf((LPCWSTR)Data.GetRawData( ), L"%8u%2u%2u%2u", 
                   &dwDays, &dwHours, &dwMinutes, &dwSeconds) != 4)
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        dwSeconds += dwMinutes * 60 + dwHours * 3600 + dwDays * 3600 * 24;
        pData->m_Interval.SetMilliseconds(1000 * dwSeconds);
    }
    else if (m_ct == CIM_REAL32)
    {
        float fSeconds = *(float*)Data.GetRawData( );
        pData->m_Interval.SetMilliseconds( 1000 * fSeconds );
    }   
    else
    {
        DWORD dwSeconds = *(DWORD*)Data.GetRawData( );
        pData->m_Interval.SetMilliseconds( 1000 * dwSeconds );
    }

    if(pData->m_Interval.IsZero())
    {
        pData->m_Next = CWbemTime::GetInfinity();
        return WBEM_S_NO_ERROR;
    }

    //
    // Compute the next firing time
    //

    pData->m_Next = CWbemTime::GetCurrentTime() + pData->m_Interval;
    
    //
    // Schedule an instruction to fire then
    //

    pData->m_pCurrentInst = 
    new CEggTimerInstruction(this, pInstData, pData->m_Next);

    if ( pData->m_pCurrentInst == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pData->m_pCurrentInst->AddRef();
    hres = mstatic_Generator.Set(pData->m_pCurrentInst);
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}
    
HRESULT CTimerProperty::Update(CTransientInstance* pInstData, 
                                IWbemObjectAccess* pNew)
{
    return Set(pInstData, pNew);
}

HRESULT CTimerProperty::Get(CTransientInstance* pInstData)
{
    //
    // Retrieve instance data blob
    //

    CTimerPropertyData* pData = 
        (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    CInCritSec ics(&pData->m_cs);

    HRESULT hres;

    //
    // Check if we are currently active
    //

    DWORD dwMs;
    if(pData->m_pCurrentInst)
    {
        //
        // Subtract the current time from the firing time
        //

        dwMs = (pData->m_Next - CWbemTime::GetCurrentTime()).GetMilliseconds();
    }
    else
    {
        dwMs = 0;
    }
        
    // 
    // Stick it into the property
    //

    if(m_ct == CIM_DATETIME)
    {
        WCHAR wszInterval[25];
        DWORD dwDays = dwMs / (3600 * 1000 * 24);
        dwMs -= dwDays * (3600 * 1000 * 24);
        DWORD dwHours = dwMs / (3600 * 1000);
        dwMs -= dwHours * (3600 * 1000);
        DWORD dwMinutes = dwMs / (60 * 1000);
        dwMs -= dwMinutes * (60 * 1000);
        DWORD dwSeconds = dwMs / 1000;
        dwMs -= dwSeconds * 1000;
        StringCchPrintfW(wszInterval, 25, L"%08u%02u%02u%02u.%06u:000", 
            dwDays, dwHours, dwMinutes, dwSeconds, dwMs);
            
        hres = pInstData->GetObjectPtr()->WritePropertyValue(m_lHandle, 50, 
                (BYTE*)wszInterval);
    }
    if(m_ct == CIM_REAL32)
    {
        float fSec = dwMs / 1000.0;
        hres = pInstData->GetObjectPtr()->WritePropertyValue( m_lHandle, 
                                                              sizeof(float), 
                                                              (BYTE*)&fSec ); 
    }
    else
    {
        DWORD dwSec = dwMs / 1000;
        hres = pInstData->GetObjectPtr()->WriteDWORD( m_lHandle, dwSec );
    }

    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}

HRESULT CTimerProperty::Delete(CTransientInstance* pInstData)
{
    //
    // Retrieve instance data blob
    //

    CTimerPropertyData* pData = 
        (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    //
    // Clear the data
    //

    pData->~CTimerPropertyData();
    return WBEM_S_NO_ERROR;
}

size_t CTimerProperty::GetInstanceDataSize()
{
    return sizeof(CTimerPropertyData);
}

CTimerPropertyData::~CTimerPropertyData()
{
    //
    // Cancel the timer instruction, if any
    //

    if(m_pCurrentInst)
    {
        CIdentityTest Test(m_pCurrentInst);
        HRESULT hres = CTimerProperty::GetGenerator().Remove(&Test);
        m_pCurrentInst->Release();
    }
}
void CTimerPropertyData::ResetInstruction()
{
    CInCritSec ics(&m_cs);
    m_pCurrentInst->Release();
    m_pCurrentInst = NULL;
}

CEggTimerInstruction::CEggTimerInstruction(CTimerProperty* pProp, 
                            CTransientInstance* pData,
                            const CWbemTime& Time)
    : m_pProp(pProp), m_pData(pData), m_Time(Time), m_lRef(0)
{
}
    
HRESULT CEggTimerInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    HRESULT hres;

    //
    // Remove instruction from instance
    //

    CTimerPropertyData* pTimerData = 
        (CTimerPropertyData*)m_pProp->GetData(m_pData);
    pTimerData->ResetInstruction();

    //
    // Create an instance of the egg timer event
    //

    IWbemClassObject* pEvent = NULL;
    hres = m_pProp->m_pClass->GetEggTimerClass()->SpawnInstance(0, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pEvent);

    //
    // Fill in the class name
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_pProp->m_pClass->GetName());
    if ( V_BSTR(&v) == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    hres = pEvent->Put(EGGTIMER_PROP_CLASSNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;
    VariantClear(&v);

    //
    // Fill in the property name
    //

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_pProp->GetName());
    if ( V_BSTR(&v) == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    hres = pEvent->Put(EGGTIMER_PROP_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;
    VariantClear(&v);

    //
    // Retrieve a current copy of the object
    //

    hres = m_pProp->m_pClass->Postprocess(m_pData);
    if(FAILED(hres))
        return hres;

    // 
    // Put it into the event
    //

    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = m_pData->GetObjectPtr();
    V_UNKNOWN(&v)->AddRef();
    hres = pEvent->Put(EGGTIMER_PROP_OBJECT, 0, &v, 0);
    if(FAILED(hres))
        return hres;
    VariantClear(&v);

    //
    // Fire event
    //

    return m_pProp->m_pClass->FireEvent(pEvent);
}

void CEggTimerInstruction::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CEggTimerInstruction::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}

//******************************************************************************
//
//                          TIME AVERAGE
//
//******************************************************************************

CTimeAverageData::CTimeAverageData()
    : m_bOn(false)
{
}

HRESULT CTimeAverageProperty::Initialize(IWbemObjectAccess* pObj, 
                                            LPCWSTR wszName)
{
    //
    // Initialize like every other
    //

    HRESULT hres = CTransientProperty::Initialize(pObj, wszName);
    if(FAILED(hres))
        return hres;

    if(m_lHandle == -1)
        return WBEM_E_INVALID_PROPERTY_TYPE;

    //
    // Make sure that the type is REAL64
    //

    if(m_ct != CIM_REAL64)
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    //
    // Get the qualifier set
    //

    IWbemClassObject* pObjObj;
    pObj->QueryInterface(IID_IWbemClassObject, (void**)&pObjObj);
    CReleaseMe rm0(pObjObj);

    IWbemQualifierSet* pSet = NULL;
    hres = pObjObj->GetPropertyQualifierSet(wszName, &pSet);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pSet);

    //
    // Get the target property
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pSet->Get(VALUE_QUALIFIER, 0, &v, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    
    //
    // Get it's handle
    //

    hres = pObj->GetPropertyHandle(V_BSTR(&v), &m_ctValue, &m_lValueHandle);
    if(FAILED(hres))
        return WBEM_E_INVALID_PROPERTY;
    if(m_ctValue != CIM_REAL64 && m_ctValue != CIM_SINT32 && 
        m_ctValue != CIM_UINT32)
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    VariantClear(&v);

    //
    // Get the switch property 
    //

    hres = pSet->Get(SWITCH_QUALIFIER, 0, &v, NULL);

    if( SUCCEEDED(hres) )
    {
        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_QUALIFIER_TYPE;
    
        //
        // Get it's handle
        //
        
        CIMTYPE ct;
        hres = pObj->GetPropertyHandle(V_BSTR(&v), &ct, &m_lSwitchHandle);
        if(FAILED(hres))
            return WBEM_E_INVALID_PROPERTY;
        if(ct != CIM_BOOLEAN)
            return WBEM_E_INVALID_PROPERTY_TYPE;
    }
    else
    {
        m_lSwitchHandle = -1;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CTimeAverageProperty::Create(CTransientInstance* pInstData)
{
    //
    // Initialize our data
    //

    CTimeAverageData* pData = (CTimeAverageData*)GetData(pInstData);

    new (pData) CTimeAverageData;
    
    return Update(pInstData, pInstData->GetObjectPtr());
}
    
HRESULT CTimeAverageProperty::Update(CTransientInstance* pOldData, 
                        IWbemObjectAccess* pNew)
{
    HRESULT hres;

    CTimeAverageData* pData =  (CTimeAverageData*)GetData(pOldData);
    CWbemTime Now = CWbemTime::GetCurrentTime();

    //
    // Check if we are being switched on or off
    //

    VARIANT_BOOL boSwitch;
    
    long lRead;
    if ( m_lSwitchHandle != -1 )
    {
        hres = pNew->ReadPropertyValue( m_lSwitchHandle, 
                                        sizeof(VARIANT_BOOL), 
                                        &lRead, 
                                        (BYTE*)&boSwitch);
        if(FAILED(hres))
            return hres;
    }
    else
    {
        boSwitch = VARIANT_TRUE;
        hres = WBEM_S_NO_ERROR;
    }

    if(hres == WBEM_S_NO_ERROR)
    {
        //
        // Reset value is being written.  See if it is being changed
        //

        if(boSwitch && !pData->m_bOn)
        {
            //
            // We are being turned on.
            // Make the last known value the current one, startiung now
            //

            double dblVal;
            hres = pOldData->GetObjectPtr()->ReadPropertyValue(m_lValueHandle, 
                                                sizeof(double), &lRead, 
                                                (BYTE*)&dblVal);
            if(FAILED(hres))
                return hres;
        
            if(hres != WBEM_S_NO_ERROR)
            {
                // 
                // NULL.  Hard to average.  Set to 0 for now, hope it is being
                // written, in which we will change it down below
                //

                pData->m_dblLastValue = 0;
            }
            else
                SetValue(pData, dblVal);

            pData->m_LastUpdate = Now;
            pData->m_bOn = true;
        }
        if(!boSwitch && pData->m_bOn)
        {
            //
            // We are being turned off
            //
            // Combine the last value into the sum
            //

            CombineLastValue(pData, Now);
            pData->m_bOn = false;
        }
    }

    if(pData->m_bOn)
    {
        //
        // Check if we ourselves are actually being written
        //
    
        double dblVal;
    
        long lReadPropValue;
        hres = pNew->ReadPropertyValue(m_lHandle, 
                                            sizeof(double), 
                                            &lReadPropValue, 
                                            (BYTE*)&dblVal);
        if(FAILED(hres))
            return hres;
    
        if(hres == WBEM_S_NO_ERROR)
        {
            //
            // We are.  The only acceptable value is 0.  Make sure that's the 
            // one we got.
            //
    
            if(dblVal != 0)
                return WBEM_E_VALUE_OUT_OF_RANGE;
    
            // 
            // It is zero.  Reset everything
            //
    
            pData->m_dblWeightedSum = 0;
            pData->m_SumInterval.SetMilliseconds(0);
            pData->m_LastUpdate = Now;
        }

        //
        // Combine the last value into the sum.
        //

        CombineLastValue(pData, Now);
    
        //
        // Check if our value is being written
        //

        hres = pNew->ReadPropertyValue(m_lValueHandle, 
                                            sizeof(double), 
                                            &lReadPropValue, 
                                            (BYTE*)&dblVal);
        if(FAILED(hres))
            return hres;
    
        if(hres == WBEM_S_NO_ERROR)
        {
            //
            // It is.  Set it
            //

            SetValue(pData, dblVal);
        }
    }

    return WBEM_S_NO_ERROR;
}
    
void CTimeAverageProperty::SetValue(CTimeAverageData* pData, double dblVal)
{
    // 
    // Check the type
    //

    switch(m_ctValue)
    {
    case CIM_REAL64:
        pData->m_dblLastValue = dblVal;
        break;
    case CIM_SINT32:
        pData->m_dblLastValue = *(long*)&dblVal;
        break;
    case CIM_UINT32:
        pData->m_dblLastValue = *(DWORD*)&dblVal;
        break;
    default:
        break;
        // invalid!
    }
}

void CTimeAverageProperty::CombineLastValue(CTimeAverageData* pData, 
                                            const CWbemTime& Now)
{
    if(!pData->m_bOn)
        return;

    //
    // Calclulate the amount of time that the last value stayed in effect
    //

    CWbemInterval Duration = Now - pData->m_LastUpdate;
    if(Duration.IsZero())
        return;

    //
    // Multiple the Last value by the number of ms it stayed in effect
    //

    pData->m_dblWeightedSum += 
        pData->m_dblLastValue * Duration.GetMilliseconds();

    //
    // Append the elapsed time to the time for the sum
    //

    pData->m_SumInterval += Duration;

    //
    // Reset last update
    //

    pData->m_LastUpdate = Now;
}
    
HRESULT CTimeAverageProperty::Get(CTransientInstance* pInstData)
{
    HRESULT hres;

    CTimeAverageData* pData =  (CTimeAverageData*)GetData(pInstData);

    //
    // Combine the last value into the sum
    //

    CombineLastValue(pData, CWbemTime::GetCurrentTime());

    // 
    // Place the weighted sum divided by the time it stayed in effect into the
    // object
    //

    DWORD dwMs = pData->m_SumInterval.GetMilliseconds();
    double dblAverage = 0;
    if(dwMs)
        dblAverage = pData->m_dblWeightedSum / dwMs;

    hres = pInstData->GetObjectPtr()->WritePropertyValue(m_lHandle, 
                                sizeof(double), (BYTE*)&dblAverage);

    if(FAILED(hres))
        return hres;
    
    return WBEM_S_NO_ERROR;
}


HRESULT CTimeAverageProperty::Delete(CTransientInstance* pInstData)
{
    CTimeAverageData* pData =  (CTimeAverageData*)GetData(pInstData);
    pData->~CTimeAverageData();
    return WBEM_S_NO_ERROR;
}

size_t CTimeAverageProperty::GetInstanceDataSize()
{
    return sizeof(CTimeAverageData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsschm.h ===
#define REBOOT_EVENT_CLASS L"MSFT_TransientRebootEvent"
#define EGGTIMER_EVENT_CLASS L"MSFT_TransientEggTimerEvent"
#define EGGTIMER_PROP_CLASSNAME L"ClassName"
#define EGGTIMER_PROP_PROPNAME L"PropertyName"
#define EGGTIMER_PROP_OBJECT L"Object"

#define EGGTIMER_QUALIFIER L"trns_egg_timer"
#define TIMEAVERAGE_QUALIFIER L"trns_time_average"
#define VALUE_QUALIFIER L"trns_value_is"
#define SWITCH_QUALIFIER L"trns_switch_is"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprop.h ===
#ifndef __WMI_TRANSIENT_PROP__H_
#define __WMI_TRANSIENT_PROP__H_

#pragma warning(disable: 4786)

#include <map>

#include <cwbemtime.h>
#include <tss.h>
#include "trnsinst.h"

class CTransientClass;
class CTransientProperty
{
protected:
    LPWSTR m_wszName;
    long m_lHandle;
    CIMTYPE m_ct;
    size_t m_nOffset;

protected:
    CTransientProperty();
    static HRESULT CreateNode(CTransientProperty** ppProp, 
                                IWbemQualifierSet* pSet);

public:
    virtual ~CTransientProperty();
    LPCWSTR GetName() const {return m_wszName;}

    static HRESULT CreateNew(CTransientProperty** ppProp, 
                                IWbemObjectAccess* pClass, 
                                LPCWSTR wszName);

    virtual size_t GetInstanceDataSize() {return 0;}
    virtual void SetInstanceDataOffset(size_t nOffset) {m_nOffset = nOffset;}
    virtual void SetClass(CTransientClass* pClass) {}

    virtual HRESULT Initialize(IWbemObjectAccess* pObj, LPCWSTR wszName);
    virtual HRESULT Create(CTransientInstance* pInstData);
    virtual HRESULT Update(CTransientInstance* pOldData, 
                            IWbemObjectAccess* pNew);
    virtual HRESULT Get(CTransientInstance* pInstData);
    virtual HRESULT Delete(CTransientInstance* pInstData);
    void* GetData(CTransientInstance* pInst) 
        {return pInst->GetOffset(m_nOffset);}
};

class CTimerProperty;
class CEggTimerInstruction : public CTimerInstruction
{
protected:
    long m_lRef;
    CWbemTime m_Time;
    CTimerProperty* m_pProp;
    CTransientInstance* m_pData;
    
public:
    CEggTimerInstruction(CTimerProperty* pProp, CTransientInstance* pData,
                            const CWbemTime& Time);
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
    CWbemTime GetFirstFiringTime() const {return m_Time;}
    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime, long* plCount) const
    {
        *plCount = 1;
        return CWbemTime::GetInfinity();
    }
    void AddRef();
    void Release();
    int GetInstructionType() {return 0;}
};

class CTimerProperty : public CTransientProperty
{
protected:
    static CTimerGenerator mstatic_Generator;
    CTransientClass* m_pClass;

public:
    CTimerProperty(){}
    ~CTimerProperty();

    virtual HRESULT Initialize(IWbemObjectAccess* pObj, LPCWSTR wszName);
    virtual HRESULT Create(CTransientInstance* pInstData);
    virtual HRESULT Update(CTransientInstance* pOldData, 
                            IWbemObjectAccess* pNew);
    virtual HRESULT Get(CTransientInstance* pInstData);
    virtual HRESULT Delete(CTransientInstance* pInstData);
    virtual void SetClass(CTransientClass* pClass);
    virtual size_t GetInstanceDataSize();

protected:
    HRESULT Set(CTransientInstance* pInstData, IWbemObjectAccess* pObj);
    static CTimerGenerator& GetGenerator() {return mstatic_Generator;}

    friend class CTimerPropertyData;
    friend class CEggTimerInstruction;
};
    
class CTimerPropertyData
{
protected:
    CEggTimerInstruction* m_pCurrentInst;
    CCritSec m_cs;
    CWbemTime m_Next;
    CWbemInterval m_Interval;

    friend class CTimerProperty;
public:
    CTimerPropertyData() : m_pCurrentInst(NULL){}
    ~CTimerPropertyData();

    void ResetInstruction();

};

class CTimeAverageData;
class CTimeAverageProperty : public CTransientProperty
{
protected:
    CIMTYPE m_ctValue;
    long m_lValueHandle;
    long m_lSwitchHandle;
    
public:
    CTimeAverageProperty(){}
    ~CTimeAverageProperty(){}

    virtual HRESULT Initialize(IWbemObjectAccess* pObj, LPCWSTR wszName);
    virtual HRESULT Create(CTransientInstance* pInstData);
    virtual HRESULT Update(CTransientInstance* pOldData, 
                            IWbemObjectAccess* pNew);
    virtual HRESULT Get(CTransientInstance* pInstData);
    virtual HRESULT Delete(CTransientInstance* pInstData);
    virtual size_t GetInstanceDataSize();
protected:
    void SetValue(CTimeAverageData* pData, double dblVal);
    void CombineLastValue(CTimeAverageData* pData, const CWbemTime& Now);
};

class CTimeAverageData
{
protected:
    double m_dblWeightedSum;
    CWbemInterval m_SumInterval;
    CWbemTime m_LastUpdate;
    double m_dblLastValue;
    bool m_bOn;

    friend CTimeAverageProperty;

public:
    CTimeAverageData();
};

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprov.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <comutl.h>
#include <statsync.h>
#include <genlex.h>
#include <objpath.h>
#include <cominit.h>
#include "trnsprov.h"
#include "trnsschm.h"

CStaticCritSec g_CSMap;
typedef std::map<WString, CTransientProvider*, WSiless, wbem_allocator<CTransientProvider*> > TProvMap;
typedef TProvMap::iterator TProvMapIterator;
TProvMap* g_pmapProvs;

const LPCWSTR g_wszTrnsEventProvName=L"Microsoft WMI Transient Event Provider";

HRESULT PlugKeyHoles(IWbemClassObject* pInst);

HRESULT CTransientProvider::ModuleInitialize()
{
    g_pmapProvs = new TProvMap;

    if ( g_pmapProvs == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CTransientProvider::ModuleUninitialize()
{
    delete g_pmapProvs;
    return S_OK;   
}


CTransientProvider::CTransientProvider( CLifeControl* pControl, 
                                        IUnknown* pOuter ) 
: CUnk(pControl, pOuter), m_XProv(this), m_XInit(this), 
  m_XClassChangeSink(this), m_pNamespace(NULL),
  m_pEggTimerClass(NULL), m_pSink(NULL), m_wszName(NULL),
  m_pCreationClass(NULL), m_pDeletionClass(NULL), 
  m_pModificationClass(NULL), m_pRedirectTo(NULL),
  m_pDES(NULL), m_pEventSink(NULL)
{
}

CTransientProvider::~CTransientProvider()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    if(m_pEggTimerClass)
        m_pEggTimerClass->Release();

    if(m_pSink)
        m_pSink->Release();
    
    if(m_pRedirectTo)
        m_pRedirectTo->Release();

    if ( m_pEventSink != NULL )
    {
        m_pEventSink->Release();
    }

    if( m_pDES )
    {
        m_pDES->UnRegister();
        m_pDES->Release();
    }

    delete [] m_wszName;
}

ULONG STDMETHODCALLTYPE CTransientProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);

    ENTER_API_CALL

    if(lRef == 0)
    {
        if(m_pRedirectTo == NULL)
        {
            CInCritSec ics(&g_CSMap);
            g_pmapProvs->erase(m_wszName);
        }

        delete this;
    }

    EXIT_API_CALL

    return lRef;
}

void* CTransientProvider::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProv;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else if(riid == IID_IWbemObjectSink)
        return &m_XClassChangeSink;
    else
        return NULL;
}

HRESULT CTransientProvider::GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
    ENTER_API_CALL

    if(m_pRedirectTo)
        return m_pRedirectTo->GetObjectAsync(strObjectPath, lFlags, pCtx, 
                                                pSink);

    //
    // Parse the object path to determine the class and the db key
    //

    CObjectPathParser Parser;
    ParsedObjectPath* pPath = NULL;
    int nRes = Parser.Parse(strObjectPath, &pPath);
    CDeleteMe<ParsedObjectPath> dm1(pPath);

    if(nRes != CObjectPathParser::NoError || 
        !pPath->IsInstance() || pPath->m_pClass == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics( &m_cs );

        TIterator it = m_mapClasses.find(pPath->m_pClass);
        if(it == m_mapClasses.end())
        {
            return WBEM_E_NOT_FOUND;
        }

        pClass = it->second;
    }

    //
    // Get Db key and delegate to class
    //
    
    LPWSTR wszDbKey = pPath->GetKeyString();
    if(wszDbKey == NULL)
        return WBEM_E_INVALID_OBJECT_PATH;
    CVectorDeleteMe<WCHAR> vdm1(wszDbKey);

    IWbemObjectAccess* pInst;
    HRESULT hres = pClass->Get(wszDbKey, &pInst);
    if(FAILED(hres))
        return hres;

    IWbemClassObject* pInstObj;
    pInst->QueryInterface(IID_IWbemClassObject, (void**)&pInstObj);
    CReleaseMe rm1(pInstObj);

    pSink->Indicate(1, &pInstObj);
    pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
    ENTER_API_CALL

    if(m_pRedirectTo)
        return m_pRedirectTo->CreateInstanceEnumAsync(strClass, lFlags, pCtx,
                                                        pSink);
    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics(&m_cs);

        TIterator it = m_mapClasses.find(strClass);
        if(it != m_mapClasses.end())
        {
            pClass = it->second;
        }
    }

    if ( pClass == NULL )
    {
            //
            // No instances --- that's not an error
            //

            pSink->SetStatus( WBEM_STATUS_COMPLETE, 
                              WBEM_S_NO_ERROR, 
                              NULL, 
                              NULL);
     
            return WBEM_S_NO_ERROR;
    }

    HRESULT hres = pClass->Enumerate(pSink);
    pSink->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
    return WBEM_E_NOT_SUPPORTED;
}

HRESULT CTransientProvider::DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
{
    ENTER_API_CALL

    if(m_pRedirectTo)
        return m_pRedirectTo->DeleteInstanceAsync(strObjectPath, lFlags, pCtx,
                                                    pSink);

    //
    // Parse the object path to determine the class and the db key
    //

    CObjectPathParser Parser;
    ParsedObjectPath* pPath = NULL;
    int nRes = Parser.Parse(strObjectPath, &pPath);
    CDeleteMe<ParsedObjectPath> dm1(pPath);

    if(nRes != CObjectPathParser::NoError || 
        !pPath->IsInstance() || pPath->m_pClass == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics( &m_cs );

        TIterator it = m_mapClasses.find(pPath->m_pClass);
        if(it == m_mapClasses.end())
            return WBEM_E_NOT_FOUND;
        pClass = it->second;
    }

    //
    // Get Db key and delegate to class
    //
    
    LPWSTR wszDbKey = pPath->GetKeyString();
    if(wszDbKey == NULL)
        return WBEM_E_INVALID_OBJECT_PATH;
    CVectorDeleteMe<WCHAR> vdm1(wszDbKey);

    IWbemObjectAccess* pOld = NULL;
    HRESULT hres = pClass->Delete(wszDbKey, &pOld);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pOld);

    //
    // Fire an instance deletion event
    //

    hres = FireIntrinsicEvent(m_pDeletionClass, pOld);

    pSink->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}
    
HRESULT CTransientProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
{
    ENTER_API_CALL

    if(m_pRedirectTo)
    return m_pRedirectTo->PutInstanceAsync(pInst, lFlags, pCtx, pSink);

    HRESULT hres;

    //
    // Get the class name and the relpath
    //

    VARIANT vClass;
    hres = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
    return hres;
    if(V_VT(&vClass) != VT_BSTR)
    return WBEM_E_INVALID_OBJECT;
    CClearMe cm1(&vClass);

    LPCWSTR wszClassName = V_BSTR(&vClass);

    VARIANT vKey;
    hres = pInst->Get(L"__RELPATH", 0, &vKey, NULL, NULL);
    if(FAILED(hres))
    return hres;
    CClearMe cm2(&vKey);

    if(V_VT(&vKey) != VT_BSTR)
    {
        //
        // No relpath yet.  Try plgging key holes
        //

        hres = PlugKeyHoles(pInst);
        if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

        hres = pInst->Get(L"__RELPATH", 0, &vKey, NULL, NULL);
        if(FAILED(hres))
        return hres;
        if(V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    }

    //
    // Parse the object path to determine the db key
    //

    CObjectPathParser Parser;
    ParsedObjectPath* pPath = NULL;
    int nRes = Parser.Parse(V_BSTR(&vKey), &pPath);
    CDeleteMe<ParsedObjectPath> dm1(pPath);

    if(nRes != CObjectPathParser::NoError || 
       !pPath->IsInstance() || pPath->m_pClass == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Get Db key
    //
    
    LPWSTR wszDbKey = pPath->GetKeyString();
    if(wszDbKey == NULL)
    return WBEM_E_INVALID_OBJECT_PATH;
    CVectorDeleteMe<WCHAR> vdm1(wszDbKey);

    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics( &m_cs );
        TIterator it = m_mapClasses.find( wszClassName );

        if( it == m_mapClasses.end() )
        {
            //
            // Time to create one.  Get the class def from the namespace
            //
            
            BSTR strClassName = SysAllocString(wszClassName);
            if(strClassName == NULL)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            CSysFreeMe sfm(strClassName);

            IWbemClassObject* pClassDef = NULL;
            
            hres = m_pNamespace->GetObject( strClassName, 
                                            0, 
                                            pCtx, 
                                            &pClassDef, 
                                            NULL );
            if(FAILED(hres))
            {
                return hres;
            }

            CReleaseMe rm1(pClassDef);
        
            //
            // Create a new structure and initialize it
            //
            
            pClass = new CTransientClass(this);

            if ( pClass == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            IWbemObjectAccess* pClassAccess;
            pClassDef->QueryInterface( IID_IWbemObjectAccess, 
                                       (void**)&pClassAccess );
            CReleaseMe rm2(pClassAccess);

            hres = pClass->Initialize(pClassAccess, wszClassName);
            if(FAILED(hres))
            {
                return hres;
            }
        
            m_mapClasses[wszClassName] = pClass;
        }
        else
        {
            pClass = it->second;
        }
    }

    //
    // Delegate to class
    //
    
    IWbemObjectAccess* pInstAccess;
    pInst->QueryInterface(IID_IWbemObjectAccess, (void**)&pInstAccess);
    CReleaseMe rm0(pInstAccess);

    IWbemObjectAccess* pOld = NULL;
    IWbemObjectAccess* pNew = NULL;
    hres = pClass->Put(pInstAccess, wszDbKey, lFlags, &pOld, &pNew);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pOld);
    CReleaseMe rm2(pNew);

    //
    // Fire creation or modification event
    //

    if(pOld)
        hres = FireIntrinsicEvent(m_pModificationClass, pNew, pOld);
    else
        hres = FireIntrinsicEvent(m_pCreationClass, pNew);

    pSink->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::FireIntrinsicEvent(IWbemClassObject* pClass,
                                               IWbemObjectAccess* pTarget, IWbemObjectAccess* pPrev)
{
    HRESULT hres;

    //  
    // Spawn an instance
    //

    IWbemClassObject* pEvent = NULL;
    hres = pClass->SpawnInstance(0, &pEvent);
    if(FAILED(hres))
    return hres;

    CReleaseMe rm1( pEvent );

    //
    // Set target instance
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    if(pTarget)
    {
        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = pTarget;
        pTarget->AddRef();

        hres = pEvent->Put(L"TargetInstance", 0, &v, 0);
        if(FAILED(hres))
        return hres;
        VariantClear(&v);
    }

    //
    // Set previous instance
    //

    if(pPrev)
    {
        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = pPrev;
        pPrev->AddRef();

        hres = pEvent->Put(L"PreviousInstance", 0, &v, 0);
        if(FAILED(hres))
        return hres;
        VariantClear(&v);
    }

    //  
    // Fire it off
    //

    hres = FireEvent(pEvent);

    if ( FAILED(hres) )
    {
        return hres;
    }
    
    return WBEM_S_NO_ERROR; 
}


HRESULT CTransientProvider::Init(
                                 /* [in] */ LPWSTR pszNamespace,
                                 /* [in] */ IWbemServices *pNamespace,
                                 /* [in] */ IWbemContext *pCtx,
                                 /* [in] */ IWbemProviderInitSink *pInitSink
                                 )
{
    ENTER_API_CALL

    HRESULT hres;

    //
    // Check if this namespace is already in the map
    //

    CInCritSec ics(&g_CSMap);

    TProvMapIterator it = g_pmapProvs->find(pszNamespace);
        
    if(it != g_pmapProvs->end())
    {
        //
        // Set the old one as our redirector and return.
        //
        
        m_pRedirectTo = it->second;
        m_pRedirectTo->AddRef();
            
        pInitSink->SetStatus(0, WBEM_S_NO_ERROR);
        return WBEM_S_NO_ERROR;
    }

    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
    
    m_wszName = new WCHAR[wcslen(pszNamespace)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchCopyW( m_wszName, wcslen(pszNamespace)+1, pszNamespace);

    //
    // Retrieve the class definitions for events
    //

    BSTR strEgg = SysAllocString(EGGTIMER_EVENT_CLASS);
    if ( strEgg == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strEgg);
    hres = m_pNamespace->GetObject(strEgg, 0, pCtx, &m_pEggTimerClass, NULL);
    if(FAILED(hres))
        return hres;

    BSTR strCreate = SysAllocString(L"__InstanceCreationEvent");
    if ( strCreate == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm2(strCreate);
    hres = m_pNamespace->GetObject(strCreate, 0, pCtx, &m_pCreationClass, NULL);
    if(FAILED(hres))
        return hres;

    BSTR strDelete = SysAllocString(L"__InstanceDeletionEvent");
    if ( strDelete == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm3(strDelete);
    hres = m_pNamespace->GetObject(strDelete, 0, pCtx, &m_pDeletionClass, NULL);
    if(FAILED(hres))
        return hres;

    BSTR strMod = SysAllocString(L"__InstanceModificationEvent");
    if ( strMod == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm(strMod);
    hres = m_pNamespace->GetObject(strMod, 0, pCtx, &m_pModificationClass,NULL);
    if(FAILED(hres))
        return hres;

    //
    // Obtain our event sink
    //

    hres = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                             NULL, 
       		     	     CLSCTX_INPROC_SERVER, 
       			     IID_IWbemDecoupledBasicEventProvider,
       			     (void**)&m_pDES );
    if ( FAILED(hres) )
    {
        return hres;
    }

    hres = m_pDES->Register( 0,
                             NULL,
                             NULL,
                             NULL,
                             pszNamespace,
                             g_wszTrnsEventProvName,
                             NULL );
    
    if ( FAILED(hres) )
    {
        return hres;
    }

    //
    // get the decoupled event sink
    //

    hres = m_pDES->GetSink( 0, NULL, &m_pEventSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    pInitSink->SetStatus(0, WBEM_S_NO_ERROR);

    //
    // register for class change/deletion events for transient state base.
    //

    CWbemPtr<IWbemObjectSink> pSink;

    hres = QueryInterface( IID_IWbemObjectSink, (void**)&pSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    CWbemBSTR bsQuery;
    CWbemBSTR bsQueryLang = L"WQL";

    bsQuery = L"select * from __ClassModificationEvent where "
              L"TargetClass ISA 'MSFT_TransientStateBase'";

    hres = pNamespace->ExecNotificationQueryAsync( bsQueryLang,
                                                   bsQuery,
                                                   0,
                                                   pCtx,
                                                   pSink );
    if ( FAILED(hres) )   
    {
        return hres;
    }

    bsQuery = L"select * from __ClassDeletionEvent where "
              L"TargetClass ISA 'MSFT_TransientStateBase'";

    hres = pNamespace->ExecNotificationQueryAsync( bsQueryLang,
                                                   bsQuery,
                                                   0,
                                                   pCtx,
                                                   pSink );
    if ( FAILED(hres) )  
    {
        return hres;
    }

    //
    // now that we're fully initialized, add ourselves to the provider 
    // list so that others can connect to us.
    //

    (*g_pmapProvs)[pszNamespace] = this;
        
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::FireEvent(IWbemClassObject* pEvent)
{
    return m_pEventSink->Indicate(1, &pEvent);
}
   
HRESULT PlugKeyHoles(IWbemClassObject* pInst)
{
    HRESULT hres;

    //
    // Enumerate all keys
    //

    hres = pInst->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
    if(FAILED(hres))
        return hres;

    VARIANT vProp;
    BSTR strPropName;
    CIMTYPE ct;
    while(pInst->Next(0, &strPropName, &vProp, &ct, NULL) == S_OK)
    {
        CClearMe cm(&vProp);
        CSysFreeMe sfm(strPropName);
    
        //
        // Check if the value of this key is NULL
        //

        if(V_VT(&vProp) == VT_NULL)
        {
            if(ct != CIM_STRING)
            {
                // We don't support non-string key holes
                return WBEM_E_ILLEGAL_NULL;
            }
            else
            {
                //
                // Get a guid and put it there
                // 

                GUID guid;
                CoCreateGuid(&guid);
                WCHAR wszBuffer[100];
                StringFromGUID2(guid, wszBuffer, 100);
        
                // 
                // Stick it in the variant --- it will get cleared
                //

                V_VT(&vProp) = VT_BSTR;
                V_BSTR(&vProp) = SysAllocString(wszBuffer);
                if ( V_BSTR(&vProp) == NULL )
                    return WBEM_E_OUT_OF_MEMORY;
                hres = pInst->Put(strPropName, 0, &vProp, 0);
                if(FAILED(hres))
                    return WBEM_E_ILLEGAL_NULL;
            }
        }
    }

    pInst->EndEnumeration();
    return WBEM_S_NO_ERROR;
}

//*****************************************************************************
//
//              EVENT PROVIDER
//
//*****************************************************************************

CTransientEventProvider::CTransientEventProvider(CLifeControl* pControl, 
                                                    IUnknown* pOuter)
: CUnk(pControl, pOuter), m_XInit(this), m_XEvent(this), m_wszName(NULL),
  m_pRebootEventClass(NULL),  m_bLoadedOnReboot(FALSE)
{
}

CTransientEventProvider::~CTransientEventProvider()
{
    if(m_pRebootEventClass)
        m_pRebootEventClass->Release();
    delete [] m_wszName;
}

void* CTransientEventProvider::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else if(riid == IID_IWbemEventProvider)
        return &m_XEvent;
    else 
        return NULL;
}



HRESULT CTransientEventProvider::Init(LPWSTR pszNamespace, 
                                        IWbemServices* pNamespace,
                                        IWbemContext* pCtx,
                                        IWbemProviderInitSink *pInitSink)
{
    ENTER_API_CALL

    HRESULT hres;

    m_wszName = new WCHAR[wcslen(pszNamespace)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchCopyW(m_wszName, wcslen(pszNamespace)+1,pszNamespace);

    //
    // Get the class of the reboot event
    //

    BSTR strClass = SysAllocString(REBOOT_EVENT_CLASS);  
    if ( strClass == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm(strClass);
    hres = pNamespace->GetObject(strClass, 0, pCtx, &m_pRebootEventClass, NULL);
    if(FAILED(hres))
        return hres;
        
    if ( pCtx != NULL )
    {
        //
        // check context object for ess initialization value.
        //
        
        VARIANT vInit;
        hres = pCtx->GetValue( L"__EssInInitialize", 0, &vInit );
        
        if ( SUCCEEDED(hres) && V_BOOL(&vInit) == VARIANT_TRUE )
        {
            m_bLoadedOnReboot = TRUE;
        }
    }

    pInitSink->SetStatus(0, WBEM_S_NO_ERROR);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientEventProvider::ProvideEvents(long lFlags, 
                                                IWbemObjectSink* pSink)
{
    ENTER_API_CALL

    HRESULT hres;

    if( m_bLoadedOnReboot )
    {
        //
        // Fire a transient reboot event if we're just starting up.
        //
    
        IWbemClassObject* pEvent;
        hres = m_pRebootEventClass->SpawnInstance(0, &pEvent);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pEvent);

        hres = pSink->Indicate(1, &pEvent);
        if(FAILED(hres))
            return hres;
    }

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

void CTransientProvider::PurgeClass( LPCWSTR wszName )
{
    CInCritSec ics( &m_cs );

    TIterator it = m_mapClasses.find( wszName );

    if ( it != m_mapClasses.end() )
    {
        m_mapClasses.erase( it );
    }
}

STDMETHODIMP CTransientProvider::XClassChangeSink::Indicate(
                                   long cObjs, IWbemClassObject** ppObjs )
{
    HRESULT hr;

    //
    // get the name of the class that was changed or deleted and call purge.
    //

    for( int i=0; i < cObjs; i++ )
    {
        CPropVar vClass;

        hr = ppObjs[i]->Get( L"TargetClass", 0, &vClass, NULL, NULL );

        if ( SUCCEEDED(hr) && V_VT(&vClass) == VT_UNKNOWN )
        {
            CWbemPtr<IWbemClassObject> pClass;

            hr = V_UNKNOWN(&vClass)->QueryInterface( IID_IWbemClassObject, 
                                                     (void**)&pClass );
        
            if ( SUCCEEDED(hr) )
            {
                CPropVar vName;

                hr = pClass->Get( L"__CLASS", 0, &vName, NULL, NULL );

                if ( SUCCEEDED(hr) && V_VT(&vName) == VT_BSTR )
                {
                    m_pObject->PurgeClass( V_BSTR(&vName) );
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprov.h ===
#ifndef __WMI_TRANSIENT_PROVIDER__H_
#define __WMI_TRANSIENT_PROVIDER__H_

#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <map>
#include <wstlallc.h>
#include "trnscls.h"

class CTransientProvider : public CUnk
{
protected:
    class XProv : public CImpl<IWbemServices, CTransientProvider>
    {
    public:
        XProv(CTransientProvider* pObject) 
            : CImpl<IWbemServices, CTransientProvider>(pObject)
        {}
		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
        {
            return m_pObject->GetObjectAsync(ObjectPath, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
        {
            return m_pObject->PutInstanceAsync(pInst, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
        {
            return m_pObject->DeleteInstanceAsync(ObjectPath, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
        {
            return m_pObject->CreateInstanceEnumAsync(Class, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
        {
            return m_pObject->ExecQueryAsync(QueryLanguage, Query, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

    } m_XProv;
    friend XProv;

    class XClassChangeSink : public CImpl<IWbemObjectSink, CTransientProvider>
    {
    public:
         XClassChangeSink( CTransientProvider* pObject )
         : CImpl<IWbemObjectSink, CTransientProvider>(pObject) {}

         STDMETHOD(Indicate)( long cObjs, IWbemClassObject** ppObjs );
        
         STDMETHOD(SetStatus)( long lFlags,
                               HRESULT hResult,
                               BSTR strParam,
                               IWbemClassObject* pObjParam )
         {
             return WBEM_S_NO_ERROR;
         }
    } m_XClassChangeSink;

    friend class XClassChangeSink;

    class XInit : public CImpl<IWbemProviderInit, CTransientProvider>
    {
    public:
        XInit(CTransientProvider* pObject) 
            : CImpl<IWbemProviderInit, CTransientProvider>(pObject)
        {}
        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        )
        {
            return m_pObject->Init(pszNamespace, pNamespace, pCtx, pInitSink);
        }
    } m_XInit;
    friend XInit;

protected:

    CCritSec m_cs;

    IWbemServices* m_pNamespace;
    CTransientProvider* m_pRedirectTo;

    LPWSTR m_wszName;
    IWbemObjectSink* m_pSink;
    typedef std::map< WString, 
                      CWbemPtr<CTransientClass>, 
                      WSiless, 
                      wbem_allocator<CWbemPtr<CTransientClass> > > TMap;
    typedef TMap::iterator TIterator;
    TMap m_mapClasses;

    IWbemDecoupledBasicEventProvider* m_pDES;
    IWbemObjectSink* m_pEventSink;

    IWbemClassObject* m_pEggTimerClass;
    IWbemClassObject* m_pCreationClass;
    IWbemClassObject* m_pDeletionClass;
    IWbemClassObject* m_pModificationClass;

    void PurgeClass( LPCWSTR wszName );

public:

    CTransientProvider(CLifeControl* pControl, IUnknown* pOuter = NULL);
    ~CTransientProvider();
    void* GetInterface(REFIID riid);

    ULONG STDMETHODCALLTYPE Release();

    HRESULT GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    HRESULT CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    HRESULT ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    HRESULT DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    HRESULT PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    HRESULT Init(
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink );

    static HRESULT ModuleInitialize();
    static HRESULT ModuleUninitialize();

    HRESULT FireEvent(IWbemClassObject* pEvent);
    INTERNAL IWbemClassObject* GetEggTimerClass() {return m_pEggTimerClass;}
    INTERNAL IWbemClassObject* GetCreationClass() {return m_pCreationClass;}
    INTERNAL IWbemClassObject* GetDeletionClass() {return m_pDeletionClass;}
    INTERNAL IWbemClassObject* GetModificationClass() 
        {return m_pModificationClass;}
protected:

    HRESULT FireIntrinsicEvent(IWbemClassObject* pClass,
            IWbemObjectAccess* pTarget, IWbemObjectAccess* pPrev = NULL);
};



class CTransientEventProvider : public CUnk
{
    class XInit : public CImpl<IWbemProviderInit, CTransientEventProvider>
    {
    public:
        XInit(CTransientEventProvider* pObject) 
        : CImpl<IWbemProviderInit, CTransientEventProvider>(pObject)
        {}
        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        )
        {
            return m_pObject->Init(pszNamespace, pNamespace, pCtx, pInitSink);
        }
    } m_XInit;
    friend XInit;

    class XEvent : public CImpl<IWbemEventProvider, CTransientEventProvider>
    {
    public:
        XEvent(CTransientEventProvider* pObject) 
        : CImpl<IWbemEventProvider, CTransientEventProvider>(pObject)
        {}
        HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink* pSink, 
                                                long lFlags)
        {
            return m_pObject->ProvideEvents(lFlags, pSink);
        }
    } m_XEvent;
    friend XEvent;

 protected:
    LPWSTR m_wszName;
    IWbemClassObject* m_pRebootEventClass;
    BOOL m_bLoadedOnReboot;
    
 protected:
    HRESULT Init(LPWSTR pszNamespace, IWbemServices* pNamespace, 
                    IWbemContext* pCtx, IWbemProviderInitSink *pInitSink);
    HRESULT ProvideEvents(long lFlags, IWbemObjectSink* pSink);

 public:
    CTransientEventProvider(CLifeControl* pControl, IUnknown* pOuter = NULL);
    ~CTransientEventProvider();
    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\objacces.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include "objacces.h"

/****************************************************************************
  CPropAccessor
*****************************************************************************/

HRESULT CPropAccessor::GetParentObject( ObjectArray& raObjects,
                                        _IWmiObject** ppParent )
{
    HRESULT hr = WBEM_S_NO_ERROR;
 
    *ppParent = NULL;

    if ( m_pParent == NULL )
    {
        _DBG_ASSERT( raObjects.size() > 0 );
        *ppParent = raObjects[0];
        (*ppParent)->AddRef();
    }
    else
    {
        CPropVar vParent;
        
        hr = m_pParent->GetProp( raObjects, 0, &vParent, NULL );

        if ( SUCCEEDED(hr) )
        {
            _DBG_ASSERT( V_VT(&vParent) == VT_UNKNOWN );

            hr = V_UNKNOWN(&vParent)->QueryInterface( IID__IWmiObject,                                                               (void**)ppParent );
        }
    }

    return hr;
}

/****************************************************************************
  CFastPropAccessor
*****************************************************************************/

HRESULT CFastPropAccessor::GetProp( ObjectArray& raObjects,
                                    DWORD dwFlags, 
                                    VARIANT* pvar, 
                                    CIMTYPE* pct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( pvar != NULL )
    {
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );
        
        if ( SUCCEEDED(hr) )
        {
            hr = ReadValue( pParent, pvar );
        }
    }
    
    if ( pct != NULL )
    {
        *pct = m_ct;
    }

    return hr;
}

HRESULT CFastPropAccessor::PutProp( ObjectArray& raObjects,
                                    DWORD dwFlags, 
                                    VARIANT* pvar, 
                                    CIMTYPE ct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( pvar != NULL )
    {
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );
        
        if ( SUCCEEDED(hr) )
        {
            hr = WriteValue( pParent, pvar );
        }
    }

    return hr;
}

/****************************************************************************
  CStringPropAccessor
*****************************************************************************/

HRESULT CStringPropAccessor::ReadValue( _IWmiObject* pObj, VARIANT* pvar )
{
    HRESULT hr;
    
    long cBuff;

    hr = pObj->ReadPropertyValue( m_lHandle, 0, &cBuff, NULL );

    if ( hr == WBEM_E_BUFFER_TOO_SMALL )
    {
        BSTR bstr = SysAllocStringByteLen( NULL, cBuff );

        if ( bstr != NULL )
        {
            hr = pObj->ReadPropertyValue( m_lHandle, 
                                          cBuff, 
                                          &cBuff, 
                                          PBYTE(bstr) );
            if ( SUCCEEDED(hr) )
            {
                V_VT(pvar) = VT_BSTR;
                V_BSTR(pvar) = bstr;
            }
            else
            {
                SysFreeString( bstr );
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if ( SUCCEEDED(hr) )
    {
        V_VT(pvar) = VT_NULL;
    }

    return hr;
}

HRESULT CStringPropAccessor::WriteValue( _IWmiObject* pObj, VARIANT* pvar )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( V_VT(pvar) == VT_BSTR )
    {
        ULONG cLen = wcslen( V_BSTR(pvar) );
        hr = pObj->WritePropertyValue( m_lHandle, 
                                       cLen*2+2, 
                                       PBYTE(V_BSTR(pvar)) );  
    }
    else if ( V_VT(pvar) == VT_NULL )
    {
        //
        // how do we handle NULL ?? 
        //
    }
    else
    {
        hr = WBEM_E_TYPE_MISMATCH;
    }

    return hr;
}

/****************************************************************************
  CSimplePropAccessor
*****************************************************************************/

HRESULT CSimplePropAccessor::GetProp( ObjectArray& raObjects,
                                      DWORD dwFlags, 
                                      VARIANT* pvar, 
                                      CIMTYPE* pct )
{
    HRESULT hr;

    if ( m_pDelegateTo == NULL )
    {        
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );

        if ( SUCCEEDED(hr) )
        {
            hr = pParent->Get( m_wsName, 0, pvar, pct, NULL );
        }
    }
    else
    {
        hr = m_pDelegateTo->GetProp( raObjects, dwFlags, pvar, pct );
    }

    return hr;
}
                                     
HRESULT CSimplePropAccessor::PutProp( ObjectArray& raObjects,
                                      DWORD dwFlags, 
                                      VARIANT* pvar, 
                                      CIMTYPE ct )
{
    HRESULT hr;

    if ( m_pDelegateTo == NULL )
    {
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );

        if ( SUCCEEDED(hr) )
        {
            hr = pParent->Put( m_wsName, 0, pvar, ct );
        }
    }
    else
    {
        hr = m_pDelegateTo->PutProp( raObjects, dwFlags, pvar, ct );
    }

    return hr;
}

/****************************************************************************
  CEmbeddedPropAccessor
*****************************************************************************/

HRESULT CEmbeddedPropAccessor::GetProp( ObjectArray& raObjects,
                                        DWORD dwFlags, 
                                        VARIANT* pvar, 
                                        CIMTYPE* pct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VariantInit( pvar );

    if ( raObjects.size() <= m_lObjIndex )
    {
        raObjects.resize( m_lObjIndex*2 );
    }

    _IWmiObjectP pObj = raObjects[m_lObjIndex];
 
    if ( pObj != NULL )
    {
        V_VT(pvar) = VT_UNKNOWN;
        V_UNKNOWN(pvar) = pObj;
        pObj->AddRef();
    }
    else
    {
        _IWmiObjectP pParent;

        hr = GetParentObject( raObjects, &pParent );

        if ( SUCCEEDED(hr) )
        {
            CPropVar vProp;

            hr = pParent->Get( m_wsName, 0, &vProp, pct, NULL );

            if ( SUCCEEDED(hr) )
            {
                if ( V_VT(&vProp) == VT_UNKNOWN )
                {
                    hr = V_UNKNOWN(&vProp)->QueryInterface( IID__IWmiObject,
                                                            (void**)&pObj );
                    if ( SUCCEEDED(hr) )
                    {
                        raObjects[m_lObjIndex] = pObj;
                        V_VT(pvar) = VT_UNKNOWN;
                        V_UNKNOWN(pvar) = pObj;
                        pObj->AddRef();
                    }
                }
                else if ( V_VT(&vProp) == VT_NULL )
                {
                    hr = WBEM_E_NOT_FOUND;
                }
                else
                {
                    hr = WBEM_E_TYPE_MISMATCH;
                }
            }
        }
    }

    return hr;
}
                                     
HRESULT CEmbeddedPropAccessor::PutProp( ObjectArray& raObjects,
                                        DWORD dwFlags, 
                                        VARIANT* pvar, 
                                        CIMTYPE ct )
{
    HRESULT hr;

    if ( raObjects.size() <= m_lObjIndex )
    {
        raObjects.resize( m_lObjIndex*2 );
    }

    _IWmiObjectP pParent;

    hr = GetParentObject( raObjects, &pParent );

    if ( SUCCEEDED(hr) )
    {
        hr = pParent->Put( m_wsName, 0, pvar, ct );
        
        if ( SUCCEEDED(hr) )
        {
            _IWmiObjectP pObj;

            if ( V_VT(pvar) == VT_UNKNOWN )
            {
                hr = V_UNKNOWN(pvar)->QueryInterface( IID__IWmiObject, 
                                                      (void**)&pObj );
            }

            if ( SUCCEEDED(hr) )
            {
                raObjects[m_lObjIndex] = pObj;
            }
        } 
    }

    return hr;
}

/****************************************************************************
  CObjectAccessFactory - impl for IWmiObjectAccessFactory
*****************************************************************************/

STDMETHODIMP CObjectAccessFactory::SetObjectTemplate( IWbemClassObject* pTmpl )
{
    HRESULT hr;

    if ( m_pTemplate == NULL )
    {
        hr = pTmpl->QueryInterface( IID__IWmiObject, (void**)&m_pTemplate );
    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

STDMETHODIMP CObjectAccessFactory::GetObjectAccess(IWmiObjectAccess** ppAccess)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    *ppAccess = new CObjectAccess( m_pControl );

    if ( *ppAccess != NULL )
    {
        (*ppAccess)->AddRef();
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CObjectAccessFactory::FindOrCreateAccessor( LPCWSTR wszPropElem,
                                                    BOOL bEmbedded,
                                                    CPropAccessor* pParent, 
                                                    CPropAccessor** ppAccessor)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    *ppAccessor = NULL;

    //
    // determine the map the use for the prop accessors.  
    // 

    PropAccessMap* pmapPropAccess;

    if ( pParent != NULL )
    {
        _DBG_ASSERT( pParent->GetType() == CPropAccessor::e_Embedded ); 
        pmapPropAccess = &((CEmbeddedPropAccessor*)pParent)->m_mapPropAccess;
    }
    else
    {
        pmapPropAccess = &m_mapPropAccess;
    }

    //
    // see if an accessor already exists.  If not create one.
    //

    PropAccessMap::iterator it = pmapPropAccess->find( wszPropElem );

    //
    // if we're untyped and the accessor is also a Simple 
    // accessor, but now we know it to be embedded, convert the
    // accessor to an embedded one.
    // 

    if ( it != pmapPropAccess->end() && 
         !( bEmbedded && it->second->GetType() == CPropAccessor::e_Simple ) )
    {
        *ppAccessor = it->second;
        (*ppAccessor)->AddRef();
    }
    else
    {
        long lHandle = -1;
        CIMTYPE cimtype = 0;

        if ( m_pTemplate != NULL )
        {
            //
            // get type information from the template. Also get handle
            // if possible. For now, we don't do anything special for 
            // properties that are embedded.
            //
            
            if ( !bEmbedded )
            {
                hr = m_pTemplate->GetPropertyHandle( wszPropElem,
                                                     &cimtype,
                                                     &lHandle );
                if ( SUCCEEDED(hr) )
                {
                    ;
                }
                else
                {
                    cimtype = -1;
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }

        CWbemPtr<CPropAccessor> pAccessor;
        
        if ( SUCCEEDED(hr) )
        {
            if ( bEmbedded )
            {
                pAccessor = new CEmbeddedPropAccessor( wszPropElem, 
                                                       m_lIndexGenerator++, 
                                                       pParent );
            }
            else if ( m_pTemplate != NULL && lHandle != -1 && cimtype == CIM_STRING )
            {
                pAccessor = new CStringPropAccessor( lHandle, cimtype, pParent );
            }
            else
            {
                pAccessor = new CSimplePropAccessor( wszPropElem, pParent );
            }
        }

        //
        // add to the map. If an entry does exists already, then have it 
        // delegate to our new one. The new entry becomes responsible for 
        // the original one to keep it alive.
        //
                
        if ( pAccessor != NULL )
        {
            if ( it != pmapPropAccess->end() )
            {
                pAccessor->AssumeOwnership( it->second );
                it->second->DelegateTo( pAccessor );
            }

            (*pmapPropAccess)[wszPropElem] = pAccessor;
            pAccessor->AddRef();
            *ppAccessor = pAccessor;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

STDMETHODIMP CObjectAccessFactory::GetPropHandle( LPCWSTR wszProp, 
                                                  DWORD dwFlags, 
                                                  LPVOID* ppHdl )
{
    HRESULT hr;

    ENTER_API_CALL

    WString wsProp( wszProp );

    LPWSTR wszPropElem = wcstok( wsProp, L"." );
    
    CWbemPtr<CPropAccessor> pAccessor;
    CWbemPtr<CPropAccessor> pParentAccessor;

    do
    {
        LPWSTR wszNextPropElem = wcstok( NULL, L"." );
    
        pAccessor.Release();

        hr = FindOrCreateAccessor( wszPropElem, 
                                   wszNextPropElem != NULL, 
                                   pParentAccessor, 
                                   &pAccessor );

        pParentAccessor = pAccessor;
        wszPropElem = wszNextPropElem;

    } while( SUCCEEDED(hr) && wszPropElem != NULL );

    if ( SUCCEEDED(hr) )
    {
        *ppHdl = pAccessor;
    }
    else
    {
        *ppHdl = NULL;
    }

    EXIT_API_CALL

    return hr;
}

/***************************************************************************
  CObjectAccess
****************************************************************************/

STDMETHODIMP CObjectAccess::CommitChanges()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ENTER_API_CALL

    //
    // commit our embeddeded objects.  Since the set of embedded object 
    // accessors is ordered by level, we will do things in the right order.
    //

    EmbeddedPropAccessSet::iterator it;

    for( it = m_setEmbeddedAccessorsToCommit.begin(); 
         it != m_setEmbeddedAccessorsToCommit.end(); it++ )
    {
        CEmbeddedPropAccessor* pAccessor = *it;

        IWbemClassObject* pProp = m_aObjects[pAccessor->GetObjectIndex()];
        _DBG_ASSERT( pProp != NULL );

        VARIANT vProp;
        V_VT(&vProp) = VT_UNKNOWN;
        V_UNKNOWN(&vProp) = pProp;

        hr = pAccessor->PutProp( m_aObjects, 0, &vProp, CIM_OBJECT );

        if ( SUCCEEDED(hr) )
        {
            ;
        }
        else
        {
            break;
        }
    }

    EXIT_API_CALL

    return hr;
}

STDMETHODIMP CObjectAccess::GetObject( IWbemClassObject** ppObj )
{
    HRESULT hr;

    if ( m_aObjects.size() > 0 && m_aObjects[0] != NULL )
    {
        m_aObjects[0]->AddRef();
        *ppObj = m_aObjects[0];
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        *ppObj = NULL;
        hr = WBEM_S_FALSE;
    }
    
    return hr;
}

STDMETHODIMP CObjectAccess::SetObject( IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ENTER_API_CALL

    m_aObjects.clear();    
    m_setEmbeddedAccessorsToCommit.clear();

    if ( pObj != NULL )
    {
        CWbemPtr<_IWmiObject> pIntObj;

        hr = pObj->QueryInterface( IID__IWmiObject, (void**)&pIntObj );

        if ( SUCCEEDED(hr) )
        {
            m_aObjects.insert( m_aObjects.end(), pIntObj );
        }
    }

    EXIT_API_CALL

    return hr;
}
    
STDMETHODIMP CObjectAccess::GetProp( LPVOID pHdl, 
                                     DWORD dwFlags,
                                     VARIANT* pvar, 
                                     CIMTYPE* pct )
{
    HRESULT hr;

    ENTER_API_CALL

    if ( m_aObjects.size() > 0 )
    {
        hr = ((CPropAccessor*)pHdl)->GetProp( m_aObjects, dwFlags, pvar, pct );
    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    EXIT_API_CALL

    return hr;
}

STDMETHODIMP CObjectAccess::PutProp( LPVOID pHdl, 
                                     DWORD dwFlags, 
                                     VARIANT* pvar,
                                     CIMTYPE ct )
{
    HRESULT hr;

    ENTER_API_CALL

    if ( m_aObjects.size() > 0 )
    {
        CPropAccessor* pAccessor = (CPropAccessor*)pHdl;

        CEmbeddedPropAccessor* pParent = 
              (CEmbeddedPropAccessor*)pAccessor->GetParent();

        hr = pAccessor->PutProp( m_aObjects, dwFlags, pvar, ct );
                                           
        if ( SUCCEEDED(hr) )
        {
            //
            // if there is an 
            if ( pParent == NULL )
            {
                ;
            }
            else
            {
                m_setEmbeddedAccessorsToCommit.insert( pParent );
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    EXIT_API_CALL

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\objacces.h ===
#ifndef __OBJACCES_H__
#define __OBJACCES_H__

#include <wbemint.h>
#include <wstring.h>
#include <comutl.h>
#include <arrtempl.h>
#include <unk.h>
#include <map>
#include <vector>
#include <set>
#include <wstlallc.h>
#include "wmimsg.h"

typedef CWbemPtr<_IWmiObject> _IWmiObjectP;
typedef std::vector< _IWmiObjectP, wbem_allocator<_IWmiObjectP> > ObjectArray;

/****************************************************************************
  CPropAccessor - base class for all prop accessors.  Property Accessors are 
  passed back from the GetPropHandle() method of IWmiObjectAccessFactory.
*****************************************************************************/

class CPropAccessor : public CUnk
{

protected:

    //
    // if the object we're accessing is not a top level object, then we'll
    // have a parent accessor to get it.  Cannot hold reference here, 
    // because in some cases the parent may hold a reference on the child and
    // we'd have a circular reference.  It will not be possible though for a 
    // parent to be deleted out from the child.
    // 
    CPropAccessor* m_pParent;

    //
    // Accessor to delegate to.  Sometimes, once a prop accessor is 
    // handed out, we learn more about the property ( e.g. its type )
    // and it would be beneficial to have the original accessor delegate 
    // to a more efficient one.  we don't hold a reference here because 
    // the delegate will assume ownership of this object and will hold 
    // a reference on it.  Holding a reference to the delegate would cause
    // a circular reference.
    //
    CPropAccessor* m_pDelegateTo;

    //
    // whenever a prop accessor is replaced by a more efficient one, it 
    // is removed from the map.  Since the map holds onto the ref that 
    // keeps the accessor alive, we need to the new accessor be responsible
    // for cleaning up the original one.  The original one is potentially
    // still being used by the client ( but now delegates to the new accessor )
    // ane we have to keep it alive for the lifetime of the access factory.
    //
    CWbemPtr<CPropAccessor> m_pResponsibleFor;
 
    //
    // level of the property - 0 means its a property on a top level object.
    //
    int m_nLevel;

    HRESULT GetParentObject( ObjectArray& raObjects, _IWmiObject** ppParent );
   
    void* GetInterface( REFIID ) { return NULL; }

public:

    CPropAccessor( CPropAccessor* pParent ) 
    : m_pParent( pParent ), m_pDelegateTo( NULL )
    { 
        if ( pParent == NULL )
            m_nLevel = 0;
        else
            m_nLevel = pParent->GetLevel() + 1;
    }

    int GetLevel() const { return m_nLevel; }
    CPropAccessor* GetParent() { return m_pParent; } 

    enum AccessorType_e { e_Simple, e_Fast, e_Embedded };

    virtual ~CPropAccessor() {} 

    virtual HRESULT GetProp( ObjectArray& raObjects,
			     DWORD dwFlags, 
			     VARIANT* pvar, 
			     CIMTYPE* pct ) = 0;

    virtual HRESULT PutProp( ObjectArray& raObjects,
			     DWORD dwFlags, 
			     VARIANT* pvar,
                             CIMTYPE ct ) = 0;

    virtual AccessorType_e GetType() = 0;

    void AssumeOwnership( CPropAccessor* pAccessor )
    {
        m_pResponsibleFor = pAccessor;
    }

    void DelegateTo( CPropAccessor* pAccessor ) 
    { 
        m_pDelegateTo = pAccessor; 
    }
};

typedef CWbemPtr<CPropAccessor> CPropAccessorP;

typedef std::map< WString, 
                  CPropAccessorP, 
                  WSiless, 
                  wbem_allocator<CPropAccessorP> > PropAccessMap;

/*****************************************************************************
  CEmbeddedPropAccessor - accessor for an embedded object property.
  This impl caches the embedded object that is accessed to optimize 
  subsequent accesses.
******************************************************************************/

class CEmbeddedPropAccessor : public CPropAccessor
{
    //
    // name of the embedded object property.
    //
    WString m_wsName;
    
    //
    // the index in the object array where the embedded obj will be cached 
    // when accessed for the first time.
    //
    long m_lObjIndex;

    //
    // child accessors for the embedded object.
    //
    PropAccessMap m_mapPropAccess;

    friend class CObjectAccessFactory;

public:

    CEmbeddedPropAccessor( LPCWSTR wszName, 
                           long lObjIndex,
                           CPropAccessor* pParent = NULL )
    : CPropAccessor( pParent ), m_wsName( wszName ), m_lObjIndex( lObjIndex )
    {
    } 

    HRESULT GetProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
		     VARIANT* pvar, 
		     CIMTYPE* pct );

    HRESULT PutProp( ObjectArray& raObjects, 
		     DWORD dwFlags, 
		     VARIANT* pvar,
                     CIMTYPE ct );

    AccessorType_e GetType() { return e_Embedded; }

    int GetObjectIndex() { return m_lObjIndex; }
};

/*****************************************************************************
  CSimplePropAccessor - simple accessor for non-embedded object properties. 
******************************************************************************/

class CSimplePropAccessor : public CPropAccessor
{
    //
    // name of the embedded object property.
    //
    WString m_wsName;

public:

    CSimplePropAccessor( LPCWSTR wszName, CPropAccessor* pParent = NULL )
    : CPropAccessor( pParent ), m_wsName( wszName ) { }

    HRESULT GetProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
		     VARIANT* pvar, 
		     CIMTYPE* pct );

    HRESULT PutProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
                     VARIANT* pvar, 
                     CIMTYPE ct ); 

    AccessorType_e GetType() { return e_Simple; }
};

/*****************************************************************************
  CFastPropAccessor - fast accessor base for non-embedded object properties. 
  Is used when the type of the property is known at property handle creation.
******************************************************************************/

class CFastPropAccessor : public CPropAccessor
{
protected:

    long m_lHandle;
    CIMTYPE m_ct;

public:

    CFastPropAccessor( long lHandle, CIMTYPE ct, CPropAccessor* pParent=NULL )
    : CPropAccessor( pParent ), m_lHandle( lHandle ), m_ct( ct ) { }

    HRESULT GetProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
		     VARIANT* pvar, 
		     CIMTYPE* pct );

    HRESULT PutProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
                     VARIANT* pvar, 
                     CIMTYPE ct ); 

    AccessorType_e GetType() { return e_Fast; }

    virtual HRESULT ReadValue( _IWmiObject* pObj, VARIANT* pvar ) = 0;
    virtual HRESULT WriteValue( _IWmiObject* pObj, VARIANT* pvar ) = 0;
};

/*****************************************************************************
  CStringPropAccessor
******************************************************************************/

class CStringPropAccessor : public CFastPropAccessor
{
public:

    CStringPropAccessor( long lHandle, CIMTYPE ct, CPropAccessor* pParent=NULL)
    : CFastPropAccessor( lHandle, ct, pParent ) { }

    HRESULT ReadValue( _IWmiObject* pObj, VARIANT* pvar );
    HRESULT WriteValue( _IWmiObject* pObj, VARIANT* pvar );
};

/****************************************************************************
  CObjectAccessFactory - impl for IWmiObjectAccessFactory
*****************************************************************************/

class CObjectAccessFactory 
: public CUnkBase<IWmiObjectAccessFactory, &IID_IWmiObjectAccessFactory>
{
    _IWmiObjectP m_pTemplate;
    PropAccessMap m_mapPropAccess;
    long m_lIndexGenerator;

    HRESULT FindOrCreateAccessor( LPCWSTR wszPropElem,
                                  BOOL bEmbedded,
                                  CPropAccessor* pParent, 
                                  CPropAccessor** ppAccessor );
public:

    CObjectAccessFactory( CLifeControl* pControl ) 
    : CUnkBase<IWmiObjectAccessFactory,&IID_IWmiObjectAccessFactory>(pControl),
      m_lIndexGenerator(1)
    {
    } 

    STDMETHOD(SetObjectTemplate)( IWbemClassObject* pTemplate );
    STDMETHOD(GetObjectAccess)( IWmiObjectAccess** ppAccess );
    STDMETHOD(GetPropHandle)( LPCWSTR wszProp, DWORD dwFlags, LPVOID* ppHdl );
};

/****************************************************************************
  CObjectAccess - impl for IWmiObjectAccess.
*****************************************************************************/

class CObjectAccess : public CUnkBase<IWmiObjectAccess,&IID_IWmiObjectAccess>
{
    ObjectArray m_aObjects;

    class CEmbeddedPropAccessorCompare
    {
    public:
        bool operator() ( const CEmbeddedPropAccessor* pA,
                          const CEmbeddedPropAccessor* pB ) const
        {
            bool bRet;    
            if ( !(pA == pB) )
                if ( pA->GetLevel() == pB->GetLevel() )
                    bRet = pA < pB;
                else
                    bRet = pA->GetLevel() > pB->GetLevel();
            else
                bRet = FALSE; 
            return bRet;
        }
    };
 
    typedef std::set< CEmbeddedPropAccessor*, 
            CEmbeddedPropAccessorCompare, 
            wbem_allocator<CEmbeddedPropAccessor*> > EmbeddedPropAccessSet;
    
    EmbeddedPropAccessSet m_setEmbeddedAccessorsToCommit;
 
public:

    CObjectAccess( CLifeControl* pControl ) 
    : CUnkBase<IWmiObjectAccess,&IID_IWmiObjectAccess> ( pControl ) {} 

    STDMETHOD(SetObject)( IWbemClassObject* pObj );
    STDMETHOD(GetObject)( IWbemClassObject** ppObj );

    //
    // should support flags that describe what is going to be done 
    // with the value.  If it's going to be put into another object then
    // we'll give back a value which can only be used for that purpose.  More
    // efficient. e.g. we could use the get/put prop pointer methods 
    //
    STDMETHOD(GetProp)( LPVOID pHdl, 
                        DWORD dwFlags, 
                        VARIANT* pvar, 
                        CIMTYPE* pct );

    STDMETHOD(PutProp)( LPVOID pHdl, 
                        DWORD dwFlags, 
                        VARIANT* pvar,
                        CIMTYPE ct );

    STDMETHOD(CommitChanges)();
};

#endif // __OBJACCES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updassoc.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <clsfac.h>
#include <pathutl.h>
#include "updassoc.h"
#include <strutils.h>

static CWbemBSTR g_bsAssocClass= L"MSFT_UCScenarioAssociation";
static CWbemBSTR g_bsQueryLang = L"WQL";

const LPWSTR g_wszClass = L"__Class";
const LPWSTR g_wszScenario = L"Scenario";
const LPWSTR g_wszId = L"Id";
const LPWSTR g_wszScenarioClass = L"MSFT_UCScenario";
const LPWSTR g_wszState = L"Object";
const LPWSTR g_wszStateQuery = L"Query";
const LPWSTR g_wszRelpath = L"__Relpath";
const LPWSTR g_wszAssocInfoQuery = 
   L"SELECT * FROM MSFT_UCScenarioAssociationInfo";

HRESULT CUpdConsAssocProvider::Init( IWbemServices* pSvc, 
                                     IWbemProviderInitSink* pInitSink ) 
{
    HRESULT hr;

    m_pSvc = pSvc;
    
    hr = m_pSvc->GetObject( g_bsAssocClass, 0, NULL, &m_pAssocClass, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pInitSink->SetStatus( WBEM_S_INITIALIZED, WBEM_S_NO_ERROR ); 
}

HRESULT CUpdConsAssocProvider::GetObject( BSTR bstrPath, 
                                          IWbemObjectSink* pResHndlr )
{
    CRelativeObjectPath RelPath;

    if ( !RelPath.Parse( bstrPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ParsedObjectPath* pPath = RelPath.m_pPath;

    _DBG_ASSERT( pPath->m_pClass != NULL );

    if ( wbem_wcsicmp( pPath->m_pClass, g_bsAssocClass ) != 0 )
    {
        return WBEM_E_NOT_FOUND;
    }

    if ( pPath->m_dwNumKeys != 2 ||
         wbem_wcsicmp( pPath->m_paKeys[0]->m_pName, g_wszState ) != 0 || 
         wbem_wcsicmp( pPath->m_paKeys[1]->m_pName, g_wszScenario ) != 0  ||
         V_VT(&pPath->m_paKeys[0]->m_vValue) != VT_BSTR ||
         V_VT(&pPath->m_paKeys[1]->m_vValue) != VT_BSTR )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Get and validate scenario path.
    //

    LPWSTR wszScenarioPath = V_BSTR(&pPath->m_paKeys[1]->m_vValue);

    CRelativeObjectPath ScenarioPath;

    if ( !ScenarioPath.Parse( wszScenarioPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ParsedObjectPath* pScenarioPath = ScenarioPath.m_pPath;

    _DBG_ASSERT( pScenarioPath->m_pClass != NULL );

    if ( wbem_wcsicmp( pScenarioPath->m_pClass, g_wszScenarioClass ) != 0 || 
         pScenarioPath->m_dwNumKeys != 1 || 
         V_VT(&pScenarioPath->m_paKeys[0]->m_vValue) != VT_BSTR || 
         (pScenarioPath->m_paKeys[0]->m_pName != NULL && 
         wbem_wcsicmp( pScenarioPath->m_paKeys[0]->m_pName, g_wszId ) != 0 ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Derive the Scenario name from the path.
    //

    LPWSTR wszScenario = V_BSTR(&pScenarioPath->m_paKeys[0]->m_vValue);

    //
    // Get the state path. We do not need to validate it, since it will be
    // compared with validated paths.  However, since it will be compared
    // with other paths, it needs to be normalized.  This will be done 
    // in GetInstances though.
    // 

    LPWSTR wszStatePath = V_BSTR(&pPath->m_paKeys[0]->m_vValue);

    HRESULT hr = GetInstances( wszScenario, wszStatePath, pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

//
// wszScenario is used to scope the query for the Assoc Info objects.(optional)
// wszStatePath is used to filter the returned objects. (optional).
//
HRESULT CUpdConsAssocProvider::GetInstances( LPCWSTR wszScenario, 
                                             LPCWSTR wszStatePath,
                                             IWbemObjectSink* pResHndlr )
{
    HRESULT hr;
    
    CWbemBSTR bsAssocInfoQuery = g_wszAssocInfoQuery;
    
    if ( wszScenario != NULL )
    {
        bsAssocInfoQuery += L" WHERE Scenario = '";
        bsAssocInfoQuery += wszScenario;
        bsAssocInfoQuery += L"'";
    }

    CWbemPtr<IEnumWbemClassObject> pAssocInfoObjs;

    hr = m_pSvc->ExecQuery( g_bsQueryLang,
                            bsAssocInfoQuery,
                            WBEM_FLAG_FORWARD_ONLY,
                            NULL,
                            &pAssocInfoObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }

    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pAssocInfo;
    
    hr = pAssocInfoObjs->Next( WBEM_INFINITE, 1, &pAssocInfo, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs ==  1 );

        //
        // first get the scenario name from the assoc info ...
        //

        CPropVar vScenario;
        
        hr = pAssocInfo->Get( g_wszScenario, 0, &vScenario, NULL, NULL);

        if ( FAILED(hr) || FAILED( hr = vScenario.CheckType( VT_BSTR ) ) )
        {
            return hr;
        }
        
        if ( VT_NULL == V_VT( &vScenario ) )
        {
            hr = pAssocInfoObjs->Next( WBEM_INFINITE, 1, &pAssocInfo, &cObjs );
            continue;
        }
        
        CWbemBSTR bsScenarioPath = g_wszScenarioClass;
        bsScenarioPath += L"='";
        bsScenarioPath += V_BSTR(&vScenario);
        bsScenarioPath += L"'";
    
        //
        // Now get the state query from the assoc info and execute it
        //

        CPropVar vStateQuery;

        hr = pAssocInfo->Get( g_wszStateQuery, 0, &vStateQuery, NULL, NULL );

        if ( FAILED(hr) || FAILED( hr = vStateQuery.CheckType( VT_BSTR ) ) )
        {
            return hr;
        }
        
        CWbemPtr<IEnumWbemClassObject> pStateObjs;

        hr = m_pSvc->ExecQuery( g_bsQueryLang,
                                V_BSTR(&vStateQuery),
                                WBEM_FLAG_FORWARD_ONLY,
                                NULL,
                                &pStateObjs );
        if ( FAILED(hr) )
        {
            return hr;
        }

        // 
        // Enumerate the state objects and for each one create an assoc obj
        //

        CWbemPtr<IWbemClassObject> pState;
        
        hr = pStateObjs->Next( WBEM_INFINITE, 1, &pState, &cObjs );

        while( hr == WBEM_S_NO_ERROR )
        {
            _DBG_ASSERT( cObjs ==  1 );

            CPropVar varStatePath;
            hr = pState->Get( g_wszRelpath, 0, &varStatePath, NULL, NULL );

            if ( FAILED(hr) )
            {
                return hr;
            }

            if ( V_VT( &varStatePath ) !=  VT_BSTR )
            {
                return DISP_E_TYPEMISMATCH;
            }
            
            BOOL bCheck = TRUE;

            if ( wszStatePath != NULL )
            {
                CRelativeObjectPath PathA, PathB;
                if ( !PathA.Parse( wszStatePath ) || 
                     !PathB.Parse( V_BSTR(&varStatePath) ) )
                {
                    return WBEM_E_INVALID_OBJECT_PATH;
                }

                bCheck = PathA == PathB;
            }

            if ( bCheck )
            {            
                CWbemPtr<IWbemClassObject> pAssoc;
                hr = m_pAssocClass->SpawnInstance( 0, &pAssoc );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                VARIANT var;

                V_VT(&var) = VT_BSTR;
                V_BSTR(&var) = bsScenarioPath;

                hr = pAssoc->Put( g_wszScenario, 0, &var, NULL );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                hr = pAssoc->Put( g_wszState, 0, &varStatePath, NULL );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                hr = pResHndlr->Indicate( 1, &pAssoc );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                if ( wszStatePath != NULL )
                {
                    return WBEM_S_NO_ERROR;
                }
            }

            hr = pStateObjs->Next( WBEM_INFINITE, 1, &pState, &cObjs );
        }
 
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pAssocInfoObjs->Next( WBEM_INFINITE, 1, &pAssocInfo, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( wszStatePath != NULL )
    {
        //
        // we did not find a match for the state path
        //

        return WBEM_E_NOT_FOUND;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CUpdConsAssocProvider::GetAllInstances( LPWSTR wszClassname, 
                                                IWbemObjectSink* pResHndlr)
{
    if ( wbem_wcsicmp( wszClassname, g_bsAssocClass ) != 0 )
    {
        return WBEM_E_NOT_FOUND;
    }
    
    HRESULT hr = GetInstances( NULL, NULL, pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

void* CUpdConsAssocProvider::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }
    
    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CUpdConsAssocProvider::CUpdConsAssocProvider( CLifeControl* pCtl, 
                                              IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}    

CUpdConsAssocProvider::XServices::XServices( CUpdConsAssocProvider* pProv )
: CImpl< IWbemServices, CUpdConsAssocProvider> ( pProv )
{

}

CUpdConsAssocProvider::XInitialize::XInitialize( CUpdConsAssocProvider* pProv )
: CImpl< IWbemProviderInit, CUpdConsAssocProvider> ( pProv )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcmd.h ===
#ifndef __UPDCMD_H__
#define __UPDCMD_H__

#include <wbemcli.h>
#include <unk.h>
#include <comutl.h>
#include <wmimsg.h>
#include "updsql.h"
#include "updscen.h"
#include "updsink.h"

class CUpdConsCommand : public CUnk
{
protected:

    SQLCommand m_SqlCmd;
    AliasInfo m_DataAliasOffsets;
    AliasInfo m_EventAliasOffsets;

    CWbemPtr<IWmiObjectAccessFactory> m_pEventAccessFact;
    CWbemPtr<IWmiObjectAccessFactory> m_pDataAccessFact;
    CWbemPtr<IWmiObjectAccessFactory> m_pInstAccessFact;

    CWbemPtr<IWmiObjectAccess> m_pEventAccess;
    CWbemPtr<IWmiObjectAccess> m_pDataAccess;
    CWbemPtr<IWmiObjectAccess> m_pInstAccess;
    CWbemPtr<IWmiObjectAccess> m_pOrigInstAccess;

    //
    // this is the beginning of the sink chain that we use to execute the 
    // command.  It is built up on Initialization.
    //
    CWbemPtr<CUpdConsSink> m_pSink;
    
    CWbemPtr<CUpdConsScenario> m_pScenario;

    CUpdConsCommand( CUpdConsScenario* pScenario ) : m_pScenario(pScenario) {}

    HRESULT ProcessUpdateQuery( LPCWSTR wszUpdateQuery,
                                IWbemServices* pUpdSvc,
                                CUpdConsState& rState,
                                IWbemClassObject** ppUpdClass );

    HRESULT ProcessDataQuery( LPCWSTR wszDataQuery,
                              IWbemServices* pDataSvc,
                              CUpdConsState& rState,
                              IWbemClassObject** ppDataClass );

    HRESULT ProcessEventQuery( LPCWSTR wszEventQuery,
                               IWbemServices* pEventSvc,
                               CUpdConsState& rState,
                               IWbemClassObject** ppEventClass );
    
    HRESULT InitializeAccessFactories( IWbemClassObject* pUpdClass );
    HRESULT InitializePropertyInfo( CUpdConsState& rState );
    HRESULT InitializeDefaultAccessors();       
    HRESULT InitializeExecSinks( ULONG ulFlags, 
                                 IWbemServices* pUpdSvc,
                                 IWbemClassObject* pUpdClass,
                                 LPCWSTR wszDataQuery,
                                 IWbemServices* pDataSvc );

public:

    enum { e_UpdateOrCreate = 0, 
           e_UpdateOnly = 1, 
           e_CreateOnly = 2 };

    HRESULT Execute( CUpdConsState& rState, BOOL bConcurrent );
    
    void* GetInterface( REFIID ) { return NULL; }
    
    static HRESULT Create( LPCWSTR wszUpdateQuery, 
                           LPCWSTR wszDataQuery,
                           ULONG ulFlags,
                           IWbemServices* pUpdSvc,
                           IWbemServices* pDataSvc,
                           CUpdConsScenario* pScenario,
                           CUpdConsState& rState,
                           CUpdConsCommand** ppCmd ); 
};

#endif // __UPDCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updassoc.h ===
#ifndef __UPDASSOC_H__
#define __UPDASSOC_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <unk.h>

class CUpdConsAssocProvider : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl< IWbemProviderInit, 
                                       CUpdConsAssocProvider >
    {
        XInitialize( CUpdConsAssocProvider* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl<IWbemServices, CUpdConsAssocProvider>
    {
        XServices( CUpdConsAssocProvider* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetObject( strObjectPath, pResponseHandler );
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetAllInstances( strClass, pResponseHandler );
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    CWbemPtr<IWbemClassObject> m_pAssocClass;
    CWbemPtr<IWbemServices> m_pSvc;

    HRESULT GetInstances( LPCWSTR wszScenario,
                          LPCWSTR wszStatePath,
                          IWbemObjectSink* pResHndlr );

public:

    CUpdConsAssocProvider( CLifeControl* pCtl = NULL, IUnknown* pUnk = NULL );
    void* GetInterface( REFIID );

    HRESULT Init( IWbemServices* pSvc, IWbemProviderInitSink* pInitSink );
    HRESULT GetObject( BSTR bstrPath, IWbemObjectSink* pResponseHndlr );
    HRESULT GetAllInstances( LPWSTR wszClassname, IWbemObjectSink* pResHndlr );
};

#endif // __UPDASSOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcons.h ===
#ifndef __UPDCONS_H__
#define __UPDCONS_H__

#include <wbemcli.h>
#include <map>
#include <comutl.h>
#include <unk.h>
#include <wstlallc.h>
#include "updcmd.h"

class CUpdConsNamespace;
class CUpdConsScenario;

/*************************************************************************
  CUpdCons
**************************************************************************/
 
class CUpdCons 
: public CUnkBase<IWbemUnboundObjectSink,&IID_IWbemUnboundObjectSink>
{
    //
    // we lock the scenario object when executing, ensuring that all
    // updating consumers belonging to the same scenario are serialized.
    // we also use the scenario object for tracing.
    //
    CWbemPtr<CUpdConsScenario> m_pScenario;

    //
    // the list of updating consumer commands.
    //
    typedef CWbemPtr<CUpdConsCommand> CUpdConsCommandP;
    typedef std::vector<CUpdConsCommandP,wbem_allocator<CUpdConsCommandP> > UpdConsCommandList;
    typedef UpdConsCommandList::iterator UpdConsCommandListIter;
    UpdConsCommandList m_CmdList;

    BOOL m_bInitialized;

    CUpdCons( CLifeControl* pControl, CUpdConsScenario* pScenario );

    HRESULT Initialize( IWbemClassObject* pCons, CUpdConsState& rState );

    HRESULT IndicateOne( IWbemClassObject* pObj, CUpdConsState& rState );

public:
 
    static HRESULT Create( CUpdConsScenario* pScenario,
                           IWbemUnboundObjectSink** ppSink );

    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pCons, 
                                   long cObjs, 
                                   IWbemClassObject** ppObjs );        
};

#endif __UPDCONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcmd.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <wbemcli.h>
#include <arrtempl.h>
#include "updcmd.h"
#include "updnspc.h"
#include "updsink.h"

const LPCWSTR g_wszDataAlias = L"__THISDATA";
const LPCWSTR g_wszEventAlias = L"__THISEVENT";
const LPCWSTR g_wszUpdateEventClass = L"MSFT_UCEventBase";
const LPCWSTR g_wszDynamic = L"Dynamic";
const LPCWSTR g_wszProvider = L"Provider";
const LPCWSTR g_wszServer = L"__Server";
const LPCWSTR g_wszNamespace = L"__Namespace";
const LPCWSTR g_wszTransientProvider = L"Microsoft WMI Transient Provider";

// {405595AA-1E14-11d3-B33D-00105A1F4AAF}
static const GUID CLSID_TransientProvider =
{ 0x405595aa, 0x1e14, 0x11d3, {0xb3, 0x3d, 0x0, 0x10, 0x5a, 0x1f, 0x4a, 0xaf}};

class CWbemProviderInitSink : public IWbemProviderInitSink
{
    STDMETHOD_(ULONG, AddRef)() { return 1; }
    STDMETHOD_(ULONG, Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID, void** ) { return NULL; }
    STDMETHOD(SetStatus) ( long lStatus, long lFlags ) { return lFlags; }
};

inline void RemoveAliasKeyword( CPropertyName& rAlias )
{
    CPropertyName NewProp;

    long cElements = rAlias.GetNumElements();
    
    for( long i=1; i < cElements; i++ )
    {
        NewProp.AddElement( rAlias.GetStringAt(i) );
    }
    
    rAlias = NewProp;
}

// this should be a global function of qllex.cpp or something.
int FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;
        
    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;
        
    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;
        
    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

inline HRESULT SetPropHandle( CPropertyName& rPropName, 
                              IWmiObjectAccessFactory* pAccessFact )
{
    HRESULT hr;
    LPVOID pvHandle;
    
    LPWSTR wszPropName = rPropName.GetText();

    if ( wszPropName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pAccessFact->GetPropHandle( wszPropName, 0, &pvHandle );

    delete wszPropName;

    if ( FAILED(hr) )
    {
        return hr;
    }

    rPropName.SetHandle( pvHandle );

    return WBEM_S_NO_ERROR;
}  

HRESULT IsClassTransient( IWbemClassObject* pClassObj )
{
    //
    // We can tell for sure a class is transient if it is backed by
    // the transient provider.
    //

    HRESULT hr;

    CWbemPtr<IWbemQualifierSet> pQualSet;

    hr = pClassObj->GetQualifierSet( &pQualSet );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pQualSet->Get( g_wszDynamic, 0, NULL, NULL );

    if ( hr == WBEM_E_NOT_FOUND )
    {
        return WBEM_S_FALSE;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    VARIANT varProvider;
    VariantInit( &varProvider );
    CClearMe cmvarProvider( &varProvider );

    hr = pQualSet->Get( g_wszProvider, 0, &varProvider, NULL );

    if ( hr == WBEM_E_NOT_FOUND || V_VT(&varProvider) != VT_BSTR )
    {
        return WBEM_E_INVALID_OBJECT;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    if ( wbem_wcsicmp( V_BSTR(&varProvider), g_wszTransientProvider ) != 0 )
    {
        return WBEM_S_FALSE;
    }
    return WBEM_S_NO_ERROR;
}

//
// if S_FALSE is returned, then ppDirectSvc will be NULL.
//
HRESULT GetDirectSvc( IWbemClassObject* pClassObj, 
                      IWbemServices* pUpdSvc,
                      IWbemServices** ppDirectSvc )
{
    HRESULT hr;
    *ppDirectSvc = NULL;

    // 
    // if the svc pointer is remote, then we cannot perform the optimization.  
    // this is because queries for the state will be issued to the svc ptr 
    // and will return nothing, because the state will only live in this 
    // process.  In short, the transient state must ALWAYS exist in the 
    // winmgmt process.
    //

    CWbemPtr<IClientSecurity> pClientSec;
    hr = pUpdSvc->QueryInterface( IID_IClientSecurity, (void**)&pClientSec );
    
    if ( SUCCEEDED(hr) )
    {
        return WBEM_S_FALSE;
    }

    // 
    // we can perform the optimization.  Get the namespace str and 
    // instantiate the transient provider.
    //

    VARIANT varNamespace;

    hr = pClassObj->Get( g_wszNamespace, 0, &varNamespace, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    _DBG_ASSERT( V_VT(&varNamespace) == VT_BSTR );
    CClearMe cmvarNamespace( &varNamespace );

    CWbemPtr<IWbemProviderInit> pDirectInit;
    hr = CoCreateInstance( CLSID_TransientProvider, 
                           NULL, 
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemProviderInit,
                           (void**)&pDirectInit );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemProviderInitSink InitSink;
    hr = pDirectInit->Initialize( NULL, 0, V_BSTR(&varNamespace), 
                                  NULL, pUpdSvc, NULL, &InitSink );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pDirectInit->QueryInterface(IID_IWbemServices, (void**)ppDirectSvc);
}

/********************************************************************
  CUpdConsCommand
*********************************************************************/

HRESULT CUpdConsCommand::ProcessUpdateQuery( LPCWSTR wszUpdateQuery,
                                             IWbemServices* pUpdSvc,
                                             CUpdConsState& rState,
                                             IWbemClassObject** ppUpdClass )  
{
    HRESULT hr;
    *ppUpdClass = NULL;

    CTextLexSource Lexer( wszUpdateQuery );
    CSQLParser Parser( Lexer );

    if ( Parser.Parse( m_SqlCmd ) != 0 )
    {  
        rState.SetErrStr( Parser.CurrentToken() );
        return WBEM_E_INVALID_QUERY;
    }

    if ( m_SqlCmd.m_eCommandType == SQLCommand::e_Select )
    {
        rState.SetErrStr( wszUpdateQuery );
        return WBEM_E_QUERY_NOT_IMPLEMENTED;
    }

    hr = pUpdSvc->GetObject( m_SqlCmd.bsClassName, 
                             0, 
                             NULL, 
                             ppUpdClass, 
                             NULL);
    if ( FAILED(hr) ) 
    {
        rState.SetErrStr( m_SqlCmd.bsClassName );
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::ProcessDataQuery( LPCWSTR wszDataQuery,
                                           IWbemServices* pDataSvc,
                                           CUpdConsState& rState,
                                           IWbemClassObject** ppDataClass )  
{
    *ppDataClass = NULL;
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::ProcessEventQuery( LPCWSTR wszEventQuery,
                                            IWbemServices* pEventSvc,
                                            CUpdConsState& rState,
                                            IWbemClassObject** ppEventClass )  
{
    //
    // TODO: in the future we should be able to optimize the correlator 
    // for the incoming events too.  It would be nice to know the type of 
    // incoming events so that we can obtain fast accessors.
    //
    *ppEventClass = NULL;
    return WBEM_S_NO_ERROR;
}
    

HRESULT CUpdConsCommand::InitializeAccessFactories(IWbemClassObject* pUpdClass)
{
    HRESULT hr;

    //
    // obtain access factories and prepare them for fetching prop access hdls.
    //

    CWbemPtr<IClassFactory> pClassFact;

    hr = CoGetClassObject( CLSID_WmiSmartObjectAccessFactory,
                           CLSCTX_INPROC,
                           NULL,
                           IID_IClassFactory,
                           (void**)&pClassFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pClassFact->CreateInstance( NULL, 
                                     IID_IWmiObjectAccessFactory, 
                                     (void**)&m_pEventAccessFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pClassFact->CreateInstance( NULL, 
                                     IID_IWmiObjectAccessFactory, 
                                     (void**)&m_pDataAccessFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pClassFact->CreateInstance( NULL, 
                                     IID_IWmiObjectAccessFactory, 
                                     (void**)&m_pInstAccessFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pInstAccessFact->SetObjectTemplate( pUpdClass );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

/********************************************************************

  InitializePropertyInfo() - This method examines the SQLCommand object and 
  constructs a summary to aid in its execution. It also finishes checking 
  the semantics of the SQL command.  Since the parser does not have
  the alias support built into it, it is checked here.
  
  This method does modify the SQLCommand by removing the ALIAS keywords
  DATA/OBJECT from the property names.  

  This method also obtains a property access handle from the appropriate 
  access factory for the each referenced property and stores it with the 
  prop structure.

********************************************************************/

HRESULT CUpdConsCommand::InitializePropertyInfo( CUpdConsState& rState )      
{
    HRESULT hr;
    LPCWSTR wszAlias;

    //
    // process properties in the assignment tokens.
    // 

    _DBG_ASSERT( m_SqlCmd.nNumberOfProperties == 
                 m_SqlCmd.m_AssignmentTokens.size() );

    int i;
    for( i=0; i < m_SqlCmd.m_AssignmentTokens.size(); i++ )
    {
        SQLAssignmentToken& rAssignToken = m_SqlCmd.m_AssignmentTokens[i];

        for( int j=0; j < rAssignToken.size(); j++ )
        {
            CPropertyName& rPropName = rAssignToken[j].m_PropName;

            if ( rPropName.GetNumElements() == 0 )
            {
                continue;
            }
        
            wszAlias = rPropName.GetStringAt(0);
        
            _DBG_ASSERT(wszAlias != NULL);

            if ( wbem_wcsicmp( wszAlias, g_wszDataAlias ) == 0 )
            {
                m_DataAliasOffsets.AddAssignOffset( i, j );
                RemoveAliasKeyword( rPropName );
                hr = SetPropHandle( rPropName, m_pDataAccessFact );
            }
            else if ( wbem_wcsicmp( wszAlias, g_wszEventAlias ) == 0 )
            {
                m_EventAliasOffsets.AddAssignOffset( i, j );
                RemoveAliasKeyword( rPropName );
                hr = SetPropHandle( rPropName, m_pEventAccessFact );
            }
            else
            {
                hr = SetPropHandle( rPropName, m_pInstAccessFact );
            }

            if ( FAILED(hr) )
            {
                rState.SetErrStr( wszAlias );
                return hr;
            }
        }

        //
        // process property on the left side of the assignment.
        //
        
        CPropertyName& rPropName = m_SqlCmd.pRequestedPropertyNames[i];

        _DBG_ASSERT( rPropName.GetNumElements() > 0 );

        hr = SetPropHandle( rPropName, m_pInstAccessFact );

        if ( FAILED(hr) )
        {
            rState.SetErrStr( wszAlias );
            return hr;
        }
    }

    //
    // process properties in the condition clause 
    // 

    // TODO : I should be setting the bPropComp value in a token 
    // to FALSE after detecting the presence of an alias. However, 
    // the alias name is stored in the Prop2 member of the token and
    // that will not be copied by the assignment op or copy ctor if 
    // bPropComp is false.  This should be fixed, but in the meanwhile I'm
    // going to use the presence of a value in the vConstValue to signal
    // that it is not a real prop compare.

    for( i=0; i < m_SqlCmd.nNumTokens; i++ )
    {
        CPropertyName& rProp1 = m_SqlCmd.pArrayOfTokens[i].PropertyName; 
        CPropertyName& rProp2 = m_SqlCmd.pArrayOfTokens[i].PropertyName2;

        if ( m_SqlCmd.pArrayOfTokens[i].nTokenType != 
             QL_LEVEL_1_TOKEN::OP_EXPRESSION )
        {
            continue;
        }

        _DBG_ASSERT( rProp1.GetNumElements() > 0 );

        wszAlias = rProp1.GetStringAt(0);
        
        _DBG_ASSERT( wszAlias != NULL );
        BOOL bAlias = FALSE;
        
        if ( wbem_wcsicmp( wszAlias, g_wszDataAlias ) == 0 )
        {
            bAlias = TRUE;
            m_DataAliasOffsets.AddWhereOffset(i);
            RemoveAliasKeyword( rProp1 );
            hr = SetPropHandle( rProp1, m_pDataAccessFact );
        }
        else if ( wbem_wcsicmp( wszAlias, g_wszEventAlias ) == 0 )
        {
            bAlias = TRUE;
            m_EventAliasOffsets.AddWhereOffset(i);
            RemoveAliasKeyword( rProp1 );
            hr = SetPropHandle( rProp1, m_pEventAccessFact );
        }
        else
        {
            hr = SetPropHandle( rProp1, m_pInstAccessFact );
        }

        if ( FAILED(hr) )
        {
            rState.SetErrStr( wszAlias );
            return hr;
        }

        if ( !m_SqlCmd.pArrayOfTokens[i].m_bPropComp ) 
        {
            if ( bAlias )
            {
                //
                // this means that someone is trying to compare an 
                // alias to const val.  Not a valid use of aliases.
                //

                rState.SetErrStr( wszAlias );
                return WBEM_E_INVALID_QUERY;
            }
            else
            {
                continue;
            }
        }
                
        _DBG_ASSERT( rProp2.GetNumElements() > 0 );
        wszAlias = rProp2.GetStringAt(0);
        _DBG_ASSERT( wszAlias != NULL );
        
        if ( wbem_wcsicmp( wszAlias, g_wszDataAlias ) == 0 )
        {
            if ( !bAlias )
            {
                m_DataAliasOffsets.AddWhereOffset(i);
                RemoveAliasKeyword( rProp2 );
                hr = SetPropHandle( rProp2, m_pDataAccessFact );
            }
            else
            {
                hr = WBEM_E_INVALID_QUERY;
            }
        }
        else if ( wbem_wcsicmp( wszAlias, g_wszEventAlias ) == 0 )
        {
            if ( !bAlias )
            {
                m_EventAliasOffsets.AddWhereOffset(i);
                RemoveAliasKeyword( rProp2 );
                hr = SetPropHandle( rProp2, m_pEventAccessFact );
            }
            else
            {
                hr = WBEM_E_INVALID_QUERY;
            }
        }
        else
        {
            hr = SetPropHandle( rProp2, m_pInstAccessFact );

            if ( bAlias )
            {
                // this is the case we where have a real propname as the 
                // second prop and an alias as the first.  We must adjust 
                // the token so that the real propname is first and the alias 
                // is second because we need to stay consistent 
                // with the prop <rel_operator> const model which the QL1 
                // Parser has established.
                
                CPropertyName Tmp = rProp1;
                rProp1 = rProp2;
                rProp2 = Tmp;
                
                // of course the operator must be flipped ..
                int& nOp = m_SqlCmd.pArrayOfTokens[i].nOperator;
                nOp = FlipOperator( nOp );
            }
        }

        if ( FAILED(hr) )
        {
            rState.SetErrStr( wszAlias );
            return hr;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::InitializeDefaultAccessors()
{
    HRESULT hr;

    //
    // get default accessors from the factories.  These are only used 
    // we're guaranteed that calls to Execute() are serialized.  If not, 
    // then Execute() will be responsible for allocating new ones.
    //

    hr = m_pEventAccessFact->GetObjectAccess( &m_pEventAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDataAccessFact->GetObjectAccess( &m_pDataAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pInstAccessFact->GetObjectAccess( &m_pInstAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pInstAccessFact->GetObjectAccess( &m_pOrigInstAccess );

    return hr;
}

HRESULT CUpdConsCommand::InitializeExecSinks( ULONG ulFlags,
                                              IWbemServices* pUpdSvc,
                                              IWbemClassObject* pUpdClass,
                                              LPCWSTR wszDataQuery,
                                              IWbemServices* pDataSvc )
{
    HRESULT hr;

    CUpdConsNamespace* pNamespace = m_pScenario->GetNamespace();

    //
    // only care about update disposition flags
    //
    ulFlags &= 0x3;

    //
    // only set pEventSink if our class is derived from our 
    // extrinsic event class. The presence of this pointer will be 
    // used to tell us which sink to create.
    //

    CWbemPtr<IWbemObjectSink> pEventSink;

    hr = pUpdClass->InheritsFrom( g_wszUpdateEventClass );

    if ( hr == WBEM_S_NO_ERROR )
    {
        pEventSink = pNamespace->GetEventSink();
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // here we determine if we can use the direct svc optimization
    // first check to see if the class is transient.
    //

    BOOL bTransient = FALSE;

    hr = IsClassTransient( pUpdClass );

    CWbemPtr<IWbemServices> pSvc;

    if ( hr == WBEM_S_NO_ERROR )
    {
        hr = GetDirectSvc( pUpdClass, pUpdSvc, &pSvc );
    
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        bTransient = TRUE;
        ulFlags |= WBEM_FLAG_RETURN_IMMEDIATELY;
    }
    else
    {
        pSvc = pUpdSvc;
    } 
   
    CWbemPtr<IWbemClassObject> pCmdTraceClass;
    CWbemPtr<IWbemClassObject> pInstTraceClass;

    //
    // now that we've got everything set, set up the sink chain that 
    // we'll use to do the execute.
    //

    CWbemPtr<CUpdConsSink> pSink;

    //
    // create sink chain based on command type
    //

    if ( m_SqlCmd.m_eCommandType == SQLCommand::e_Update )
    {
        pCmdTraceClass = pNamespace->GetUpdateCmdTraceClass();
        pInstTraceClass = pNamespace->GetUpdateInstTraceClass();

        pSink = new CPutSink( pSvc, ulFlags, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CAssignmentSink( bTransient,
                                     pUpdClass,
                                     m_SqlCmd.m_eCommandType, 
                                     pSink );
        
        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CTraceSink( m_pScenario, pInstTraceClass, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CFilterSink( pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // use the async version only in the case where we go directly to
        // the transient provider.
        //
        if ( bTransient )
        {
            pSink = new CFetchTargetObjectsAsync( pSvc, pSink );
        }
        else
        {
            pSink = new CFetchTargetObjectsSync( pSvc, pSink );
        }

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if ( m_SqlCmd.m_eCommandType == SQLCommand::e_Insert )
    {
        pCmdTraceClass = pNamespace->GetInsertCmdTraceClass();
        pInstTraceClass = pNamespace->GetInsertInstTraceClass();

        // 
        // If inserts are going to be done on an Extrinsic event class, 
        // then use the event sink instead of an update sink.
        //

        if ( pEventSink != NULL )
        {
            pSink = new CBranchIndicateSink( pEventSink, pSink );
        }
        else
        {
            pSink = new CPutSink( pSvc, ulFlags, pSink );
        }

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CAssignmentSink( bTransient,
                                     pUpdClass,
                                     m_SqlCmd.m_eCommandType, 
                                     pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        pSink = new CTraceSink( m_pScenario, pInstTraceClass, pSink );


        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CNoFetchTargetObjects( pUpdClass, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        //
        // we never go direct with deletes because we would have to queue
        // objects to delete until we were done enumerating them.
        //

        pCmdTraceClass = pNamespace->GetDeleteCmdTraceClass();
        pInstTraceClass = pNamespace->GetDeleteInstTraceClass();

        pSink = new CDeleteSink( pUpdSvc, 0, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CTraceSink( m_pScenario, pInstTraceClass, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
       
        pSink = new CFilterSink( pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CFetchTargetObjectsSync( pUpdSvc, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    pSink = new CTraceSink( m_pScenario, pCmdTraceClass, pSink );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pSink = new CResolverSink( m_EventAliasOffsets, m_DataAliasOffsets, pSink );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( wszDataQuery != NULL && *wszDataQuery != '\0' )
    {
        pSink = new CFetchDataSink( wszDataQuery, pDataSvc, pSink );       

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    m_pSink = pSink;

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
  CUpdConsCommand
******************************************************************************/

HRESULT CUpdConsCommand::Create( LPCWSTR wszUpdateQuery, 
                                 LPCWSTR wszDataQuery,
                                 ULONG ulFlags,
                                 IWbemServices* pUpdSvc,
                                 IWbemServices* pDataSvc,
                                 CUpdConsScenario* pScenario,
                                 CUpdConsState& rState,
                                 CUpdConsCommand** ppCmd )
{
    HRESULT hr;    

    *ppCmd = NULL;

    CWbemPtr<CUpdConsCommand> pCmd = new CUpdConsCommand( pScenario );

    if ( pCmd == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    CWbemPtr<IWbemClassObject> pUpdClass, pDataClass, pEventClass;

    hr = pCmd->ProcessUpdateQuery( wszUpdateQuery, 
                                   pUpdSvc, 
                                   rState, 
                                   &pUpdClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->ProcessDataQuery( wszDataQuery, 
                                 pDataSvc, 
                                 rState, 
                                 &pDataClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->ProcessEventQuery( NULL, NULL, rState, &pEventClass );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializeAccessFactories( pUpdClass );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializePropertyInfo( rState );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializeDefaultAccessors();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializeExecSinks( ulFlags, 
                                    pUpdSvc, 
                                    pUpdClass, 
                                    wszDataQuery, 
                                    pDataSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }
     
    pCmd->AddRef();
    *ppCmd = pCmd;
                           
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::Execute( CUpdConsState& rState, BOOL bConcurrent )
{
    HRESULT hr;

    if ( !bConcurrent )
    {
        rState.SetSqlCmd( &m_SqlCmd, FALSE );
        
        hr = rState.SetEventAccess(m_pEventAccess);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = rState.SetDataAccess(m_pDataAccess);
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = rState.SetInstAccess(m_pInstAccess);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = rState.SetOrigInstAccess(m_pOrigInstAccess);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        SQLCommand* pCmd = new SQLCommand( m_SqlCmd );

        if ( pCmd == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        rState.SetSqlCmd( pCmd, TRUE );

        CWbemPtr<IWmiObjectAccess> pAccess;

        hr = m_pEventAccessFact->GetObjectAccess( &pAccess );
        
        if ( FAILED(hr) || FAILED(hr=rState.SetEventAccess(pAccess)) )
        {
            return hr;
        }
        
        pAccess.Release();

        hr = m_pDataAccessFact->GetObjectAccess( &pAccess );
        
        if ( FAILED(hr) || FAILED(hr=rState.SetDataAccess(pAccess)) )
        {
            return hr;
        }

        pAccess.Release();

        hr = m_pInstAccessFact->GetObjectAccess( &pAccess );

        if ( FAILED(hr) || FAILED(hr=rState.SetInstAccess(pAccess)) )
        {
            return hr;
        }

        pAccess.Release();

        hr = m_pInstAccessFact->GetObjectAccess( &pAccess );

        if ( FAILED(hr) || FAILED(hr=rState.SetOrigInstAccess(pAccess)) )
        {
            return hr;
        }

        pAccess.Release();        
    }

    hr = m_pSink->Execute( rState );

    //
    // at this point we reset any state that is not needed 
    // by caller.
    //

    rState.SetInst( NULL );
    rState.SetData( NULL );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcons.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <GroupsForUser.h>
#include "updcons.h"
#include "updcmd.h"
#include "updscen.h"
#include "updnspc.h"
#include "updprov.h"
#include "updstat.h"
#include "updmain.h"

const LPCWSTR g_wszScenarioClass = L"MSFT_UCScenario";
const LPCWSTR g_wszFlags = L"Flags";
const LPCWSTR g_wszTargetInst =  L"TargetInstance";
const LPCWSTR g_wszDataQuery = L"DataQueries";
const LPCWSTR g_wszDataNamespace = L"DataNamespace";
const LPCWSTR g_wszUpdateNamespace = L"UpdateNamespace";
const LPCWSTR g_wszCommands = L"Commands";
const LPCWSTR g_wszName = L"Name";
const LPCWSTR g_wszSid = L"CreatorSid";
const LPCWSTR g_wszQueryLang = L"WQL";

/************************************************************************
  CUpdCons
*************************************************************************/

CUpdCons::CUpdCons( CLifeControl* pControl, CUpdConsScenario* pScenario )
: CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink >( pControl ),
  m_pScenario( pScenario ), m_bInitialized(FALSE)
{

}

HRESULT CUpdCons::Create( CUpdConsScenario* pScenario,
                          IWbemUnboundObjectSink** ppSink )
{
    CLifeControl* pControl = CUpdConsProviderServer::GetGlobalLifeControl();

    CUpdCons* pSink = new CUpdCons( pControl, pScenario );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return pSink->QueryInterface( IID_IWbemUnboundObjectSink, (void**)ppSink );
}

HRESULT CUpdCons::Initialize( IWbemClassObject* pCons, CUpdConsState& rState )
{
    HRESULT hr;

    if ( m_bInitialized ) 
    {
        return WBEM_S_NO_ERROR;
    }

    // 
    // make sure that pObj (our logical consumer) is valid. Currently, this 
    // means that it was created by an account belonging to the administrators
    // group.
    //
    
    CPropVar vSid;
    hr = pCons->Get( g_wszSid, 0, &vSid, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vSid.CheckType(VT_UI1 | VT_ARRAY)) )
    {
        return hr;
    }
    
    CPropSafeArray<BYTE> saSid(V_ARRAY(&vSid));

    NTSTATUS stat = IsUserAdministrator( saSid.GetArray() );
    
    if ( stat != 0 )
    {
        return WBEM_E_ACCESS_DENIED;
    }

    // 
    // Get the list of commands
    //

    CPropVar vCommands;
    hr = pCons->Get( g_wszCommands, 0, &vCommands, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vCommands) != VT_NULL )
    {
        if ( FAILED(hr=vCommands.CheckType( VT_BSTR | VT_ARRAY ) ) )
        {
            return hr;
        }
    }
    else
    {
        // 
        // No-Op command, no need to go any further
        //  
        return WBEM_S_NO_ERROR;
    }

    CPropSafeArray<BSTR> saCommands( V_ARRAY(&vCommands) );

    //
    // obtain the namespace ptr to use for obtaining data. This namespace 
    // can be null in which case it is assumed that data will be obtained  
    // from the namespace that this consumer belongs to.
    //
    
    CPropVar vDataNamespace;
    hr = pCons->Get( g_wszDataNamespace, 0, &vDataNamespace, NULL, NULL);

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemServices> pDataSvc;

    if ( V_VT(&vDataNamespace) == VT_NULL )
    {
        pDataSvc = m_pScenario->GetNamespace()->GetDefaultService();
    }
    else if ( V_VT(&vDataNamespace) == VT_BSTR )
    {
        hr = CUpdConsProviderServer::GetService( V_BSTR(&vDataNamespace), 
                                                 &pDataSvc );
        
        if ( FAILED(hr) )
        {            
            rState.SetErrStr( V_BSTR(&vDataNamespace) );
            return hr;
        }
    }
    else 
    {
        return WBEM_E_INVALID_OBJECT;
    }

    _DBG_ASSERT( pDataSvc != NULL );

    //
    // obtain the namespace ptr to use for updating state. This namespace 
    // can be null in which case it is assumed that state will be updated  
    // in the namespace that this consumer belongs to.
    //

    CPropVar vUpdateNamespace;
    hr = pCons->Get( g_wszUpdateNamespace, 0, &vUpdateNamespace, NULL, NULL);

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemServices> pUpdSvc;

    if ( V_VT(&vUpdateNamespace) == VT_NULL )
    {
        pUpdSvc = m_pScenario->GetNamespace()->GetDefaultService();
    }
    else if ( V_VT(&vUpdateNamespace) == VT_BSTR )
    {
        hr = CUpdConsProviderServer::GetService( V_BSTR(&vUpdateNamespace), 
                                                 &pUpdSvc );
        
        if ( FAILED(hr) )
        {            
            rState.SetErrStr( V_BSTR(&vUpdateNamespace) );
            return hr;
        }
    }
    else 
    {
        return WBEM_E_INVALID_OBJECT;
    }

    _DBG_ASSERT( pUpdSvc != NULL );

    // 
    // Get Flags Array
    //

    CPropVar vFlags;
    hr = pCons->Get( g_wszFlags, 0, &vFlags, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropSafeArray<ULONG> saFlags;

    if ( V_VT(&vFlags) != VT_NULL )
    {
        if ( FAILED(hr=vFlags.CheckType( VT_I4 | VT_ARRAY ) ) )
        {
            return hr;
        }
        saFlags = V_ARRAY(&vFlags);
    }

    // 
    // Get Data Query Array
    //

    CPropVar vDataQuery;
    hr = pCons->Get( g_wszDataQuery, 0, &vDataQuery, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropSafeArray<BSTR> saDataQuery;

    if ( V_VT(&vDataQuery) != VT_NULL )
    {
        if ( FAILED(hr=vDataQuery.CheckType( VT_BSTR | VT_ARRAY ) ) )
        {
            return hr;
        }

        saDataQuery = V_ARRAY(&vDataQuery);
    }

    //
    // now create the command objects using the info we've obtained. first
    // make sure that we remove any existing commands.
    //

    m_CmdList.clear();

    for( long i=0; i < saCommands.Length(); i++ )
    {
        CWbemPtr<CUpdConsCommand> pCmd; 

        ULONG ulFlags = 0;
        LPCWSTR wszDataQuery = NULL;

        if ( i < saFlags.Length() )
        {
            ulFlags = saFlags[i];
        }

        if ( i < saDataQuery.Length() )
        {
            wszDataQuery = saDataQuery[i];
        } 
   
        hr = CUpdConsCommand::Create( saCommands[i], 
                                      wszDataQuery,
                                      ulFlags,
                                      pUpdSvc,
                                      pDataSvc,
                                      m_pScenario,
                                      rState,
                                      &pCmd );
        if ( FAILED(hr) )
        {
            //
            // set which command index we're on before returning
            //        
            rState.SetCommandIndex( i );
            break;
        }
        
        m_CmdList.insert( m_CmdList.end(), pCmd );
    }

    return hr;
}

HRESULT CUpdCons::IndicateOne( IWbemClassObject* pObj, CUpdConsState& rState ) 
{
    HRESULT hr;

    //
    // see if our scenario object has been deactivated.  If so, try to obtain
    // a new one.  
    // 
    
    if ( !m_pScenario->IsActive() )
    {
        CWbemPtr<CUpdConsScenario> pScenario;

        hr = m_pScenario->GetNamespace()->GetScenario( m_pScenario->GetName(),
                                                       &pScenario );

        if ( hr == WBEM_S_NO_ERROR )
        {
            m_pScenario = pScenario; // it was reactivated
        }
        else if ( hr == WBEM_S_FALSE )
        {
            //
            // the scenario is not currently active.  If this event has to
            // do with an operation on the scenario obj itself, then allow 
            // it to go through, otherwise return.
            //

            IWbemClassObject* pEvent = rState.GetEvent();

            if ( pEvent->InheritsFrom( L"__InstanceOperationEvent" ) 
                 == WBEM_S_NO_ERROR )
            {
                CPropVar vTarget;

                hr = pEvent->Get( L"TargetInstance", 0, &vTarget, NULL, NULL );

                if ( FAILED(hr) || FAILED(hr=vTarget.CheckType( VT_UNKNOWN)) )
                {
                    return hr;
                }

                CWbemPtr<IWbemClassObject> pTarget;
                hr = V_UNKNOWN(&vTarget)->QueryInterface( IID_IWbemClassObject,
                                                          (void**)&pTarget );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                hr = pTarget->InheritsFrom( g_wszScenarioClass );

                if ( hr != WBEM_S_NO_ERROR )
                {
                    return hr; // return WBEM_S_FALSE, scenario is inactive.
                }
            }
            else
            {
                return hr; // return WBEM_S_FALSE, scenario is inactive.
            }
        }
        else
        {
            return hr;
        }
    }

    //
    // Lock the scenario. 
    //

    CInCritSec ics( m_pScenario->GetLock() );

    _DBG_ASSERT( rState.GetEvent() != NULL );

    //
    // execute each command object. 
    //

    for( int i=0; i < m_CmdList.size(); i++ )
    {
        //
        // set the current command we're on in the state object. 
        //
        
        rState.SetCommandIndex( i );

        //
        // by specifying false for the concurrent param on Execute(),
        // we're saying that there's going to be no concurrent access
        // to the command, in which case it can save a bit on memory
        // allocation.
        //

        hr = m_CmdList[i]->Execute( rState, FALSE );

        if ( FAILED(hr) )
        {
            return hr;
        }            
    }

    //
    // reset the current command index, since we're sucessfully execute 
    // all of them. 
    //

    rState.SetCommandIndex( -1 );

    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CUpdCons::IndicateToConsumer( IWbemClassObject* pCons,
                                           long cObjs,
                                           IWbemClassObject** ppObjs )
{
    ENTER_API_CALL

    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pTraceClass;
    pTraceClass = m_pScenario->GetNamespace()->GetTraceClass();
    
    //
    // workaround for bogus context object left on thread by wmi.
    // just remove it. shouldn't leak because this call doesn't addref it.
    //

    IUnknown* pCtx;
    CoSwitchCallContext( NULL, &pCtx ); 

    //
    // state that is passed through the command execution chain.
    //

    CUpdConsState ExecState;

    ExecState.SetCons( pCons );

    //
    // execute the updating consumer using one event at a time. 
    //

    for( int i=0; i < cObjs; i++ ) 
    {
        //
        // each time set the event and a new guid on the state object ..
        //
        
        ExecState.SetEvent( ppObjs[i] );

        GUID guidExec;

        hr = CoCreateGuid( &guidExec );
        _DBG_ASSERT( SUCCEEDED(hr) );

        ExecState.SetExecutionId( guidExec );
        
        //
        // if not already initialized, do so now.  We wait until here 
        // because we now enough info to generate a trace event in case 
        // something goes wrong with initialization.
        //

        if ( !m_bInitialized )
        {
            hr = Initialize( pCons, ExecState );

            if ( FAILED(hr) )
            {
                m_pScenario->FireTraceEvent( pTraceClass, ExecState, hr );
                return WBEM_S_NO_ERROR; // we've notified the user already
            }

            m_bInitialized = TRUE;
        }

        //
        // Actual Indicate. 
        //
    
        hr = IndicateOne( ppObjs[i], ExecState );
  
        //
        // generate trace event. It is intentional that we are not returning
        // errors from the Indicate().  The policy is that as long as we 
        // generate a trace event, then the error is handled.  The rational 
        // here is that we don't want to screw up the user's state by 
        // executing a portion of the commands again ( which happens when the
        // error is not in the first command. )
        //

        m_pScenario->FireTraceEvent( pTraceClass, ExecState, hr ); 
    }

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updmain.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <wstring.h>
#include <wbemutil.h>
#include <comutl.h>
#include <statsync.h>
#include "updmain.h"
#include "updprov.h"
#include "updassoc.h"
#include "objacces.h"

// Function pointer type used with LoadMofFiles entrypoint in wbemupgd.dll
typedef BOOL ( WINAPI *PFN_LOAD_MOF_FILES )(wchar_t* pComponentName, const char* rgpszMofFilename[]);

// {A3A16907-227B-11d3-865D-00C04F63049B}
static const CLSID CLSID_UpdConsProvider =  
{ 0xa3a16907, 0x227b, 0x11d3, {0x86, 0x5d, 0x0, 0xc0, 0x4f, 0x63, 0x4, 0x9b}};

// {74E3B84C-C7BE-4e0a-9BD2-853CA72CD435}
static const CLSID CLSID_UpdConsAssocProvider = 
{0x74e3b84c, 0xc7be, 0x4e0a, {0x9b, 0xd2, 0x85, 0x3c, 0xa7, 0x2c, 0xd4, 0x35}};

CStaticCritSec g_CSNS;
CUpdConsProviderServer g_Server;

typedef CWbemPtr<CUpdConsNamespace> UpdConsNamespaceP;
std::map<WString,UpdConsNamespaceP,WSiless, wbem_allocator<UpdConsNamespaceP> >* g_pNamespaceCache;

HRESULT CUpdConsProviderServer::Initialize() 
{
    ENTER_API_CALL

    HRESULT hr;
    CWbemPtr<CUnkInternal> pFactory; 

    pFactory = new CSimpleClassFactory<CUpdConsProvider>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_UpdConsProvider, 
                       pFactory,
                       TEXT("Updating Consumer Provider"), 
                       TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }
     
    pFactory = new CClassFactory<CUpdConsAssocProvider>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_UpdConsAssocProvider, 
                       pFactory,
                       TEXT("Updating Consumer Assoc Provider"), 
                       TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pFactory=new CSimpleClassFactory<CObjectAccessFactory>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_WmiSmartObjectAccessFactory,
                       pFactory,
                       TEXT("Smart Object Access Factory"), 
                       TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    g_pNamespaceCache = new std::map< WString, UpdConsNamespaceP, WSiless, wbem_allocator<UpdConsNamespaceP> >;

    if ( g_pNamespaceCache == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}

void CUpdConsProviderServer::Uninitialize()
{
    delete g_pNamespaceCache;
}

void CUpdConsProviderServer::Register()
{
    //
    //  Load mofs and mfls during registration
    //
    HINSTANCE hinstWbemupgd = LoadLibrary(L"wbemupgd.dll");
    if (hinstWbemupgd)
    {
        PFN_LOAD_MOF_FILES pfnLoadMofFiles = (PFN_LOAD_MOF_FILES) GetProcAddress(hinstWbemupgd, "LoadMofFiles"); // no wide version of GetProcAddress
        if (pfnLoadMofFiles)
        {
            wchar_t*    wszComponentName = L"Updprov";
            const char* rgpszMofFilename[] = 
            {
                "updprov.mof",
                "updprov.mfl",
                NULL
            };
            
            pfnLoadMofFiles(wszComponentName, rgpszMofFilename);
        }
        
        FreeLibrary(hinstWbemupgd);
    }
}

HRESULT CUpdConsProviderServer::GetService( LPCWSTR wszNamespace, 
                                            IWbemServices** ppSvc )
{
    HRESULT hr;

    *ppSvc = NULL;

    CWbemPtr<IWbemLocator> pLocator;
    
    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWbemLocator, 
                           (void**)&pLocator );        
    if ( FAILED(hr) )
    {
        return hr;
    }
   
    return pLocator->ConnectServer( (LPWSTR)wszNamespace, 
                                    NULL, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    NULL, 
                                    NULL, 
                                    ppSvc );
}
 
HRESULT CUpdConsProviderServer::GetNamespace( LPCWSTR wszNamespace, 
                                              CUpdConsNamespace** ppNamespace )
{
    HRESULT hr;
    *ppNamespace = NULL;

    CInCritSec ics( &g_CSNS );

    CWbemPtr<CUpdConsNamespace> pNamespace;

    pNamespace = (*g_pNamespaceCache)[wszNamespace];

    if ( pNamespace == NULL )
    {
        hr = CUpdConsNamespace::Create( wszNamespace, &pNamespace );

        if ( FAILED(hr) )
        {
            return hr;
        }

        (*g_pNamespaceCache)[wszNamespace] = pNamespace;
    }
        
    _DBG_ASSERT( pNamespace != NULL );

    pNamespace->AddRef();
    *ppNamespace = pNamespace;

    return WBEM_S_NO_ERROR;
}

CLifeControl* CUpdConsProviderServer::GetGlobalLifeControl() 
{ 
    return g_Server.GetLifeControl(); 
}

/*

This code will register the Updating Consumer to work under a Dll Surrogate.

extern void CopyOrConvert( TCHAR*, WCHAR*, int );

void CUpdConsProviderServer::Register()
{
    // must register the Updating provider to be able to be instantiated 
    // from within a surrogate. 

    TCHAR szID[128];
    WCHAR wszID[128];
    TCHAR szCLSID[128];
    TCHAR szAPPID[128];

    HKEY hKey;

    StringFromGUID2( CLSID_UpdConsProvider, wszID, 128 );
    CopyOrConvert( szID, wszID, 128 );

    lstrcpy( szCLSID, TEXT( "SOFTWARE\\Classes\\CLSID\\") );
    lstrcat( szCLSID, szID );

    lstrcpy( szAPPID, TEXT( "SOFTWARE\\Classes\\APPID\\") );
    lstrcat( szAPPID, szID );

    RegCreateKey( HKEY_LOCAL_MACHINE, szCLSID, &hKey );
    
    RegSetValueEx( hKey, 
                   TEXT("AppID"), 
                   0, 
                   REG_SZ, 
                   (BYTE*)szID, 
                   lstrlen(szID)+1 );
    
    // now set up the appid entries ... 

    RegCloseKey(hKey);

    RegCreateKey( HKEY_LOCAL_MACHINE, szAPPID, &hKey );

    LPCTSTR szEmpty = TEXT("");
    RegSetValueEx( hKey, TEXT("DllSurrogate"), 0, REG_SZ, (BYTE*)szEmpty, 1 );
    
    DWORD nAuth = 2; // AUTHN_LEVEL_CONNECT
    RegSetValueEx( hKey, TEXT("AuthenticationLevel"), 
                   0, REG_DWORD, (BYTE*)&nAuth, 4);

    // now build a self relative SD for Access and Launch Permissions 
    // allowing Everyone access.
    
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    BYTE achAcl[256], achDesc[256], achSRDesc[256];
    PSID pWorldSid;
    BOOL bRes;

    // first have to get the owner ...
    //
    HANDLE hProcTok;
    bRes = OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hProcTok );
    _DBG_ASSERT(bRes);

    PSID pOwnerSid;
    DWORD dummy;
    BYTE achSidAndAttrs[256];
    bRes = GetTokenInformation( hProcTok,
                                TokenUser,
                                &achSidAndAttrs,
                                sizeof(achSidAndAttrs),
                                &dummy );
    _DBG_ASSERT(bRes);

    pOwnerSid = PSID_AND_ATTRIBUTES(achSidAndAttrs)->Sid;
  
    bRes = AllocateAndInitializeSid( &SIDAuthWorld, 1,
                                     SECURITY_WORLD_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pWorldSid );
    DWORD cSidLen = GetLengthSid(pWorldSid);
    _DBG_ASSERT(bRes);
    bRes = InitializeAcl( (PACL)achAcl, sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE) 
                          - 4 + cSidLen, ACL_REVISION2 ); 
    _DBG_ASSERT(bRes);
    bRes = AddAccessAllowedAce( (PACL)achAcl, ACL_REVISION, 
                                1, pWorldSid ); 
    _DBG_ASSERT(bRes);
    bRes = InitializeSecurityDescriptor( achDesc, 
                                         SECURITY_DESCRIPTOR_REVISION );
    _DBG_ASSERT(bRes);
    bRes = SetSecurityDescriptorDacl( achDesc, TRUE, (PACL)achAcl, FALSE );
    _DBG_ASSERT(bRes);
    bRes = SetSecurityDescriptorOwner( achDesc, pOwnerSid, FALSE );
    _DBG_ASSERT(bRes);
    bRes = SetSecurityDescriptorGroup( achDesc, pOwnerSid, FALSE );
    _DBG_ASSERT(bRes);

    DWORD dwLen = 256;
    bRes = MakeSelfRelativeSD( achDesc, achSRDesc, &dwLen );
    _DBG_ASSERT(bRes);
    bRes = IsValidSecurityDescriptor( achSRDesc );
    _DBG_ASSERT(bRes);

    dwLen = GetSecurityDescriptorLength( achSRDesc );

    RegSetValueEx( hKey, TEXT("AccessPermission"), 0, REG_BINARY,
                   (BYTE*)achSRDesc, dwLen );
    
    RegSetValueEx( hKey, TEXT("LaunchPermission"), 0, REG_BINARY,
                   (BYTE*)achSRDesc, dwLen );

    FreeSid( pWorldSid );

    RegCloseKey( hKey );
}

void CUpdConsProviderServer::Unregister()
{
    TCHAR szID[128];
    WCHAR wszID[128];

    HKEY hKey;
    DWORD dwRet;
    StringFromGUID2( CLSID_UpdConsProvider, wszID, 128 );
    CopyOrConvert( szID, wszID, 128 );

    dwRet = RegOpenKey( HKEY_LOCAL_MACHINE, 
                        TEXT("SOFTWARE\\Classes\\APPID"), 
                        &hKey );

    if( dwRet == NO_ERROR )
    {
        RegDeleteKey( hKey,szID );
        RegCloseKey( hKey );
    } 
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updmain.h ===
#ifndef __UPDMAIN_H__
#define __UPDMAIN_H__

#include <wbemcli.h>
#include <commain.h>

class CUpdConsNamespace;

class CUpdConsProviderServer : public CComServer
{  

protected:

    HRESULT Initialize();
    void Uninitialize();
    void Register();

public:

    static HRESULT GetService( LPCWSTR wszNamespace, IWbemServices** ppSvc );
    
    static HRESULT GetNamespace( LPCWSTR wszNamespace, 
                                 CUpdConsNamespace** ppNamespace );
    
    static CLifeControl* GetGlobalLifeControl();
};

#endif // __UPDMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updnspc.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include "updnspc.h"
#include "updcons.h"
#include "updmain.h"

const LPCWSTR g_wszIdProp = L"Id";
const LPCWSTR g_wszScenarioProp = L"Scenario";
const LPCWSTR g_wszScenarioClass = L"MSFT_UCScenario";
const LPCWSTR g_wszTargetInstance = L"TargetInstance";
const LPCWSTR g_wszTraceClass = L"MSFT_UCExecutedTraceEvent";
const LPCWSTR g_wszInsertCmdTraceClass = L"MSFT_UCInsertCommandTraceEvent";
const LPCWSTR g_wszUpdateCmdTraceClass = L"MSFT_UCUpdateCommandTraceEvent";
const LPCWSTR g_wszDeleteCmdTraceClass = L"MSFT_UCDeleteCommandTraceEvent";
const LPCWSTR g_wszInsertInstTraceClass = L"MSFT_UCInsertInstanceTraceEvent";
const LPCWSTR g_wszUpdateInstTraceClass = L"MSFT_UCUpdateInstanceTraceEvent";
const LPCWSTR g_wszDeleteInstTraceClass = L"MSFT_UCDeleteInstanceTraceEvent";
const LPCWSTR g_wszEvProvName = L"Microsoft WMI Updating Consumer Event Provider";
                                                          
HRESULT CUpdConsNamespace::GetScenario( LPCWSTR wszScenario, 
                                        CUpdConsScenario** ppScenario)
{
    HRESULT hr;
    *ppScenario = NULL;

    CInCritSec ics(&m_cs);

    CWbemPtr<CUpdConsScenario> pScenario = m_ScenarioCache[wszScenario];

    if ( pScenario != NULL )
    {
        pScenario->AddRef();
        *ppScenario = pScenario;
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}

HRESULT CUpdConsNamespace::ActivateScenario( LPCWSTR wszScenario )
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    //
    // if the scenario is not there then create one.
    //

    if ( m_ScenarioCache[wszScenario] != NULL )
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        CWbemPtr<CUpdConsScenario> pScenario;

        hr = CUpdConsScenario::Create( wszScenario, this, &pScenario );

        if ( SUCCEEDED(hr) )
        {
            m_ScenarioCache[wszScenario] = pScenario;
        }
    }

    return hr;
}

HRESULT CUpdConsNamespace::DeactivateScenario( LPCWSTR wszScenario )
{
    CInCritSec ics(&m_cs);

    //
    // remove the scenario from our list.
    //

    CWbemPtr<CUpdConsScenario> pScenario;

    ScenarioMap::iterator it = m_ScenarioCache.find( wszScenario );

    //
    // deactivate it.
    //

    if ( it != m_ScenarioCache.end() )
    {
        it->second->Deactivate();
        m_ScenarioCache.erase( it );
    }

    return WBEM_S_NO_ERROR;
}
   
CUpdConsNamespace::~CUpdConsNamespace()
{
    if ( m_pDES != NULL )
    {
        m_pDES->UnRegister();
    }
}

HRESULT CUpdConsNamespace::GetUpdCons( IWbemClassObject* pCons, 
                                       IWbemUnboundObjectSink** ppSink )
{
    HRESULT hr;
    
    //
    // Get Scenario Name from the consumer object. Then use it to
    // obtain the Scenario object.
    //

    CPropVar vScenario;

    hr = pCons->Get( g_wszScenarioProp, 0, &vScenario, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<CUpdConsScenario> pScenario;

    if ( V_VT(&vScenario) != VT_NULL )
    {
        if ( FAILED(hr=vScenario.CheckType( VT_BSTR ) ) ) 
        {
            return hr;
        }
  
        hr = GetScenario( V_BSTR(&vScenario), &pScenario );

        if ( hr == WBEM_S_FALSE )
        {
            //
            // no active scenario exists for this consumer.  We do have to 
            // pass something to the consumer though, so create a deactived 
            // scenario. 
            //

            hr = CUpdConsScenario::Create( V_BSTR(&vScenario), 
                                           this, 
                                           &pScenario );

            if ( SUCCEEDED(hr) )
            {
                pScenario->Deactivate();
            }
        }
    }
    else
    {
        //
        // no scenario name, create a 'default' scenario object.
        // 

        hr = CUpdConsScenario::Create( NULL, this, &pScenario );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return CUpdCons::Create( pScenario, ppSink ); 
}

HRESULT CUpdConsNamespace::Initialize( LPCWSTR wszNamespace )
{
    HRESULT hr;

    //
    // register our decoupled event provider 
    //

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Register( 0,
                           NULL,
                           NULL,
                           NULL,
                           wszNamespace,
                           g_wszEvProvName,
                           NULL );
     
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the service pointer for out namespace
    //

    hr = m_pDES->GetService( 0, NULL, &m_pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the decoupled event sink
    //

    hr = m_pDES->GetSink( 0, NULL, &m_pEventSink );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get event classes from namespace
    //

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszTraceClass), 
                            0, 
                            NULL, 
                            &m_pTraceClass, 
                            NULL );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszInsertCmdTraceClass), 
                            0, 
                            NULL, 
                            &m_pInsertCmdTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszUpdateCmdTraceClass), 
                            0, 
                            NULL, 
                            &m_pUpdateCmdTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszDeleteCmdTraceClass), 
                            0, 
                            NULL, 
                            &m_pDeleteCmdTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszInsertInstTraceClass), 
                            0, 
                            NULL, 
                            &m_pInsertInstTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszUpdateInstTraceClass), 
                            0, 
                            NULL, 
                            &m_pUpdateInstTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszDeleteInstTraceClass), 
                            0, 
                            NULL, 
                            &m_pDeleteInstTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // process the list of active scenarios.
    // 

    CWbemPtr<IEnumWbemClassObject> pEnum;

    long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;

    hr = m_pSvc->CreateInstanceEnum( CWbemBSTR(g_wszScenarioClass),
                                     lFlags,
                                     NULL,
                                     &pEnum );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pObj;
    
    hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs == 1 );

        CPropVar vId;

        hr = pObj->Get( g_wszIdProp, 0, &vId, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vId.CheckType(VT_BSTR)) )
        {
            return hr;
        }
         
        ActivateScenario( V_BSTR(&vId) );

        pObj.Release();
        hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsNamespace::GetScenarioControl( 
                                     IWbemUnboundObjectSink** ppControl )
{
    CLifeControl* pCtl = CUpdConsProviderServer::GetGlobalLifeControl();

    CWbemPtr<CUpdConsNamespaceSink> pSink;
   
    pSink = new CUpdConsNamespaceSink( pCtl, this );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return pSink->QueryInterface( IID_IWbemUnboundObjectSink, 
                                  (void**)ppControl );
}

STDMETHODIMP CUpdConsNamespaceSink::IndicateToConsumer(
                                                   IWbemClassObject* pCons,
                                                   long cObjs, 
                                                   IWbemClassObject** ppObjs )
{
    HRESULT hr;

    for( int i=0; i < cObjs; i++ )
    {
        DEBUGTRACE((LOG_ESS,"UPDCONS: Handling scenario change notification"));

        hr = m_pNamespace->NotifyScenarioChange( ppObjs[i] );

        if ( FAILED(hr) )
        {
            ERRORTRACE((LOG_ESS, "UPDCONS: Could not process a scenario "
                         "change notification. HR=0x%x\n", hr ));
        }
    }    

    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsNamespace::NotifyScenarioChange( IWbemClassObject* pEvent)
{
    HRESULT hr;

    CPropVar vTarget;

    hr = pEvent->Get( L"TargetInstance", 0, &vTarget, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTarget.CheckType( VT_UNKNOWN)) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pTarget;
    hr = V_UNKNOWN(&vTarget)->QueryInterface( IID_IWbemClassObject,
                                              (void**)&pTarget );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropVar vId;

    hr = pTarget->Get( g_wszIdProp, 0, &vId, NULL, NULL );
    
    if ( FAILED(hr) || FAILED(hr=vId.CheckType( VT_BSTR )) )
    {
        return hr;
    }

    if ( pEvent->InheritsFrom(L"__InstanceCreationEvent") == WBEM_S_NO_ERROR )
    {
        hr = ActivateScenario( V_BSTR(&vId) );
    }
    else if ( pEvent->InheritsFrom( L"__InstanceDeletionEvent" )
             == WBEM_S_NO_ERROR )
    {
        hr = DeactivateScenario( V_BSTR(&vId) );
    }

    return hr;
}

HRESULT CUpdConsNamespace::Create( LPCWSTR wszNamespace,
                                   CUpdConsNamespace** ppNamespace )
{
    HRESULT hr;
    *ppNamespace = NULL;

    CWbemPtr<CUpdConsNamespace> pNamespace;

    pNamespace = new CUpdConsNamespace;

    if ( pNamespace == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pNamespace->Initialize( wszNamespace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pNamespace->AddRef();
    *ppNamespace = pNamespace;
    
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updprov.h ===
#ifndef __UPDPROV_H__
#define __UPDPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>
#include <comutl.h>
#include "updnspc.h"

/*************************************************************************
  CUpdConsProvider
**************************************************************************/
class CUpdConsProvider 
: public CUnkBase<IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider>
{
    BOOL m_bInit;
    CCritSec m_csInit;
    CWbemPtr<CUpdConsNamespace> m_pNamespace;    
    
    HRESULT Init( LPCWSTR wszNamespace );

public:
    
    CUpdConsProvider( CLifeControl* pCtl );

    STDMETHOD(FindConsumer)( IWbemClassObject* pLogicalConsumer,
                             IWbemUnboundObjectSink** ppConsumer );
};


#endif // __UPDPROV__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updscen.cpp ===
#include "precomp.h"
#include <arrtempl.h>
#include <wbemutil.h>
#include "updscen.h"
#include "updnspc.h"
#include "updcons.h"
#include "updstat.h"

LPCWSTR g_wszTraceSuccessQuery = 
 L"SELECT * FROM MSFT_UCTraceEventBase WHERE StatusCode <= 1 "
 L"AND Consumer.Scenario = \""; 

LPCWSTR g_wszTraceFailureQuery = 
 L"SELECT * FROM MSFT_UCTraceEventBase WHERE StatusCode > 1 "
 L"AND Consumer.Scenario = \""; 

HRESULT CUpdConsScenario::Create( LPCWSTR wszScenario, 
                                  CUpdConsNamespace* pNamespace,
                                  CUpdConsScenario** ppScenario )
{
    HRESULT hr;

    CWbemPtr<CUpdConsScenario> pScenario = new CUpdConsScenario;

    if ( pScenario == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pScenario->m_pNamespace = pNamespace;

    if ( wszScenario != NULL )
    {
        pScenario->m_wsName = wszScenario;
    }

    //
    // get tracing sink from namespace.
    // 

    CWbemPtr<IWbemObjectSink> pSink = pNamespace->GetEventSink();

    _DBG_ASSERT( pSink != NULL );

    //
    // if the sink supports IWbemEventSink, then we'll get a restricted sink
    // from it based on our scenario.
    //
 
    CWbemPtr<IWbemEventSink> pNewSink;

    hr = pSink->QueryInterface( IID_IWbemEventSink, (void**)&pNewSink );
    
    if ( SUCCEEDED(hr) && wszScenario != NULL )
    {
        //
        // construct restricted query for successes.
        //
        
        WString wsQuery = g_wszTraceSuccessQuery;
        wsQuery += wszScenario;
        wsQuery += L"\"";
        
        LPCWSTR wszQuery = wsQuery;
        
        hr = pNewSink->GetRestrictedSink( 1, 
                                          &wszQuery, 
                                          NULL, 
                                          &pScenario->m_pTraceSuccessSink );
        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // construct restricted query for failures.
        //

        wsQuery = g_wszTraceFailureQuery;
        wsQuery += wszScenario;
        wsQuery += L"\"";
        
        wszQuery = wsQuery;
        
        hr = pNewSink->GetRestrictedSink( 1, 
                                          &wszQuery, 
                                          NULL, 
                                       &pScenario->m_pTraceFailureSink );
        if ( FAILED(hr) )
        {
            return hr;
        }
    
        DEBUGTRACE(( LOG_ESS,
                     "UPDPROV: Tracing Optimized for scenario %s.\n",
                     wszScenario ));
    }
    else
    {
        //
        // this is o.k. we're on an older platform.  tracing just won't 
        // be optimized.
        //

        DEBUGTRACE(( LOG_ESS,
                     "UPDPROV: Tracing Not Optimized for scenario %s.\n",
                     wszScenario ));        
    }

    pScenario->AddRef();
    *ppScenario = pScenario;
   
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsScenario::FireTraceEvent( IWbemClassObject* pTraceClass,
                                          CUpdConsState& rState,
                                          HRESULT hrStatus )
{
    HRESULT hr;

    CWbemPtr<IWbemObjectSink> pTraceSink;

    if ( m_pTraceSuccessSink != NULL && m_pTraceFailureSink != NULL )
    {
        if ( SUCCEEDED(hrStatus) )
        {
            if ( m_pTraceSuccessSink->IsActive() == WBEM_S_FALSE )
            {
                return WBEM_S_NO_ERROR;
            }
            else
            {
                pTraceSink = m_pTraceSuccessSink.m_pObj;
            }
        }
        else if ( m_pTraceFailureSink->IsActive() == WBEM_S_FALSE )
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pTraceSink = m_pTraceFailureSink.m_pObj;
        }
    }
    else
    {
        pTraceSink = m_pNamespace->GetEventSink();
    }

    CWbemPtr<IWbemClassObject> pTraceObj;

    hr = pTraceClass->SpawnInstance( 0, &pTraceObj );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = rState.SetStateOnTraceObject( pTraceObj, hrStatus );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pTraceSink->Indicate( 1, &pTraceObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updprov.cpp ===
#include "precomp.h"
#include "updprov.h"
#include "updcons.h"
#include "updmain.h"

const LPCWSTR g_wszNamespace = L"__Namespace";
const LPCWSTR g_wszUpdConsClass = L"MSFT_UpdatingConsumer";

STDMETHODIMP CUpdConsProvider::FindConsumer( IWbemClassObject* pCons,
                                             IWbemUnboundObjectSink** ppSink )
{
    HRESULT hr;

    ENTER_API_CALL

    *ppSink = NULL;

    //
    // workaround for bogus context object left on thread by wmi.
    // just remove it. shouldn't leak because this call doesn't addref it.
    //
    IUnknown* pCtx;
    CoSwitchCallContext( NULL, &pCtx ); 

    // 
    // use the namespace prop on the consumer to find our namespace obj
    // 
    
    CPropVar vNamespace;
    hr = pCons->Get( g_wszNamespace, 0, &vNamespace, NULL, NULL);
    
    if ( FAILED(hr) || FAILED(hr=vNamespace.CheckType( VT_BSTR)) )
    {
        return hr;
    }

    CWbemPtr<CUpdConsNamespace> pNamespace;

    hr = CUpdConsProviderServer::GetNamespace( V_BSTR(&vNamespace), 
                                               &pNamespace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the appropriate sink depending on the type of consumer.
    // 

    if ( pCons->InheritsFrom( g_wszUpdConsClass ) == WBEM_S_NO_ERROR )
    {
        hr = pNamespace->GetUpdCons( pCons, ppSink );
    }
    else
    {
        hr = pNamespace->GetScenarioControl( ppSink );
    }

    EXIT_API_CALL

    return hr;
}

HRESULT CUpdConsProvider::Init( LPCWSTR wszNamespace )
{
    ENTER_API_CALL

    HRESULT hr;

    CInCritSec ics(&m_csInit);

    if ( m_bInit )
    {
        return WBEM_S_NO_ERROR;
    }

    // 
    // we need to obtain the 'default' svc pointer.  This is used for 
    // obtaining class objects necessary for the updating consumers.  
    // This logic relies on the fact that wszNamespace is relative and 
    // does not contain the name of the server.  We always want the local
    // server's namespace pointer.  This is because the process that 
    // serves as the context for the remote execution of an updating consumer
    // (currently the standard surrogate) always runs with a restricted 
    // process token (because it has an identity of 'launching user' ). 
    // This token is the same as an impersonation token in that you cannot 
    // call off the box.  
    //

    CWbemPtr<IWbemServices> pSvc;

    hr = CUpdConsProviderServer::GetService( wszNamespace, &pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_bInit = TRUE;

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}


CUpdConsProvider::CUpdConsProvider( CLifeControl* pCtl ) : m_bInit(FALSE),
 CUnkBase<IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider>( pCtl )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updnspc.h ===
#ifndef __UPDNSPC_H__
#define __UPDNSPC_H__

#include <arrtempl.h>
#include <wstring.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <wstring.h>
#include <unk.h>
#include <sync.h>
#include <map>
#include <wstlallc.h>
#include "updscen.h"
#include "updstat.h"

/*****************************************************************************
  CUpdConsNamespace - holds per namespace information for the updating 
  consumer provider.  
******************************************************************************/

class CUpdConsNamespace : public CUnk 
{
    CCritSec m_cs;

    typedef CWbemPtr<CUpdConsScenario> UpdConsScenarioP;
    typedef std::map< WString,
                      UpdConsScenarioP,
                      WSiless,
                      wbem_allocator<UpdConsScenarioP> > ScenarioMap;
    //
    // list of ACTIVE scenarios.
    //
    ScenarioMap m_ScenarioCache;

    //
    // Default Service Ptr
    //

    CWbemPtr<IWbemServices> m_pSvc;

    //
    // tracing class info.
    //
    
    CWbemPtr<IWbemClassObject> m_pTraceClass;
    CWbemPtr<IWbemClassObject> m_pDeleteCmdTraceClass;
    CWbemPtr<IWbemClassObject> m_pInsertCmdTraceClass;
    CWbemPtr<IWbemClassObject> m_pUpdateCmdTraceClass;
    CWbemPtr<IWbemClassObject> m_pDeleteInstTraceClass;
    CWbemPtr<IWbemClassObject> m_pInsertInstTraceClass;
    CWbemPtr<IWbemClassObject> m_pUpdateInstTraceClass;
    
    //
    // sink for update driven event generation.  also is used for 
    // trace event generation if there are subscribers.
    //

    CWbemPtr<IWbemObjectSink> m_pEventSink;     

    //
    // need to hold onto this while holding sinks obtained from it.
    //

    CWbemPtr<IWbemDecoupledBasicEventProvider> m_pDES;

    void* GetInterface( REFIID ) { return NULL; }

    HRESULT Initialize( LPCWSTR wszNamespace );
    HRESULT ActivateScenario( LPCWSTR wszScenario ); 
    HRESULT DeactivateScenario( LPCWSTR wszScenario ); 

public:

    ~CUpdConsNamespace();

    IWbemServices* GetDefaultService() { return m_pSvc; }
    IWbemClassObject* GetTraceClass() { return m_pTraceClass; }
    
    IWbemClassObject* GetDeleteCmdTraceClass() 
    { 
        return m_pDeleteCmdTraceClass; 
    }
    IWbemClassObject* GetInsertCmdTraceClass() 
    { 
        return m_pInsertCmdTraceClass; 
    }
    IWbemClassObject* GetUpdateCmdTraceClass() 
    { 
        return m_pUpdateCmdTraceClass; 
    }
    IWbemClassObject* GetDeleteInstTraceClass()
    { 
        return m_pDeleteInstTraceClass;
    }
    IWbemClassObject* GetInsertInstTraceClass()
    {
        return m_pInsertInstTraceClass;
    }
    IWbemClassObject* GetUpdateInstTraceClass()
    {
        return m_pUpdateInstTraceClass;
    }
   
    IWbemObjectSink* GetEventSink() { return m_pEventSink; }

    static HRESULT Create( LPCWSTR wszNamespace,
                           CUpdConsNamespace** ppNamespace );

    //
    // called by Consumer Sink when it's current scenario obj is deactivated.
    // 
    HRESULT GetScenario( LPCWSTR wszScenario, CUpdConsScenario** ppScenario );

    //
    // called by FindConsumer()
    //
    HRESULT GetUpdCons( IWbemClassObject* pObj, 
                        IWbemUnboundObjectSink** ppSink );

    HRESULT GetScenarioControl( IWbemUnboundObjectSink** ppSink );

    HRESULT NotifyScenarioChange( IWbemClassObject* pEvent );
};

/*****************************************************************************
  CUpdConsNamespaceSink - Used for notification of a change in a scenario's 
  state. We need to use permanent consumer mechanism because the notification 
  of the change MUST be handled synchronously. Ideally, we should use the 
  temporary subscription mechanism, subscribing/unsubscribing when the 
  namespace is initialized/uninitialized, however we cannot get sync delivery
  with it.  Should be changed when ess supports sync temp subscriptions.
******************************************************************************/

class CUpdConsNamespaceSink 
: public CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink >
{
    CWbemPtr<CUpdConsNamespace> m_pNamespace;

public:

    CUpdConsNamespaceSink( CLifeControl* pCtl, CUpdConsNamespace* pNamespace ) 
    : CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink > ( pCtl ),
      m_pNamespace( pNamespace ) { } 
                           
    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pCons, 
                                   long cObjs, 
                                   IWbemClassObject** ppObjs );
};


#endif // __UPDNSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updscen.h ===
#ifndef __UPDSCEN_H__
#define __UPDSCEN_H__

#include <wstring.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>
#include <sync.h>
#include <comutl.h>

class CUpdCons;
class CUpdConsState;
class CUpdConsNamespace;

/*************************************************************************
  CUpdConsScenario
**************************************************************************/

class CUpdConsScenario : public CUnk
{
    CCritSec m_cs;
    WString m_wsName;
    BOOL m_bActive;
    CWbemPtr<IWbemEventSink> m_pTraceSuccessSink;
    CWbemPtr<IWbemEventSink> m_pTraceFailureSink;

    CUpdConsNamespace* m_pNamespace; // No AddRef because Circular Ref.
    
    CUpdConsScenario() : m_pNamespace(NULL), m_bActive(TRUE) {} 

public:
    
    void* GetInterface( REFIID ) { return NULL; }

    CRITICAL_SECTION* GetLock() { return &m_cs; }

    BOOL IsActive() { return m_bActive; }
    void Deactivate() { m_bActive = FALSE; }
    LPCWSTR GetName() { return m_wsName; }

    CUpdConsNamespace* GetNamespace() { return m_pNamespace; }

    HRESULT FireTraceEvent( IWbemClassObject* pTraceClass,
                            CUpdConsState& rStatus,
                            HRESULT hrStatus );
                            
    HRESULT GetUpdCons( IWbemClassObject* pObj, CUpdCons** ppSink );

    static HRESULT Create( LPCWSTR wszScenario, 
                           CUpdConsNamespace* pNamespace,
                           CUpdConsScenario** ppScenario );
};

#endif //  __UPDSCEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsink.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <cimval.h>
#include <arrtempl.h>
#include <statsync.h>
#include <stack>
#include <pathutl.h>
#include <txttempl.h>
#include "updsink.h"
#include "updcmd.h"
#include "updstat.h"

const LPCWSTR g_wszNowAlias = L"__NOW";
const LPCWSTR g_wszServerAlias = L"__SERVER";
const LPCWSTR g_wszSubType = L"SubType";
const LPCWSTR g_wszRelPath = L"__RelPath";
const LPCWSTR g_wszInterval = L"Interval";
const LPCWSTR g_wszQueryLang = L"WQL";

extern BOOL FileTimeToDateTime( FILETIME* pft, LPWSTR wszText, size_t bufferSize );

HRESULT EvaluateExpression( SQLAssignmentToken& rAssignTok, 
                            IWmiObjectAccess* pAccess, 
                            CCimValue& rValue );

HRESULT EvaluateToken( IWmiObjectAccess* pAccess, QL_LEVEL_1_TOKEN& Tok );

HRESULT GetTokenValue( SQLExpressionToken& rTok, 
                       IWmiObjectAccess* pAccess, 
                       ULONG& rulCimType,
                       VARIANT& vValue );

static CStaticCritSec cs_GetComputerName;

static LPCWSTR FastGetComputerName()
{
    static WCHAR awchBuff[MAX_COMPUTERNAME_LENGTH+1];
    static BOOL bThere = FALSE;

    CInCritSec ics(&cs_GetComputerName);
    
    if ( bThere )
    {
        ;
    }
    else
    {
        DWORD dwMax = MAX_COMPUTERNAME_LENGTH+1;
        TCHAR atchBuff[MAX_COMPUTERNAME_LENGTH+1];
        
        if ( FALSE == GetComputerName( atchBuff, &dwMax ) )
        {
            return NULL;
        }
        
        dwMax = MAX_COMPUTERNAME_LENGTH+1;
        tsz2wsz( atchBuff, awchBuff, &dwMax );
        bThere = TRUE;
    }

    return awchBuff;
}

/*
//
// This function will return the embedded object identified by 
// pObj.(PropName-lastelement). If PropName only contains one element, 
// then pObj will be returned.
//
HRESULT GetInnerMostObject( CPropertyName& PropName,
                            IWbemClassObject* pObj,
                            IWbemClassObject** ppInnerObj )
{
    HRESULT hr;
    VARIANT var;

    long lElements = PropName.GetNumElements();
    
    CWbemPtr<IWbemClassObject> pInnerObj = pObj;
    
    for( long i=0; i < lElements-1; i++ )
    {
        LPCWSTR wszElement = PropName.GetStringAt(i);

        CClearMe cmvar( &var );
 
        hr = pInnerObj->Get( wszElement, 0, &var, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&var) != VT_UNKNOWN )
        {
            return WBEM_E_NOT_FOUND;
        }
        
        pInnerObj.Release();

        hr = V_UNKNOWN(&var)->QueryInterface( IID_IWbemClassObject, 
                                              (void**)&pInnerObj );
        _DBG_ASSERT( SUCCEEDED(hr) );
    }

    pInnerObj->AddRef();
    *ppInnerObj = pInnerObj;
    
    return WBEM_S_NO_ERROR;
}

*/

// This method handles embedded object properties.
HRESULT GetValue( CPropertyName& rPropName,
                  IWmiObjectAccess* pAccess,
                  ULONG& rulCimType, 
                  VARIANT* pvarRet )
{
    HRESULT hr;
    long lElements = rPropName.GetNumElements();
    
    if ( lElements == 0 ) 
    {
        rulCimType = CIM_OBJECT;
        
        if ( pvarRet != NULL )
        {
            CWbemPtr<IWbemClassObject> pObj;

            hr = pAccess->GetObject( &pObj );

            if ( FAILED(hr) )
            {
                return hr;
            }

            //
            // then the caller really want this object ...
            //
            V_VT(pvarRet) = VT_UNKNOWN;
            V_UNKNOWN(pvarRet) = pObj;
            pObj->AddRef();
        }
        
        return WBEM_S_NO_ERROR;
    }

    _DBG_ASSERT( lElements > 0 );

    //
    // check for __NOW alias.
    //         

    if ( wbem_wcsicmp( rPropName.GetStringAt(0), g_wszNowAlias ) == 0 )
    {
        FILETIME ft;
        WCHAR achBuff[64];
        GetSystemTimeAsFileTime(&ft);
        FileTimeToDateTime(&ft,achBuff,64);
        rulCimType = CIM_DATETIME;
        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(achBuff);

        if ( V_BSTR(pvarRet) == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_NO_ERROR;
    }

    //
    // check for __SERVER alias
    //

    if ( wbem_wcsicmp( rPropName.GetStringAt(0), g_wszServerAlias ) == 0 )
    {        
        rulCimType = CIM_STRING;
        V_VT(pvarRet) = VT_BSTR;

        LPCWSTR lpwszComputerName = FastGetComputerName();

        if ( NULL == lpwszComputerName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        V_BSTR(pvarRet) = SysAllocString(lpwszComputerName);
        
        if ( V_BSTR(pvarRet) == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        return WBEM_S_NO_ERROR;
    }

    LPVOID pvPropHdl = rPropName.GetHandle();
    _DBG_ASSERT( pvPropHdl != NULL );

    CIMTYPE ct;

    hr = pAccess->GetProp( pvPropHdl, 0, pvarRet, &ct );

    if ( FAILED(hr) )
    {
        return hr;
    }

    rulCimType = ct;

    return hr;

/*        
    HRESULT hr = GetInnerMostObject( PropName, pObj, &pInnerObj );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemBSTR bstrElement = PropName.GetStringAt( lElements-1 );
        
    hr = pInnerObj->Get( bstrElement, 0, pvarRet, (long*)&rulCimType, NULL );

    if ( rulCimType == CIM_DATETIME )
    {
        //
        // have to know if the datetime is really an interval or not.
        //

        CWbemPtr<IWbemQualifierSet> pQualSet;
        hr = pInnerObj->GetPropertyQualifierSet( bstrElement, &pQualSet );

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        VARIANT vSubType;
        hr = pQualSet->Get( g_wszSubType, 0, &vSubType, NULL );

        if ( SUCCEEDED(hr) )
        {
            if ( V_VT(&vSubType) == VT_BSTR && 
                 wbem_wcsicmp( V_BSTR(&vSubType), g_wszInterval ) == 0 )
            {
                rulCimType = CIM_INTERVAL; // non standard type !!!!
            }
            VariantClear(&vSubType);
        }
        else if ( hr == WBEM_E_NOT_FOUND )
        {
            hr = WBEM_S_NO_ERROR;
        }
    }

    return hr;
*/

}

//
// this method handles embedded object properties. 
//

HRESULT SetValue( CPropertyName& rPropName,
                  IWmiObjectAccess* pAccess,
                  VARIANT vVal,
                  ULONG ulCimType )
{
    HRESULT hr;

    long lElements = rPropName.GetNumElements();

    _DBG_ASSERT( lElements > 0 );

    LPCWSTR wszElement = rPropName.GetStringAt(lElements-1);

    if ( wszElement == NULL )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    LPVOID pvPropHdl = rPropName.GetHandle();

    _DBG_ASSERT( pvPropHdl != NULL );

    if ( wbem_wcsicmp( wszElement, L"__this" ) != 0 )
    {
        //
        // first get the type of the property we are going to set
        //
 
        CIMTYPE ctProp;

        hr = pAccess->GetProp( pvPropHdl, 0, NULL, &ctProp );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // now convert our type to the expected type if necessary.
        // currently, the put will do most conversion, however we run into
        // a problem with conversion when the variant type doesn't correctly
        // describe the type that it holds.  to complicate this further, 
        // specifying the cim type on the put doesn't do the job.  The only
        // conversion we have to worry about is an unsigned val to a string. 
        // (because variant will say it is a signed type).
        // 

        WCHAR awchBuff[64]; // used for conversion from unsigned to string 

        if ( ctProp == CIM_STRING )
        {            
            if ( ulCimType == CIM_UINT32 || 
                 ulCimType == CIM_UINT16 ||
                 ulCimType == CIM_UINT8 )
            {
                hr = VariantChangeType( &vVal, &vVal, 0, VT_UI4 );
                
                if ( FAILED(hr) )
                {
                    return WBEM_E_TYPE_MISMATCH;
                }
                
                _ultow( V_UI4(&vVal), awchBuff, 10 );

                V_VT(&vVal) = VT_BSTR;
                V_BSTR(&vVal) = awchBuff;
            }
        }

        return pAccess->PutProp( pvPropHdl, 0, &vVal, 0 );
    }

    return WBEM_E_NOT_SUPPORTED;
}
/*
    //
    // we need to copy the entire object. first check that the 
    // variant is of the correct type.
    //

    if ( V_VT(&vVal) != VT_UNKNOWN )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    CWbemPtr<IWbemClassObject> pOther;
    
    hr = V_UNKNOWN(&vVal)->QueryInterface( IID_IWbemClassObject,
                                           (void**)&pOther );
    if ( FAILED(hr) )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    //
    // we don't do a clone here because the target object might not be of 
    // the same class as the source object, although it must have the same 
    // properties. ( this might be going a bit too far ).
    // 

    hr = pOther->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BSTR bstrOther;
    VARIANT vOther;
    CIMTYPE ctOther;

    VariantInit( &vOther );
    CClearMe cmvOther( &vOther );

    hr = pOther->Next( 0, &bstrOther, &vOther, &ctOther, NULL ); 

    while( hr == WBEM_S_NO_ERROR )
    {
        hr = pInnerObj->Put( bstrOther, 0, &vOther, ctOther );

        SysFreeString( bstrOther );
        VariantClear( &vOther );

        if ( FAILED(hr) )
        {
            return hr;
        }
                         
        hr = pOther->Next( 0, &bstrOther, &vOther, &ctOther, NULL ); 
    }       

    return hr;
}

*/

inline void GetAssignmentTokenText( SQLAssignmentToken& rToken, 
                                    CWbemBSTR& rbstrText )
{
    for( int i=0; i < rToken.size(); i++ )
    {
        LPWSTR wszTokenText = rToken[i].GetText();
        rbstrText += wszTokenText;
        delete wszTokenText;
    }
}
    

/***************************************************************************
  CResolverSink
****************************************************************************/

HRESULT CResolverSink::ResolveAliases( IWmiObjectAccess* pAccess,
                                       AliasInfo& rInfo,
                                       CUpdConsState& rState )
{
    int i, j, k;
    HRESULT hr = S_OK;
    VARIANT* pvarTgt;

    SQLCommand* pCmd = rState.GetSqlCmd();

    if ( rInfo.m_WhereOffsets.size() + rInfo.m_AssignOffsets.size() > 0 
         && pAccess == NULL )
    {
        return WBEM_E_INVALID_QUERY;
    }

    for( i=0; i < rInfo.m_AssignOffsets.size(); i++ )
    {
        j = rInfo.m_AssignOffsets[i] >> 16;
        k = rInfo.m_AssignOffsets[i] & 0xffff;
        
        SQLExpressionToken& rExprTok = pCmd->m_AssignmentTokens[j][k];
        
        ULONG& rulCimType = rExprTok.m_ulCimType;
        pvarTgt = &rExprTok.m_vValue;
        
        VariantClear( pvarTgt );
        
        hr = GetValue( rExprTok.m_PropName, pAccess, rulCimType, pvarTgt );

        if ( FAILED(hr) )
        {
            LPWSTR wszErrStr = rExprTok.m_PropName.GetText();
            rState.SetErrStr( wszErrStr );
            delete wszErrStr;
            return hr;
        }
    }

    for( i=0; i < rInfo.m_WhereOffsets.size(); i++ )
    {
        j = rInfo.m_WhereOffsets[i];
        pvarTgt = &pCmd->pArrayOfTokens[j].vConstValue;

        VariantClear( pvarTgt );

        // Property to resolve is always property 2 ..
        CPropertyName& rTgtProp = pCmd->pArrayOfTokens[j].PropertyName2;

        ULONG ulCimType;
        hr = GetValue( rTgtProp, pAccess, ulCimType, pvarTgt );

        if ( FAILED(hr) )
        {
            LPWSTR wszErrStr = rTgtProp.GetText();
            rState.SetErrStr( wszErrStr );
            delete wszErrStr;
            return hr;
        }
    }

    return hr;
}

HRESULT CResolverSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // resolve any event aliases. 
    // 

    hr = ResolveAliases( rState.GetEventAccess(), m_rEventAliasInfo, rState );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // resolve ant data aliases
    // 

    hr = ResolveAliases( rState.GetDataAccess(), m_rDataAliasInfo, rState );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pNext->Execute( rState );
}

/***************************************************************************
  CFetchDataSink
****************************************************************************/

HRESULT CFetchDataSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // execute the query here.  for each object returned, call resolve 
    // and continue with the execute.
    //

    long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
        
    //
    // first, we must resolve any Event Aliases in the data query.
    //
        
    CTextTemplate TextTmpl( m_wsDataQuery );
        
    BSTR bsNewQuery = TextTmpl.Apply( rState.GetEvent() );

    if ( bsNewQuery == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CSysFreeMe sfm( bsNewQuery );  
    
    //
    // execute the data query.
    // 
    
    CWbemPtr<IEnumWbemClassObject> pEnum;

    hr = m_pDataSvc->ExecQuery( CWbemBSTR(g_wszQueryLang), 
                                bsNewQuery,
                                lFlags, 
                                NULL, 
                                &pEnum );    
    if ( FAILED(hr) )
    {
        rState.SetErrStr( bsNewQuery );
        return hr;
    }

    ULONG cRetObjs;
    CWbemPtr<IWbemClassObject> pData;
        
    //
    // for each data object returned, call execute on next sink.
    //
    
    hr = pEnum->Next( WBEM_INFINITE, 1, &pData, &cRetObjs );

    if ( FAILED(hr) )
    {
        //
        // only need to check on the first next to see if the query was 
        // invalid ( since we're using 'return immediately' we don't catch it
        // on the exec query - kind of inconvienent )
        // 
        rState.SetErrStr( bsNewQuery );
        return hr;
    }

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cRetObjs == 1 );

        rState.SetData( pData );

        hr = m_pNext->Execute( rState );

        if ( FAILED(hr) )
        {
            break;
        }

        pData.Release();
        
        hr = pEnum->Next( WBEM_INFINITE, 1, &pData, &cRetObjs );
    }

    if ( hr != WBEM_S_FALSE )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

/***************************************************************************
  CFetchTargetObjectsAsync
****************************************************************************/

HRESULT CFetchTargetObjectsAsync::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // set the next item in the chain on the state, then pass the 
    // state object as the object sink. 
    //

    CUpdConsSink* pOldNext = rState.GetNext();

    rState.SetNext( m_pNext );

    SQLCommand* pCmd = rState.GetSqlCmd();

    hr = m_pSvc->CreateInstanceEnumAsync( pCmd->bsClassName,
                                          WBEM_FLAG_DEEP,
                                          NULL, 
                                          &rState );
    rState.SetNext( pOldNext );

    return hr;
};

/***************************************************************************
  CFetchTargetObjectsSync
****************************************************************************/

HRESULT CFetchTargetObjectsSync::Execute( CUpdConsState& rState )
{
    HRESULT hr;
    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pObj;
    CWbemPtr<IEnumWbemClassObject> pEnum;

    long lFlags = WBEM_FLAG_DEEP | 
                  WBEM_FLAG_FORWARD_ONLY | 
                  WBEM_FLAG_RETURN_IMMEDIATELY;

    SQLCommand* pCmd = rState.GetSqlCmd();

    hr = m_pSvc->CreateInstanceEnum( pCmd->bsClassName,
                                     lFlags,
                                     NULL,
                                     &pEnum );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs == 1 );
        
        rState.SetInst( pObj );

        hr = m_pNext->Execute( rState );

        if ( FAILED(hr) )
        {
            break;
        }

        pObj.Release();
        hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return WBEM_S_NO_ERROR;
};

/***************************************************************************
  CNoFetchTargetObjects
****************************************************************************/

HRESULT CNoFetchTargetObjects::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    CWbemPtr<IWbemClassObject> pObj;
    hr = m_pClassObj->SpawnInstance( 0, &pObj );
    
    if ( FAILED(hr) ) 
    {
        return hr;
    }    

    rState.SetInst( pObj );

    return m_pNext->Execute( rState );
}                           

/***************************************************************************
  CTraceSink 
****************************************************************************/
 
HRESULT CTraceSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // execute the next object and then generate a trace event.
    //

    if ( m_pNext != NULL )
    {
        hr = m_pNext->Execute( rState );
    }
    else
    {
        hr = S_OK;
    }

    m_pScenario->FireTraceEvent( m_pTraceClass, rState, hr );

    return hr;
}

/****************************************************************************
  CFilterSink
*****************************************************************************/

HRESULT CFilterSink::Execute( CUpdConsState& rState )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    char achStack[256];
    UCHAR chTop = 0;
    BOOL bA,bB;
    LPWSTR wszErrStr;
    QL_LEVEL_1_TOKEN* pToken;

    SQLCommand* pCmd = rState.GetSqlCmd();
    IWmiObjectAccess* pAccess = rState.GetInstAccess();

    if ( pCmd->nNumTokens == 0 )
    {
        // nothing to filter ...
        return m_pNext->Execute( rState );
    }

    chTop = 0;
    for( int j=0; j < pCmd->nNumTokens; j++ )
    {
        pToken = &pCmd->pArrayOfTokens[j];

        switch( pToken->nTokenType )
        {
            
        case QL_LEVEL_1_TOKEN::OP_EXPRESSION:
            hr = EvaluateToken( pAccess, *pToken );
            if ( FAILED(hr) )
            {
                wszErrStr = pToken->GetText();
                rState.SetErrStr( wszErrStr );
                delete wszErrStr;
                return hr;
            }
            achStack[chTop++] = hr != S_FALSE;
            break;
            
        case QL_LEVEL_1_TOKEN::TOKEN_AND:
            bA = achStack[--chTop];
            bB = achStack[--chTop];
            achStack[chTop++] = bA && bB;
            break;
            
        case QL_LEVEL_1_TOKEN::TOKEN_OR:
            bA = achStack[--chTop];
            bB = achStack[--chTop];
            achStack[chTop++] = bA || bB;
            break;
            
        case QL_LEVEL_1_TOKEN::TOKEN_NOT:
            achStack[chTop-1] = achStack[chTop-1] == 0;
            break;
        }
    }

    // now we should be left with one token on the stack - or 
    // something is wrong with our parser .. 
    _DBG_ASSERT( chTop == 1 );
    
    if ( achStack[0] )
    {
        hr = m_pNext->Execute( rState );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

/***************************************************************************
  CAssignmentSink
****************************************************************************/

//
// The purpose of this function is to smooth out differences in 
// PutInstance() semantics between the Transient and other Providers.  
// Transient provider is different than other providers because it treats
// properties that are NULL as ignore. 
//

HRESULT CAssignmentSink::NormalizeObject( IWbemClassObject* pObj,
                                          IWbemClassObject** ppNormObj )
{
    HRESULT hr;
    *ppNormObj = NULL;

    if ( m_eCommandType == SQLCommand::e_Insert )
    {
        //
        // if its an insert, we don't need to do anything.
        //

        pObj->AddRef();
        *ppNormObj = pObj;
        
        return WBEM_S_NO_ERROR;
    }

    //
    // We always need to update a copy because the we need to keep 
    // the original state of the object to maintain the update semantics.
    // Whether we clone or spawn a new instance depends on the transient 
    // semantics.
    //

    if ( !m_bTransSemantics )
    {
        return pObj->Clone( ppNormObj );
    }

    //
    // for transient semantics, we spawn a new instance and set the 
    // key props.
    //

    CWbemPtr<IWbemClassObject> pNormObj;

    hr = m_pClassObj->SpawnInstance( 0, &pNormObj );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    hr = pObj->BeginEnumeration( WBEM_FLAG_KEYS_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BSTR bstrProp;
    VARIANT varProp;
    
    hr = pObj->Next( NULL, &bstrProp, &varProp, NULL, NULL);

    while( hr == WBEM_S_NO_ERROR )
    {
        hr = pNormObj->Put( bstrProp, NULL, &varProp, 0 );

        SysFreeString( bstrProp );
        VariantClear( &varProp );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pObj->Next( NULL, &bstrProp, &varProp, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    pObj->EndEnumeration();
    
    pNormObj->AddRef();
    *ppNormObj = pNormObj.m_pObj;
    
    return WBEM_S_NO_ERROR;
}

HRESULT CAssignmentSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    _DBG_ASSERT( rState.GetSqlCmd()->nNumberOfProperties == 
                 rState.GetSqlCmd()->m_AssignmentTokens.size() );

    SQLCommand* pCmd = rState.GetSqlCmd();    
    IWbemClassObject* pOrig = rState.GetInst();

    CWbemPtr<IWbemClassObject> pObj;
        
    hr = NormalizeObject( pOrig, &pObj );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // move our current inst to original inst and set the new obj as inst.
    //
    rState.SetInst( pObj );
    rState.SetOrigInst( pOrig ); 

    IWmiObjectAccess* pInstAccess = rState.GetInstAccess();
    IWmiObjectAccess* pOrigInstAccess = rState.GetOrigInstAccess();

    _DBG_ASSERT( pInstAccess != NULL && pOrigInstAccess != NULL );

    for( int j=0; j < pCmd->m_AssignmentTokens.size(); j++ )
    {            
        SQLAssignmentToken& rAssignTok = pCmd->m_AssignmentTokens[j];
        VARIANT varAssign;
        ULONG ulCimType;

        if ( rAssignTok.size() == 1 )
        {
            // 
            // bypass Evaluation of the expression.  This is because 
            // it does not handle strings, objects, etc ...
            //
            
            hr = GetTokenValue( rAssignTok[0], 
                                pOrigInstAccess, 
                                ulCimType, 
                                varAssign );
        }
        else
        {   
            CCimValue Value;

            hr = EvaluateExpression( rAssignTok, pOrigInstAccess, Value );

            if ( FAILED(hr) )
            {
                CWbemBSTR bsErrStr;
                GetAssignmentTokenText( rAssignTok, bsErrStr );      
                rState.SetErrStr( bsErrStr );
                break;
            }

            // 
            // now must get the cimtype of the property.
            //

            hr = GetValue( pCmd->pRequestedPropertyNames[j],
                           pOrigInstAccess,
                           ulCimType, 
                           NULL );
            
            if ( FAILED(hr) )
            {
                LPWSTR wszErrStr = pCmd->pRequestedPropertyNames[j].GetText();
                rState.SetErrStr( wszErrStr);
                delete wszErrStr;
                return hr;
            }

            // 
            // Get the final value from the CCimValue object. 
            //

            hr = Value.GetValue( varAssign, ulCimType );
        }

        if ( FAILED(hr) )
        {
            CWbemBSTR bsErrStr;
            GetAssignmentTokenText( rAssignTok, bsErrStr );      
            rState.SetErrStr( bsErrStr );
            break;
        }
        
        hr = SetValue( pCmd->pRequestedPropertyNames[j], 
                       pInstAccess,
                       varAssign,
                       ulCimType );

        VariantClear( &varAssign );

        if ( FAILED(hr) )
        {
            LPWSTR wszErrorStr = pCmd->pRequestedPropertyNames[j].GetText();
            rState.SetErrStr( wszErrorStr );
            delete wszErrorStr;
            return hr;
        }
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pNext->Execute( rState );
}

/*************************************************************************
  CPutSink
**************************************************************************/

HRESULT CPutSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    long lFlags = m_lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;
    
    IWbemClassObject* pObj = rState.GetInst();

    if ( m_lFlags & WBEM_FLAG_RETURN_IMMEDIATELY )
    {
        CUpdConsSink* pOldNext = rState.GetNext();

        rState.SetNext( NULL );  // use state obj as a null sink.
        
        hr = m_pSvc->PutInstanceAsync( pObj, lFlags, NULL, &rState );
    
        rState.SetNext( pOldNext );
    }
    else
    {
        hr = m_pSvc->PutInstance( pObj, lFlags, NULL, NULL );
    }
        
    if ( (hr == WBEM_E_ALREADY_EXISTS && m_lFlags & WBEM_FLAG_CREATE_ONLY) || 
         (hr == WBEM_E_NOT_FOUND && m_lFlags & WBEM_FLAG_UPDATE_ONLY) )
    {
        hr = WBEM_S_FALSE;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_pNext != NULL )
    {
        HRESULT hr2;

        hr2 = m_pNext->Execute( rState );

        if ( FAILED(hr2) )
        {
            return hr2;
        }
    }

    //
    // make sure that if the Put was not executed, but also did not execute 
    // that we return WBEM_S_FALSE
    //

    return hr;
}

/*************************************************************************
  CDeleteSink
**************************************************************************/

HRESULT CDeleteSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;
    CPropVar vRelPath;

    IWbemClassObject* pObj = rState.GetInst();

    hr = pObj->Get( g_wszRelPath, 0, &vRelPath, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vRelPath.CheckType(VT_BSTR)) ) 
    {
        return hr;
    }

    long lFlags = m_lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;
    
    if ( m_lFlags & WBEM_FLAG_RETURN_IMMEDIATELY )
    {
        CUpdConsSink* pOldNext = rState.GetNext();

        rState.SetNext( NULL );
        
        hr = m_pSvc->DeleteInstanceAsync( V_BSTR(&vRelPath), 
                                          lFlags, 
                                          NULL, 
                                          &rState );            
        rState.SetNext( pOldNext );
    }
    else
    {
        hr = m_pSvc->DeleteInstance( V_BSTR(&vRelPath), lFlags, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        rState.SetErrStr( V_BSTR(&vRelPath) );
        return hr;
    }
    
    if ( m_pNext != NULL )
    {
        return m_pNext->Execute( rState );
    }

    return WBEM_S_NO_ERROR;
}

/*************************************************************************
  CBranchIndicateSink
**************************************************************************/

HRESULT CBranchIndicateSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    IWbemClassObject* pInst = rState.GetInst();
       
    hr = m_pSink->Indicate( 1, &pInst );
        
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_pNext != NULL )
    {
        return m_pNext->Execute( rState );
    }

    return WBEM_S_NO_ERROR;
}

HRESULT EvaluateToken( IWmiObjectAccess* pObj, QL_LEVEL_1_TOKEN& Tok )
{
    VARIANT PropVal, CompVal;
    VariantInit(&PropVal);
    VariantInit(&CompVal);
    
    CClearMe clv(&PropVal);
    CClearMe clv2(&CompVal);

    HRESULT hr;

    if( Tok.nOperator == QL1_OPERATOR_ISA ||
        Tok.nOperator == QL1_OPERATOR_ISNOTA ||
        Tok.nOperator == QL1_OPERATOR_INV_ISA ||
        Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
    {
        return WBEM_E_INVALID_QUERY;
    }

    ULONG ulCimType1, ulCimType2 = CIM_EMPTY;

    hr = GetValue( Tok.PropertyName, pObj, ulCimType1, &PropVal );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Handle a property-to-property comparisons

    if ( Tok.m_bPropComp != FALSE && V_VT(&Tok.vConstValue) == VT_EMPTY )
    {
        hr = GetValue( Tok.PropertyName2, pObj, ulCimType2, &CompVal );
       
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        hr = VariantCopy( &CompVal, &Tok.vConstValue );

        if ( FAILED(hr) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // now propval and compval are both set ...

    //
    // if either CimType1 or CimType2 are of type relpath, we must normalize
    // the relpaths of both and then compare
    // 

    if ( ulCimType1 == CIM_REFERENCE || ulCimType2 == CIM_REFERENCE )
    {
        // This is a reference. The only operators allowed are = and !=
        // ============================================================
        
        if ( V_VT(&CompVal) != VT_BSTR || V_VT(&PropVal) != VT_BSTR )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        CRelativeObjectPath PathA;
        CRelativeObjectPath PathB;

        if ( !PathA.Parse( V_BSTR(&CompVal) ) ||
            !PathB.Parse( V_BSTR(&PropVal) ) )
        {
            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL )
        {
            return PathA == PathB ? S_OK : S_FALSE;
        }
        else if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL )
        {
            return PathA == PathB ? S_FALSE : S_OK;
        }
        return WBEM_E_INVALID_QUERY;
    }

    // Handle NULLs
    // ============

    if( V_VT(&PropVal) == VT_NULL)
    {
        if ( V_VT(&CompVal) == VT_NULL)
        {
            if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL )
                return S_OK;
            return S_FALSE;
        }
        else
        {
            if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL )
                return S_OK;
            return S_FALSE;
        }
    }
    else if ( V_VT(&CompVal) == VT_NULL )
    {
        if( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL )
            return S_OK;
        return S_FALSE;
    }

    // Coerce types to match.
    // ======================

    if(V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        hr = VariantChangeType(&CompVal, &CompVal, 0, V_VT(&PropVal));
        if(FAILED(hr))
        {
            return WBEM_E_INVALID_QUERY;
        }
    }

    switch (V_VT(&CompVal))
    {
    case VT_NULL:
        return WBEM_E_INVALID_QUERY; // handled above

    case VT_I4:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            LONG va = V_I4(&PropVal);
            LONG vb = V_I4(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_I2:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            short va = V_I2(&PropVal);
            short vb = V_I2(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_UI1:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            BYTE va = V_I1(&PropVal);
            BYTE vb = V_I1(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_BSTR:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }
            LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
            LPWSTR vb = (LPWSTR) V_BSTR(&CompVal);

            int retCode = 0;
            BOOL bDidIt = TRUE;

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL:
                retCode = ( wbem_wcsicmp(va,vb) == 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                retCode = (wbem_wcsicmp(va, vb) != 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                retCode = (wbem_wcsicmp(va, vb) >= 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                retCode = (wbem_wcsicmp(va, vb) <= 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                retCode = (wbem_wcsicmp(va, vb) < 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                retCode = (wbem_wcsicmp(va, vb) > 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_LIKE:
                retCode = (wbem_wcsicmp(va,vb) == 0);
                break;
            default:
                bDidIt = FALSE;
                break;
            }
            VariantClear(&CompVal);
            if (bDidIt)
            {
                return retCode ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_R8:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }
            
            double va = V_R8(&PropVal);
            double vb = V_R8(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_R4:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            float va = V_R4(&PropVal);
            float vb = V_R4(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_BOOL:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            VARIANT_BOOL va = V_BOOL(&PropVal);
            if(va != VARIANT_FALSE) va = VARIANT_TRUE;
            VARIANT_BOOL vb = V_BOOL(&CompVal);
            if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return (va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;
    }

    return S_FALSE;
}

HRESULT GetTokenValue( SQLExpressionToken& rExprTok, 
                       IWmiObjectAccess* pAccess,
                       ULONG& rulCimType,
                       VARIANT& rvValue )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VariantInit( &rvValue );

    if ( V_VT(&rExprTok.m_vValue) == VT_EMPTY )
    {
        _DBG_ASSERT( rExprTok.m_PropName.GetNumElements() > 0 );
        
        hr = GetValue( rExprTok.m_PropName, 
                       pAccess, 
                       rulCimType,
                       &rvValue );        
    }
    else
    {
        hr = VariantCopy( &rvValue, &rExprTok.m_vValue );
        
        if ( FAILED(hr) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        rulCimType = rExprTok.m_ulCimType;
    }
    
    return hr;
}

HRESULT EvaluateExpression( SQLAssignmentToken& rAssignTok, 
                            IWmiObjectAccess* pAccess,
                            CCimValue& rValue )
{
    CCimValue ValA, ValB, ValC, ValZero;

    HRESULT hr = S_OK;
    std::stack<CCimValue> Stack;

    try 
    {
       for( int i=0; i < rAssignTok.size(); i++ )
       {
           SQLExpressionToken& rExprTok = rAssignTok[i];
           
           if ( rExprTok.m_eTokenType == SQLExpressionToken::e_Operand )
           {                
               VARIANT vValue;
               ULONG ulCimType;

               hr = GetTokenValue( rExprTok, pAccess, ulCimType, vValue );
               
               if ( FAILED(hr) )
               {
                   return hr;
               }
               
               hr = ValA.SetValue( vValue, ulCimType );
               
               VariantClear( &vValue );

               if ( FAILED(hr) )
               {                    
                   return hr;
               }
               
               Stack.push( ValA );
               
               continue;
           }
           
           _DBG_ASSERT( !Stack.empty() );

           if ( rExprTok.m_eTokenType == SQLExpressionToken::e_UnaryMinus )
           {
               ValA = Stack.top();
               Stack.pop();
               Stack.push( ValZero - ValA );
               continue;
           }

           if ( rExprTok.m_eTokenType == SQLExpressionToken::e_UnaryPlus )
           {
               continue;
           }
           
           ValB = Stack.top();
           Stack.pop();
           _DBG_ASSERT( !Stack.empty() );
           ValA = Stack.top();
           Stack.pop();

           switch( rExprTok.m_eTokenType )
           {
           case SQLExpressionToken::e_Plus :
               ValC = ValA + ValB;
               break;

           case SQLExpressionToken::e_Minus :
               ValC = ValA - ValB;
               break;

           case SQLExpressionToken::e_Mult :
               ValC = ValA * ValB;
               break;

           case SQLExpressionToken::e_Div :
               ValC = ValA / ValB;
               break;

           case SQLExpressionToken::e_Mod :
               ValC = ValA % ValB;
               break;
           };

           Stack.push( ValC );
       }

       _DBG_ASSERT( !Stack.empty() );
       rValue = Stack.top();
       Stack.pop();
    }
    catch ( ... )
    {
        hr = DISP_E_DIVBYZERO;
    }
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsink.h ===
#ifndef __UPDSINK_H__
#define __UPDSINK_H__

#include <assert.h>
#include <wbemcli.h>
#include <wstring.h>
#include <unk.h>
#include <comutl.h>
#include <vector>
#include <wstlallc.h>
#include <wmimsg.h>
#include "updsql.h"
#include "updscen.h"

typedef std::vector<DWORD,wbem_allocator<DWORD> > AliasOffsetVector;
typedef std::vector<CWbemPtr<IWbemClassObject>, wbem_allocator< CWbemPtr<IWbemClassObject> > > ClassObjectVector;

/***********************************************************************
  AliasInfo - structure describing alias offsets in the assign and 
  where tokens of the SQLCommand. In the case of the assign offsets, the
  first two bytes are the offset of the assign token and second two bytes are 
  the offset of the expression token.
************************************************************************/
struct AliasInfo
{
    AliasOffsetVector m_AssignOffsets;
    AliasOffsetVector m_WhereOffsets;

    void AddAssignOffset( int iAssignTok, int iExprTok )
    {
        DWORD dwOffset = iAssignTok;
        dwOffset <<= 16;
        dwOffset |= iExprTok;

        m_AssignOffsets.insert( m_AssignOffsets.end(), dwOffset );
    }
        
    void AddWhereOffset( int i )
    {
        m_WhereOffsets.insert( m_WhereOffsets.end(), i );
    }
};

/********************************************************************
  CUpdConsSink
*********************************************************************/

class CUpdConsSink : public CUnk
{
protected:

    CWbemPtr<CUpdConsSink> m_pNext;

    void* GetInterface( REFIID ) { return NULL; }

    CUpdConsSink( CUpdConsSink* pNext ) : m_pNext( pNext ) {}

public:

    CUpdConsSink* GetNext() { return m_pNext; }
    void SetNext( CUpdConsSink* pSink ) { m_pNext = pSink; }

    virtual HRESULT Execute( CUpdConsState& rState ) = 0;
    
    virtual ~CUpdConsSink() {}
};
 
/*************************************************************************
  CResolverSink - this sink fixes up the unresolved props in the sql cmd
  with the values from the data and event objects.
**************************************************************************/

class CResolverSink : public CUpdConsSink
{
    AliasInfo& m_rEventAliasInfo;
    AliasInfo& m_rDataAliasInfo;

    HRESULT ResolveAliases( IWmiObjectAccess* pAccess,
                            AliasInfo& rInfo,
                            CUpdConsState& rState );

public:

    CResolverSink( AliasInfo& rEventAliasInfo, 
                   AliasInfo& rDataAliasInfo,
                   CUpdConsSink* pNext )
    : m_rEventAliasInfo(rEventAliasInfo), 
      m_rDataAliasInfo(rDataAliasInfo),
      CUpdConsSink( pNext ) {}

    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFetchDataSink 
**************************************************************************/

class CFetchDataSink : public CUpdConsSink
{
    WString m_wsDataQuery;
    CWbemPtr<IWbemServices> m_pDataSvc;

public:

    CFetchDataSink( LPCWSTR wszDataQuery,
                    IWbemServices* pDataSvc,
                    CUpdConsSink* pNext )
    : CUpdConsSink(pNext), m_wsDataQuery(wszDataQuery), m_pDataSvc(pDataSvc){}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFetchTargetObjectsAsync
**************************************************************************/

class CFetchTargetObjectsAsync : public CUpdConsSink
{
    CWbemPtr<IWbemServices> m_pSvc;
    
public:

    CFetchTargetObjectsAsync( IWbemServices* pSvc, CUpdConsSink* pNext ) 
    : CUpdConsSink(pNext), m_pSvc(pSvc)  {}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFetchTargetObjectsSync
**************************************************************************/

class CFetchTargetObjectsSync : public CUpdConsSink
{
    CWbemPtr<IWbemServices> m_pSvc;
    
public:

    CFetchTargetObjectsSync( IWbemServices* pSvc, CUpdConsSink* pNext ) 
    : CUpdConsSink( pNext ), m_pSvc( pSvc)  {}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CNoFetchTargetObjects
**************************************************************************/

class CNoFetchTargetObjects : public CUpdConsSink
{
    CWbemPtr<IWbemClassObject> m_pClassObj;
    
public:

    CNoFetchTargetObjects( IWbemClassObject* pClassObj, CUpdConsSink* pNext ) 
    : CUpdConsSink(pNext), m_pClassObj(pClassObj)  {}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CTraceSink
**************************************************************************/
    
class CTraceSink : public CUpdConsSink
{    
    CWbemPtr<CUpdConsScenario> m_pScenario;
    CWbemPtr<IWbemClassObject> m_pTraceClass;

public:

    CTraceSink( CUpdConsScenario* pScenario,
                IWbemClassObject* pTraceClass,
                CUpdConsSink* pNext ) 
    : CUpdConsSink(pNext), m_pTraceClass(pTraceClass), m_pScenario(pScenario){}

    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFilterSink
**************************************************************************/

class CFilterSink : public CUpdConsSink
{
public:

    CFilterSink(CUpdConsSink* pNext) : CUpdConsSink(pNext) {}

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CAssignmentSink
**************************************************************************/

class CAssignmentSink : public CUpdConsSink
{
    
    BOOL m_bTransSemantics;
    CWbemPtr<IWbemClassObject> m_pClassObj;
    SQLCommand::CommandType m_eCommandType;

    HRESULT NormalizeObject( IWbemClassObject* pObj,
                             IWbemClassObject** ppNormObj );
public:

    CAssignmentSink( BOOL bTransSemantics,
                     IWbemClassObject* pClassObj,
                     SQLCommand::CommandType eCommandType,
                     CUpdConsSink* pNext )
    : m_bTransSemantics(bTransSemantics), m_pClassObj(pClassObj),
      CUpdConsSink(pNext), m_eCommandType(eCommandType) { }

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CPutSink
**************************************************************************/

class CPutSink : public CUpdConsSink
{
    CWbemPtr<IWbemServices> m_pSvc;
    long m_lFlags;
    
public: 

    CPutSink( IWbemServices* pSvc, long lFlags, CUpdConsSink* pNext )
    : CUpdConsSink(pNext), m_pSvc(pSvc), m_lFlags(lFlags) {}

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CDeleteSink
**************************************************************************/

class CDeleteSink : public CUpdConsSink
{
    long m_lFlags;
    CWbemPtr<IWbemServices> m_pSvc;
    
public: 

    CDeleteSink( IWbemServices* pSvc, long lFlags, CUpdConsSink* pNext) 
    : CUpdConsSink(pNext), m_pSvc(pSvc), m_lFlags(lFlags) {}

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CBranchIndicateSink
**************************************************************************/

class CBranchIndicateSink : public CUpdConsSink
{
    CWbemPtr<IWbemObjectSink> m_pSink;

public:

    CBranchIndicateSink( IWbemObjectSink* pSink, CUpdConsSink* pNext )
    : CUpdConsSink(pNext), m_pSink(pSink) { }

    HRESULT Execute( CUpdConsState& rState );
};
    
#endif // __UPDSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsql.h ===
#ifndef __SQLPARSE_H__
#define __SQLPARSE_H__

#include <stdio.h>
#include <vector>
#include <wstlallc.h>
#include "ql.h"

#define QL_1_TOK_UPDATE        140
#define QL_1_TOK_INSERT        141
#define QL_1_TOK_DELETE        142
#define QL_1_TOK_SET           143
#define QL_1_TOK_VALUES        144
#define QL_1_TOK_INTO          145
#define QL_1_TOK_PLUS          146
#define QL_1_TOK_MINUS         147
#define QL_1_TOK_MULT          148
#define QL_1_TOK_DIV           149
#define QL_1_TOK_MOD           150

struct SQLExpressionToken
{
    enum TokenType { e_Operand, 
                     e_Plus, 
                     e_Minus, 
                     e_Div, 
                     e_Mult, 
                     e_Mod, 
                     e_UnaryMinus, 
                     e_UnaryPlus } m_eTokenType;

    CPropertyName m_PropName;
    VARIANT m_vValue;
    ULONG m_ulCimType; 

    SQLExpressionToken();
    ~SQLExpressionToken();
    SQLExpressionToken( const SQLExpressionToken& );
    SQLExpressionToken& operator=( const SQLExpressionToken& );

    LPWSTR GetText();
};

typedef std::vector<SQLExpressionToken,wbem_allocator<SQLExpressionToken> > SQLExpressionTokenList;
typedef SQLExpressionTokenList SQLAssignmentToken; 
typedef std::vector<SQLAssignmentToken,wbem_allocator<SQLAssignmentToken> > SQLAssignmentTokenList;

struct SQLCommand : QL_LEVEL_1_RPN_EXPRESSION
{
    enum CommandType { e_Select, 
                       e_Update, 
                       e_Delete, 
                       e_Insert } m_eCommandType; 
    
    QL_LEVEL_1_RPN_EXPRESSION m_ConditionTokens;
    SQLAssignmentTokenList m_AssignmentTokens;
    
    LPWSTR GetTextEx();
};


class CSQLParser : public CAbstractQl1Parser
{
    virtual BOOL Next( int nFlags = ALL_KEYWORDS );

    int parse2();
   
    int update_statement();
    int delete_statement();
    int insert_statement();
   
    int prop_spec();
    int value_spec();

    int value_list();
    int value_list2();

    int assign_list();
    int assign_list2();

    int assign_expr();
    
    int add_expr();
    int add_expr2();

    int mult_expr();
    int mult_expr2();

    int secondary_expr();
    int primary_expr();

    void SetNewAssignmentToken();
    void AddExpressionToken( SQLExpressionToken::TokenType eTokenType ); 
    SQLAssignmentToken* m_pCurrAssignmentToken;

    CSQLParser( const CSQLParser& );
    CSQLParser& operator=( const CSQLParser& );

public:

    CSQLParser( CGenLexSource& rSrc );
    ~CSQLParser( );
    
    int Parse( SQLCommand& rUpdate );
    int GetClassName( LPWSTR wszClassBuff, int cSize );
};

#endif __SQLPARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsql.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <qllex.h>
#include <wstring.h>
#include <genutils.h>
#include <corex.h>
#include <wbemutil.h>
#include "updsql.h"

typedef SQLCommand* PCOMMAND;
LexEl Ql_1_ModifiedLexTable[];

inline void CSQLParser::SetNewAssignmentToken()
{
    SQLAssignmentTokenList& rTokens = PCOMMAND(m_pSink)->m_AssignmentTokens;
    rTokens.insert( rTokens.end() );
    m_pCurrAssignmentToken = &rTokens.back();
}

inline void CSQLParser::AddExpressionToken(SQLExpressionToken::TokenType eType)
{
    _DBG_ASSERT( m_pCurrAssignmentToken != NULL );
    m_pCurrAssignmentToken->insert( m_pCurrAssignmentToken->end() ); 
    
    SQLExpressionToken& rExprTok = m_pCurrAssignmentToken->back();
    
    rExprTok.m_eTokenType = eType;
    
    if ( eType != SQLExpressionToken::e_Operand )
    {
        return;
    }

    rExprTok.m_PropName = m_PropertyName2;
    
    if ( FAILED(VariantCopy(&rExprTok.m_vValue,&m_vTypedConst) ) )
    {
        throw CX_MemoryException();
    }

    // reset everything ... 
    VariantClear(&m_vTypedConst);
    m_PropertyName.Empty();
    m_PropertyName2.Empty();
    m_bPropComp = FALSE;
}


//***************************************************************************
//
//  Next()
//
//  Extends CAbstractQl1Parser's Next() by checking for additional keywords.
//
//***************************************************************************
BOOL CSQLParser::Next( int nFlags )
{
    BOOL bRetval = CAbstractQl1Parser::Next( nFlags );

    // check new keywords ...
    if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        if (wbem_wcsicmp(m_pTokenText, L"update") == 0)
        {
            m_nCurrentToken = QL_1_TOK_UPDATE;
        }
        else if (wbem_wcsicmp(m_pTokenText, L"delete") == 0)
        {
            m_nCurrentToken = QL_1_TOK_DELETE;
        }
        else if (wbem_wcsicmp(m_pTokenText, L"insert") == 0)
        {
            m_nCurrentToken = QL_1_TOK_INSERT;
        }
        else if (wbem_wcsicmp(m_pTokenText, L"set") == 0)
        {
            m_nCurrentToken = QL_1_TOK_SET;
        }
        else if (wbem_wcsicmp(m_pTokenText, L"values") == 0)
        {
            m_nCurrentToken = QL_1_TOK_VALUES;
        }
        else if (wbem_wcsicmp(m_pTokenText, L"into") == 0)
        {
            m_nCurrentToken = QL_1_TOK_INTO;
        }
    }

    return bRetval;
}

//***************************************************************************
//
// <parse> ::= SELECT <select_statement>
// <parse> ::= UPDATE <update_statement>
// <parse> ::= DELETE <delete_statement>
// <parse> ::= INSERT <insert_statement>
//
//***************************************************************************
int CSQLParser::parse2()
{
    int nRes;

    int nLastToken = m_nCurrentToken;
    m_bInAggregation = FALSE;
    
    if ( nLastToken == QL_1_TOK_SELECT )
    {
        return parse(0); // should be select_statement().
    }

    if ( nLastToken == QL_1_TOK_UPDATE )
    {
        if ( !Next() )
            return LEXICAL_ERROR;
        nRes = update_statement();
    }
    else if ( nLastToken == QL_1_TOK_DELETE )
    {
        if ( !Next() )
            return LEXICAL_ERROR;
        nRes = delete_statement();
    }
    else if ( nLastToken == QL_1_TOK_INSERT )
    {
        if ( !Next() )
            return LEXICAL_ERROR;
        nRes = insert_statement();
    }
    else
    {
        nRes = SYNTAX_ERROR;
    }

    return nRes;
}

//***************************************************************************
//
// <update_statement> ::= <class_name> SET <assign_list> <opt_where>;
//
//***************************************************************************
int CSQLParser::update_statement()
{
    int nRes;

    PCOMMAND(m_pSink)->m_eCommandType = SQLCommand::e_Update;

    // <classsname>
    // ===========
    if (nRes = class_name())
    {
        return nRes;
    }
    
    if ( m_nCurrentToken != QL_1_TOK_SET )
    {
        return SYNTAX_ERROR;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    // <assign_list>
    // ====

    // this is a hack, but it'll do for now.  I need a slightly 
    // different lexer state table for arithmetic.  Since I'm using 
    // the ql_1 parser implementation, I do not have access to the 
    // table its lexer is using, so I have to sneak in the table, use
    // the lexer for the arithmetic, and then switch it back before 
    // anyone knows - pkenny .. 

    LexEl** ppLexTbl = (LexEl**)(((char*)m_pLexer) + 
                                 sizeof(CGenLexer) - sizeof(LexEl*));
    LexEl* pOld = *ppLexTbl;
    *ppLexTbl = Ql_1_ModifiedLexTable;

    if ( nRes = assign_list() )
    {
        return nRes;
    }

    *ppLexTbl = pOld;
    
    // <opt_where>
    // ==========
    return opt_where();
}

//***************************************************************************
//
// <delete_statement> ::= FROM <class_name> <opt_where>;
// <delete_statement> ::= <class_name> <opt_where>;
//
//***************************************************************************
int CSQLParser::delete_statement()
{
    int nRes;
    
    PCOMMAND(m_pSink)->m_eCommandType = SQLCommand::e_Delete;
    
    if ( m_nCurrentToken == QL_1_TOK_FROM )
    {
        if ( !Next() )
        {
            return LEXICAL_ERROR;
        }
    }
    
    // <classsname>
    // ===========
    if ( nRes = class_name() )
    {
        return nRes;
    }

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
// <insert_statement> ::= INTO <class_name> <prop_spec> <value_spec>;
// <insert_statement> ::= <class_name> <prop_spec> <value_spec>;
//
//***************************************************************************
int CSQLParser::insert_statement()
{
    int nRes;

    PCOMMAND(m_pSink)->m_eCommandType = SQLCommand::e_Insert;

    if ( m_nCurrentToken == QL_1_TOK_INTO )
    {
        if ( !Next() )
        {
            return LEXICAL_ERROR;
        }
    }

    // <classsname>
    // ===========
    if (nRes = class_name())
    {
        return nRes;
    }

    // <prop_spec>
    if ( nRes = prop_spec() )
    {
        return nRes;
    }

    // this is a hack, but it'll do for now.  I need a slightly 
    // different lexer state table for arithmetic.  Since I'm using 
    // the ql_1 parser implementation, I do not have access to the 
    // table its lexer is using, so I have to sneak in the table, use
    // the lexer for the arithmetic, and then switch it back before 
    // anyone knows - pkenny .. 

    LexEl** ppLexTbl = (LexEl**)(((char*)m_pLexer) + 
                                 sizeof(CGenLexer) - sizeof(LexEl*));
    LexEl* pOld = *ppLexTbl;
    *ppLexTbl = Ql_1_ModifiedLexTable;

    // <value_spec>
    if ( nRes = value_spec() )
    {
        return nRes;
    }

    *ppLexTbl = pOld;
        
    return SUCCESS;
}

//**********************************************************************
//
// <prop_spec> ::= OPEN_PAREN <prop_list> CLOSE_PAREN
//
//**********************************************************************
int CSQLParser::prop_spec()
{
    int nRes;

    if ( m_nCurrentToken != QL_1_TOK_OPEN_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( m_nCurrentToken == QL_1_TOK_ASTERISK )
    {
        return SYNTAX_ERROR;
    }

    if ( nRes = prop_list() )
    {
        return nRes;
    }

    if ( m_nCurrentToken != QL_1_TOK_CLOSE_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return SUCCESS;
}

    
//**********************************************************************
//
// <value_spec> ::= OPEN_PAREN <value_list> CLOSE_PAREN
//
//**********************************************************************
int CSQLParser::value_spec()
{
    int nRes;

    if ( m_nCurrentToken != QL_1_TOK_OPEN_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = value_list() )
    {
        return nRes;
    }

    if ( PCOMMAND(m_pSink)->m_AssignmentTokens.size() < 
         PCOMMAND(m_pSink)->nNumberOfProperties )
    {
        // too few values specified ... 
        return SYNTAX_ERROR;
    }

    if ( m_nCurrentToken != QL_1_TOK_CLOSE_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return SUCCESS;
}

//**********************************************************************
//
// <value_list> ::= <assign_expr> <value_list2>
//
//**********************************************************************
int CSQLParser::value_list()
{
    int nRes;

    if ( PCOMMAND(m_pSink)->m_AssignmentTokens.size() >= 
         PCOMMAND(m_pSink)->nNumberOfProperties )
    {
        // too many values specified ... 
        return SYNTAX_ERROR;
    }

    if ( nRes = assign_expr() )
    {
        return nRes;
    }
/*
    SetNewAssignmentToken();
    AddExpressionToken( SQLExpressionToken::e_Operand );
*/
    if ( nRes = value_list2() )
    {
        return nRes;
    }

    return SUCCESS;
}

//**********************************************************************
//
// <value_list2> ::= COMMA <value_list>
// <value_list2> ::= <>
//
//**********************************************************************
int CSQLParser::value_list2()
{
    if ( m_nCurrentToken != QL_1_TOK_COMMA )
    {
        return SUCCESS;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return value_list();
}

//**********************************************************************
//
// <assign_list> ::= <property_name> EQUALS <assign_expr> <assign_list2>
//
//**********************************************************************
int CSQLParser::assign_list()
{
    int nRes;

    if ( m_nCurrentToken == QL_1_TOK_ASTERISK )
    {
        return SYNTAX_ERROR;
    }

    if ( nRes = property_name() )
    {
        return nRes;
    }

    if ( m_nCurrentToken != QL_1_TOK_EQ )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = assign_expr() )
    {
        return nRes;
    }

    return assign_list2();
}

//**********************************************************************
//
// <assign_list2> ::= COMMA <assign_list>
// <assign_list2> ::= <>
//
//**********************************************************************
int CSQLParser::assign_list2()
{
    if ( m_nCurrentToken != QL_1_TOK_COMMA )
    {
        return SUCCESS;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return assign_list();
}

//**************************************************************************
//
// <assign_expr> ::= NULL
// <assign_expr> ::= <add_expr>
//
//***************************************************************************
int CSQLParser::assign_expr()
{
    int nRes;

    SetNewAssignmentToken();

    if ( m_nCurrentToken == QL_1_TOK_NULL )
    {
        if ( !Next() )
        {
            return LEXICAL_ERROR;
        }
        
        V_VT(&m_vTypedConst) = VT_NULL;
        AddExpressionToken( SQLExpressionToken::e_Operand );
    }
    else
    {
        if ( nRes = add_expr() )
        {
            return SYNTAX_ERROR;
        }
    }

    return SUCCESS;
}

//***************************************************************************
//
// <add_expr> ::= <mult_expr> <add_expr2>
//
//***************************************************************************
int CSQLParser::add_expr()
{
    int nRes;
    if ( nRes = mult_expr() )
    {
        return nRes;
    }

    return add_expr2();
}

//***************************************************************************
//
// <add_expr2> ::= <PLUS> <mult_expr> <add_expr2>
// <add_expr2> ::= <MINUS> <mult_expr> <add_expr2>
// <add_expr2> ::= <>
//
//***************************************************************************
int CSQLParser::add_expr2()
{
    int nRes;

    SQLExpressionToken::TokenType eTokType;

    if ( m_nCurrentToken == QL_1_TOK_PLUS )
    {
        eTokType = SQLExpressionToken::e_Plus;
    }
    else if ( m_nCurrentToken == QL_1_TOK_MINUS )
    {
        eTokType = SQLExpressionToken::e_Minus;
    }
    else
    {
        return SUCCESS;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = mult_expr() )
    {
        return SYNTAX_ERROR;
    }

    AddExpressionToken( eTokType );

    return add_expr2();
}


//***************************************************************************
//
// <mult_expr> ::= <secondary_expr> <mult_expr2>
//
//***************************************************************************
int CSQLParser::mult_expr()
{
    int nRes;
    if ( nRes = secondary_expr() )
    {
        return nRes;
    }

    return mult_expr2();
}


//***************************************************************************
//
// <mult_expr2> ::= <MULT> <secondary_expr> <mult_expr2>
// <mult_expr2> ::= <DIV> <secondary_expr> <mult_expr2>
// <mult_expr2> ::= <>
//
//***************************************************************************
int CSQLParser::mult_expr2()
{
    int nRes;
    SQLExpressionToken::TokenType eTokType;

    if ( m_nCurrentToken == QL_1_TOK_MULT )
    {
        eTokType = SQLExpressionToken::e_Mult;
    }
    else if ( m_nCurrentToken == QL_1_TOK_DIV )
    {
        eTokType = SQLExpressionToken::e_Div;
    }
    else if ( m_nCurrentToken == QL_1_TOK_MOD )
    {
        eTokType = SQLExpressionToken::e_Mod;
    }
    else
    {
        return SUCCESS;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = secondary_expr() )
    {
        return SYNTAX_ERROR;
    }

    AddExpressionToken( eTokType );
    return mult_expr2();
}
        
//***************************************************************************
//
//  <secondary_expr> ::= PLUS <primary_expr> 
//  <secondary_expr> ::= MINUS <primary_expr>
//  <secondary_expr> ::= <primary_expr> 
//
//***************************************************************************
int CSQLParser::secondary_expr()
{
    int nRes;

    SQLExpressionToken::TokenType eTokType;

    if ( m_nCurrentToken == QL_1_TOK_PLUS )
    {
        eTokType = SQLExpressionToken::e_UnaryPlus;
    }
    else if ( m_nCurrentToken == QL_1_TOK_MINUS )
    {
        eTokType = SQLExpressionToken::e_UnaryMinus;
    }
    else
    {
        return primary_expr();
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = primary_expr() )
    {
        return nRes;
    }

    AddExpressionToken( eTokType );

    return SUCCESS;
}

//***************************************************************************
//
//  <primary_expr> ::= <trailing_const_expr>
//  <primary_expr> ::= OPEN_PAREN <add_expr> CLOSE_PAREN
//
//***************************************************************************
int CSQLParser::primary_expr()
{
    int nRes;
    if ( m_nCurrentToken != QL_1_TOK_OPEN_PAREN )
    {
        if ( nRes = trailing_const_expr() )
        {
            return nRes;
        }

        AddExpressionToken( SQLExpressionToken::e_Operand );
        return SUCCESS;
    }

    if ( !Next() ) 
    {
        return LEXICAL_ERROR;
    }
    
    if ( nRes = add_expr() ) 
    {
        return nRes;
    }
    
    if ( m_nCurrentToken != QL_1_TOK_CLOSE_PAREN )
    {
        return SYNTAX_ERROR;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }
    
    return SUCCESS;
}


int CSQLParser::GetClassName( LPWSTR pDestBuf, int nBufLen )
{
    m_nCurrentToken = m_pLexer->NextToken();

    if (m_nCurrentToken != QL_1_TOK_IDENT)
    {
        m_pLexer->Reset();
        return FAILED;
    }

    if ( wbem_wcsicmp( m_pLexer->GetTokenText(), L"delete" ) == 0 )
    {
        m_nCurrentToken = m_pLexer->NextToken();
        
        if ( m_nCurrentToken == QL_1_TOK_IDENT &&
            wbem_wcsicmp( m_pLexer->GetTokenText(), L"from" ) == 0 )
        {
            m_nCurrentToken = m_pLexer->NextToken();
        }
    }
    else if ( wbem_wcsicmp( m_pLexer->GetTokenText(), L"insert" ) == 0 )
    {
        m_nCurrentToken = m_pLexer->NextToken();
        
        if ( m_nCurrentToken == QL_1_TOK_IDENT && 
            wbem_wcsicmp( m_pLexer->GetTokenText(), L"into" ) == 0 )
        {
            m_nCurrentToken = m_pLexer->NextToken();
        }
    }
    else if ( wbem_wcsicmp( m_pLexer->GetTokenText(), L"select" ) == 0 )
    {
        // scan until from ... 
        // Scan until 'FROM' and then get the class name.
        // ==============================================

        for (;;)
        {
            m_nCurrentToken = m_pLexer->NextToken();

            if (m_nCurrentToken == QL_1_TOK_EOF)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            if (m_nCurrentToken == QL_1_TOK_IDENT)
            {
                if (wbem_wcsicmp(m_pLexer->GetTokenText(),L"from") == 0 )
                {
                    break;
                }
            }
        }

        m_nCurrentToken = m_pLexer->NextToken();
    }
    else if ( wbem_wcsicmp( m_pLexer->GetTokenText(), L"update" ) == 0 )
    {
        m_nCurrentToken = m_pLexer->NextToken();
    }
    else 
    {
        m_pLexer->Reset();
        return FAILED;
    }

    if ( m_nCurrentToken != QL_1_TOK_IDENT )
    {
        m_pLexer->Reset();
        return FAILED;
    }

    // If here, we have the class name.
    // ================================
    if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen )
    {
        m_pLexer->Reset();
        return BUFFER_TOO_SMALL;
    }

    StringCchCopyW(pDestBuf, nBufLen, m_pLexer->GetTokenText());

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

CSQLParser::CSQLParser( CGenLexSource& rSrc )
: CAbstractQl1Parser( &rSrc ) 
{

} 

CSQLParser::~CSQLParser( )
{

}

int CSQLParser::Parse( SQLCommand& rCommand )
{
    m_pSink = &rCommand;

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return parse2();
}

LPWSTR _GetText( SQLAssignmentToken& rToken )
{
    WString wsText;

    for( int i=0; i < rToken.size(); i++ )
    {
        SQLExpressionToken& rExprTok = rToken[i];
        LPWSTR wszTokenText = rExprTok.GetText();
        if ( wszTokenText == NULL )
            return NULL;
        wsText += wszTokenText;
        delete wszTokenText;
    }

    return wsText.UnbindPtr();
}

LPWSTR SQLCommand::GetTextEx()
{
    WString wsText;
    
    switch ( m_eCommandType )
    {
      case e_Select :
        {
            wsText += L"select ";
            if ( nNumberOfProperties > 0 )
            {
                for(int i = 0; i < nNumberOfProperties; i++)
                {
                    if(i != 0) wsText += L", ";
                    wsText+=(LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
                }
            }
            else   
            {
                wsText += L"*";
            }

            wsText += L" from ";
            wsText += bsClassName;
        }
        break;

      case e_Update :
        {
            wsText += L"update ";
            wsText += bsClassName;
            wsText += L" set ";
            
            for(int i = 0; i < nNumberOfProperties; i++)
            {
                if ( i != 0 ) wsText += L", ";
                LPWSTR wszPropName = pRequestedPropertyNames[i].GetText();
                if ( wszPropName == NULL ) 
                    return NULL;
                wsText += wszPropName;
                delete wszPropName;

                wsText += " = ";
                
                LPWSTR wszPropVal = _GetText(m_AssignmentTokens[i]);
                if ( wszPropVal == NULL )
                    return NULL;
                wsText += wszPropVal;
                delete wszPropVal;
            }
        }
        break;

      case e_Delete :
        {
            wsText += L"delete ";
            wsText += bsClassName;
        }
        break;

      case e_Insert :
        {
            wsText += L"insert ";
            wsText += bsClassName;
            wsText += L" ( ";
            
            for(int i = 0; i < nNumberOfProperties; i++)
            {
                if ( i != 0 ) wsText += L", ";
                LPWSTR wszPropName = pRequestedPropertyNames[i].GetText();
                if ( wszPropName == NULL )
                    return NULL;
                wsText += wszPropName;
                delete wszPropName;
            }

            wsText += L" ) ( ";

            for ( i=0; i < nNumberOfProperties; i++ )
            {
                if ( i != 0 ) wsText += ", ";
                LPWSTR wszPropVal = m_AssignmentTokens[i][0].GetText();
                if ( wszPropVal == NULL )
                    return NULL;
                wsText += wszPropVal;
                delete wszPropVal;
            }

            wsText += L" )";
        }
        break;
    };

    if ( nNumTokens > 0 )
    {
        wsText += L" where ";

        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if ( wszTokenText == NULL )
                return NULL;
            wsText += wszTokenText;
            delete wszTokenText;
/*
            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }

*/
        }

//        if(awsStack.Size() != 1) return NULL;
//        wsText += awsStack[0];
    }
         
    return wsText.UnbindPtr();
}

LPWSTR SQLExpressionToken::GetText()
{
    WString wsText;
    switch( m_eTokenType )
    {
    case SQLExpressionToken::e_Operand :
        {
            if ( V_VT(&m_vValue) == VT_EMPTY )
            {
                LPWSTR wszAlias = m_PropName.GetText();
                if ( wszAlias == NULL )
                    return NULL;
                wsText += wszAlias;
                delete wszAlias;
                return wsText.UnbindPtr();
            }

            if ( V_VT(&m_vValue) == VT_NULL )
            {
                wsText += L"NULL";
                return wsText.UnbindPtr();
            }
            
            VARIANT var;
            VariantInit( &var );

            if ( FAILED(VariantChangeType( &var, &m_vValue, NULL, VT_BSTR )) )
            {
                throw CX_MemoryException();
            }

            wsText += V_BSTR(&var);
            VariantClear( &var );
        }
        break;
        
    case SQLExpressionToken::e_Minus :
        wsText += L" - ";
        break;
        
    case SQLExpressionToken::e_Plus :
        wsText += L" + ";
        break;
        
    case SQLExpressionToken::e_UnaryMinus :
        wsText += L"|-|";
        break;
        
    case SQLExpressionToken::e_UnaryPlus :
        wsText += L"+";
        break;
        
    case SQLExpressionToken::e_Mult :
        wsText += L" * ";
        break;
        
    case SQLExpressionToken::e_Div :
        wsText += L" / ";
        break;
        
    case SQLExpressionToken::e_Mod :
        wsText += L" % ";
        break;
    };

    return wsText.UnbindPtr();
}

SQLExpressionToken::SQLExpressionToken() : m_ulCimType( CIM_EMPTY )
{
    VariantInit( &m_vValue );
}

SQLExpressionToken::~SQLExpressionToken()
{
    VariantClear( &m_vValue );
}
SQLExpressionToken::SQLExpressionToken( const SQLExpressionToken& rOther )
{
    VariantInit( &m_vValue );
    *this = rOther;
}
SQLExpressionToken& SQLExpressionToken::operator=( const SQLExpressionToken& rOther )
{
    m_ulCimType = rOther.m_ulCimType;
    m_eTokenType = rOther.m_eTokenType;
    m_PropName = rOther.m_PropName;
    
    if ( FAILED(VariantCopy( &m_vValue, (VARIANT*)&rOther.m_vValue )))
    {
        throw CX_MemoryException();
    }
    
    return *this;
}


#define ST_STRING       26
#define ST_IDENT        31
#define ST_GE           37
#define ST_LE           39
#define ST_NE           42
#define ST_NUMERIC      44
#define ST_REAL         49
#define ST_STRING2      55
#define ST_STRING_ESC   60
#define ST_STRING2_ESC  63   
#define ST_DOT          66
#define ST_NEGATIVE_NUM 68
#define ST_POSITIVE_NUM 71

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_ModifiedLexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,    0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,          QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,     0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,          QL_1_TOK_MULT,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,          QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',  GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, 0,      QL_1_TOK_MINUS,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,    GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA,  GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, 0,  QL_1_TOK_PLUS,   GLEX_ACCEPT,

/* 23 */ L'/',   GLEX_EMPTY, 0,     QL_1_TOK_DIV,               GLEX_ACCEPT,
/* 24 */ L'%',   GLEX_EMPTY, 0,     QL_1_TOK_MOD,               GLEX_ACCEPT,

    // Unknown characters

/* 25 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 26 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 27 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 29 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 31 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 37 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 39 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 40 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 42 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 43 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 44 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 45 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 46 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 47 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 48 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 49 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 50 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 53 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 54 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 55 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 56 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 57 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 58 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 59 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 60 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 61 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 62 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 63 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 64 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 65 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 66 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 67 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 68 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 69 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 70 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 71 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 72 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 73 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updstat.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include "updstat.h"

static GUID g_guidNull = {0,0,0,{0,0,0,0,0,0,0,0}};

LPCWSTR g_wszCmdIndex = L"CommandIndex";
LPCWSTR g_wszErrStr = L"ErrorStr";
LPCWSTR g_wszConsumer = L"Consumer";
LPCWSTR g_wszResult = L"StatusCode";
LPCWSTR g_wszGuid = L"ExecutionId";
LPCWSTR g_wszData = L"Data";
LPCWSTR g_wszEvent = L"Event";
LPCWSTR g_wszInstance = L"Inst";
LPCWSTR g_wszOriginalInstance = L"OriginalInst";

CUpdConsState::CUpdConsState( const CUpdConsState& rOther )
: m_pCmd(NULL), m_bOwnCmd(FALSE)
{
    *this = rOther;
}

HRESULT CUpdConsState::SetEvent( IWbemClassObject* pEvent )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pEvent = pEvent;

    if ( m_pEventAccess != NULL )
    {
        hr = m_pEventAccess->SetObject( m_pEvent );
    }

    return hr;
}

HRESULT CUpdConsState::SetEventAccess( IWmiObjectAccess* pEventAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pEventAccess = pEventAccess;

    if ( m_pEventAccess != NULL )
    {
        hr = m_pEventAccess->SetObject( m_pEvent );
    }

    return hr;
}

HRESULT CUpdConsState::SetData( IWbemClassObject* pData )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pData = pData;

    if ( m_pDataAccess != NULL )
    {
        hr = m_pDataAccess->SetObject( m_pData );
    }

    return hr;
}

HRESULT CUpdConsState::SetDataAccess( IWmiObjectAccess* pDataAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pDataAccess = pDataAccess;

    if ( m_pDataAccess != NULL )
    {
        hr = m_pDataAccess->SetObject( m_pData );
    }

    return hr;
}

HRESULT CUpdConsState::SetInst( IWbemClassObject* pInst )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pInst = pInst;

    if ( m_pInstAccess != NULL )
    {
        hr = m_pInstAccess->SetObject( m_pInst );
    }

    return hr;
}

HRESULT CUpdConsState::SetInstAccess( IWmiObjectAccess* pInstAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pInstAccess = pInstAccess;

    if ( m_pInstAccess != NULL )
    {
        hr = m_pInstAccess->SetObject( m_pInst );
    }

    return hr;
}

HRESULT CUpdConsState::SetOrigInst( IWbemClassObject* pOrigInst )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pOrigInst = pOrigInst;

    if ( m_pOrigInstAccess != NULL )
    {
        hr = m_pOrigInstAccess->SetObject( m_pOrigInst );
    }

    return hr;
}

HRESULT CUpdConsState::SetOrigInstAccess( IWmiObjectAccess* pOrigInstAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pOrigInstAccess = pOrigInstAccess;

    if ( m_pOrigInstAccess != NULL )
    {
        hr = m_pOrigInstAccess->SetObject( m_pOrigInst );
    }

    return hr;
}

CUpdConsState& CUpdConsState::operator= ( const CUpdConsState& rOther )
{
    m_iCommand = rOther.m_iCommand;
    m_guidExec = rOther.m_guidExec;
    m_bsErrStr = rOther.m_bsErrStr;
    m_pCons = rOther.m_pCons;
    
    m_pEvent = rOther.m_pEvent;
    m_pData = rOther.m_pData;
    m_pInst = rOther.m_pInst;
    m_pOrigInst = rOther.m_pOrigInst;
   
    m_pEventAccess = rOther.m_pEventAccess;
    m_pDataAccess = rOther.m_pDataAccess;
    m_pInstAccess = rOther.m_pInstAccess;
    m_pOrigInstAccess = rOther.m_pOrigInstAccess;
    
    if ( m_bOwnCmd )
    {
        delete m_pCmd;
    }

    m_pCmd = new SQLCommand( *rOther.m_pCmd );

    if ( m_pCmd == NULL )
    {
        throw CX_MemoryException();
    }

    m_pNext = rOther.m_pNext;

    return *this;
}

CUpdConsState::CUpdConsState() 
: m_iCommand(-1), m_pCmd(NULL), m_bOwnCmd(FALSE)
{
    memset( &m_guidExec, 0, sizeof(GUID) );
}

//
// TODO: Could optimize this to use Property handles instead of strings.
// but since we're tracing anyways - does it matter ?
// 

HRESULT CUpdConsState::SetStateOnTraceObject( IWbemClassObject* pObj,
                                                HRESULT hrStatus )
{
    HRESULT hr;
    VARIANT var;

    //
    // consumer object
    //

    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = m_pCons;

    hr = pObj->Put( g_wszConsumer, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // execution id.  may be null if we failed when initializing cons
    //

    if ( g_guidNull != m_guidExec )
    {
        WCHAR achBuff[256];
        int cch = StringFromGUID2( m_guidExec, achBuff, 256 );
        _DBG_ASSERT( cch > 0 );
        
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = achBuff;
    
        hr = pObj->Put( g_wszGuid, 0, &var, NULL );
    
        if ( FAILED(hr) )
        {
            return hr;
        }
    }   

    //
    // error string. only use it when status specifies failure.
    // 

    if ( (!(!m_bsErrStr)) && FAILED(hrStatus) )
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = m_bsErrStr;
        
        hr = pObj->Put( g_wszErrStr, 0, &var, NULL );
   
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // command index - zero based.  will be -1 if trace event isn't 
    // specific to a particular command ( e.g overall success )
    //

    if ( m_iCommand != -1 )
    {
        V_VT(&var) = VT_I4;
        V_I4(&var) = m_iCommand;
        
        hr = pObj->Put( g_wszCmdIndex, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Status Code
    //

    V_VT(&var) = VT_I4;
    V_I4(&var) = hrStatus;

    hr = pObj->Put( g_wszResult, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // the event that triggered the updating consumer.
    // 

    if ( m_pEvent != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pEvent;
        
        hr = pObj->Put( g_wszEvent, 0, &var, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // we've set all the base properties.  now try to set the command 
    // trace and instance event properties.  This may fail depending on
    // the type of event class.  
    //

    if ( m_pData != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pData;        
        hr = pObj->Put( g_wszData, 0, &var, NULL );
    }  

    if ( m_pInst != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pInst;
        hr = pObj->Put( g_wszInstance, 0, &var, NULL );
    }  

    if ( m_pOrigInst != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pOrigInst;        
        hr = pObj->Put( g_wszOriginalInstance, 0, &var, NULL );
    }  

    return WBEM_S_NO_ERROR;
}


STDMETHODIMP CUpdConsState::Indicate( long cObjs, IWbemClassObject** ppObjs )
{
    HRESULT hr;

    if ( m_pNext == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    for( long i=0; i < cObjs; i++ )
    {
        hr = SetInst( ppObjs[i] );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = m_pNext->Execute( *this );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CUpdConsState::SetStatus( long, HRESULT, BSTR, IWbemClassObject* )
{
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updstat.h ===
#ifndef __UPDSTAT_H__
#define __UPDSTAT_H__

#include <wbemcli.h>
#include <comutl.h>
#include <wmimsg.h>
#include <updsql.h>
#include <updsink.h>

/**************************************************************************
  CUpdConsState - contains all of the mutable state for execution of 
  an Updating Consumer command.  This object is passed through the sink
  chain.

  The state object can be used as an wbem object sink.  The reason for this
  is that if we had to we could support asynchronous execution of a 
  sink chain we could do so without having to allocate a new sink object
  on the heap.  This sink object would have to be allocated on the fly
  because it would need to contain the state object since it would need
  it to continue the execution of the sink chain and there is no way
  to pass the state object through the wbem interfaces.  We get around 
  this by making the state object implement IWbemObjectSink and simply
  delegating calls to the next sink in the chain.

***************************************************************************/

class CUpdConsState : public CUnkBase<IWbemObjectSink,&IID_IWbemObjectSink>
{
    //
    // an execution id generated each time the Updating Consumer executes.
    // 
    GUID m_guidExec;
    
    //
    // this is used for tracing to tell us which command is being executed
    // by the Updating Consumer. It is zero based.
    //
    int m_iCommand;
    
    //
    // Contains extra information when we wncounter errors during execution.  
    // 
    CWbemBSTR m_bsErrStr;
    
    //
    // the consumer object that the command corresponds to.  Is only 
    // used for tracing.
    // 
    CWbemPtr<IWbemClassObject> m_pCons;

    //
    // the data object used for resolving aliases in the command. 
    //
    CWbemPtr<IWbemClassObject> m_pData;
    
    //
    // the event responsible for the execution of the command.  Is used for
    // resolving aliases in the command
    //
    CWbemPtr<IWbemClassObject> m_pEvent;

    //
    // the current instance.  Always contains the most recent change
    // when used by assignment sink. 
    //
    CWbemPtr<IWbemClassObject> m_pInst;

    //
    // the original instance. This is the instance before any
    // modifications were performed on it.
    // 
    CWbemPtr<IWbemClassObject> m_pOrigInst;

    //
    // efficient object accessors for data, event, and inst objects.
    // 
    CWbemPtr<IWmiObjectAccess> m_pEventAccess;
    CWbemPtr<IWmiObjectAccess> m_pDataAccess;
    CWbemPtr<IWmiObjectAccess> m_pInstAccess;
    CWbemPtr<IWmiObjectAccess> m_pOrigInstAccess;
    
    //
    // the parsed uql query.  It is updated as we resolve aliases.
    //

    BOOL m_bOwnCmd;
    SQLCommand* m_pCmd;
    
    //
    // Only used when the State object is used as a sink.  Each time 
    // Indicate() is called on the State object, Execute() will be called 
    // on the next sink.
    //
    CWbemPtr<CUpdConsSink> m_pNext;

public:

    CUpdConsState();
    CUpdConsState( const CUpdConsState& );
    CUpdConsState& operator= ( const CUpdConsState& );
 
    GUID& GetExecutionId() { return m_guidExec; }
    void SetExecutionId( GUID& rguidExec ) { m_guidExec = rguidExec; }

    int GetCommandIndex() { return m_iCommand; }
    void SetCommandIndex( int iCommand ) { m_iCommand = iCommand; }

    BSTR GetErrStr() { return m_bsErrStr; }
    void SetErrStr( LPCWSTR wszErrStr ) { m_bsErrStr = wszErrStr; }

    IWbemClassObject* GetCons() { return m_pCons; }
    void SetCons( IWbemClassObject* pCons ) { m_pCons = pCons; }

    IWbemClassObject* GetEvent() { return m_pEvent; }
    HRESULT SetEvent( IWbemClassObject* pEvent );

    IWbemClassObject* GetData() { return m_pData; }
    HRESULT SetData( IWbemClassObject* pData );

    IWbemClassObject* GetInst() { return m_pInst; }
    HRESULT SetInst( IWbemClassObject* pInst );

    IWbemClassObject* GetOrigInst() { return m_pOrigInst; }
    HRESULT SetOrigInst( IWbemClassObject* pOrigInst );

    IWmiObjectAccess* GetEventAccess() { return m_pEventAccess; }
    HRESULT SetEventAccess( IWmiObjectAccess* pEventAccess ); 

    IWmiObjectAccess* GetDataAccess() { return m_pDataAccess; }
    HRESULT SetDataAccess( IWmiObjectAccess* pDataAccess ); 

    IWmiObjectAccess* GetInstAccess() { return m_pInstAccess; }
    HRESULT SetInstAccess( IWmiObjectAccess* pInstAccess ); 

    IWmiObjectAccess* GetOrigInstAccess() { return m_pOrigInstAccess; }
    HRESULT SetOrigInstAccess( IWmiObjectAccess* pOrigInstAccess ); 

    CUpdConsSink* GetNext() { return m_pNext; }
    void SetNext( CUpdConsSink* pSink ) { m_pNext = pSink; }
    
    SQLCommand* GetSqlCmd() { return m_pCmd; }

    void SetSqlCmd( SQLCommand* pCmd, BOOL bAssumeOwnership )
    {
        if ( m_bOwnCmd )
        {
            delete m_pCmd;
        }
        m_pCmd = pCmd;
        m_bOwnCmd = bAssumeOwnership;
    }

    STDMETHOD(Indicate)( long cObjs, IWbemClassObject** ppObjs );
    STDMETHOD(SetStatus)( long, HRESULT, BSTR, IWbemClassObject* );
 
    HRESULT SetStateOnTraceObject( IWbemClassObject* pTraceObj, HRESULT hr );
};

#endif __UPDSTAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconnspc.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include "fconnspc.h"

LPCWSTR g_wszConsumer = L"Consumer";
LPWSTR g_wszTarget = L"Target";
LPWSTR g_wszQueued = L"Queued";
LPWSTR g_wszTargetUsed = L"TargetUsed";
LPCWSTR g_wszStatusCode = L"StatusCode";
LPCWSTR g_wszExecutionId = L"ExecutionId";
LPWSTR g_wszTraceClass = L"MSFT_FCExecutedTraceEvent";
LPWSTR g_wszTargetTraceClass = L"MSFT_FCTargetTraceEvent";
LPWSTR g_wszEvents = L"Events";
LPCWSTR g_wszTraceProvider
 = L"Microsoft WMI Forwarding Consumer Trace Event Provider";

LPCWSTR g_wszTraceSuccessQuery = 
 L"SELECT * FROM MSFT_FCTraceEventBase WHERE StatusCode <= 1"; 

LPCWSTR g_wszTraceFailureQuery = 
 L"SELECT * FROM MSFT_FCTraceEventBase WHERE StatusCode > 1";

/**************************************************************************
  CFwdConsQuerySink - this implements the ProviderQuerySink.  This would 
  normally be implemented by CFwdConsNamespace, but we'd end up with a 
  circular reference on the DES.
****************************************************************************/
class CFwdConsQuerySink 
: public CUnkBase<IWbemEventProviderQuerySink,&IID_IWbemEventProviderQuerySink>
{
    CFwdConsNamespace* m_pNspc; // doesn't hold ref.

public:
    
    STDMETHOD(NewQuery)( DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery )
    {
        return m_pNspc->NewQuery( dwId, wszQuery );
    }
        
    STDMETHOD(CancelQuery)( DWORD dwId )
    {
        return m_pNspc->CancelQuery( dwId );
    }

    CFwdConsQuerySink( CFwdConsNamespace* pNspc ) 
    : CUnkBase< IWbemEventProviderQuerySink,
                &IID_IWbemEventProviderQuerySink>(NULL), m_pNspc( pNspc ) {} 
public:

    static HRESULT Create( CFwdConsNamespace* pNspc, 
                           IWbemEventProviderQuerySink** ppSink )
    {
        CWbemPtr<IWbemEventProviderQuerySink> pSink;

        pSink = new CFwdConsQuerySink( pNspc );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink->AddRef();
        *ppSink = pSink;

        return WBEM_S_NO_ERROR;
    }
};

CFwdConsNamespace::~CFwdConsNamespace()
{
    if ( m_pDES != NULL )
    {
        m_pDES->UnRegister();
    }
}

HRESULT CFwdConsNamespace::InitializeTraceEventBase( IWbemClassObject* pTrace, 
                                                     HRESULT hres,
                                                     CFwdContext* pCtx )
{
    HRESULT hr;
    VARIANT var;
    
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pCtx->m_pCons;

    hr = pTrace->Put( g_wszConsumer, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    WCHAR achExecutionId[64];
    
    if ( StringFromGUID2( pCtx->m_guidExecution, achExecutionId, 64 ) == 0 )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = achExecutionId;

    hr = pTrace->Put( g_wszExecutionId, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    V_VT(&var) = VT_I4;
    V_I4(&var) = hres;
    
    return pTrace->Put( g_wszStatusCode, 0, &var, NULL );
}    

//
// called after each execution of a forwarding consumer.
//

HRESULT CFwdConsNamespace::HandleTrace( HRESULT hres, CFwdContext* pCtx )
{
    HRESULT hr;

    CWbemPtr<IWbemEventSink> pTraceSink;

    if ( SUCCEEDED(hres) )
    {
        if ( m_pTraceSuccessSink->IsActive() == WBEM_S_FALSE )
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pTraceSink = m_pTraceSuccessSink;
        }
    }
    else if ( m_pTraceFailureSink->IsActive() == WBEM_S_FALSE )
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        pTraceSink = m_pTraceFailureSink;
    }
            
    CWbemPtr<IWbemClassObject> pTrace;

    hr = m_pTraceClass->SpawnInstance( 0, &pTrace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = InitializeTraceEventBase( pTrace, hres, pCtx );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // set the events that were indicated in the trace event 
    // 

    VARIANT var;
    V_VT(&var) = VT_ARRAY | VT_UNKNOWN;
    V_ARRAY(&var) = SafeArrayCreateVector( VT_UNKNOWN, 0, pCtx->m_cEvents );
    
    if ( V_ARRAY(&var) == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CPropSafeArray<IUnknown*> apEvents(V_ARRAY(&var));

        for( ULONG i=0; i < pCtx->m_cEvents; i++ )
        {
            apEvents[i] = pCtx->m_apEvents[i];
            apEvents[i]->AddRef();
        }    
    }
     
    hr = pTrace->Put( g_wszEvents, 0, &var, NULL );

    VariantClear( &var );

    if ( FAILED(hr) )
    {
        return hr;
    }
        
    //
    // don't set other props on failure.
    //

    if ( FAILED(hres) )
    {
        return pTraceSink->Indicate( 1, &pTrace );
    }

    //
    // it is possible that there may be not target.
    //

    if ( pCtx->m_wsTarget.Length() > 0 )
    {
        LPWSTR wszTarget = pCtx->m_wsTarget;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = wszTarget;
    
        hr = pTrace->Put( g_wszTargetUsed, 0, &var, NULL );
    
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = pCtx->m_bQueued ? VARIANT_TRUE : VARIANT_FALSE;

    hr = pTrace->Put( g_wszQueued, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pTraceSink->Indicate( 1, &pTrace );
}

//
// This is called by Senders when their SendReceive() method is called for
// both error and success states.  In both cases the wszTrace string will 
// be the name of the sender.  Senders, such as the multisender or fwdsender
// can call the sink multiple times since they can represent multiple 
// connections.  Since all Senders initialize themselves lazily, we don't
// have to worry about generating trace events when Open() calls fail.
// 
STDMETHODIMP CFwdConsNamespace::Notify( HRESULT hres, 
                                        GUID guidSource,
                                        LPCWSTR wszTrace, 
                                        IUnknown* pContext )
{
    HRESULT hr;

    //
    // since we are the ones who created the context, we can safely cast.
    //

    CFwdContext* pCtx = (CFwdContext*)pContext;
    
    if ( SUCCEEDED(hres) )
    {
        //
        // save any state with the context about the successful send.
        //

        if ( guidSource == CLSID_WmiMessageMsmqSender )
        {
            pCtx->m_bQueued = TRUE;
        }

        pCtx->m_wsTarget = wszTrace;
    }

    CWbemPtr<IWbemEventSink> pTraceSink;

    if ( SUCCEEDED(hres) )
    {
        if ( m_pTraceSuccessSink->IsActive() == WBEM_S_FALSE )
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pTraceSink = m_pTraceSuccessSink;
        }
    }
    else if ( m_pTraceFailureSink->IsActive() == WBEM_S_FALSE )
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        pTraceSink = m_pTraceFailureSink;
    }

    CWbemPtr<IWbemClassObject> pTrace;

    hr = m_pTargetTraceClass->SpawnInstance( 0, &pTrace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = InitializeTraceEventBase( pTrace, hres, pCtx );

    if ( FAILED(hr) )
    {
        return hr;
    }

    LPWSTR wszTmp = LPWSTR(wszTrace);
 
    VARIANT var;
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = wszTmp;
    
    hr = pTrace->Put( g_wszTarget, 0, &var, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pTraceSink->Indicate( 1, &pTrace );
}

HRESULT CFwdConsNamespace::Initialize( LPCWSTR wszNamespace )
{
    HRESULT hr;

    m_wsName = wszNamespace;

    //
    // register our decoupled event provider 
    //

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Register( 0,
                         NULL,
                         NULL,
                         NULL,
                         wszNamespace,
                         g_wszTraceProvider,
                         NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the service pointer for out namespace
    //

    hr = m_pDES->GetService( 0, NULL, &m_pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the decoupled event sink
    //

    CWbemPtr<IWbemObjectSink> pTraceObjectSink;

    hr = m_pDES->GetSink( 0, NULL, &pTraceObjectSink );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemEventSink> pTraceEventSink;

    hr = pTraceObjectSink->QueryInterface( IID_IWbemEventSink, 
                                           (void**)&pTraceEventSink);

    if ( FAILED(hr) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // get restricted query for successes.
    //
    
    hr = pTraceEventSink->GetRestrictedSink( 1, 
                                             &g_wszTraceSuccessQuery,
                                             NULL, 
                                             &m_pTraceSuccessSink );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get restricted query for failures.
    //
    
    hr = pTraceEventSink->GetRestrictedSink( 1, 
                                             &g_wszTraceFailureQuery,
                                             NULL, 
                                             &m_pTraceFailureSink );
    if ( FAILED(hr) ) 
    {
        return hr;
    }

    //
    // more trace initialization
    //

    hr = m_pSvc->GetObject( g_wszTraceClass, 0, NULL, &m_pTraceClass, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( g_wszTargetTraceClass, 
                            0, 
                            NULL,
                            &m_pTargetTraceClass, 
                            NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconprov.h ===
#ifndef __FCONPROV_H__
#define __FCONPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>

/*************************************************************************
  CFwdConsProv
**************************************************************************/

class CFwdConsProv 
: public CUnkBase<IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider>
{
public:

    CFwdConsProv( CLifeControl* pCtl )
     : CUnkBase< IWbemEventConsumerProvider,
                 &IID_IWbemEventConsumerProvider>( pCtl ) {} 

    STDMETHOD(FindConsumer)( IWbemClassObject* pLogicalConsumer,
                             IWbemUnboundObjectSink** ppConsumer );

    static HRESULT InitializeModule();
    static void UninitializeModule();
};

#endif // __FCONPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconprov.cpp ===
#include "precomp.h"
#include <assert.h>
#include <sync.h>
#include <arrtempl.h>
#include <wstring.h>
#include <comutl.h>
#include <statsync.h>
#include <map>
#include <wstlallc.h>
#include "fconprov.h"
#include "fconnspc.h"
#include "fconsink.h"

LPCWSTR g_wszNamespace = L"__NAMESPACE";
LPCWSTR g_wszClass = L"__CLASS";
LPCWSTR g_wszEventFwdCons = L"MSFT_EventForwardingConsumer";
LPCWSTR g_wszDataFwdCons = L"MSFT_DataForwardingConsumer";

static CStaticCritSec g_cs;
typedef CWbemPtr<CFwdConsNamespace> CFwdConsNamespaceP;
typedef std::map<WString,CFwdConsNamespaceP,WSiless,wbem_allocator<CFwdConsNamespaceP> > NamespaceMap; 
NamespaceMap* g_pNamespaces;
 
HRESULT CFwdConsProv::InitializeModule()
{
    g_pNamespaces = new NamespaceMap;
    
    if ( g_pNamespaces == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

void CFwdConsProv::UninitializeModule()
{
    delete g_pNamespaces;
}

HRESULT CFwdConsProv::FindConsumer( IWbemClassObject* pCons,
                                    IWbemUnboundObjectSink** ppSink )
{
    ENTER_API_CALL

    HRESULT hr;

    //
    // workaround for bogus context object left on thread by wmi.
    // just remove it. shouldn't leak because this call doesn't addref it.
    //
    IUnknown* pCtx;
    CoSwitchCallContext( NULL, &pCtx ); 

    //
    // first obtain the namespace object. we derive the namespace from 
    // the consumer object.  If no namespace obj is there, create one.
    //

    CPropVar vNamespace;

    hr = pCons->Get( g_wszNamespace, 0, &vNamespace, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vNamespace.SetType(VT_BSTR)) )
    {
        return hr;
    }

    CInCritSec ics( &g_cs );

    CWbemPtr<CFwdConsNamespace> pNspc = (*g_pNamespaces)[V_BSTR(&vNamespace)];

    if ( pNspc == NULL )
    {
        pNspc = new CFwdConsNamespace;

        if ( pNspc == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = pNspc->Initialize( V_BSTR(&vNamespace) );

        if ( FAILED(hr) )
        {
            return hr;
        }

        (*g_pNamespaces)[V_BSTR(&vNamespace)] = pNspc;
    }

    return CFwdConsSink::Create( m_pControl, pNspc, pCons, ppSink );

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconnspc.h ===
#ifndef __FCONNSPC_H__
#define __FCONNSPC_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <unk.h>
#include <wmimsg.h>
#include <wstring.h>

/*****************************************************************************
  CFwdContext - we use this context object to thread information through 
  the senders.
****************************************************************************/ 

struct CFwdContext : public CUnk
{
    //
    // is true when a successful send has been performed by an msmq sender.
    //
    BOOL m_bQueued; 
     
    //
    // contains the name of the sender that performed a successful send.
    // is empty if no senders succeed.
    //
    WString m_wsTarget;

    //
    // contains the events that are indicated to the consumer.  Used for 
    // tracing.
    //
    ULONG m_cEvents;
    IWbemClassObject** m_apEvents;
    
    //
    // for each execution of a fwding consumer a new guid is created. this
    // allows us to correlate target trace events with a given execution.
    //
    GUID m_guidExecution;

    CWbemPtr<IWbemClassObject> m_pCons;

    CFwdContext( GUID& guidExecution, 
                 IWbemClassObject* pCons,
                 ULONG cEvents,
                 IWbemClassObject** apEvents ) 
     : m_guidExecution( guidExecution ), m_pCons(pCons), 
       m_bQueued(FALSE), m_cEvents(cEvents), m_apEvents(apEvents) {}
 
    void* GetInterface( REFIID riid ) { return NULL; }
};

/*************************************************************************
  CFwdConsNamespace
**************************************************************************/
 
class CFwdConsNamespace 
: public CUnkBase<IWmiMessageTraceSink,&IID_IWmiMessageTraceSink>
{
    CWbemPtr<IWbemDecoupledBasicEventProvider> m_pDES;
    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemEventSink> m_pTraceSuccessSink;
    CWbemPtr<IWbemEventSink> m_pTraceFailureSink;
    CWbemPtr<IWbemClassObject> m_pTargetTraceClass;
    CWbemPtr<IWbemClassObject> m_pTraceClass;
    WString m_wsName;
    long m_lTrace;

    ~CFwdConsNamespace();

    HRESULT InitializeTraceEventBase( IWbemClassObject* pTrace,
                                      HRESULT hres,
                                      CFwdContext* pCtx );
public:

    HRESULT Initialize( LPCWSTR wszNamespace );
  
    IWbemServices* GetSvc() { return m_pSvc; } 
    LPCWSTR GetName() { return m_wsName; } 

    CFwdConsNamespace() 
    : CUnkBase<IWmiMessageTraceSink,&IID_IWmiMessageTraceSink>(NULL), 
      m_lTrace(0) {}

    void* GetInterface( REFIID riid );

    HRESULT NewQuery( DWORD dwId, LPWSTR wszQuery ) 
    { 
        InterlockedIncrement(&m_lTrace);
        return WBEM_S_NO_ERROR;
    }

    HRESULT CancelQuery( DWORD dwId )
    {
        InterlockedDecrement( &m_lTrace );
        return WBEM_S_NO_ERROR;
    }

    HRESULT HandleTrace( HRESULT hres, CFwdContext* pCtx );

    STDMETHOD(Notify)( HRESULT hRes,
                       GUID guidSource,
                       LPCWSTR wszTrace,
                       IUnknown* pContext );
};

#endif // __FCONNSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsend.h ===
#ifndef __FCONSEND_H__
#define __FCONSEND_H__

#include <sync.h>
#include <unk.h>
#include <wbemcli.h>
#include <comutl.h>
#include <wstring.h>
#include "wmimsg.h"

/*********************************************************************
  CFwdConsSend - fwdcons senders handle issues with resolving logical 
  target names and also setting up alternate destinations - for 
  example, when sending using async qos, the it will try to use a 
  dcom sender and then resort to an msmq sender.
**********************************************************************/

class CFwdConsSend 
: public CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>
{
    CCritSec m_cs;
    WString m_wsTarget;
    DWORD m_dwFlags;
    BOOL m_bResolved;
    CWbemPtr<IWbemServices> m_pDefaultSvc;
    CWbemPtr<IWmiMessageMultiSendReceive> m_pMultiSend;
    CWbemPtr<IWmiMessageTraceSink> m_pTraceSink;

    CFwdConsSend( CLifeControl* pCtl ) 
     : CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>(pCtl), 
       m_bResolved(FALSE) { }

    void DeriveQueueLogicalName( WString& rwsPathName, BOOL bAuth );
    HRESULT HandleTrace( HRESULT hr, IUnknown* pCtx );
    HRESULT AddAsyncSender( LPCWSTR wszMachine );
    HRESULT AddPhysicalSender( LPCWSTR wszMachine );
    HRESULT AddMSMQSender( LPCWSTR wszFormatName );
    HRESULT AddSyncSender( LPCWSTR wszMachine );
    HRESULT AddLogicalSender( LPCWSTR wszTarget );
    HRESULT AddLogicalSender( LPCWSTR wszObjPath, LPCWSTR wszProp );
    HRESULT EnsureSender();

public:
    
    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pCtx );

    static HRESULT Create( CLifeControl* pCtl,
                           LPCWSTR wszTarget,
                           DWORD dwFlags,                    
                           IWbemServices* pDefaultSvc,
                           IWmiMessageTraceSink* pTraceSink,
                           IWmiMessageSendReceive** ppSend );
};

#endif // __FCONSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsend.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <arrtempl.h>
#include <wmimsg.h>
#include <ntdsapi.h>
#include "fconsend.h"

// flags below 0x10000 are reserved for msg implementations.

#define FWD_FLAG_NO_INDIRECT 0x00010000

// {DDE18466-D244-4a5b-B91F-93D17E13178D}
static const GUID g_guidQueueType = 
{0xdde18466, 0xd244, 0x4a5b, {0xb9, 0x1f, 0x93, 0xd1, 0x7e, 0x13, 0x17, 0x8d}};

HRESULT IsTcpIpAddress( LPCWSTR wszTarget )
{
    HRESULT hr;
    WSADATA wsaData; 
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD( 2, 2 );
 
    int err = WSAStartup( wVersionRequested, &wsaData );

    if ( err == 0 ) 
    {
        IN_ADDR ia;

        //
        // convert unicode addr to ansi .. 
        // 

        int cTarget = wcstombs( NULL, wszTarget, 0 );
        LPSTR szTarget = new char[cTarget+1];

        if ( szTarget != NULL )
        {
            wcstombs( szTarget, wszTarget, cTarget+1 );
            ULONG in_ad = inet_addr( szTarget );   
            hr = in_ad == INADDR_NONE ? WBEM_S_FALSE : WBEM_S_NO_ERROR;
            delete [] szTarget;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        WSACleanup();                
    }
    else
    {
        hr = WMIMSG_E_REQSVCNOTAVAIL;
    }

    return hr;
}

HRESULT GetDnsName( LPCWSTR wszTarget, LPWSTR* pwszDnsName )
{
    HRESULT hr;
    *pwszDnsName = NULL;

    //
    // first make sure winsock is initialized.
    //

    WSADATA wsaData; 
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD( 2, 2 );
 
    int err = WSAStartup( wVersionRequested, &wsaData );

    if ( err == 0 ) 
    {
        IN_ADDR ia;
        HOSTENT* pHost;

        //
        // convert unicode addr to ansi .. 
        // 

        int cTarget = wcstombs( NULL, wszTarget, 0 );
        LPSTR szTarget = new char[cTarget+1];

        if ( szTarget != NULL )
        {
            wcstombs( szTarget, wszTarget, cTarget+1 );

            //
            // see if its an ip address ...
            //
            
            ULONG in_ad = inet_addr( szTarget );
            
            if ( in_ad == INADDR_NONE )
            {
                pHost = gethostbyname( szTarget );
            }
            else
            {
                pHost = gethostbyaddr( (char*)&in_ad, 4, PF_INET );
            }
            
            if ( pHost != NULL )
            {
                int cDnsTarget = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      pHost->h_name,
                                                      -1,
                                                      NULL,
                                                      0 );
            
                *pwszDnsName = new WCHAR[cDnsTarget+1];

                if ( *pwszDnsName != NULL )
                {
                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         pHost->h_name,
                                         -1,
                                         *pwszDnsName,
                                         cDnsTarget+1 );

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else
            {
                hr = WMIMSG_E_INVALIDADDRESS;
            }

            delete [] szTarget;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        WSACleanup();
    }
    else
    {
        hr = WMIMSG_E_REQSVCNOTAVAIL;
    }

    return hr;
}

HRESULT GetSpn( LPCWSTR wszTarget, LPWSTR* wszSpn )
{
    HRESULT hr;
    *wszSpn = NULL;

    LPWSTR wszNormTarget;
    hr = GetDnsName( wszTarget, &wszNormTarget );
    
    if ( FAILED(hr) )
        return hr;

    CVectorDeleteMe<WCHAR> vdm( wszNormTarget );
    
    DWORD cSpn = 0;
    
    DWORD dwRes = DsMakeSpn( L"HOST", wszNormTarget, NULL, 0,
                              NULL, &cSpn, NULL);

    if ( dwRes == ERROR_MORE_DATA || dwRes == ERROR_BUFFER_OVERFLOW )
    {
        *wszSpn = new WCHAR[cSpn];
        
        if ( *wszSpn != NULL )
        {
            dwRes = DsMakeSpn( L"HOST", 
                               wszNormTarget, 
                               NULL, 
                               0, 
                               NULL, 
                               &cSpn, 
                               *wszSpn );

            if ( dwRes == ERROR_SUCCESS )
            {
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                delete [] *wszSpn;
                *wszSpn = NULL;
                hr = HRESULT_FROM_WIN32( dwRes );
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( dwRes );
    }

    return hr;
}

/********************************************************************
  CFwdConsSend
*********************************************************************/

HRESULT CFwdConsSend::AddMSMQSender( LPCWSTR wszName )
{
    HRESULT hr;

    //
    // need to construct the Ack address for this sender.
    //

    TCHAR atchComputer[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cComputer = MAX_COMPUTERNAME_LENGTH+1; 
    GetComputerName( atchComputer, &cComputer );
    WCHAR awchComputer[MAX_COMPUTERNAME_LENGTH+1];
    cComputer = MAX_COMPUTERNAME_LENGTH+1;
    
    tsz2wsz( atchComputer, awchComputer, &cComputer );
    
    WString wsAckQueueName = L"DIRECT=OS:";
    wsAckQueueName += awchComputer;
    wsAckQueueName += L"\\private$\\WMIFwdAck";

    //
    // create the sender object and add it to the multisender.
    //

    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( CLSID_WmiMessageMsmqSender,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IWmiMessageSender,
                          (void**)&pSender );
    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWmiMessageSendReceive> pSend;

    DWORD dwFlags = m_dwFlags | 
    WMIMSG_FLAG_SNDR_LAZY_INIT | 
    WMIMSG_FLAG_SNDR_PRIV_SIGN | 
    WMIMSG_FLAG_SNDR_NACK_ONLY;

    hr = pSender->Open( wszName,
                        dwFlags,
                        NULL,
                        wsAckQueueName,
                        m_pTraceSink,
                        &pSend );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pMultiSend->Add( WMIMSG_FLAG_MULTISEND_TERMINATING_SENDER, pSend);
}

HRESULT CFwdConsSend::AddAsyncSender( LPCWSTR wszMachine )
{
    HRESULT hr;

    //
    // derive the msmq address from the target and add the sender.
    //

    WString wsQueueName;

    if ( (m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT) == 0 )
    {
        //
        // we can use a direct format name to identify the target.  This is 
        // the most flexible type of address besides a private format name, 
        // but those cannot be derived.  ( public pathnames can only be used 
        // when online )
        // 

        wsQueueName = L"DIRECT=";

        hr = IsTcpIpAddress( wszMachine );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( hr == WBEM_S_NO_ERROR )
        {
            wsQueueName += L"TCP:";
        }
        else
        {
            wsQueueName += L"OS:";
        }

        wsQueueName += wszMachine;
        wsQueueName += L"\\private$\\";
    }
    else
    {
        //
        // we must use a public queue pathname to reference the queue.  this is
        // because msmq will not accept direct format names for encryption.
        // encryption is supported by msmq only when the sender has access to
        // ds.  This means when this machine is offline, we cannot encrypt 
        // messages.
        // 
        wsQueueName = L"wszMachine\\";
    }

    DWORD dwQos = m_dwFlags & WMIMSG_MASK_QOS;

    _DBG_ASSERT( dwQos != WMIMSG_FLAG_QOS_SYNCHRONOUS );

    if( dwQos == WMIMSG_FLAG_QOS_EXPRESS )
    {
        wsQueueName += L"WMIFwdExpress";
    }
    else if( dwQos == WMIMSG_FLAG_QOS_GUARANTEED )
    {
        wsQueueName += L"WMIFwdGuaranteed";
    }
    else if ( dwQos == WMIMSG_FLAG_QOS_XACT )
    {
        wsQueueName += L"WMIFwdXact";
    }

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT )
    {
        wsQueueName += L"Encrypt";
    }
    else if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        wsQueueName += L"Auth";
    }

    return AddMSMQSender(wsQueueName);    
}

HRESULT CFwdConsSend::AddSyncSender( LPCWSTR wszMachine )
{
    HRESULT hr;

    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( CLSID_WmiMessageRpcSender,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IWmiMessageSender,
                          (void**)&pSender );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // construct target binding : OBJID@ncacn_ip_tcp:target
    // 

    WString wsTarget = L"7879E40D-9FB5-450a-8A6D-00C89F349FCE@ncacn_ip_tcp:";
    wsTarget += wszMachine;

    //
    // construct the target principal name - for kerberos.  We expect that 
    // has registered its SPN with AD.  we only need to do this if we 
    // are sending authenticated though ...
    //

    LPWSTR wszSpn = NULL;

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {  
        hr = GetSpn( wszMachine, &wszSpn );

        if ( FAILED(hr) )
        {
            DEBUGTRACE((LOG_ESS,"FC: Could not determine SPN for target %S. "
                    "hr=0x%x. Will try to forward events using NTLM\n",
                     wszMachine, hr ));
        }
    }

    CVectorDeleteMe<WCHAR> vdm2( wszSpn );

    WMIMSG_SNDR_AUTH_INFO AuthInfo;
    ZeroMemory( &AuthInfo, sizeof( WMIMSG_SNDR_AUTH_INFO ) );

    AuthInfo.wszTargetPrincipal = wszSpn;

    //
    // open sender
    //
    
    CWbemPtr<IWmiMessageSendReceive> pSend;

    hr = pSender->Open( wsTarget,
                        m_dwFlags | WMIMSG_FLAG_SNDR_LAZY_INIT,
                        &AuthInfo,
                        NULL,
                        m_pTraceSink,
                        &pSend );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // add to multi sender and return.
    //

    return m_pMultiSend->Add(WMIMSG_FLAG_MULTISEND_TERMINATING_SENDER, pSend );
}

HRESULT CFwdConsSend::AddPhysicalSender( LPCWSTR wszMachine )
{
    HRESULT hr;

#ifndef __WHISTLER_UNCUT

    if ( (m_dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    return AddSyncSender( wszMachine );

#else

    //
    // here, we always add a sync sender first even if a qos
    // of async is specified. Later this type of service may change to
    // be its own QoS class.
    //

    hr = AddSyncSender( wszMachine );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( (m_dwFlags & WMIMSG_MASK_QOS) == WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        return WBEM_S_NO_ERROR;
    }

    return AddAsyncSender( wszMachine );

#endif

}

HRESULT CFwdConsSend::AddLogicalSender( LPCWSTR wszTarget )
{
    HRESULT hr;

    CWbemPtr<IWmiMessageSendReceive> pSend;

    hr = Create( m_pControl,
                wszTarget,
                m_dwFlags | FWD_FLAG_NO_INDIRECT,
                NULL,
                m_pTraceSink,
                &pSend );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pMultiSend->Add( 0, pSend );
}

HRESULT CFwdConsSend::AddLogicalSender( LPCWSTR wszObjpath, LPCWSTR wszProp )
{
    HRESULT hr;

    //
    // Check to make sure that indirect names are supported.
    // This flag is mostly used to prohibit recursive indirect
    // addesses.
    //

    if ( m_dwFlags & FWD_FLAG_NO_INDIRECT )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CWbemBSTR bsObjPath = wszObjpath;

    //
    // Resolve the address by obtaining the object and getting
    // the value of the specified property.
    //

    VARIANT var;
    CWbemPtr<IWbemClassObject> pObj;

    hr = m_pDefaultSvc->GetObject( bsObjPath, 0, NULL, &pObj, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pObj->Get( wszProp, 0, &var, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CClearMe cmvar(&var);

    //
    // Add a new logical sender after resolving the address.
    // Before adding the new sender, make sure we disable indirect
    // addresses on it to prohibit recursive resolution.
    //

    DWORD dwFlags = m_dwFlags | FWD_FLAG_NO_INDIRECT;

    if ( V_VT(&var) == VT_BSTR )
    {
        return AddLogicalSender( V_BSTR(&var) );
    }
    else if ( V_VT(&var) == (VT_ARRAY | VT_BSTR) )
    {
        BSTR* abstrNames;
        hr = SafeArrayAccessData( V_ARRAY(&var), (void**)&abstrNames );

        if ( FAILED(hr) )
        {
            return hr;
        }

        long lUbound;
        hr = SafeArrayGetUBound( V_ARRAY(&var), 0, &lUbound );
        _DBG_ASSERT(SUCCEEDED(hr));

        for( long i=0; i < lUbound+1; i++ )
        {
            AddLogicalSender( V_BSTR(&var) );
        }

        SafeArrayUnaccessData( V_ARRAY(&var) );
    }
    else
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    return hr;
}

HRESULT CFwdConsSend::EnsureSender()
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    if ( m_bResolved )
    {
        return S_OK;
    }

    WString wsTarget = m_wsTarget;

    LPWSTR wszToken = wcstok( wsTarget, L"!" );

    LPWSTR wszToken2 = wcstok( NULL, L"!" );

    if ( wszToken2 == NULL )
    {
        hr = AddPhysicalSender( wszToken );
    }
#ifdef __WHISTLER_UNCUT
    else if ( wbem_wcsicmp( wszToken, L"msmq" ) == 0 )
    {
        hr = AddMSMQSender( wszToken2 );
    }
    else if ( wbem_wcsicmp( wszToken, L"wmi" ) == 0 )
    {
        LPWSTR wszToken3 = wcstok( NULL, L"!" );

        if ( wszToken3 == NULL )
        {
            return WMIMSG_E_INVALIDADDRESS;
        }

        hr = AddLogicalSender( wszToken2, wszToken3 );
    }
#endif
    else
    {
        return WMIMSG_E_INVALIDADDRESS;
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_bResolved = TRUE;

    return hr;
}

HRESULT CFwdConsSend::HandleTrace( HRESULT hr, IUnknown* pCtx )
{
    if ( m_pTraceSink == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    return m_pTraceSink->Notify( hr, g_guidQueueType, m_wsTarget, pCtx );
}

HRESULT CFwdConsSend::SendReceive( PBYTE pData,
                                  ULONG cData,
                                  PBYTE pAuxData,
                                  ULONG cAuxData,
                                  DWORD dwFlagStatus,
                                  IUnknown* pCtx )
{
    HRESULT hr;

    hr = EnsureSender();

    if ( FAILED(hr) )
    {
        HandleTrace( hr, pCtx );
        return hr;
    }

    return m_pMultiSend->SendReceive( pData,
                                     cData,
                                     pAuxData,
                                     cAuxData,
                                     dwFlagStatus,
                                     pCtx );
}

HRESULT CFwdConsSend::Create( CLifeControl* pCtl,
                             LPCWSTR wszTarget,
                             DWORD dwFlags,
                             IWbemServices* pDefaultSvc,
                             IWmiMessageTraceSink* pTraceSink,
                             IWmiMessageSendReceive** ppSend )
{
    HRESULT hr;

    *ppSend = NULL;

    CWbemPtr<IWmiMessageMultiSendReceive> pMultiSend;

    hr = CoCreateInstance( CLSID_WmiMessageMultiSendReceive,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IWmiMessageMultiSendReceive,
                          (void**)&pMultiSend );
    if ( FAILED(hr) )
    {
	return hr;
    }

    CWbemPtr<CFwdConsSend> pSend = new CFwdConsSend( pCtl );

    if ( pSend == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( wszTarget != NULL && *wszTarget != 0 )
    {
        pSend->m_wsTarget = wszTarget;
    }
    else
    {
        //
        // the default is to send to local computer.
        //

        TCHAR achComputer[MAX_COMPUTERNAME_LENGTH+1];
        ULONG ulSize = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerName( achComputer, &ulSize );
        pSend->m_wsTarget = achComputer;
    }

    pSend->m_dwFlags = dwFlags;
    pSend->m_pDefaultSvc = pDefaultSvc;
    pSend->m_pTraceSink = pTraceSink;
    pSend->m_pMultiSend = pMultiSend;

    hr = pSend->QueryInterface( IID_IWmiMessageSendReceive, (void**)ppSend );
    _DBG_ASSERT(SUCCEEDED(hr));

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsink.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include <buffer.h>
#include <wbemutil.h>
#include <sddl.h>
#include "fwdhdr.h"
#include "fconsink.h"
#include "fconsend.h"

LPCWSTR g_wszQos = L"ForwardingQos";
LPCWSTR g_wszAuth = L"Authenticate";
LPCWSTR g_wszEncrypt = L"Encryption";
LPCWSTR g_wszTargets = L"Targets";
LPCWSTR g_wszName = L"Name";
LPCWSTR g_wszTargetSD = L"TargetSD";
LPCWSTR g_wszSendSchema = L"IncludeSchema";

typedef BOOL (APIENTRY*PStringSDToSD)(
                                LPCWSTR StringSecurityDescriptor,
                                DWORD StringSDRevision,          
                                PSECURITY_DESCRIPTOR *SecurityDescriptor, 
                                PULONG SecurityDescriptorSize );

#define OPTIMAL_MESSAGE_SIZE 0x4000

class CTraceSink 
: public CUnkBase< IWmiMessageTraceSink, &IID_IWmiMessageTraceSink >
{
    CFwdConsSink* m_pOwner;

public:

    CTraceSink( CFwdConsSink* pOwner ) : m_pOwner( pOwner ) { }

    STDMETHOD(Notify)( HRESULT hRes,
                       GUID guidSource,
                       LPCWSTR wszTrace,
                       IUnknown* pContext )
    {
        return m_pOwner->Notify( hRes, guidSource, wszTrace, pContext );
    }
};

/****************************************************************************
  CFwdConsSink
*****************************************************************************/

CFwdConsSink::~CFwdConsSink()
{
    if ( m_pTargetSD != NULL )
    {
        LocalFree( m_pTargetSD );
    }
}

HRESULT CFwdConsSink::Initialize( CFwdConsNamespace* pNspc, 
                                  IWbemClassObject* pCons )
{
    HRESULT hr;
    CPropVar vQos, vAuth, vEncrypt, vTargets, vName, vSendSchema, vTargetSD;

    m_pNamespace = pNspc;

    //
    // initialize multi sender.  each forwarding consumer can
    // contain multiple targets. 
    //

    hr = CoCreateInstance( CLSID_WmiMessageMultiSendReceive,
	 		   NULL,
	 		   CLSCTX_INPROC,
	 		   IID_IWmiMessageMultiSendReceive,
	 		   (void**)&m_pMultiSend );
    if ( FAILED(hr) )
    {
	 return hr;
    }


    hr = CoCreateInstance( CLSID_WmiSmartObjectMarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&m_pMrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // initialize internal props from forwarding consumer props.
    //

    hr = pCons->Get( g_wszQos, 0, &vQos, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vQos.SetType(VT_UI4) ) )
    {
        return hr;
    } 

    if ( V_UI4(&vQos) != WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }

    hr = pCons->Get( g_wszName, 0, &vName, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vName.CheckType(VT_BSTR) ) )
    {
        return hr;
    }

    m_wsName = V_BSTR(&vName);

    hr = pCons->Get( g_wszTargetSD, 0, &vTargetSD, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    } 
  
    if ( V_VT(&vTargetSD) != VT_NULL )
    {
        if ( V_VT(&vTargetSD) != VT_BSTR )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        //
        // convert the SD string to a relative SD. The function to do this 
        // needs to be dynamically loaded because its w2k+ only.
        // 
        
        HMODULE hMod = LoadLibrary( TEXT("advapi32") );

        if ( hMod != NULL )
        {
            PStringSDToSD fpTextToSD;

            fpTextToSD = (PStringSDToSD)GetProcAddress( hMod, 
                   "ConvertStringSecurityDescriptorToSecurityDescriptorW" );
        
            if ( fpTextToSD != NULL )
            {
               if ( (*fpTextToSD)( V_BSTR(&vTargetSD), 
                                   SDDL_REVISION_1, 
                                   &m_pTargetSD, 
                                   &m_cTargetSD ) )
               {
                   hr = WBEM_S_NO_ERROR;
               }
               else
               {
                   hr = HRESULT_FROM_WIN32( GetLastError() );
               } 
            }
            else
            {
                hr = WBEM_E_NOT_SUPPORTED;
            }

            FreeLibrary( hMod );

            if ( FAILED(hr) )
            {
                return hr;
            }
        }
        else
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    }
    
    hr = pCons->Get( g_wszAuth, 0, &vAuth, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vAuth.SetType(VT_BOOL) ) )
    {
        return hr;
    }

    hr = pCons->Get( g_wszEncrypt, 0, &vEncrypt, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vEncrypt.SetType(VT_BOOL) ) )
    {
        return hr;
    }

    hr = pCons->Get( g_wszSendSchema, 0, &vSendSchema, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vSendSchema.SetType(VT_BOOL) ) )
    {
        return hr;
    }

    m_dwFlags = V_UI4(&vQos);
    m_dwFlags |= V_BOOL(&vAuth)==VARIANT_TRUE ?WMIMSG_FLAG_SNDR_AUTHENTICATE:0;
    m_dwFlags |= V_BOOL(&vEncrypt)==VARIANT_TRUE ? WMIMSG_FLAG_SNDR_ENCRYPT:0;
  
    m_dwCurrentMrshFlags = WMIMSG_FLAG_MRSH_FULL_ONCE; 
    m_dwDisconnectedMrshFlags = V_BOOL(&vSendSchema) == VARIANT_TRUE ?
          WMIMSG_FLAG_MRSH_FULL : WMIMSG_FLAG_MRSH_PARTIAL;
    
    //
    // create a trace sink for receiving callbacks from wmimsg.  Note that
    // this sink's lifetime must be decoupled from this objects, else we'd 
    // end up with a circular ref.
    //
    CWbemPtr<CTraceSink> pInternalTraceSink = new CTraceSink( this );

    if ( pInternalTraceSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemPtr<IWmiMessageTraceSink> pTraceSink;
    hr = pInternalTraceSink->QueryInterface( IID_IWmiMessageTraceSink, 
                                             (void**)&pTraceSink );
    _DBG_ASSERT( SUCCEEDED(hr) );

    //
    // targets array can be null, in which case we treat it as if the array
    // had one element, the empty string.
    //

    hr = pCons->Get( g_wszTargets, 0, &vTargets, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    } 

    if ( V_VT(&vTargets) != VT_NULL )
    {
        if ( FAILED(hr=vTargets.CheckType(VT_ARRAY|VT_BSTR) ) )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        CPropSafeArray<BSTR> aTargets( V_ARRAY(&vTargets) );
    
        //
        // create all the fwd cons senders for the targets.  
        // 
        
        for( ULONG i=0; i < aTargets.Length(); i++ )
        {
            CWbemPtr<IWmiMessageSendReceive> pSend;
            
            hr = CFwdConsSend::Create( m_pControl, 
                                       aTargets[i],
                                       m_dwFlags,
                                       m_pNamespace->GetSvc(),
                                       pTraceSink,
                                       &pSend );
            if ( FAILED(hr) )
            {
                break;
            }

            hr = m_pMultiSend->Add( 0, pSend );
            
            if ( FAILED(hr) )
            { 
                break;
            }
        }
    }
    else
    {
        CWbemPtr<IWmiMessageSendReceive> pSend;

        hr = CFwdConsSend::Create( m_pControl,
                                   L"",
                                   m_dwFlags,
                                   m_pNamespace->GetSvc(),
                                   pTraceSink,
                                   &pSend );
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = m_pMultiSend->Add( 0, pSend );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;  
}

//
// this method handles all sending/marshaling errors internally and will 
// return either S_OK when all objects are processed or S_FALSE 
// if only some are processed.
//

HRESULT CFwdConsSink::IndicateSome( IWbemClassObject* pConsumer,
                                    long cObjs, 
                                    IWbemClassObject** ppObjs, 
                                    long* pcProcessed )
{
    HRESULT hr;

    _DBG_ASSERT( cObjs > 0 );
    
    //
    // create an execution id for this indicate.
    //

    GUID guidExecution;
    CoCreateGuid( &guidExecution );

    //
    // marshal the events. we will stop marshaling them when the buffer 
    // gets bigger than it should for an optimally sized message.
    //

    BYTE achData[512];
    BYTE achHdr[256];

    CBuffer DataStrm( achData, 512, FALSE );
    CBuffer HdrStrm( achHdr, 256, FALSE );

    //
    // we remembered our last buffer size, so set to that in the hopes that 
    // we can avoid a retry on the packing.
    //
    
    hr = DataStrm.SetSize( m_ulLastDataSize );
    m_ulLastDataSize = 0;

    ULONG i;

    for( i = 0; i < cObjs && SUCCEEDED(hr); i++ )
    {
        ULONG cUsed;
        PBYTE pData = DataStrm.GetRawData();
        ULONG cData = DataStrm.GetSize();
        ULONG iData = DataStrm.GetIndex();

        if ( iData < OPTIMAL_MESSAGE_SIZE )
        {
            hr = m_pMrsh->Pack( ppObjs[i], 
                                m_pNamespace->GetName(),
                                m_dwCurrentMrshFlags, 
                                cData-iData,
                                pData+iData,
                                &cUsed );

            if ( hr == WBEM_E_BUFFER_TOO_SMALL )
            {
                hr = DataStrm.SetSize( iData + cUsed );

                if ( SUCCEEDED(hr) )
                {
                    pData = DataStrm.GetRawData();
                    cData = DataStrm.GetSize();
                                        
                    hr = m_pMrsh->Pack( ppObjs[i], 
                                        m_pNamespace->GetName(),
                                        m_dwCurrentMrshFlags, 
                                        cData-iData, 
                                        pData+iData, 
                                        &cUsed);
                }
            }

            if ( SUCCEEDED(hr) )
            {
                DataStrm.Advance( cUsed );
            }
        }
        else
        {
            break;
        }
    }

    //
    // at this point, we know how many events we've actually processed
    // i will always be the number of objects successfully processed.  
    // we want to try to separate out the events that fail to be packed 
    // from ones that are packed.  For this reason, pretend we didn't event 
    // process the one that failed, unless it is the first one.
    // 
    
    *pcProcessed = i > 0 ? i : 1;

    //
    // create a context object for this indicate. This is used to  
    // thread information through to the trace functions 
    // which are invoked by the senders. 
    //

    CFwdContext Ctx( guidExecution, pConsumer, *pcProcessed, ppObjs );        
    
    if ( i > 0 ) // at least some were successfully processed.
    {
        m_ulLastDataSize = DataStrm.GetIndex();

        //
        // create and stream the msg header 
        //

        CFwdMsgHeader Hdr( *pcProcessed, 
                           m_dwFlags & WMIMSG_MASK_QOS, 
                           m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE,
                           m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT, 
                           guidExecution, 
                           m_wsName,
                           m_pNamespace->GetName(),
                           PBYTE(m_pTargetSD),
                           m_cTargetSD );

        hr = Hdr.Persist( HdrStrm );

        if ( SUCCEEDED(hr) )
        {
            //
            // send it and notify the tracing sink of the result.  Always try
            // once with return immediately set.  This will try all the 
            // primary senders first.
            //

            hr = m_pMultiSend->SendReceive( DataStrm.GetRawData(), 
                                            DataStrm.GetIndex(),
                                            HdrStrm.GetRawData(),
                                            HdrStrm.GetIndex(),
                                     WMIMSG_FLAG_MULTISEND_RETURN_IMMEDIATELY,
                                            &Ctx );

            if ( SUCCEEDED(hr) )
            {
                ;
            }
            else
            {
                //
                // o.k so all the primary ones failed, so now lets try all the 
                // senders.
                //
            
                hr = m_pMultiSend->SendReceive( DataStrm.GetRawData(),
                                                DataStrm.GetIndex(),
                                                HdrStrm.GetRawData(),
                                                HdrStrm.GetIndex(),
                                                0,
                                                &Ctx );
            }
        }
    }

    m_pNamespace->HandleTrace( hr, &Ctx );

    return *pcProcessed == cObjs ? S_OK : S_FALSE;
}

//
// this is where we get notified of every target send event.  here, we look 
// at the information and adjust our marshalers accordingly. we then pass the
// event onto the namespace sink for tracing purposes. NOTE: This solution of 
// adjusting our marshalers on callbacks means that we're assuming a couple 
// things about the send implementation .. 1 ) the notification of the send 
// must be on the same control path as the send call.  2 ) the sender will 
// use the same target when it has successfully sent to it previously (e.g it
// will not notify us that it sent to an rpc target, we then optimize our 
// marshalers for it, then it chooses to send to an msmq target ).  
//

HRESULT CFwdConsSink::Notify( HRESULT hRes,
                              GUID guidSource,
                              LPCWSTR wszTrace,
                              IUnknown* pContext )
{
    HRESULT hr;

    ENTER_API_CALL

    if ( FAILED(hRes) )
    {
        //
        // we failed sending to a target, flush any state the marshaler 
        // was keeping.
        //
        m_pMrsh->Flush();
    }

    //
    // check that current marshaling flags against the type of sender that 
    // was used.
    //

    if ( guidSource == CLSID_WmiMessageRpcSender )
    {
        if ( SUCCEEDED(hRes) &&
             m_dwCurrentMrshFlags != WMIMSG_FLAG_MRSH_FULL_ONCE )
        {
            //
            // lets give schema once-only a whirl..
            //
            m_dwCurrentMrshFlags = WMIMSG_FLAG_MRSH_FULL_ONCE;
        }
    }
    else // must be queueing
    {
        if ( m_dwCurrentMrshFlags == WMIMSG_FLAG_MRSH_FULL_ONCE )
        {
            //
            // once only is not for messaging !! Its o.k. though
            // because we are sure that we've only used it once
            // and it did send the schema.  Just don't use it again.
            //
            m_dwCurrentMrshFlags = m_dwDisconnectedMrshFlags;
        }
    }

    //
    // pass the call onto the namespace sink for tracing.
    //

    hr = m_pNamespace->Notify( hRes, guidSource, wszTrace, pContext );
    
    EXIT_API_CALL

    return hr;
}

HRESULT CFwdConsSink::IndicateToConsumer( IWbemClassObject* pConsumer,
                                          long cObjs, 
                                          IWbemClassObject** ppObjs )
{
    HRESULT hr;

    ENTER_API_CALL

    //
    // If the security context of the event provider is maintained then 
    // we will use it to send the forwarded event.
    // 
    CWbemPtr<IServerSecurity> pSec;
    hr = CoGetCallContext( IID_IServerSecurity, (void**)&pSec );

    if ( SUCCEEDED(hr) )
    {
        hr = pSec->ImpersonateClient();

        if ( FAILED(hr) )
            return hr;
    }
    
    long cProcessed = 0;
    
    //
    // IndicateSome() may send only a subset of the total indicated events.
    // This is to avoid sending potentially huge messages.  So we'll keep 
    // calling IndicateSome() until all messages are sent or there's an error.
    // 

    do
    {
        cObjs -= cProcessed;
        ppObjs += cProcessed;

        hr = IndicateSome( pConsumer, cObjs, ppObjs, &cProcessed );

        _DBG_ASSERT( FAILED(hr) || (SUCCEEDED(hr) && cProcessed > 0 )); 

    } while ( SUCCEEDED(hr) && cProcessed < cObjs );

    if ( pSec != NULL )
        pSec->RevertToSelf();

    EXIT_API_CALL

    return hr;
}

HRESULT CFwdConsSink::Create( CLifeControl* pCtl, 
                              CFwdConsNamespace* pNspc,
                              IWbemClassObject* pCons, 
                              IWbemUnboundObjectSink** ppSink )
{
    HRESULT hr;

    *ppSink = NULL;

    CWbemPtr<CFwdConsSink> pSink = new CFwdConsSink( pCtl );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pSink->Initialize( pNspc, pCons );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSink->QueryInterface( IID_IWbemUnboundObjectSink, (void**)ppSink );

    assert( SUCCEEDED(hr) );

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fevprov.h ===
#ifndef __FEVPROV_H__
#define __FEVPROV_H__

#include <unk.h>
#include <comutl.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <wmimsg.h>
#include "fwdhdr.h"

class CFwdEventProv : public CUnk
{
    class XProv : public CImpl< IWbemEventProvider, CFwdEventProv >
    { 
    public:

        STDMETHOD(ProvideEvents)( IWbemObjectSink* pSink, long lFlags )
 	{
	    return m_pObject->ProvideEvents( pSink, lFlags );
	}

        XProv( CFwdEventProv* pObj )
	 : CImpl<IWbemEventProvider, CFwdEventProv> ( pObj ) {}

    } m_XProv;

    class XQuery : public CImpl<IWbemEventProviderQuerySink, CFwdEventProv>
    {
    public:
        
        STDMETHOD(NewQuery)( DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery )
	{
	    return m_pObject->NewQuery( dwId, wszQuery );
	}

        STDMETHOD(CancelQuery)( DWORD dwId )
	{
	    return m_pObject->CancelQuery( dwId );
	}

        XQuery( CFwdEventProv* pObj) 
	 : CImpl<IWbemEventProviderQuerySink, CFwdEventProv> ( pObj ) {}

    } m_XQuery;

    class XInit : public CImpl<IWbemProviderInit, CFwdEventProv>
    {
    public:

        STDMETHOD(Initialize)( LPWSTR wszUser, 
                               LONG lFlags, 
                               LPWSTR wszNamespace,
                               LPWSTR wszLocale, 
                               IWbemServices* pNamespace,
                               IWbemContext* pContext,
                               IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, pInitSink );
        }

        XInit( CFwdEventProv* pObj) 
         : CImpl<IWbemProviderInit, CFwdEventProv>(pObj) { }

    } m_XInit;

    //
    // the next two interface impls are not associated with this objects's 
    // identity.  Reasons is there would be a circular ref problem if they 
    // were because we hold onto the receiver, which in turn holds on to
    // the send/recv and error sink objects.
    //

    class XSendReceive : public IWmiMessageSendReceive
    {
        CFwdEventProv* m_pOwner; // no add-ref or circular reference.

        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if ( riid == IID_IUnknown || riid == IID_IWmiMessageSendReceive )
            {
                *ppv = this;
                return S_OK;
            }
            return E_NOINTERFACE;
        }
            
        STDMETHOD_(ULONG, AddRef)() { return 1; }
        STDMETHOD_(ULONG, Release)() { return 1; }

    public:

        STDMETHOD(SendReceive)( PBYTE pData, 
                                ULONG cData,
                                PBYTE pAuxData,
                                ULONG cAuxData,
                                DWORD dwFlagStatus,
                                IUnknown* pCtx )
 	{
	    return m_pOwner->Receive( pData, 
                                      cData, 
                                      pAuxData,
                                      cAuxData,
                                      dwFlagStatus,
                                      pCtx );
	}

        XSendReceive( CFwdEventProv* pOwner ) : m_pOwner( pOwner ) { }

    } m_XSendReceive;

    class XErrorSink : public IWmiMessageTraceSink
    { 
        CFwdEventProv* m_pOwner; // no add-ref or circular reference.

        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if ( riid == IID_IUnknown || riid == IID_IWmiMessageTraceSink )
            {
                *ppv = this;
                return S_OK;
            }
            return E_NOINTERFACE;
        }
            
        STDMETHOD_(ULONG, AddRef)() { return 1; }
        STDMETHOD_(ULONG, Release)() { return 1; }

    public:

	STDMETHOD(Notify)( HRESULT hRes, 
                           GUID guidSource, 
                           LPCWSTR wszError, 
                           IUnknown* pCtx )
	{
	    return m_pOwner->HandleRecvError( hRes, wszError );
	}

        XErrorSink( CFwdEventProv* pOwner ) : m_pOwner( pOwner ) { }

    } m_XErrorSink;
              
    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemObjectSink> m_pEventSink;
    CWbemPtr<IWbemClassObject> m_pEventClass;
    CWbemPtr<IWbemClassObject> m_pDataClass;    
    
    CWbemPtr<IWmiObjectMarshal> m_pMrsh;
    CWbemPtr<IWmiMessageReceiver> m_pDcomRcvr;
    CWbemPtr<IWmiMessageReceiver> m_apQueueRcvr[16];

    long m_lMachineProp;
    long m_lConsumerProp;
    long m_lNamespaceProp;
    long m_lAuthProp;
    long m_lSDProp;
    long m_lAccountProp;
    long m_lTimeProp;

    HRESULT InitializeQueues( BOOL bAllowUnauth );
    HRESULT InitializeReceivers( BOOL bAllowUnauth );

    HRESULT InitializeEvent( IWbemClassObject* pOriginalEvent,
                             IWmiMessageReceiverContext* pRecvCtx,
                             LPCWSTR wszConsumer,
                             LPCWSTR wszNamespace,
                             PBYTE pSD,
                             ULONG cSD,
                             IWbemClassObject* pEvent ); 

    void* GetInterface( REFIID riid );

public:

    CFwdEventProv( CLifeControl* pCtl, IUnknown* pUnk = NULL );
    virtual ~CFwdEventProv();

    HRESULT Init( IWbemServices* pSvc, IWbemProviderInitSink* pInitSink);
    HRESULT ProvideEvents( IWbemObjectSink* pSink, long lFlags );
    HRESULT NewQuery( DWORD dwId, LPWSTR wszQuery );
    HRESULT CancelQuery( DWORD dwId );	
    HRESULT HandleRecvError( HRESULT hRes, LPCWSTR wszError );
    HRESULT Receive( PBYTE pData, 
                     ULONG cData, 
                     PBYTE pAuxData,
                     ULONG cAuxData,
                     DWORD dwFlagStatus,
                     IUnknown* pCtx );
};

#endif // __FEVPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsink.h ===
#ifndef __FCONSINK_H__
#define __FCONSINK_H__

#include <comutl.h>
#include <unk.h>
#include <wmimsg.h>
#include <wstring.h>
#include "fconnspc.h"

/*************************************************************************
  CFwdConsSink
**************************************************************************/
 
class CFwdConsSink 
: public CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink > 
{
    CFwdConsNamespace* m_pNamespace;
    CWbemPtr<IWmiMessageMultiSendReceive> m_pMultiSend;
    WString m_wsName;
    DWORD m_dwFlags;
    ULONG m_ulLastDataSize;
    ULONG m_cTargetSD;
    PSECURITY_DESCRIPTOR m_pTargetSD;
    DWORD m_dwCurrentMrshFlags;
    DWORD m_dwDisconnectedMrshFlags;

    CWbemPtr<IWmiObjectMarshal> m_pMrsh;

protected:
  
    CFwdConsSink( CLifeControl* pCtl ) : 
      CUnkBase<IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink>(pCtl),
      m_ulLastDataSize(0), m_pTargetSD(NULL), m_cTargetSD(0) { }

    ~CFwdConsSink();

    HRESULT Initialize( CFwdConsNamespace* pNspc, IWbemClassObject* pCons );
    
    HRESULT IndicateSome( IWbemClassObject* pLogicalConsumer, 
                          long cObjs, 
                          IWbemClassObject** ppObjs,
                          long* pcProcessed );
public:

    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pLogicalConsumer, 
                                   long cObjs, 
                                   IWbemClassObject** ppObjs );
 
    HRESULT Notify( HRESULT hRes,
                    GUID guidSource,
                    LPCWSTR wszTrace,
                    IUnknown* pContext );

    static HRESULT Create( CLifeControl* pCtl, 
                           CFwdConsNamespace* pNspc,
                           IWbemClassObject* pCons, 
                           IWbemUnboundObjectSink** ppSink );
};


#endif // __FCONSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fevprov.cpp ===
#include "precomp.h"
#include <sspi.h>
#include <secext.h>
#include <ntdsapi.h>
#include <stdio.h>
#include <buffer.h>
#include <winntsec.h>
#include <callsec.h>
#include <wbemint.h>
#include <wbemutil.h>
#include <arrtempl.h>
#include "fevprov.h"
#include "fwdhdr.h"

static LPWSTR g_wszEventClass = L"MSFT_ForwardedEvent";
static LPWSTR g_wszEventProp = L"Event";
static LPWSTR g_wszMachineProp = L"Machine";
static LPWSTR g_wszConsumerProp = L"Consumer";
static LPWSTR g_wszNamespaceProp = L"Namespace";
static LPWSTR g_wszAuthenticatedProp = L"Authenticated";
static LPWSTR g_wszAccountProp = L"Account";
static LPWSTR g_wszSDProp = L"SECURITY_DESCRIPTOR";
static LPWSTR g_wszTimeProp = L"Time";

// {0F3162C5-7B5A-469f-955C-79603B7EB5A6}
static const GUID g_guidQueueType = 
{ 0xf3162c5, 0x7b5a, 0x469f, {0x95, 0x5c, 0x79, 0x60, 0x3b, 0x7e, 0xb5, 0xa6}};

LPCWSTR g_awszQueueNames[] = { L".\\private$\\WMIFwdGuaranteed",
                               L".\\private$\\WMIFwdExpress",
                               L".\\private$\\WMIFwdGuaranteedAuth",      
                               L".\\private$\\WMIFwdExpressAuth",
                               L".\\WMIFwdGuaranteedEncrypt",
                               L".\\WMIFwdExpressEncrypt" }; 

BOOL g_adwQueueQos[] = { WMIMSG_FLAG_QOS_GUARANTEED,
                         WMIMSG_FLAG_QOS_EXPRESS,
                         WMIMSG_FLAG_QOS_GUARANTEED,
                         WMIMSG_FLAG_QOS_EXPRESS,
                         WMIMSG_FLAG_QOS_GUARANTEED,
                         WMIMSG_FLAG_QOS_EXPRESS };

BOOL g_abQueueAuth[] = { FALSE, FALSE, TRUE, TRUE, TRUE, TRUE };

extern BOOL AllowUnauthenticatedEvents();

/**************************************************************************
  CFwdEventProv
***************************************************************************/

CFwdEventProv::CFwdEventProv( CLifeControl* pCtl, IUnknown* pUnk )
: CUnk( pCtl, pUnk ), m_XErrorSink( this ), m_XSendReceive( this ), 
  m_XProv( this ), m_XQuery( this ), m_XInit( this ),
  m_lMachineProp(-1), m_lConsumerProp(-1), m_lNamespaceProp(-1), 
  m_lAuthProp(-1), m_lAccountProp(-1), m_lTimeProp(-1), m_lSDProp(-1)
{
}

CFwdEventProv::~CFwdEventProv()
{

}

void* CFwdEventProv::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemEventProvider )
    {
        return &m_XProv;
    }
    else if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInit;
    }
    else if ( riid == IID_IWmiMessageTraceSink )
    {
        return &m_XErrorSink;
    }
    else if ( riid == IID_IWmiMessageSendReceive )
    {
        return &m_XSendReceive;
    }
    else if ( riid == IID_IWbemEventProviderQuerySink )
    {
        return &m_XQuery;
    }
    return NULL;
}

HRESULT CFwdEventProv::Init( IWbemServices* pSvc, 
                             IWbemProviderInitSink* pInitSink )
{
    ENTER_API_CALL

    HRESULT hr;

    m_pSvc = pSvc;

    hr = pSvc->GetObject( g_wszEventClass, 
                          0, 
                          NULL, 
                          &m_pEventClass, 
                          NULL );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get handles for all the properties in the event .
    //

    CWbemPtr<_IWmiObject> pWmiEventClass;

    hr = m_pEventClass->QueryInterface( IID__IWmiObject, 
                                        (void**)&pWmiEventClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszMachineProp,
                                              0, 
                                              NULL, 
                                              &m_lMachineProp );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszConsumerProp, 
                                              0, 
                                              NULL, 
                                              &m_lConsumerProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszNamespaceProp, 
                                              0, 
                                              NULL, 
                                              &m_lNamespaceProp );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszAuthenticatedProp, 
                                              0, 
                                              NULL, 
                                              &m_lAuthProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszSDProp, 
                                              0, 
                                              NULL, 
                                              &m_lSDProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszAccountProp, 
                                              0, 
                                              NULL, 
                                              &m_lAccountProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszTimeProp, 
                                              0, 
                                              NULL, 
                                              &m_lTimeProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = CoCreateInstance( CLSID_WmiSmartObjectUnmarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&m_pMrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );

    EXIT_API_CALL
}

HRESULT CFwdEventProv::InitializeEvent( IWbemClassObject* pOriginalEvent,
                                        IWmiMessageReceiverContext* pRecvCtx,
                                        LPCWSTR wszConsumer,
                                        LPCWSTR wszNamespace,
                                        PBYTE pSD,
                                        ULONG cSD,
                                        IWbemClassObject* pEvent ) 
{
    HRESULT hr;
    VARIANT var;

    CWbemPtr<_IWmiObject> pWmiEvent;
    hr = pEvent->QueryInterface( IID__IWmiObject, (void**)&pWmiEvent );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    SYSTEMTIME st;
    BYTE achBuff[256];
    CBuffer Buff( achBuff, 256, FALSE );

    WCHAR* pwchBuff = (WCHAR*)Buff.GetRawData();
    ULONG cBuff =  Buff.GetSize() / 2;

    //
    // Time Sent
    //

    hr = pRecvCtx->GetTimeSent( &st );

    if ( FAILED(hr) )
    {
        return hr;
    }

    StringCchPrintfW( pwchBuff,
                      cBuff,
                      L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d+000",
                      st.wYear, st.wMonth, st.wDay, st.wHour,
                      st.wMinute, st.wSecond, 0 );
    
    hr = pWmiEvent->WritePropertyValue( m_lTimeProp, 
                                        (wcslen(pwchBuff)+1)*2,
                                        Buff.GetRawData() );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Sending Machine
    //

    pwchBuff = (WCHAR*)Buff.GetRawData();
    cBuff = Buff.GetSize() / 2;

    hr = pRecvCtx->GetSendingMachine( pwchBuff, cBuff, &cBuff );

    if ( hr == WBEM_S_FALSE )
    {
        hr = Buff.SetSize( cBuff*2 ); // note: size for wchars

        if ( FAILED(hr) )
        {
            return hr;
        }

        pwchBuff = (WCHAR*)Buff.GetRawData();
        cBuff = Buff.GetSize() / 2;
        
        hr = pRecvCtx->GetSendingMachine( pwchBuff, cBuff, &cBuff );
    }

    if ( SUCCEEDED(hr) && cBuff > 0 ) 
    {
        hr = pWmiEvent->WritePropertyValue( m_lMachineProp, 
                                            cBuff*2,
                                            Buff.GetRawData() ); 
                                           
    }

    //
    // Sender Authenticated
    //

    hr = pRecvCtx->IsSenderAuthenticated();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEvent->WriteDWORD( m_lAuthProp, hr == S_OK ? 1 : 0 );  

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Sender Identity
    //

    ULONG cSid;
    hr = pRecvCtx->GetSenderId( Buff.GetRawData(), Buff.GetSize(), &cSid );
    
    if ( hr == WBEM_S_FALSE )
    {
        hr = Buff.SetSize( cSid );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pRecvCtx->GetSenderId( Buff.GetRawData(), Buff.GetSize(), &cSid );
    }

    if ( SUCCEEDED(hr) && cSid > 0 )
    {
        hr = pWmiEvent->SetArrayPropRangeByHandle( m_lAccountProp,
                                                   WMIARRAY_FLAG_ALLELEMENTS,
                                                   0,
                                                   cSid,
                                                   cSid,
                                                   Buff.GetRawData() );
    }

    //
    // Original Event
    //

    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pOriginalEvent;

    hr = pEvent->Put( g_wszEventProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Sending Consumer Name
    // 

    if ( wszConsumer != NULL )
    {
        hr = pWmiEvent->WritePropertyValue( m_lConsumerProp, 
                                            (wcslen(wszConsumer)+1)*2, 
                                            PBYTE(wszConsumer) );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Sending Consumer Namespace
    // 

    if ( wszNamespace != NULL )
    {
        hr = pWmiEvent->WritePropertyValue( m_lNamespaceProp, 
                                            (wcslen(wszNamespace)+1)*2,
                                            PBYTE(wszNamespace) );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // set the security descriptor on the event if specified. 
    // 

    if ( cSD > 0 )
    {
        hr = pWmiEvent->SetArrayPropRangeByHandle( m_lSDProp,
                                                   WMIARRAY_FLAG_ALLELEMENTS,
                                                   0,
                                                   cSD,
                                                   cSD,
                                                   pSD );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CFwdEventProv::ProvideEvents( IWbemObjectSink* pSink, long lFlags )
{
    ENTER_API_CALL

    m_pEventSink = pSink;

    //
    // we were waiting to obtain the sink before starting up the 
    // receivers.
    //

    DEBUGTRACE((LOG_ESS,"FEVPROV: Begin Initializing.\n"));

    BOOL bAllowUnauth = AllowUnauthenticatedEvents();

    HRESULT hr;
#ifdef __WHISTLER_UNCUT
    hr = InitializeQueues( bAllowUnauth );

    if ( FAILED(hr) )
    {
        return hr;
    }
#endif

    hr = InitializeReceivers( bAllowUnauth );

    DEBUGTRACE((LOG_ESS,"FEVPROV: End Initializing.\n"));

    return hr;

    EXIT_API_CALL
}

HRESULT CFwdEventProv::InitializeQueues( BOOL bAllowUnauth )
{
    HRESULT hr;

    DWORD dwQuota = 0xffffffff;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = CoCreateInstance( CLSID_WmiMessageQueueManager,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageQueueManager,
                           (void**)&pQueueMgr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    for( int i=0 ; i < sizeof(g_adwQueueQos)/sizeof(DWORD); i++ )
    {
        if ( g_abQueueAuth[i] || (!g_abQueueAuth[i] && bAllowUnauth) )
        {
            hr = pQueueMgr->Create( g_awszQueueNames[i], 
                                    g_guidQueueType, 
                                    g_abQueueAuth[i], 
                                    g_adwQueueQos[i], 
                                    dwQuota, 
                                    pSecDesc );

            if ( FAILED(hr) && hr != WBEM_E_ALREADY_EXISTS )
            {
                ERRORTRACE((LOG_ESS,"FEVPROV: Could not create/open queue %S, "
                                    "HR=0x%x\n", g_awszQueueNames[i], hr ));
            }
        }
        else
        {
            //
            // since we're not going to allow unauthenticated queues, make 
            // sure that we delete any existing ones so that there's not an 
            // open unauthenticated entry point on the machine.  There will
            // only be a queue actually there to clean up if we're 
            // transitioning from unauthenticated allowed to not allowed.
            // 
            
            pQueueMgr->Destroy( g_awszQueueNames[i] );
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::InitializeReceivers( BOOL bAllowUnauth )
{
    HRESULT hr;

    DWORD dwFlags = 0;

    if ( !bAllowUnauth )
    {
        dwFlags |= WMIMSG_FLAG_RCVR_SECURE_ONLY;
    }

    //
    // Initialize Sync DCOM Receiver.
    //

    hr = CoCreateInstance( CLSID_WmiMessageRpcReceiver,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageReceiver,
                           (void**)&m_pDcomRcvr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDcomRcvr->Open( 
                   L"7879E40D-9FB5-450a-8A6D-00C89F349FCE@ncacn_ip_tcp:",
                   WMIMSG_FLAG_QOS_SYNCHRONOUS | dwFlags,
                   NULL,
                   &m_XSendReceive );

    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS,"FEVPROV: Could not open dcom rcvr, "
                            "HR=0x%x\n", hr ));
        return hr;
    }

#ifdef __WHISTLER_UNCUT
    for( int i=0; i < sizeof(g_adwQueueQos)/sizeof(DWORD); i++ )
    {
        if ( g_abQueueAuth[i] || (!g_abQueueAuth[i] && bAllowUnauth) )
        {
            hr = CoCreateInstance( CLSID_WmiMessageMsmqReceiver,
                                   NULL,
                                   CLSCTX_INPROC,
                                   IID_IWmiMessageReceiver,
                                   (void**)&m_apQueueRcvr[i] );
            if ( FAILED(hr) )
            {
                return hr;
            }

            hr = m_apQueueRcvr[i]->Open( g_awszQueueNames[i],
                                         g_adwQueueQos[i] | dwFlags,
                                         NULL,
                                         &m_XSendReceive );
    
            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"FEVPROV: Could not open rcvr for queue %S"
                            ", HR=0x%x\n", g_awszQueueNames[i], hr ));
            }
        }
    }
#endif

    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::NewQuery( DWORD dwId, LPWSTR wszQuery )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::CancelQuery( DWORD dwId )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::Receive( PBYTE pData, 
                                ULONG cData,
                                PBYTE pAuxData,
                                ULONG cAuxData,
                                DWORD dwStatus,
                                IUnknown* pCtx )
{
    ENTER_API_CALL

    HRESULT hr;

    CBuffer DataStrm( pData, cData, FALSE );
    CBuffer HdrStrm( pAuxData, cAuxData, FALSE );

    //
    // read and verify msg hdr - don't do much with it though - it mostly
    // contains info for nack event prov.
    //

    CFwdMsgHeader FwdHdr;

    hr = FwdHdr.Unpersist( HdrStrm );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // read objects and generate event.
    //

    #define MAXEVENTS 256

    IWbemClassObject* apEvents[MAXEVENTS];
    
    DWORD i=0;
    hr = S_OK;
    
    CWbemPtr<IWmiMessageReceiverContext> pRecvCtx;

    if ( pCtx == NULL || pCtx->QueryInterface( IID_IWmiMessageReceiverContext, 
                                               (void**)&pRecvCtx ) != S_OK )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // if possible, convert our recv ctx to com context so that ess can 
    // impersonate the sender if necessary.  
    // 

    IWbemCallSecurity* pSec = NULL;

    hr = pRecvCtx->ImpersonateSender();

    if ( SUCCEEDED(hr) )
    {
        pSec = CWbemCallSecurity::CreateInst(); // ref is 1 on create.

        if ( pSec == NULL )
        {
            pRecvCtx->RevertToSelf();
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = pSec->CloneThreadContext( FALSE );

        pRecvCtx->RevertToSelf();

        IUnknown* pUnkSec = NULL;

        if ( SUCCEEDED(hr) )
        {
            hr = CoSwitchCallContext( pSec, &pUnkSec );
        }

        if ( FAILED(hr) )
        {
            pSec->Release();
            return hr;
        }

        _DBG_ASSERT( pUnkSec == NULL );
    }
    else if ( pRecvCtx->IsSenderAuthenticated() == S_FALSE )
    {
        //
        // it is expected that ImpersonateClient will fail if 
        // the sender is not authenticated.
        //
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        //
        // something else wrong here.
        //
        return WMIMSG_E_AUTHFAILURE;
    }

    const PSECURITY_DESCRIPTOR pSD = FwdHdr.GetTargetSD();
    ULONG cSD = FwdHdr.GetTargetSDLength();

    ULONG iData = DataStrm.GetIndex();

    while( i < FwdHdr.GetNumObjects() && SUCCEEDED(hr) )
    {
        for( DWORD j=0; j < MAXEVENTS && j+i < FwdHdr.GetNumObjects(); j++ )
        {
            ULONG cUsed;
            CWbemPtr<IWbemClassObject> pOriginalEvent;

            hr = m_pMrsh->Unpack( cData-iData, 
                                  pData+iData, 
                                  0, 
                                  &pOriginalEvent, 
                                  &cUsed );
            if ( FAILED(hr) )
            {
                break;
            }

            iData += cUsed;

            CWbemPtr<IWbemClassObject> pEvent;

            hr = m_pEventClass->SpawnInstance( NULL, &pEvent );

            if ( FAILED(hr) )
            {
                break;
            }

            hr = InitializeEvent( pOriginalEvent, 
                                  pRecvCtx, 
                                  FwdHdr.GetConsumer(), 
                                  FwdHdr.GetNamespace(),
                                  PBYTE(pSD),
                                  cSD,
                                  pEvent );

            if ( FAILED(hr) )
            {
                break;
            }

            pEvent->AddRef();
            apEvents[j] = pEvent;
        }

        i += j;

        if ( SUCCEEDED(hr) )
        {
            hr = m_pEventSink->Indicate( j, apEvents );
        }

        for( DWORD k=0; k < j; k++ )
        {
            apEvents[k]->Release();
        }
    }

    //
    // if we switched the com call context, then switch it back.
    //

    if ( pSec != NULL )
    {
        IUnknown* pDummy;
        
        if ( SUCCEEDED(CoSwitchCallContext( NULL, &pDummy ) ) )
        {
            _DBG_ASSERT( pDummy == pSec );
            pSec->Release();
        }
    }

    return hr;

    EXIT_API_CALL
}   

HRESULT CFwdEventProv::HandleRecvError( HRESULT hr, LPCWSTR wszError )
{
    //
    // right now just log to ESS log.
    //
    ERRORTRACE((LOG_ESS,"FEVPROV: RECV Error, ErrorString=%S, HR=0x%x\n",
                wszError, hr ));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fwdhdr.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wmimsg.h>
#include "fwdhdr.h"

const DWORD g_dwSig = 0x66696d77;
const BYTE g_chVersionMajor = 1;
const BYTE g_chVersionMinor = 0;
const BYTE g_achPad[] = { 0, 0, 0 };

/**************************************************************************
  CFwdMsgHeader
***************************************************************************/


CFwdMsgHeader::CFwdMsgHeader()
{
    ZeroMemory( this, sizeof( CFwdMsgHeader ) );
}

CFwdMsgHeader::CFwdMsgHeader( DWORD dwNumObjs, 
                              DWORD dwQos,
                              BOOL bAuth,
                              BOOL bEncrypt,
                              GUID& rguidExecution,
                              LPCWSTR wszConsumer,
                              LPCWSTR wszNamespace,
                              PBYTE pTargetSD,
                              ULONG cTargetSD )
: m_dwNumObjs(dwNumObjs), m_chQos(char(dwQos)), 
  m_chEncrypt(char(bEncrypt)), m_wszConsumer( wszConsumer ), 
  m_guidExecution(rguidExecution), m_chAuth(char(bAuth)),
  m_pTargetSD( pTargetSD ), m_cTargetSD( cTargetSD ),
  m_wszNamespace( wszNamespace )
{

}

HRESULT CFwdMsgHeader::Persist( CBuffer& rStrm )
{
    HRESULT hr;

    //
    // write signature.
    //

    hr = rStrm.Write( &g_dwSig, 4, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write version major.
    //

    hr = rStrm.Write( &g_chVersionMajor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // write version minor.
    //

    hr = rStrm.Write( &g_chVersionMinor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write reserved flags ( currently not used ).
    //

    DWORD dwReserved = 0;
    
    hr = rStrm.Write( &dwReserved, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // write num events contained in data.
    //

    hr = rStrm.Write( &m_dwNumObjs, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write Qos used 
    //

    hr = rStrm.Write( &m_chQos, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write if Auth was used.
    //

    hr = rStrm.Write( &m_chAuth, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write if Encryption was used.
    //

    hr = rStrm.Write( &m_chEncrypt, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // pad so that subsequent strings will at least be on 2 byte boundaries
    //

    hr = rStrm.Write( g_achPad, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write execution id.
    //

    hr = rStrm.Write( &m_guidExecution, sizeof(GUID), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }    
    
    //
    // write name of forwarding consumer
    //

    hr = rStrm.WriteLPWSTR( m_wszConsumer );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write the namespace of the forwarding consumer
    // 

    hr = rStrm.WriteLPWSTR( m_wszNamespace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write SD used for the event at Target. 
    //

    hr = rStrm.Write( &m_cTargetSD, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_cTargetSD > 0 )
    {
        hr = rStrm.Write( m_pTargetSD, m_cTargetSD, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFwdMsgHeader::Unpersist( CBuffer& rStrm )
{
    HRESULT hr;
    DWORD dwSig;
    BYTE chVersionMajor, chVersionMinor;

    //
    // read and verify signature.
    //

    hr = rStrm.Read( &dwSig, 4, NULL );

    if ( hr != S_OK || dwSig != g_dwSig )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read and check version major (currently no check).
    //

    hr = rStrm.Read( &chVersionMajor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    // 
    // read and check version minor (currently no check).
    //

    hr = rStrm.Read( &chVersionMinor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read reserved
    //

    DWORD dwReserved;

    hr = rStrm.Read( &dwReserved, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    //
    // read num events contained in data.
    //

    hr = rStrm.Read( &m_dwNumObjs, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read Qos used 
    //

    hr = rStrm.Read( &m_chQos, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read if Auth was used.
    //

    hr = rStrm.Read( &m_chAuth, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read if Encryption was used.
    //

    hr = rStrm.Read( &m_chEncrypt, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read byte pad 
    //

    BYTE chPad;
    hr = rStrm.Read( &chPad, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read execution id.
    //

    hr = rStrm.Read( &m_guidExecution, sizeof(GUID), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }    

    //
    // read name of forwarding consumer
    //

    hr = rStrm.ReadLPWSTR( m_wszConsumer );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read namespace of forwarding consumer
    //

    hr = rStrm.ReadLPWSTR( m_wszNamespace );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read SD to use for signaling event
    //

    hr = rStrm.Read( &m_cTargetSD, sizeof(DWORD), NULL );

    if ( hr != S_OK || m_cTargetSD > rStrm.GetSize() - rStrm.GetIndex() )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    if ( m_cTargetSD > 0 )
    {
        m_pTargetSD = rStrm.GetRawData() + rStrm.GetIndex();
        rStrm.Advance( m_cTargetSD );
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\localloc.cpp ===
#include "precomp.h"
#include <arena.h>
#include <corex.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fwdhdr.h ===
#ifndef __FWDHDR_H__
#define __FWDHDR_H__

#include <buffer.h>
#include <comutl.h>
#include <wbemcli.h>

/**************************************************************************
  CFwdMsgHeader
***************************************************************************/

class CFwdMsgHeader
{
    DWORD m_dwNumObjs;
    char m_chQos;
    char m_chAuth;
    char m_chEncrypt;
    GUID m_guidExecution;
    LPCWSTR m_wszConsumer;
    LPCWSTR m_wszNamespace;
    PBYTE m_pTargetSD;
    DWORD m_cTargetSD;

public:

    CFwdMsgHeader();

    CFwdMsgHeader( DWORD dwNumObjs, 
                   DWORD dwQos,
                   BOOL bAuth,
                   BOOL bEncrypt,
                   GUID& rguidExecution,
                   LPCWSTR wszConsumer,
                   LPCWSTR wszNamespace,
                   PBYTE pTargetSD,
                   DWORD cTargetSD );

    DWORD GetNumObjects() { return m_dwNumObjs; }
    DWORD GetQos() { return m_chQos; }
    BOOL GetAuthentication() { return m_chAuth; }
    BOOL GetEncryption() { return m_chEncrypt; }
    GUID& GetExecutionId() { return m_guidExecution; }
    LPCWSTR GetConsumer() { return m_wszConsumer; }
    LPCWSTR GetNamespace() { return m_wszNamespace; }
    PBYTE GetTargetSD() { return m_pTargetSD; }
    DWORD GetTargetSDLength() { return m_cTargetSD; }

    HRESULT Persist( CBuffer& rStrm );
    HRESULT Unpersist( CBuffer& rStrm );
};

#endif __FWDHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fwdmain.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <arrtempl.h>
#include "fconprov.h"
#include "fevprov.h"

// Function pointer type used with LoadMofFiles entrypoint in wbemupgd.dll
typedef BOOL ( WINAPI *PFN_LOAD_MOF_FILES )(wchar_t* pComponentName, const char* rgpszMofFilename[]);

// {AD1B46E8-0AAC-401b-A3B8-FCDCF8186F55}
static const CLSID CLSID_FwdConsProvider = 
{0xad1b46e8, 0xaac, 0x401b, {0xa3, 0xb8, 0xfc, 0xdc, 0xf8, 0x18, 0x6f, 0x55}};

// {7879E40D-9FB5-450a-8A6D-00C89F349FCE}
static const CLSID CLSID_FwdEventProvider =  
{0x7879e40d, 0x9fb5, 0x450a, {0x8a, 0x6d, 0x0, 0xc8, 0x9f, 0x34, 0x9f, 0xce}};

#define REG_WBEM_FWD TEXT("Software\\Microsoft\\WBEM\\FWD")

class CFwdConsProviderServer : public CComServer
{
protected:

    void Register();
    void Unregister();
    HRESULT Initialize();
    void Uninitialize() { CFwdConsProv::UninitializeModule(); }

} g_Server;


BOOL AllowUnauthenticatedEvents()
{
    //
    // look up in registry if we will allow unauthenticated forwarded events.
    // 

    HKEY hKey;
    LONG lRes;
    BOOL bAllowUnauth = FALSE;

    lRes = RegOpenKey( HKEY_LOCAL_MACHINE, REG_WBEM_FWD, &hKey );

    if ( lRes == ERROR_SUCCESS )
    {
        DWORD dwAllowUnauth;
        DWORD dwBuffSize = 4;

        lRes = RegQueryValueEx( hKey, 
                                TEXT("AllowUnauthenticatedEvents"), 
                                0, 
                                NULL, 
                                (BYTE*)&dwAllowUnauth, 
                                &dwBuffSize );

        if ( lRes == ERROR_SUCCESS )
        {
            bAllowUnauth = dwAllowUnauth != 0 ? TRUE : FALSE;
        }
        
        RegCloseKey( hKey );
    }

    return bAllowUnauth;
}


HRESULT CFwdConsProviderServer::Initialize()
{
    ENTER_API_CALL

    HRESULT hr;

    hr = CFwdConsProv::InitializeModule();

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<CBaseClassFactory> pFactory;

    pFactory = new CSimpleClassFactory<CFwdConsProv>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_FwdConsProvider, 
                      pFactory,
                      TEXT("Forwarding Consumer Provider"), 
                      TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pFactory = new CClassFactory<CFwdEventProv>( GetLifeControl() );

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_FwdEventProvider, 
                      pFactory,
                      TEXT("Forwarding Event Provider"), 
                      TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

#ifdef __WHISTLER_UNCUT
    
    pFactory = new CClassFactory<CFwdAckEventProv>( GetLifeControl() );

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_FwdAckEventProvider, 
                      pFactory,
                      TEXT("Forwarding Ack Event Provider"), 
                      TRUE );

#endif

    return hr;
    
    EXIT_API_CALL
}

void CFwdConsProviderServer::Register()
{    
    HKEY hKey;
    LONG lRes;
    DWORD dwDisposition;

    lRes = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                           REG_WBEM_FWD,
                           0,
                           NULL,
                           0,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           &dwDisposition );

    if ( lRes == ERROR_SUCCESS )
    {
        if ( dwDisposition == REG_CREATED_NEW_KEY )
        {
            DWORD dwAllowUnauth = 0;

            lRes = RegSetValueEx( hKey, 
                                  TEXT("AllowUnauthenticatedEvents"), 
                                  0, 
                                  REG_DWORD,
                                  (BYTE*)&dwAllowUnauth, 
                                  4 );
        }

        RegCloseKey( hKey );
            
        if ( lRes == ERROR_SUCCESS )
        {
            //
            //  Load mofs and mfls during registration
            //
            HINSTANCE hinstWbemupgd = LoadLibrary(L"wbemupgd.dll");
            if (hinstWbemupgd)
            {
                PFN_LOAD_MOF_FILES pfnLoadMofFiles = (PFN_LOAD_MOF_FILES) GetProcAddress(hinstWbemupgd, "LoadMofFiles"); // no wide version of GetProcAddress
                if (pfnLoadMofFiles)
                {
                    wchar_t*    wszComponentName = L"Fwdprov";
                    const char* rgpszMofFilename[] = 
                    {
                        "fconprov.mof",
                        "fconprov.mfl",
                        "fevprov.mof",
                        "fevprov.mfl",
                        NULL
                    };
                    
                    pfnLoadMofFiles(wszComponentName, rgpszMofFilename);
                }

                FreeLibrary(hinstWbemupgd);
            }
        }
    }
}

void CFwdConsProviderServer::Unregister()
{
    RegDeleteKey( HKEY_LOCAL_MACHINE, REG_WBEM_FWD );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\makefile.inc ===
$(O)\fconprov.mof: fconprov.mof
    copy copyright.mof+fconprov.mof $(O)\fconprov.mof

$(O)\fconprov.mfl: fconprov.mof
    copy copyright.mof+fconprov.mfl $(O)\fconprov.mfl

$(O)\fevprov.mof $(O)\fevprov.mfl: fevprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\fevprovTmp.mof -MFL:$(O)\fevprovTmp.mfl fevprov.mof
    copy copyright.mof+$(O)\fevprovTmp.mof+$(O)\fevprovTmp.mfl $(O)\fevprov.mof
    copy copyright.mof+$(O)\fevprovTmp.mfl $(O)\fevprov.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\precomp.h ===
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <ole2.h>
#include <winsock2.h>
#include <windows.h>
#include <wincrypt.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\kerneltraceprovider.h ===
// KernelTraceProvider.h : Declaration of the CKernelTraceProvider

#ifndef __KERNELTRACEPROVIDER_H_
#define __KERNELTRACEPROVIDER_H_

#include "resource.h"       // main symbols
#include "ObjAccess.h"
#include <Sync.h>

_COM_SMARTPTR_TYPEDEF(IWbemEventSink, __uuidof(IWbemEventSink));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

struct EVENT_TRACE_PROPERTIES_EX : public EVENT_TRACE_PROPERTIES
{
    EVENT_TRACE_PROPERTIES_EX()
    {
        ZeroMemory(this, sizeof(*this));

        Wnode.BufferSize = sizeof(*this);
        Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        LogFileNameOffset = (DWORD) ((LPBYTE) szLogFileName - (LPBYTE) this);
        LoggerNameOffset = (DWORD) ((LPBYTE) szLoggerName - (LPBYTE) this);
    }
        
    TCHAR szLogFileName[MAX_PATH];
    TCHAR szLoggerName[MAX_PATH];
};
    
/////////////////////////////////////////////////////////////////////////////
// CKernelTraceProvider
class ATL_NO_VTABLE CKernelTraceProvider : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CKernelTraceProvider, &CLSID_KernelTraceProvider>,
	public IWbemProviderInit,
    public IWbemEventProvider,
    public IWbemEventProviderSecurity
{
public:
	CKernelTraceProvider();
        void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_KERNELTRACEPROVIDER)
DECLARE_NOT_AGGREGATABLE(CKernelTraceProvider)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CKernelTraceProvider)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
	COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
END_COM_MAP()


// IWbemProviderInit
public:
    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);


// IWbemEventProvider
public:
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags);


    enum SINK_TYPE
    {
        //SINK_PROCESS_CREATION,
        //SINK_PROCESS_DELETION,
        SINK_PROCESS_START,
        SINK_PROCESS_STOP,

        //SINK_THREAD_CREATION,
        //SINK_THREAD_DELETION,
        SINK_THREAD_START,
        SINK_THREAD_STOP,

        SINK_MODULE_LOAD,
        
        SINK_COUNT
    };

// IWbemEventProviderSecurity
public:
    HRESULT STDMETHODCALLTYPE AccessCheck( 
        /* [in] */ WBEM_CWSTR wszQueryLanguage,
        /* [in] */ WBEM_CWSTR wszQuery,
        /* [in] */ long lSidLength,
        /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid);


// Implementation
protected:
    IWbemEventSinkPtr   m_pSinks[SINK_COUNT];
    IWbemServicesPtr    m_pNamespace;
    EVENT_TRACE_PROPERTIES_EX 
                        m_properties;
    TRACEHANDLE         m_hSession,
                        m_hTrace;
    BOOL                m_bDone;
    HANDLE              m_hProcessTraceThread;
    CCritSec            m_cs;

    // Process events
    CObjAccess          //m_eventProcessInstCreation,
                        //m_eventProcessInstDeletion,
                        //m_objProcessCreated,
                        //m_objProcessDeleted,
                        m_eventProcessStart,
                        m_eventProcessStop;

    // Thread events
    CObjAccess          //m_eventThreadInstCreation,
                        //m_eventThreadInstDeletion,
                        //m_objThread,
                        m_eventThreadStart,
                        m_eventThreadStop;

    // Module load
    CObjAccess          m_eventModuleLoad;

    HRESULT InitEvents();
    HRESULT InitTracing();
    void StopTracing();

    static DWORD WINAPI DoProcessTrace(CKernelTraceProvider *pThis);
    static void WINAPI OnProcessEvent(PEVENT_TRACE pEvent);
    static void WINAPI OnThreadEvent(PEVENT_TRACE pEvent);
    static void WINAPI OnImageEvent(PEVENT_TRACE pEvent);
};

#endif //__KERNELTRACEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\krnlprov.cpp ===
// krnlprov.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f krnlprovps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "krnlprov.h"

#include "krnlprov_i.c"
#include "KernelTraceProvider.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_KernelTraceProvider, CKernelTraceProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_KRNLPROVLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\kerneltraceprovider.cpp ===
// KernelTraceProvider.cpp : Implementation of CKernelTraceProvider
#include "precomp.h"
#include "Krnlprov.h"
#include "KernelTraceProvider.h"
#include <GroupsForUser.h>


void Trace(LPCTSTR szFormat, ...)
{
    va_list ap;
    TCHAR szMessage[512];

    va_start(ap, szFormat);
    StringCchVPrintf(szMessage,512,szFormat,ap); 
    va_end(ap);

    StringCchCat(szMessage, 512, TEXT("\n"));

    OutputDebugString(szMessage);
}

/////////////////////////////////////////////////////////////////////////////
// CKernelTraceProvider

// Because the event trace API won't allow you to get back a user-defined 
// value when events are received!
CKernelTraceProvider *g_pThis;

CKernelTraceProvider::CKernelTraceProvider()
 : m_bDone(FALSE), m_hProcessTraceThread(NULL)
{
    g_pThis = this;
}

void CKernelTraceProvider::FinalRelease()
{
    StopTracing();
}

HRESULT STDMETHODCALLTYPE CKernelTraceProvider::Initialize( 
    /* [in] */ LPWSTR pszUser,
    /* [in] */ LONG lFlags,
    /* [in] */ LPWSTR pszNamespace,
    /* [in] */ LPWSTR pszLocale,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    HRESULT hr = S_OK;

    m_pNamespace = pNamespace;

    // Tell Windows Management our initialization status.
    pInitSink->SetStatus(SUCCEEDED(hr) ? WBEM_S_INITIALIZED : WBEM_E_FAILED, 0);
    
    return hr;
}

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

HRESULT CKernelTraceProvider::InitEvents()
{
    /////////////////////////////////////////////////////////////////////////
    // Win32_ProcessStartTrace

    LPCWSTR szProcessStartTraceNames[] =
    {
        L"PageDirectoryBase",
		L"ProcessID",
        L"ParentProcessID",
		L"SessionID",
        L"Sid",
        L"ProcessName"
    };

    m_eventProcessStart.Init(
        m_pNamespace,
        L"Win32_ProcessStartTrace",
        szProcessStartTraceNames,
        COUNTOF(szProcessStartTraceNames),
        CObjAccess::FAILED_PROP_FAIL);


    /////////////////////////////////////////////////////////////////////////
    // Win32_ProcessStopTrace

    LPCWSTR szProcessStopTraceNames[] =
    {
        L"PageDirectoryBase",
		L"ProcessID",
        L"ParentProcessID",
		L"SessionID",
		L"ExitStatus",
        L"Sid",
        L"ProcessName"
    };

    m_eventProcessStop.Init(
        m_pNamespace,
        L"Win32_ProcessStopTrace",
        szProcessStopTraceNames,
        COUNTOF(szProcessStopTraceNames),
        CObjAccess::FAILED_PROP_FAIL);

    /////////////////////////////////////////////////////////////////////////
    // Win32_ThreadStartTrace

    LPCWSTR szThreadStartNames[] =
    {
		L"StackBase",
		L"StackLimit",
		L"UserStackBase",
		L"UserStackLimit",
		L"StartAddr",
		L"Win32StartAddr",
        L"ProcessID",
        L"ThreadID",
		L"WaitMode",
    };

    m_eventThreadStart.Init(
        m_pNamespace,
        L"Win32_ThreadStartTrace",
        szThreadStartNames,
        COUNTOF(szThreadStartNames),
        CObjAccess::FAILED_PROP_FAIL);


    /////////////////////////////////////////////////////////////////////////
    // Win32_ThreadStopTrace

    LPCWSTR szThreadStopNames[] =
    {
        L"ProcessID",
        L"ThreadID",
    };

    m_eventThreadStop.Init(
        m_pNamespace,
        L"Win32_ThreadStopTrace",
        szThreadStopNames,
        COUNTOF(szThreadStopNames),
        CObjAccess::FAILED_PROP_FAIL);


    /////////////////////////////////////////////////////////////////////////
    // Win32_ModuleLoadTrace

    LPCWSTR szModuleNames[] =
    {
        L"ImageBase",
        L"ImageSize",
        L"ProcessID",
        L"FileName",
    };

    m_eventModuleLoad.Init(
        m_pNamespace,
        L"Win32_ModuleLoadTrace",
        szModuleNames,
        COUNTOF(szModuleNames),
        CObjAccess::FAILED_PROP_FAIL);

    return S_OK;
}

#define REALTIME
#define BUFFER_SIZE 64
#define MIN_BUFFERS 20
#define MAX_BUFFERS 200
#define FLUSH_TIME  1

//#define USE_KERNEL_GUID

#ifdef USE_KERNEL_GUID
#define LOGGER_NAME           L"NT Kernel Logger"
#define WMI_KERNEL_TRACE_GUID guidSystemTrace
#define ENABLE_FLAGS          EVENT_TRACE_FLAG_PROCESS | EVENT_TRACE_FLAG_THREAD | EVENT_TRACE_FLAG_IMAGE_LOAD
#else
#define LOGGER_NAME           L"WMI Event Logger"
#define WMI_KERNEL_TRACE_GUID guidWMITrace
#define ENABLE_FLAGS          0
#endif

#ifndef REALTIME
#define MAX_FILE_SIZE         20     // In MB
#define LOGGER_FILE           L"c:\\temp\\wmi.etl"
#endif

GUID guidProcess = 
    // {3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c}
    {0x3d6fa8d0, 0xfe05, 0x11d0, 0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c};

GUID guidThread = 
    // {3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c}
    {0x3d6fa8d1, 0xfe05, 0x11d0, 0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c};

GUID guidImage = 
    // {2cb15d1d-5fc1-11d2-abe1-00a0c911f518}
    {0x2cb15d1d, 0x5fc1, 0x11d2, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x11, 0xf5, 0x18};

GUID guidSystemTrace = 
    // 9e814aad-3204-11d2-9a82-006008a86939 
    {0x9e814aad, 0x3204, 0x11d2, 0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39};

GUID guidWMITrace = 
    // 44608a51-1851-4456-98b2-b300e931ee41 
    {0x44608a51, 0x1851, 0x4456, 0x98, 0xb2, 0xb3, 0x00, 0xe9, 0x31, 0xee, 0x41};

HRESULT CKernelTraceProvider::InitTracing()
{
    DWORD status;
    
    m_bDone = FALSE;

    // See if the logger is already running.  If not, set it up.
    if (QueryTrace(
        NULL,
        LOGGER_NAME,
        &m_properties) != ERROR_SUCCESS)
    {
        // Initialize property values here.
#ifdef REALTIME
        m_properties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
        StringCchCopy( m_properties.szLoggerName, MAX_PATH, LOGGER_NAME );
#else
        m_properties.LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
        //properties.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;

        // MaximumFileSize is in MB.
        m_properties.MaximumFileSize = MAX_FILE_SIZE;

        StringCchCopy( m_properties.szLogFileName, MAX_PATH, LOGGER_FILE );
#endif

        m_properties.Wnode.Guid = WMI_KERNEL_TRACE_GUID;
    
        // Set the buffer size.  BufferSize is in KB.
        m_properties.BufferSize = BUFFER_SIZE;
        m_properties.MinimumBuffers = MIN_BUFFERS;
        m_properties.MaximumBuffers = MAX_BUFFERS;
    
        // Number of seconds before timer is flushed.
        m_properties.FlushTimer = FLUSH_TIME;

        m_properties.EnableFlags |= ENABLE_FLAGS;

        // Start tracing.
        status = 
            StartTrace(
                &m_hSession,
                LOGGER_NAME,
                &m_properties);

        if (status != ERROR_SUCCESS) 
        {
            TRACE(L"StartTrace error=%d (GetLastError=0x%x)",
                status, GetLastError());

            return WBEM_E_FAILED;
        }
    }
    else
        m_hSession = NULL;

    EVENT_TRACE_LOGFILE eventFile;

    ZeroMemory(&eventFile, sizeof(eventFile));

    //eventFile.BufferCallback = BufferCallback;
    //eventFile.EventCallback = DumpEvent;
    eventFile.LoggerName = (LPTSTR) LOGGER_NAME;

#ifdef REALTIME
    eventFile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
#else
    eventFile.LogFileMode = 0;
    eventFile.LogFileName = (LPTSTR) LOGGER_FILE;
#endif


    SetTraceCallback(&guidProcess, OnProcessEvent);
    SetTraceCallback(&guidThread, OnThreadEvent);
    SetTraceCallback(&guidImage, OnImageEvent);

    m_hTrace = OpenTrace(&eventFile);
    
    TRACE(L"Ready to call ProcessTrace (m_hTrace = %d)...\n", m_hTrace);

    DWORD dwID;

    m_hProcessTraceThread =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) DoProcessTrace,
            this,
            0,
            &dwID);

    if ( m_hProcessTraceThread == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return S_OK;
}

DWORD WINAPI CKernelTraceProvider::DoProcessTrace(CKernelTraceProvider *pThis)
{
#ifndef REALTIME
    FILETIME filetime;

    GetSystemTimeAsFileTime(&filetime);
#endif

    while(!pThis->m_bDone)
    {
        DWORD status;

        status =
            ProcessTrace(
                &pThis->m_hTrace,
                1,
#ifdef REALTIME
                NULL,
#else
                &filetime, 
#endif
                NULL);

#ifndef REALTIME
        // Save this off for our next all.
        GetSystemTimeAsFileTime(&filetime);
#endif

        if (status != ERROR_SUCCESS) 
        {
            TRACE(L"Error processing with status=%dL (GetLastError=0x%x)",
                status, GetLastError());
            
            break;
        }
        else
        {
#ifndef REALTIME
            TRACE(L"ProcessTrace exited successfully, sleeping...");
            
            Sleep(5000);
#endif
        }
    }

    TRACE(L"Exiting StartTracing.");

    return 0;
}

void CKernelTraceProvider::StopTracing()
{
    CInCritSec cs(&g_pThis->m_cs);
    DWORD      status;
    
    m_bDone = TRUE;

    RemoveTraceCallback(&guidProcess);
    RemoveTraceCallback(&guidThread);
    RemoveTraceCallback(&guidImage);

    status = CloseTrace(m_hTrace);

    status = 
        StopTrace(
            m_hSession,
            LOGGER_NAME,
            &m_properties);

    if (status != ERROR_SUCCESS) 
    {
        TRACE(L"StopTrace error=%d (GetLastError=0x%x)\n",
            status, GetLastError());
    }
    
    if ( m_hProcessTraceThread != NULL )
    {
        WaitForSingleObject( m_hProcessTraceThread, INFINITE );
        CloseHandle( m_hProcessTraceThread );
    }
}

const LPCWSTR szQueries[CKernelTraceProvider::SINK_COUNT] =
{
    /////////////////////////////////////////////////////////////////////
    // Process queries
        
    L"select * from Win32_ProcessStartTrace",
    L"select * from Win32_ProcessStopTrace",


    /////////////////////////////////////////////////////////////////////
    // Thread queries
        
    L"select * from Win32_ThreadStartTrace",
    L"select * from Win32_ThreadStopTrace",


    /////////////////////////////////////////////////////////////////////
    // Module queries
        
    L"select * from Win32_ModuleLoadTrace"
};

HRESULT STDMETHODCALLTYPE CKernelTraceProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags)
{
    HRESULT           hr;
    IWbemEventSinkPtr pEventSink;

    hr = pSink->QueryInterface(IID_IWbemEventSink, (LPVOID*) &pEventSink);
    
    for (int i = 0; i < SINK_COUNT && SUCCEEDED(hr); i++)
    {
        hr =
            pEventSink->GetRestrictedSink(
                1,
                &szQueries[i],
                NULL,
                &m_pSinks[i]);
    }

    if (SUCCEEDED(hr))
        hr = InitEvents();

    if (SUCCEEDED(hr))
        hr = InitTracing();

    return hr;
}


HRESULT STDMETHODCALLTYPE CKernelTraceProvider::AccessCheck( 
    /* [in] */ WBEM_CWSTR wszQueryLanguage,
    /* [in] */ WBEM_CWSTR wszQuery,
    /* [in] */ long lSidLength,
    /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid)
{
    if ( NULL == pSid )
    {
        HRESULT hr = CoImpersonateClient();
        
        if( FAILED( hr ) ) 
        {
            return hr;
        }
        
        HANDLE hToken;
        if( !OpenThreadToken( GetCurrentThread( ), TOKEN_READ, TRUE, &hToken ) )
        {
            CoRevertToSelf( );
            return WBEM_E_FAILED;
        }

        hr = WBEM_E_ACCESS_DENIED;

        BOOL bRet = FALSE;
        PSID pRawSid;
        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

        if( AllocateAndInitializeSid( &id, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0,0,0,0,0,0,&pRawSid ) )
        {
            if ( CheckTokenMembership( hToken, pRawSid, &bRet ) && bRet )
            {
                hr = WBEM_S_NO_ERROR;
            }
            
            FreeSid( pRawSid );
        }
        
        CloseHandle( hToken );
        CoRevertToSelf();
        
        return hr;
    }

    //
    // SID IS NOT NULL HERE
    //

    if ( IsUserAdministrator( ( PSID )pSid ) )
    {
        return WBEM_E_ACCESS_DENIED;
    }

    return WBEM_S_NO_ERROR;
}


#define PROCESS_START   1
#define PROCESS_END     2

struct CProcessTrace
{
    DWORD_PTR dwPageDirBase;
    DWORD     dwProcessID,
              dwParentProcessID,
              dwSessionID;
    DWORD     dwExitStatus;
    BYTE      cSidBegin[1];    
};

void WINAPI CKernelTraceProvider::OnProcessEvent(PEVENT_TRACE pEvent)
{
    CInCritSec     cs(&g_pThis->m_cs);
    CObjAccess     *pObjEx;
    IWbemEventSink *pSink;

    if (pEvent->Header.Class.Type == PROCESS_START)
    {
        pSink = g_pThis->m_pSinks[SINK_PROCESS_START];

        if (pSink->IsActive() != WBEM_S_NO_ERROR)
            return;
        
        pObjEx = &g_pThis->m_eventProcessStart;
    }
    else if (pEvent->Header.Class.Type == PROCESS_END)
    {
        pSink = g_pThis->m_pSinks[SINK_PROCESS_STOP];

        if (pSink->IsActive() != WBEM_S_NO_ERROR)
            return;
        
        pObjEx = &g_pThis->m_eventProcessStop;
    }
    else
        // Ignore anything else.
        return;
                
    CProcessTrace *pProcess = (CProcessTrace*) pEvent->MofData;

    // Find out where the SID is.
    LPBYTE pCurrent = (LPBYTE) &pProcess->cSidBegin,
           pSid;
    DWORD  nSidLen;

    if (*(DWORD*) pCurrent == 0)
    {
        pSid = NULL;
        pCurrent += sizeof(DWORD);
    }
    else
    {
        // These numbers were taken from tracedmp.c of the sdktool 
        // tracedmp.exe.  There's no explanation as to how they came up with 
        // them, but I'm assuming it's documented somewhere in the SDK.
        pCurrent += sizeof( TOKEN_USER );
        nSidLen = 8 + (4 * pCurrent[1]);
        pSid = pCurrent;
        pCurrent += nSidLen;
    }

    _bstr_t strProcess = (LPSTR) pCurrent;

    // Extrinsic events
    pObjEx->WriteDWORD64(0, pProcess->dwPageDirBase);
    pObjEx->WriteDWORD(1, pProcess->dwProcessID);
    pObjEx->WriteDWORD(2, pProcess->dwParentProcessID);
    pObjEx->WriteDWORD(3, pProcess->dwSessionID);

    if (pEvent->Header.Class.Type == PROCESS_END)
    {
        pObjEx->WriteDWORD(4, pProcess->dwExitStatus);
        
        if (pSid)
            pObjEx->WriteNonPackedArrayData(5, pSid, nSidLen, nSidLen);
        else
            pObjEx->WriteNULL(5);
        
        pObjEx->WriteString(6, (LPCWSTR) strProcess);
    }
    else
    {
        if (pSid)
            pObjEx->WriteNonPackedArrayData(4, pSid, nSidLen, nSidLen);
        else
            pObjEx->WriteNULL(4);
        
        pObjEx->WriteString(5, (LPCWSTR) strProcess);
    }

    pSink->Indicate(1, pObjEx->GetObjForIndicate());
}

struct CThreadStart
{
	DWORD	  dwProcessID,
		      dwThreadID;
	DWORD_PTR dwStackBase,
			  dwStackLimit,
			  dwUserStackBase,
              dwUserStackLimit,
			  dwStartAddr,
			  dwWin32StartAddr;
	char	  cWaitMode;
};

struct CThreadStop
{
	DWORD	  dwProcessID,
		      dwThreadID;
};

void WINAPI CKernelTraceProvider::OnThreadEvent(PEVENT_TRACE pEvent)
{
    CInCritSec cs(&g_pThis->m_cs);

    if (pEvent->Header.Class.Type == PROCESS_START)
    {
		if (g_pThis->m_pSinks[SINK_THREAD_START]->IsActive() != WBEM_S_NO_ERROR)
			return;

	    CObjAccess   *pObjEx = &g_pThis->m_eventThreadStart;
		CThreadStart *pStart = (CThreadStart*) pEvent->MofData;

		pObjEx->WriteDWORD64(0, pStart->dwStackBase);
		pObjEx->WriteDWORD64(1, pStart->dwStackLimit);
		pObjEx->WriteDWORD64(2, pStart->dwUserStackBase);
		pObjEx->WriteDWORD64(3, pStart->dwUserStackLimit);
		pObjEx->WriteDWORD64(4, pStart->dwStartAddr);
		pObjEx->WriteDWORD64(5, pStart->dwWin32StartAddr);
		pObjEx->WriteDWORD(6, pStart->dwProcessID);
		pObjEx->WriteDWORD(7, pStart->dwThreadID);
		pObjEx->WriteDWORD(8, pStart->cWaitMode);
    
		g_pThis->m_pSinks[SINK_THREAD_START]->
			Indicate(1, pObjEx->GetObjForIndicate());
    }
    else if (pEvent->Header.Class.Type == PROCESS_END)
    {
		if (g_pThis->m_pSinks[SINK_THREAD_STOP]->IsActive() != WBEM_S_NO_ERROR)
			return;

	    CObjAccess  *pObjEx = &g_pThis->m_eventThreadStop;
		CThreadStop *pStop = (CThreadStop*) pEvent->MofData;

		pObjEx->WriteDWORD(0, pStop->dwProcessID);
		pObjEx->WriteDWORD(1, pStop->dwThreadID);
    
		g_pThis->m_pSinks[SINK_THREAD_STOP]->
			Indicate(1, pObjEx->GetObjForIndicate());
    }
}

struct CImageLoad
{
	DWORD_PTR dwImageBase;
	DWORD_PTR dwImageSize;
    DWORD     dwProcessID;
    WCHAR     szFileName[4];
};

void WINAPI CKernelTraceProvider::OnImageEvent(PEVENT_TRACE pEvent)
{
    CInCritSec cs(&g_pThis->m_cs);

    if (g_pThis->m_pSinks[SINK_MODULE_LOAD]->IsActive() == WBEM_S_NO_ERROR)
    {
        CObjAccess *pObjEx = &g_pThis->m_eventModuleLoad;
        CImageLoad *pLoad = (CImageLoad*) pEvent->MofData;
        LPBYTE     pData = (LPBYTE) pEvent->MofData;

        // Extrinsic events
        pObjEx->WriteDWORD64(0, pLoad->dwImageBase);
        pObjEx->WriteDWORD64(1, pLoad->dwImageSize);
        pObjEx->WriteDWORD(2, pLoad->dwProcessID);
        pObjEx->WriteString(3, pLoad->szFileName);
    
        g_pThis->m_pSinks[SINK_MODULE_LOAD]->Indicate(1, pObjEx->GetObjForIndicate());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7393E509_39EB_49E1_A775_08A22949E117__INCLUDED_)
#define AFX_STDAFX_H__7393E509_39EB_49E1_A775_08A22949E117__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#ifndef _WIN64
#define ULONG_PTR ULONG
#endif

#include <wmistr.h>
#include <evntrace.h>
#include <strsafe.h>
#include <windows.h>

extern "C" void Trace(LPCTSTR szFormat, ...);

#ifndef _DEBUG
#define TRACE  1 ? (void)0 : ::Trace
#else
#define TRACE  ::Trace
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7393E509_39EB_49E1_A775_08A22949E117__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by krnlprov.rc
//
#define IDS_PROJNAME                    100
#define IDR_KERNELTRACEPROVIDER         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\common\ncdefs.h ===
// NCEDefs.h

#ifndef _NCEDEFS_H
#define _NCEDEFS_H

#include <comdef.h>

#define WMI_INIT_EVENT_NAME           L"WBEM_ESS_OPEN_FOR_BUSINESS"

#define OBJNAME_EVENT_READY           L"EVENT_READY"
#define OBJNAME_NAMED_PIPE            L"PIPE_EVENT"

#define MAX_MSG_SIZE                  0x8000
#define PIPE_TIMEOUT                  32000   

#define NC_SRVMSG_CLIENT_INFO         0
#define NC_SRVMSG_EVENT_LAYOUT        1
#define NC_SRVMSG_PREPPED_EVENT       2
#define NC_SRVMSG_BLOB_EVENT          3
#define NC_SRVMSG_RESTRICTED_SINK     4

#ifdef USE_SD
#define NC_SRVMSG_SET_SINK_SD         5
#define NC_SRVMSG_SET_EVENT_SD        6
#endif

#define NC_SRVMSG_ACCESS_CHECK_REPLY 10
#define NC_SRVMSG_NEW_QUERY_REPLY    11
#define NC_SRVMSG_CANCEL_QUERY_REPLY 12

#define NC_CLIMSG_ACCESS_CHECK_REQ   10
#define NC_CLIMSG_NEW_QUERY_REQ      11
#define NC_CLIMSG_CANCEL_QUERY_REQ   12
#define NC_CLIMSG_PROVIDER_UNLOADING 13

struct NC_SRVMSG_REPLY
{
    DWORD     dwMsg;
    HRESULT   hrRet;
    DWORD_PTR dwMsgCookie;
};

class IPostBuffer
{
public:
    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;
    
    virtual HRESULT PostBuffer(LPBYTE pData, DWORD dwSize) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\common\ncobjapi.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  NCEvent.h
//
//***************************************************************************

#ifndef _NCEVENT_H
#define _NCEVENT_H

#ifdef ISP2PDLL
//#define WMIAPI __declspec(dllexport) WINAPI
#define WMIAPI WINAPI
#else
#define WMIAPI __declspec(dllimport) WINAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _tagEVENT_SOURCE_MSG
{
    ESM_START_SENDING_EVENTS,
    ESM_STOP_SENDING_EVENTS,
    ESM_NEW_QUERY,
    ESM_CANCEL_QUERY,
    ESM_ACCESS_CHECK,
} EVENT_SOURCE_MSG;

typedef HRESULT (WINAPI *LPEVENT_SOURCE_CALLBACK)(HANDLE, EVENT_SOURCE_MSG, LPVOID, LPVOID);
    
typedef struct _tagES_ACCESS_CHECK
{
    LPCWSTR szQueryLanguage;
    LPCWSTR szQuery;
    DWORD   dwSidLen;
    LPBYTE  pSid;
} ES_ACCESS_CHECK;

typedef struct _tagES_NEW_QUERY
{
    DWORD   dwID;
    LPCWSTR szQueryLanguage;
    LPCWSTR szQuery;
} ES_NEW_QUERY;

typedef struct _tagES_CANCEL_QUERY
{
    DWORD dwID;
} ES_CANCEL_QUERY;

typedef long CIMTYPE;

// Flags for all Create functions
#define WMI_CREATEOBJ_LOCKABLE              1

// Flags for WmiSetAndCommit
#define WMI_SENDCOMMIT_SET_NOT_REQUIRED     1
#define WMI_USE_VA_LIST                     2

#ifndef __WbemClient_v1_LIBRARY_DEFINED__
typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_IUNKNOWN	= 104,
	CIM_FLAG_ARRAY	= 0x2000
    }	CIMTYPE_ENUMERATION;
#endif

// Register to send events
HANDLE WMIAPI WmiEventSourceConnect(
    LPCWSTR szNamespace,
    LPCWSTR szProviderName,
    BOOL bBatchSend,
    DWORD dwBatchBufferSize,
    DWORD dwMaxSendLatency,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback);

void WMIAPI WmiEventSourceDisconnect(
    HANDLE hSource);

BOOL WMIAPI WmiIsObjectActive(HANDLE hObject);

BOOL WMIAPI WmiDestroyObject(
    HANDLE hObject);

HANDLE WMIAPI WmiCreateObjectWithFormat(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags,
    LPCWSTR szFormat);

BOOL WMIAPI WmiSetAndCommitObject(
    HANDLE hObject,
    DWORD dwFlags,
    ...);

HANDLE WMIAPI WmiCreateObject(
    HANDLE hSource,
    LPCWSTR szClassName,
    DWORD dwFlags);

BOOL WMIAPI WmiAddObjectProp(
    HANDLE hObject,
    LPCWSTR szPropertyName,
    CIMTYPE type,
    DWORD *pdwPropIndex);

HANDLE WMIAPI WmiCreateObjectWithProps(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags,
    DWORD nPropertyCount,
    LPCWSTR *pszPropertyNames,
    CIMTYPE *pPropertyTypes);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\dutils.cpp ===
#include "precomp.h"
#include "dutils.h"
#include <stdio.h>

void Trace(LPCTSTR szFormat, ...)
{
    va_list ap;

    TCHAR szMessage[512];
    
    va_start(ap, szFormat);
    StringCchVPrintf(szMessage, 512, szFormat, ap);
    va_end(ap);
    
    StringCchCat(szMessage,512,TEXT("\n"));

    OutputDebugString(szMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\dutils.h ===
// dutils.h

#pragma once

extern "C" void MBTrace(LPCTSTR szFormat, ...);
extern "C" void FTrace(LPCTSTR szFormat, ...);
extern "C" void Trace(LPCTSTR szFormat, ...);

#ifdef USE_FTRACE
#define TRACE  FTrace
#else

#ifndef _DEBUG
#define TRACE  1 ? (void)0 : ::Trace
#else
#define TRACE  ::Trace
#endif

#endif // #ifdef USE_FTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\connection.cpp ===
// Connection.cpp

#include "precomp.h"
#include "Connection.h"
#include "Event.h"

#include "Transport.h"
#include "NamedPipe.h"

#include "NCDefs.h"
#include "dutils.h"

#define DEF_BATCH_BUFFER_SIZE  131072
#define DEF_SEND_LATENCY       1000
 
/////////////////////////////////////////////////////////////////////////////
// CSink

CSink::CSink()
{
    InitializeCriticalSection(&m_cs);
}

CSink::~CSink()
{
    // Make sure none of the still alive events are referencing us.
    {
        CInCritSec cs(&m_cs);

        for (CEventListIterator event = m_listEvents.begin();
            event != m_listEvents.end(); event++)
        {
            CEvent *pEvent = *event;

            pEvent->m_pSink = NULL;
        }
    }

    DeleteCriticalSection(&m_cs);
}

BOOL CSink::Init(
    CConnection *pConnection, 
    DWORD dwSinkID,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    m_pConnection = pConnection;
    m_dwSinkID = dwSinkID;
    m_pUserData = pUserData;
    m_pCallback = pCallback;

    return TRUE;
}

void CSink::AddEvent(CEvent *pEvent)
{
    CInCritSec cs(&m_cs);

    m_listEvents.push_back(pEvent);
}

void CSink::RemoveEvent(CEvent *pEvent)
{
    CInCritSec cs(&m_cs);

    m_listEvents.remove(pEvent);
}

void CSink::ResetEventBufferLayoutSent()
{
    CInCritSec cs(&m_cs);

    for (CEventListIterator i = m_listEvents.begin();
        i != m_listEvents.end(); i++)
    {
        CEvent *pEvent = *i;

        pEvent->ResetLayoutSent();
        pEvent->SetEnabled(FALSE);
    }
}

void CSink::EnableAndDisableEvents()
{
    // For each event, set its enabled value.
    for (CEventListIterator i = m_listEvents.begin(); 
        i != m_listEvents.end(); 
        i++)
    {
        CEvent *pEvent = *i;

        EnableEventUsingList(pEvent);
    }
}

void CSink::AddToEnabledEventList(CBuffer *pBuffer)
{
    DWORD dwLen;
    DWORD dwNumEnabled = pBuffer->ReadDWORD();

    // Add the event names to our enabled map.
    for( DWORD i=0; i < dwNumEnabled; i++ )
    {
        LPCWSTR szCurrentEvent = pBuffer->ReadAlignedLenString(&dwLen);
        m_mapEnabledEvents[szCurrentEvent] = 1;
        TRACE("Enabled: %S", szCurrentEvent);
    }

    EnableAndDisableEvents();
}

void CSink::RemoveFromEnabledEventList(CBuffer *pBuffer)
{
    DWORD dwLen;
    DWORD dwNumDisabled = pBuffer->ReadDWORD();

    // Add the event names to our enabled map.
    for( DWORD i=0; i < dwNumDisabled; i++ )
    {
        LPCWSTR szCurrentEvent = pBuffer->ReadAlignedLenString(&dwLen);
        m_mapEnabledEvents.erase(szCurrentEvent);    
        TRACE("Disabled: %S", szCurrentEvent);
    }

    EnableAndDisableEvents();
}

BOOL CSink::IsEventClassEnabled(LPCWSTR szEventClass)
{
    BOOL  bEnable;
    WCHAR szTempClassName[256];

    if (szEventClass)
    {
        StringCchCopyW(szTempClassName, 256, szEventClass);
        _wcsupr(szTempClassName);

        bEnable =
            m_mapEnabledEvents.find(szTempClassName) != m_mapEnabledEvents.end();
    }
    else
        bEnable = FALSE;

    return bEnable;
}

void CSink::EnableEventUsingList(CEvent *pEvent)
{
    BOOL bEnable;
    bEnable = IsEventClassEnabled(pEvent->GetClassName());
    pEvent->SetEnabled(bEnable);
}

/////////////////////////////////////////////////////////////////////////////
// CConnection

CConnection::CConnection(BOOL bBatchSend, DWORD dwBatchBufferSize, 
    DWORD dwMaxSendLatency) :
    m_bDone(FALSE),
    m_bUseBatchSend(bBatchSend),
    m_dwSendLatency(dwMaxSendLatency ? dwMaxSendLatency : DEF_SEND_LATENCY),
    m_heventBufferNotFull(NULL),
    m_heventBufferFull(NULL),
    m_heventEventsPending(NULL),
    m_heventDone(NULL),
    m_hthreadSend(NULL),
    m_pTransport(NULL),
    m_hthreadWMIInit(NULL),
    m_heventWMIInit(NULL),
    m_bWMIResync(TRUE),
    m_dwNextSinkID(1)
{
    if (bBatchSend)
    {
        if (dwBatchBufferSize == 0)
            dwBatchBufferSize = DEF_BATCH_BUFFER_SIZE;

        m_bufferSend.Reset(dwBatchBufferSize);
    }
    else
        m_bufferSend.Reset(DEF_BATCH_BUFFER_SIZE);
}

CConnection::~CConnection()
{
    Deinit();
}

void CConnection::GetBaseName(LPCWSTR szName, LPWSTR szBase)
{
    StringCchCopyW(szBase, MAX_PATH*2, szName);
    _wcsupr(szBase);

    // Get rid of the '\' chars since we can't use it in OS object names.
    for (WCHAR *szCurrent = szBase; *szCurrent; szCurrent++)
    {
        if (*szCurrent == '\\')
            *szCurrent = '/';
    }
}

BOOL CConnection::Init(
    LPCWSTR szNamespace, 
    LPCWSTR szProviderName,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    if (!m_sinkMain.Init(this, 0, pUserData, pCallback))
        return FALSE;
    
    GetBaseName(szNamespace, m_szBaseNamespace);
    GetBaseName(szProviderName, m_szBaseProviderName);

    try
    {
        InitializeCriticalSection(&m_cs);

        // The rest of these are for batch sending.
        InitializeCriticalSection(&m_csBuffer);
    }
    catch(...)
    {
        return FALSE;
    }
   
    m_heventDone =
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);
    if(m_heventDone == NULL)
        return FALSE;

    m_heventBufferNotFull =
        CreateEvent(
            NULL,
            TRUE,
            TRUE,
            NULL);
    if(m_heventBufferNotFull == NULL)
        return FALSE;

    m_heventBufferFull =
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);
    if(m_heventBufferFull == NULL)
        return FALSE;

    m_heventEventsPending =
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);
    if(m_heventEventsPending == NULL)
        return FALSE;

    if(!StartWaitWMIInitThread())
        return FALSE;

    return TRUE;
}

BOOL CConnection::StartWaitWMIInitThread()
{
    TRACE("Entered StartWaitWMIInitThread.");

    m_heventWMIInit =
        OpenEventW(
            SYNCHRONIZE,
            FALSE,
            WMI_INIT_EVENT_NAME);

    if (!m_heventWMIInit)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwSize;

        if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
            ESS_EVENT_SDDL,  // security descriptor string
            SDDL_REVISION_1, // revision level
            &pSD,            // SD
            &dwSize) )
            return FALSE;

        SECURITY_ATTRIBUTES sa = { sizeof(sa), pSD, FALSE };

        m_heventWMIInit =
            CreateEventW(
                &sa,
                TRUE,
                FALSE,
                WMI_INIT_EVENT_NAME);

        if (pSD)
            LocalFree((HLOCAL) pSD);

        if (!m_heventWMIInit)
        {
            TRACE("Couldn't create ESS ready event: %d", GetLastError());
            return FALSE;
        }
    }

    if (WaitForSingleObject(m_heventWMIInit, 0) == 0)
    {
        TRACE("ESS event was already set, so going to init transport...");

        if(!InitTransport())
            return FALSE;
    }
    else
    {
        DWORD dwID;

        TRACE("Creating WaitWMIInitThreadProc thread.");

        m_hthreadWMIInit =
            CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) WaitWMIInitThreadProc,
                this,
                0,
                &dwID);

        if(m_hthreadWMIInit == NULL)
            return FALSE;
    }

    return TRUE;
}

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

BOOL CConnection::InitTransport()
{
    if ( m_pTransport != NULL )
    {
        return TRUE;
    }

    TRACE("Entered InitTransport.");

    try
    {
        m_pTransport = new CNamedPipeClient;
    }
    catch(...)
    {
        // this page intentionally left blank - m_pTransport will still be NULL.
    }
    
    BOOL bRet;
    if (m_pTransport)
    {
        m_pTransport->SetConnection(this);
        m_pTransport->Init(m_szBaseNamespace, m_szBaseProviderName);
        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

DWORD CConnection::WaitWMIInitThreadProc(CConnection *pThis)
{
    try
    {
        TRACE("Entered WaitWMIInitThreadProc");

        HANDLE hWait[2] = { pThis->m_heventDone, pThis->m_heventWMIInit };
        DWORD  dwWait;

        dwWait = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

        if (dwWait == 1)
        {
            TRACE("ESS event fired, going to init transport");

            // If WMI is now ready, startup our transport.
            pThis->InitTransport();
            pThis->m_bWMIResync = FALSE;
        }
        else
        {
            TRACE("dwWait in WaitWMIInitThreadProc = %d", dwWait);
        }
    }
    catch( CX_MemoryException )
    {
        return ERROR_OUTOFMEMORY;
    }
    
    return ERROR_SUCCESS;
}    

BOOL CConnection::ResyncWithWMI()
{
    m_bWMIResync = TRUE;

    StopThreads();

    ResetEvent( m_heventDone) ;

    m_hthreadWMIInit = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)WaitWMIInitThreadProc,
                                this,
                                0,
                                NULL );

    return m_hthreadWMIInit != NULL ? TRUE : FALSE;
}

void CConnection::StopThreads()
{
    if (m_hthreadSend)
    {
        BOOL bDoneSending;

        do
        {
            Lock();

            bDoneSending = m_bufferSend.GetUsedSize() == 0;

            // If there's still stuff left to send, make sure it
            // gets sent.
            if (bDoneSending)
            {
                SetEvent(m_heventDone);

                Unlock();

                WaitForSingleObject(m_hthreadSend, INFINITE);

                CloseHandle(m_hthreadSend);
                m_hthreadSend = NULL;
            }
            else
            {
                SetEvent(m_heventBufferFull);

                Unlock();

                // Sleep a little to give the send thread a chance to do its 
                // thing.
                Sleep(1);
            }

        } while (!bDoneSending);
    }

    if ( m_hthreadWMIInit != NULL )
    {
        SetEvent(m_heventDone);
        WaitForSingleObject(m_hthreadWMIInit, INFINITE);
        CloseHandle(m_hthreadWMIInit);
    }

    m_hthreadWMIInit = NULL;
    m_hthreadSend = NULL;
}
    
void CConnection::Deinit()
{
    m_bDone = TRUE;
    
    StopThreads();

    if (m_heventWMIInit)
        CloseHandle(m_heventWMIInit);

    CloseHandle(m_heventDone);
    CloseHandle(m_heventBufferNotFull);
    CloseHandle(m_heventBufferFull);
    CloseHandle(m_heventEventsPending);

    // Give the transport a chance to clean up.
    if (m_pTransport)
        m_pTransport->Deinit();

    // Make sure no sinks are referencing us anymore.
    for (CSinkMapIterator i = m_mapSink.begin();
        i != m_mapSink.end(); 
        i++)
    {
        CSink *pSink = (*i).second;

        pSink->m_pConnection = NULL;
    }

    DeleteCriticalSection(&m_csBuffer);
    DeleteCriticalSection(&m_cs);
}

BOOL CConnection::StartSendThread()
{
    DWORD dwID;
    
    m_hthreadSend =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) SendThreadProc,
            this,
            0,
            &dwID);
    if(m_hthreadSend == NULL)
        return FALSE;

    return TRUE;
}

BOOL CConnection::SendMessagesOverTransport( PBYTE pData, DWORD cData )
{
    CBuffer buffer( pData, cData );

    //
    // walk the messages until we hit our max message size for 
    // the transport.  Keep doing this until no more messages.
    // 

    PBYTE pTransportMsg = buffer.m_pBuffer;
    DWORD cTransportMsg = 0;

    while (!buffer.IsEOF())
    {
        _ASSERT( pTransportMsg != NULL );
        _ASSERT( cTransportMsg < MAX_MSG_SIZE );

        //
        // process one message from the buffer 
        // 

        DWORD dwMsg = buffer.ReadDWORD();

        if ( dwMsg != NC_SRVMSG_EVENT_LAYOUT && 
             dwMsg != NC_SRVMSG_PREPPED_EVENT )
        {
            _ASSERT( FALSE );
            return FALSE;
        }

        DWORD cMsg = buffer.ReadDWORD();

        if ( cMsg <= MAX_MSG_SIZE )
        {
            if ( cTransportMsg + cMsg >= MAX_MSG_SIZE )
            {
                //
                // send what we have so far.
                //
                if ( !SendDataOverTransports( pTransportMsg, cTransportMsg ) )
                    return FALSE;
                
                //
                // set up new transport msg.
                //
                pTransportMsg = buffer.m_pCurrent - 8;
                cTransportMsg = cMsg;
            }
            else 
            {
                //
                // add to transport msg
                //
                cTransportMsg += cMsg;
            }
        }
        else
        {
            //
            // this means a mesage was too big to send. skip it.
            // 
        }   

        buffer.m_pCurrent += cMsg - 8;
    }

    if ( cTransportMsg > 0 )
    {
        return SendDataOverTransports( pTransportMsg, cTransportMsg );
    }

    return TRUE;
}

DWORD WINAPI CConnection::SendThreadProc(CConnection *pThis)
{
    try
    {
        HANDLE  hWait[2] = { pThis->m_heventDone, pThis->m_heventEventsPending },
          hwaitSendLatency[2] = { pThis->m_heventDone, pThis->m_heventBufferFull },
          heventBufferNotFull = pThis->m_heventBufferNotFull;
        DWORD            dwSendLatency = pThis->m_dwSendLatency;
        LPBYTE           pData = pThis->m_bufferSend.m_pBuffer;
        CBuffer          *pBuffer = &pThis->m_bufferSend;
        CRITICAL_SECTION *pCS = &pThis->m_csBuffer;

        while (WaitForMultipleObjects(2, hWait, FALSE, INFINITE) != 0)
        {
            // If we have a send latency, wait for that time or until the send 
            // buffer is full.  If the done event fires, get out.
            if (dwSendLatency)
            {
                if (WaitForMultipleObjects(2, hwaitSendLatency, FALSE, 
                    dwSendLatency) == 0)
                    break;

                // Reset m_heventBufferFull.
                ResetEvent(hwaitSendLatency[1]);
            }

            EnterCriticalSection(pCS);
        
            pThis->SendMessagesOverTransport(
                pData, 
                pBuffer->GetUsedSize());

            pBuffer->Reset();

            SetEvent(heventBufferNotFull);

            // Reset m_heventEventsPending
            ResetEvent(hWait[1]);

            LeaveCriticalSection(pCS);
        }
    }
    catch( CX_MemoryException )
    {
        return ERROR_OUTOFMEMORY;
    }
    
    return 0;
}

//#define NO_SEND

BOOL CConnection::IndicateProvEnabled()
{
    // Get out if we're already done.
    if (m_bDone)
        return TRUE;

    CInCritSec cs(&m_cs);

    // Tell the callback that the provider is now activated.
    if (m_sinkMain.m_pCallback)
        m_sinkMain.m_pCallback(
            (HANDLE) this, ESM_START_SENDING_EVENTS, m_sinkMain.m_pUserData, NULL);

    // Tell the server about us.
    if(!SendInitInfo())
        return FALSE;


    // See if we've buffered any events while we were waiting for WMI to come
    // up.  If we did, send them on their way.
    DWORD dwSize;

    EnterCriticalSection(&m_csBuffer);

    dwSize = m_bufferSend.GetUsedSize();
    
    if (dwSize)
    {
        m_pTransport->SendData(m_bufferSend.m_pBuffer, dwSize);
        m_bufferSend.Reset();
    }
        
    LeaveCriticalSection(&m_csBuffer);


    if (m_bUseBatchSend && m_hthreadSend == NULL)
        return StartSendThread();
    else
        return TRUE;
}

void CConnection::IndicateProvDisabled()
{
    // Get out if we're already done.
    if (m_bDone)
        return;

    CInCritSec cs(&m_cs);

    for (CSinkMapIterator i = m_mapSink.begin();
        i != m_mapSink.end();
        i++)
    {
        CSink *pSink = (*i).second;

        pSink->ResetEventBufferLayoutSent();

        if (pSink->m_pCallback)
        {
            pSink->m_pCallback(
                (HANDLE) pSink, 
                ESM_STOP_SENDING_EVENTS, 
                pSink->m_pUserData, 
                NULL);
        }
    }

    // Tell the callback that the provider is now deactivated.
    m_sinkMain.ResetEventBufferLayoutSent();

    if (m_sinkMain.m_pCallback)
    {
        m_sinkMain.m_pCallback(
            (HANDLE) &m_sinkMain, 
            ESM_STOP_SENDING_EVENTS, 
            m_sinkMain.m_pUserData, 
            NULL);
    }

    ResyncWithWMI();
}

BOOL CConnection::SendData(LPBYTE pBuffer, DWORD dwSize)
{
    BOOL bRet = FALSE;

    // Make sure this event isn't too big.
    if (dwSize > m_bufferSend.m_dwSize)
        return FALSE;

    if (m_bUseBatchSend || WaitingForWMIInit())
    {
        BOOL bContinue;

        do
        {
            EnterCriticalSection(&m_csBuffer);

            bContinue = FALSE;

            // See if we have enough room to add our event.
            if (dwSize <= m_bufferSend.GetUnusedSize())
            {
                BOOL bWasEmpty = m_bufferSend.GetUsedSize() == 0;

                m_bufferSend.Write(pBuffer, dwSize);

                if (bWasEmpty)
                    SetEvent(m_heventEventsPending);

                LeaveCriticalSection(&m_csBuffer);
                bRet = TRUE;
                break;
            }
            else
            {
                // If we're not waiting for WMI to initialize, we just need to
                // wait for the send thread to finish sending what's in our
                // buffer.
                if (!WaitingForWMIInit())
                {
                    // Wake up the send latency thread if necessary.
                    if (m_dwSendLatency)
                        SetEvent(m_heventBufferFull);
                
                    // So we'll block until the send thread sets the event.
                    ResetEvent(m_heventBufferNotFull);

                    LeaveCriticalSection(&m_csBuffer);

                    WaitForSingleObject(m_heventBufferNotFull, INFINITE);
                    bContinue = TRUE;
                }
                // If we're still waiting for WMI to initialize but our buffer
                // is full, drop it.
                else
                {
                    LeaveCriticalSection(&m_csBuffer);
                    bRet = FALSE;
                }

            } // else from if (dwSize <= m_bufferSend.GetUnusedSize())

        } while( bContinue );
    }
    else
    {
        bRet = SendDataOverTransports(pBuffer, dwSize);
    }

    return bRet;
}

BOOL CConnection::SendDataOverTransports(LPBYTE pBuffer, DWORD dwSize)
{
    if (m_pTransport->IsReady())
        m_pTransport->SendData(pBuffer, dwSize);

    return TRUE;
}

BOOL CConnection::SendInitInfo()
{
    BYTE    cBuffer[sizeof(DWORD) * 2];
    CBuffer buffer(cBuffer, sizeof(cBuffer), CBuffer::ALIGN_DWORD);
    BOOL    bRet;

    buffer.Write((DWORD) NC_SRVMSG_CLIENT_INFO);
    buffer.Write((DWORD) (m_bUseBatchSend ? m_bufferSend.m_dwSize : MAX_MSG_SIZE));
    
    if(!m_pTransport->InitCallback())
        return FALSE;
    
    return m_pTransport->SendData(cBuffer, buffer.GetUsedSize());
}

HRESULT CConnection::ProcessMessage(LPBYTE pData, DWORD dwSize)
{
    // Get out if we're already done.
    if (m_bDone)
        return S_OK;

    if ( dwSize <= sizeof(DWORD)*2+sizeof(DWORD_PTR) )
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    DWORD     *pdwMsg = (DWORD*) pData;
    DWORD     *pdwSinkID = (DWORD*) (pdwMsg + 1);
    
    DWORD_PTR dwMsgCookie;
    memcpy( &dwMsgCookie, pdwMsg+2, sizeof(dwMsgCookie) );

    LPBYTE    pMsgBits = (LPBYTE)(pData+sizeof(DWORD)*2+sizeof(DWORD_PTR));
    CBuffer   buffer(pMsgBits, dwSize - sizeof(DWORD)*2 - sizeof(DWORD_PTR));
    HRESULT   hr = S_OK; 
    DWORD     dwLen;

    switch(*pdwMsg)
    {
        case NC_CLIMSG_ACCESS_CHECK_REQ:
        {
            ES_ACCESS_CHECK check;

            check.szQueryLanguage = buffer.ReadAlignedLenString(&dwLen);
            check.szQuery = buffer.ReadAlignedLenString(&dwLen);
            check.dwSidLen = buffer.ReadDWORD();

            if ( check.dwSidLen <= buffer.GetUnusedSize() )
            {            
                if (check.dwSidLen != 0)
                    check.pSid = buffer.m_pCurrent;
                else
                    check.pSid = NULL;

                if (m_sinkMain.m_pCallback)
                {
                    hr =
                        m_sinkMain.m_pCallback(
                            (HANDLE) &m_sinkMain, 
                            ESM_ACCESS_CHECK, 
                            m_sinkMain.m_pUserData, 
                            &check);
                }
            }
            else
            {
                hr = E_FAIL;
            }

            NC_SRVMSG_REPLY reply = { NC_SRVMSG_ACCESS_CHECK_REPLY, 
                                      hr, dwMsgCookie };
            
            m_pTransport->SendMsgReply(&reply);
            break;
        }

        case NC_CLIMSG_NEW_QUERY_REQ:
        {
            ES_NEW_QUERY query;
            CSink        *pSink = GetSink(*pdwSinkID);

            if (pSink)
            {
                query.dwID = buffer.ReadDWORD();
                query.szQueryLanguage = buffer.ReadAlignedLenString(&dwLen);
                query.szQuery = buffer.ReadAlignedLenString(&dwLen);

                // This is the list of event class names that are now
                // enabled thanks to this query.
                pSink->AddToEnabledEventList(&buffer);

                if (pSink->m_pCallback)
                {
                    hr =
                        pSink->m_pCallback(
                            (HANDLE) pSink, ESM_NEW_QUERY, pSink->m_pUserData, &query);
                }
            }
            else
                TRACE("Sink %d not found.", *pdwSinkID);

            m_pTransport->SendMsgReply(NULL);

            break;                    
        }

        case NC_CLIMSG_CANCEL_QUERY_REQ:
        {
            ES_CANCEL_QUERY query;
            CSink           *pSink = GetSink(*pdwSinkID);

            if (pSink)
            {
                query.dwID = buffer.ReadDWORD();

                // This is the list of event class names that are now
                // disabled thanks to this query.
                pSink->RemoveFromEnabledEventList(&buffer);

                if (pSink->m_pCallback)
                {
                    hr =
                        pSink->m_pCallback(
                            (HANDLE) pSink, ESM_CANCEL_QUERY, pSink->m_pUserData, 
                            &query);

                    m_pTransport->SendMsgReply(NULL);

                    break;                    
                }
                else
                    hr = S_OK;
            }
            else
                TRACE("Sink %d not found.", *pdwSinkID);

            break;
        }

        case NC_CLIMSG_PROVIDER_UNLOADING:
            TRACE("Got the NC_CLIMSG_PROVIDER_UNLOADING message.");

            // Give our named pipe client a chance to go see if it 
            // should deactivate itself (if the server doesn't need
            // us anymore).
            m_pTransport->SignalProviderDisabled();

            hr = S_OK;

            break;

        default:
            TRACE("Bad message from server!");
            break;    
    } // switch(*(DWORD*)cBuffer)

    return hr;
}

CSink *CConnection::GetSink(DWORD dwID)
{
    return &m_sinkMain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\connection.h ===
// Connection.h
// This class is the hSource returned by WMIEventSourceConnect.

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CConnection

#include "NCObjApi.h"
#include "Buffer.h"
#include "ReportEvent.h"
#include "NamedPipe.h"

#include "corex.h"
#include <list>
#include <map>

class CMyString
{
    LPWSTR m_wsz;

    void Set( LPCWSTR wsz )
    {
        delete [] m_wsz;
        
        if ( wsz != NULL )
        {
            m_wsz = new WCHAR[wcslen(wsz)+1];
            if ( m_wsz != NULL )
            {
                StringCchCopyW( m_wsz, wcslen(wsz)+1, wsz );
            }
            else
            {
                throw CX_MemoryException();
            }
        }
        else
        {
            m_wsz = NULL;
        }
    }

public:

    CMyString( LPCWSTR wsz = NULL ) : m_wsz( NULL ) { Set(wsz); }
    CMyString( const CMyString& rws ) : m_wsz(NULL) { *this = rws; }
    const CMyString & operator=( const CMyString& rws ) { Set( rws.m_wsz ); return *this; }
    
    ~CMyString() { delete [] m_wsz; }
    
    bool operator< ( const CMyString& rws ) const
      { return _wcsicmp( m_wsz, rws.m_wsz ) < 0; }
};
    
typedef CMyString wstring;

class CEvent;
class CTransport;

typedef std::list< CEvent*, wbem_allocator<CEvent*> > CEventList;
typedef CEventList::iterator CEventListIterator;

#define NUM_TRANSPORTS    2

enum TRANSPORT_INDEX
{
    TRANS_NAMED_PIPE,
    TRANS_EVENT_TRACE,
};

struct NC_SRVMSG_REPLY;

class CSink
{
public:
    LPEVENT_SOURCE_CALLBACK 
                     m_pCallback;
    LPVOID           m_pUserData;
    CReportEventMap  m_mapReportEvents;
    CRITICAL_SECTION m_cs;

    CSink();
    ~CSink();

    BOOL Init(
        CConnection *pConnection, 
        DWORD dwID,
        LPVOID pUserData,
        LPEVENT_SOURCE_CALLBACK pCallback);
    BOOL IsReady();

    DWORD GetSinkID() { return m_dwSinkID; }

    // Used for keeping track of the events created with the CConnection.
    void AddEvent(CEvent *pEvent);
    void RemoveEvent(CEvent *pEvent);

    void ResetEventBufferLayoutSent();
    BOOL IsEventClassEnabled(LPCWSTR szEventClass);

    CConnection *GetConnection() { return m_pConnection; }

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

    void EnableEventUsingList(CEvent *pEvent);

protected:
    friend CConnection;

    typedef std::map<wstring, int, std::less<wstring>, wbem_allocator<int> > CStrToIntMap;
    typedef CStrToIntMap::iterator CStrToIntMapIterator;

    CConnection  *m_pConnection;
    CEventList   m_listEvents;
    CStrToIntMap m_mapEnabledEvents;
    DWORD        m_dwSinkID;

    void AddToEnabledEventList(CBuffer *pBuffer);
    void RemoveFromEnabledEventList(CBuffer *pBuffer);
    void EnableAndDisableEvents();
};

class CConnection
{
public:
    BOOL   m_bDone;
    HANDLE m_heventDone,
           m_hthreadSend,
           m_heventEventsPending,
           m_heventBufferNotFull,
           m_heventBufferFull;
    WCHAR  m_szBaseNamespace[MAX_PATH * 2],
           m_szBaseProviderName[MAX_PATH * 2];
    CRITICAL_SECTION
           m_cs,
           m_csBuffer;
    
    DWORD  m_dwSendLatency;
    BOOL   m_bUseBatchSend;
    BOOL   m_bWMIResync;

    HANDLE m_heventWMIInit,
           m_hthreadWMIInit;

    CTransport *m_pTransport;

    CConnection(BOOL bBatchSend, DWORD dwBatchBufferSize, DWORD dwMaxSendLatency);
    ~CConnection();

    BOOL Init(
        LPCWSTR szNamespace, 
        LPCWSTR szProviderName,
        LPVOID pUserData,
        LPEVENT_SOURCE_CALLBACK pCallback);

    void Deinit();

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

    BOOL SendMessagesOverTransport( PBYTE pBuffer, DWORD cBuffer );
    BOOL SendData(LPBYTE pBuffer, DWORD dwSize);
    
    BOOL ResyncWithWMI();
    BOOL IndicateProvEnabled();
    void IndicateProvDisabled();
    void StopThreads();

    BOOL SendInitInfo();

    BOOL WaitingForWMIInit() { return m_bWMIResync; }

    HRESULT ProcessMessage(LPBYTE pData, DWORD dwSize);

    BOOL IsReady() { return m_pTransport && m_pTransport->IsReady(); }

    CSink *GetSink(DWORD dwID);
    CSink *GetMainSink() { return &m_sinkMain; }
    void RemoveSink(CSink *pSink);

protected:
    typedef std::map<DWORD, CSink*, std::less<DWORD>, wbem_allocator<CSink*> > CSinkMap;
    typedef CSinkMap::iterator CSinkMapIterator;

    CSink    m_sinkMain;
    CSinkMap m_mapSink;
    DWORD    m_dwNextSinkID;

    CBuffer  m_bufferSend;

    BOOL StartProviderReadyThread();
    BOOL StartSendThread();
    void StopSendThread();

    BOOL SendDataOverTransports(LPBYTE pBuffer, DWORD dwSize);

    static DWORD WINAPI SendThreadProc(CConnection *pThis);
    static void GetBaseName(LPCWSTR szName, LPWSTR szBase);

    BOOL StartWaitWMIInitThread();
    BOOL InitTransport();
    static DWORD WINAPI WaitWMIInitThreadProc(CConnection *pThis);
};

class CInCritSec
{
public:
    CInCritSec(CRITICAL_SECTION *pCS) 
    { 
        EnterCriticalSection(pCS);

        m_pCS = pCS;
    }

    ~CInCritSec()
    {
        LeaveCriticalSection(m_pCS);
    }

protected:
    CRITICAL_SECTION *m_pCS;
};

class CCondInCritSec
{
public:
    CCondInCritSec(CRITICAL_SECTION *pCS, BOOL bDoLock) 
    { 
        if (bDoLock)
        {
            EnterCriticalSection(pCS);

            m_pCS = pCS;
        }
        else
            m_pCS = NULL;
    }

    ~CCondInCritSec()
    {
        if (m_pCS)
            LeaveCriticalSection(m_pCS);
    }

protected:
    CRITICAL_SECTION *m_pCS;
};

// SDDL string description:
// D:        Security Descriptor
// A:        Access allowed
// 0x1f0003: EVENT_ALL_ACCESS
// BA:       Built-in administrators
// 0x100000: SYNCHRONIZE
// WD:       Everyone
#define ESS_EVENT_SDDL L"D:(A;;0x1f0003;;;BA)(A;;0x100000;;;WD)"


// Security helper
BOOL GetRelativeSD(
    SECURITY_DESCRIPTOR *pSDIn, 
    SECURITY_DESCRIPTOR **ppSDOut,
    BOOL *pbFree);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\event.cpp ===
// Event.cpp
#include "precomp.h"
#include "buffer.h"
#include "Connection.h"
#include "Event.h"
#include "NCDefs.h"
#include <corex.h>

#include <strutils.h>


#define DEF_EVENT_DATA_SIZE   512
#define DEF_EVENT_LAYOUT_SIZE 256

#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)


BOOL isunialpha(wchar_t c)
{
    if(c == 0x5f || (0x41 <= c && c <= 0x5a) ||
       (0x61  <= c && c <= 0x7a) || (0x80  <= c && c <= 0xfffd))
        return TRUE;
    else
        return FALSE;
}

BOOL isunialphanum(wchar_t c)
{
    if(isunialpha(c))
        return TRUE;
    else
        return wbem_iswdigit(c);
}

/////////////////////////////////////////////////////////////////////////////
// CPropInfo

BOOL CPropInfo::Init(CIMTYPE type)
{
    m_bPointer = FALSE;

    switch(type & ~CIM_FLAG_ARRAY)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            m_pFunc = CEvent::AddStringW;
            m_dwElementSize = 1;
            m_bCountPrefixNeeded = TRUE;
            m_bPointer = TRUE;
            break;

        case CIM_REAL32:
            // We can't use AddDWORD because the compiler converts 32-bit 
            // floats to 64-bit doubles before pushing them on the stack.
            m_pFunc = CEvent::AddFloat;
            m_dwElementSize = sizeof(float);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_UINT32:
        case CIM_SINT32:
            m_pFunc = CEvent::AddDWORD;
            m_dwElementSize = sizeof(DWORD);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_UINT16:
        case CIM_SINT16:
        case CIM_CHAR16:
        case CIM_BOOLEAN:
            m_pFunc = CEvent::AddDWORD;
            m_dwElementSize = sizeof(DWORD);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_REAL64:
            m_pFunc = CEvent::AddDWORD64;
            m_dwElementSize = sizeof(__int64);
            m_bCountPrefixNeeded = FALSE;
            m_bPointer = TRUE;
            break;

        case CIM_UINT8:
        case CIM_SINT8:
            m_pFunc = CEvent::AddBYTE;
            m_dwElementSize = sizeof(BYTE);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_OBJECT:
            m_pFunc = CEvent::AddObject;
            m_dwElementSize = 1;
            m_bCountPrefixNeeded = TRUE;
            m_bPointer = TRUE;
            break;

        case CIM_IUNKNOWN:
            m_pFunc = CEvent::AddWmiObject;
            m_dwElementSize = 1;
            m_bCountPrefixNeeded = TRUE;
            m_bPointer = TRUE;
            break;

        default:
            // Bad type passed!
            return FALSE;
    }

    // Change some things if this is an array.
    if (type & CIM_FLAG_ARRAY)
    {
        m_bPointer = TRUE;

        // All arrays need to have the number of elements prefixed to the data.
        m_bCountPrefixNeeded = TRUE;

        if (m_pFunc == CEvent::AddStringW)
            m_pFunc = CEvent::AddStringArray;
        else if ( m_pFunc == CEvent::AddObject || 
                  m_pFunc == CEvent::AddWmiObject )
            return FALSE;
        else
            m_pFunc = CEvent::AddScalarArray;
    }

    if (m_bPointer == FALSE)
    {
        // We no longer need element size, since it's the same as current size.
        // So, set current size and clear element size so we'll ignore it.
        m_dwCurrentSize = m_dwElementSize;
        m_dwElementSize = 0;
    }
        
    return TRUE;
}

void CPropInfo::InitCurrentSize(LPBYTE pData)
{
    DWORD dwTotalSize;

    if (IsPointer())
    {
        DWORD dwItems = *(DWORD*)pData;

        if (m_pFunc != CEvent::AddStringArray)
        {
            // This works for all pointer types except for object and string
            // arrays.
            dwTotalSize = dwItems * m_dwElementSize + sizeof(DWORD);
        }
        else
        {
            // Account for the number in the array.
            dwTotalSize = sizeof(DWORD);

            // For each item in the array, get its size and add it to the total
            // length.
            for (DWORD i = 0; i < dwItems; i++)
            {
                dwTotalSize += 
                    sizeof(DWORD) +
                    DWORD_ALIGNED(*(DWORD*) (pData + dwTotalSize));
            }
        }
    }
    else
        dwTotalSize = m_dwElementSize; 

    // Align the total size.
    m_dwCurrentSize = dwTotalSize;
}

/////////////////////////////////////////////////////////////////////////////
// CEventWrap

CEventWrap::CEventWrap(CSink *pSink, DWORD dwFlags) :
    m_bFreeEvent(TRUE)
{
    m_pEvent = new CEvent(pSink, dwFlags);
    
    if ( NULL == m_pEvent )
    {
        throw CX_MemoryException();
    }

    pSink->AddEvent(m_pEvent);
}

CEventWrap::CEventWrap(CEvent *pEvent, int nIndexes, DWORD *pdwIndexes) :
    m_bFreeEvent(FALSE)
{
    m_pEvent = pEvent;

    if ( !m_pIndexes.Init(nIndexes) )
        throw CX_MemoryException();

    for (int i = 0; i < nIndexes; i++)
        m_pIndexes.AddVal(pdwIndexes[i]);
}

CEventWrap::~CEventWrap()
{
    if (m_bFreeEvent && m_pEvent)
    {
        if (m_pEvent->m_pSink)
            m_pEvent->m_pSink->RemoveEvent(m_pEvent);

        delete m_pEvent;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(CSink *pSink, DWORD dwFlags) :
    m_pSink(pSink),
    CBuffer(DEF_EVENT_DATA_SIZE),
    m_bufferEventLayout(DEF_EVENT_LAYOUT_SIZE),
    m_bLayoutSent(FALSE),
    m_bEnabled(FALSE),
    m_pProps(0),
    m_dwFlags(dwFlags)
{
    if (IsLockable())
        InitializeCriticalSection(&m_cs);
}

CEvent::~CEvent()
{
    if (IsLockable())
        DeleteCriticalSection(&m_cs);
}

void CEvent::ResetEvent()
{
    CCondInCritSec cs(&m_cs, IsLockable());

    // Clear all our data.
    m_pCurrent = (LPBYTE) m_pdwHeapData;
    
    // Zero out our null table to make everything null.
    ZeroMemory(m_pdwNullTable, m_pdwPropTable - m_pdwNullTable);
}

static DWORD g_dwEventIndex = 0;

BOOL CEvent::PrepareEvent(
    LPCWSTR szEventName,
    DWORD nPropertyCount,
    LPCWSTR *pszPropertyNames,
    CIMTYPE *pPropertyTypes)
{
    DWORD dwEventIndex = InterlockedExchangeAdd((long*) &g_dwEventIndex, 1);

    CCondInCritSec cs(&m_cs, IsLockable());

    // Setup the event layout buffer.
    m_bufferEventLayout.Reset();
    
    m_bufferEventLayout.Write((DWORD) NC_SRVMSG_EVENT_LAYOUT);
    
    // This serves as a place holder for the size of the message.
    m_bufferEventLayout.Write((DWORD) 0);
    
    m_bufferEventLayout.Write(dwEventIndex);

    m_bufferEventLayout.Write(m_pSink->GetSinkID());
    
    m_bufferEventLayout.Write(nPropertyCount);
    
    m_bufferEventLayout.WriteAlignedLenString(szEventName);
    
    
    // Make this upper case to simplify lookups.
    _wcsupr((LPWSTR) GetClassName());
    
    // Setup the main event buffer    
    Reset();

    Write((DWORD) NC_SRVMSG_PREPPED_EVENT);

    // This serves as a place holder for the size of the message.
    Write((DWORD) 0);

    Write(dwEventIndex);
    
    // This will setup our table pointers.
    RecalcTables();

    // Set mask to indicate all values are null.
    ZeroMemory(m_pdwNullTable, (LPBYTE) m_pdwPropTable - (LPBYTE) m_pdwNullTable);

    // Point our buffer to where we'll put all the object data.
    m_pCurrent = (LPBYTE) m_pdwHeapData;

    m_pProps.Init(nPropertyCount);
    m_pProps.SetCount(nPropertyCount);

    for (DWORD i = 0; i < nPropertyCount; i++)
    {
        CPropInfo &info = m_pProps[i];

        if(!info.Init(pPropertyTypes[i]))
            return FALSE;

        m_bufferEventLayout.Write((DWORD) pPropertyTypes[i]);
        m_bufferEventLayout.WriteAlignedLenString(pszPropertyNames[i]);
    }

    return TRUE;
}

BOOL CEvent::FindProp(LPCWSTR szName, CIMTYPE* ptype, DWORD* pdwIndex)
{
    CCondInCritSec cs(&m_cs, IsLockable());

    DWORD dwSize = 0;
    BYTE* pProps = NULL;

    GetLayoutBuffer(&pProps, &dwSize, FALSE);
    CBuffer Buffer(pProps, dwSize);
    
    //
    // Skip the name of the event
    //

    DWORD dwNumProps = Buffer.ReadDWORD();

    DWORD dwIgnore;
    Buffer.ReadAlignedLenString(&dwIgnore);

    for(DWORD i = 0; i < dwNumProps; i++)
    {
        *ptype = Buffer.ReadDWORD();
        LPCWSTR szThisName = Buffer.ReadAlignedLenString(&dwIgnore);

        if(!wbem_wcsicmp(szName, szThisName))
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}
        
BOOL CEvent::AddProp(LPCWSTR szName, CIMTYPE type, DWORD *pdwIndex)
{
    //
    // Check the name for validity
    //

    if(szName[0] == 0)
        return FALSE;
    
    const WCHAR* pwc = szName;
 
    // Check the first letter
    // ======================
 
    if(!isunialpha(*pwc) || *pwc == '_')
        return FALSE;
    pwc++;
 
    // Check the rest
    // ==============
    
    while(*pwc)
    {
        if(!isunialphanum(*pwc))
            return FALSE;
        pwc++;
    }
 
    if(pwc[-1] == '_')
        return FALSE;

    //
    // Check the type for validity
    //

    CPropInfo info;

    if(!info.Init(type))
        return FALSE;

    CCondInCritSec cs(&m_cs, IsLockable());

    //
    // Check if the property is already there
    //

    CIMTYPE typeOld;
    DWORD dwOldIndex;
    if(FindProp(szName, &typeOld, &dwOldIndex))
    {
        return FALSE;
    }
    
    // Our layout changed, so make sure we resend it.
    ResetLayoutSent();

    DWORD nProps = GetPropertyCount();
    BOOL  bExtraNullSpaceNeeded;
    DWORD dwHeapMove;

    // If the caller cares, return the index of this property.
    if (pdwIndex)
        *pdwIndex = nProps;
    
    // Increase the number of properties.
    SetPropertyCount(++nProps);
    
    // See if we need another DWORD for our null flags.
    bExtraNullSpaceNeeded = (nProps % 32) == 1 && nProps != 1;

    // Figure how many slots we need to move up the heap pointer.
    // Always one for the new property data/pointer, and maybe one
    // if we need more null space.
    dwHeapMove = 1 + bExtraNullSpaceNeeded;

    // Move the heap pointer;
    m_pdwHeapData += dwHeapMove;

    // Convert to number of bytes.
    dwHeapMove *= sizeof(DWORD);

    // Scoot all property pointers up by the number of bytes the heap moved.
    for (int i = 0; i < nProps - 1; i++)
    {
        if (m_pProps[i].IsPointer())
            m_pdwPropTable[i] += dwHeapMove; 
    }

    // Move the current pointer up.
    MoveCurrent(dwHeapMove);

    // Slide the property data forward by dwHeapMove bytes.
    memmove(
        m_pdwHeapData, 
        (LPBYTE) m_pdwHeapData - dwHeapMove,
        m_pCurrent - (LPBYTE) m_pdwHeapData);

    // See if we're going to require another DWORD in our null table once
    // we add this property.  If so, we have some work to do.
    if (bExtraNullSpaceNeeded)
    {
        DWORD dwTableIndex;

        // Slide forward the tables by one DWORD.
        m_pdwPropTable++;

        dwTableIndex = nProps / 32;

        // Set our new entry in our table to 0 (all props null).
        m_pdwNullTable[dwTableIndex] = 0;

        // Slide forward the prop data by one slot.
        memmove(
            m_pdwPropTable,
            m_pdwPropTable - 1,
            (LPBYTE) m_pdwHeapData - (LPBYTE) m_pdwNullTable);
    }

    m_pProps.AddVal(info);

    m_bufferEventLayout.Write((DWORD) type);
    m_bufferEventLayout.WriteAlignedLenString(szName);

    return TRUE;
}

BOOL CEvent::SetSinglePropValue(DWORD dwIndex, va_list list)
{
    PROP_FUNC pFunc;
    BOOL      bRet;

    CCondInCritSec cs(&m_cs, IsLockable());

    //m_pStack = (LPVOID*) pStack;
    m_valist = list;
    m_iCurrentVar = dwIndex;

    pFunc = m_pProps[dwIndex].m_pFunc;

    bRet = (this->*pFunc)();

    return bRet;
}

BOOL CEvent::SetPropValues(CIntArray *pArr, va_list list)
{
    BOOL bRet = TRUE;

    CCondInCritSec cs(&m_cs, IsLockable());

    // Is this a 'normal' event?
    if (!pArr)
    {
        DWORD nProps = GetPropertyCount();

        //m_pStack = (LPVOID*) pStack;
        m_valist = list;
    
        for (m_iCurrentVar = 0; m_iCurrentVar < nProps && bRet; m_iCurrentVar++)
        {
            PROP_FUNC pFunc = m_pProps[m_iCurrentVar].m_pFunc;

            bRet = (this->*pFunc)();
        }
    }
    // Must be a property subset.
    else
    {
        DWORD nProps = pArr->GetCount();

        //m_pStack = (LPVOID*) pStack;
        m_valist = list;
    
        for (DWORD i = 0; i < nProps && bRet; i++)
        {
            PROP_FUNC pFunc;
            int       iRealIndex = (*pArr)[i];
            
            m_iCurrentVar = iRealIndex;
            
            pFunc = m_pProps[iRealIndex].m_pFunc;

            bRet = (this->*pFunc)();
        }
    }

    return bRet;
}

BOOL CEvent::SetPropValue(DWORD dwPropIndex, LPVOID pData, DWORD dwElements, 
    DWORD dwSize)
{
    if(dwPropIndex >= GetPropertyCount())
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    if(dwSize == 0)
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    CCondInCritSec cs(&m_cs, IsLockable());

    CPropInfo *pProp = &m_pProps[dwPropIndex];

    if (!pProp->IsPointer())
    {
        SetPropNull(dwPropIndex, FALSE);

        m_pdwPropTable[dwPropIndex] = *(DWORD*) pData;

        return TRUE;
    }

    BOOL  bRet = FALSE;
    BOOL  bLengthPrefixed = pProp->CountPrefixed();
    DWORD dwSizeNeeded = bLengthPrefixed ? dwSize + sizeof(DWORD) : dwSize;

    // Align the size.
    dwSizeNeeded = DWORD_ALIGNED(dwSizeNeeded);

    // If the value is null we'll have to make some room for the new value.
    if (IsPropNull(dwPropIndex))
    {
        LPBYTE pStart;

        // Increase our buffer size.
        MoveCurrent(dwSizeNeeded);
        
        // Make sure we get this after we call MoveCurrent, in case the
        // buffer is reallocated.
        pStart = m_pCurrent - dwSizeNeeded;

        // Copy in the new value.
        if (bLengthPrefixed)
        {
            *((DWORD*) pStart) = dwElements;
                
            if (pData)
                memcpy(pStart + sizeof(DWORD), pData, dwSize);
        }
        else
        {                
            if (pData)
                memcpy(pStart, pData, dwSize);
        }

        // Set this value as non-null.
        SetPropNull(dwPropIndex, FALSE);

        // Point to our new data.
        m_pdwPropTable[dwPropIndex] = pStart - m_pBuffer;

        pProp->m_dwCurrentSize = dwSizeNeeded;

        bRet = TRUE;
    }
    else // Value is currently non-null.
    {
        // Does the old size match the new one?  If so, just copy it in.
        if (pProp->m_dwCurrentSize == dwSizeNeeded)
        {
            if (pData)
            {
                DWORD  dwDataOffset = m_pdwPropTable[dwPropIndex];
                LPBYTE pPropData = m_pBuffer + dwDataOffset; 

                // We always have to copy this in because the elements can
                // vary for the same current size because of DWORD aligning.
                *((DWORD*) pPropData) = dwElements;

                if (bLengthPrefixed)
                    memcpy(pPropData + sizeof(DWORD), pData, dwSize);
                else
                    memcpy(pPropData, pData, dwSize);
            }

            bRet = TRUE;
        }
        else // If the sizes don't match we have a little more work to do.
        {
            int    iSizeDiff = dwSizeNeeded - pProp->m_dwCurrentSize;
            DWORD  dwOldCurrentOffset = m_pCurrent - m_pBuffer;

            // Change our buffer size.
            // This has to be done before we get the pointers below, because
            // MoveCurrent can potentially get our buffer reallocated.
            MoveCurrent(iSizeDiff);

            DWORD  dwDataOffset = m_pdwPropTable[dwPropIndex];
            LPBYTE pPropData = m_pBuffer + dwDataOffset; 
            LPBYTE pOldDataEnd = pPropData + pProp->m_dwCurrentSize;

            memmove(
                pOldDataEnd + iSizeDiff, 
                pOldDataEnd,
                m_pBuffer + dwOldCurrentOffset - pOldDataEnd);

            // Copy in the new value.
            if (bLengthPrefixed)
            {
                *((DWORD*) pPropData) = dwElements;
    
                if (pData)
                    memcpy(pPropData + sizeof(DWORD), pData, dwSize);
            }
            else
            {
                if (pData)
                    memcpy(pPropData, pData, dwSize);
            }

            // Init this property's data.
            pProp->m_dwCurrentSize = dwSizeNeeded;

            // Increment all the data pointers by the amount we just added.
            CPropInfo *pProps = m_pProps.GetData();
    
            // We have to look at them all since we're now allowing properties
            // to store data in the heap non-sequentially (e.g. property 3
            // can point to data that comes after property 4's data).
            DWORD nProps = GetPropertyCount();

            for (DWORD i = 0; i < nProps; i++)
            {
                if (pProps[i].IsPointer() && m_pdwPropTable[i] > dwDataOffset)
                    m_pdwPropTable[i] += iSizeDiff;
            }
                    
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL CEvent::SetPropNull(DWORD dwPropIndex)
{
    CCondInCritSec cs(&m_cs, IsLockable());

    if(dwPropIndex >= GetPropertyCount())
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    // Only do something if the value isn't already null.
    if (!IsPropNull(dwPropIndex))
    {
        // Mark the given index as null.
        SetPropNull(dwPropIndex, TRUE);

        if (m_pProps[dwPropIndex].IsPointer())
        {
            CPropInfo *pProps = m_pProps.GetData();
            DWORD      nProps = GetPropertyCount(),
                       dwSizeToRemove = pProps[dwPropIndex].m_dwCurrentSize;
            DWORD      dwDataOffset = m_pdwPropTable[dwPropIndex];
            LPBYTE     pDataToRemove = m_pBuffer + dwDataOffset; 

            // Slide up all the data that comes after the one we're nulling 
            // out.
            memmove(
                pDataToRemove, 
                pDataToRemove + dwSizeToRemove, 
                m_pCurrent - pDataToRemove - dwSizeToRemove);
    
            // Reduce the size of our send buffer.
            MoveCurrent(-dwSizeToRemove);

            // Decrement all the data pointers by the amount we just removed.
            for (DWORD i = 0; i < nProps; i++)
            {
                if (pProps[i].IsPointer() && 
                    m_pdwPropTable[i] > dwDataOffset) 
                {
                    m_pdwPropTable[i] -= dwSizeToRemove;
                }
            }
        }
    }

    return TRUE;
}

LPBYTE CEvent::GetPropData(DWORD dwPropIndex)
{
    CPropInfo *pProp = &m_pProps[dwPropIndex];
    LPBYTE    pData;

    if (pProp->IsPointer())
    {
        DWORD dwDataOffset = m_pdwPropTable[dwPropIndex];
        
        pData = m_pBuffer + dwDataOffset;
    }
    else
        pData = (LPBYTE) &m_pdwPropTable[dwPropIndex];

    return pData;   
}

BOOL CEvent::GetPropValue(
    DWORD dwPropIndex, 
    LPVOID pData, 
    DWORD dwBufferSize,
    DWORD *pdwBytesRead)
{
    CCondInCritSec cs(&m_cs, IsLockable());

    if(dwPropIndex >= GetPropertyCount())
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    if(dwBufferSize == 0)
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    BOOL      bRet = FALSE;

    // If the value is non-null then read it.
    if (!IsPropNull(dwPropIndex))
    {
        CPropInfo *pProp = &m_pProps[dwPropIndex];
        DWORD     dwSizeToRead = pProp->m_dwCurrentSize;
        LPBYTE    pPropData = GetPropData(dwPropIndex);

        // Get rid of the prefix if there is any.
        if (pProp->CountPrefixed())
        {
            pPropData += sizeof(DWORD);
            dwSizeToRead -= sizeof(DWORD);
        }

        // Make sure we have enough room for the output data.
        if (dwBufferSize >= dwSizeToRead)
        {
            memcpy(pData, pPropData, dwSizeToRead);
            *pdwBytesRead = dwSizeToRead;
            bRet = TRUE;
        }
    }
    else
    {
        *pdwBytesRead = 0;
        bRet = TRUE;
    }

    return bRet;
}

BOOL CEvent::AddStringW()
{
    BOOL    bRet = TRUE;
    LPCWSTR szVal = va_arg(m_valist, LPCWSTR);

    if (!szVal)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD dwLen = (wcslen(szVal) + 1) * sizeof(WCHAR);
        
        bRet = 
            SetPropValue(
                m_iCurrentVar, 
                (LPVOID) szVal, 
                dwLen,    // This will be written into the buffer as the size
                          // of the string.
                dwLen);   // The number of bytes we need.
    }

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddScalarArray()
{
    BOOL   bRet = TRUE;
    LPBYTE pData = va_arg(m_valist, LPBYTE);
    DWORD  dwElements = va_arg(m_valist, DWORD);

    if (!pData)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD dwSize;

        // The caller gives us the number of elements in the array.  So,
        // multiply the number of elements by the element size.
        dwSize = m_pProps[m_iCurrentVar].m_dwElementSize * dwElements;

        bRet = SetPropValue(m_iCurrentVar, pData, dwElements, dwSize);

        // Moves past the LPVOID and the DWORD.
        //m_pStack += 2;
    }

    return bRet;
}


BOOL CEvent::AddStringArray()
{
    BOOL    bRet = TRUE;
    LPCWSTR *pszStrings = va_arg(m_valist, LPCWSTR*);
    DWORD   dwItems = va_arg(m_valist, DWORD);

    if (!pszStrings)
        SetPropNull(m_iCurrentVar);
    else
    {
        // Copy the strings into our buffer.
        DWORD dwTotalLen = 0;

        // Calculate the total length.
        for (DWORD i = 0; i < dwItems; i++)
        {
            // The amount of buffer each string takes must be DWORD aligned.
            dwTotalLen += DWORD_ALIGNED(wcslen(pszStrings[i]) + 1) * sizeof(WCHAR);
        }

        // Account for the DWORDs before each string.
        dwTotalLen += sizeof(DWORD) * dwItems;

        // Use a NULL for the data pointer to just make room for the strings
        // without copying in the data.
        bRet = SetPropValue(m_iCurrentVar, NULL, dwItems, dwTotalLen);

        if (bRet)
        {
            // Copy the strings into our buffer.
            LPBYTE pCurrent = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            for (DWORD i = 0; i < dwItems; i++)
            {
                DWORD dwLen = (wcslen(pszStrings[i]) + 1) * sizeof(WCHAR);

                // Add the prefixed size.
                *(DWORD*) pCurrent = dwLen;

                // Copy in the string.  Don't use an aligned len because
                // we only copy exactly dwLen bytes.
                memcpy(pCurrent + sizeof(DWORD), pszStrings[i], dwLen);
                
                pCurrent += 
                    sizeof(DWORD) + 
                    DWORD_ALIGNED(*(DWORD*) pCurrent);
            }

            // Moves past the LPVOID and the DWORD.
            //m_pStack += 2;
        }
        else
            bRet = FALSE;
    }

    return bRet;
}

BOOL CEvent::AddObject()
{
    BOOL   bRet = TRUE;
    HANDLE hEvent = va_arg(m_valist, HANDLE);

    if (!hEvent)
        SetPropNull(m_iCurrentVar);
    else
    {
        CEvent *pEvent = ((CEventWrap*) hEvent)->GetEvent();
        DWORD  dwTotalLen,
               dwLayoutLen,
               dwDataLen;
        LPBYTE pLayout,
               pData;
                   
        pEvent->GetLayoutBuffer(&pLayout, &dwLayoutLen, FALSE); 
        pEvent->GetDataBuffer(&pData, &dwDataLen, FALSE); 

        dwTotalLen = dwLayoutLen + dwDataLen;
        
        // Use a NULL for the data pointer to just make room for the event
        // buffers without copying in the data.
        // Note that because the property has m_bCountPrefixNeeded set to 
        // TRUE, SetPropValue will write in the 3rd argument (the length of 
        // the object) into the first DWORD.
        bRet = 
            SetPropValue(
                m_iCurrentVar, 
                NULL, 
                // Aligned since this will represent the size of the buffer
                // taken by the object.
                DWORD_ALIGNED(dwTotalLen),
                // This one should not be aligned because it's the literal number
                // of bytes we're going to copy into the buffer.
                dwTotalLen);
            
        if (bRet)
        {
            // Now that we have some room, copy in the data.
            // The sizeof(DWORD) gets us past the length of the object.
            LPBYTE pDestData = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            memcpy(pDestData, pLayout, dwLayoutLen);
            memcpy(pDestData + dwLayoutLen, pData, dwDataLen);
        }
    }

    //m_pStack++;
    
    return bRet;
}


BOOL CEvent::AddWmiObject()
{
    BOOL        bRet = TRUE;
    _IWmiObject *pObj = 
                    (_IWmiObject*) (IWbemClassObject*) va_arg(m_valist, IWbemClassObject*);

    if (!pObj)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD   dwTotalLen = 0;
        HRESULT hr;
                   
        hr = 
            pObj->GetObjectParts(
                NULL, 
                0, 
                WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                    WBEM_OBJ_CLASS_PART,
                &dwTotalLen);
            
        // This should never happen, but just in case...
        if (hr != WBEM_E_BUFFER_TOO_SMALL)
            return FALSE;

        // Use a NULL for the data pointer to just make room for the event
        // buffers without copying in the data.
        // Note that because the property has m_bCountPrefixNeeded set to 
        // TRUE, SetPropValue will write in the 3rd argument (the length of 
        // the object) into the first DWORD.
        bRet = 
            SetPropValue(
                m_iCurrentVar, 
                NULL, 
                // Aligned since this will represent the size of the buffer
                // taken by the object.
                DWORD_ALIGNED(dwTotalLen),
                // This one should not be aligned because it's the literal number
                // of bytes we're going to copy into the buffer.
                dwTotalLen);
            
        if (bRet)
        {
            // Now that we have some room, copy in the data.
            // The sizeof(DWORD) gets us past the length of the object.
            LPBYTE pDestData = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            hr = 
                pObj->GetObjectParts(
                    pDestData, 
                    dwTotalLen, 
                    WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                        WBEM_OBJ_CLASS_PART,
                    &dwTotalLen);

            bRet = SUCCEEDED(hr);
        }
    }

    return bRet;
}

BOOL CEvent::AddBYTE()
{
    BYTE cData = va_arg(m_valist, BYTE);
    BOOL bRet = SetPropValue(m_iCurrentVar, &cData, 1, sizeof(BYTE));

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddWORD()
{
    WORD wData = va_arg(m_valist, WORD);
    BOOL bRet = 
            SetPropValue(m_iCurrentVar, &wData, 1, sizeof(WORD));

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddDWORD()
{
    DWORD dwData = va_arg(m_valist, DWORD);
    BOOL  bRet = SetPropValue(m_iCurrentVar, &dwData, 1, sizeof(DWORD));

    //m_pStack++;

    return bRet;
}

BOOL CEvent::AddFloat()
{
    // The compiler pushes 64-bit doubles when passing floats, so we'll have
    // to first convert it to a 32-bit float.
    //float fValue = (float) *(double*) m_pStack;
    float fValue = va_arg(m_valist, double);
    BOOL  bRet = SetPropValue(m_iCurrentVar, &fValue, 1, sizeof(float));

    // Account for the 64-bits passed on the stack.
    //m_pStack += 2;

    return bRet;
}

BOOL CEvent::AddDWORD64()
{
    DWORD64 dwData = va_arg(m_valist, DWORD64);
    BOOL    bRet = SetPropValue(m_iCurrentVar, &dwData, 1, sizeof(DWORD64));

    // To get past both DWORDs.
    //m_pStack += 2;

    return bRet;
}

BOOL CEvent::SendEvent()
{
    BOOL bRet = FALSE;

    if (IsEnabled())
    {
        CCondInCritSec cs(&m_cs, IsLockable());

        if (!m_bLayoutSent)
        {
            DWORD dwLayoutSize = m_bufferEventLayout.GetUsedSize();

            // Embed the layout size in the message.
            ((DWORD*) m_bufferEventLayout.m_pBuffer)[1] = dwLayoutSize;

            m_bLayoutSent = 
                m_pSink->GetConnection()->SendData(
                    m_bufferEventLayout.m_pBuffer,
                    dwLayoutSize);
        }

        if (m_bLayoutSent)
        {
            DWORD dwDataSize = GetUsedSize();

            // Embed the data buffer size in the message.
            ((DWORD*) m_pBuffer)[1] = dwDataSize;

            bRet = m_pSink->GetConnection()->SendData(m_pBuffer, dwDataSize);
        }
    }
    
    return bRet;        
}

void CEvent::GetLayoutBuffer(
    LPBYTE *ppBuffer, 
    DWORD *pdwSize,
    BOOL bIncludeHeader)
{
    DWORD dwHeaderSize = bIncludeHeader ? 0 : sizeof(DWORD) * 4;

    // Get past the header stuff.
    *ppBuffer = m_bufferEventLayout.m_pBuffer + dwHeaderSize;

    // Subtract off the header stuff.
    *pdwSize = m_bufferEventLayout.GetUsedSize() - dwHeaderSize;
}

void CEvent::GetDataBuffer(
    LPBYTE *ppBuffer, 
    DWORD *pdwSize,
    BOOL bIncludeHeader)
{
    DWORD dwHeaderSize = bIncludeHeader ? 0 : sizeof(DWORD) * 3;

    // Get past the header stuff.
    *ppBuffer = m_pBuffer + dwHeaderSize;

    // Subtract off the header stuff.
    *pdwSize = GetUsedSize() - dwHeaderSize;
}

BOOL CEvent::SetLayoutAndDataBuffers(
    LPBYTE pLayoutBuffer,
    DWORD dwLayoutBufferSize,
    LPBYTE pDataBuffer,
    DWORD dwDataBufferSize)
{
    DWORD dwEventIndex = InterlockedExchangeAdd((long*) &g_dwEventIndex, 1);
    int   nProps;

    CCondInCritSec cs(&m_cs, IsLockable());

    // Setup the event layout buffer.
    m_bufferEventLayout.Reset();
    
    // Set the layout buffer.
    m_bufferEventLayout.Write(pLayoutBuffer, dwLayoutBufferSize);
    
    // Add the new index we just created.
    *(((DWORD*) m_bufferEventLayout.m_pBuffer) + 1) = dwEventIndex;
    
    // Get the number of props from the layout buffer.
    nProps = GetPropertyCount();

    // Setup the main event buffer    
    Reset();
    Write(pDataBuffer, dwDataBufferSize);

    // Add the new index we just created.
    *(((DWORD*) m_pBuffer) + 1) = dwEventIndex;

    m_pProps.Init(nProps);
    m_pProps.SetCount(nProps);

    // Setup our data tables.
    RecalcTables();

    LPBYTE pLayoutCurrent = 
            // Get past the header and property count.
            (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 5);

    // Get past the event name.
    pLayoutCurrent += sizeof(DWORD) + DWORD_ALIGNED(*(DWORD*) pLayoutCurrent);

    // For each non-null pointer property, figure out the property's size.
    for (DWORD i = 0; i < nProps; i++)
    {
        CPropInfo &info = m_pProps[i];
        CIMTYPE   dwType = *(DWORD*) pLayoutCurrent;

        info.Init(dwType);
        
        // Get past the type, the length of the property name, and the property
        // name itself.
        pLayoutCurrent += 
            sizeof(DWORD) * 2 + 
            DWORD_ALIGNED(*(DWORD*) (pLayoutCurrent + sizeof(DWORD)));

        if (!IsPropNull(i) && info.IsPointer())
        {
            LPBYTE pData = GetPropData(i);

            info.InitCurrentSize(pData);
        }
    }

    return TRUE;
}

#define DEF_HEAP_EXTRA  256

void CEvent::RecalcTables()
{
    DWORD nProps = GetPropertyCount(),
          dwNullSize;

    m_pdwNullTable = (DWORD*) (m_pBuffer + sizeof(DWORD) * 3);
    dwNullSize = (nProps + 31) / 32;
    if (!dwNullSize)
        dwNullSize = 1;

    m_pdwPropTable = m_pdwNullTable + dwNullSize;

    m_pdwHeapData = m_pdwPropTable + nProps;

    DWORD dwSize = (LPBYTE) m_pdwHeapData - m_pCurrent;

    if ((LPBYTE) m_pdwHeapData - m_pBuffer > m_dwSize)
        Resize((LPBYTE) m_pdwHeapData - m_pBuffer + DEF_HEAP_EXTRA);

    dwSize = m_pCurrent - (LPBYTE) m_pdwHeapData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\event.h ===
// Event.h
// These classes represent the hEvent returned by the CreateEvent functions.

#pragma once

// Forward declarations
class CConnection;
class CEvent;

#include "array.h"
#include "NCObjApi.h"

/////////////////////////////////////////////////////////////////////////////
// CPropInfo

typedef BOOL (CEvent::*PROP_FUNC)();

typedef CArray<int, int> CIntArray;

class CPropInfo
{
public:
    DWORD     m_dwCurrentSize;
    DWORD     m_dwElementSize;
    PROP_FUNC m_pFunc;

    BOOL Init(CIMTYPE type);
    BOOL CountPrefixed() { return m_bCountPrefixNeeded; }

    BOOL IsPointer()
    {
        return m_bPointer;
    }

    void InitCurrentSize(LPBYTE pData);

protected:
    BOOL      m_bCountPrefixNeeded;
    BOOL      m_bPointer;
};

/////////////////////////////////////////////////////////////////////////////
// CEventWrap

typedef CArray<CPropInfo, CPropInfo&> CPropInfoArray;

class CEventWrap
{
public:
    CEventWrap(CSink *pSink, DWORD dwFlags);
    CEventWrap(CEvent *pEvent, int nIndexes, DWORD *pdwIndexes);
    ~CEventWrap();

    BOOL IsSubset() { return !m_bFreeEvent; }
    CEvent *GetEvent() { return m_pEvent; }
    CIntArray *GetIndexArray() { return !IsSubset() ? NULL : &m_pIndexes; }

    int SubIndexToEventIndex(int iIndex)
    {
        if (!IsSubset())
            return iIndex;
        else
        {
            if(iIndex < 0 || iIndex >= m_pIndexes.GetSize())
            {
                _ASSERT(FALSE);
                return -1;
            }

            return m_pIndexes[iIndex];
        }
    }

protected:
    CEvent    *m_pEvent;
    CIntArray m_pIndexes;
    BOOL      m_bFreeEvent;
};


/////////////////////////////////////////////////////////////////////////////
// CEvent

// LenStr:
// DWORD         nBytes - Bytes in the string.
// WCHAR[nBytes] String data.
// BYTE[0-3]     Padding to make the string DWORD aligned.

// Event Layout Buffer:
// DWORD         NC_SRVMSG_EVENT_LAYOUT (msg type)
// DWORD         dwMsgBytes - The total number of bytes in the buffer.
// DWORD         dwEventIndex
// DWORD         dwSinkIndex
// DWORD         nProperties
// LenStr        szEventClassName
// The next two properties are repeated for each property.
// DWORD         dwPropType (Uses CIMTYPE values)
// LenStr        szPropertyName

// Event Data Buffer:
// DWORD         NC_SRVMSG_PREPPED_EVENT (msg type)
// DWORD         dwMsgBytes - The total number of bytes in the buffer.
// DWORD         dwEventIndex
// DWORD[n]      cNullMask (0 bit == null)
//               n = # of props divided by 32.  If no props, n == 1.
// DWORD[nProps] dwDataInfo
//               This contains actual data for scalar values for types that
//               fit into 32-bits and offsets the to data for everything else.
//               Offsets are relative from the start of the buffer.
// BYTE[???]     The data pointed to by dwDataInfo (if necessary).

// Event SD:
// DWORD         NC_SRVMSG_SET_EVENT_SD
// DWORD         dwMsgBytes - The total number of bytes in the buffer.
// DWORD         dwEventIndex
// BYTE[]        SD data

// Data encoding (total length is always DWORD aligned):
// Strings:
// All strings, both alone and in arrays, are encoded as LenStr's.

//
// Arrays:
// DWORD          dwItems - Number of elements in the array.
// Type[dwItems]  array data
// BYTE[0-3]      Padding to make the data end on a DWORD boundary.
//
// Objects:
// DWORD          dwBytes - Number of bytes of object data.
// BYTE[dwBytes]  Layout Buffer + Data Buffer
// BYTE[0-3]      Padding to make the data end on a DWORD boundary.
//

// Blob Event Layout:
// DWORD          NC_SRVMSG_BLOB_EVENT
// DWORD          dwMsgBytes - The total number of bytes in the buffer.
// DWORD          dwSinkIndex
// LenStr         szEventName
// DWORD          dwSize - Size of blob.
// BYTE[dwSize]   pBlob

class CEvent : public CBuffer
{
public:
    CRITICAL_SECTION m_cs;
    CSink            *m_pSink;

    CEvent(CSink *pSink, DWORD dwFlags);
    ~CEvent();

    void ResetEvent();
    
    // Prepared event functions
    BOOL PrepareEvent(
        LPCWSTR szEventName,
        DWORD nPropertyCount,
        LPCWSTR *pszPropertyNames,
        CIMTYPE *pPropertyTypes);
    BOOL FindProp(LPCWSTR szName, CIMTYPE* ptype, DWORD* pdwIndex);
    BOOL AddProp(LPCWSTR szName, CIMTYPE type, DWORD *pdwIndex);
    BOOL SetPropValues(CIntArray *pArr, va_list list);
    BOOL SetSinglePropValue(DWORD dwIndex, va_list list);
    BOOL SetPropValue(DWORD dwPropIndex, LPVOID pData, DWORD dwElements, 
        DWORD dwSize);
    BOOL GetPropValue(DWORD dwPropIndex, LPVOID pData, DWORD dwBufferSize,
        DWORD *pdwBytesRead);
    BOOL SetPropNull(DWORD dwPropIndex);

    void ResetLayoutSent() { m_bLayoutSent = FALSE; }

    CBuffer *GetLayout() { return &m_bufferEventLayout; }
    CPropInfo *GetProp(DWORD dwIndex) { return &m_pProps[dwIndex]; }

    BOOL SendEvent();

    friend CPropInfo; // For CPropInfo::Init.
    friend CEventWrap;

    LPCWSTR GetClassName() 
    { 
        return (LPCWSTR) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 6);
    }

    BOOL IsEnabled() 
    { 
        BOOL bEnabled;

        bEnabled =
            m_bEnabled ||
            (m_pSink->GetConnection() && 
                m_pSink->GetConnection()->WaitingForWMIInit());

        return bEnabled;
    }
    void SetEnabled(BOOL bEnabled) { m_bEnabled = bEnabled; }

    void GetLayoutBuffer(
        LPBYTE *ppBuffer, 
        DWORD *pdwSize, 
        BOOL bIncludeHeader);
    void GetDataBuffer(
        LPBYTE *ppBuffer, 
        DWORD *pdwSize,
        BOOL bIncludeHeader);
    
    BOOL SetLayoutAndDataBuffers(
        LPBYTE pLayoutBuffer,
        DWORD dwLayoutBufferSize,
        LPBYTE pDataBuffer,
        DWORD dwDataBufferSize);

    void Lock()
    {
        if (IsLockable())
            EnterCriticalSection(&m_cs);
    }

    void Unlock()
    {
        if (IsLockable())
            LeaveCriticalSection(&m_cs);
    }

    BOOL IsPropNull(DWORD dwIndex)
    {
        LPDWORD pTable = GetNullTable();

        return !(pTable[dwIndex / 32] & (1 << (dwIndex % 32)));
    }

    void SetPropNull(DWORD dwIndex, BOOL bNull)
    {
        LPDWORD pTable = GetNullTable();

        if (bNull)
            pTable[dwIndex / 32] &= ~(1 << (dwIndex % 32));
        else
            pTable[dwIndex / 32] |= 1 << (dwIndex % 32);
    }

    BOOL IsLockable()
    {
        return (m_dwFlags & WMI_CREATEOBJ_LOCKABLE) != 0;
    }

protected:
    CPropInfoArray   m_pProps;
    CBuffer          m_bufferEventLayout;
    BOOL             m_bLayoutSent,
                     m_bEnabled;
    DWORD            m_iCurrentVar,
                     m_dwFlags;
    va_list          m_valist;

    DWORD *m_pdwNullTable;
    DWORD *m_pdwPropTable;
    DWORD *m_pdwHeapData;

    void RecalcTables();

    BOOL AddBYTE();
    BOOL AddWORD();
    BOOL AddDWORD();
    BOOL AddDWORD64();
    BOOL AddFloat();
    BOOL AddStringW();
    BOOL AddObject();
    BOOL AddWmiObject();
    BOOL AddScalarArray();
    BOOL AddStringArray();

    DWORD GetEventIndex()
    {
        return *(DWORD*) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 2);
    }

    DWORD GetPropertyCount() 
    {
        return *(DWORD*) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 4);
    }

    void SetPropertyCount(DWORD nProps)
    {
        *(DWORD*) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 4) =
            nProps;
    }

    DWORD *GetNullTable() 
    {
        return m_pdwNullTable;
    }

    LPBYTE GetPropData(DWORD dwPropIndex);
    
    // Used by SetLayoutAndDataBuffers to figure out the current data size of
    // a property and set m_dwCurrentSize with it.
    DWORD CalcPropDataSize(CPropInfo *pInfo);

    // Called when our buffer is resized.
    virtual void OnResize()
    {
        RecalcTables();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\namedpipe.h ===
// NamedPipe.h

#pragma once

#include "Transport.h"

#define CALLBACK_BUFFSIZE   2048

struct READ_DATA
{
    OVERLAPPED       overlap;
    BYTE             cBuffer[CALLBACK_BUFFSIZE];
    class CNamedPipeClient *pThis;
};

class CNamedPipeClient : public CTransport
{
public:
    CNamedPipeClient();
    virtual ~CNamedPipeClient();

    // Overrideables
    virtual IsReady();
    virtual BOOL SendData(LPBYTE pBuffer, DWORD dwSize);
    virtual void Deinit();
    virtual BOOL InitCallback();
    virtual void SendMsgReply(NC_SRVMSG_REPLY *pReply);


    // Init function.
    virtual BOOL Init(LPCWSTR szBasePipeName, LPCWSTR szBaseProviderName);

    BOOL SignalProviderDisabled();

protected:
    HANDLE // Objects visible to P2 client but created by the server.
           m_hPipe,
           m_heventProviderReady,
           // Other handles used for implementation
           m_hthreadReady,
           m_heventDone;

    WCHAR  m_szPipeName[MAX_PATH],
           m_szProviderReadyEvent[MAX_PATH];
    BOOL   m_bDone;

    void DeinitPipe();
    BOOL GetPipe();
    static DWORD WINAPI ProviderReadyThreadProc(CNamedPipeClient *pThis);
    static void WINAPI CompletedReadRoutine(
        DWORD dwErr, 
        DWORD nBytesRead, 
        LPOVERLAPPED pOverlap);

    BOOL StartReadyThreadProc();
    long DealWithBuffer(READ_DATA* pData, DWORD dwOrigBytesRead, 
                        BOOL* pbClosePipe);


    // Callback properties.
    HANDLE m_heventCallbackReady,
           m_hthreadCallbackListen;

    // Callback methods.
    static DWORD WINAPI CallbackListenThreadProc(CNamedPipeClient *pThis);
    BOOL StartCallbackListenThread();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\namedpipe.cpp ===
// NamedPipe.cpp

#include "precomp.h"
#include "NamedPipe.h"
#include "NCDefs.h"
#include "DUtils.h"
#include "Connection.h"

CNamedPipeClient::CNamedPipeClient() :
    m_hPipe(INVALID_HANDLE_VALUE),
    m_hthreadReady(NULL),
    m_heventProviderReady(NULL),
    m_heventDone(NULL),
    m_heventCallbackReady(NULL),
    m_hthreadCallbackListen(NULL),
    m_bDone(FALSE)
{
}    

CNamedPipeClient::~CNamedPipeClient()
{
}

CNamedPipeClient::IsReady()
{
    return m_hPipe != INVALID_HANDLE_VALUE;
}

BOOL CNamedPipeClient::SendData(LPBYTE pBuffer, DWORD dwSize)
{
    BOOL  bWritten;
    DWORD dwWritten;

#ifdef NO_SEND
    bWriten = TRUE;
#else
    bWritten = 
        WriteFile(
            m_hPipe,
            pBuffer,
            dwSize,
            &dwWritten,
            NULL);

    if (!bWritten)
    {
        TRACE("%d: WriteFile failed, err = %d", GetCurrentProcessId(), GetLastError());
        
        DeinitPipe();

        // Start watching for our provider to be ready, and get the pipe.
        StartReadyThreadProc();
    }
#endif

    return bWritten;
}

void CNamedPipeClient::Deinit()
{
    HANDLE hthreadReady,
           hthreadCallbackListen;

    // Protect m_bDone, m_hthreadReady, m_hthreadCallbackListen.
    {
        CInCritSec cs(&m_cs);

        hthreadReady = m_hthreadReady;
        hthreadCallbackListen = m_hthreadCallbackListen;

        m_hthreadReady = NULL;
        m_hthreadCallbackListen = NULL;

        m_bDone = TRUE;
    }

    // Tells both the ready and the callback listen threads to go away.
    SetEvent(m_heventDone);

    if (hthreadReady)
    {
        WaitForSingleObject(hthreadReady, INFINITE);
        CloseHandle(hthreadReady);
    }

    if (hthreadCallbackListen)
    {
        WaitForSingleObject(hthreadCallbackListen, INFINITE);
        CloseHandle(hthreadCallbackListen);
    }

    DeinitPipe();

    CloseHandle(m_heventDone);

    delete this;
}

// Init function.
BOOL CNamedPipeClient::Init(LPCWSTR szBaseNamespace, LPCWSTR szBaseProvider)
{
    //HANDLE heventProviderReady;

    // Get the ready event.
    StringCchPrintfW(
        m_szProviderReadyEvent, 
        MAX_PATH,
        OBJNAME_EVENT_READY L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    // Construct the pipe name.
    StringCchPrintfW(
        m_szPipeName,
        MAX_PATH,
        L"\\\\.\\pipe\\" OBJNAME_NAMED_PIPE L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    m_heventDone =
        CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_heventDone == NULL)
        return FALSE;

    // Before we start the thread see if our provider is ready right off 
    // the bat.
    if (!GetPipe())
        return StartReadyThreadProc();

    return TRUE;
}

BOOL CNamedPipeClient::SignalProviderDisabled()
{
    if (m_hPipe != INVALID_HANDLE_VALUE)
    {
        m_pConnection->IndicateProvDisabled();

        DeinitPipe();

        if(!StartReadyThreadProc())
            return FALSE;
    }
    return TRUE;
}

BOOL CNamedPipeClient::StartReadyThreadProc()
{
    DWORD dwID;

    // Protect m_bDone and m_hthreadReady.
    CInCritSec cs(&m_cs);

    // No need if we're already cleaning up.
    if (m_bDone)
        return TRUE;

    if (m_hthreadReady)
        CloseHandle(m_hthreadReady);

    m_hthreadReady =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) ProviderReadyThreadProc,
            this,
            0,
            &dwID);

    if(m_hthreadReady == NULL)
        return FALSE;

    return TRUE;
}

void CNamedPipeClient::DeinitPipe()
{
    CInCritSec cs(&m_cs);

    // Close the pipe.
    if (m_hPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPipe);
        m_hPipe = INVALID_HANDLE_VALUE;
    }
}

BOOL CNamedPipeClient::GetPipe()
{
    // This block must be protected to keep other threads
    // from also trying to get the pipe.

    TRACE("Attempting to get event pipe...");

    CInCritSec cs(&m_cs);

    SetLastError(0);

#define MAX_RETRIES 10

    if (m_hPipe == INVALID_HANDLE_VALUE)
    {
        // Get the pipe
        for (int i = 0; i < MAX_RETRIES; i++)
        {
            m_hPipe =
                CreateFileW(
                    m_szPipeName, 
                    GENERIC_READ | GENERIC_WRITE, 
                    0, 
                    NULL, 
                    OPEN_EXISTING, 
                    FILE_FLAG_OVERLAPPED | SECURITY_IDENTIFICATION | 
                    SECURITY_SQOS_PRESENT,
                    NULL);

            if ( m_hPipe != INVALID_HANDLE_VALUE )
            {
                //
                // we want to handle Reads using message mode.
                //
 
                DWORD dwMode = PIPE_READMODE_MESSAGE;
                
                if ( SetNamedPipeHandleState( m_hPipe, &dwMode, NULL, NULL ) )
                {
                    break;
                }
                else
                {
                    TRACE("SetNamedPipeHandleState() Failed.");
                }
            }
            else if (GetLastError() == ERROR_PIPE_BUSY)
            {
                TRACE("Pipe is busy, we'll try again.");

                // Try again to get a pipe instance if the pipe is currently busy.
                Sleep(100);

                continue;
            }
        } 

        if (m_hPipe != INVALID_HANDLE_VALUE)
        {
            TRACE("Got the pipe, calling IncEnabledCount.");

            if(!m_pConnection->IndicateProvEnabled())
                return FALSE;
        }
        else
            TRACE("Failed to get send pipe.");
    }
    else
        TRACE("Already have a valid pipe.");

    return m_hPipe != INVALID_HANDLE_VALUE;
}

DWORD WINAPI CNamedPipeClient::ProviderReadyThreadProc(CNamedPipeClient *pThis)
{
    try
    {
        HANDLE hwaitReady[2];

        hwaitReady[0] = pThis->m_heventDone;
        
        // Create the provider ready event.
        hwaitReady[1] =
            OpenEventW(
                SYNCHRONIZE,
                FALSE,
                pThis->m_szProviderReadyEvent);

        if (!hwaitReady[1])
        {
            PSECURITY_DESCRIPTOR pSD = NULL;
            DWORD                dwSize;

            if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
                ESS_EVENT_SDDL,  // security descriptor string
                SDDL_REVISION_1, // revision level
                &pSD,            // SD
                &dwSize) )
                return GetLastError();

            SECURITY_ATTRIBUTES sa = { sizeof(sa), pSD, FALSE };

            hwaitReady[1] =
                CreateEventW(
                    &sa,
                    TRUE,
                    FALSE,
                    pThis->m_szProviderReadyEvent);

            DWORD dwErr = GetLastError();

            if (pSD)
                LocalFree((HLOCAL) pSD);

            if (!hwaitReady[1])
            {
                TRACE("Couldn't create provider ready event: %d", dwErr);
                return dwErr;
            }
        }

        TRACE("(Pipe) Waiting for provider ready event.");

        while (WaitForMultipleObjects(2, hwaitReady, FALSE, INFINITE) == 1 &&
            !pThis->GetPipe())
        {
            // TODO: Should we close the ready event and then reopen it after we 
            // sleep?
            Sleep(100);
        }

        // Close the provider ready event.
        CloseHandle(hwaitReady[1]);
    }
    catch( CX_MemoryException )
    {
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}

BOOL CNamedPipeClient::InitCallback()
{
    if (!m_heventCallbackReady)
    {
        m_heventCallbackReady = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(m_heventCallbackReady == NULL)
            return FALSE;
    }

    if(!StartCallbackListenThread())
        return FALSE;

    return TRUE;
}

#define PIPE_SIZE   64000
#define CONNECTING_STATE 0 
#define READING_STATE    1 
#define WRITING_STATE    2 


void CNamedPipeClient::SendMsgReply(NC_SRVMSG_REPLY *pReply)
{
    if (pReply)
        SendData((LPBYTE) pReply, sizeof(*pReply));    
}


DWORD WINAPI CNamedPipeClient::CallbackListenThreadProc(CNamedPipeClient *pThis)
{
    try
    {
        READ_DATA dataRead;
        HANDLE    heventPipeDied = CreateEvent(NULL, TRUE, FALSE, NULL),
                  hWait[2] = { pThis->m_heventDone, heventPipeDied };

        ZeroMemory(&dataRead.overlap, sizeof(dataRead.overlap));
        
        // Since ReadFileEx doesn't use the hEvent, we'll use it to signal this proc
        // that something went wrong with the pipe and should try to reconnect.
        dataRead.overlap.hEvent = heventPipeDied;
        dataRead.pThis = pThis;

        // Our callback is ready, so indicate that it's so.
        SetEvent(pThis->m_heventCallbackReady);

        BOOL bRet;

        bRet =
            ReadFileEx(
                pThis->m_hPipe,
                dataRead.cBuffer,
                sizeof(dataRead.cBuffer),
                (OVERLAPPED*) &dataRead,
                (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine);

        if (bRet)
        {
            DWORD dwRet;

            while ((dwRet = WaitForMultipleObjectsEx(2, hWait, FALSE, INFINITE, TRUE))
                == WAIT_IO_COMPLETION)
            {
            }

            CloseHandle(heventPipeDied);

            // Note: If dwRet == 0, our done event fired and it's time to get out.

            // If we got the event that says our pipe went bad, tell our provider that
            // it's now disabled.
            if (dwRet == 1)
                pThis->SignalProviderDisabled();
        }
        else
            pThis->SignalProviderDisabled();
    }
    catch( CX_MemoryException )
    {
        return ERROR_OUTOFMEMORY;
    }
    
    return ERROR_SUCCESS;
}

void WINAPI CNamedPipeClient::CompletedReadRoutine(
    DWORD dwErr, 
    DWORD nBytesRead, 
    LPOVERLAPPED pOverlap) 
{ 
    READ_DATA        *pData = (READ_DATA*) pOverlap;
    CNamedPipeClient *pThis = pData->pThis;
 
    BOOL bClosePipe = FALSE;

    if(dwErr == 0)
    {
        if (nBytesRead)
        {
            pThis->DealWithBuffer(pData, nBytesRead, &bClosePipe);
        }
    
        if(!bClosePipe)
        {
            bClosePipe = !ReadFileEx( 
                pThis->m_hPipe, 
                pData->cBuffer, 
                sizeof(pData->cBuffer), 
                (OVERLAPPED*) pData, 
                (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 
        }
    }
    else
    {
        bClosePipe = TRUE;
    }

    if(bClosePipe)
    {
        // Close the event to tell our read loop to go away.
        SetEvent(pData->overlap.hEvent);
    }
} 

long CNamedPipeClient::DealWithBuffer( READ_DATA* pData, 
                                       DWORD dwOrigBytesRead, 
                                       BOOL* pbClosePipe)
{
    //
    // Check if the actual message is longer that the buffer
    //

    DWORD dwMessageLength = *(DWORD*)pData->cBuffer;
    *pbClosePipe = FALSE;
    BOOL bDeleteBuffer = FALSE;

    if(dwMessageLength != dwOrigBytesRead)
    {
        if ( dwMessageLength < dwOrigBytesRead )
        {
            _ASSERT( FALSE );
            return ERROR_INVALID_DATA;
        }

        //
        // Have to read the rest of it --- the message was larger than the
        // buffer
        //

        _ASSERT( dwMessageLength > dwOrigBytesRead );

        if ( dwMessageLength >= MAX_MSG_SIZE )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        BYTE* pNewBuffer = new BYTE[dwMessageLength - sizeof(DWORD)];
        if(pNewBuffer == NULL)
            return ERROR_OUTOFMEMORY;

        memcpy(pNewBuffer, pData->cBuffer + sizeof(DWORD), 
                    dwOrigBytesRead - sizeof(DWORD));

        OVERLAPPED ov;
        memset(&ov, 0, sizeof ov);
        ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(ov.hEvent == NULL)
        {
            delete [] pNewBuffer;
            return GetLastError();
        }

        DWORD dwExtraBytesRead = 0;
        BOOL bSuccess = ReadFile(m_hPipe, 
                                pNewBuffer + dwOrigBytesRead - sizeof(DWORD), 
                                dwMessageLength - dwOrigBytesRead,
                                &dwExtraBytesRead,
                                &ov);
        CloseHandle(ov.hEvent);
        if(!bSuccess)
        {
            long lRes = GetLastError();
            if(lRes == ERROR_IO_PENDING)
            {
                //
                // Fine, I can wait, I got nowhere else to go
                //

                if(!GetOverlappedResult(m_hPipe,
                        &ov, &dwExtraBytesRead, TRUE))
                {
                    *pbClosePipe = TRUE;
                    delete [] pNewBuffer;
                    return GetLastError();
                }
            }
            else
            {
                *pbClosePipe = TRUE;
                delete [] pNewBuffer;
                return lRes;
            }
        }

        if(dwExtraBytesRead != dwMessageLength - dwOrigBytesRead)
        {
            *pbClosePipe = TRUE;
            delete [] pNewBuffer;
            return ERROR_OUTOFMEMORY;
        }

        //
        // Process it
        //

        try
        {
            m_pConnection->ProcessMessage(pNewBuffer, 
                                        dwMessageLength - sizeof(DWORD));
        }
        catch(...)
        {
            *pbClosePipe = FALSE;
            delete [] pNewBuffer;
            return ERROR_OUTOFMEMORY;
        }

        delete [] pNewBuffer;
    }
    else
    {
        //
        // All here --- just process it
        //
                
        try
        {
            m_pConnection->ProcessMessage(pData->cBuffer + sizeof(DWORD), 
                                        dwMessageLength - sizeof(DWORD));
        }
        catch(...)
        {
            *pbClosePipe = FALSE;
            return ERROR_OUTOFMEMORY;
        }
    }

    return ERROR_SUCCESS;
}

BOOL CNamedPipeClient::StartCallbackListenThread()
{
    DWORD dwID;

    // Protect m_bDone and m_hthreadCallbackListen.
    {
        CInCritSec cs(&m_cs);

        if (m_bDone)
            return TRUE;

        m_hthreadCallbackListen =
            CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) CallbackListenThreadProc,
                this,
                0,
                &dwID);
        if(m_hthreadCallbackListen == NULL)
            return FALSE;
    }

    // We have to make sure our callback pipe has been created before we can
    // continue.
    WaitForSingleObject(m_heventCallbackReady, INFINITE);
    CloseHandle(m_heventCallbackReady);
    m_heventCallbackReady = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\reportevent.cpp ===
// ReportEvent.cpp
#include "precomp.h"
#include "ReportEvent.h"

CReportEventMap::~CReportEventMap()
{
    for (CReportEventMapIterator i = begin(); i != end(); i++)
        delete ((*i).second);
}

CIMTYPE CReportEventMap::PrintfTypeToCimType(LPCWSTR szType)
{
    CIMTYPE type = 0;
    LPWSTR  szArray = wcsstr(szType, L"[]");

    // Look to see if this should be an array.
    if (szArray)
    {
        type = CIM_FLAG_ARRAY;
        *szArray = 0;
    }

    // See if the remainder of the string is only a single character.
    if (*szType && !*(szType + 1))
    {
        // Set the type for the single character cases.
        switch(*szType)
        {
            case 'u':
                type |= CIM_UINT32;
                break;

            case 'd':
            case 'i':
                type |= CIM_SINT32;
                break;

            case 'f':
                type |= CIM_REAL32;
                break;

            case 'g':
                type |= CIM_REAL64;
                break;

            case 's':
                type |= CIM_STRING;
                break;

            case 'c':
                type |= CIM_UINT8;
                break;

            case 'w':
                type |= CIM_UINT16;
                break;

            case 'b':
                type |= CIM_BOOLEAN;
                break;
    
            case 'o':
                type |= CIM_OBJECT;
                break;

            case 'O':
                type |= CIM_IUNKNOWN;
                break;

            default:
                type = CIM_EMPTY;
                break;
        }
    }
    // Else check for the more complicated cases.
    else if (!wcscmp(szType, L"I64d") || !wcscmp(szType, L"I64i"))
        type |= CIM_SINT64;
    else if (!wcscmp(szType, L"I64u"))
        type |= CIM_UINT64;
    else
        type = CIM_EMPTY;
        
    return type;
}

HANDLE CReportEventMap::CreateEvent(
    HANDLE hConnection, 
    LPCWSTR szName, 
    DWORD dwFlags,
    LPCWSTR szFormat)
{
    if ( szName == NULL )
        return NULL;

    LPWSTR szTempFormat = _wcsdup(szFormat);
    HANDLE hEvent;

    // Out of memory?
    if (!szTempFormat)
        return NULL;

    hEvent =
        WmiCreateObject(
            hConnection,
            szName,
            dwFlags);
        
    if (hEvent == NULL)
    {
        free(szTempFormat);
        return NULL;
    }

    LPWSTR szCurrent = wcstok(szTempFormat, L" ");
    BOOL   bBad = FALSE;

    while (szCurrent && !bBad)
    {
        LPWSTR szType = wcschr(szCurrent, '!'),
               szBang2;

        bBad = TRUE;

        if (szType)
        {
            szBang2 = wcschr(szType + 1, '!');

            if (szBang2)
            {
                *szBang2 = 0;
                *szType = 0;
                szType++;

                CIMTYPE type = PrintfTypeToCimType(szType);

                if (type != CIM_EMPTY)
                {
                    bBad =
                        !WmiAddObjectProp(
                            hEvent,
                            szCurrent,
                            type,
                            NULL);       
                }
            }
        }
            
        szCurrent = wcstok(NULL, L" ");
    }

    if (bBad && hEvent)
    {
        // Something went wrong, so blow away the event and return NULL.
        WmiDestroyObject(hEvent);
        hEvent = NULL;
    }

    free(szTempFormat);
    return hEvent;
}


HANDLE CReportEventMap::GetEvent(
    HANDLE hConnection, 
    LPCWSTR szName, 
    LPCWSTR szFormat)
{
    HANDLE                  hEvent;
    CReportParams           params(szName, szFormat);
    CReportEventMapIterator i;

    // First find a match using the pointers, then verify it's a real match
    // by using string compares.
    if ((i = find(params)) != end())
    {
        // If it's a match, return the event we already have.
        if (params.IsEquivalent((*i).first))
            return (*i).second->GetEvent();
        else
        {
            // Was not a match, so free up the mapping.
            delete ((*i).second);
            erase(i);
        }
    }

    hEvent =
        CreateEvent(
            hConnection,
            szName,
            0,
            szFormat);

    if (hEvent)
    {
        // If everything was OK then we need to store this event in our
        // map.
        CReportItem *pItem = new CReportItem( );
            
        if (pItem)
        {
            if ( pItem->Initialize( szName, szFormat, hEvent) )
            {
                (*this)[params] = pItem;
                return hEvent;
            }
        }
        
        WmiDestroyObject(hEvent);
        return NULL;
    }
        
    return hEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\ncobjapi.cpp ===
// P2Prov.cpp : Defines the entry point for the DLL application.
//

#include "precomp.h"
#include <crtdbg.h>
#include "buffer.h"
#include "NCDefs.h"
#include "NCObjApi.h"
#include "dutils.h"

#include "Connection.h"
#include "Event.h"

#include "Transport.h"
#include "NamedPipe.h"

#include <stdio.h>

#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)

/////////////////////////////////////////////////////////////////////////////
// DllMain

BOOL APIENTRY DllMain(
    HANDLE hModule, 
    DWORD  dwReason, 
    LPVOID lpReserved)
{
    return TRUE;
}


void SetOutOfMemory()
{
    SetLastError(ERROR_OUTOFMEMORY);
}

/////////////////////////////////////////////////////
// Functions exposed in DLL

// Register to send events
HANDLE WMIAPI WmiEventSourceConnect(
    LPCWSTR szNamespace,
    LPCWSTR szProviderName,
    BOOL bBatchSend,
    DWORD dwBatchBufferSize,
    DWORD dwMaxSendLatency,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    if(szNamespace == NULL)
    {
        _ASSERT(FALSE);
        return NULL;
    }

    if(szProviderName == NULL)
    {
        _ASSERT(FALSE);
        return NULL;
    }

    CConnection *pConnection = NULL;
    CSink       *pSink = NULL;

    if (!szNamespace || !szProviderName)
        return NULL;

    try
    {
        pConnection = 
            new CConnection(bBatchSend, dwBatchBufferSize, dwMaxSendLatency);

        if (pConnection)
        {
            if (pConnection->Init(
                szNamespace, 
                szProviderName,
                pUserData,
                pCallback))
            {
                pSink = pConnection->GetMainSink();
            }
            else
            {
                delete pConnection;
                pConnection = NULL;

                SetOutOfMemory();
            }
        }
        else
            SetOutOfMemory();
    }
    catch(...)
    {
        SetOutOfMemory();
    }

    return (HANDLE) pSink;
}

void WMIAPI WmiEventSourceDisconnect(HANDLE hSource)
{
    if (!hSource)
    {
        _ASSERT(FALSE);
        return;
    }

    try
    {
        CSink *pSink = (CSink*) hSource;
        delete pSink->GetConnection();
    }
    catch(...)
    {
    }
}

BOOL 
WMIAPI
WmiCommitObject(
    HANDLE hObject)
{
    BOOL bRet = FALSE;

    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pBuffer = ((CEventWrap*) hObject)->GetEvent();

        bRet = pBuffer->SendEvent();
    }
    catch(...)
    {
    }

    return bRet;
}

BOOL WMIAPI WmiSetAndCommitObject(
    HANDLE hObject,
    DWORD dwFlags,
    ...)
{
    BOOL bRet;
    
    if (!hObject)
        return FALSE;

    if((dwFlags & ~WMI_SENDCOMMIT_SET_NOT_REQUIRED & ~WMI_USE_VA_LIST) != 0)
        return FALSE;

    try
    {
        CEventWrap *pWrap = (CEventWrap *) hObject;
        CEvent     *pEvent = pWrap->GetEvent();
        BOOL       bEnabled = pEvent->IsEnabled();

        // If the data to be set isn't important and if the event isn't
        // enabled, just return TRUE.
        if ((dwFlags & WMI_SENDCOMMIT_SET_NOT_REQUIRED) && !bEnabled)
        {
            bRet = TRUE;
        }
        else
        {
            va_list *pList;
            va_list list;

            va_start(list, dwFlags); 
            
            if (!(dwFlags & WMI_USE_VA_LIST))
                pList = &list;
            else
                pList = va_arg(list, va_list*);

            // Make sure we have the event locked until we commit the values
            // we set.
            CCondInCritSec cs(&pEvent->m_cs, pEvent->IsLockable());

            bRet = 
                pEvent->SetPropValues(
                    pWrap->GetIndexArray(),
                    *pList);

            if (bEnabled && bRet)
                WmiCommitObject(hObject);
        }
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

DWORD dwSet = 0;

BOOL WMIAPI WmiDestroyObject(
    HANDLE hObject)
{
    if (!hObject)
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    try
    {
        delete (CEventWrap *) hObject;
    }
    catch(...)
    {
    }

    return TRUE;
}


HANDLE WMIAPI WmiCreateObjectWithFormat(
    HANDLE hSource,
    LPCWSTR szClassName,
    DWORD dwFlags,
    LPCWSTR szFormat)
{
    CSink  *pSink = (CSink*) hSource;
    HANDLE hEvent;
    BOOL   bRet = FALSE;

    if (!pSink || !szClassName || !szFormat)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        hEvent = 
            pSink->m_mapReportEvents.CreateEvent(
                hSource, szClassName, dwFlags, szFormat);
    }
    catch(...)
    {
        hEvent = NULL;
    }

    return hEvent;
}

BOOL WMIAPI WmiIsObjectActive(HANDLE hObject)
{
    BOOL bRet;

    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pEvent = ((CEventWrap*) hObject)->GetEvent();
        bRet = pEvent->IsEnabled();
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;    
}

HANDLE WMIAPI WmiCreateObjectWithProps(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags,
    DWORD nPropertyCount,
    LPCWSTR *pszPropertyNames,
    CIMTYPE *pPropertyTypes)
{
    CSink      *pSink = NULL;
    CEventWrap *pWrap = NULL;

    if (!hSource || !szEventName)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        pSink = (CSink*) hSource;
        pWrap = new CEventWrap(pSink, dwFlags);

        if (pWrap)
        {
            CEvent *pEvent = pWrap->GetEvent();

            if (pWrap->GetEvent()->PrepareEvent(
                szEventName,
                nPropertyCount,
                pszPropertyNames,
                pPropertyTypes))
            {
                // Figure out if this event should be enabled (ready to be fired) 
                // or not.
                pSink->EnableEventUsingList(pEvent);
            }
            else
            {
                delete pWrap;
                pWrap = NULL;
            }
        }
        else
            SetOutOfMemory();
    }
    catch(...)
    {
    }
    
    return (HANDLE) pWrap;
}

// For adding properties one at a time.

HANDLE WMIAPI WmiCreateObject(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags)
{
    if (!hSource)
        return NULL;

    return 
        WmiCreateObjectWithProps(
            hSource,
            szEventName,
            dwFlags,
            0,
            NULL,
            NULL);
}

BOOL WMIAPI WmiAddObjectProp(
    HANDLE hObject,
    LPCWSTR szPropertyName,
    CIMTYPE type,
    DWORD *pdwPropIndex)
{
    BOOL bRet;

    if (!hObject || !szPropertyName)
        return FALSE;

    try
    {
        CEvent *pBuffer = ((CEventWrap *) hObject)->GetEvent();

        bRet = pBuffer->AddProp(szPropertyName, type, pdwPropIndex);
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\precomp.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
#define AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <windows.h>
#include <comdef.h>
#include <strsafe.h>
#include <crtdbg.h>
#include <objbase.h>
#include <wbemint.h> // For _IWmiObject
#include <sddl.h>

// This makes WMIAPI == dllexport stuff
#define ISP2PDLL

// Change this to use shared memory or named pipes.
#define NAMED_PIPES

// Because our template names get so long, we have to disable the 'debug name 
// truncated' warning.
#pragma warning ( disable : 4786)

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\reportevent.h ===
// ReportEvent.h
// This module contains helpers for the WMIReportEvent function.

#pragma once

#include "NCObjApi.h"
#include <wstlallc.h>
#include <map>

class CReportParams
{
public:
    CReportParams(LPCWSTR szName, LPCWSTR szFormat)
    {
        m_szName = szName;
        m_szFormat = szFormat;
    }

    bool operator < (const CReportParams& other) const
    { 
        return m_szName < other.m_szName && m_szFormat < other.m_szFormat;
    }

    bool operator == (const CReportParams& other) const
    {
        return m_szName == other.m_szName && m_szFormat == other.m_szFormat;
    }

    bool IsEquivalent(const CReportParams& other) const
    {
        // The format string is case-senstive due to printf format characters.
        return !_wcsicmp(m_szName, other.m_szName) && 
            !wcscmp(m_szFormat, other.m_szFormat);
    }

protected:
    LPCWSTR m_szName;
    LPCWSTR m_szFormat;
};

class CReportItem
{
public:
    CReportItem( )
        : m_szName( NULL ),
          m_szFormat( NULL ),
          m_hEvent( NULL )
    {
    }

    ~CReportItem()
    {
        if (m_szName)
            free(m_szName);

        if (m_szFormat)
            free(m_szFormat);

        if (m_hEvent)
            WmiDestroyObject(m_hEvent);            
    }

    BOOL Initialize( LPCWSTR szName, LPCWSTR szFormat, HANDLE hEvent )
    {
        if ( szName && szFormat && hEvent )
        {
            m_szName = _wcsdup(szName);
            if ( NULL == m_szName )
            {
                return FALSE;
            }
            
            m_szFormat = _wcsdup(szFormat);
            if ( NULL == m_szFormat )
            {
                return FALSE;
            }
            
            m_hEvent = hEvent;

            return TRUE;
        }

        return FALSE;
    }
    
    HANDLE GetEvent() { return m_hEvent; }
    
protected:
    LPWSTR m_szName;
    LPWSTR m_szFormat;
    HANDLE m_hEvent;
};

class CReportEventMap : protected std::map< CReportParams, 
                                            CReportItem*, 
                                            std::less< CReportParams >, 
                                            wbem_allocator< CReportItem* > >
{
public:
    ~CReportEventMap();

    HANDLE GetEvent(
        HANDLE hConnection, 
        LPCWSTR szName, 
        LPCWSTR szFormat);

    HANDLE CreateEvent(
        HANDLE hConnection, 
        LPCWSTR szName, 
        DWORD dwFlags,
        LPCWSTR szFormat);

protected:
    typedef CReportEventMap::iterator CReportEventMapIterator;
    static CIMTYPE PrintfTypeToCimType(LPCWSTR szType);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	P2Prov.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\dutils.h ===
// dutils.h

#pragma once

/*
extern "C" void MBTrace(LPCTSTR szFormat, ...);
extern "C" void FTrace(LPCTSTR szFormat, ...);
extern "C" void Trace(LPCTSTR szFormat, ...);

#ifdef USE_FTRACE
#define TRACE  FTrace
#else

#ifndef _DEBUG
#define TRACE  1 ? (void)0 : ::Trace
#else
#define TRACE  ::Trace
#endif
*/

#ifdef _ASSERT
#undef _ASSERT
#endif

#include <wbemutil.h>

//#endif // #ifdef USE_FTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\transport.h ===
// Transport.h
// This is the base class for event transport classes.

#pragma once

#include "buffer.h"
#include "NCDefs.h"

class CConnection;

class CTransport
{
public:
    CTransport() :
        m_iRef(1)
    {
        InitializeCriticalSection(&m_cs);
    }

    virtual ~CTransport()
    {
        DeleteCriticalSection(&m_cs);    
    }

    void SetConnection(CConnection *pConnection) 
    { 
        m_pConnection = pConnection; 
    }

    // Overrideables
    virtual IsReady()=0;
    virtual BOOL SendData(LPBYTE pBuffer, DWORD dwSize)=0;
    virtual void Deinit()=0;
    virtual BOOL InitCallback()=0;
    virtual BOOL Init(LPCWSTR szBasePipeName, LPCWSTR szBaseProviderName)=0;
    virtual BOOL SignalProviderDisabled()=0;
    virtual void SendMsgReply(NC_SRVMSG_REPLY *pReply)=0;

    // Critical section functions
    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

protected:
    LONG             m_iRef;
    CRITICAL_SECTION m_cs;
    CConnection      *m_pConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\eventinfo.cpp ===
// EventInfo.cpp

#include "precomp.h"
#include "ProvInfo.h"
#include "EventInfo.h"
#include "NCProv.h"
#include "NCProvider.h"
#include <comutl.h>


#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))
#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)


/////////////////////////////////////////////////////////////////////////////
// CEventInfo

CEventInfo::CEventInfo() :
    m_pPropFuncs(0)
{
}

CEventInfo::~CEventInfo()
{
}

BOOL GetClassQualifier(
    IWbemClassObject *pObj, 
    LPCWSTR szQualifier,
    VARIANT *pVal)
{
    IWbemQualifierSet *pSet = NULL;
    BOOL              bRet = FALSE;

    if (SUCCEEDED(pObj->GetQualifierSet(&pSet)))
    {
        if (SUCCEEDED(pSet->Get(szQualifier, 0, pVal, NULL)))
            bRet = TRUE;

        pSet->Release();
    }

    return bRet;
}

BOOL GetClassPropertyQualifier(
    IWbemClassObject *pObj, 
    LPCWSTR szProperty,
    LPCWSTR szQualifier,
    VARIANT *pVal)
{
    IWbemQualifierSet *pSet = NULL;
    BOOL              bRet = FALSE;

    if (SUCCEEDED(pObj->GetPropertyQualifierSet(szProperty, &pSet)))
    {
        if (SUCCEEDED(pSet->Get(szQualifier, 0, pVal, NULL)))
            bRet = TRUE;

        pSet->Release();
    }

    return bRet;
}

#define MAX_EVENT_PROPS 1024

BOOL CEventInfo::InitFromBuffer(CClientInfo *pInfo, CBuffer *pBuffer)
{
    WCHAR *pszEvent;
    DWORD nProps,
          dwStrSize;
    BOOL  bRet = FALSE;

    m_pInfo = pInfo;

    // Get the number of properties for this event layout.
    nProps = pBuffer->ReadDWORD();

    if ( nProps > MAX_EVENT_PROPS )
    	return FALSE;

    pszEvent = pBuffer->ReadAlignedLenString(&dwStrSize);

    if ( dwStrSize == 0 )
        return FALSE;

    // Prepare the array of property functions.
    m_pPropFuncs.Init(nProps);

    LPWSTR *pszProps = new LPWSTR[nProps];

    if (pszProps)
    {
        for (DWORD i = 0; i < nProps; i++)
        {
            DWORD     type = pBuffer->ReadDWORD();
            DWORD     dwSize;
            LPCWSTR   szProp = pBuffer->ReadAlignedLenString(&dwSize);
            PROP_FUNC pFunc = TypeToPropFunc(type);
            
            if ( pFunc == NULL || !m_pPropFuncs.AddVal(pFunc) )
            {
                delete [] pszProps;
                return FALSE;
            }

            pszProps[i] = (BSTR) szProp;
        }

        bRet = 
            Init(
                pInfo->m_pProvider->m_pProv->GetNamespace(),
                pszEvent,
                (LPCWSTR*) pszProps,
                nProps,
                FAILED_PROP_TRY_ARRAY);

        delete [] pszProps;
    }

    return bRet;
}

BOOL CEventInfo::SetPropsWithBuffer(CBuffer *pBuffer)
{
    if (!m_pObj)
        return FALSE;

    DWORD nProps = m_pPropFuncs.GetCount();
    BOOL  bRet = TRUE;
    DWORD *pNullTable = (DWORD*) pBuffer->m_pCurrent;

    if ( PBYTE(pNullTable + nProps/32) > 
         (pBuffer->m_pBuffer + pBuffer->m_dwSize) )
        return FALSE;

    // We need this as the offsets are relative from the beginning
    // of the object packet (including the 2 DWORDs of header stuff).

    m_pBitsBase = (LPBYTE) (pNullTable - 3);
    _ASSERT( m_pBitsBase < pBuffer->m_pBuffer + pBuffer->m_dwSize );
    m_cBitsBase = pBuffer->m_pBuffer + pBuffer->m_dwSize - m_pBitsBase;

    m_pdwPropTable = pNullTable + (nProps / 32 + ((nProps % 32) != 0));
    if ( PBYTE(m_pdwPropTable + nProps) > 
         (pBuffer->m_pBuffer + pBuffer->m_dwSize) )
   	return FALSE;

    //
    // here we should be safe to use the prop table now, but the
    // use of bits base is checked against buffer overflow on a case by 
    // case basis.
    //
    	 
    for (m_iCurrentVar = 0; 
        m_iCurrentVar < nProps && bRet; 
        m_iCurrentVar++)
    {
    	 
        if ((pNullTable[m_iCurrentVar / 32] & (1 << (m_iCurrentVar % 32))))
        {
            PROP_FUNC pFunc = m_pPropFuncs[m_iCurrentVar];

            _ASSERT(pFunc != NULL);

            bRet = (this->*pFunc)();

            _ASSERT(bRet);
        }
#ifdef NO_WINMGMT
        else
            WriteNULL(m_iCurrentVar);
#endif
    }

    return bRet;
}

PROP_FUNC CEventInfo::TypeToPropFunc(DWORD type)
{
    PROP_FUNC pRet;
    BOOL      bNonArray = (type & CIM_FLAG_ARRAY) == 0;

    switch(type & ~CIM_FLAG_ARRAY)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            pRet = bNonArray ? ProcessString : ProcessStringArray;
            break;

        case CIM_UINT32:
        case CIM_SINT32:
        case CIM_REAL32:
            pRet = bNonArray ? ProcessDWORD : ProcessArray4;
            break;

        case CIM_UINT16:
        case CIM_SINT16:
        case CIM_CHAR16:
        case CIM_BOOLEAN:
            pRet = bNonArray ? ProcessWORD : ProcessArray2;
            break;

        case CIM_SINT8:
        case CIM_UINT8:
            pRet = bNonArray ? ProcessBYTE : ProcessArray1;
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_REAL64:
            pRet = bNonArray ? ProcessDWORD64 : ProcessArray8;
            break;

        case CIM_OBJECT:
            pRet = bNonArray ? ProcessObject : NULL;
            break;

        // We'll use this for _IWmiObjects.
        case CIM_IUNKNOWN:
            pRet = bNonArray ? ProcessWmiObject : NULL;
            break;

        default:
            // Bad type!
            _ASSERT(FALSE);
            pRet = NULL;
    }

    return pRet;
}

BOOL CEventInfo::ProcessString()
{
    DWORD cData;
    LPBYTE pData = GetPropDataPointer(m_iCurrentVar, cData );

    if ( cData < sizeof(DWORD) )
         return FALSE;
    
    DWORD  dwSize = *(DWORD*) pData;
    BOOL   bRet;

    if ( dwSize > cData - sizeof(DWORD) )
        return FALSE;

#ifndef NO_WINMGMT
    bRet = WriteData( m_iCurrentVar, 
                      pData + sizeof(DWORD), 
                      dwSize );
#else
    bRet = TRUE;
#endif

    return bRet;
}

#define MAX_ARRAY_SIZE 4096 

BOOL CEventInfo::ProcessStringArray()
{
    DWORD          cData;
    LPBYTE         pData = GetPropDataPointer(m_iCurrentVar, cData);

    if ( cData < sizeof(DWORD) )
        return FALSE;

    DWORD          nStrings = *(DWORD*) pData;
    BOOL           bRet;
    VARIANT        vValue;
    SAFEARRAYBOUND sabound;

    if ( nStrings > MAX_ARRAY_SIZE )
        return FALSE;
    
    sabound.lLbound = 0;
    sabound.cElements = nStrings;

    pData += sizeof(DWORD);
    cData -= sizeof(DWORD);

    if ((V_ARRAY(&vValue) = SafeArrayCreate(VT_BSTR, 1, &sabound)) != NULL)
    {
        BSTR   *pStrings = (BSTR*) vValue.parray->pvData;

        vValue.vt = VT_BSTR | VT_ARRAY;

        for (DWORD i = 0; i < nStrings; i++)
        {
            if ( cData < sizeof(DWORD) )
                break;

            DWORD cLen = DWORD_ALIGNED(*(DWORD*)pData);

            pData += sizeof(DWORD);
            cData -= sizeof(DWORD);

            if ( cLen > cData )
                break;

            pStrings[i] = SysAllocString((BSTR)pData);

            if ( pStrings[i] == NULL )
                break;
 
            pData += cLen;
            cData -= cLen;
        }

        if ( i != nStrings )
        {
            SafeArrayDestroy(V_ARRAY(&vValue));
            return FALSE;
        }

#ifndef NO_WINMGMT
        HRESULT hr;

        hr =
            m_pObj->Put(
                m_pProps[m_iCurrentVar].m_strName,
                0,
                &vValue,
                0);

        bRet = SUCCEEDED(hr);
        
        if (!bRet)
            bRet = TRUE;
#else
        bRet = TRUE;
#endif

        SafeArrayDestroy(V_ARRAY(&vValue));
    }
    else
        bRet = FALSE;

    return bRet;
}

BOOL CEventInfo::ProcessDWORD()
{
#ifndef NO_WINMGMT
    return WriteDWORD(m_iCurrentVar, m_pdwPropTable[m_iCurrentVar]);
#else
    
    //m_pBuffer->ReadDWORD();

    return TRUE;
#endif
}

BOOL CEventInfo::ProcessBYTE()
{
    BYTE cData = m_pdwPropTable[m_iCurrentVar];

#ifndef NO_WINMGMT
    return WriteData(m_iCurrentVar, &cData, sizeof(cData));
#else
    return TRUE;
#endif
}

BOOL CEventInfo::ProcessDWORD64()
{
    DWORD cData;
    DWORD64 *pdwData = (DWORD64*) GetPropDataPointer(m_iCurrentVar,cData);
    if ( cData < sizeof(DWORD64) )
        return FALSE;

#ifndef NO_WINMGMT
    return WriteData(m_iCurrentVar, pdwData, sizeof(*pdwData));
#else
    return TRUE;
#endif
}

BOOL CEventInfo::ProcessWORD()
{
    WORD wData = m_pdwPropTable[m_iCurrentVar];

#ifndef NO_WINMGMT
    return WriteData(m_iCurrentVar, &wData, sizeof(wData));
#else
    return TRUE;
#endif
}

BOOL CEventInfo::ProcessScalarArray(DWORD dwItemSize)
{
    DWORD cBits;
    LPBYTE pBits = GetPropDataPointer(m_iCurrentVar,cBits);
    BOOL   bRet;

    if ( cBits < sizeof(DWORD) )
        return FALSE;

   cBits -= sizeof(DWORD);
   
    if ( cBits < (*(DWORD*)pBits) * dwItemSize )
        return FALSE;

#ifndef NO_WINMGMT
    bRet = WriteArrayData(m_iCurrentVar, pBits, dwItemSize);
#else
    bRet = TRUE;
#endif

    return bRet;
}

BOOL CEventInfo::ProcessArray1()
{
    return ProcessScalarArray(1);
}

BOOL CEventInfo::ProcessArray2()
{
    return ProcessScalarArray(2);
}

BOOL CEventInfo::ProcessArray4()
{
    return ProcessScalarArray(4);
}

BOOL CEventInfo::ProcessArray8()
{
    return ProcessScalarArray(8);
}

// Digs out an embedded object from the current buffer.
BOOL CEventInfo::GetEmbeddedObject(IUnknown **ppObj, LPBYTE pBits, DWORD cBits )
{
    *ppObj = NULL;
    CEventInfo* pEvent = new CEventInfo;
    if ( pEvent == NULL )
        return FALSE;

    BOOL       bRet = FALSE;

    if ( cBits > sizeof(DWORD) )
    {
        DWORD dwSize = *(DWORD*)pBits;
        cBits -= sizeof(DWORD);

        if ( dwSize <= cBits )
        {
            CBuffer bufferObj( pBits+sizeof(DWORD), 
                               dwSize, 
                               CBuffer::ALIGN_NONE );
        
            bRet =
                pEvent->InitFromBuffer(m_pInfo, &bufferObj) &&
                pEvent->SetPropsWithBuffer(&bufferObj);
        }
    }

   if (bRet)
   {
         bRet = 
                    SUCCEEDED(pEvent->m_pObj->QueryInterface(
                        IID_IUnknown, (LPVOID*) ppObj));
   }

   delete pEvent;

   return bRet;
}

BOOL CEventInfo::ProcessObject()
{
    _variant_t vObj;
    BOOL       bRet = FALSE;
    LPBYTE     pObjBegin = m_pBitsBase + m_pdwPropTable[m_iCurrentVar];
    DWORD      cObjBits = m_cBitsBase - m_pdwPropTable[m_iCurrentVar];
 
    if (GetEmbeddedObject(&vObj.punkVal, pObjBegin, cObjBits))
    {
        vObj.vt = VT_UNKNOWN;

        bRet =
            SUCCEEDED(m_pObj->Put(
                m_pProps[m_iCurrentVar].m_strName,
                0,
                &vObj,
                0));
    }
    
    return bRet;
}

// Digs out an embedded object from the current buffer.
BOOL CEventInfo::GetWmiObject(_IWmiObject **ppObj, LPBYTE pBits, DWORD cBits )
{
    if (m_pObjSpawner == NULL)
    {
        HRESULT hr;

        hr =
            m_pInfo->m_pProvider->m_pProv->GetNamespace()->GetObject(
                CWbemBSTR( L"__NAMESPACE" ),
                0,
                NULL,
                (IWbemClassObject**) (_IWmiObject**) &m_pObjSpawner,
                NULL);

        if (FAILED(hr))
            return FALSE;
    }

    BOOL        bRet = FALSE;
    _IWmiObject *pObjTemp = NULL;

    if (SUCCEEDED(m_pObjSpawner->SpawnInstance(0, (IWbemClassObject**) &pObjTemp)))
    {
        if ( cBits >= sizeof(DWORD ) )
        {
            DWORD  dwSize = *(DWORD*) pBits;
            cBits -= sizeof(DWORD);

            if ( dwSize <= cBits )
            {
                LPVOID pMem = CoTaskMemAlloc(dwSize);
                
                if (pMem)
                {
                    memcpy(pMem, pBits + sizeof(DWORD), dwSize);
                    if (SUCCEEDED(pObjTemp->SetObjectMemory(pMem, dwSize)))
                    {
                        *ppObj = pObjTemp;
                        
                        bRet = TRUE;
                    }
                }
            }
        }

         if ( !bRet )
    		pObjTemp->Release();
         
    }
    
    return bRet;
}

BOOL CEventInfo::ProcessWmiObject()
{
    BOOL        bRet;
    LPBYTE      pObjBegin = m_pBitsBase + m_pdwPropTable[m_iCurrentVar];
    DWORD       cObjBits = m_cBitsBase - m_pdwPropTable[m_iCurrentVar];
    _IWmiObject *pObj = NULL;

    if (GetWmiObject(&pObj, pObjBegin, cObjBits))
    {
        CProp   &prop = m_pProps[m_iCurrentVar];
        HRESULT hr;

        hr =
            m_pWmiObj->SetPropByHandle(
                prop.m_lHandle,
                0,
                sizeof(_IWmiObject*),
                &pObj);
            
        pObj->Release();

        bRet = SUCCEEDED(hr);
    }
    else
        bRet = FALSE;
    
    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// CEventInfoMap

CEventInfoMap::~CEventInfoMap()
{
    while (m_mapNormalEvents.size())
    {
        CNormalInfoMapIterator item = m_mapNormalEvents.begin();

        delete (*item).second;
        
        m_mapNormalEvents.erase(item);
    }
}

CEventInfo *CEventInfoMap::GetNormalEventInfo(DWORD dwIndex)
{
    CEventInfo             *pInfo;
    CNormalInfoMapIterator item = m_mapNormalEvents.find(dwIndex);

    if (item != m_mapNormalEvents.end())
        pInfo = (*item).second;
    else
        pInfo = NULL;

    return pInfo;
}

BOOL CEventInfoMap::AddNormalEventInfo(DWORD dwIndex, CEventInfo *pInfo)
{
    m_mapNormalEvents[dwIndex] = pInfo;

    return TRUE;
}

HRESULT CEventInfo::Indicate()
{
    HRESULT hr;
    hr = m_pSink->Indicate(1, &m_pObj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\eventinfo.h ===
// EventInfo.h

#pragma once

#include <map>
#include <wstlallc.h>
#include "array.h"
#include "ObjAccess.h"
#include "buffer.h"
#include "ProvInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CEventInfo

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(_IWmiObject, __uuidof(_IWmiObject));

class CEventInfo;
class CClientInfo;

typedef BOOL (CEventInfo::*PROP_FUNC)();
typedef CArray<PROP_FUNC> CPropFuncArray;

class CEventInfo : public CObjAccess
{
public:
    CEventInfo();
    ~CEventInfo();

    BOOL InitFromBuffer(CClientInfo *pInfo, CBuffer *pBuffer);
    BOOL SetPropsWithBuffer(CBuffer *pBuffer);
    HRESULT Indicate();
    void SetSink(IWbemEventSink *pSink) { m_pSink = pSink; }
        
    // These are used when we're decoding an object.
    LPBYTE         m_pBitsBase;
    DWORD          m_cBitsBase;
    DWORD          *m_pdwPropTable;

    int            m_iCurrentVar;
    CPropFuncArray m_pPropFuncs;  
    
    // We need this for embedded objects, so they can call InitFromBuffer.
    CClientInfo    *m_pInfo;
    
    // The sink to indicate to.  This keeps us from having to lookup the
    // restricted sink in a map each time an event is received.
    IWbemEventSink *m_pSink;
    
    // Used only for generic events.
    _variant_t     m_vParamValues;
    BSTR           *m_pValues;

    // Used to get a new _IWmiObject when processing an _IWmiObject property.
    _IWmiObjectPtr m_pObjSpawner;

    PROP_FUNC TypeToPropFunc(DWORD type);

    BOOL SetBlobPropsWithBuffer(CBuffer *pBuffer);

    LPBYTE GetPropDataPointer(DWORD dwIndex, DWORD& rcData )
    {
        LPBYTE pData = m_pBitsBase + m_pdwPropTable[dwIndex];
        rcData = m_cBitsBase - m_pdwPropTable[dwIndex];
        return pData;
    }

    // Prop type functions for non-generic events.
    BOOL ProcessString();
    BOOL ProcessBYTE();
    BOOL ProcessWORD();
    BOOL ProcessDWORD();
    BOOL ProcessDWORD64();
    BOOL ProcessObject();
    BOOL ProcessWmiObject();

    BOOL ProcessArray1();
    BOOL ProcessArray2();
    BOOL ProcessArray4();
    BOOL ProcessArray8();
    BOOL ProcessStringArray();

    // Helpers
    BOOL ProcessScalarArray(DWORD dwItemSize);

    // Digs out an embedded object from the buffer.
    BOOL GetEmbeddedObject(IUnknown **ppObj, LPBYTE pBits, DWORD cBits );
    BOOL GetWmiObject(_IWmiObject **ppObj, LPBYTE pBits, DWORD cBits );
};

/////////////////////////////////////////////////////////////////////////////
// CEventInfoMap

class CEventInfoMap
{
public:
    ~CEventInfoMap();

    CEventInfo *GetNormalEventInfo(DWORD dwIndex);
    BOOL AddNormalEventInfo(DWORD dwIndex, CEventInfo *pInfo);

protected:
    typedef std::map<DWORD, CEventInfo*, std::less<DWORD>, wbem_allocator<CEventInfo*> > CNormalInfoMap;
    typedef CNormalInfoMap::iterator CNormalInfoMapIterator;

    CNormalInfoMap m_mapNormalEvents;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\makefile.inc ===
$(O)\ncprov.mof $(O)\ncprov.mfl: ncprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\ncprovTmp.mof -MFL:$(O)\ncprovTmp.mfl ncprov.mof
    copy copyright.mof+$(O)\ncprovTmp.mof+$(O)\ncprovTmp.mfl $(O)\ncprov.mof
    copy copyright.mof+$(O)\ncprovTmp.mfl $(O)\ncprov.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\ncprovider.cpp ===
// NCProvider.cpp : Implementation of CNCProvider
#include "precomp.h"
#include "NCProv.h"
#include "NCProvider.h"
#include "NCDefs.h"
#include <list>
#include "Buffer.h"
#include "dutils.h"
#include "NCObjAPI.h"
#include <Winntsec.h>

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

/////////////////////////////////////////////////////////////////////////////
// CNCProvider

CNCProvider::CNCProvider() :
    m_heventDone(NULL),
    m_heventConnect(NULL),
    m_hPipe( NULL ),
    m_hthreadConnect(NULL),
    m_pProv(NULL)
{
    InitializeCriticalSection(&m_cs);
}

CNCProvider::~CNCProvider()
{
    DeleteCriticalSection(&m_cs);
}

void CNCProvider::FinalRelease()
{
    //
    // do potentially time consuming cleanup in this function rather than
    // DTOR.  Reason is that ATL decrements the module ref count before calling
    // the DTOR.  This means that a call to DllCanUnloadNow will return TRUE
    // while there is still a call executing in the module.  The race condition
    // is that the module could be unloaded while it is still being executed.
    // ATL will call FinalRelease() before decrementing the module refcount 
    // making this race condition much smaller. COM addresses this race 
    // condition by waiting for a bit to unload the module after returning 
    // TRUE.  This wait can be controlled by the delay unload param to 
    // CoFreeUnusedLibrariesEx().  This allows the call to the last Release()
    // of the COM object to finish, before being unloaded.  
    // 

    if ( m_hthreadConnect )
    {
        SetEvent(m_heventDone);
        WaitForSingleObject( m_hthreadConnect, INFINITE );
        CloseHandle(m_hthreadConnect);
    }

    if (m_heventDone)
        CloseHandle(m_heventDone);

    delete m_pProv;
}

HRESULT STDMETHODCALLTYPE CNCProvider::Initialize( 
    /* [in] */ LPWSTR pszUser,
    /* [in] */ LONG lFlags,
    /* [in] */ LPWSTR pszNamespace,
    /* [in] */ LPWSTR pszLocale,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    m_pProv = new CProvInfo;

    if ( m_pProv == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pProv->SetNamespace(pNamespace);

    m_heventDone = 
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);

    if ( m_heventDone == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    try 
    {
        m_strNamespace = pszNamespace;
    }
    catch( _com_error )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Tell Windows Management our initialization status.
    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
}

HRESULT STDMETHODCALLTYPE CNCProvider::SetRegistrationObject(
    LONG lFlags,
    IWbemClassObject __RPC_FAR *pProvReg)
{
    _variant_t vName;

    if (SUCCEEDED(pProvReg->Get(
        L"Name",
        0,
        &vName,
        NULL,
        NULL)) )
    {
    	if ( V_VT(&vName) != VT_BSTR )
            return WBEM_E_INVALID_OBJECT;
        m_strProvider = V_BSTR(&vName);
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNCProvider::AccessCheck( 
    /* [in] */ WBEM_CWSTR wszQueryLanguage,
    /* [in] */ WBEM_CWSTR wszQuery,
    /* [in] */ long lSidLength,
    /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid)
{
    HRESULT hr;

    try
    {
        hr = 
            m_pProv->AccessCheck(
                wszQueryLanguage, 
                wszQuery, 
                lSidLength, 
                (LPBYTE) pSid);
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CNCProvider::NewQuery( 
    /* [in] */ DWORD dwID,
    /* [in] */ WBEM_WSTR wszQueryLanguage,
    /* [in] */ WBEM_WSTR wszQuery)
{
    HRESULT hr;

    try
    {
        hr = m_pProv->NewQuery(dwID, wszQueryLanguage, wszQuery);
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}
        
HRESULT STDMETHODCALLTYPE CNCProvider::CancelQuery( 
    /* [in] */ DWORD dwID)
{
    try
    {
        // Get rid of the query item(s).
        m_pProv->CancelQuery(dwID);
    }
    catch(...)
    {
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CNCProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags)
{
    DWORD          dwID;
    IWbemEventSink *pEventSink = NULL;
    HRESULT        hr;

    if (SUCCEEDED(pSink->QueryInterface(
        IID_IWbemEventSink, (LPVOID*) &pEventSink)))
    {
        m_pProv->SetSink(pEventSink);
        pEventSink->Release();

        if (!m_hthreadConnect)
        {
            m_hthreadConnect =
                CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) ConnectThreadProc,
                    this,
                    0,
                    &dwID);
        }

        hr = S_OK;
    }
    else
        hr = WBEM_E_FAILED;

    return hr;
}

DWORD WINAPI CNCProvider::ConnectThreadProc(CNCProvider *pThis)
{
    DWORD dwRet = ERROR_SUCCESS;
    
    if (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        try
        {
            pThis->ConnectLoop();
        }
        catch( CX_MemoryException )
        {
            dwRet = ERROR_OUTOFMEMORY;
        }

        CoUninitialize();
    }

    return dwRet;
}

// ConnectToNewClient(HANDLE, LPOVERLAPPED) 
// This function is called to start an overlapped connect operation. 
// It returns TRUE if an operation is pending or FALSE if the 
// connection has been completed. 
 
BOOL CNCProvider::ConnectToNewClient(HANDLE hPipe, LPOVERLAPPED lpo) 
{ 
    BOOL bConnected, 
         bPendingIO = FALSE; 
 
    // Start an overlapped connection for this pipe instance. 
    bConnected = ConnectNamedPipe(hPipe, lpo); 
 
    // Overlapped ConnectNamedPipe should return zero. 
    if (bConnected) 
        return FALSE;
 
    switch (GetLastError()) 
    { 
        // The overlapped connection in progress. 
        case ERROR_IO_PENDING: 
            bPendingIO = TRUE; 
            break; 
 
        // Client is already connected, so signal an event. 
        case ERROR_PIPE_CONNECTED: 
            SetEvent(lpo->hEvent);
            break; 
 
        // If an error occurs during the connect operation... 
        default: 
            return FALSE;
   } 
 
   return bPendingIO; 
} 

#define PIPE_SIZE   64000

BOOL CNCProvider::CreateAndConnectInstance(LPOVERLAPPED lpoOverlap, BOOL bFirst)
{
    SECURITY_ATTRIBUTES sa;
    
    sa.nLength = sizeof( SECURITY_ATTRIBUTES );
    sa.bInheritHandle = FALSE;
    
    LPWSTR lpwszSD = L"D:"              // DACL
                     L"(A;;GA;;;SY)"    // Allow local system full control
                     L"(A;;GRGW;;;LS)"  // Allow local service Read/Write
                     L"(A;;GRGW;;;NS)"; // Allow network service Read/Write

    if ( ConvertStringSecurityDescriptorToSecurityDescriptor( 
            lpwszSD,
            SDDL_REVISION_1,
            &(sa.lpSecurityDescriptor),
            NULL ) )
    {
        long lFlags = PIPE_ACCESS_DUPLEX | // read/write access 
                    FILE_FLAG_OVERLAPPED;  // overlapped mode 
        if( bFirst )
        {
            lFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;
        }
        
        m_hPipe = CreateNamedPipe( 
            m_szNamedPipe,             // pipe name 
            lFlags,
            PIPE_TYPE_MESSAGE |        // message-type pipe 
               PIPE_READMODE_MESSAGE | // message read mode 
               PIPE_WAIT,              // blocking mode 
            PIPE_UNLIMITED_INSTANCES,  // unlimited instances 
            PIPE_SIZE,                 // output buffer size 
            PIPE_SIZE,                 // input buffer size 
            0,                         // client time-out 
            &sa );                     // security per above

            if ( INVALID_HANDLE_VALUE == m_hPipe )
            {
                return FALSE;
            }
    }
    else
    {
        return FALSE;
    }

    //
    // Make sure that the pipe is owned by us
    // Call a subroutine to connect to the new client.
    //
 
    return ConnectToNewClient(m_hPipe, lpoOverlap); 
/*
    HRESULT hr = WBEM_S_NO_ERROR;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;

    if (AllocateAndInitializeSid(&id, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0,0,0,0,0,0,&pSidSystem))
    {            
        // Create an everyone SID
        PSID pRawSid;
        SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;;

        if( FALSE == AllocateAndInitializeSid( &id2, 1,0,0,0,0,0,0,0,0, &pRawSid ) )
        {
            FreeSid ( pSidSystem );
            return FALSE;
        }
        
        // setup security descriptor with read/write for everyone & owned by local system
        // actual check for valid client is performed in CProvInfo::ClientAccessCheck        

        CNtSid sidWorld( pRawSid );
        FreeSid(pRawSid);
        CNtAce aceWorld(GENERIC_READ | GENERIC_WRITE, ACCESS_ALLOWED_ACE_TYPE, 0, sidWorld);

        CNtSid sidSystem(pSidSystem);
        FreeSid ( pSidSystem );
        pSidSystem = NULL;

        CNtAce aceSystem(FULL_CONTROL, ACCESS_ALLOWED_ACE_TYPE, 0, sidSystem);

        CNtAcl ackl;
        ackl.AddAce(&aceWorld);
        ackl.AddAce(&aceSystem);
        ackl.Resize(CNtAcl::MinimumSize);

        CNtSecurityDescriptor cSD;
        cSD.SetDacl(&ackl);

        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = true;
        sa.lpSecurityDescriptor = (void*)cSD.GetPtr(); 
  
        long lFlags = PIPE_ACCESS_DUPLEX |        // read/write access 
                    FILE_FLAG_OVERLAPPED;  // overlapped mode 
        if(bFirst)
            lFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;

        m_hPipe = 
            CreateNamedPipe( 
                m_szNamedPipe,              // pipe name 
                lFlags,
                PIPE_TYPE_MESSAGE |         // message-type pipe 
                    PIPE_READMODE_MESSAGE | // message read mode 
                    PIPE_WAIT,              // blocking mode 
                PIPE_UNLIMITED_INSTANCES,   // unlimited instances 
                PIPE_SIZE,                  // output buffer size 
                PIPE_SIZE,                  // input buffer size 
                0,                          // client time-out 
                &sa);                       // security per above

    }
    else // AllocateAndInitSid failed - outta here
        return FALSE;

    if (m_hPipe == INVALID_HANDLE_VALUE) 
        return FALSE;
 
    //
    // Make sure that the pipe is owned by us
    // Call a subroutine to connect to the new client. 
 
    return ConnectToNewClient(m_hPipe, lpoOverlap); 
*/
} 

void CNCProvider::ConnectLoop()
{
    // Init our provider info which will tell our comless providers that
    // we're ready.

    try
    {
        m_pProv->Init(m_strNamespace, m_strProvider);
    }
    catch( CX_MemoryException )
    {
        return;
    }

    m_heventConnect =
        CreateEvent( 
            NULL,    // no security attribute
            TRUE,    // manual reset event 
            TRUE,    // initial state = signaled 
            NULL);   // unnamed event object 

    //m_pServerPost = new CPostBuffer(this);

    // TODO: We need to indicate an error here.
    if (!m_heventConnect)
        return;

    StringCchPrintf(
        m_szNamedPipe,
        256,
        L"\\\\.\\pipe\\" OBJNAME_NAMED_PIPE L"%s%s", 
        (LPCWSTR) m_pProv->m_strBaseNamespace,
        (LPCWSTR) m_pProv->m_strBaseName);

    OVERLAPPED oConnect;
    BOOL       bSuccess,
               bPendingIO;
    HANDLE     hWait[2] = { m_heventDone, m_heventConnect };
    DWORD      dwRet;

    oConnect.hEvent = m_heventConnect;

    bPendingIO = CreateAndConnectInstance(&oConnect, TRUE); // first instance

    while ((dwRet = WaitForMultipleObjectsEx(2, hWait, FALSE, INFINITE, TRUE))
        != WAIT_OBJECT_0)
    {
        if ( dwRet == WAIT_FAILED )
        {
            break;
        }

        switch(dwRet)
        {
            case 1:
            {
                if (bPendingIO)
                {
                    DWORD dwBytes;

                    bSuccess =
                        GetOverlappedResult( 
                            m_hPipe,   // pipe handle 
                            &oConnect, // OVERLAPPED structure 
                            &dwBytes,  // bytes transferred 
                            FALSE);    // does not wait 
                    
                    // TODO: This is an error, but what to do?
                    if (!bSuccess) 
                       break;
                }

                CPipeClient *pInfo = new CPipeClient(this, m_hPipe);        

                if (pInfo)
                {
                    bSuccess = 
                        ReadFileEx( 
                            pInfo->m_hPipe, 
                            pInfo->m_bufferRecv.m_pBuffer, 
                            pInfo->m_bufferRecv.m_dwSize, 
                            &pInfo->m_info.overlap, 
                            (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 

                    if (!bSuccess)
                        DisconnectAndClose(pInfo);
                }
 
                bPendingIO = CreateAndConnectInstance(&oConnect, FALSE);
                break;
            }

            case WAIT_IO_COMPLETION:
                break;
        }
    }

    CloseHandle(m_hPipe);

    CloseHandle(m_heventConnect);
}

void CNCProvider::DisconnectAndClose(CClientInfo *pInfo) 
{ 
    m_pProv->RemoveClient(pInfo);
} 
 
void WINAPI CNCProvider::CompletedReadRoutine(
    DWORD dwErr, 
    DWORD nBytesRead, 
    LPOVERLAPPED pOverlap) 
{ 
    CPipeClient *pInfo = ((OLAP_AND_CLIENT*) pOverlap)->pInfo;
    CNCProvider *pThis = pInfo->m_pProvider;
 
#ifndef _DEBUG
    try
#endif
    {
#ifndef NO_DECODE
        if (nBytesRead)
        {
            pInfo->PostBuffer(pInfo->m_bufferRecv.m_pBuffer, nBytesRead);
        }
#endif
    }
#ifndef _DEBUG
    catch(...)
    {
    }
#endif

    try
    {
        // The read operation has finished, so write a response (if no 
        // error occurred). 
        if (dwErr == 0) 
        { 
            BOOL bSuccess;

            bSuccess = 
                ReadFileEx( 
                    pInfo->m_hPipe, 
                    pInfo->m_bufferRecv.m_pBuffer, 
                    pInfo->m_bufferRecv.m_dwSize, 
                    pOverlap, 
                    (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 

            if (!bSuccess)
                pThis->DisconnectAndClose(pInfo);
        }
        else
            pThis->DisconnectAndClose(pInfo);
    }   
    catch( CX_MemoryException )
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\ncprov.cpp ===
// NCSrv.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f NCSrvps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "NCProv.h"

#include "NCProv_i.c"
#include "NCProvider.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NCProvider, CNCProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_NCProvLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1AF40294_748A_4BA9_B2AB_52DFF1CF1D4F__INCLUDED_)
#define AFX_STDAFX_H__1AF40294_748A_4BA9_B2AB_52DFF1CF1D4F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define NAMED_PIPES

#include <comdef.h>

/*
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
*/


//
// Use of COREPROX_POLARITY should not be needed when ESSLIB 
// is no longer dependent on COREPROX.
//
// #define COREPROX_POLARITY __declspec( dllimport )

/*
#include "corepol.h"
#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <localloc.h>
*/

#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

//#ifdef _ASSERT
//#undef _ASSERT
//#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1AF40294_748A_4BA9_B2AB_52DFF1CF1D4F__INCLUDED)

#include <strsafe.h>
#include <sddl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\ncprovider.h ===
// NCProvider.h : Declaration of the CNCProvider

#ifndef __NCProvider_H_
#define __NCProvider_H_

#include "resource.h"       // main symbols
#include <map>
#include <list>
#include <wstlallc.h>
#include "NCDefs.h"
#include "buffer.h"
#include "QueryHelp.h" // For CBstrList
#include "ProvInfo.h"
#include "EventInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CNCProvider

class CNCProvider : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CNCProvider, &CLSID_NCProvider>,
    public IWbemProviderInit,
    public IWbemProviderIdentity,
    public IWbemEventProviderSecurity,
    public IWbemEventProviderQuerySink,
    public IWbemEventProvider
{
public:
	CNCProvider();
	~CNCProvider();
        void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_NCPROVIDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNCProvider)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemProviderIdentity)
	COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
	COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
END_COM_MAP()

    // Globals
    HANDLE           m_heventDone,
                     m_heventConnect,
                     m_hthreadConnect;
    _bstr_t          m_strNamespace,
                     m_strProvider;
    TCHAR            m_szNamedPipe[256];
    HANDLE           // Objects visible to P2 clients
                     m_hPipe;
    CProvInfo*       m_pProv;
    CRITICAL_SECTION m_cs;

    static DWORD WINAPI ConnectThreadProc(CNCProvider *pThis);
    void ConnectLoop();

    BOOL ConnectToNewClient(HANDLE hPipe, OVERLAPPED *pOverlap);
    BOOL CreateAndConnectInstance(OVERLAPPED *pOverlap, BOOL bFirst);
    void DisconnectAndClose(CClientInfo *pInfo);

    static void WINAPI CompletedReadRoutine(
        DWORD dwErr, 
        DWORD cbBytesRead, 
        LPOVERLAPPED lpOverLap);

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

// IWbemProviderInit
public:
    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);


// IWbemProviderIdentity
public:
    HRESULT STDMETHODCALLTYPE SetRegistrationObject(
            LONG lFlags,
            IWbemClassObject __RPC_FAR *pProvReg);


// IWbemEventProviderSecurity
public:
    HRESULT STDMETHODCALLTYPE AccessCheck( 
        /* [in] */ WBEM_CWSTR wszQueryLanguage,
        /* [in] */ WBEM_CWSTR wszQuery,
        /* [in] */ long lSidLength,
        /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid);


// IWbemEventProviderQuerySink
public:
    HRESULT STDMETHODCALLTYPE NewQuery( 
        /* [in] */ unsigned long dwId,
        /* [in] */ WBEM_WSTR wszQueryLanguage,
        /* [in] */ WBEM_WSTR wszQuery);
        
    HRESULT STDMETHODCALLTYPE CancelQuery( 
        /* [in] */ unsigned long dwId);

// IWbemEventProvider
public:
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags);
};

#endif //__NCProvider_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\provinfo.cpp ===
// ProvInfo.cpp

#include "precomp.h"
#include "ProvInfo.h"
#include "NCDefs.h"
#include "dutils.h"
#include "NCProv.h"
#include "NCProvider.h"
#include "QueryHelp.h" // For parsing stuff.
#include <comutl.h>

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

extern BOOL bIgnore;

CClientInfo::~CClientInfo()
{
}

CSinkInfo *CClientInfo::GetSinkInfo(DWORD dwID)
{
    if (dwID == 0)
        return m_pProvider->m_pProv;
    return NULL;
}

HRESULT CClientInfo::PostBuffer(LPBYTE pData, DWORD dwDataSize)
{
    CBuffer buffer(pData, dwDataSize);
        
    while (!buffer.IsEOF())
    {
        DWORD dwMsg = buffer.ReadDWORD();
        
        switch(dwMsg)
        {
            case NC_SRVMSG_CLIENT_INFO:
                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: Got NC_SRVMSG_CLIENT_INFO\n"));

                if (ProcessClientInfo(&buffer))
                    m_pProvider->m_pProv->AddClient(this);
                else
                    m_pProvider->DisconnectAndClose(this);

                // Ignore the rest of this client's messages since the client
                // info message can't be accompanied by any other messages.
                buffer.SetEOF();

                break;

            case NC_SRVMSG_EVENT_LAYOUT:
            {
                LPBYTE pTop = buffer.m_pCurrent - sizeof(DWORD);
                DWORD  dwSize = buffer.ReadDWORD(),
                       dwFuncIndex = buffer.ReadDWORD(),
                       dwSinkIndex = buffer.ReadDWORD();
                
                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: Got event layout: index = %d, sink = %d\n", 
                    dwFuncIndex, dwSinkIndex));

                CEventInfo *pEvent = new CEventInfo;

                if (pEvent)
                {
                    CSinkInfo *pSinkInfo = GetSinkInfo(dwSinkIndex);

                    if (pSinkInfo && pEvent->InitFromBuffer(this, &buffer))
                    {
                        pEvent->SetSink(pSinkInfo->GetSink());

                        m_mapEvents.AddNormalEventInfo(dwFuncIndex, pEvent);
                    }
                    else
                    {
                        delete pEvent;
                            
                        DEBUGTRACE(
                            (LOG_ESS, 
                            "NCProv: Failed to init event layout: index = %d, sink = %d\n",
                            dwFuncIndex, dwSinkIndex));
                    }
                }

                // Move past the current message.
                buffer.m_pCurrent = pTop + dwSize;

                //
                // validation of dwSize will be done on next iteration when 
                // retrieving dword.
                //
                    
                break;
            }

            case NC_SRVMSG_PREPPED_EVENT:
            {
                LPBYTE     pTop = buffer.m_pCurrent - sizeof(DWORD);
                DWORD      dwSize = buffer.ReadDWORD(),
                           dwEventIndex = buffer.ReadDWORD();
                CEventInfo *pEvent;
		  
                pEvent = m_mapEvents.GetNormalEventInfo(dwEventIndex);

                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: NCMSG_PREPPED_EVENT index %d\n", dwEventIndex));

                if (pEvent)
                {
                    if (pEvent->SetPropsWithBuffer(&buffer))
                    {
#ifndef NO_INDICATE
                        pEvent->Indicate();
#else
                        m_dwEvents++;                            
#endif
                    }
                    else
                        ERRORTRACE(
                            (LOG_ESS, 
                            "NCProv: SetPropsWithBuffer failed, index %d", 
                            dwEventIndex));
                }
                else
                    ERRORTRACE(
                        (LOG_ESS, 
                        "NCProv: Didn't find function info for index %d",
                        dwEventIndex));

                // Move past the current message.
                buffer.m_pCurrent = pTop + dwSize;

		  //
                // validation of dwSize will be done on next iteration when 
                // retrieving dword.
                //
                break;
            }

            case NC_SRVMSG_ACCESS_CHECK_REPLY:
            {
                try
                {
                    NC_SRVMSG_REPLY *pReply = (NC_SRVMSG_REPLY*) buffer.m_pBuffer;
                    CPipeClient     *pClient = (CPipeClient*) pReply->dwMsgCookie;

                    pClient->m_hrClientReply = pReply->hrRet;
                    SetEvent(pClient->m_heventMsgReceived);
                }
                catch(...)
                {
                }

                buffer.SetEOF();

                break;
            }

            default:
                // Unknown message!
                _ASSERT(FALSE, L"NCProv: Received unknown message");
                    
                // Ignore the rest of this message.
                buffer.SetEOF();
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPipeClient

CPipeClient::CPipeClient(CNCProvider *pProvider, HANDLE hPipe) :
    m_hPipe(hPipe),
#ifndef NO_DECODE
    m_bufferRecv(MAX_MSG_SIZE)
#else
    m_bufferRecv(500000) // We need to make this really big since we won't know
                         // how big to make it.
#endif
{
    m_pProvider = pProvider;
    memset(&m_info.overlap, 0, sizeof(m_info.overlap));
    m_info.pInfo = this;

    // We'll set this to indicate we've received a message from our client.
    m_heventMsgReceived = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CPipeClient::~CPipeClient()
{
    if (m_hPipe)
    {
        DisconnectNamedPipe(m_hPipe);
 
        // Close the handle to the pipe instance. 
        CloseHandle(m_hPipe); 
    }

    if (m_heventMsgReceived)
        CloseHandle(m_heventMsgReceived);
}

BOOL CPipeClient::ProcessClientInfo(CBuffer *pBuffer)
{
    DWORD dwBufferSize = pBuffer->ReadDWORD();
    //
    // ignore what the client says here. we've already determined our msg size.
    // 
    m_bufferRecv.Reset(MAX_MSG_SIZE);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CProvInfo

#ifdef _UNICODE
#define USTR_INSERT     _T("%s")
#else
#define USTR_INSERT     _T("%S")
#endif

CProvInfo::CProvInfo() : m_heventProviderReady(NULL), CSinkInfo(0)
{

}

void GetBaseName(LPCWSTR szName, LPWSTR szBase)
{
    // Normalize this by making sure it doesn't start with "\\.\"
    if (wcsstr(szName, L"\\\\.\\") == szName)
        StringCchCopyW( szBase, MAX_PATH*2, szName + 4);
    else
        StringCchCopyW( szBase, MAX_PATH*2, szName );

    _wcsupr(szBase);

    // Get rid of the '\' chars since we can't use it in OS object names.
    for (WCHAR *szCurrent = szBase; *szCurrent; szCurrent++)
    {
        if (*szCurrent == '\\')
            *szCurrent = '/';
    }
}

// SDDL string description:
// D:        Security Descriptor
// A:        Access allowed
// 0x1f0003: EVENT_ALL_ACCESS
// BA:       Built-in administrators
// 0x100000: SYNCHRONIZE
// WD:       Everyone
#define ESS_EVENT_SDDL L"D:(A;;0x1f0003;;;BA)(A;;0x100000;;;WD)"

BOOL CProvInfo::Init(LPCWSTR szNamespace, LPCWSTR szProvider)
{
    WCHAR szReadyEventName[MAX_PATH * 2],
          szBaseNamespace[MAX_PATH * 2] = L"",
          szBaseProvider[MAX_PATH * 2] = L"";
        
    if (!szNamespace || !szProvider)
        return FALSE;

    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CProvInfo::Init: %S, %S\n", szNamespace, szProvider));

    GetBaseName(szNamespace, szBaseNamespace);
    GetBaseName(szProvider, szBaseProvider);

    // Get the ready event.
    StringCchPrintfW(
        szReadyEventName, 
        MAX_PATH*2,
        OBJNAME_EVENT_READY L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    _wcsupr(szReadyEventName);

    // Save these for later.
    m_strName = szProvider;
    m_strBaseName = szBaseProvider;
    m_strBaseNamespace = szBaseNamespace;

    // Create the provider ready event.
    m_heventProviderReady =
        OpenEventW(
            EVENT_ALL_ACCESS,
            FALSE,
            szReadyEventName);

    if (!m_heventProviderReady)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwSize;

        if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
            ESS_EVENT_SDDL,  // security descriptor string
            SDDL_REVISION_1, // revision level
            &pSD,            // SD
            &dwSize) )
            return FALSE;

        SECURITY_ATTRIBUTES sa = { sizeof(sa), pSD, FALSE };

        m_heventProviderReady =
            CreateEventW(
                &sa,
                TRUE,
                FALSE,
                szReadyEventName);

        if (!m_heventProviderReady)
        {
            ERRORTRACE(
                (LOG_ESS, 
                "NCProv: Couldn't init provider event: err = %d", GetLastError()));
        }

        if (pSD)
            LocalFree((HLOCAL) pSD);
    }

    BOOL bRet;

    if (m_heventProviderReady)
    {
        SetEvent(m_heventProviderReady);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

CProvInfo::~CProvInfo()
{
    if (m_heventProviderReady)
    {
        DEBUGTRACE(
            (LOG_ESS, 
            "NCProv: In ~CProvInfo, resetting ready event.\n"));
        ResetEvent(m_heventProviderReady);
        CloseHandle(m_heventProviderReady);
        
        DWORD dwMsg = NC_CLIMSG_PROVIDER_UNLOADING;

        DEBUGTRACE(
            (LOG_ESS, 
            "NCProv: Sending the NC_CLIMSG_PROVIDER_UNLOADING message.\n"));

        // Tell our clients that we're going away.
        SendMessageToClients((LPBYTE) &dwMsg, sizeof(dwMsg), FALSE);
    }

    CClientInfoListIterator info;

    Lock();

    for ( info = m_listClients.begin( ); 
          info != m_listClients.end( );
          ++info )
    {
        (*info)->Release();
    }

    Unlock();
}

DWORD WINAPI TempThreadProc(IWbemEventSink *pSink)
{
    HRESULT hr;
    
    hr = CoInitializeEx( 0, COINIT_MULTITHREADED );

    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwRet = ERROR_SUCCESS;
    
    try
    {
        // Since we got a new client, we'll have to recheck our subscriptions
        pSink->SetStatus(
            WBEM_STATUS_REQUIREMENTS, 
            WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
            NULL, 
            NULL);
    }
    catch( CX_MemoryException )
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    
    pSink->Release();

    CoUninitialize();

    return dwRet;
}

// Functions called as clients connect/disconnect with pipe.
void CProvInfo::AddClient(CClientInfo *pInfo)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: In AddClient...\n"));

    Lock();

    m_listClients.push_back(pInfo);

    Unlock();

    DWORD dwID;

    IWbemEventSink *pSink = pInfo->m_pProvider->m_pProv->GetSink();

    // Will get released by TempThreadProc.
    pSink->AddRef();

    // We have to do this stuff off a thread, because AddClient is 
    // called from the completed read routine (which means the routine
    // isn't free to receive a response to a client AccessCheck query).
    CloseHandle(
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) TempThreadProc,
            pSink,
            0,
            &dwID));

}

void CProvInfo::RemoveClient(CClientInfo *pInfo)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: Client removed...\n"));

    CClientInfoListIterator info;

    Lock();

    for (info = m_listClients.begin(); 
        info != m_listClients.end();
        info++)
    {
        if (*info == pInfo)
        {
            m_listClients.erase(info);

            //delete pInfo;
            pInfo->Release();

            break;
        }
    }

    Unlock();
}

BOOL CSinkInfo::BuildClassDescendentList(
    LPCWSTR szClass, 
    CBstrList &listClasses)
{
    if ( szClass == NULL )
        return FALSE;

    IEnumWbemClassObject *pClassEnum = NULL;

    // Add the class name itself to the list.
    listClasses.push_front(szClass);

    if (SUCCEEDED(m_pNamespace->CreateClassEnum(
        (const BSTR) szClass,
        WBEM_FLAG_DEEP,
        NULL,
        &pClassEnum)))
    {
        IWbemClassObject *pClass = NULL;
        DWORD            nCount;

        while(SUCCEEDED(pClassEnum->Next(
            WBEM_INFINITE,
            1,
            &pClass,
            &nCount)) && nCount == 1)
        {
            _variant_t vClass;

            if (SUCCEEDED(pClass->Get(
                L"__CLASS",
                0,
                &vClass,
                NULL,
                NULL) && vClass.vt == VT_BSTR))
            {
                // Upper it to simplify our comparisons later.
                _wcsupr(V_BSTR(&vClass));

                listClasses.push_back(V_BSTR(&vClass));
            }

            pClass->Release();
        }

        pClassEnum->Release();
    }

    return TRUE;
}

HRESULT CProvInfo::SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply)
{
    HRESULT hr = S_OK;

    Lock();

    for (CClientInfoListIterator client = m_listClients.begin();
        client != m_listClients.end(); client++)
    {
        hr = (*client)->SendClientMessage(pData, dwSize, bGetReply);

        if (bGetReply && FAILED(hr))
            break;
    }

    Unlock();

    return hr;
}

// Functions called as CNCProvider:: functions are called by WMI.
HRESULT STDMETHODCALLTYPE CSinkInfo::NewQuery(
    DWORD dwID, 
    WBEM_WSTR szLang, 
    WBEM_WSTR szQuery)
{
    CQueryParser parser;
    HRESULT      hr;
    _bstr_t      strClass;

    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CSinkInfo::NewQuery: %d, %S, %S\n", dwID, szLang, szQuery));

    if (SUCCEEDED(hr = parser.Init(szQuery)) &&
        SUCCEEDED(hr = parser.GetClassName(strClass)))
    {
        CBstrList listClasses;

        // Make sure this is upper cased (optimizes compares).  
        _wcsupr(strClass);

        BuildClassDescendentList(strClass, listClasses);

        Lock();

        BOOL bAlreadyInMap = m_mapQueries.find(dwID) != m_mapQueries.end();

        // Keep this in our map.
        if (!bAlreadyInMap)
        {
            m_mapQueries[dwID] = listClasses;

            //pList->assign(listClasses.begin(), listClasses.end());
        }

        Unlock();

        if (GetClientCount() != 0)
        {
            char buff[256];
            CBuffer buffer( buff, 256, CBuffer::ALIGN_DWORD_PTR);

				// Header stuff
            buffer.Write((DWORD) NC_CLIMSG_NEW_QUERY_REQ);
            buffer.Write(m_dwID); // Write the sink ID.
            buffer.Write((DWORD_PTR) 0); // No cookie needed.
        
				// New Query data
            buffer.Write(dwID);
            buffer.WriteAlignedLenString(szLang);
            buffer.WriteAlignedLenString(szQuery);
                                
            buffer.Write( (DWORD)listClasses.size() );
				// Write the newly activated classes.
            for (CBstrListIterator i = listClasses.begin();
                 i != listClasses.end();
                 i++)
            {
                if (!bAlreadyInMap)
                    AddClassRef(*i);

                buffer.WriteAlignedLenString((LPCWSTR) *i);
            }
        
            DWORD dwSize = buffer.GetUsedSize();

            SendMessageToClients(buffer.m_pBuffer, dwSize, FALSE);
        }
        else
        {
            // Add a ref to each class if the query wasn't already in our map.
            if (!bAlreadyInMap)
            {
                for (CBstrListIterator i = listClasses.begin();
                    i != listClasses.end();
                    i++)
                {
                    AddClassRef(*i);
                }
            }
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CSinkInfo::CancelQuery(DWORD dwID)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CSinkInfo::CancelQuery: %d\n", dwID));

    Lock();

    //BOOL      bProvGoingAway;
    CQueryToClassMapIterator query = m_mapQueries.find(dwID);

    // If this isn't in our map, winmgmt is doing something strange.
    if (query == m_mapQueries.end())
    {
        Unlock();
        return S_OK;
    }

    CBstrList &listClasses = (*query).second;

    // Remove this query's ref on its classes, and remove the classes from the 
    // list that still have a positive ref.  The classes left in the list are 
    // the ones that we need to tell our clients to deactivate.
    for (CBstrListIterator i = listClasses.begin();
        i != listClasses.end();
        )
    {
        if (RemoveClassRef(*i) > 0)
        {
            i = listClasses.erase(i);

            if (i == listClasses.end())
                break;
        }
        else
            // We can't have this in the for loop because listClasses.erase 
            // already moves us ahead.
            i++;
    }

    if (GetClientCount() != 0)
    {
        char buff[256];
        CBuffer buffer( buff, 256, CBuffer::ALIGN_DWORD_PTR);

        // Header stuff
        buffer.Write((DWORD) NC_CLIMSG_CANCEL_QUERY_REQ);
        buffer.Write(m_dwID); // Write the sink ID.
        buffer.Write((DWORD_PTR) 0); // No cookie needed.
        
        // Cancel Query data
        buffer.Write(dwID);
        buffer.Write( (DWORD)listClasses.size() );

        // Write the newly deactivated classes.
        for (CBstrListIterator i = listClasses.begin();
            i != listClasses.end();
            i++)
        {
            buffer.WriteAlignedLenString((LPCWSTR) *i);
        }

        DWORD dwSize = buffer.GetUsedSize();

        SendMessageToClients(buffer.m_pBuffer, dwSize, FALSE);
    }

    // Erase this query ID from our map.
    m_mapQueries.erase(query);

    Unlock();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CProvInfo::AccessCheck(
    LPCWSTR szLang, 
    LPCWSTR szQuery, 
    DWORD dwSidLen, 
    LPBYTE pSid)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CProvInfo::AccessCheck: %S, %S\n", szLang, szQuery));

    HRESULT hr;
    char    szBuffer[256];
    CBuffer buffer(szBuffer, sizeof(szBuffer), CBuffer::ALIGN_DWORD_PTR);

    // Header stuff
    buffer.Write((DWORD) NC_CLIMSG_ACCESS_CHECK_REQ);
    buffer.Write((DWORD) 0); // We only send this to the main sink (for now).
    buffer.Write((DWORD_PTR) 0); // We'll fill this in later with the real cookie.
        
    // Access Check data
    buffer.WriteAlignedLenString(szLang);
    buffer.WriteAlignedLenString(szQuery);
    buffer.Write(dwSidLen);
    buffer.Write(pSid, dwSidLen);

    DWORD dwSize = buffer.GetUsedSize();

    hr = SendMessageToClients(buffer.m_pBuffer, dwSize, TRUE);

    return hr;
}

int CSinkInfo::AddClassRef(LPCWSTR szClass)
{
    CBstrToIntIterator i = m_mapEnabledClasses.find(szClass);
    int                iRet = 1;

    if (i == m_mapEnabledClasses.end())
    {
        iRet = 1;
        m_mapEnabledClasses[szClass] = 1;
    }
    else
        iRet = ++(*i).second;

    return iRet;
}

int CSinkInfo::RemoveClassRef(LPCWSTR szClass)
{
    CBstrToIntIterator i = m_mapEnabledClasses.find(szClass);
    int                iRet = 0;

    if (i != m_mapEnabledClasses.end())
    {
        iRet = --(*i).second;

        if (iRet <= 0)
            m_mapEnabledClasses.erase(i);
    }

    return iRet;
}

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

// retrieve the acl from the provider registration
// upon success, *pDacl points to a byte array containing the dacl
// will be NULL if dacl is NULL
// caller's responsibility to delete memory
HRESULT CProvInfo::GetProviderDacl(IWbemServices *pNamespace, BYTE** pDacl)
{
    HRESULT hr = WBEM_E_INVALID_PROVIDER_REGISTRATION;
    DEBUGTRACE((LOG_ESS, "NCProv: GetProviderDacl\n"));
    WCHAR szObjPath[MAX_PATH * 2];

    StringCchPrintfW(
        szObjPath,
        MAX_PATH*2,
        L"__Win32Provider.Name=\"%s\"", 
        (LPCWSTR) m_strName);

    IWbemClassObjectPtr pRegistration;
    
    if (SUCCEEDED(hr = 
        pNamespace->GetObject(CWbemBSTR( szObjPath ), 0, NULL, &pRegistration, NULL)))
    {
        _variant_t vSD;

        if (SUCCEEDED(hr = pRegistration->Get(L"SecurityDescriptor", 0, &vSD, NULL, NULL)))
        {
            if (vSD.vt == VT_NULL)
            {
                hr = WBEM_S_NO_ERROR;
                *pDacl = NULL;
                DEBUGTRACE((LOG_ESS, "NCProv: GetProviderDacl - NULL SD\n"));
            }
            else
            {
                _ASSERT(vSD.vt == VT_BSTR, L"");
				
                PSECURITY_DESCRIPTOR pSD;
				
                if (ConvertStringSecurityDescriptorToSecurityDescriptorW(
                    vSD.bstrVal, SDDL_REVISION_1, &pSD,	NULL))
                {
                    PACL pAcl;
                    BOOL bDaclPresent, bDaclDefaulted;
                    
                    if (GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pAcl, &bDaclDefaulted))
                    {
                        if (bDaclPresent)
                        {
                            ACL_SIZE_INFORMATION sizeInfo;

                            if ( GetAclInformation(pAcl, &sizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation) )
                            {
                                if (*pDacl = new BYTE[sizeInfo.AclBytesInUse + sizeInfo.AclBytesFree])
                                    memcpy(*pDacl, pAcl, sizeInfo.AclBytesInUse);
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;
                            }
                            else
                            {
                                ERRORTRACE((LOG_ESS, "NCProv: Failed to retrieve ACL Information\n"));
                                hr = WBEM_E_FAILED;
                            }
                        }
                        else
                        {
                            pDacl = NULL;
                            hr = WBEM_S_NO_ERROR;
                        }
                    }
                    else
                    {
                        ERRORTRACE((LOG_ESS, "NCProv: Failed to retrieve DACL\n"));
                        hr = WBEM_E_FAILED;
                    }

                    LocalFree(pSD);
                }
                else
                {
                    ERRORTRACE((LOG_ESS, "NCProv: Failed to convert SecurityDescriptor property\n"));
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            }
        }
        else
            ERRORTRACE((LOG_ESS, "NCProv: Failed to retrieve SecurityDescriptor property, 0x%08X\n", hr));
    }

    DEBUGTRACE((LOG_ESS, "NCProv: GetProviderDacl returning 0x%08X\n", hr));

    return hr;
}

#define REPLY_WAIT_TIMEOUT 5000

HRESULT CPipeClient::SendClientMessage(LPVOID pData, DWORD dwSize, BOOL bGetReply)
{
    CPipeClient **pCookie = (CPipeClient**) ((LPBYTE) pData + sizeof(DWORD) * 2);
    DWORD       dwWritten;

    if (bGetReply)
        *pCookie = this;

    //
    // Allocate a bigger buffer to put the length in
    //

    BYTE* pBuffer = new BYTE[dwSize + sizeof(DWORD)];
    if(pBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    *(DWORD*)pBuffer = dwSize + sizeof(DWORD);
    memcpy(pBuffer + sizeof(DWORD), pData, dwSize);

    BOOL bRes = WriteFile(m_hPipe, pBuffer, dwSize + sizeof(DWORD),
                            &dwWritten, NULL);
    delete [] pBuffer;

    if(!bRes)
        return WBEM_E_FAILED;

    if(dwWritten != dwSize + sizeof(DWORD))
        return WBEM_E_FAILED;

    if (bGetReply)
    {
        HRESULT hr;

        if (WaitForSingleObject(m_heventMsgReceived, REPLY_WAIT_TIMEOUT) == 0)
            hr = m_hrClientReply;
        else
            hr = WBEM_E_FAILED;

        return hr;
    }
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\queryhelp.h ===
// QueryHelp.h

#pragma once

class CTextLexSource;
class QL1_Parser;
struct QL_LEVEL_1_RPN_EXPRESSION;

#include <list>
#include <wstlallc.h>

typedef std::list<_bstr_t, wbem_allocator<_bstr_t> > CBstrList;
typedef CBstrList::iterator CBstrListIterator;

class CQueryParser
{
public:
    CQueryParser();
    ~CQueryParser();

    HRESULT Init(LPCWSTR szQuery);
    HRESULT GetValuesForProp(LPCWSTR szProperty, CBstrList &listValues);
    HRESULT GetClassName(_bstr_t &strClass);

protected:
    CTextLexSource *m_pLexSource;
    QL1_Parser     *m_pParser;
    QL_LEVEL_1_RPN_EXPRESSION         
                   *m_pExpr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\provinfo.h ===
// ProvInfo.h

#pragma once

#include <list>
#include <map>
#include <wstlallc.h>
#include "NCDefs.h" // For IPostBuffer
#include "buffer.h"
#include "EventInfo.h"
#include "QueryHelp.h" // For CBstrList

/////////////////////////////////////////////////////////////////////////////
// CClientInfo

class CNCProvider;
class CProvInfo;
class CEventInfoMap;

_COM_SMARTPTR_TYPEDEF(IWbemEventSink, __uuidof(IWbemEventSink));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

class CSinkInfo;

class CClientInfo : public IPostBuffer
{ 
public:
    CEventInfoMap m_mapEvents;
    CNCProvider   *m_pProvider;

    CClientInfo() :
        m_iRef(1)
    {
    }

    ULONG AddRef()
    {
        return InterlockedIncrement(&m_iRef);
    }

    ULONG Release()
    {
        LONG lRet = InterlockedDecrement(&m_iRef);

        if (!lRet)
            delete this;

        return lRet;
    }
    
    virtual HRESULT SendClientMessage(LPVOID pData, DWORD dwSize, 
        BOOL bGetReply = FALSE) = 0;

    virtual ~CClientInfo();

    virtual BOOL ProcessClientInfo(CBuffer *pBuffer) = 0;

    virtual HRESULT PostBuffer(LPBYTE pData, DWORD dwSize);

protected:
    LONG m_iRef;

    CSinkInfo *GetSinkInfo(DWORD dwID);
};

class CPipeClient;

struct OLAP_AND_CLIENT
{
    OVERLAPPED  overlap;
    CPipeClient *pInfo;
};

class CPipeClient : public CClientInfo
{
public:
    // We have to do this because the completion routine won't let us pass
    // custom data along with the OVERLAPPED struct.  We can't pass 'this'
    // because this first points to the junk found in CClientInfo.  So, we
    // have to pass m_info, which is OVERLAPPED + this.
    OLAP_AND_CLIENT 
               m_info;
    CBuffer    m_bufferRecv;
    HANDLE     m_hPipe,
               m_heventMsgReceived;
    HRESULT    m_hrClientReply;

    CPipeClient(CNCProvider *pProvider, HANDLE hPipe);
    ~CPipeClient();

    HRESULT SendClientMessage(LPVOID pData, DWORD dwSize, 
        BOOL bGetReply = FALSE);

    BOOL ProcessClientInfo(CBuffer *pBuffer);
};

/////////////////////////////////////////////////////////////////////////////
// CProvInfo

typedef std::list<CClientInfo*, wbem_allocator<CClientInfo*> > CClientInfoList;
typedef CClientInfoList::iterator CClientInfoListIterator;

typedef std::map<_bstr_t, int, std::less<_bstr_t>, wbem_allocator<int> > CBstrToInt;
typedef CBstrToInt::iterator CBstrToIntIterator;

typedef std::map<int, int, std::less<int>, wbem_allocator<int> > CIntToIntMap;
typedef CIntToIntMap::iterator CIntToIntMapIterator;

class CSinkInfo : 
    public IWbemEventProviderQuerySink
{
public:
    CSinkInfo(DWORD dwSinkID) :
        m_dwID(dwSinkID),
        m_lRef(1)
    {
        InitializeCriticalSection(&m_cs);
    }

    virtual ~CSinkInfo()
    {
        DeleteCriticalSection(&m_cs);
    }

    void SetNamespace(IWbemServices *pNamespace)
    {
        m_pNamespace = pNamespace;
    }

    IWbemServices *GetNamespace() { return m_pNamespace; }

    void SetSink(IWbemEventSink *pSink)
    {
        m_pSink = pSink;
    }

    IWbemEventSink *GetSink() { return m_pSink; }

// IUnknown
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID refid, PVOID *ppThis)
    {
        if (refid == IID_IUnknown || refid == IID_IWbemEventProviderQuerySink)
        {
            *ppThis = this;
            AddRef();
            
            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        LONG lRet = InterlockedDecrement(&m_lRef);

        if (!lRet)
            delete this;

        return lRet;
    }

// IWbemEventProviderQuerySink
public:
    HRESULT STDMETHODCALLTYPE NewQuery( 
        /* [in] */ DWORD dwId,
        /* [in] */ WBEM_WSTR wszQueryLanguage,
        /* [in] */ WBEM_WSTR wszQuery);
        
    HRESULT STDMETHODCALLTYPE CancelQuery( 
        /* [in] */ unsigned long dwId);

// Implementation
protected:
    typedef std::map<DWORD, CBstrList, std::less<DWORD>, wbem_allocator<CBstrList> > CQueryToClassMap;
    typedef CQueryToClassMap::iterator CQueryToClassMapIterator;

    IWbemServicesPtr  m_pNamespace;
    IWbemEventSinkPtr m_pSink;
    CBstrToInt        m_mapEnabledClasses;
    CQueryToClassMap  m_mapQueries;
    DWORD             m_dwID;
    LONG              m_lRef;
    CRITICAL_SECTION  m_cs;

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

    int AddClassRef(LPCWSTR szClass);
    int RemoveClassRef(LPCWSTR szClass);

    BOOL BuildClassDescendentList(
        LPCWSTR szClass, 
        CBstrList &listClasses);

    virtual DWORD GetClientCount() = 0;
    virtual HRESULT SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply) = 0;
};

class CRestrictedSink : public CSinkInfo
{
public:
    CRestrictedSink(DWORD dwID, CClientInfo *pInfo);

protected:
    CClientInfo *m_pInfo;

    virtual DWORD GetClientCount() { return 1; }
    virtual HRESULT SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply)
    {
        return m_pInfo->SendClientMessage(pData, dwSize, bGetReply);
    }
};

class CProvInfo : public CSinkInfo
{ 
public:
    _bstr_t m_strName,
            m_strBaseName,
            m_strBaseNamespace;
    HRESULT m_hrClientMsgResult;

    CProvInfo();
    ~CProvInfo();

    // Called when the provider finds out its name.
    BOOL Init(LPCWSTR szNamespace, LPCWSTR szProvider);

    // Functions called as clients connect/disconnect with pipe.
    void AddClient(CClientInfo *pInfo);
    void RemoveClient(CClientInfo *pInfo);

    HRESULT STDMETHODCALLTYPE AccessCheck(
        LPCWSTR szLang, 
        LPCWSTR szQuery, 
        DWORD dwSidLen, 
        LPBYTE pSid);

protected:
    CClientInfoList m_listClients;
    HANDLE          m_heventProviderReady;

    HRESULT GetProviderDacl(IWbemServices *pNamespace, BYTE** pDacl);

    virtual DWORD GetClientCount()
    {
        return m_listClients.size();
    }

    virtual HRESULT SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\queryhelp.cpp ===
// QueryHelp.cpp
#include "precomp.h"

// Becase someone is using _ASSERT in WMI!

#ifdef _ASSERT
#undef _ASSERT
#endif

//#include <analyser.h>

#include <ql.h>
#include "QueryHelp.h"

CQueryParser::CQueryParser() :
    m_pLexSource(NULL),
    m_pParser(NULL),
    m_pExpr(NULL)   
{
}

CQueryParser::~CQueryParser()
{
    if (m_pLexSource)
        delete m_pLexSource;

    if (m_pParser)
        delete m_pParser;

    if (m_pExpr)
        delete m_pExpr;
}

HRESULT CQueryParser::Init(LPCWSTR szQuery)
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    m_pLexSource = new CTextLexSource(szQuery);

    if (m_pLexSource)
    {
        m_pParser = new QL1_Parser(m_pLexSource);
    
        if (m_pParser)
        {
            if (m_pParser->Parse(&m_pExpr) == 0)
                hr = S_OK;
            else
                hr = WBEM_E_INVALID_QUERY;
        }
    }

    return hr;
}

HRESULT CQueryParser::GetClassName(_bstr_t &strClass)
{
    HRESULT hr;

    if (m_pExpr)
    {
        strClass = m_pExpr->bsClassName;
        hr = S_OK;
    }
    else
        hr = WBEM_E_FAILED;
    
    return hr;
}

/*
HRESULT CQueryParser::GetValuesForProp(LPCWSTR szProperty, CBstrList &listValues)
{
    CPropertyName prop;
    
    prop.AddElement(szProperty);

    // Get the necessary query
    QL_LEVEL_1_RPN_EXPRESSION *pPropExpr;
    HRESULT hres = 
                CQueryAnalyser::GetNecessaryQueryForProperty(
                    m_pExpr, 
                    prop, 
                    pPropExpr);
    
    if (FAILED(hres))
        return hres;

    // See if there are any tokens
    if (pPropExpr->nNumTokens > 0)
    {
        // Combine them all
        for (int i = 0; i < pPropExpr->nNumTokens && SUCCEEDED(hres); i++)
        {
            QL_LEVEL_1_TOKEN &token = pPropExpr->pArrayOfTokens[i];
        
            if (token.nTokenType == QL1_NOT)
                hres = WBEMESS_E_REGISTRATION_TOO_BROAD;
            else if (token.nTokenType == QL1_AND || token.nTokenType == QL1_OR)
            {
                // We treat them all as ORs
                // ========================
            }
            else    
            {
                // This is a token
                if (token.nOperator != QL1_OPERATOR_EQUALS)
                    hres = WBEMESS_E_REGISTRATION_TOO_BROAD;
                else if (V_VT(&token.vConstValue) != VT_BSTR)
                    hres = WBEM_E_INVALID_QUERY;
                else
                {
                    // This token is a string equality.
                    listValues.push_back(V_BSTR(&token.vConstValue));
                }
            }
        }
    }
    else
        hres = WBEMESS_E_REGISTRATION_TOO_BROAD;

    delete pPropExpr;

    return hres;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NCProv.rc
//
#define IDS_PROJNAME                    100
#define IDR_NCPROVIDER                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\array.h ===
// array.h

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CArray template

#define DEF_SIZE    10
#define DEF_GROW_BY 10

template<class TYPE, class REF = TYPE> class CArray
{
public:
    CArray(int iSize = DEF_SIZE, int iGrowBy = DEF_GROW_BY) :
        m_nSize(0),
        m_nCount(0),
        m_nGrowBy(iGrowBy),
        m_pVals(NULL)
    {
        if (m_nGrowBy <= 0)
            m_nGrowBy = DEF_GROW_BY;

        if (iSize)
            Init(iSize);
    }

    CArray(const CArray& other)
    {
        *this = other;
    }

    const CArray& operator= (const CArray<TYPE, REF>& other)
    {
        Init(other.m_nCount);
        m_nCount = other.m_nCount;
        
        for (int i = 0; i < m_nCount; i++)
            m_pVals[i] = other.m_pVals[i];

        return *this;
    }

    ~CArray()
    {
        if (m_pVals)
            delete [] m_pVals;
    }

    BOOL AddVal(REF val)
    {
        if (m_nCount >= m_nSize)
        {
            TYPE *pTemp = new TYPE[m_nSize + m_nGrowBy];

            if (!pTemp)
                return FALSE;

            m_nSize += m_nGrowBy;

            for (int i = 0; i < m_nCount; i++)
                pTemp[i] = m_pVals[i];

            delete [] m_pVals;

            m_pVals = pTemp;
        }
        
        m_pVals[m_nCount++] = val;

        return TRUE;
    }

    BOOL Init(int iSize)
    {
        //if (iSize < DEF_SIZE)
        //    iSize = DEF_SIZE;

        if (iSize != m_nSize)
        {
            if (m_pVals)
                delete [] m_pVals;

            m_pVals = new TYPE[iSize];
        }

        m_nSize = iSize;
        m_nCount = 0;
        
        return m_pVals != NULL;
    }

    TYPE operator[] (int iIndex) const
    {
        return m_pVals[iIndex];
    }

    TYPE& operator[] (int iIndex)
    {
        return m_pVals[iIndex];
    }

    int GetCount() { return m_nCount; }
    void SetCount(int iCount)
    {
        //_ASSERT(iCount < m_nSize);

        m_nCount = iCount;
    }

    int GetSize() { return m_nSize; }
    void SetGrowBy(int iVal) { m_nGrowBy = iVal; }
    TYPE *GetData() { return m_pVals; }

protected:
    TYPE *m_pVals;
    int  m_nCount,
         m_nSize,
         m_nGrowBy;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\precomp.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
#define AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <windows.h>
#include <comdef.h>
#include <crtdbg.h>
#include <strsafe.h>

// This makes WMIAPI == dllexport stuff
#define ISP2PDLL

// Change this to use shared memory or named pipes.
#define NAMED_PIPES


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\buffer.h ===
#ifndef _BUFFER_H
#define _BUFFER_H

class CBuffer
{
public:
    LPBYTE    m_pBuffer,
        m_pCurrent;
    DWORD_PTR m_dwSize;

    enum ALIGN_TYPE
    {
        ALIGN_NONE,
        ALIGN_DWORD,
        ALIGN_QWORD,
        ALIGN_DWORD_PTR
    };

    CBuffer(LPCVOID pBuffer, DWORD_PTR dwSize, ALIGN_TYPE type = ALIGN_NONE);
    CBuffer(DWORD_PTR dwSize = 0);
    CBuffer(const CBuffer &other);
    virtual ~CBuffer();
    BOOL Write(LPCSTR szVal);
    BOOL Write(LPCWSTR szVal);
    BOOL Write(DWORD dwVal);
    BOOL Write(DWORD64 dwVal);
    BOOL Write(BYTE cVal);
    BOOL Write(WORD wVal);
    BOOL Write(LPCVOID pBuffer, DWORD dwSize);

    BOOL WriteAlignedLenString(LPCWSTR szVal);

    DWORD ReadDWORD();
    BYTE ReadBYTE();
    WORD ReadWORD();
    LPWSTR ReadAlignedLenString(DWORD *pdwBytes);
    short int ReadShortInt();
    BOOL Read(LPVOID pBuffer, DWORD dwToRead);

    void Reset() {m_pCurrent = m_pBuffer;}
    void Reset(LPCVOID pBuffer, DWORD_PTR dwSize);
    void Reset(DWORD_PTR dwSize) { Reset(NULL, dwSize); }
    BOOL Resize(DWORD_PTR dwNewSize);
    BOOL Grow(DWORD_PTR dwGrowBy)
    {
        return Resize(m_dwSize + dwGrowBy);
    }

    // Will make sure dwSize bytes are available.  If not, it will call
    // Resize.  If that fails, it throws a CBufferException.
    void AssureSizeRemains(DWORD_PTR dwSize);

    BOOL IsEOF() {return m_pCurrent >= m_pBuffer + m_dwSize;}
    DWORD_PTR GetUsedSize() {return m_pCurrent - m_pBuffer;}
    DWORD_PTR GetUnusedSize() {return m_dwSize - (m_pCurrent - m_pBuffer);}
    void SetUsedSize(DWORD_PTR dwSize) {m_pCurrent = m_pBuffer + dwSize;}
    void SetEOF() { m_pCurrent = m_pBuffer + m_dwSize; }
    
    // A safe way to move m_pCurrent.
    void MoveCurrent(int iOffset)
    {
        if (iOffset > 0)
            AssureSizeRemains(iOffset);
        m_pCurrent += iOffset;
    }

    BOOL operator ==(const CBuffer &other);
    const CBuffer& operator =(const CBuffer &other);

    // This gets called when the buffer is realloced.  Override with your own
    // behavior if necessary.
    virtual void OnResize()
    {
    }

protected:
    BOOL m_bAllocated;

    void Free();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\objaccess.h ===
// ObjAccess.h

#ifndef _OBJACCESS_H
#define _OBJACCESS_H

#include <wbemcli.h>
#include <wbemint.h>
#include "array.h"

class CProp
{
public:
    CProp() : 
        m_lHandle(0),
        m_dwSize(0),
        m_pData(NULL)
    {
    }

    CIMTYPE m_type;
    long    m_lHandle;
    _bstr_t m_strName;
    DWORD   m_dwSize;
    LPVOID  m_pData;
};

typedef CArray<CProp, CProp&> CPropArray;

class CObjAccess
{
public:
    CObjAccess();
    CObjAccess(const CObjAccess& other);

    ~CObjAccess();
    
    const CObjAccess& operator=(const CObjAccess& other);

    enum INIT_FAILED_PROP_TYPE
    {
        // Init returns FALSE if a property isn't found.
        FAILED_PROP_FAIL, 
        
        // See if this property is an array.
        FAILED_PROP_TRY_ARRAY,
        
        // If the property isn't found just set the handle to 0 and go on.
        FAILED_PROP_IGNORE
    };

    BOOL Init(
        IWbemServices *pSvc,
        LPCWSTR szClass,
        LPCWSTR *pszPropNames,
        DWORD nProps,
        INIT_FAILED_PROP_TYPE type = FAILED_PROP_FAIL);

    BOOL WriteArrayData(DWORD dwIndex, LPVOID pData, DWORD dwItemSize);
    BOOL WriteNonPackedArrayData(DWORD dwIndex, LPVOID pData, DWORD dwItems, 
        DWORD dwTotalSize);
    BOOL WriteData(DWORD dwIndex, LPVOID pData, DWORD dwSize);
    BOOL WriteString(DWORD dwIndex, LPCWSTR szValue);
    BOOL WriteString(DWORD dwIndex, LPCSTR szValue);
    BOOL WriteDWORD(DWORD dwIndex, DWORD dwValue);
    BOOL WriteDWORD64(DWORD dwIndex, DWORD64 dwValue);
    BOOL WriteNULL(DWORD dwIndex);
    IWbemClassObject **GetObjForIndicate() { return &m_pObj; }
    IWbemClassObject *GetObj() { return m_pObj; }
    _IWmiObject *GetWmiObj() { return m_pWmiObj; }

    HRESULT SetProp(DWORD dwIndex, DWORD dwSize, LPVOID pData)
    {
        return 
            m_pWmiObj->SetPropByHandle(
                m_pProps[dwIndex].m_lHandle,
                0,
                dwSize,
                pData);
    }

protected:
    IWbemObjectAccess *m_pObjAccess;
    IWbemClassObject  *m_pObj;
    _IWmiObject       *m_pWmiObj;
    CPropArray        m_pProps;
};
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\buffer.cpp ===
#include "precomp.h"

#include <pshpack1.h>
#include "buffer.h"
#include <corex.h>
#include <poppack.h>

#define DWORD_ALIGNED(x)    (((x) + 3) & ~3)
#define QWORD_ALIGNED(x)    (((x) + 7) & ~7)

#ifdef _WIN64
#define DEF_ALIGNED         QWORD_ALIGNED
#else
#define DEF_ALIGNED         DWORD_ALIGNED
#endif

#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef DBG
#define _ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _ASSERT(X)
#endif

CBuffer::CBuffer(LPCVOID pBuffer, DWORD_PTR dwSize, ALIGN_TYPE type) :
    m_bAllocated(FALSE),
    m_pBuffer(NULL),
    m_pCurrent(NULL)
{
    LPBYTE pRealBuffer = NULL;

    // Align the buffer if necessary.
    if (type == ALIGN_NONE)
        pRealBuffer = (LPBYTE) pBuffer;
    else if (type == ALIGN_DWORD)
        pRealBuffer = (LPBYTE) DWORD_ALIGNED((DWORD_PTR) pBuffer);
    else if (type == ALIGN_QWORD)
        pRealBuffer = (LPBYTE) QWORD_ALIGNED((DWORD_PTR) pBuffer);
    else if (type == ALIGN_DWORD_PTR)
        pRealBuffer = (LPBYTE) DEF_ALIGNED((DWORD_PTR) pBuffer);
    else
        // Caller passed an invalid type.
        _ASSERT(FALSE);

    dwSize -= pRealBuffer - (LPBYTE) pBuffer;

    Reset(pRealBuffer, dwSize);
}

CBuffer::CBuffer(DWORD_PTR dwSize) :
    m_bAllocated(FALSE),
    m_pBuffer(NULL)
{
    Reset(NULL, dwSize);
}

CBuffer::CBuffer(const CBuffer &other) :
    m_bAllocated(FALSE),
    m_pBuffer(NULL)
{
    *this = other;
}

void CBuffer::Reset(LPCVOID pBuffer, DWORD_PTR dwSize)
{
    Free();

    if (!pBuffer)
    {
        pBuffer = malloc(dwSize);
		
        if (!pBuffer)
            throw CX_MemoryException();

        m_bAllocated = TRUE;
    }
    else
        m_bAllocated = FALSE;

    m_pCurrent = m_pBuffer = (LPBYTE) pBuffer;
    m_dwSize = dwSize;
}

CBuffer::~CBuffer()
{
    Free();
}

void CBuffer::Free()
{
    if (m_bAllocated && m_pBuffer)
    {
        free(m_pBuffer);

        m_pBuffer = NULL;
    }
}

BOOL CBuffer::Write(LPCSTR szVal)
{
    return Write(szVal, lstrlenA(szVal) + 1);
}

BOOL CBuffer::Write(LPCWSTR szVal)
{
    return Write(szVal, (wcslen(szVal) + 1) * sizeof(WCHAR));
}

BOOL CBuffer::Resize(DWORD_PTR dwNewSize)
{
    if ( dwNewSize < m_dwSize )
    	   return TRUE;

    if (m_pBuffer)
    {
        DWORD_PTR dwUsedSize = GetUsedSize();

        _ASSERT( dwUsedSize <= dwNewSize );

        LPBYTE pNewBuffer;
        
        if (m_bAllocated)
        {
            pNewBuffer = (LPBYTE) realloc(m_pBuffer, dwNewSize);

            if (!pNewBuffer)
            {
                pNewBuffer = (LPBYTE) malloc(dwNewSize);

                if (!pNewBuffer)
                    throw CX_MemoryException();

                memcpy(pNewBuffer, m_pBuffer, dwUsedSize);

                free(m_pBuffer);
            }
        }
        else
        {
            pNewBuffer = (LPBYTE) malloc(dwNewSize);
		
            if (!pNewBuffer)
                throw CX_MemoryException();

            memcpy(pNewBuffer, m_pBuffer, dwUsedSize);

            m_bAllocated = TRUE;

            // Free not needed because we didn't allocate the original memory.
        }

        m_pBuffer = pNewBuffer;
        m_pCurrent = pNewBuffer + dwUsedSize;
        m_dwSize = dwNewSize;

        // Inform the buffer that we reallocated.
        OnResize();
    }
    else
        Reset(dwNewSize);

    return TRUE;
}

BOOL CBuffer::WriteAlignedLenString(LPCWSTR szVal)
{
    DWORD dwLen = (wcslen(szVal) + 1) * sizeof(WCHAR),
        dwLenAligned = DWORD_ALIGNED(dwLen);
    BOOL  bRet;

    bRet = Write(dwLen);

    if (bRet)
    {
        bRet = Write(szVal, dwLen); 

        if (bRet)
            // Move current to make up for the padding, if needed.
            MoveCurrent(dwLenAligned - dwLen);
    }

    return bRet;
}

#define DEF_GROW_BY 256

void CBuffer::AssureSizeRemains(DWORD_PTR dwSize)
{
    DWORD_PTR dwUnusedSize = GetUnusedSize();

    if (dwSize > dwUnusedSize)
    {
        Grow(max(dwSize - dwUnusedSize, DEF_GROW_BY));
    }
}

BOOL CBuffer::Write(DWORD dwVal)
{
    AssureSizeRemains(sizeof(dwVal));

    *((DWORD *) m_pCurrent) = dwVal;

    m_pCurrent += sizeof(dwVal);

    return TRUE;
}

BOOL CBuffer::Write(DWORD64 dwVal)
{
    AssureSizeRemains(sizeof(dwVal));

    *((DWORD64 *) m_pCurrent) = dwVal;

    m_pCurrent += sizeof(dwVal);

    return TRUE;
}

BOOL CBuffer::Write(BYTE cVal)
{
    AssureSizeRemains(sizeof(cVal));
    
    *((BYTE *) m_pCurrent) = cVal;
	
    m_pCurrent += sizeof(cVal);
    
    return TRUE;
}

BOOL CBuffer::Write(WORD wVal)
{
    AssureSizeRemains(sizeof(wVal));

    *((WORD *) m_pCurrent) = wVal;

    m_pCurrent += sizeof(WORD);  

    return TRUE;
}

DWORD CBuffer::ReadDWORD()
{
    if ( GetUnusedSize() < sizeof(DWORD) )
        throw CX_MemoryException();
        
#ifndef _WIN32_WCE
    DWORD dwVal = *((DWORD *) m_pCurrent);
#else
    DWORD dwVal = 0;
    memcpy(&dwVal, m_pCurrent, sizeof(DWORD));
#endif
    m_pCurrent += sizeof(dwVal);     
    return dwVal;
}

BYTE CBuffer::ReadBYTE()
{
    if ( GetUnusedSize() < 1 )
        throw CX_MemoryException();

    BYTE cVal = *((BYTE *) m_pCurrent);
    m_pCurrent += sizeof(cVal);    
    return cVal;
}

WORD CBuffer::ReadWORD()
{
    if ( GetUnusedSize() < 2 )
       throw CX_MemoryException();

#ifndef _WIN32_WCE
    WORD wVal = *((WORD *) m_pCurrent);
#else
    WORD wVal;
    memcpy(&wVal, m_pCurrent, sizeof(WORD));
#endif
	
    m_pCurrent += sizeof(wVal);    
    return wVal;
}

BOOL CBuffer::Read(LPVOID pBuffer, DWORD dwToRead)
{
    if ( GetUnusedSize() < dwToRead )
        throw CX_MemoryException();
		
    memcpy(pBuffer, m_pCurrent, dwToRead);
    m_pCurrent += dwToRead; 
    return TRUE;
}

BOOL CBuffer::Write(LPCVOID pBuffer, DWORD dwSize)
{
    AssureSizeRemains(dwSize);

    memcpy(m_pCurrent, pBuffer, dwSize);
	
    m_pCurrent += dwSize;

    return TRUE;
}

BOOL CBuffer::operator ==(const CBuffer &other)
{
    if (!m_pBuffer && !other.m_pBuffer)
        return TRUE;

    // See if the sizes aren't the same, or if either buffer is NULL,
    // return FALSE.
    if (m_dwSize != other.m_dwSize || !m_pBuffer || !other.m_pBuffer)
        return FALSE;

    // Compare the buffers.
    return !memcmp(m_pBuffer, other.m_pBuffer, m_dwSize);
}

const CBuffer& CBuffer::operator =(const CBuffer &other)
{
    // NULL so we allocate our own buffer.
    Reset(NULL, other.m_dwSize);
	
	// Copy the bits.
    memcpy(m_pBuffer, other.m_pBuffer, other.m_dwSize);

    return *this;
}

LPWSTR CBuffer::ReadAlignedLenString(DWORD *pdwBytes)
{
    LPWSTR szRet = (LPWSTR) (m_pCurrent + sizeof(DWORD));

    if ( GetUnusedSize() < sizeof(DWORD) )
        throw CX_MemoryException();

    *pdwBytes = *(DWORD*) m_pCurrent;

    if ( GetUnusedSize() < DWORD_ALIGNED(*pdwBytes) + sizeof(DWORD) )
        throw CX_MemoryException();

    m_pCurrent += DWORD_ALIGNED(*pdwBytes) + sizeof(DWORD);
    return szRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\objaccess.cpp ===
#include "precomp.h"
#include "ObjAccess.h"

/////////////////////////////////////////////////////////////////////////////
// CObjAccess

CObjAccess::CObjAccess() :
    m_pObj(NULL),
    m_pObjAccess(NULL),
    m_pWmiObj(NULL),
    m_pProps(0)
{
}

CObjAccess::CObjAccess(const CObjAccess& other) :
    m_pProps(other.m_pProps),
    m_pObj(NULL),
    m_pObjAccess(NULL),
    m_pWmiObj(NULL)
{
    other.m_pObj->Clone(&m_pObj);

    m_pObj->QueryInterface(
        IID_IWbemObjectAccess, 
        (LPVOID*) &m_pObjAccess);
    m_pObj->QueryInterface(
        IID__IWmiObject, 
        (LPVOID*) &m_pWmiObj);
}

CObjAccess::~CObjAccess()
{
    if (m_pObjAccess)
        m_pObjAccess->Release();

    if (m_pObj)
        m_pObj->Release();

    if (m_pWmiObj)
        m_pWmiObj->Release();
}

    
const CObjAccess& CObjAccess::operator=(const CObjAccess& other)
{
    m_pProps = other.m_pProps;

    other.m_pObj->Clone(&m_pObj);

    m_pObj->QueryInterface(
        IID_IWbemObjectAccess, 
        (LPVOID*) &m_pObjAccess);

    m_pObj->QueryInterface(
        IID__IWmiObject, 
        (LPVOID*) &m_pWmiObj);

    return *this;
}

BOOL CObjAccess::Init(
    IWbemServices *pSvc,
    LPCWSTR szClass,
    LPCWSTR *pszPropNames,
    DWORD nProps,
    INIT_FAILED_PROP_TYPE typeFail)
{
    IWbemClassObject *pClass = NULL;
    BOOL             bRet = FALSE;

    if (SUCCEEDED(pSvc->GetObject(
        _bstr_t(szClass), 
        0, 
        NULL, 
        &pClass, 
        NULL)) &&
        SUCCEEDED(pClass->SpawnInstance(0, &m_pObj)))
    {
        // Get out if we don't need the whole IWbemObjectAccess stuff.
        if (nProps == 0)
            return TRUE;

        m_pObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID*) &m_pObjAccess);
        m_pObj->QueryInterface(IID__IWmiObject, (LPVOID*) &m_pWmiObj);

        if (m_pProps.Init(nProps))
        {
            m_pProps.SetCount(nProps);
            
            bRet = TRUE;

            for (DWORD i = 0; i < nProps; i++)
            {
                CProp &prop = m_pProps[i];

                if(m_pWmiObj)
                {
                    if (SUCCEEDED(m_pWmiObj->GetPropertyHandleEx(
                        pszPropNames[i],
                        0,
                        &prop.m_type,
                        &prop.m_lHandle)))
                    {
                        prop.m_strName = pszPropNames[i];
                    }
                }
                else
                {
                    if (SUCCEEDED(m_pObjAccess->GetPropertyHandle(
                        pszPropNames[i],
                        &prop.m_type,
                        &prop.m_lHandle)))
                    {
                        prop.m_strName = pszPropNames[i];
                    }
                }
            }
        }
    }

    if (pClass)
        pClass->Release();
    
    return bRet;    
}

BOOL CObjAccess::WriteData(DWORD dwIndex, LPVOID pData, DWORD dwSize)
{
    CProp &prop = m_pProps[dwIndex];
    BOOL  bRet = FALSE;

    // This function only works for non arrays.
    _ASSERT((prop.m_type & CIM_FLAG_ARRAY) == 0);

    bRet =  
        SUCCEEDED(m_pObjAccess->WritePropertyValue(
            prop.m_lHandle,
            dwSize,
            (LPBYTE) pData));

    return bRet;
}

BOOL CObjAccess::WriteArrayData(DWORD dwIndex, LPVOID pData, DWORD dwItemSize)
{
    if(m_pWmiObj == NULL)
        return TRUE; // pretend we did it

    CProp &prop = m_pProps[dwIndex];

    // This function only works for arrays.
    _ASSERT(prop.m_type & CIM_FLAG_ARRAY);
        
    DWORD   dwItems = *(DWORD*) pData,
            dwSize = dwItems * dwItemSize;

    HRESULT hr;

    hr =
        m_pWmiObj->SetArrayPropRangeByHandle(
            prop.m_lHandle,
            WMIARRAY_FLAG_ALLELEMENTS, // flags
            0,                         // start index
            dwItems,                   // # items
            dwSize,                    // buffer size
            ((LPBYTE) pData) + sizeof(DWORD)); // data buffer

    return SUCCEEDED(hr);
}

BOOL CObjAccess::WriteNonPackedArrayData(
    DWORD dwIndex, 
    LPVOID pData, 
    DWORD dwItems, 
    DWORD dwTotalSize)
{
    if(m_pWmiObj == NULL)
        return TRUE; // pretend we did it

    CProp   &prop = m_pProps[dwIndex];
    HRESULT hr;

    // This function only works for arrays.
    _ASSERT(prop.m_type & CIM_FLAG_ARRAY);

    hr =
        m_pWmiObj->SetArrayPropRangeByHandle(
            prop.m_lHandle,
            WMIARRAY_FLAG_ALLELEMENTS, // flags
            0,                         // start index
            dwItems,                   // # items
            dwTotalSize,               // buffer size
            pData);                    // data buffer

    return SUCCEEDED(hr);
}


BOOL CObjAccess::WriteString(DWORD dwIndex, LPCWSTR szValue)
{
    return 
        SUCCEEDED(m_pObjAccess->WritePropertyValue(
            m_pProps[dwIndex].m_lHandle, 
            (wcslen(szValue) + 1) * sizeof(WCHAR),
            (LPBYTE) szValue));
}

BOOL CObjAccess::WriteString(DWORD dwIndex, LPCSTR szValue)
{
    return WriteString(dwIndex, (LPCWSTR) _bstr_t(szValue));
}

BOOL CObjAccess::WriteDWORD(DWORD dwIndex, DWORD dwValue)
{
    return
        SUCCEEDED(m_pObjAccess->WriteDWORD(
            m_pProps[dwIndex].m_lHandle, 
            dwValue));
}

BOOL CObjAccess::WriteDWORD64(DWORD dwIndex, DWORD64 dwValue)
{
    return
        SUCCEEDED(m_pObjAccess->WriteQWORD(
            m_pProps[dwIndex].m_lHandle, 
            dwValue));
}

BOOL CObjAccess::WriteNULL(DWORD dwIndex)
{
    return 
        SUCCEEDED(m_pObj->Put(
            m_pProps[dwIndex].m_strName, 
            0,
            NULL,
            0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	P2Prov.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\errorobj.cpp ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name: ErrorObj

Abstract: IErrorInfo support for the standard consumers

History: 07/11/2001 - creation, HHance.

--*/

#include "precomp.h"
//#include <stdio.h>
#include <wbemutil.h>
//#include <ArrTempl.h>
//#include <lmaccess.h>
#include <wbemdisp.h>
//#include "ScriptKiller.h"
//#include "script.h"
//#include "ClassFac.h"
//#include <GroupsForUser.h> 
#include <GenUtils.h>

#include "ErrorObj.h"
#include <strsafe.h>


#define ClassName L"__ExtendedStatus"

// no touch.  Use GetErrorObj instead.
ErrorObj StaticErrorObj;

// so we can manage our component's lifetimes in the wunnerful world of COM, etc...
// returns addref'd error object
ErrorObj* ErrorObj::GetErrorObj()
{
    StaticErrorObj.AddRef();
    return &StaticErrorObj;
}


// returns adref'd namespace ("root")
IWbemServices* ErrorObj::GetMeANamespace()
{
    IWbemServices* pNamespace = NULL;
    IWbemLocator* pLocator = NULL;

    if (SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
                                          IID_IWbemLocator, (void**)&pLocator)))
    {
        BSTR bstrNamespace;
        bstrNamespace = SysAllocString(L"root");
        
        if (bstrNamespace)
        {            
            pLocator->ConnectServer(bstrNamespace,  NULL, NULL, NULL, 0, NULL, NULL, &pNamespace);
            SysFreeString(bstrNamespace);
        }

        pLocator->Release();
    }

    return pNamespace;
}


ULONG ErrorObj::AddRef()
{
    // since we don't do a delete this
    // there is a chance that someone could sneak in and re-init while we're in the process
    // of shutting down.  That would be bad. 
    // Hence we use our own CS instead of interlockedXXrement.

    CInCritSec cs( &m_cs );
    
    ULONG count = ++m_lRef;
    
    return count;
}

// we do not do a 'delete this' here.  
// We just release the COM objects
ULONG ErrorObj::Release()
{
    // since we don't do a 'delete this'
    // there is a chance that someone could sneak in and re-init 
    // while we're in the process of shutting down.  
    // That would be bad.
    // Hence we use our own CS instead of interlockedXXrement.
    CInCritSec cs( &m_cs );

    ULONG count = --m_lRef;

    if (m_lRef == 0)
    {
        if (m_pErrorObject)
        {
            m_pErrorObject->Release();
            m_pErrorObject = NULL;
        }
    }

    return count;
}

// does the real work, creates the object, populates it, sends it off.
// arguments map to __ExtendedStatus class.
// void func - what are y'gonna do if you can't report an error?  Report an error?
// bFormat - will attempt to use FormatError to fill in the description if NULL.
void ErrorObj::ReportError(const WCHAR* operation, const WCHAR* parameterInfo, const WCHAR* description, UINT statusCode, bool bFormat)
{
    // a shiny new instance of __ExtendedStatus
    IWbemClassObject* pObj = GetObj();
    IErrorInfo* pEI = NULL;

    if (pObj && SUCCEEDED(pObj->QueryInterface(IID_IErrorInfo, (void**)&pEI)))
    {
        // theory: I'm going to try to set everything.  
        // something might fail along the way.  At this point
        // the biggest disaster would be that the user got partial info
        VARIANT v;
        VariantInit(&v);
        v.vt = VT_BSTR;

        // Operation
        if (operation)
        {
            v.bstrVal = SysAllocString(operation);
            if (v.bstrVal)
            {
                pObj->Put(L"Operation", 0, &v, 0);
                SysFreeString(v.bstrVal);
            }
        }

        // ParameterInfo
        if (parameterInfo)
        {
            v.bstrVal = SysAllocString(parameterInfo);
            if (v.bstrVal)
            {
                pObj->Put(L"ParameterInfo", 0, &v, 0);
                SysFreeString(v.bstrVal);
            }
        }
        
        
        // Description
        if (description)
            v.bstrVal = SysAllocString(description);
        else if (bFormat)
        {
            WCHAR* pMsg = NULL;
            if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL, statusCode, 0, (WCHAR*)&pMsg, 1, NULL) && pMsg)
            {
                v.bstrVal = SysAllocString(pMsg);
                LocalFree(pMsg);
            }
            else
                v.bstrVal = NULL;
        }
        else
            v.bstrVal = NULL;

        if (v.bstrVal)
        {
            pObj->Put(L"Description", 0, &v, 0);
            SysFreeString(v.bstrVal);
        }


        // StatusCode
        v.vt = VT_I4;
        v.lVal = statusCode;
        pObj->Put(L"StatusCode", 0, &v, 0);

        // do it to it
        SetErrorInfo(0, pEI);
    }

    if (pObj)
        pObj->Release();

    if (pEI)
        pEI->Release();

}

// spawn off an object to be populated
// can't keep reusing same object as we have more than one thread going
IWbemClassObject* ErrorObj::GetObj()
{
    IWbemClassObject* pObj = NULL;    

    // big CS -- need to guard against possibility of shut down
    // occuring during startup.
    CInCritSec cs( &m_cs );

    if (!m_pErrorObject)
    {
        IWbemServices* pNamespace = NULL;
        pNamespace = GetMeANamespace();
        
        if (pNamespace)
        {
            BSTR className;
            className = SysAllocString(ClassName);

            if (className)
            {
                IWbemClassObject* pClassObject = NULL;
                if (SUCCEEDED(pNamespace->GetObject(className, 0, NULL, &pClassObject, NULL)))
                {
                    // okay, if it fails, then m_pErrorObject is still NULL.  No problemo.
                    pClassObject->SpawnInstance(0, &m_pErrorObject);
                    pClassObject->Release();
                }

                SysFreeString(className);
            }

            pNamespace->Release();
        }
    }

    if (m_pErrorObject)
        m_pErrorObject->Clone(&pObj);

    return pObj;
}

/************************ a legacy before it's shipped...
// must be called inside the CS.
// must be called prior to ReportError (if you expect it to succeed, anyway...)
void ErrorObj::SetNamespace(IWbemServices* pNamespace)
{
    // first one in wins, after that it's static
    if (pNamespace && !m_pNamespace)
    {
        if (!m_pNamespace)
        {
            m_pNamespace = pNamespace;
            m_pNamespace->AddRef();
        }
    }
}
*************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\precomp.h ===
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <winsock2.h>
#include <ole2.h>
#include <windows.h>

#pragma message("Hi there")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\errorobj.h ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name: ErrorObj

Abstract: IErrorInfo support for the standard consumers

History: 07/11/2001 - creation, HHance.

--*/

#ifndef STDCONS_ERROBJ_COMPILED
#define STDCONS_ERROBJ_COMPILED

#include <wbemidl.h>
#include <sync.h>

// class to build an IErrorInfo (Acutally an IWbemClassObject for our purposes)
// used by the standard consumers to report errors in execution
// we'll keep a single global object around, lifetime managed by addref & release
// instanciation & access is via GetErrorObj()    
class ErrorObj
{
public:
    // so we can manage our component's lifetimes in the wunnerful world of COM, etc...
    // returns addref'd error object
    static ErrorObj* GetErrorObj();
        
    // does the real work, creates the object, populates it, sends it off.
    // arguments map to __ExtendedStatus class.
    // void func - what are y'gonna do if you can't report an error?  Report an error?
    // bFormat - will attempt to use FormatError to fill in the description if NULL.
    void ReportError(const WCHAR* operation, const WCHAR* parameterInfo, const WCHAR* description, UINT statusCode, bool bFormat);

    ULONG AddRef();
    ULONG Release();

    // Do not create one of these!
    // Use GetErrorObj.  Thou Hast Been Warned...
    ErrorObj() : m_pErrorObject(NULL), m_lRef(0) { };
    
    // com objects are taken care of by Release()
    ~ErrorObj() { };

protected:

    // must be called prior to SetError (if you expect it to succeed, anyway...)
    IWbemServices* GetMeANamespace();


    // refcount, when it goes to zero, we release our COM objects
    ULONG m_lRef;

    // error object object
    IWbemClassObject* m_pErrorObject;

    // protection for our IWbemXXX pointers.
    CCritSec m_cs;

    // spawn off an object to be populated
    IWbemClassObject* GetObj();
};

#endif // STDCONS_ERROBJ_COMPILED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\killtimer.h ===
#ifndef __KILL_TIMER_COMPILED__
#define __KILL_TIMER_COMPILED__

#include <wbemidl.h>
#include <wbemutil.h>
#include <cominit.h>
#include <Limits.h>

#include <FlexArry.h>
#include <unk.h>
#include <sync.h>

// used for "forever" or "invalid date"
const FILETIME FILETIME_MAX = {_UI32_MAX, _UI32_MAX};

// something to make FILETIME easier to deal with
// performs casts automagically, allows addition
union WAYCOOL_FILETIME
{
public:
    /* CONSTRUCTION */
    WAYCOOL_FILETIME(UINT64 ui64 = 0)
    { m_ui64 = ui64; }

    WAYCOOL_FILETIME(FILETIME ft)
    { m_ft = ft; }
    

    /* ASSIGNMENT */
    FILETIME& operator= (const FILETIME& other)
    { m_ft = other; return m_ft; }

    UINT64& operator= (const UINT64& other)
    { m_ui64 = other; return m_ui64; }

    
    /* COMPARISON */    
    bool operator< (const WAYCOOL_FILETIME& other)
    { return m_ui64 < other.m_ui64; }
    bool operator<= (const WAYCOOL_FILETIME& other)
    { return m_ui64 <= other.m_ui64; }

    bool operator> (const WAYCOOL_FILETIME& other)
    { return m_ui64 >  other.m_ui64; }
    bool operator>= (const WAYCOOL_FILETIME& other)
    { return m_ui64 >= other.m_ui64; }
    
    bool operator== (const WAYCOOL_FILETIME& other)
    { return m_ui64 == other.m_ui64; }
    bool operator!= (const WAYCOOL_FILETIME& other)
    { return m_ui64 != other.m_ui64; }

    /* ADDITION & SUBTRACTION */
    // remember: units are hundreds of nanoseconds
    WAYCOOL_FILETIME operator+  (UINT64 other)
    { return WAYCOOL_FILETIME(m_ui64 + other); }
    
    WAYCOOL_FILETIME& operator+= (UINT64 other)
    {
        m_ui64 += other;
        return *this;
    }

    WAYCOOL_FILETIME operator-  (UINT64 other)
    { return WAYCOOL_FILETIME(m_ui64 - other); }

    WAYCOOL_FILETIME& operator-= (UINT64 other)
    {
        m_ui64 -= other;
        return *this;
    }

    // += that takes seconds as a parm
    WAYCOOL_FILETIME& AddSeconds(UINT64 other)
    { return operator+= (SecondsToTicks(other)); }    
                                       
    // -= that takes seconds as a parm
    WAYCOOL_FILETIME& SubtractSeconds(UINT64 other)
    { return operator-= (SecondsToTicks(other)); }


    /* CASTS & CONVERSIONS */
    operator UINT64()
    { return m_ui64; }

    // hey if CString can do it, so can I...
    operator UINT64*()
    { return &m_ui64; }
    
    operator FILETIME()
    { return m_ft; }        



    static UINT64 SecondsToTicks(UINT64 ticks)
    { return (ticks * 10000000ui64); }


    /* GET, SET */
    FILETIME GetFILETIME(void)
    { return m_ft; }

    void SetFILETIME(FILETIME ft)
    { m_ft = ft; }

    UINT64 GetUI64(void)
    { return m_ui64; }

    void SetUI64(UINT64 ui64)
    { m_ui64 = ui64; }


private:
    FILETIME m_ft;
    UINT64   m_ui64;
};


/* VIRTUAL BASE CLASS CKiller DEFINITION */

// base class for things that can be killed
// chlid classes should only need to add constructor
// and overrid Die()
class CKiller
{
public:
    CKiller(FILETIME deathDate, CLifeControl* pControl) :
        m_pControl(pControl), m_deathDate(deathDate)
    {
        if (m_pControl)
            m_pControl->ObjectCreated(NULL);       
    }

    virtual ~CKiller()
    {
        if (m_pControl)
            m_pControl->ObjectDestroyed(NULL);       
    }

    // terminate whatever, 
    virtual void Die() = 0;

    // returns true if now is >= death date
    bool TimeExpired(const FILETIME& now)
        { return (CompareTime(now) < 1); }

    // returns  0 if times identical
    //         -1 if this time is less than now
    //         +1 if this time is greater than now
    int CompareTime(const FILETIME& now)
        { return CompareFileTime(&m_deathDate, &now); }

    FILETIME GetDeathDate()
        { return m_deathDate; }

protected:

private:
    FILETIME m_deathDate;
    CLifeControl* m_pControl;
};

// class to provide an arbitrary life time to a process
// proc is killed after a specified timeout
// intended as a global manager class
class CKillerTimer
{
public:

    /* CONSTRUCTION & INITIALIZATION */
    CKillerTimer();
    ~CKillerTimer();

    HRESULT Initialize(CLifeControl* pControl);

    // force shutdown.
    void UnloadNOW();

    /* VICTIM CONTROL */
    // who to kill & when
    // generic version of ScheduleAssassination.  You can stuff any CKiller derived class in.
    // alternatively, the derived class can hide this & expose their own specialized version
    HRESULT ScheduleAssassination(CKiller* pKiller);

protected:

    // holds CKillers sorted by execution time.
    // earliest date first
    // array is not sorted "natively:" order is enforced at ScheduleAssaination time.
    // TODO: consider use of a container that sorts itself.
    CFlexArray m_killers;

    /* SYNCHRONIZATION */

    // keep us from getting our threads tangled around the array
    CCritSec m_csKillers;

    // protect worker thread startup & shutdown
    CCritSec m_csStartup;

    // event signalled when it's time to go away
    HANDLE m_hShutdown;

    // event signalled when there's a new item in the list
    HANDLE m_hNewVictim;

    /* THREAD CONTOL */

    // called by first thread to notice there isn't a timer thread
    HRESULT StartTimer();

    // shuts down timer thread
    bool KillTimer();

    // main killer thread loop
    static DWORD WINAPI ThreadStartRoutine(LPVOID lpParameter);
    void   RunKillerThread();

    /* KILLER THREAD'S ROUTINES */

    // kill all procs that are older than our expiration date
    // called from killer thread only
    void   KillOffOldGuys(const FILETIME& now);

    // decide when to set the waitable timer again.
    // called from killer thread only
    void   RecalcNextKillingSpree(FILETIME& then);

protected:
    CLifeControl* m_pControl;

private:
    // thread to handle actual waits & kills
    HANDLE m_hTimerThread;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\classfac.cpp ===
#include "precomp.h"
#include "ClassFac.h"
#include <arrTempl.h>

DWORD WMIScriptClassFactory::m_scriptsStarted = 0;
 
DWORD WMIScriptClassFactory::m_scriptsAllowed = 300;

bool WMIScriptClassFactory::m_bIsScriptsAllowedInitialized = false;
bool WMIScriptClassFactory::m_bWeDeadNow = false;


DWORD WMIScriptClassFactory::m_timerID = 0;

HRESULT WMIScriptClassFactory::CreateInstance(IUnknown* pOuter, REFIID riid, void** ppv)
{
    if (!m_bIsScriptsAllowedInitialized)
        FindScriptsAllowed();
    
    HRESULT hr = CClassFactory<CScriptConsumer>::CreateInstance(pOuter, riid, ppv);

    return hr;
}

// our time has come.  Curl up & die.
void CALLBACK WMIScriptClassFactory::TimeoutProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) 
{
    CoSuspendClassObjects();
    KillTimer(NULL, m_timerID);
    m_timerID = 0;
    m_bWeDeadNow = true;
}

bool WMIScriptClassFactory::LimitReached(void)
{
    return m_bWeDeadNow;
}

// determine number of scripts we're allowed to run
// from the class registration object
void WMIScriptClassFactory::FindScriptsAllowed(void)
{    
    m_bIsScriptsAllowedInitialized = true;
    HRESULT hr;
    IWbemLocator* pLocator;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
                                          IID_IWbemLocator, (void**)&pLocator)))
    {
        CReleaseMe releaseLocator(pLocator);

        BSTR bstrNamespace;
        bstrNamespace = SysAllocString(L"root\\CIMv2");
        
        if (bstrNamespace)
        {
            IWbemServices* pNamespace;
            CSysFreeMe freeBstr(bstrNamespace);
            hr = pLocator->ConnectServer(bstrNamespace,  NULL, NULL, NULL, 0, NULL, NULL, &pNamespace);
            if (SUCCEEDED(hr))
            {
                CReleaseMe relNamespace(pNamespace);

                BSTR bstrClassName;
                bstrClassName = SysAllocString(L"ScriptingStandardConsumerSetting=@");
                if (bstrClassName)
                {
                    IWbemClassObject* pRegistration = NULL;
                    CSysFreeMe freeTheClassNames(bstrClassName);               
                    hr = pNamespace->GetObject(bstrClassName, 0, NULL, &pRegistration, NULL);
                    if (SUCCEEDED(hr))
                    {
                        CReleaseMe relRegistration(pRegistration);

                        VARIANT v;
                        VariantInit(&v);

                        if (SUCCEEDED(pRegistration->Get(L"MaximumScripts", 0, &v, NULL, NULL))
                            && ((v.vt == VT_I4) || (v.vt == VT_UI4))
                            && (v.ulVal > 0))
                        {
                            m_scriptsAllowed = (DWORD)v.ulVal;
                            VariantClear(&v);
                        }

                        if (SUCCEEDED(hr = pRegistration->Get(L"Timeout", 0, &v, NULL, NULL))
                            && (v.vt == VT_I4))
                        {
                            // maximum to prevent overflow, doc'd in MOF
                            if ((((DWORD)v.lVal) <= 71000) && ((DWORD)v.lVal > 0))
                            {
                                UINT nMilliseconds = (DWORD)v.lVal * 1000 * 60;
                                m_timerID = SetTimer(NULL, 0, nMilliseconds, TimeoutProc);
                            }
                        }
                    }
                }
            }
        }
    }
}

// after the specified number of scripts have been run
// we suspend the class object
// note that access to m_scriptsStarted is not serialized.
// this should not cause a problem, m_scripts allowed does not change
// after instanciation, and if we blow it, it just means we allow
// an extra script to be run, or call CoSuspend an extra time.
void WMIScriptClassFactory::IncrementScriptsRun(void)
{    
    InterlockedIncrement((long*)&m_scriptsStarted);

    if (m_scriptsStarted >= m_scriptsAllowed)
    {
        CoSuspendClassObjects();
        m_bWeDeadNow = true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\killtimer.cpp ===
#include "precomp.h"
#include "KillTimer.h"
#include <strsafe.h>

HRESULT CKillerTimer::Initialize(CLifeControl* pControl)
{
    HRESULT hr = WBEM_E_FAILED;

    // create events
    m_hShutdown  = CreateEvent(NULL, false, false, NULL);
    m_hNewVictim = CreateEvent(NULL, false, false, NULL);

    // get some control into our lives
    m_pControl = pControl;

    if (m_hShutdown && m_hNewVictim && m_pControl)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

CKillerTimer::CKillerTimer()
    : m_hTimerThread(NULL), m_hShutdown(NULL), 
      m_hNewVictim(NULL), m_pControl(NULL)
{
}

// shuts down timer thread
// toggle thread dead event
// wait for thread to exit
bool CKillerTimer::KillTimer()
{
    bool bRet = false;
    
    CInCritSec csStartup(&m_csStartup);
    
    // double check - might have gotten crossed up...
    if (m_hTimerThread != NULL)
    {
        if (SetEvent(m_hShutdown))
        {
            // you've got one minute to vacate...
            bRet = (WAIT_TIMEOUT != WaitForSingleObject(m_hTimerThread, 60000));

            CloseHandle(m_hTimerThread);
            m_hTimerThread = NULL;
        }
    }

    return bRet;
}

// kill all procs that are older than our expiration date
// called from killer thread only
void CKillerTimer::KillOffOldGuys(const FILETIME& now)
{
    CInCritSec csKillers(&m_csKillers);
    CKiller* pKiller;
    int nSize = m_killers.Size();

    for (int i = 0; 
    
        (i < nSize) && 
        (pKiller = ((CKiller*)m_killers[i])) &&    
        pKiller->TimeExpired(now); 
        
        i++)
    {
        
        m_killers[i] = NULL;
        pKiller->Die();
        // all done now
        delete pKiller;
    }

    // remove them NULLs
    m_killers.Compress();
}

// decide when to set the waitable timer again.
// called from killer thread only
void CKillerTimer::RecalcNextKillingSpree(FILETIME& then)
{
    CInCritSec csKillers(&m_csKillers);

    if (m_killers.Size() > 0)
        // since these are assumed sorted, we can just grab the first one
        then = ((CKiller*)m_killers[0])->GetDeathDate();
    else
        then = FILETIME_MAX;
}


HRESULT CKillerTimer::StartTimer() 
{
    CInCritSec csStartup(&m_csStartup);
    HRESULT hr = WBEM_S_NO_ERROR;

    // double check - might have gotten crossed up...
    if (m_hTimerThread == NULL)
    {
        DWORD dwIDLikeIcare;
        m_hTimerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadStartRoutine, 
                                     (LPVOID)this, 0, &dwIDLikeIcare);
        if (m_hTimerThread == NULL)
            hr = WBEM_E_FAILED;
    }

    return hr;
}

DWORD WINAPI CKillerTimer::ThreadStartRoutine(LPVOID lpParameter)
{
    ((CKillerTimer*)lpParameter)->RunKillerThread();

    return 0;
}

void CKillerTimer::RunKillerThread()
{    
    HRESULT foo = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    HANDLE hTimer = CreateWaitableTimer(NULL, false, NULL);
    HANDLE hAutoShutdownTimer = CreateWaitableTimer(NULL, false, NULL);

    // toggled if while we are inside the startup CS
    // so we know to get out when we leave
    bool bInStartupCS = false;
    
    // those things that are worth waiting for
    enum { FirstEvent       = WAIT_OBJECT_0,
           TimerEvent       = FirstEvent,
           AutoShutdownEvent,
           NewVictimEvent,
           LastHandledEvent = NewVictimEvent,
           ShutDownEvent,
           TrailerEvent
         };

    // order counts.  so does neatness.
    const DWORD nEvents = TrailerEvent -FirstEvent;

    HANDLE events[nEvents];
    events[TimerEvent        -FirstEvent] = hTimer;
    events[AutoShutdownEvent -FirstEvent] = hAutoShutdownTimer;
    events[NewVictimEvent    -FirstEvent] = m_hNewVictim;
    events[ShutDownEvent     -FirstEvent] = m_hShutdown;
    
// silliness about the FirstEvent <= whichEvent being always true
// well it is unless somebody changes one of hte constants
// whihc is *why* I made them constants in the first place...
#pragma warning(disable:4296)

    DWORD whichEvent;
    for (whichEvent = WaitForMultipleObjects(nEvents, (const HANDLE*)&events, FALSE, INFINITE);
        (FirstEvent <= whichEvent) && (whichEvent <= LastHandledEvent);
         whichEvent = WaitForMultipleObjects(nEvents, (const HANDLE*)&events, FALSE, INFINITE))
#pragma warning(default:4296)
    {        
        // cancel auto-shutdown if scheduled;
        CancelWaitableTimer(hAutoShutdownTimer);

        switch (whichEvent)
        {
            case AutoShutdownEvent:
                {
                    m_csStartup.Enter();

                    // double check - might have gotten crossed up...
                    if (m_hTimerThread != NULL)
                    {
                        {
                            // see if there's anything in the queue
                            // if it's enpty - we're gone
                            // if anything slips in, it'll get caught at ScheduleAssassination time
                            // and we'll start a new thread
                            CInCritSec csKillers(&m_csKillers);

                            if (m_killers.Size() == 0)
                            {
                                bInStartupCS = true;

                                CloseHandle(m_hTimerThread);
                                m_hTimerThread = NULL;

                                // and we're outta here...
                                SetEvent(m_hShutdown);
                            }
                        }
                    }
                }
                break;
            case TimerEvent:
            {
                // the *official* "now" so we don't get confused
                // anything that occurs after *official* "now" must wait for next loop
                FILETIME now;
                GetSystemTimeAsFileTime(&now);    
                KillOffOldGuys(now);
                
                // if we killed everybody off
                // schedule our own termination in sixty seconds
                {
                    CInCritSec csKillers(&m_csKillers);

                    if (m_killers.Size() == 0)
                    {
                        WAYCOOL_FILETIME then = WAYCOOL_FILETIME(now) +WAYCOOL_FILETIME::SecondsToTicks(60);
                        SetWaitableTimer(hAutoShutdownTimer, (const union _LARGE_INTEGER *)&then, 0, NULL, NULL, true);
                    }
                }
            }
            // no break; FALLTHROUGH to recalc
            case NewVictimEvent:
            {
                FILETIME then;
                RecalcNextKillingSpree(then);
                if (WAYCOOL_FILETIME(FILETIME_MAX) != WAYCOOL_FILETIME(then))
                    if (!SetWaitableTimer(hTimer, (const union _LARGE_INTEGER *)&then, 0, NULL, NULL, true))
                    {
                        DWORD dwErr = GetLastError();
                    }
            }
            break;
        }
    }
         
    // handle the other handles
    CancelWaitableTimer(hTimer);
    CloseHandle(hTimer);
    
    CancelWaitableTimer(hAutoShutdownTimer);
    CloseHandle(hAutoShutdownTimer);
    
    // last gasp at killing off anyone whose time has come
    FILETIME now;
    GetSystemTimeAsFileTime(&now);            
    KillOffOldGuys(now);

    CoUninitialize();

    if (bInStartupCS)
        m_csStartup.Leave();
}

CKillerTimer::~CKillerTimer()
{
    if (m_hTimerThread)
        if (!KillTimer())
            ERRORTRACE((LOG_ESS, "CKillerTimer: Unable to stop worker thread, continuing shutdown\n"));

    UnloadNOW();
   
    if (m_hShutdown)  CloseHandle(m_hShutdown);
    if (m_hNewVictim)  CloseHandle(m_hNewVictim);
}

// clear out array, does not trigger deaths
void CKillerTimer::UnloadNOW(void)
{
    CInCritSec csKillers(&m_csKillers);
    
    for (int i = 0; i < m_killers.Size(); i++)
    {
        delete (CKiller*)m_killers[i];
        m_killers[i] = NULL;
    }

    m_killers.Empty();
}

// insert pKiller into array where he belongs
HRESULT CKillerTimer::ScheduleAssassination(CKiller* pKiller)
{
    HRESULT hr = WBEM_E_FAILED;
    {
        CInCritSec csKillers(&m_csKillers);

        if (m_killers.Size())
        {            
            // minor optimization: check to see if this time is greater than all known
            // this will ALWAYS be the case if all procs are created with the same timeout.
            if  (((CKiller*)m_killers[m_killers.Size() -1])->CompareTime(pKiller->GetDeathDate()) < 0)
            {
                if (SUCCEEDED(m_killers.Add(pKiller)))
                    hr = WBEM_S_NO_ERROR;
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }            
            else
            {
                int nFirstGreater = 0;
                // WARNING: break in middle of loop.
                while (nFirstGreater < m_killers.Size())
                {
                    if (((CKiller*)m_killers[nFirstGreater])->CompareTime(pKiller->GetDeathDate()) >= 0)
                    {
                        if (SUCCEEDED(m_killers.InsertAt(nFirstGreater, (void*)pKiller)))
                        {
							hr = WBEM_S_NO_ERROR;
                            break; // BREAKOUT!
                        }
                        else
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    nFirstGreater++;
                } // endwhile
            } // else
        }
        else
        {
            // array is empty
            if (SUCCEEDED(m_killers.Add(pKiller)))
                hr = WBEM_S_NO_ERROR;
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    // we'll set this last just to make sure, 
    // timer thread may have died along the way
    if (SUCCEEDED(hr))
    {
        hr = StartTimer();
        if (!SetEvent(m_hNewVictim))
            hr = WBEM_E_FAILED;
    }
    else
        // NOTE: this assumes that all failure paths result in 
        //       pKiller *not* being added to list
        delete pKiller;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\main.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <TChar.h>
#include "ClassFac.h"
#include "ScriptKiller.h"
#include "script.h"
#include "StrSafe.h"

const CLSID CLSID_WbemActiveScriptConsumer = 
    {0x266c72e7,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

class CMyServer : public CComServer
{
public:
#ifdef ENABLE_REMOTING
	void RegisterMe(CLSID clsID, WCHAR* name)
	{    
        WCHAR      wcID[128];
        WCHAR      szKeyName[128];
        HKEY       hKey;

        // open/create registry entry under CLSID
        // not checking return codes of string functions when all sizes are known at compile time
        StringFromGUID2(clsID, wcID, 128);
        StringCchCopyW(szKeyName, 128, TEXT("SOFTWARE\\Classes\\CLSID\\"));
        StringCchCatW(szKeyName, 128, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        
        // set AppID
        RegSetValueEx(hKey, L"AppID", 0, REG_SZ, (BYTE*)wcID, 2*(wcslen(wcID) +1));
        RegCloseKey(hKey);

        // make appID entry w/ DLLSurrogate value
        StringCchCopyW(szKeyName, 128, TEXT("SOFTWARE\\Classes\\APPID\\"));
        StringCchCatW(szKeyName, 128, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);

        // and a nice name
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)name, 2*(wcslen(name) +1));
        RegCloseKey(hKey);
	}


    virtual void Register()
    {
		RegisterMe(CLSID_WbemActiveScriptConsumer, L"Microsoft WBEM Active Scripting Event Consumer Provider");
	}

	void UnregisterMe(CLSID clsID)
	{
		WCHAR      wcID[128];
        HKEY       hKey;

		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\APPID\\"), &hKey))
		{
			if (0 != StringFromGUID2(clsID, wcID, 128))
			{
				RegDeleteKey(hKey, wcID);
			}
			RegCloseKey(hKey);
		}

	}
	
	virtual void Unregister()
	{
        UnregisterMe(CLSID_WbemActiveScriptConsumer);
	}

#endif // ENABLE_REMOTING


protected:
    HRESULT Initialize()
    {
        g_scriptKillerTimer.Initialize(GetLifeControl());

        WMIScriptClassFactory* pFact;
        pFact = new WMIScriptClassFactory(GetLifeControl()); 

        if ( pFact == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        HRESULT hr;
        hr = AddClassInfo( CLSID_WbemActiveScriptConsumer,
                           pFact,
                           _T("Active Scripting Event Consumer Provider"), 
                           TRUE );

        if ( FAILED(hr) )
            return hr;

        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\script.h ===
#ifndef __WBEM_SCRIPT_CONSUMER__H_
#define __WBEM_SCRIPT_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>
#include <activscp.h>
#include <ErrorObj.h>

class CScriptConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CScriptConsumer>
    {
    public:
        XProvider(CScriptConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CScriptConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CScriptConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CScriptConsumer(){}
    void* GetInterface(REFIID riid);
};


class CScriptSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CScriptSink>
    {
    public:
        XSink(CScriptSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CScriptSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    // do the dirty work of making the script go
    HRESULT RunScriptFile(IWbemClassObject *pObj);
    HRESULT RunScriptText(IWbemClassObject *pObj);

    // logical consumer values
    WString m_wsScript;
    WString m_wsScriptFileName;
    PSID  m_pSidCreator;   
    // delay in seconds before killing script.  
    // If zero, script will not be killed; it must suicide.
    DWORD m_dwKillTimeout;

    IClassFactory* m_pEngineFac;

    // scripting DLL
    HMODULE m_hMod;

    WString m_wsErrorMessage;
    WString m_wsErrorLine;

    ErrorObj* m_pErrorObj;


    friend class CScriptSite;
public:
    CScriptSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_pEngineFac(NULL), m_pSidCreator(NULL), m_pErrorObj(NULL)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CScriptSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\script.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemutil.h>
#include <ArrTempl.h>
#include <lmaccess.h>
#include <wbemdisp.h>
#include "ScriptKiller.h"
#include <ErrorObj.h>
#include "script.h"
#include "ClassFac.h"
#include <GroupsForUser.h> 
#include <GenUtils.h>
#include <strsafe.h>

#define SCRIPT_PROPNAME_SCRIPT L"ScriptText"
#define SCRIPT_PROPNAME_FILENAME L"ScriptFilename"
#define SCRIPT_PROPNAME_ENGINE L"ScriptingEngine"
#define SCRIPT_PROPNAME_TIMEOUT L"KillTimeout"

#define SCRIPT_EVENTNAME L"TargetEvent"

// uncomment me to remove the WMI script object
// #define NO_DISP_CLASS

#ifdef HOWARDS_DEBUG_CODE
#define NO_DISP_CLASS
#endif // HOWARDS_DEBUG_CODE

HRESULT STDMETHODCALLTYPE CScriptConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    if (WMIScriptClassFactory::LimitReached())
       return RPC_E_DISCONNECTED;
    
    CScriptSink* pSink = new CScriptSink(m_pObject->m_pControl);
    if (!pSink)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL; 
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}

void* CScriptConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}

class CScriptSite : public IActiveScriptSite, public IActiveScriptSiteWindow
{
protected:
    long m_lRef;

    IDispatch* m_pObject;
    CScriptSink* m_pSink;

    HRESULT m_hr;
public:
    CScriptSite(CScriptSink* pSink, IDispatch* pObject);
    ~CScriptSite();

    HRESULT GetScriptHResult()
    { return m_hr; }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
    virtual HRESULT STDMETHODCALLTYPE GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid);

    virtual HRESULT STDMETHODCALLTYPE GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);

    virtual HRESULT STDMETHODCALLTYPE GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion);

    virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);

    virtual HRESULT STDMETHODCALLTYPE OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState);

    virtual HRESULT STDMETHODCALLTYPE OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);

    virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void);

    virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void);

    virtual HRESULT STDMETHODCALLTYPE GetWindow(
        /* [out] */ HWND __RPC_FAR *phwnd);

    virtual HRESULT STDMETHODCALLTYPE EnableModeless(
        /* [in] */ BOOL fEnable);

};

CScriptSite::CScriptSite(CScriptSink* pSink, IDispatch* pObject) :
    m_lRef(0), m_hr(0)
{
    m_pSink = pSink;
    m_pSink->AddRef();

    m_pObject = pObject;
    if(m_pObject)
        m_pObject->AddRef();
}

CScriptSite::~CScriptSite()
{
    if (m_pObject)
        m_pObject->Release();
    if (m_pSink)
        m_pSink->Release();
}

HRESULT STDMETHODCALLTYPE CScriptSite::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IActiveScriptSite)
        *ppv = (IActiveScriptSite*)this;
    else if(riid == IID_IActiveScriptSiteWindow)
        *ppv = (IActiveScriptSiteWindow*)this;
    else
        return E_NOINTERFACE;
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CScriptSite::AddRef() 
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CScriptSite::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}
        


HRESULT STDMETHODCALLTYPE CScriptSite::GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid)
{ 
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CScriptSite::GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti)
{ 
    if(wbem_wcsicmp(pstrName, SCRIPT_EVENTNAME))
        return TYPE_E_ELEMENTNOTFOUND;
    if(ppti)
        *ppti = NULL;
    if(ppiunkItem)
        *ppiunkItem = NULL;

    if(dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if(ppiunkItem == NULL)
            return E_POINTER;
        m_pObject->QueryInterface(IID_IUnknown, (void**)ppiunkItem);
    }
    
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion)
{ return E_NOTIMPL;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{ 
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror)
{ 
    HRESULT hres;
    EXCEPINFO ei;
    hres = pscripterror->GetExceptionInfo(&ei);
    if(SUCCEEDED(hres))
    {
        if (ei.bstrSource)
        {
            m_pSink->m_wsErrorMessage = ei.bstrSource;
            m_pSink->m_wsErrorMessage += L": ";
        }

        if (ei.bstrDescription)
            m_pSink->m_wsErrorMessage += ei.bstrDescription;
        else
            m_pSink->m_wsErrorMessage += L"unknown";

        if ((ei.wCode != 0) && (ei.wCode >= 1000))
            m_hr = WBEM_E_FAILED;
        else 
            m_hr = ei.scode;
    }
    
    DWORD cookie;
    ULONG lineNo = 0;
    LONG charPos = 0;
    hres = pscripterror->GetSourcePosition(&cookie, &lineNo, &charPos);

    // we will construct an error message of the form:
    // filename.vbs (3,15)
    if(SUCCEEDED(hres))
    {
        if (m_pSink->m_wsScriptFileName.Length() > 0)
            m_pSink->m_wsErrorLine = m_pSink->m_wsScriptFileName;
        else
            m_pSink->m_wsErrorLine = SCRIPT_PROPNAME_SCRIPT;

        // if the sprintf fails for some reason, no problem we concat a null sting.
        WCHAR buf[256] = L"\0";
        // experimentation shows that the line/pos appear to be zero based: add one.
        // swprintf(buf, L" (%u,%d)", lineNo +1, charPos +1);
        StringCchPrintfW(buf, 256, L" (%u,%d)", lineNo +1, charPos +1);
        m_pSink->m_wsErrorLine += buf;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::OnEnterScript( void)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnLeaveScript( void)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::GetWindow(
    /* [out] */ HWND __RPC_FAR *phwnd)
{
    *phwnd = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::EnableModeless(
    /* [in] */ BOOL fEnable)
{return S_OK;}


CScriptSink::~CScriptSink()
{
    if(m_pEngineFac)
        m_pEngineFac->Release();
    if (m_pErrorObj)
        m_pErrorObj->Release();

}

HRESULT CScriptSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    VARIANT v;
    VariantInit(&v);

    // this is actually a pointer to a static object
    // if it fails, something is Very, Very Wrong.
    m_pErrorObj = ErrorObj::GetErrorObj();
    if (!m_pErrorObj)
        return WBEM_E_CRITICAL_ERROR;
    
    BSTR propName;
    propName = SysAllocString(L"CreatorSID");
    if (!propName)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe freeName(propName);

    if (SUCCEEDED(pLogicalConsumer->Get(propName, 0, &v, NULL, NULL)))
    {
        HRESULT hDebug;
        long ubound;
        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

        PVOID pVoid;
        hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

        if(SUCCEEDED(hDebug))
        {
            m_pSidCreator = new BYTE[ubound +1];
            if (m_pSidCreator)
                memcpy(m_pSidCreator, pVoid, ubound + 1);
            else
            {
                SafeArrayUnaccessData(V_ARRAY(&v));
                return WBEM_E_OUT_OF_MEMORY;
            }

            SafeArrayUnaccessData(V_ARRAY(&v));
        }
    }
    else
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
    
    
    // Get the information
    // ===================

    HRESULT hres;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_ENGINE, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        m_pErrorObj->ReportError(SCRIPT_PROPNAME_ENGINE, NULL, NULL, WBEM_E_INVALID_PARAMETER, true);  
        return WBEM_E_INVALID_PARAMETER;
    }
    WString wsEngine = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_TIMEOUT, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_I4)
        m_dwKillTimeout = V_I4(&v);
    else
        m_dwKillTimeout = 0;
    VariantClear(&v);

    hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_SCRIPT, 0, &v, NULL, NULL);
    if (SUCCEEDED(hres))
    {
        if (V_VT(&v) == VT_BSTR)
        {
            m_wsScript = V_BSTR(&v);
            VariantClear(&v);
        }
        else
        // try the script file name approach
        {
            hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_FILENAME, 0, &v, NULL, NULL);
            if (SUCCEEDED(hres) && (V_VT(&v) == VT_BSTR))
            {
                m_wsScriptFileName = V_BSTR(&v);
                VariantClear(&v);
            }
            else
            {
                m_pErrorObj->ReportError(L"Initialize", L"ScriptText, ScriptFilename", NULL, WBEM_E_ILLEGAL_NULL, true);
                return WBEM_E_INVALID_PARAMETER;
            }
        }                                                        
    }
    else 
        return WBEM_E_INVALID_PARAMETER;


    // Get the CLSID
    // =============
    CLSID clsid;
    if (wsEngine.Length() == 0)
        hres = WBEM_E_INVALID_PARAMETER;
    else
        hres = CLSIDFromProgID((LPCWSTR)wsEngine, &clsid);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Scripting engine '%S' not found: %X\n",
            (LPCWSTR)wsEngine, hres));
        m_pErrorObj->ReportError(L"Initialize", (WCHAR *)wsEngine, NULL, hres, true);
        return hres;
    }

    hres = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                NULL, IID_IClassFactory, (void**)&m_pEngineFac);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create scripting engine %S: %X\n",
            (LPCWSTR)wsEngine, hres));
         m_pErrorObj->ReportError(L"Initialize", (WCHAR*)wsEngine, NULL, hres, true);
        return hres;
    }

    return S_OK;
}

// runs the script contained in the script text
HRESULT CScriptSink::RunScriptText(IWbemClassObject *pObj)
{
    HRESULT hres = S_OK;


    WMIScriptClassFactory::IncrementScriptsRun();
    
    IActiveScript* pScript;
    hres = m_pEngineFac->CreateInstance(NULL, IID_IActiveScript,
            (void**)&pScript);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create a script. Error code %X\n", 
            hres));
        return hres;
    }

    IActiveScriptParse* pParse;
    hres = pScript->QueryInterface(IID_IActiveScriptParse, (void**)&pParse);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Scripting engine does not support "
            "parsing!\n"));
        pScript->Release();
        return hres;
    }

    IDispatch* pDObject;
#ifdef NO_DISP_CLASS
    pDObject = NULL;
#else
	IBindCtx *pbc = NULL;; 
	IMoniker *pMk = NULL;
	ULONG chEaten = 0; 
	
	if(FAILED(hres = CreateBindCtx(0, &pbc)))
	{
        ERRORTRACE((LOG_ESS, "Unable to Create IBindCtx: 0x%X\n", hres));
        pScript->Release();
        return hres;
    }

	if(FAILED(hres = pbc->RegisterObjectParam(L"WmiObject", pObj)))
	{
		ERRORTRACE((LOG_ESS, "Unable to Register IBindCtx: 0x%X\n", hres));
		pScript->Release();
		return hres;
	}

	if(FAILED(hres = MkParseDisplayName(pbc, L"winmgmts:", &chEaten, &pMk)))
	{
		ERRORTRACE((LOG_ESS, "Unable to MkParseDisplayName: 0x%X\n", hres));
		pScript->Release();
		return hres;
	}

	if(FAILED(hres = pMk->BindToObject(pbc, 0, IID_ISWbemObject, (void **)&pDObject)))
	{
		ERRORTRACE((LOG_ESS, "Unable to BindToObject: 0x%X\n", hres));
		pScript->Release();
		return hres;
	}

	pMk->Release();
	pbc->Release();
	
#endif

    CScriptSite* pSite = new CScriptSite(this, pDObject);
    pSite->AddRef();

#ifndef NO_DISP_CLASS
	if(pDObject) pDObject->Release();
#endif

    hres = pScript->SetScriptSite(pSite);

    hres = pParse->InitNew();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to initialize script(InitNew): %X\n", 
            hres));
        pSite->Release();
        pScript->Release();
        pParse->Release();
        return hres;
    }

#ifndef NO_DISP_CLASS
    hres = pScript->AddNamedItem(SCRIPT_EVENTNAME, 
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to add named item: %X\n", hres));
        pSite->Release();
        pScript->Release();
        pParse->Release();
        return hres;
    }
#endif

    EXCEPINFO ei;
    hres = pParse->ParseScriptText(
        (LPCWSTR)m_wsScript,
        NULL, NULL, NULL, 
        0, 0, 0, NULL, &ei);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to parse script. Error code %X\n"
            "Scripting engine says: %S\n", hres, 
            (LPCWSTR)m_wsErrorMessage));
        m_pErrorObj->ReportError(L"ParseScriptText", m_wsErrorLine, m_wsErrorMessage, hres, true);
        pSite->Release();
        pScript->Release();
        pParse->Release();
        return hres;
    }
    pParse->Release();


    if (m_dwKillTimeout)
    {           
        FILETIME now;
        GetSystemTimeAsFileTime(&now);        
        WAYCOOL_FILETIME expires(now);
        expires.AddSeconds(m_dwKillTimeout);

        SCRIPTTHREADID threadID;
        hres = pScript->GetScriptThreadID(GetCurrentThreadId(), &threadID);
        if (SUCCEEDED(hres))
            g_scriptKillerTimer.ScheduleAssassination(pScript, expires, threadID);

        /************
        Doing it in the stream.  Probably don't need to.
        LPSTREAM pStream;
        if (SUCCEEDED(hres) && 
            SUCCEEDED(CoMarshalInterThreadInterfaceInStream(IID_IActiveScript, pScript, &pStream)))
        {
            g_scriptKillerTimer.ScheduleAssassination(pStream, expires, threadID);
        }
        ***************/
    }
    
    hres = pScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to execute script. Error code 0x%X\n"
            "Scripting engine says: %S\n", hres, 
            (LPCWSTR)m_wsErrorMessage));

        m_pErrorObj->ReportError(L"SetScriptState(SCRIPTSTATE_CONNECTED)", m_wsErrorLine, m_wsErrorMessage, hres, true);
    }
    else if (FAILED(pSite->GetScriptHResult()))
    {
        hres = pSite->GetScriptHResult();
        ERRORTRACE((LOG_ESS, "Error in script execution. Error code 0x%X\n"
            "Scripting engine says: %S\n", hres, 
            (LPCWSTR)m_wsErrorMessage));
        
        m_pErrorObj->ReportError(L"SetScriptState(SCRIPTSTATE_CONNECTED)", m_wsErrorLine, m_wsErrorMessage, hres, true);

    }
        
    pScript->Close();

    pScript->Release();
    pSite->Release();

    return hres;
}

HRESULT CScriptSink::RunScriptFile(IWbemClassObject *pObj)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    if (m_wsScriptFileName.Length())
    {
        HANDLE hFile = CreateFileW((LPWSTR)m_wsScriptFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD fSize;
            if (0xFFFFFFFF != (fSize = GetFileSize(hFile, &fSize)))
            {
                char* pBuf = new char[fSize +2];             
                if (!pBuf)
                    hr = WBEM_E_OUT_OF_MEMORY;
                else
                {                  
                    ZeroMemory(pBuf, fSize+2);
                    DWORD bitsRead;

                    if (ReadFile(hFile, pBuf, fSize, &bitsRead, NULL))
                    {
                        hr = WBEM_S_NO_ERROR;

                        const WCHAR ByteOrderMark = L'\xFEFF';
                        // determine whether this is a unicode file
                        if (((WCHAR*)pBuf)[0] == ByteOrderMark)                        
                            m_wsScript.BindPtr((WCHAR*)pBuf);
                        else
                        {
                            int length = strlen(pBuf) +1;

                            // not unicode, do the conversion
                            WCHAR* pWideBuf = new WCHAR[length];
                            if (!pWideBuf)
                                hr = WBEM_E_OUT_OF_MEMORY;
                            else
                            {
                                if (!MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED, pBuf, length, pWideBuf, length))
                                {
                                    ERRORTRACE((LOG_ESS, "Script: cannot convert %s, 0x%08X\n", pBuf, GetLastError()));
                                    hr = WBEM_E_FAILED;
                                }
                                else
                                    m_wsScript.BindPtr(pWideBuf);
                            }

                            // delete the old buffer - we saved a copy
                            delete[] pBuf;
                        }
                        
                        if (SUCCEEDED(hr))
                            hr = RunScriptText(pObj);
                    }                       
                    else
                    {
                        ERRORTRACE((LOG_ESS, "Script: Cannot read %S, 0x%X\n", (LPWSTR)m_wsScriptFileName, GetLastError()));
                        delete[] pBuf;
                        hr = WBEM_E_FAILED;
                    }

                }                                
            }

            CloseHandle(hFile);
        }
        else
            ERRORTRACE((LOG_ESS, "Script: Cannot Open %S, 0x%X\n", (LPWSTR)m_wsScriptFileName, GetLastError()));
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CScriptSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    
    PSID pSidSystem;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if  (AllocateAndInitializeSid(&id, 1,
        SECURITY_LOCAL_SYSTEM_RID, 
        0, 0,0,0,0,0,0,&pSidSystem))
    {         
        // guilty until proven innocent
        HRESULT hr = WBEM_E_ACCESS_DENIED;

        // check to see if sid is either Local System or an admin of some sort...
        if ((EqualSid(pSidSystem, m_pObject->m_pSidCreator)) ||
            (S_OK == IsUserAdministrator(m_pObject->m_pSidCreator)))
            hr = WBEM_S_NO_ERROR;
      
        // We're done with this
        FreeSid(pSidSystem);

        if (FAILED(hr))
            return hr;
    }
    else
        return WBEM_E_OUT_OF_MEMORY;

    if (WMIScriptClassFactory::LimitReached())
        return RPC_E_DISCONNECTED;
    
    HRESULT hrOutter = WBEM_S_NO_ERROR;

    for(int i = 0; i < lNumObjects; i++)
    {
        HRESULT hrInner;
        
        if (m_pObject->m_wsScript.Length())
            hrInner = m_pObject->RunScriptText(apObjects[i]);
        else if (m_pObject->m_wsScriptFileName.Length())
            hrInner = m_pObject->RunScriptFile(apObjects[i]);            
		else
        {
            m_pObject->m_pErrorObj->ReportError(L"IndicateToConsumer", L"ScriptText, ScriptFilename", NULL, WBEM_E_ILLEGAL_NULL, true);
            return WBEM_E_INVALID_PARAMETER;
        }

        if (FAILED(hrInner))
        {
            
            m_pObject->m_pErrorObj->ReportError(L"IndicateToConsumer", m_pObject->m_wsErrorLine, m_pObject->m_wsErrorMessage, hrInner, true);
            hrOutter = hrInner;
            // m_pObject->RaiseErrorStatus();
        }
    }

    return hrOutter;
}    

void* CScriptSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\classfac.h ===
#ifndef _WMISCRIPT_CLASSFAC_HEADER_
#define _WMISCRIPT_CLASSFAC_HEADER_

#include <clsfac.h>
#include <Script.h>

class WMIScriptClassFactory : public CClassFactory<CScriptConsumer>
{
public:
    WMIScriptClassFactory(CLifeControl* pControl = NULL) : 
        CClassFactory<CScriptConsumer>(pControl)
        {}

    HRESULT CreateInstance(IUnknown* pOuter, REFIID riid, void** ppv);

    static void FindScriptsAllowed(void);
    static void IncrementScriptsRun(void);
    static bool LimitReached(void);

    static void CALLBACK TimeoutProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

protected:
    // statics to control how many scripts we're allowed to run
    // note that we don't bother wrapping these in critical sections
    // The worst that can happen is that we initialize m_scriptsAllowed twice
    // or that we run one too many scripts.  I can live with that.

    // number of scripts we've been asked to run
    static DWORD m_scriptsStarted;

    // number of scripts we've been configured to run
    static DWORD m_scriptsAllowed;

    // whether we've gone & looked at how many we need
    static bool m_bIsScriptsAllowedInitialized;

    // id for the timer, only valid if we've been asked to time out
    static DWORD m_timerID;

    // toggled when we reach our timeout limit or max # scripts
    static bool m_bWeDeadNow;
};

#endif // _WMISCRIPT_CLASSFAC_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\scriptkiller.cpp ===
#include "precomp.h"
#include "ScriptKiller.h"

// the only one we'll ever need
CScriptKillerTimer g_scriptKillerTimer;

// last meal is the scheduled execution date
HRESULT CScriptKillerTimer::ScheduleAssassination(IActiveScript* pScript, FILETIME lastMeal, SCRIPTTHREADID threadID)
{
    HRESULT hr = WBEM_E_FAILED;

    CScriptKiller* pKiller;

    if (pKiller = new CScriptKiller(pScript, lastMeal, threadID, m_pControl))
        hr = CKillerTimer::ScheduleAssassination(pKiller);
    else
        // allocation failed
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

// terminate script
void CScriptKiller::Die()
{
    if (m_pScript)
    {
        EXCEPINFO info;    
        ZeroMemory(&info, sizeof(EXCEPINFO));
        HRESULT hr;

        // regardless of what the dox say, KB article Q182946 says to pass NULL for the second parm.  Really.
        // experimentation shows that zero-ing out the info struct works, too.
        //hr = pScript->InterruptScriptThread(m_threadID, &info, 0);
        hr = m_pScript->SetScriptState(SCRIPTSTATE_DISCONNECTED);
        hr = m_pScript->InterruptScriptThread(SCRIPTTHREADID_ALL, &info, 0);
    }

    /***********************
    stream method
    if (m_pStream)
    {
        EXCEPINFO info;    
        ZeroMemory(&info, sizeof(EXCEPINFO));
        
        IActiveScript* pScript;
        HRESULT hr = CoGetInterfaceAndReleaseStream(m_pStream, IID_IActiveScript, (LPVOID *) &pScript);
        m_pStream = NULL;
    
        // regardless of what the dox say, KB article Q182946 says to pass NULL for the second parm.  Really.
        // experimentation shows that zero-ing out the info struct works, too.
        //hr = pScript->InterruptScriptThread(m_threadID, &info, 0);
        hr = pScript->InterruptScriptThread(SCRIPTTHREADID_ALL, &info, 0);
        hr = pScript->SetScriptState(SCRIPTSTATE_DISCONNECTED);
    
        pScript->Release();    
    }
    *****************************/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\main.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include "smtp.h"
#include <TCHAR.h>
#include <strsafe.h>

// {C7A3A54B-0250-11D3-9CD1-00105A1F4801}
const CLSID CLSID_WbemSMTPConsumer = 
{ 0xc7a3a54b, 0x250, 0x11d3, { 0x9c, 0xd1, 0x0, 0x10, 0x5a, 0x1f, 0x48, 0x1 } };


class CMyServer : public CComServer
{
public:
#ifdef ENABLE_REMOTING
	void RegisterMe(CLSID clsID, WCHAR* name)
	{    
        WCHAR      wcID[128];
        WCHAR      szKeyName[128];
        HKEY       hKey;

        // open/create registry entry under CLSID
        // not checking returns from string functions - all sizes a known ahead of time
        StringFromGUID2(clsID, wcID, 128);
        StringCchCopyW(szKeyName, 128, TEXT("SOFTWARE\\Classes\\CLSID\\"));
        StringCchCatW(szKeyName, 128, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        
        // set AppID
        RegSetValueEx(hKey, L"AppID", 0, REG_SZ, (BYTE*)wcID, 2*(wcslen(wcID) +1));
        RegCloseKey(hKey);

        // make appID entry w/ DLLSurrogate value
        StringCchCopyW(szKeyName, 128, TEXT("SOFTWARE\\Classes\\APPID\\"));
        StringCchCatW(szKeyName, 128, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        RegSetValueEx(hKey, L"DllSurrogate", 0, REG_SZ, (BYTE*)L"\0", 2);

        // and a nice name
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)name, 2*(wcslen(name) +1));
        RegCloseKey(hKey);
	}

	// provider server specific registration
	virtual void Register()
	{
		RegisterMe(CLSID_WbemSMTPConsumer, L"Microsoft WBEM SMTP Event Consumer Provider");
	}

	void UnregisterMe(CLSID clsID)
	{
		WCHAR      wcID[128];
        HKEY       hKey;

		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\APPID\\"), &hKey))
		{
			if (0 != StringFromGUID2(clsID, wcID, 128))
			{
				RegDeleteKey(hKey, wcID);
			}
			RegCloseKey(hKey);
		}

	}
	
	virtual void Unregister()
	{
		UnregisterMe(CLSID_WbemSMTPConsumer);
	}
#endif

protected:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemSMTPConsumer,
            new CClassFactory<CSMTPConsumer>(GetLifeControl()), 
            _T("SMTP Event Consumer Provider"), TRUE);

        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\scriptkiller.h ===
#ifndef __SCRIPT_KILLER_COMPILED__
#define __SCRIPT_KILLER_COMPILED__

#include <activscp.h>
#include "KillTimer.h"

// only need one of these laying around
class CScriptKillerTimer;
extern CScriptKillerTimer g_scriptKillerTimer;

// specialized to kill scripts
class CScriptKillerTimer : public CKillerTimer
{
public:
    
    // who to kill & when
    HRESULT ScheduleAssassination(IActiveScript* pScript, FILETIME lastMeal, SCRIPTTHREADID threadID);            
    // HRESULT ScheduleAssassination(LPSTREAM pStream, FILETIME lastMeal, SCRIPTTHREADID threadID);            
};

/* CLASS CScriptKiller DEFINITION */

// hold script that needs to be killed
class CScriptKiller : public CKiller
{
public:
    CScriptKiller(IActiveScript* pScript, FILETIME deathDate, SCRIPTTHREADID threadID, CLifeControl* pControl) :
      CKiller(deathDate, pControl), m_pScript(pScript) /*m_pStream(pStream)*/, m_threadID(threadID)
    {
        m_pScript->AddRef();
    }

    virtual ~CScriptKiller()
    {
        m_pScript->Release();
    }

    // terminate process, 
    virtual void Die();

protected:

private:
    IActiveScript* m_pScript;
    // LPSTREAM m_pStream;

    SCRIPTTHREADID m_threadID;
};

#endif //__SCRIPT_KILLER_COMPILED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\smtp.h ===
#ifndef __WBEM_SMTP_CONSUMER__H_
#define __WBEM_SMTP_CONSUMER__H_

#include <unk.h>


#include <wbemidl.h>
#include <errorObj.h>

#include "txttempl.h"

class CSMTPConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CSMTPConsumer>
    {
    public:
        XProvider(CSMTPConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CSMTPConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CSMTPConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
    ~CSMTPConsumer();
    void* GetInterface(REFIID riid);
};


class CSMTPSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CSMTPSink>
    {
    public:
        XSink(CSMTPSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CSMTPSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

	char* PreProcessLine(WCHAR* line, bool bStripWhitespace, bool bHammerSemiColons);

protected:
    CTextTemplate m_SubjectTemplate;
    CTextTemplate m_MessageTemplate;

    CTextTemplate  m_To;
    CTextTemplate  m_Cc;
    CTextTemplate  m_Bcc;

    CTextTemplate  m_From;
    WString        m_wsFakeFromLine;
    CTextTemplate  m_ReplyTo;
    WString m_wsServer;
    WString m_wsHeaders;

    ErrorObj* m_pErrorObj;


    bool m_bSMTPInitialized;
    bool m_bFakeFromLine; // true if the from line was generated from the computer name.

public:
    CSMTPSink(CLifeControl* pControl = NULL);
    ~CSMTPSink();

    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\smtp.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <initguid.h>
#include <wbemutil.h>
#include <cominit.h>
#include <ArrTempl.h>
#include <wbemidl.h>
#include <errorObj.h>
#include "smtp.h"

#define SMTP_PROPNAME_TO       L"ToLine"
#define SMTP_PROPNAME_CC       L"CcLine"
#define SMTP_PROPNAME_BCC      L"BccLine"
#define SMTP_PROPNAME_SUBJECT  L"Subject"
#define SMTP_PROPNAME_MESSAGE  L"Message"
#define SMTP_PROPNAME_SERVER   L"SMTPServer"
#define SMTP_PROPNAME_REPLYTO  L"ReplyToLine"
#define SMTP_PROPNAME_FROM     L"FromLine"
#define SMTP_PROPNAME_HEADERS  L"HeaderFields"

DWORD SMTPSend(char* szServer, char* szTo, char* szCc, char* szBcc, char* szFrom, char* szSender, 
			   char* szReplyTo, char* szSubject, char* szHeaders, char *szText);

CSMTPConsumer::CSMTPConsumer(CLifeControl* pControl, IUnknown* pOuter)
        : CUnk(pControl, pOuter), m_XProvider(this)
{
}

CSMTPConsumer::~CSMTPConsumer()
{
}

// copies gazinta inta gazotta, excluding white space
// no checking - better be good little pointers
void StripWhitespace(const WCHAR* pGazinta, WCHAR* pGazotta)
{
    WCHAR* pSource = (WCHAR*)pGazinta;
    WCHAR* pDest   = pGazotta;

    do 
        if (!iswspace(*pSource))
            *pDest++ = *pSource;    
    while (*pSource++);
}

HRESULT STDMETHODCALLTYPE CSMTPConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CSMTPSink* pSink = new CSMTPSink(m_pObject->m_pControl);
    if (!pSink)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        return hres;
    }
    return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                    (void**)ppConsumer);
}

void* CSMTPConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else
        return NULL;
}




CSMTPSink::CSMTPSink(CLifeControl* pControl)
    : CUnk(pControl), m_XSink(this), m_bSMTPInitialized(false), m_bFakeFromLine(false), m_pErrorObj(NULL)
{
}

HRESULT CSMTPSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    // this is actually a pointer to a static object
    // if it fails, something is Very, Very Wrong.
    m_pErrorObj = ErrorObj::GetErrorObj();
    if (!m_pErrorObj)
        return WBEM_E_CRITICAL_ERROR;


    WSADATA            WsaData; 
    int error = WSAStartup (0x101, &WsaData); 
    if (error)
    {
        ERRORTRACE((LOG_ESS, "Unable to initialize WinSock dll: %X\n", error));
        return WBEM_E_FAILED;
    }
    else
        m_bSMTPInitialized = true;

    // Retrieve information from the logical consumer instance
    // =======================================================

    VARIANT v;
    VariantInit(&v);

    // Get subject
    // ===========

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_SUBJECT, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_SubjectTemplate.SetTemplate(V_BSTR(&v));
    else
        m_SubjectTemplate.SetTemplate(L"");
    VariantClear(&v);

    // Get message
    // ===========

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_MESSAGE, 0, &v, NULL, NULL);

    if(V_VT(&v) == VT_BSTR)
        m_MessageTemplate.SetTemplate(V_BSTR(&v));
    else
        m_MessageTemplate.SetTemplate(L"");
    VariantClear(&v);

    // flag for 'do we have any recipients at all?'
    bool bOneAddressee = false;

    // Get the To line
    // ===============
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_TO, 0, &v, NULL, NULL);
    if ((V_VT(&v) == VT_BSTR) && (v.bstrVal != NULL))
    {
		m_To.SetTemplate(V_BSTR(&v));
        if (wcslen(V_BSTR(&v)) > 0)
            bOneAddressee = true;
    }
    else
        m_To.SetTemplate(L"");
	VariantClear(&v);

    // Create the fake from line for various uses
    // ==========================================

    m_wsFakeFromLine = L"WMI@";
    pLogicalConsumer->Get(L"__SERVER", 0, &v, NULL, NULL);
    m_wsFakeFromLine += V_BSTR(&v);

	VariantClear(&v);

    // Get the From line
    // =================
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_FROM, 0, &v, NULL, NULL);
    if (SUCCEEDED(hres) && (V_VT(&v) == VT_BSTR))
		m_From.SetTemplate(V_BSTR(&v));
    else
    {
        m_From.SetTemplate(m_wsFakeFromLine);

        m_bFakeFromLine = true;
    }
    VariantClear(&v);

    // Get the ReplyTo line
    // =====================
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_REPLYTO, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
		m_ReplyTo.SetTemplate(V_BSTR(&v));
    else
        m_ReplyTo.SetTemplate(L"");

    VariantClear(&v);

    // Get the CC line
    // ===============
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_CC, 0, &v, NULL, NULL);
    if ((V_VT(&v) == VT_BSTR) && (v.bstrVal != NULL))
    {
        m_Cc.SetTemplate( V_BSTR(&v));
        if (wcslen(V_BSTR(&v)) > 0)
            bOneAddressee = true;
    }
	else
		m_Cc.SetTemplate(L"");

    VariantClear(&v);

    // Get the BCC line
    // ===============

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_BCC, 0, &v, NULL, NULL);
    if  ((V_VT(&v) == VT_BSTR) && (v.bstrVal != NULL))
    {
        m_Bcc.SetTemplate(V_BSTR(&v));
	    if (wcslen(V_BSTR(&v)) > 0)
            bOneAddressee = true;
    }
    else
		m_Bcc.SetTemplate(L"");
    VariantClear(&v);

    // okay, at least ONE should be filled in...
    if (!bOneAddressee)
    {
        ERRORTRACE((LOG_ESS, "SMTP: No addressees found, no mail delivered\n"));
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get the server
    // ===============

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_SERVER, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_wsServer = V_BSTR(&v);
    VariantClear(&v);


    // and any extra header fields
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_HEADERS, 0, &v, NULL, NULL);
    if ((V_VT(&v) & VT_BSTR) && (V_VT(&v) & VT_ARRAY))
    {
        long lBound;

        SafeArrayGetUBound(v.parray, 1, &lBound);
        for (long i = 0; i <= lBound; i++)
        {
            BSTR pStr = NULL;
            if ( SUCCEEDED(SafeArrayGetElement(v.parray, &i, &pStr)) )
            {
                if ( pStr != NULL )
                {
                    m_wsHeaders += pStr;
                    SysFreeString( pStr );
                }
            }
            else
            {
                VariantClear(&v);
                return WBEM_E_OUT_OF_MEMORY;
            }

            if (i != lBound)
                m_wsHeaders += L"\r\n";
        }
    }
	VariantClear(&v);


    return WBEM_S_NO_ERROR;
}


CSMTPSink::~CSMTPSink()
{
    if (m_bSMTPInitialized)
	{		
		if (SOCKET_ERROR == WSACleanup())
			ERRORTRACE((LOG_ESS, "WSACleanup failed, 0x%X\n", WSAGetLastError()));
	}
    if (m_pErrorObj)
        m_pErrorObj->Release();
}

// allocates buffer, strips whitespace if asked
// scrunches wide string down to MBCS
// callers responsibility to delete	return pointer
// returns NULL on allocation failure
// if bHammerSemiColons, the semi colons shall be replaced by commas
char* CSMTPSink::PreProcessLine(WCHAR* line, bool bStripWhitespace, bool bHammerSemiColons)
{
	char *pNewLine = NULL;
	WCHAR *pSource = NULL;
	WCHAR *pStripBuf = NULL;

    if (line == NULL)
        return NULL;

	if (bStripWhitespace && (pStripBuf = new WCHAR[wcslen(line) +1]))
	{
		StripWhitespace(line, pStripBuf);
		pSource = pStripBuf;
	}
	else
		pSource = line;
							 
	if (pSource && (pNewLine = new char[2*wcslen(pSource) +1]))
	{
		sprintf(pNewLine, "%S", pSource);		
		if (bHammerSemiColons)
		{
			char* pSemiColon;
			while (pSemiColon = strchr(pNewLine, ';'))
				*pSemiColon = ',';
		}
	}

	if (pStripBuf)
		delete[] pStripBuf;


	return pNewLine;
}

HRESULT STDMETHODCALLTYPE CSMTPSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
	// HRESULT hres;
    for(long i = 0; i < lNumObjects; i++)
    {

		// TODO: Lots of duplicated code, here - fix.
        // VARIANT v;

        BSTR str;

        // Obtain customized versions of the subject and the message
        // stripping white space as we go...
        // =========================================================

		// TO
		str = m_pObject->m_To.Apply(apObjects[i]);
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
	    char* szTo;
		szTo = m_pObject->PreProcessLine(str, true, true);
        SysFreeString(str);
		if (!szTo)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delTo(szTo);
        
		// CC
		char* szCc;
		str = m_pObject->m_Cc.Apply(apObjects[i]);        
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szCc = m_pObject->PreProcessLine(str, true, true);
		SysFreeString(str);
		if (!szCc)
			return WBEM_E_OUT_OF_MEMORY;	
		CDeleteMe<char> delCc(szCc);

		// BCC
		char* szBcc;
		str = m_pObject->m_Bcc.Apply(apObjects[i]);  
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szBcc = m_pObject->PreProcessLine(str, true, true);
        SysFreeString(str);
		if (!szBcc)
			return WBEM_E_OUT_OF_MEMORY;		
		CDeleteMe<char> delBcc(szBcc);

		// FROM
        char* szFrom;
        str = m_pObject->m_From.Apply(apObjects[i]);
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szFrom = m_pObject->PreProcessLine(str, false, false);
        SysFreeString(str);
		if (!szFrom)
			return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delFrom(szFrom);

        //SENDER
        char* szSender;
        szSender = m_pObject->PreProcessLine(m_pObject->m_wsFakeFromLine, false, false);
        if (!szSender)
            return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delSender(szSender);

        // Reply To
        char* szReplyTo;
        str = m_pObject->m_ReplyTo.Apply(apObjects[i]);
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szReplyTo = m_pObject->PreProcessLine(str, true, true);
        SysFreeString(str);
		if (!szReplyTo)
			return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delReplyTo(szReplyTo);
        
        // SERVER
		char* szServer;
        szServer = m_pObject->PreProcessLine(m_pObject->m_wsServer, false, false);
        if (!szServer)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delServer(szServer);

		// SUBJECT
        str = m_pObject->m_SubjectTemplate.Apply(apObjects[i]);
        char* szSubject;
		szSubject = m_pObject->PreProcessLine(str, false, false);
		SysFreeString(str);
        if (!szSubject)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delSubject(szSubject);

		// MESSAGE TEXT
        str = m_pObject->m_MessageTemplate.Apply(apObjects[i]);
        char* szText;
		szText = m_pObject->PreProcessLine(str, false, false);
        SysFreeString(str);
		if (!szText)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delText(szText);

        // extra added header entries
        char* szHeaders;
        szHeaders = m_pObject->PreProcessLine(m_pObject->m_wsHeaders, false, false);
        if (!szHeaders)
            return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delHeaders(szHeaders);

		// djinn up a reply-to line
        // if we haven't been given one explicitly AND we haven't faked one up, 
        // we'll use the from line.
        char* szReplyToReally;
        if ((strlen(szReplyTo) == 0) && !m_pObject->m_bFakeFromLine)
            szReplyToReally = szFrom;
        else
            szReplyToReally = szReplyTo;

        // DO IT TO IT        
        DWORD dwRes = SMTPSend(szServer, szTo, szCc, szBcc, szFrom, szSender, szReplyToReally, szSubject, szHeaders, szText);
        if(dwRes)
        {
            ERRORTRACE((LOG_ESS, "Unable to send message: 0x%X\n", dwRes));
            return WBEM_E_FAILED;
        }
    }

    return WBEM_S_NO_ERROR;
}

void* CSMTPSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\cmdline.h ===
#ifndef __WBEM_CMDLINE_CONSUMER__H_
#define __WBEM_CMDLINE_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>

class CCommandLineConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, 
                                        CCommandLineConsumer>
    {
    public:
        XProvider(CCommandLineConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CCommandLineConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CCommandLineConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CCommandLineConsumer(){}
    void* GetInterface(REFIID riid);
};


class CCommandLineSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CCommandLineSink>
    {
    public:
        XSink(CCommandLineSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CCommandLineSink>(pObj){}

        HRESULT STDMETHODCALLTYPE CreateProcessNT(WCHAR* wsCommandLine, WCHAR* wsTitle, PROCESS_INFORMATION& pi, FILETIME& now);

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    WString m_wsExecutable;
    CTextTemplate m_CommandLine;
    CTextTemplate m_title;
    DWORD m_dwCreationFlags;
    WString m_wsWorkingDirectory;
    WString m_wsDesktop;
    // WString m_wsTitle;
    DWORD m_dwX;
    DWORD m_dwY;
    DWORD m_dwXSize;
    DWORD m_dwYSize;
    DWORD m_dwXNumCharacters;
    DWORD m_dwYNumCharacters;
    DWORD m_dwFillAttribute;
    DWORD m_dwStartFlags;
    DWORD m_dwShowWindow;
    BOOL  m_bInteractive;
    DWORD m_dwKillTimeout; // how long to wait before killing process, zero is infinite
    PSID  m_pSidCreator;   

    ErrorObj* m_pErrorObj;


    HRESULT FindInteractiveInfo();
public:
    WString m_wsWindowStation;

public:

    CCommandLineSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_pSidCreator(NULL), m_pErrorObj(NULL)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    ~CCommandLineSink()
    { 
        delete m_pSidCreator; 
        if (m_pErrorObj)
            m_pErrorObj->Release();
    }

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\smtphelp.cpp ===
// based on SMTP spec RFC 821
 
#include "precomp.h" 
 
#include <stdio.h> 
#include <stdarg.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h> 
#include <io.h> 
#include <fcntl.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <wbemutil.h>
#include <ArrTempl.h>
#include <ErrorObj.h>
#include <strsafe.h>

#define SMTP_PORT 25
#define MAX_SMTP_BUFFER		0x4000		// 16K
#define MAX_SUBJECT_LINE	2048		// leave room for the encoding
#define MAX_USER_NAME		512
#define MAX_EXTRA_HEADER	1024

#define SMTP_OKAY           250         // doc'd as 'Requested mail action okay, completed'                           
#define INTERNAL_ERROR      554         // sorta fit in with the SMTP error codes
                                        // doc'd as 'Transaction Failed' by the SMTP spec    

#define HH_MAX_COMPUTERNAME_LENGTH 256 // because the system defined MAX_COMPUTERNAME_LENGTH isn't

#define ERROR_MESSAGE_SIZE 256


// returns true if dwRet is an SMTP error
bool IsSMTPError(DWORD dwRet)
{
    return (dwRet >= 400);
}
    
 
// Helper functions 
 
void SkipWhite(PSTR *ppS ) 
{ 
    PSTR pS = *ppS; 
 
    while ( *pS && isspace(*pS) ) 
        ++pS; 
 
    *ppS = pS; 
} 
 
 
void SkipNonWhite(PSTR *ppS ) 
{ 
    PSTR pS = *ppS; 
 
    while ( *pS && !isspace(*pS) ) 
        ++pS; 
 
    *ppS = pS; 
} 
 

// returns numeric reply code
// in general, anything >= 400 is bad.
// copies & converts reply message to messageBuf
int SMTPReceive(int Socket, WCHAR* messageBuf)
{
    int nCode;
    
	char *szBuffer = new char[MAX_SMTP_BUFFER];
	if (szBuffer == NULL)
		return INTERNAL_ERROR;
    szBuffer[0] = '\0';

    int nLen = recv( Socket, szBuffer, MAX_SMTP_BUFFER, 0);          
    if (nLen == SOCKET_ERROR)
    {
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "SMTPReceive failed: %d\n", err));
        nCode = INTERNAL_ERROR;

    }	
    else
    {
	    szBuffer[nLen]=0;	    
        if (1 != sscanf(szBuffer, " %d", &nCode))
			nCode = INTERNAL_ERROR;
        mbstowcs(messageBuf, szBuffer, ERROR_MESSAGE_SIZE);
        messageBuf[ERROR_MESSAGE_SIZE] = L'\0';
    }

	if (szBuffer)
		delete szBuffer;

    return nCode;
}

// returns numeric reply code
// in general, anything >= 400 is bad.
DWORD SMTPTransactMailCommand(SOCKET Socket, char *cCommand)
{
	DWORD dwError;
	
    if (cCommand == NULL)
        return INTERNAL_ERROR;

    if(SOCKET_ERROR == send(Socket, cCommand, strlen(cCommand), 0))
    {
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "SMTPTransactMailCommand failed on command: %s (%d)\n", cCommand, err));
        ErrorObj* pErrorObj = ErrorObj::GetErrorObj();
        if (pErrorObj)
        {            
            // so it gets truncated, it's long enough to tell what's happening.
            WCHAR wcsCommand[256] = L"\0";
            if (mbstowcs(wcsCommand, cCommand, 255) > 0)
            {
                wcsCommand[255] = L'\0';
                if (wcslen(wcsCommand) >= 253)
                    StringCchCopyW(&wcsCommand[252], 4, L"...");
            }


            pErrorObj->ReportError(L"send", wcsCommand, NULL, err, true);
            pErrorObj->Release();
        }

        dwError = INTERNAL_ERROR;
    }
    else
    {        
        WCHAR messageBuf[ERROR_MESSAGE_SIZE +1] = L"\0";

        dwError = SMTPReceive(Socket, messageBuf);	
        messageBuf[ERROR_MESSAGE_SIZE] = L'\0';

		if(IsSMTPError(dwError))
        {
			ERRORTRACE((LOG_ESS, "SMTP command \"%s\" returned %d (%S)\n", cCommand, dwError, messageBuf));

            ErrorObj* pErrorObj = ErrorObj::GetErrorObj();
            if (pErrorObj)
            {            
                // so it gets truncated, it's long enough to tell what's happening.
                WCHAR wcsCommand[256] = L"\0";
                if (mbstowcs(wcsCommand, cCommand, 255) > 0)
                {
                    wcsCommand[255] = L'\0';
                    if (wcslen(wcsCommand) >= 253)
                        StringCchCopy(&wcsCommand[252], 4, L"...");
                }

                pErrorObj->ReportError(wcsCommand, NULL, messageBuf, dwError, false);
                pErrorObj->Release();
            }

		}
	}

	return dwError;
}


// returns 0 on success
// don't bother trying to make sense of the number otherwise       
int SMTPConnect(char* szHost, SOCKET* pSocket)
{
    SOCKET             Socket = INVALID_SOCKET; 
    struct sockaddr_in Address; 
    struct hostent *   HostEntry; 
    int Error = -1;
    BOOL fSt = FALSE;


	TCHAR cComputer[HH_MAX_COMPUTERNAME_LENGTH +2];
	DWORD dwBuffSize= HH_MAX_COMPUTERNAME_LENGTH +1;

    Socket = socket(AF_INET, SOCK_STREAM, 0); 

    if (Socket == INVALID_SOCKET)  
    { 
        // fprintf(stderr, "Error creating socket = %d\n", GetLastError()); 

        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "Error creating socket = %d\n", err));

        fSt = FALSE; 
        goto ex; 
    } 

    Address.sin_family = AF_INET; 
    Address.sin_port = 0; 
    Address.sin_addr.s_addr = INADDR_ANY; 

    Error =  
    bind( 
        Socket, 
        (struct sockaddr *) &Address, 
        sizeof(Address)); 

    if (Error)  
    { 
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "bind failed = %d\n", err));
        fSt = FALSE; 
        goto ex; 
    } 

    Address.sin_family = AF_INET; 
    Address.sin_port = htons(SMTP_PORT); 

    HostEntry = gethostbyname(szHost); 
    if (HostEntry == NULL)  
    { 
        Error = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "unable to resolve host %s error = %d\n", szHost, Error));
        ErrorObj* pErrorObj = ErrorObj::GetErrorObj();
        if (pErrorObj)
        {            
            WCHAR wcsHost[256] = L"\0";
            if (mbstowcs(wcsHost, szHost, 255) > 0)
            {
                wcsHost[255] = L'\0';
                if (wcslen(wcsHost) >= 253)
                    StringCchCopy(&wcsHost[252], 4, L"...");
            }

            pErrorObj->ReportError(L"gethostbyname", wcsHost, NULL, Error, true);
            pErrorObj->Release();
        }

        fSt = FALSE; 
        goto ex; 
    } 
    else  
    { 
        Address.sin_addr.s_addr = *((unsigned long *) HostEntry->h_addr); 
    } 

    Error = 
    connect( 
        Socket, 
        (struct sockaddr *) &Address, 
        sizeof(Address)); 

    if (Error)  
    { 
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "Error connecting to %s = %d\n", szHost, err));
        ErrorObj* pErrorObj = ErrorObj::GetErrorObj();
        if (pErrorObj)
        {            
            WCHAR wcsHost[256] = L"\0";
            if (mbstowcs(wcsHost, szHost, 255) > 0)
            {
                wcsHost[255] = L'\0';
                if (wcslen(wcsHost) >= 253)
                    StringCchCopy(&wcsHost[252], 4, L"...");
            }

            pErrorObj->ReportError(L"connect", wcsHost, NULL, err, true);
            pErrorObj->Release();
        }


        fSt = FALSE; 
        goto ex; 
    } 

    WCHAR messageBuf[ERROR_MESSAGE_SIZE +1] = L"\0";

	Error = SMTPReceive(Socket, messageBuf);
    messageBuf[ERROR_MESSAGE_SIZE] = L'\0';

    if (!IsSMTPError(Error))
    {
	    if (!GetComputerName(cComputer,&dwBuffSize))
		{
			ERRORTRACE((LOG_ESS, "GetComputerName failed! 0x%08X\n", GetLastError()));
			return -1;
		}

        const int BufLen = 2*HH_MAX_COMPUTERNAME_LENGTH + 20;
        char cMailCommand[BufLen];
	    StringCchCopyA(cMailCommand, BufLen, "HELO ");
#ifdef _UNICODE
        char narrowcComputer[BufLen];
        if (FAILED(StringCchPrintfA(narrowcComputer, BufLen, "%S", cComputer)))
            return -1;

        if (FAILED(StringCchCatA(cMailCommand, BufLen, narrowcComputer)))
            return -1;
#else
	    if (FAILED(StringCchCatA(cMailCommand, BufLen, cComputer)))
            return -1;
#endif
	    if (FAILED(StringCchCatA(cMailCommand, BufLen, "\r\n")))
            return -1;

	    Error=SMTPTransactMailCommand(Socket, cMailCommand);
   		if(IsSMTPError(Error))
        {
            ErrorObj* pErrorObj = ErrorObj::GetErrorObj();
            if (pErrorObj)
            {            
                // so it gets truncated, it's long enough to tell what's happening.
                WCHAR wcsCommand[256] = L"\0";
                if (mbstowcs(wcsCommand, cMailCommand, 255) > 0)
                {
                    wcsCommand[255] = L'\0';
                    if (wcslen(wcsCommand) >= 253)
                        StringCchCopyW(&wcsCommand[252], 4, L"...");
                }

                pErrorObj->ReportError(wcsCommand, NULL, messageBuf, Error, false);
                pErrorObj->Release();

            }

        }

        fSt = TRUE;
    }
    else
	{
        fSt = FALSE;
		ERRORTRACE((LOG_ESS, "Error establishing SMTP connection (%d) (%S)\n", Error, messageBuf));
        ErrorObj* pErrorObj = ErrorObj::GetErrorObj();
        if (pErrorObj)
        {            
            pErrorObj->ReportError(L"connect", NULL, messageBuf, Error, false);       
            pErrorObj->Release();

        }
	}

ex:
    if(!fSt)
    {
        closesocket(Socket);
        return Error;
    }
    else
    {
        *pSocket = Socket;
        return NOERROR;
    }
}


// returns SMTP reply code
DWORD SMTPDisconnect(SOCKET Socket)
{
	DWORD dwError = SMTP_OKAY;
	
	if (Socket != INVALID_SOCKET)
	{
		dwError=SMTPTransactMailCommand(Socket, "QUIT\r\n");
		closesocket(Socket);
	};

	return(dwError);
}

LPSTR Months[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
LPSTR Days[] =   { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

void GetTimeString(char *cTimeString,DWORD dwMaxSize)
{
	SYSTEMTIME st;

	GetSystemTime(&st);

	StringCchPrintfA( cTimeString, dwMaxSize, "%s, %02d %s %4d %02d:%02d:%02d GMT",
			 Days[ st.wDayOfWeek ], st.wDay, Months[ st.wMonth], st.wYear, st.wHour, st.wMinute, st.wSecond);
}

	
// returns 0 upon success
// inputs may be zero length, but may not be NULL.
DWORD SMTPSendMailHeader(SOCKET Socket, char* szTo, char* szCc, char* szFrom, char* szSender, char* szReplyTo, char* szSubject, char* szHeaders)
{	
    // dang gone it! they went & made 'template' a keyword...
    // const char templitt[] = "Date: %s\r\nTo: %s\r\nCc: %s\r\nFrom: %s via WMI auto-mailer\r\nReply-To: %s\r\nSubject: %s";
    const char templitt[] = "Date: %s\r\nTo: %s\r\nCc: %s\r\nFrom: <%s>\r\nSender: <%s>\r\nReply-To: %s\r\nSubject: %s\r\nMIME-Version: 1.0\r\nContent-Type: multipart/mixed; boundary=\"- - =_HH_= - ---\"";
    
    int bufLength = strlen(templitt) +strlen(szTo)   +strlen(szCc) 
                                                      +strlen(szFrom) +strlen(szSender) +strlen(szReplyTo)
                                                      +strlen(szSubject) +strlen(szHeaders)
                                                      +104; // to account for date string and for the trailing \r\n\r\n, and alittle fudge factor

    char* pszOutputBuffer = new char[bufLength];

    if (!pszOutputBuffer)
        return INTERNAL_ERROR;
    else
    {
        CDeleteMe<char> delbuf(pszOutputBuffer);
        char cTimeString[100];
	    GetTimeString(cTimeString,100);  
        
        StringCchPrintfA(pszOutputBuffer, bufLength, templitt, cTimeString, szTo, szCc, szFrom, szSender, szReplyTo, szSubject);

        if (strlen(szHeaders))
        {
            StringCchCatA(pszOutputBuffer, bufLength, "\r\n");
            StringCchCatA(pszOutputBuffer, bufLength, szHeaders);
        }
    
        
        StringCchCatA(pszOutputBuffer, bufLength, "\r\n\r\n");
    
        if (SOCKET_ERROR == send(Socket, pszOutputBuffer, strlen(pszOutputBuffer), 0))
        {
            int err = WSAGetLastError();
            ERRORTRACE((LOG_ESS, "SMTPSendMailHeader failed (%d)\n", err));
            return INTERNAL_ERROR;
        }
        else
	    {
	        return(NO_ERROR);
	    }
    }
}

// returns 0 on success
// but ignores error returns from server (server returns error if it must relay recipients.
DWORD SMTPSendRecipients(SOCKET Socket, LPCSTR szRecipients)
{
	char *tok;
    DWORD dwError = SMTP_OKAY;    
    int bufLength = strlen(szRecipients) +1;
	char*  pParseBuffer = new char[bufLength];

    if (!pParseBuffer)
        dwError = INTERNAL_ERROR;
    else
    {
        char szBuffer[1024];
        CDeleteMe<char> delbuf(pParseBuffer);

	    StringCchCopyA(pParseBuffer, bufLength, szRecipients);
	    
	    tok=strtok(pParseBuffer," ;,");
	    while (tok!=NULL)
	    {
		    DWORD dwErrInternal;
            
            if (FAILED(StringCchPrintfA(szBuffer, 1024, "RCPT TO:<%s>\r\n",tok)))
                return INTERNAL_ERROR;

		    dwErrInternal=SMTPTransactMailCommand(Socket, szBuffer);
            if(IsSMTPError(dwErrInternal))
            { 
                if ((dwErrInternal == 550) || (dwErrInternal == 551))
                    ERRORTRACE((LOG_ESS, "Ignoring RCPT Error, will attempt to send mail.\n"));
                else
                {
                    dwError = dwErrInternal;
                    break;
                }
            }

		    
		    tok=strtok(NULL," ;,");
	    }
    }

	return dwError;
}


// returns 0 on success, SMTP numeric reply code otherwise
DWORD SMTPSendText(SOCKET Socket, char* szTo, char* szCc, char* szFrom, char* szSender, char* szReplyTo, char* szSubject, 
                   char* szHeaders, char *szText)
{
	DWORD dwError;
	int nLen;
	int nSizeToSend;
	char *tmp;
	
	dwError=SMTPTransactMailCommand(Socket, "DATA\r\n");
    if (IsSMTPError(dwError))
        return dwError;

	dwError=SMTPSendMailHeader(Socket, szTo, szCc, szFrom, szSender, szReplyTo, szSubject, szHeaders);
    if (IsSMTPError(dwError))
        return dwError;

    char headerFake[] = "\r\n--- - =_HH_= - ---\r\nContent-Type: text/plain; charset=\"us-ascii\"\r\nContent-Transfer-Encoding: 7bit\r\n\r\n";
    if (SOCKET_ERROR == send(Socket, headerFake, strlen(headerFake), 0))
    {
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "SMTPSendText failed (%d)\n", err));

        return INTERNAL_ERROR;
    }

    nLen=strlen(szText);
	tmp=szText;
	
	while (nLen>0)
	{
		nSizeToSend=min(1000,nLen);
		
        if (SOCKET_ERROR == send(Socket, tmp, nSizeToSend, 0))
        {
            int err = WSAGetLastError();
            ERRORTRACE((LOG_ESS, "SMTPSendText failed (%d)\n", err));

            return INTERNAL_ERROR;
        }

		nLen-=nSizeToSend;
		tmp+=nSizeToSend;
	}
	
    char trailerFake[] = "\r\n\r\n--- - =_HH_= - -----\r\n\r\n";
    if (SOCKET_ERROR == send(Socket, trailerFake, strlen(trailerFake), 0))
    {
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "SMTPSendText failed (%d)\n", err));

        return INTERNAL_ERROR;
   }
	
	dwError=SMTPTransactMailCommand(Socket, "\r\n.\r\n");
	
	return dwError;
}


// uses SMTP verification to determine whether
// recipient actually exists (is known to this server)
// returns return value from SMTPTransactMailCommand
//-->> will return success code if passed a NULL buffer
DWORD CheckRecipients(SOCKET Socket2me, char* szRecipients)
{
    DWORD dwError = SMTP_OKAY;
    int bufLength = strlen(szRecipients) +1;
	char*  pParseBuffer = new char[bufLength];

    if (!pParseBuffer)
        dwError = INTERNAL_ERROR;
    else
    {
        CDeleteMe<char> delbuf(pParseBuffer);
        char *tok;            
        char szBuffer[1024];
	    
	    StringCchCopyA(pParseBuffer, bufLength, szRecipients);
	    
	    tok=strtok(pParseBuffer," ;,");
	    while (tok!=NULL)
	    {
		    if (FAILED(StringCchPrintfA(szBuffer, 1024, "VRFY %s\r\n",tok)))
                return INTERNAL_ERROR;
		    
            dwError=SMTPTransactMailCommand(Socket2me, szBuffer);
            if(IsSMTPError(dwError))
                break;
		    
		    tok=strtok(NULL," ;,");
	    }
    }

    // hack to disable error returns
    // some servers don't handle VRFY
    dwError = SMTP_OKAY;
	return dwError;
    
}

// returns zero upon success.
DWORD SMTPSend(char* szServer, char* szTo, char* szCc, char* szBcc, char* szFrom, char* szSender, 
			   char* szReplyTo, char* szSubject, char* szHeaders, char *szText)
{
	DWORD dwError = -1;
    SOCKET Socket = INVALID_SOCKET;
    
    char szFromBuffer[1024];
    if (FAILED(StringCchPrintfA(szFromBuffer, 1024, "MAIL FROM: <%s>\r\n",szFrom)))
        return INTERNAL_ERROR;
	
    // each of the functions below do their own error reporting to the log
	if ( (0 == SMTPConnect(szServer, &Socket))                       &&

	     !IsSMTPError(CheckRecipients(Socket, szTo))     &&
         !IsSMTPError(CheckRecipients(Socket, szCc))    &&		 
         !IsSMTPError(CheckRecipients(Socket, szBcc))   &&  

         !IsSMTPError(SMTPTransactMailCommand(Socket, szFromBuffer)) && 
         
         !IsSMTPError(SMTPSendRecipients(Socket, szTo))                     &&
		 !IsSMTPError(SMTPSendRecipients(Socket, szCc))                     &&
		 !IsSMTPError(SMTPSendRecipients(Socket, szBcc))                    &&

         !IsSMTPError(SMTPSendText(Socket, szTo, szCc, szFrom, szSender, szReplyTo, szSubject, szHeaders, szText)) )
	{     
		 dwError = 0;
	}

    DWORD dwDebugError;
    dwDebugError=SMTPDisconnect(Socket);
	
	if(IsSMTPError(dwDebugError))
	{
		// If disconnect failed log a message, but don't interfere with
		// operation
		ERRORTRACE((LOG_ESS, "SMTPDisconnect returned %d\n", dwDebugError));
	}

	return dwError;
} 


// test harness
//void main()
//{
//    WSADATA            WsaData; 
//    int Error = WSAStartup (0x101, &WsaData); 
// 
//    if (Error == SOCKET_ERROR)  
//    { 
//        fprintf(stderr, "Error in WSAStartup = %d\n", GetLastError()); 
//        return;
//    } 
//
//    SMTPSend("smarthost", "levn@microsoft.com", "levn@microsoft.com", "subject", "Text");
//    /*
//    SOCKET Socket;
//    SMTPConnect("smarthost", &Socket);
//    SMTPDisconnect(Socket);
//    */
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\evtlog.h ===
#ifndef __WBEM_EVENTLOG_CONSUMER__H_
#define __WBEM_EVENTLOG_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>

class CEventLogConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CEventLogConsumer>
    {
    public:
        XProvider(CEventLogConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CEventLogConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CEventLogConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CEventLogConsumer(){}
    void* GetInterface(REFIID riid);
};


class CEventLogSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CEventLogSink>
    {
    public:
        XSink(CEventLogSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CEventLogSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    private:
        void GetDatData(IWbemClassObject* pEventObj, WCHAR* dataName, 
                        VARIANT& vData, BYTE*& pData, DWORD& dataSize);
        void GetDatSID(IWbemClassObject* pEventObj, WCHAR* dataName, PSID& pSid);
        HRESULT GetDatDataVariant(IWbemClassObject* pEventObj, WCHAR* dataName, VARIANT& vData);
        HRESULT GetDatEmbeddedObjectOut(IWbemClassObject* pObject, WCHAR* objectName, IWbemClassObject*& pEmbeddedObject);

    } m_XSink;
    friend XSink;

protected:
    DWORD m_dwType;
    DWORD m_dwCategory;
    DWORD m_dwEventId;
    DWORD m_dwNumTemplates;
    CTextTemplate* m_aTemplates;
    PSID  m_pSidCreator;   
    WString m_dataName; // name of property in event, property is handed off to the 'additional data' block in nt event log
    WString m_sidName;  // name of property in event, property is handed off to the 'user sid' block in nt event log

    HANDLE m_hEventLog;

public:
    CEventLogSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_aTemplates(NULL), m_hEventLog(NULL), m_pSidCreator(NULL)          
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    ~CEventLogSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\cmdline.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemutil.h>
#include <GroupsForUser.h>
#include "ProcKiller.h"
#include <GenUtils.h>
#include <ArrTempl.h>
#include <sddl.h>
#include <ErrorObj.h>
#include "cmdline.h"
#include <Wtsapi32.h>
#include <winntsec.h>
#include <lm.h>
  

#include <malloc.h>

#define CMDLINE_PROPNAME_EXECUTABLE L"ExecutablePath"
#define CMDLINE_PROPNAME_COMMANDLINE L"CommandLineTemplate"
#define CMDLINE_PROPNAME_USEDEFAULTERRORMODE L"UseDefaultErrorMode"
#define CMDLINE_PROPNAME_CREATENEWCONSOLE L"CreateNewConsole"
#define CMDLINE_PROPNAME_CREATENEWPROCESSGROUP L"CreateNewProcessGroup"
#define CMDLINE_PROPNAME_CREATESEPARATEWOWVDM L"CreateSeparateWowVdm"
#define CMDLINE_PROPNAME_CREATESHAREDWOWVDM L"CreateSharedWowVdm"
#define CMDLINE_PROPNAME_PRIORITY L"Priority"
#define CMDLINE_PROPNAME_WORKINGDIRECTORY L"WorkingDirectory"
#define CMDLINE_PROPNAME_DESKTOP L"DesktopName"
#define CMDLINE_PROPNAME_TITLE L"WindowTitle"
#define CMDLINE_PROPNAME_X L"XCoordinate"
#define CMDLINE_PROPNAME_Y L"YCoordinate"
#define CMDLINE_PROPNAME_XSIZE L"XSize"
#define CMDLINE_PROPNAME_YSIZE L"YSize"
#define CMDLINE_PROPNAME_XCOUNTCHARS L"XNumCharacters"
#define CMDLINE_PROPNAME_YCOUNTCHARS L"YNumCharacters"
#define CMDLINE_PROPNAME_FILLATTRIBUTE L"FillAttribute"
#define CMDLINE_PROPNAME_SHOWWINDOW L"ShowWindowCommand"
#define CMDLINE_PROPNAME_FORCEON L"ForceOnFeedback"
#define CMDLINE_PROPNAME_FORCEOFF L"ForceOffFeedback"
#define CMDLINE_PROPNAME_INTERACTIVE L"RunInteractively"
#define CMDLINE_PROPNAME_KILLTIMEOUT L"KillTimeout"
#define CMDLINE_PROPNAME_CREATORSID L"CreatorSid"

HRESULT STDMETHODCALLTYPE CCommandLineConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CCommandLineSink* pSink = new CCommandLineSink(m_pObject->m_pControl);

	if (!pSink)
		return WBEM_E_OUT_OF_MEMORY;
    
	HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


void* CCommandLineConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}

HRESULT CCommandLineSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // this is actually a pointer to a static object
    // if it fails, something is Very, Very Wrong.
    m_pErrorObj = ErrorObj::GetErrorObj();
    if (!m_pErrorObj)
        return WBEM_E_CRITICAL_ERROR;

    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    // only one of the pair Executable & commandLine may be null
    // this var counts...
    int nNulls = 0;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_EXECUTABLE, 0, &v, 
            NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        m_wsExecutable = L"";
        nNulls++;
    }
    else
        m_wsExecutable = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_COMMANDLINE, 0, &v, 
            NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        m_CommandLine.SetTemplate(L"");
        nNulls++;
    }
    else
        m_CommandLine.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    if (nNulls > 1)
        return WBEM_E_INVALID_PARAMETER;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_WORKINGDIRECTORY, 0, &v, 
            NULL, NULL);
    if(SUCCEEDED(hres) && V_VT(&v) == VT_BSTR)
        m_wsWorkingDirectory  = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_DESKTOP, 0, &v, 
            NULL, NULL);
    if(SUCCEEDED(hres) && V_VT(&v) == VT_BSTR)
        m_wsDesktop  = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_TITLE, 0, &v, 
            NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        m_title.SetTemplate(L"");
    else
        m_title.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_INTERACTIVE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_bInteractive = TRUE;
    else
        m_bInteractive = FALSE;

    m_dwCreationFlags = 0;
    
    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_USEDEFAULTERRORMODE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_DEFAULT_ERROR_MODE;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATENEWCONSOLE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_NEW_CONSOLE;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATENEWPROCESSGROUP, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_NEW_PROCESS_GROUP;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATESEPARATEWOWVDM, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATESHAREDWOWVDM, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_SHARED_WOW_VDM;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_PRIORITY, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        if(V_I4(&v) == HIGH_PRIORITY_CLASS || 
            V_I4(&v) == IDLE_PRIORITY_CLASS || 
            V_I4(&v) == NORMAL_PRIORITY_CLASS || 
            V_I4(&v) == REALTIME_PRIORITY_CLASS)
        {
            m_dwCreationFlags |= V_I4(&v);
        }
        else
            return WBEM_E_INVALID_PARAMETER;
    }

    m_dwStartFlags = 0;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_X, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwX = V_I4(&v);
        m_dwStartFlags |= STARTF_USEPOSITION;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_Y, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwY = V_I4(&v);
        m_dwStartFlags |= STARTF_USEPOSITION;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_XSIZE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwXSize = V_I4(&v);
        m_dwStartFlags |= STARTF_USESIZE;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_YSIZE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwYSize = V_I4(&v);
        m_dwStartFlags |= STARTF_USESIZE;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_XCOUNTCHARS, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwXNumCharacters = V_I4(&v);
        m_dwStartFlags |= STARTF_USECOUNTCHARS;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_YCOUNTCHARS, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwYNumCharacters = V_I4(&v);
        m_dwStartFlags |= STARTF_USECOUNTCHARS;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_FILLATTRIBUTE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwFillAttribute = V_I4(&v);
        m_dwStartFlags |= STARTF_USEFILLATTRIBUTE;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_SHOWWINDOW, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwShowWindow = V_I4(&v);
        m_dwStartFlags |= STARTF_USESHOWWINDOW;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_FORCEON, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwStartFlags |= STARTF_FORCEONFEEDBACK;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_FORCEOFF, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwStartFlags |= STARTF_FORCEOFFFEEDBACK;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_KILLTIMEOUT, 0, &v,
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
        m_dwKillTimeout = V_I4(&v);
    else
        m_dwKillTimeout = 0;

    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATORSID, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres))
    {
        HRESULT hDebug;
        
        long ubound;
        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

        if(SUCCEEDED(hDebug))
        {
            PVOID pVoid;
            hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

            if(SUCCEEDED(hDebug))
            {
                m_pSidCreator = new BYTE[ubound +1];
                if (m_pSidCreator)
                    memcpy(m_pSidCreator, pVoid, ubound + 1);
                else
                    hres = WBEM_E_OUT_OF_MEMORY;
      
                SafeArrayUnaccessData(V_ARRAY(&v));
            }
        }
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Command Line Consumer could not retrieve creator sid (0x%08X)\n",hres));
        return hres;
    }
    
    return hres;
}

BOOL IsInteractive(HWINSTA hWinsta)
{
    USEROBJECTFLAGS uof;
    DWORD dwLen;
    BOOL bRes = GetUserObjectInformation(hWinsta, UOI_FLAGS, 
        (void*)&uof, sizeof(uof), &dwLen);
    if(!bRes)
        return FALSE;
    return ((uof.dwFlags & WSF_VISIBLE) != 0);
}
BOOL WinstaEnumProc(LPTSTR szWindowStation, LPARAM lParam)
{
    WString* pws = (WString*)lParam;

    HWINSTA hWinsta = OpenWindowStation(szWindowStation, FALSE, 
        WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES);
    if(hWinsta == NULL)
        return TRUE;

    if(IsInteractive(hWinsta))
    {
        *pws = szWindowStation;
    }
    CloseWindowStation(hWinsta);

    return TRUE;
}
            
    
BOOL GetInteractiveWinstation(WString& wsName)
{
    wsName.Empty();

    BOOL bRes = EnumWindowStations(WinstaEnumProc, 
        (LPARAM)&wsName);
    return bRes;
}


HRESULT CCommandLineSink::FindInteractiveInfo()
{
    BOOL bRes = GetInteractiveWinstation(m_wsWindowStation);
    if(!bRes)
	{
        return WBEM_E_FAILED;
	}
    if(m_wsWindowStation.Length() == 0)
        return WBEM_E_NOT_FOUND;

    return WBEM_S_NO_ERROR;
}

HRESULT GetSidUse(PSID pSid, SID_NAME_USE& use)
{
    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPWSTR pUser = 0;
    LPWSTR pDomain = 0;
    use = SidTypeInvalid;

    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSidW(
        NULL,
        pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &use
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return WBEM_E_FAILED;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new wchar_t[dwNameLen + 1];
    if (!pUser)
        return WBEM_E_OUT_OF_MEMORY;

    pDomain = new wchar_t[dwDomainLen + 1];
    if (!pDomain)
    {
        delete pUser;
        return WBEM_E_OUT_OF_MEMORY;
    }

    bRes = LookupAccountSidW(
        NULL,
        pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &use
        );
     
    delete [] pUser;
    delete [] pDomain;

    if (bRes)
        return WBEM_S_NO_ERROR;
    else
        return WBEM_E_FAILED;
}


bool GetLoggedOnUserViaTS(
    CNtSid& sidLoggedOnUser)
{
    bool fRet = false;
    bool fCont = true;
    PWTS_SESSION_INFO psesinfo = NULL;
    DWORD dwSessions = 0;
    LPWSTR wstrUserName = NULL;
    LPWSTR wstrDomainName = NULL;
    LPWSTR wstrWinstaName = NULL;
    DWORD dwSize = 0L;
 
    try
    {
        if(!(::WTSEnumerateSessions(
           WTS_CURRENT_SERVER_HANDLE,
           0,
           1,
           &psesinfo,
           &dwSessions) && psesinfo))
        {
            fCont = false;
        }
 
        if(fCont)
        {
            for(int j = 0; j < dwSessions && !fRet; j++, fCont = true)
            {
                if(psesinfo[j].State != WTSActive)
                {
                    fCont = false;
                }
 
                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSUserName,
                        &wstrUserName,
                        &dwSize) && wstrUserName))
                    {
                        fCont = false;
                    }
                }
                
                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSDomainName,
                        &wstrDomainName,
                        &dwSize) && wstrDomainName))
                    {
                        fCont = false;
                    }
                }
                    
                if(fCont)
                {            
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSWinStationName,
                        &wstrWinstaName,
                        &dwSize) && wstrWinstaName))   
                    {
                        fCont = false;
                    }
                }
 
                if(fCont)
                {
                    if(wbem_wcsicmp(wstrWinstaName, L"Console") != 0)
                    {
                        fCont = false;
                    }
                }
 
                if(fCont)
                {
                    WCHAR buf[256];
                    DWORD bufSize = 255;

                    if (GetComputerNameW(buf, &bufSize))
                    {
                        DWORD nRet = 0;
                        
                        // if it's a local account, we look it up locally
                        // else we find a DC to look up.
                        WCHAR* pServer = NULL;
                        if (0 == wbem_wcsicmp(buf, wstrDomainName))
                            pServer = NULL;
                        else 
                            nRet = NetGetDCName(NULL, wstrDomainName, (LPBYTE *)&pServer);
                        
                        if (nRet == 0)
                        {
                            // That establishes that this user
                            // is associated with the interactive
                            // desktop.
                            CNtSid sidInteractive(wstrUserName, pServer);
    
                            if(sidInteractive.GetStatus() == CNtSid::NoError)
                            {
                                sidLoggedOnUser = sidInteractive;
                                fRet = true;
                            }

                            if (pServer)
                                NetApiBufferFree(pServer);
                        }
                        else
                            fRet = false;
                    }
                }
 
                if(wstrUserName)
                {
                    WTSFreeMemory(wstrUserName);
     wstrUserName = NULL;
                }
                if(wstrDomainName)
                {
                    WTSFreeMemory(wstrDomainName);
     wstrDomainName = NULL;
                }
                if(wstrWinstaName)
                {
                    WTSFreeMemory(wstrWinstaName);
     wstrWinstaName = NULL;
                }
            }
            if (psesinfo)
                WTSFreeMemory(psesinfo);
        }
    }
    catch(...)
    {
        if(wstrUserName)
        {
            WTSFreeMemory(wstrUserName);
   wstrUserName = NULL;
        }
        if(wstrDomainName)
        {
            WTSFreeMemory(wstrDomainName);
   wstrDomainName = NULL;
        }
        if(wstrWinstaName)
        {
            WTSFreeMemory(wstrWinstaName);
                 wstrWinstaName = NULL;
        }

        if (psesinfo)
             WTSFreeMemory(psesinfo);

        fRet = false;
    }
 
    return fRet;
}


HRESULT STDMETHODCALLTYPE CCommandLineSink::XSink::CreateProcessNT(WCHAR* pCommandLine, WCHAR* pTitle, PROCESS_INFORMATION& pi, FILETIME& now)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR*  pDesktop = NULL;
    
    WString wsDesktop;               
    
    if(m_pObject->m_bInteractive)
    {
        if(FAILED(m_pObject->FindInteractiveInfo()))
        {
            ERRORTRACE((LOG_ESS, "No interactive window station found!\n"));
            return WBEM_E_FAILED;
        }
        wsDesktop = m_pObject->m_wsWindowStation;
        wsDesktop += L"\\Default";
        pDesktop = (wchar_t*)wsDesktop;
        
        CNtSid user;

        if (!GetLoggedOnUserViaTS(user))
        {
            ERRORTRACE((LOG_ESS, "Could not determine logged on user\n"));
            return WBEM_E_FAILED;
        }


        SID_NAME_USE use;
        if (FAILED(hr =GetSidUse(m_pObject->m_pSidCreator, use)))
            return hr;

        if (use == SidTypeUser)
        {
            if (!EqualSid(m_pObject->m_pSidCreator, user.GetPtr()))
            {
                ERRORTRACE((LOG_ESS, "Command line event consumer will only run interactively\non a workstation that the creator is logged into.\n"));
                m_pObject->m_pErrorObj->ReportError(L"AccessCheck", L"RunInteractively", 
                    NULL, WBEM_E_ACCESS_DENIED, true);

                return WBEM_E_ACCESS_DENIED;
            }
            // else we're fine continue.
            DEBUGTRACE((LOG_ESS, "User and creator are one in the same\n"));
        }
        else 
        {
            if (0 != IsUserInGroup(user.GetPtr(), m_pObject->m_pSidCreator))
            {
                ERRORTRACE((LOG_ESS, "Command line event consumer will only run interactively\non a workstation that the creator is logged into.\n"));
                m_pObject->m_pErrorObj->ReportError(L"AccessCheck", L"RunInteractively", 
                    NULL, WBEM_E_ACCESS_DENIED, true);
                
                return WBEM_E_ACCESS_DENIED;
            }
            else
            {
                DEBUGTRACE((LOG_ESS, "User is in the group!\n"));
            }
        }
    }

 

    WCHAR* szApplicationName =  (m_pObject->m_wsExecutable.Length() == 0) ? NULL : ((wchar_t*)m_pObject->m_wsExecutable);
    WCHAR* szWorkingDirectory = (m_pObject->m_wsWorkingDirectory.Length() == 0) ? NULL : ((wchar_t*)m_pObject->m_wsWorkingDirectory);

    struct _STARTUPINFOW si;
    si.cb = sizeof(si);
    si.lpReserved = NULL;
    si.cbReserved2 = 0;
    si.lpReserved2 = NULL;
    si.lpDesktop = pDesktop;
    si.lpTitle = pTitle;
    si.dwX = m_pObject->m_dwX;
    si.dwY = m_pObject->m_dwY;
    si.dwXSize = m_pObject->m_dwXSize;
    si.dwYSize = m_pObject->m_dwYSize;
    si.dwXCountChars = m_pObject->m_dwXNumCharacters;
    si.dwYCountChars = m_pObject->m_dwYNumCharacters;
    si.dwFillAttribute = m_pObject->m_dwFillAttribute;
    si.dwFlags = m_pObject->m_dwStartFlags;
    si.wShowWindow = (WORD)m_pObject->m_dwShowWindow;

#ifdef HHANCE_DEBUG_CODE
	DEBUGTRACE((LOG_ESS, "Calling Create process\n"));
#endif
    
    BOOL bRes = CreateProcessW(szApplicationName, pCommandLine,
        NULL, NULL, FALSE, m_pObject->m_dwCreationFlags,
        NULL, szWorkingDirectory, &si, &pi);

	if (!bRes)
    {
        DWORD dwErr = GetLastError();
        m_pObject->m_pErrorObj->ReportError(L"CreateProcess", szApplicationName ? szApplicationName : pCommandLine, NULL, dwErr, true);
        ERRORTRACE((LOG_ESS, "CreateProcess failed, 0x%08X\n", dwErr));
    }
#ifdef HHANCE_DEBUG_CODE
	else
		DEBUGTRACE((LOG_ESS, "Create Process succeeded\n"));
#endif


    // get current time for shutdown info
    GetSystemTimeAsFileTime(&now);        

    if (!bRes)
        hr = WBEM_E_FAILED;

    return hr;
}


HRESULT STDMETHODCALLTYPE CCommandLineSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hr = S_OK;

    PSID pSidSystem;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
 
    if  (AllocateAndInitializeSid(&id, 1,
                                  SECURITY_LOCAL_SYSTEM_RID, 
                                  0, 0,0,0,0,0,0,&pSidSystem))
    {         
        // guilty until proven innocent
        hr = WBEM_E_ACCESS_DENIED;

        // check to see if sid is either Local System or an admin of some sort...
        if ((EqualSid(pSidSystem, m_pObject->m_pSidCreator)) ||
            (S_OK == IsUserAdministrator(m_pObject->m_pSidCreator)))
            hr = WBEM_S_NO_ERROR;
          
        // We're done with this
        FreeSid(pSidSystem);

        if (FAILED(hr))
        {
            if (hr == WBEM_E_ACCESS_DENIED)
                ERRORTRACE((LOG_ESS, "Command line event consumer may only be used by an administrator\n"));
            return hr;
        }
    }
    else
        return WBEM_E_OUT_OF_MEMORY;

    
    for(int i = 0; i < lNumObjects; i++)
    {
        BSTR strCommandLine = m_pObject->m_CommandLine.Apply(apObjects[i]);
        if(strCommandLine == NULL)
        {
            ERRORTRACE((LOG_ESS, "Invalid command line!\n"));
            return WBEM_E_INVALID_PARAMETER;
        }

        WString wsCommandLine = strCommandLine;
        SysFreeString(strCommandLine);

        BSTR bstrTitle = m_pObject->m_title.Apply(apObjects[i]);
        WString wsTitle = bstrTitle;        
        if (bstrTitle)
            SysFreeString(bstrTitle);

        FILETIME now;
        PROCESS_INFORMATION pi; 

        WCHAR* pCommandLine = ((wsCommandLine.Length() == 0) ? NULL : (wchar_t *)wsCommandLine);;
        WCHAR* pTitle =       ((wsTitle.Length() == 0) ? NULL : (wchar_t *)wsTitle);           
            
        hr = CreateProcessNT(pCommandLine, pTitle, pi, now);

        if (FAILED(hr))
        {
            ERRORTRACE((LOG_ESS, "Failed to CreateProcess %S. Error 0x%X\n", (LPCWSTR)wsCommandLine, hr));
            return hr;                 
        }
        else
        {
            if (m_pObject->m_dwKillTimeout)
            {

                WAYCOOL_FILETIME then(now);
                then.AddSeconds(m_pObject->m_dwKillTimeout);                

                hr = g_procKillerTimer.ScheduleAssassination(pi.hProcess, (FILETIME)then);

				if (FAILED(hr))
					DEBUGTRACE((LOG_ESS, "Could not schedule process termination\n"));
            }

            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
    return hr;
}
    

    

void* CCommandLineSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\evtlog.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemutil.h>
#include <wbemcomn.h>
#include <GroupsForUser.h>
#include "evtlog.h"
#include <GenUtils.h>
#include <comdef.h>
#include <Sddl.h>
#undef _ASSERT
#include <atlbase.h>

#define EVENTLOG_PROPNAME_SERVER L"UNCServerName"
#define EVENTLOG_PROPNAME_SOURCE L"SourceName"
#define EVENTLOG_PROPNAME_EVENTID L"EventID"
#define EVENTLOG_PROPNAME_TYPE L"EventType"
#define EVENTLOG_PROPNAME_CATEGORY L"Category"
#define EVENTLOG_PROPNAME_NUMSTRINGS L"NumberOfInsertionStrings"
#define EVENTLOG_PROPNAME_STRINGS L"InsertionStringTemplates"
#define EVENTLOG_PROPNAME_CREATORSID L"CreatorSid"
#define EVENTLOG_PROPNAME_DATANAME L"NameOfRawDataProperty"
#define EVENTLOG_PROPNAME_SIDNAME L"NameOfUserSIDProperty"

HRESULT STDMETHODCALLTYPE CEventLogConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CEventLogSink* pSink = new CEventLogSink(m_pObject->m_pControl);

    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


void* CEventLogConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}

CEventLogSink::~CEventLogSink()
{
    if(m_hEventLog)
        DeregisterEventSource(m_hEventLog);

    if(m_aTemplates)
        delete [] m_aTemplates;

    if(m_pSidCreator)
        delete [] m_pSidCreator;
}

HRESULT CEventLogSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // Get the information
    // ===================

    HRESULT hres = WBEM_S_NO_ERROR;
    CComVariant v;

    // Get the server and source
    // =========================

    WString wsServer;
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_SERVER, 0, &v, NULL, NULL);

    if(FAILED(hres)) return hres;
    
    if(V_VT(&v) == VT_BSTR)
        wsServer = V_BSTR(&v);
    
    VariantClear(&v);

    WString wsSource;
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_SOURCE, 0, &v, NULL, NULL);
    if(SUCCEEDED(hres) && (V_VT(&v) == VT_BSTR))
        wsSource = V_BSTR(&v);

    VariantClear(&v);

    m_hEventLog = RegisterEventSourceW(
        ( (wsServer.Length() == 0) ? NULL : (LPCWSTR)wsServer),
        wsSource);
    if(m_hEventLog == NULL)
    {
        ERRORTRACE((LOG_ESS, "Unable to register event source '%S' on server "
            "'%S'. Error code: %X\n", (LPCWSTR)wsSource, (LPCWSTR)wsServer,
            GetLastError()));
        return WBEM_E_FAILED;
    }

    // Get event parameters
    // ====================

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_EVENTID, 0, &v, NULL, NULL);
    if(SUCCEEDED(hres) && (V_VT(&v) == VT_I4))
        m_dwEventId = V_I4(&v);
    else
        // This will mean we need to try to get the event information off of each
        // event class as it arrives.
        m_dwEventId = 0;
    
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_TYPE, 0, &v, NULL, NULL);
    if(FAILED(hres) || (V_VT(&v) != VT_I4))
        return WBEM_E_INVALID_PARAMETER;
    m_dwType = V_I4(&v);
    
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_CATEGORY, 0, &v, NULL, NULL);
    if(FAILED(hres) || (V_VT(&v) != VT_I4))
        m_dwCategory = 0;
    else
        m_dwCategory = V_I4(&v);

    if (m_dwCategory > 0xFFFF)
        return WBEM_E_INVALID_PARAMETER;


    // Get insertion strings
    // =====================

    // Only get this stuff if the logical consumer has an event id.
    if (m_dwEventId)
    {
        hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_NUMSTRINGS, 0, &v, 
                                        NULL, NULL);
        if(FAILED(hres) || (V_VT(&v) != VT_I4))
            return WBEM_E_INVALID_PARAMETER;
        m_dwNumTemplates = V_I4(&v);
    

        hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_STRINGS, 0, &v, NULL, NULL);
        if(FAILED(hres))
           return WBEM_E_INVALID_PARAMETER;

        // array of bstrs or null, else bail
        if ((V_VT(&v) != (VT_BSTR | VT_ARRAY)) && (V_VT(&v) != VT_NULL))
        {
            VariantClear(&v);
            return WBEM_E_INVALID_PARAMETER;
        }
    
        if ((V_VT(&v) == VT_NULL) && (m_dwNumTemplates > 0))
            return WBEM_E_INVALID_PARAMETER;

        if (m_dwNumTemplates > 0)
        {
            CVarVector vv(VT_BSTR, V_ARRAY(&v));
            VariantClear(&v);

            if (vv.Size() < m_dwNumTemplates)
                return WBEM_E_INVALID_PARAMETER;

            m_aTemplates = new CTextTemplate[m_dwNumTemplates];
            if(m_aTemplates == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            for(DWORD i = 0; i < m_dwNumTemplates; i++)
            {
                m_aTemplates[i].SetTemplate(vv.GetAt(i).GetLPWSTR());
            }
        }
    }

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_DATANAME, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres) && (v.vt == VT_BSTR) && (v.bstrVal != NULL))
    {    
        m_dataName = v.bstrVal;
    }

    VariantClear(&v);

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_SIDNAME, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres) && (v.vt == VT_BSTR) && (v.bstrVal != NULL))
    {    
        m_sidName = v.bstrVal;
    }

    VariantClear(&v);

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_CREATORSID, 0, &v,
            NULL, NULL);

    if (SUCCEEDED(hres) && (v.vt != VT_NULL))
    {
        if((v.vt != (VT_ARRAY | VT_UI1)))
        {
          VariantClear(&v);
          return WBEM_E_INVALID_OBJECT;
        }
        
        long ubound;
        if(SUCCEEDED(hres = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound)))
        {
            PVOID pVoid;
            if(SUCCEEDED(hres = SafeArrayAccessData(V_ARRAY(&v), &pVoid)))
            {
                m_pSidCreator = new BYTE[ubound +1];
                if(m_pSidCreator == NULL)
                    hres = WBEM_E_OUT_OF_MEMORY;
                else
                    memcpy(m_pSidCreator, pVoid, ubound + 1);
        
                SafeArrayUnaccessData(V_ARRAY(&v));
            }
        }
    }
    VariantClear(&v);

    return hres;
}

HRESULT CEventLogSink::XSink::GetDatEmbeddedObjectOut(IWbemClassObject* pObject, WCHAR* objectName, IWbemClassObject*& pEmbeddedObject)
{
    HRESULT hr;
    
    VARIANT vObject;
    VariantInit(&vObject);
    
    hr = pObject->Get(objectName, 0, &vObject, NULL, NULL);

    if (FAILED(hr))
    {
        ERRORTRACE((LOG_ESS, "NT Event Log Consumer: could not retrieve %S, 0x%08X\n", objectName, hr));
    }
    else if ((vObject.vt != VT_UNKNOWN) || (vObject.punkVal == NULL) 
             || FAILED(vObject.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pEmbeddedObject)))
    {
        ERRORTRACE((LOG_ESS, "NT Event Log Consumer: %S is not an embedded object\n", objectName));
        hr = WBEM_E_INVALID_PARAMETER;
    }

    VariantClear(&vObject);

    return hr;

}

HRESULT CEventLogSink::XSink::GetDatDataVariant(IWbemClassObject* pEventObj, WCHAR* dataName, VARIANT& vData)
{
    WCHAR* propName = NULL;
    IWbemClassObject* pDataObj = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // parse out data name
    WCHAR* pDot;
    if (pDot = wcschr(dataName, L'.'))
    {
        // found a dot, we're dealing with an embedded object
        // mask out dot to make our life easier
        *pDot = L'\0';

        WCHAR* pNextDot;
        pNextDot = wcschr(pDot+1, L'.');
        
        if (pNextDot)
        // we have a doubly embedded object, that's as deep as we support
        {
            // we now have three prop names with nulls between
            *pNextDot = '\0';
            IWbemClassObject* pIntermediateObj = NULL;

            if (SUCCEEDED(hr = GetDatEmbeddedObjectOut(pEventObj, dataName, pIntermediateObj)))
            {
                hr = GetDatEmbeddedObjectOut(pIntermediateObj, pDot +1, pDataObj);                
                pIntermediateObj->Release();
            }

            propName = pNextDot +1;

            // put dot back
            *pDot = L'.';

            // put dot dot back back
            *pNextDot = L'.';

        }
        else
        // we have a singly embedded object. cool.
        {
            hr = GetDatEmbeddedObjectOut(pEventObj, dataName, pDataObj);

            // put dot back
            *pDot = L'.';
        
            propName = pDot +1;
        }
    }
    else
    {
        // not an embedded object
        pDataObj = pEventObj;
        pDataObj->AddRef();

        propName = dataName;
    }

    if (SUCCEEDED(hr) && pDataObj)
    {
        if (FAILED(hr = pDataObj->Get(propName, 0, &vData, NULL, NULL)))
            DEBUGTRACE((LOG_ESS, "NT Event Log Consumer: could not retrieve property '%S' 0x%08X\n", dataName, hr));
    }

    if (pDataObj)
        pDataObj->Release();

    return hr;
}

// assumes that dataName is a valid string
// retrieves data from event object
// upon return pData points at data contained in variant
// calls responsibility to clear variant (don't delete pData)
// void return, any errors are logged - we don't want to block an event log if we can avoid it
void CEventLogSink::XSink::GetDatData(IWbemClassObject* pEventObj, WCHAR* dataName, 
                                      VARIANT& vData, BYTE*& pData, DWORD& dataSize)
{
    pData = NULL;
    dataSize = 0;
    HRESULT hr;
    
    if (SUCCEEDED(GetDatDataVariant(pEventObj, dataName, vData)))
    {
        hr = VariantChangeType(&vData, &vData, 0, (VT_UI1 | VT_ARRAY));
        
        if (FAILED(hr) || (vData.vt != (VT_UI1 | VT_ARRAY)))
        {
            ERRORTRACE((LOG_ESS, "NT Event Log Consumer: %S cannot be converted to a byte array (0x%08X)\n", dataName, hr));
            VariantClear(&vData);
        }
        else
        // should be good to go!
        {            
            if (FAILED(hr = SafeArrayAccessData(vData.parray, (void**)&pData)))
            {
                ERRORTRACE((LOG_ESS, "NT Event Log Consumer: failed to access %S, 0x%08X\n", dataName, hr));
                VariantClear(&vData);
            }

            long lDataSize;
            SafeArrayGetUBound(vData.parray, 1, &lDataSize);
            dataSize = (DWORD)lDataSize + 1;
        }
    }
}

// assumes that dataName is a valid string
// retrieves data from event object
// void return, any errors are logged - we don't want to block an event log if we can avoid it
void CEventLogSink::XSink::GetDatSID(IWbemClassObject* pEventObj, WCHAR* dataName, PSID& pSid)
{
    HRESULT hr;

    VARIANT vData;
    VariantInit(&vData);

    pSid = NULL;
    
    if (SUCCEEDED(hr = GetDatDataVariant(pEventObj, dataName, vData)))
    {
        if (vData.vt == (VT_UI1 | VT_ARRAY))
        {
            BYTE* pData;
            
            // this should be a binary SID
            if (FAILED(hr = SafeArrayAccessData(vData.parray, (void**)&pData)))
                ERRORTRACE((LOG_ESS, "NT Event Log Consumer: failed to access %S, 0x%08X\n", dataName, hr));
            else
            {
                if (IsValidSid((PSID)pData))
                {
                    DWORD l = GetLengthSid((PSID)pData);
                    if (pSid = new BYTE[l])
                        CopySid(l, pSid, (PSID)pData);
                }
            }
        }
        else if ((vData.vt == VT_BSTR) && (vData.bstrVal != NULL))
        {            
            PSID pLocalSid;

            if (!ConvertStringSidToSid(vData.bstrVal, &pLocalSid))
                ERRORTRACE((LOG_ESS, "NT Event Log Consumer: cannot convert %S to a SID\n", vData.bstrVal));
            else
            {
                DWORD l = GetLengthSid(pLocalSid);
                if (pSid = new BYTE[l])
                    CopySid(l, pSid, pLocalSid);             
                FreeSid(pLocalSid);
            }
        }
        else
            ERRORTRACE((LOG_ESS, "NT Event Log Consumer: %S is not a SID\n", dataName));
    
        VariantClear(&vData);    
    }
}


HRESULT STDMETHODCALLTYPE CEventLogSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if (IsNT())
    {
        PSID pSidSystem;
        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
 
        if  (AllocateAndInitializeSid(&id, 1,
            SECURITY_LOCAL_SYSTEM_RID, 
            0, 0,0,0,0,0,0,&pSidSystem))
        {         
            // guilty until proven innocent
            hr = WBEM_E_ACCESS_DENIED;

            // check to see if sid is either Local System or an admin of some sort...
            if ((EqualSid(pSidSystem, m_pObject->m_pSidCreator)) ||
                (S_OK == IsUserAdministrator(m_pObject->m_pSidCreator)))
                hr = WBEM_S_NO_ERROR;
          
            // We're done with this
            FreeSid(pSidSystem);

            if (FAILED(hr))
                return hr;
        }
        else
            return WBEM_E_OUT_OF_MEMORY;
    }
    
    for(int i = 0; i < lNumObjects; i++)
    {
        int  j;
        BOOL bRes = FALSE;
        
        // Do all events use the same ID?
        if (m_pObject->m_dwEventId)
        {
            BSTR* astrStrings = new BSTR[m_pObject->m_dwNumTemplates];
            if(astrStrings == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            for(j = 0; j < m_pObject->m_dwNumTemplates; j++)
            {
                BSTR strText = m_pObject->m_aTemplates[j].Apply(apObjects[i]);
                if(strText == NULL)
                {
                    strText = SysAllocString(L"invalid log entry");
                    if(strText == NULL)
                    {
                        delete [] astrStrings;
                        return WBEM_E_OUT_OF_MEMORY;
                    }
                }
                astrStrings[j] = strText;
            }

            DWORD dataSize = NULL;
            
            // data is actually held in the variant
            // pData just makes access easier (clear the variant, don't delete pData!)
            VARIANT vData;
            VariantInit(&vData);
            BYTE *pData = NULL;

            PSID pSid = NULL;

            if (m_pObject->m_dataName.Length() > 0)
                GetDatData(apObjects[i], m_pObject->m_dataName, vData, pData, dataSize);

            if (m_pObject->m_sidName.Length() > 0)
                GetDatSID(apObjects[i], m_pObject->m_sidName, pSid);

            bRes = ReportEventW(m_pObject->m_hEventLog, m_pObject->m_dwType,
                m_pObject->m_dwCategory, m_pObject->m_dwEventId, pSid,
                m_pObject->m_dwNumTemplates, dataSize, 
                (LPCWSTR*)astrStrings, pData);

            // sid was allocated as an array of BYTE, not via AllocateAndInitializeSid
            if (pSid)
                delete[] pSid;
             
            if (vData.vt == (VT_UI1 | VT_ARRAY))
                SafeArrayUnaccessData(vData.parray);

            VariantClear(&vData);
            pData = NULL;

            if(!bRes)
            {
                ERRORTRACE((LOG_ESS, "Failed to log an event: %X\n", 
                    GetLastError()));

                hr = WBEM_E_FAILED;
            }


            for(j = 0; j < m_pObject->m_dwNumTemplates; j++)
            {
                SysFreeString(astrStrings[j]);
            }
            delete [] astrStrings;
        }
        // If each event supplies its own ID, we have some work to do.
        else
        {
            IWbemQualifierSet *pQuals = NULL;

            if (SUCCEEDED(apObjects[i]->GetQualifierSet(&pQuals)))
            {
                _variant_t vMsgID;
                
                if (SUCCEEDED(pQuals->Get(EVENTLOG_PROPNAME_EVENTID, 0, &vMsgID, NULL)) &&
                    ((vMsgID.vt == VT_BSTR) || (vMsgID.vt == VT_I4)))
                {
                    _variant_t vTemplates;
                    BSTR       *pstrInsertionStrings = NULL;
                    DWORD      nStrings = 0;

                    if (SUCCEEDED(pQuals->Get(
                        EVENTLOG_PROPNAME_STRINGS, 0, &vTemplates, NULL)) &&
                        vTemplates.vt == (VT_ARRAY | VT_BSTR) && 
                        vTemplates.parray->rgsabound[0].cElements > 0)
                    {
                        CTextTemplate *pTemplates;

                        nStrings = vTemplates.parray->rgsabound[0].cElements;
                        pTemplates = new CTextTemplate[nStrings];
                        if(pTemplates == NULL)
                            return WBEM_E_OUT_OF_MEMORY;
                    
                        pstrInsertionStrings = new BSTR[nStrings];
                        if(pstrInsertionStrings == NULL)
                        {
                            delete [] pTemplates;
                            return WBEM_E_OUT_OF_MEMORY;
                        }

                        if (pTemplates && pstrInsertionStrings)
                        {
                            BSTR *pTemplateStrings = (BSTR*) vTemplates.parray->pvData;

                            for (j = 0; j < nStrings; j++)
                            {
                                pTemplates[j].SetTemplate(pTemplateStrings[j]);
                                pstrInsertionStrings[j] = pTemplates[j].Apply(apObjects[i]);
                            }
                        }
                        else
                            nStrings = 0;

                        if (pTemplates)
                            delete [] pTemplates;
                    }

                    
                    DWORD      dwEventID,
                               dwType,
                               dwCategory;
                    _variant_t vTemp;
                    WCHAR      *szBad;

                    if (vMsgID.vt == VT_BSTR)
                        dwEventID = wcstoul(V_BSTR(&vMsgID), &szBad, 10);
                    else if (vMsgID.vt == VT_I4)
                        dwEventID = V_I4(&vMsgID);

                    if ((SUCCEEDED(pQuals->Get(EVENTLOG_PROPNAME_TYPE, 0, &vTemp, NULL))) &&
                        (V_VT(&vTemp) == VT_I4))
                        dwType = V_I4(&vTemp);
                    else
                        dwType = m_pObject->m_dwType;

                    if (SUCCEEDED(pQuals->Get(
                        EVENTLOG_PROPNAME_CATEGORY, 0, &vTemp, NULL)))
                        dwCategory = V_I4(&vTemp);
                    else
                        dwCategory = m_pObject->m_dwCategory;

                    DWORD dataSize = NULL;
                    // data is actually held in the variant
                    // pData just makes access easier (clear the variant, don't delete pData!)
                    VARIANT vData;
                    VariantInit(&vData);
                    BYTE *pData = NULL;
                    PSID pSid = NULL;

                    if (m_pObject->m_dataName.Length() > 0)
                        GetDatData(apObjects[i], m_pObject->m_dataName, vData, pData, dataSize);

                    if (m_pObject->m_sidName.Length() > 0)
                        GetDatSID(apObjects[i], m_pObject->m_sidName, pSid);

                    bRes =
                        ReportEventW(
                            m_pObject->m_hEventLog, 
                            dwType,
                            dwCategory, 
                            dwEventID, 
                            pSid,
                            nStrings, 
                            dataSize, 
                            (LPCWSTR*) pstrInsertionStrings, 
                            pData);

                    // sid was allocated as an array of BYTE, not via AllocateAndInitializeSid
                    if (pSid)
                        delete[] pSid;

                    if (vData.vt == (VT_UI1 | VT_ARRAY))
                        SafeArrayUnaccessData(vData.parray);

                    VariantClear(&vData);
                    pData = NULL;

                    if (!bRes)
                    {
                        ERRORTRACE((LOG_ESS, "Failed to log an event: %X\n", 
                            GetLastError()));

                        hr = WBEM_E_FAILED;
                    }

                    for (j = 0; j < nStrings; j++)
                        SysFreeString(pstrInsertionStrings[j]);

                    delete [] pstrInsertionStrings;

                } // SUCCEEDED(Get)
                
                pQuals->Release();
            
            } // SUCCEEDED(GetQualifierSet)
        }

    }

    return hr;
}
    

    

void* CEventLogSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\precomp.h ===
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\logfile.h ===
#ifndef __WBEM_LOGFILE_CONSUMER__H_
#define __WBEM_LOGFILE_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include <ErrorObj.h>

#include "txttempl.h"
#include <stdio.h>

class CLogFileConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CLogFileConsumer>
    {
    public:
        XProvider(CLogFileConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CLogFileConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CLogFileConsumer>
    {
    public:
        XInit(CLogFileConsumer* pObj)
            : CImpl<IWbemProviderInit, CLogFileConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;


public:
    CLogFileConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this)
    {}
    ~CLogFileConsumer(){}
    void* GetInterface(REFIID riid);
};


class CLogFileSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CLogFileSink>
    {
    public:
        XSink(CLogFileSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CLogFileSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    CTextTemplate m_Template;
    WString m_wsFile;

    // determines whether file is too large, archives old if needed
    // probably returns INVALID_HANDLE_VALUE on error
    HRESULT GetFileHandle(HANDLE& handle);

    // don't access this directly. use GetFileHandle
	HANDLE m_hFile;

    ErrorObj* m_pErrorObj;

    bool  m_bUnicode;     // do the file be unicode?
    UINT64 m_maxFileSize;

    bool IsFileTooBig(UINT64 maxFileSize, HANDLE hFile);
	bool IsFileTooBig(UINT64 maxFileSize, WString& fileName);
    HRESULT ArchiveFile(WString& fileName);
    bool GetNumericExtension(WCHAR* pName, int& foundNumber);

	void OpenThisFile(WString fname, bool openExisting, bool allowDelete);
	void CloseCurrentFile();




public:
    CLogFileSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this),m_pErrorObj(NULL),  
		   m_hFile(INVALID_HANDLE_VALUE), 
           m_maxFileSize(0), m_bUnicode(false)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CLogFileSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\logfile.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <io.h>
#include <wbemutil.h>
#include <GroupsForUser.h>
#include <ArrTempl.h>
#include <GenUtils.h>
#include <ErrorObj.h>
#include "logfile.h"
#include <sync.h>
#include <statsync.h>
#include <errno.h>
#include <strsafe.h>

#define LOGFILE_PROPNAME_FILENAME L"Filename"
#define LOGFILE_PROPNAME_TEXT L"Text"
#define LOGFILE_PROPNAME_MAX_SIZE L"MaximumFileSize"
#define LOGFILE_PROPNAME_IS_UNICODE L"IsUnicode"

const char ByteOrderMark[2] = {'\xFF','\xFE'};

CStaticCritSec fileLock;

HRESULT STDMETHODCALLTYPE CLogFileConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    // Create a new sink
    // =================

    CLogFileSink* pSink = new CLogFileSink(m_pObject->m_pControl);
    if (!pSink)
        return WBEM_E_OUT_OF_MEMORY;

    // Initialize it
    // =============

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }

    // return it

    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


HRESULT STDMETHODCALLTYPE CLogFileConsumer::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink* pSink)
{
    pSink->SetStatus(0, 0);
    return 0;
}
    

void* CLogFileConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

CLogFileSink::~CLogFileSink()
{
    if(m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    if (m_pErrorObj)
        m_pErrorObj->Release();
}

// determine whether file needs to be backed up
// returns false if we are not expected to back up file
bool CLogFileSink::IsFileTooBig(UINT64 maxFileSize, HANDLE hFile)
{   
    bool bRet = false;

    // zero is interpreted to mean 'Let it grow without bounds'
    if (maxFileSize > 0)
    {    
		LARGE_INTEGER size;

		if (GetFileSizeEx(hFile, &size))
			bRet = size.QuadPart > maxFileSize;
    }

    return bRet;
}

bool CLogFileSink::IsFileTooBig(UINT64 maxFileSize, WString& fileName)
{
    bool bRet = false;

    // zero is interpreted to mean 'Let it grow without bounds'
    if (maxFileSize > 0)
    {
        struct _wfinddatai64_t foundData;

        __int64 handle;
        handle = _wfindfirsti64( (wchar_t *)fileName, &foundData);
        if (handle != -1l)
        {
            bRet = foundData.size >= maxFileSize;
            _findclose(handle);
        }
    }

    return bRet;
}


bool CLogFileSink::GetNumericExtension(WCHAR* pName, int& foundNumber)
{
    WCHAR foundExtension[_MAX_EXT];
    _wsplitpath(pName, NULL, NULL, NULL, foundExtension);
    
    return (swscanf(foundExtension, L".%d", &foundNumber) == 1);
}

// makes backup of file
// file must be closed when this is called
HRESULT CLogFileSink::ArchiveFile(WString& fullName)
{    
	// first, let's make sure the dang file actually exists...
    struct _wfinddatai64_t foundData;
    __int64 findHandle;
   if ((findHandle = _wfindfirsti64( fullName, &foundData)) == -1i64)
   {
        if (GetLastError() == ENOENT)
            return WBEM_S_NO_ERROR;
        else
            return WBEM_E_FAILED;
   }
   else
       _findclose(findHandle);

    
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fname[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];

    // warning: reused, it'll be the mask for the lookup
    // then it'll be the new file name.
    WCHAR pathBuf[MAX_PATH +1];
    
    _wsplitpath( (const wchar_t *)fullName, drive, dir, fname, ext );

    bool bItEightDotThree = (wcslen(fname) <= 8) && (wcslen(ext) <= 4);
    // eightdot three file names are backed up to name.###
    // NON eight dotthree are backed up to name.ext.###

    // build mask for lookup
    StringCchCopyW(pathBuf, MAX_PATH+1, drive);
    StringCchCatW(pathBuf,  MAX_PATH+1, dir);
    StringCchCatW(pathBuf,  MAX_PATH+1, fname);

    if (!bItEightDotThree)
    {
        // there's a possibility that the filename would be too long
        // if we appended four chars.  Will trunc if needed
        if ((wcslen(pathBuf) + wcslen(ext) + 4) > MAX_PATH)
        {
            // see if we can get away with just dropping the ext
            if ((wcslen(pathBuf) + 4) > MAX_PATH)
                pathBuf[MAX_PATH -4] = L'\0';
        }
        else
        // everything fits, no trunc needed
            StringCchCatW(pathBuf, MAX_PATH+1, ext);
    }
    // and the dotstar goes on the end, no matter what.
    StringCchCatW(pathBuf, MAX_PATH+1, L".*");

    // pathbuf is now the proper mask to lookup stuff.
    int biggestOne = 0; 
    bool foundOne = false;
    bool foundOnes[1000];
    // keep track of which ones we found
    // just in case we have to go back & find a hole
    // using 1000 so I don't have to convert all the time.
    ZeroMemory(foundOnes, sizeof(bool) * 1000);

    if ((findHandle = _wfindfirsti64( pathBuf, &foundData)) != -1i64)
    {
        int latestOne;

        if (foundOne = GetNumericExtension(foundData.name, latestOne))
        {
            if (latestOne <= 999)
            {
                foundOnes[latestOne] = true;
                if (latestOne > biggestOne)
                    biggestOne = latestOne;
            }
        }

        while (0 == _wfindnexti64(findHandle, &foundData))
        {
            if (GetNumericExtension(foundData.name, latestOne) && (latestOne <= 999))
            {   
                foundOne = true;
                foundOnes[latestOne] = true;
                if (latestOne > biggestOne)
                    biggestOne = latestOne;
            }
        }

        _findclose(findHandle);
    }

    int newExt = -1;

    if (foundOne)
        if (biggestOne < 999)
            newExt = biggestOne + 1;
        else
        {
            newExt = -1;

            // see if there's a hole somewhere
            for (int i = 1; i <= 999; i++)
                if (!foundOnes[i]) 
                {
                    newExt = i;
                    break;
                }
        }
    
    WCHAR *pTok;
    pTok = wcschr(pathBuf, L'*');

	// "can't happen" - the asterisk is added approximately 60 lines up
	// however, we'll go ahead & do the check - will make PREFIX happy if nothing else.
	if (!pTok)
		return WBEM_E_CRITICAL_ERROR;

    if (newExt != -1)
    {
        // calc how much buffer we have past the end of pTok...
        int nTokStrLen = MAX_PATH - (pTok - pathBuf) -1;

        // construct new name
        // we want to replace the * with ###
        StringCchPrintf(pTok, nTokStrLen, L"%03d", newExt);
        //swprintf(pTok, L"%03d", newExt);
    }
    else
    // okay, we'll hammer an old file
    {
        // calc how much buffer we have past the end of pTok...
        int nTokStrLen = MAX_PATH - (pTok - pathBuf) -1;
        StringCchCopy(pTok, nTokStrLen, L"001");  

        _wremove(pathBuf);
    }
    
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bRet;
	//int retval = _wrename(fullName, pathBuf);
	{
		bRet = MoveFile(fullName, pathBuf);
	}
	
	if (!bRet)
	{
        DWORD err = GetLastError();
        m_pErrorObj->ReportError(L"MoveFile", fullName, NULL, err, true);
        
		ERRORTRACE((LOG_ESS, "MoveFile failed 0x%08X\n", err));
		hr = WBEM_E_FAILED;
	}

    return hr;
}


// determines whether file is too large, archives old if needed
// use this function rather than accessing the file pointer directly
HRESULT CLogFileSink::GetFileHandle(HANDLE& handle)
{
	CInCritSec lockMe(&fileLock);
    
    // assume the worst
    HRESULT hr = WBEM_E_FAILED;
    handle = INVALID_HANDLE_VALUE;

    // check for whether we have to archive file
    // (use handle if open, else use filename)
    if (m_hFile != INVALID_HANDLE_VALUE)
	{

		if (IsFileTooBig(m_maxFileSize, m_hFile))
		{
			// two possibilities: we have ahold of logfile.log OR we've got logfile.001			
			
			CloseHandle(m_hFile);
			m_hFile = INVALID_HANDLE_VALUE;
			
			hr = WBEM_S_NO_ERROR;
			if (IsFileTooBig(m_maxFileSize, m_wsFile))
				 hr = ArchiveFile(m_wsFile);

			if (FAILED(hr))
				return hr;
		}
	}
	else
	{
		
		if (IsFileTooBig(m_maxFileSize, m_wsFile))
		{
			hr = ArchiveFile(m_wsFile);
			if (FAILED(hr))
				return hr;
		}	
	}
    
    
    if (m_hFile != INVALID_HANDLE_VALUE)    
    {
        // got a good file, we're good to go
        handle = m_hFile;
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        // Open the file
     
        // we'll try opening an existing file first

		m_hFile = CreateFile(m_wsFile, GENERIC_READ | GENERIC_WRITE, 
			                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);


        
        if(m_hFile != INVALID_HANDLE_VALUE)
        {
            if (FILE_TYPE_DISK != GetFileType(m_hFile))
            {
                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
                m_pErrorObj->ReportError(L"CreateFile", m_wsFile, NULL, WBEM_E_ACCESS_DENIED, false);

                return WBEM_E_ACCESS_DENIED;
            }

            // now, take a looksee and determine whether the existing file is unicode
            // *regardless* of what the flag says
            char readbuf[2] = {'\0','\0'};
			DWORD bytesRead;
            
            // if (fread(&readbuf, sizeof(WCHAR), 1, m_pFile) > 0)
			if (ReadFile(m_hFile, &readbuf, sizeof(WCHAR), &bytesRead, NULL) &&
			    (bytesRead == sizeof(WCHAR)))
            {
                // only interesting cases are those where the flag
                // doesn't match what's in the file...
                if ((readbuf[0] == ByteOrderMark[0]) && (readbuf[1] == ByteOrderMark[1])
					&& !m_bUnicode)
                    m_bUnicode = true;
                else if (((readbuf[0] != ByteOrderMark[0]) || (readbuf[1] != ByteOrderMark[1])) && m_bUnicode)
                    m_bUnicode = false;
            }

            // line up at the end of the file
            SetFilePointer(m_hFile, 0,0, FILE_END); 

            handle = m_hFile;
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            // ahhh - it wasn't there, for whatever reason.
			m_hFile = CreateFile(m_wsFile, GENERIC_READ | GENERIC_WRITE, 
			                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							 NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

            if (m_hFile != INVALID_HANDLE_VALUE)
            {				
                if (FILE_TYPE_DISK != GetFileType(m_hFile))
                {
                    CloseHandle(m_hFile);
                    m_hFile = INVALID_HANDLE_VALUE;
                    m_pErrorObj->ReportError(L"CreateFile", m_wsFile, NULL, WBEM_E_ACCESS_DENIED, false);

                    return WBEM_E_ACCESS_DENIED;
                }
                
                DWORD bytesWryt;
                if (m_bUnicode)
				{
					if (0 == WriteFile(m_hFile, (LPCVOID)ByteOrderMark, 2, &bytesWryt, NULL))
						ERRORTRACE((LOG_ESS, "Failed to write byte order mark to log file 0x%08X\n", GetLastError()));
				}

                handle = m_hFile;
                hr = WBEM_S_NO_ERROR;

            }
            else
            {
                DWORD dwError = GetLastError();
                m_pErrorObj->ReportError(L"CreateFile", m_wsFile, NULL, dwError, true);

                ERRORTRACE((LOG_ESS, "Unable to open log file %S, [0x%X]\n", (LPWSTR)m_wsFile, dwError));
            }
        }
    }

    return hr;
}

// initialize members, do security check.
// a tidier programmer would probably move the security check to a separate function
HRESULT CLogFileSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // this is actually a pointer to a static object
    // if it fails, something is Very, Very Wrong.
    m_pErrorObj = ErrorObj::GetErrorObj();
    if (!m_pErrorObj)
        return WBEM_E_CRITICAL_ERROR;

    
    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_FILENAME, 0, &v, NULL, NULL);
    if (FAILED(hres) || (V_VT(&v) != VT_BSTR) || (v.bstrVal == NULL))
    {
        VariantClear(&v);
        return WBEM_E_INVALID_PARAMETER;
    }

    size_t length;
    length = wcslen(v.bstrVal);
    if ((length > MAX_PATH) || (length == 0))
    {
        VariantClear(&v);
        return WBEM_E_INVALID_PARAMETER;                                 
    }

    m_wsFile = V_BSTR(&v);

    // check for disallowed filenames
    VariantClear(&v);
    m_wsFile.StripWs(WString::leading);
    if (m_wsFile.Length() == 0)
        return WBEM_E_INVALID_PARAMETER;

    // UNC global file names: no-no.
    if (wcsstr(m_wsFile, L"\\\\.")
        ||
       wcsstr(m_wsFile, L"//.")
        ||
       wcsstr(m_wsFile, L"\\\\??")
        || 
       wcsstr(m_wsFile, L"//??"))
    {
        m_pErrorObj->ReportError(L"CLogFileSink::Initialize", m_wsFile, L"Filename", WBEM_E_ACCESS_DENIED, true);
        return WBEM_E_ACCESS_DENIED;
    }

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_TEXT, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        VariantClear(&v);
        return WBEM_E_INVALID_PARAMETER;
    }
    m_Template.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_IS_UNICODE, 0, &v, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;
    else if (V_VT(&v) == VT_BOOL)
        m_bUnicode = v.boolVal == VARIANT_TRUE;
    else if (V_VT(&v) == VT_NULL)
        m_bUnicode = false;
    else
        return WBEM_E_INVALID_PARAMETER;
    VariantClear(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_MAX_SIZE, 0, &v, NULL, NULL);

    if (FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;
    else if (V_VT(&v) == VT_BSTR)
    {
        if (!ReadUI64(V_BSTR(&v), m_maxFileSize))
           return WBEM_E_INVALID_PARAMETER;
    }
    else if (V_VT(&v) == VT_NULL)
        m_maxFileSize = 65535;
    else
        return WBEM_E_INVALID_PARAMETER;
        
    VariantClear(&v);

    // Determine whether user has rights to file
    // =========================================
    // first determine who is our creator...
    hres = pLogicalConsumer->Get(L"CreatorSid", 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres))
    {
        HRESULT hDebug = WBEM_E_FAILED;
        long ubound = 0;
        PSID pSidCreator = NULL;
        PVOID pVoid = NULL;

        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);
        if(FAILED(hDebug)) return hDebug;

        hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);
        if(FAILED(hDebug)) return hDebug;

        pSidCreator = new BYTE[ubound +1];
        if (pSidCreator)
            memcpy(pSidCreator, pVoid, ubound + 1);
        else
        {
            VariantClear(&v);
            SafeArrayUnaccessData(V_ARRAY(&v));
            return WBEM_E_OUT_OF_MEMORY;
        }

        CDeleteMe<BYTE> deleteTheCreator((BYTE*)pSidCreator);
        SafeArrayUnaccessData(V_ARRAY(&v));

        VariantClear(&v);

        BOOL bIsSystem;
        // check to see if the creator is The System
        {
            PSID pSidSystem;
            SID_IDENTIFIER_AUTHORITY sa = SECURITY_NT_AUTHORITY;
            if (AllocateAndInitializeSid(&sa, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &pSidSystem))
            {
                bIsSystem = EqualSid(pSidCreator, pSidSystem);
                FreeSid(pSidSystem);
            }
            else 
                return WBEM_E_FAILED;
        }
        
        if (bIsSystem)
            // creator is local system, let him in.
            hres = WBEM_S_NO_ERROR;
        else
        {
            DWORD dwSize;
            WString fNameForCheck = m_wsFile;
            // call once to see how big a buffer we might need
            GetFileSecurityW(fNameForCheck, DACL_SECURITY_INFORMATION, NULL, 0, &dwSize);
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_INVALID_NAME)
            {
                m_pErrorObj->ReportError(L"GetFileSecurity", (WCHAR*)fNameForCheck, NULL, dwErr, true);
                return WBEM_E_INVALID_PARAMETER;
            }
            else if (dwErr == ERROR_FILE_NOT_FOUND)
            // no file - see if directory exists
            {
                WCHAR drive[_MAX_DRIVE];
                WCHAR dir[_MAX_DIR];
                _wsplitpath( m_wsFile,drive, dir, NULL, NULL);
                WCHAR path[MAX_PATH];
                StringCchCopy(path, MAX_PATH, drive);
                StringCchCat(path, MAX_PATH, dir);

                fNameForCheck = path;
                GetFileSecurityW(fNameForCheck, DACL_SECURITY_INFORMATION, NULL, 0, &dwSize);
                dwErr = GetLastError();
            }
            // we don't bother trying to create the directory.
            if ((dwErr == ERROR_FILE_NOT_FOUND)  || (dwErr == ERROR_PATH_NOT_FOUND) || (dwErr == ERROR_INVALID_NAME))
            {
                m_pErrorObj->ReportError(L"GetFileSecurity", m_wsFile, NULL, dwErr, true);
                return WBEM_E_INVALID_PARAMETER;
            }
            if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return WBEM_E_FAILED;
        
            PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
            if (!psd)
                return WBEM_E_OUT_OF_MEMORY;

            CDeleteMe<BYTE> delSD((BYTE *)psd);

        
            PACL pDacl = NULL;
            BOOL bDaclPresent, bDaclDefaulted;
            // retrieve file's security, if any
            if (GetFileSecurityW(fNameForCheck, DACL_SECURITY_INFORMATION, psd, dwSize, &dwSize) &&
                GetSecurityDescriptorDacl(psd, &bDaclPresent, &pDacl, &bDaclDefaulted))
            {
                if (bDaclPresent && pDacl)
                {
                    DWORD accessMask;
                    if (S_OK == GetAccessMask(pSidCreator, pDacl, &accessMask))
                    {
                        DWORD rightAccess = FILE_WRITE_DATA;

                        if (accessMask & rightAccess)
                            hres = WBEM_S_NO_ERROR;
                        else
                            hres = WBEM_E_ACCESS_DENIED;
                    }
                    else
                        return WBEM_E_ACCESS_DENIED;
                }
            }
            else
                return WBEM_E_FAILED;
        }

    }
    
    return hres;
}

HRESULT STDMETHODCALLTYPE CLogFileSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    for(int i = 0; i < lNumObjects; i++)
    {
        // Apply the template to the event
        // ===============================
        BSTR strText = m_pObject->m_Template.Apply(apObjects[i]);
        if(strText == NULL)
            strText = SysAllocString(L"invalid log entry");
        if (strText == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CSysFreeMe freeString(strText);

        HANDLE hFile = INVALID_HANDLE_VALUE; 
        HRESULT hr = m_pObject->GetFileHandle(hFile);

        if (SUCCEEDED(hr))
        {
            if (m_pObject->m_bUnicode)
            {
				CInCritSec lockMe(&fileLock);
				WCHAR EOL[] = L"\r\n";

                // make sure we're at the end, in case of multiple writers
	            SetFilePointer(hFile, 0,0, FILE_END);        

				DWORD bitzwritz;
				if (!WriteFile(hFile, strText, wcslen(strText) *2, &bitzwritz, NULL) ||
					!WriteFile(hFile, EOL, wcslen(EOL) *2, &bitzwritz, NULL))
				{
					DWORD dwErr = GetLastError();
                    
                    m_pObject->m_pErrorObj->ReportError(L"WriteFile", strText, NULL, dwErr, true);
                    ERRORTRACE((LOG_ESS, "LOGFILE: Failed to write to file, 0x%08X\n", dwErr));

					return WBEM_E_FAILED;
				}
            }
            else
            {
                // convert to mbcs
                char* pStr = new char[wcslen(strText) *2 +1];
                
                if (!pStr)
                    return WBEM_E_OUT_OF_MEMORY;
                // else...
                CDeleteMe<char> delStr(pStr);

                
                if (0 == WideCharToMultiByte(CP_THREAD_ACP, WC_DEFAULTCHAR | WC_COMPOSITECHECK, strText, -1, pStr, wcslen(strText) *2 +1, NULL, NULL))
                {
                    ERRORTRACE((LOG_ESS, "LOGFILE: Unable to convert \"%S\" to MBCS, failing\n", strText));
                    return WBEM_E_FAILED;
                }
                else
    			{
					CInCritSec lockMe(&fileLock);

					char EOL[] = "\r\n";

					// make sure we're at the end, in case of multiple writers
					SetFilePointer(hFile, 0,0, FILE_END);        

					DWORD bitzwritz;
					if (!WriteFile(hFile, pStr, strlen(pStr), &bitzwritz, NULL) ||
						!WriteFile(hFile, EOL, strlen(EOL), &bitzwritz, NULL))
					{
    					DWORD dwErr = GetLastError();
                        
                        m_pObject->m_pErrorObj->ReportError(L"WriteFile", strText, NULL, dwErr, true);
                        ERRORTRACE((LOG_ESS, "LOGFILE: Failed to write to file, 0x%08X\n", dwErr));

						return WBEM_E_FAILED;
					}
				}
            }            
        }
        else
            return hr;
    }
    return S_OK;
}
    

    

void* CLogFileSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\main.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include "logfile.h"
#include "cmdline.h"
#include "evtlog.h"
#include "ProcKiller.h"


#include <tchar.h>

const CLSID CLSID_WbemLogFileConsumer = 
    {0x266c72d4,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

const CLSID CLSID_WbemCommandLineConsumer = 
    {0x266c72e5,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

const CLSID CLSID_WbemNTEventLogConsumer = 
    {0x266c72e6,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

#ifdef INCLUDE_NON_PULSAR

    const CLSID CLSID_WbemPerformanceConsumer = 
        {0x266c72f8,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

    const CLSID CLSID_WbemMsgBoxConsumer = 
        {0x266c72d2,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

    // {C7A3A54A-0250-11d3-9CD1-00105A1F4801}
    const CLSID CLSID_WbemPagerConsumer = 
    { 0xc7a3a54a, 0x250, 0x11d3, { 0x9c, 0xd1, 0x0, 0x10, 0x5a, 0x1f, 0x48, 0x1 } };

#endif

//const CLSID CLSID_WbemEmailConsumer = 
//    {0x266c72d3,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

class CMyServer : public CComServer
{
public: 

#ifdef ENABLE_REMOTING
	void RegisterMe(CLSID clsID, WCHAR* name)
	{    
        WCHAR      wcID[128];
        WCHAR      szKeyName[128];
        HKEY       hKey;

        // open/create registry entry under CLSID
        StringFromGUID2(clsID, wcID, 128);
        StringCchCopyW(szKeyName, 128, TEXT("SOFTWARE\\Classes\\CLSID\\"));
        StringCchCatW(szKeyName, 128, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        
        // set AppID
        RegSetValueEx(hKey, L"AppID", 0, REG_SZ, (BYTE*)wcID, 2*(wcslen(wcID) +1));
        RegCloseKey(hKey);

        // make appID entry w/ DLLSurrogate value
        StringCchCopyW(szKeyName, 128, TEXT("SOFTWARE\\Classes\\APPID\\"));
        StringCchCatW(szKeyName, 128, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        RegSetValueEx(hKey, L"DllSurrogate", 0, REG_SZ, (BYTE*)L"\0", 2);

        // and a nice name
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)name, 2*(wcslen(name) +1));
        RegCloseKey(hKey);
	}

    // provider server specific registration
    virtual void Register()
    {
		RegisterMe(CLSID_WbemLogFileConsumer, L"Microsoft WBEM Log File Event Consumer Provider");
		RegisterMe(CLSID_WbemCommandLineConsumer, L"Microsoft WBEM Command Line Event Consumer Provider");
		RegisterMe(CLSID_WbemNTEventLogConsumer, L"Microsoft WBEM NT Event Log Event Consumer Provider");
		
#ifdef INCLUDE_NON_PULSAR

		// NOTE: Of the non-pulsar componenets,
        //       Only the pager consumer is registered for remote activation
		//		 MessageBox & Performance consumer are not
		RegisterMe(CLSID_WbemPagerConsumer, L"Microsoft WBEM Pager Event Consumer Provider");


#endif // INCLUDE_NON_PULSAR


    }

	void UnregisterMe(CLSID clsID)
	{
		WCHAR      wcID[128];
        HKEY       hKey;

		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\APPID\\"), &hKey))
		{
			if (0 != StringFromGUID2(clsID, wcID, 128))
			{
				RegDeleteKey(hKey, wcID);
			}
			RegCloseKey(hKey);
		}

	}
	
	virtual void Unregister()
	{
		UnregisterMe(CLSID_WbemLogFileConsumer);
		UnregisterMe(CLSID_WbemCommandLineConsumer);
		UnregisterMe(CLSID_WbemNTEventLogConsumer);

#ifdef INCLUDE_NON_PULSAR

		// NOTE: Of the non-pulsar componenets,
        //       Only the pager consumer is registered for remote activation
		//		 MessageBox & Performance consumer are not
		UnregisterMe(CLSID_WbemPagerConsumer);

#endif // INCLUDE_NON_PULSAR


	}
#endif //ENABLE_REMOTING


protected:
    HRESULT Initialize()
    {
        g_procKillerTimer.Initialize(GetLifeControl());

        AddClassInfo(CLSID_WbemLogFileConsumer, 
            new CClassFactory<CLogFileConsumer>(GetLifeControl()),
            _T("Log File Event Consumer Provider"), TRUE);
        AddClassInfo(CLSID_WbemCommandLineConsumer, 
            new CClassFactory<CCommandLineConsumer>(GetLifeControl()), 
            _T("Command Line Event Consumer Provider"), TRUE);
        AddClassInfo(CLSID_WbemNTEventLogConsumer, 
            new CClassFactory<CEventLogConsumer>(GetLifeControl()), 
            _T("NT Event Log Event Consumer Provider"), TRUE);

#ifdef INCLUDE_NON_PULSAR
        AddClassInfo(CLSID_WbemMsgBoxConsumer, 
            new CClassFactory<CMsgBoxConsumer>(GetLifeControl()),
            "Message Box Event Consumer Provider", TRUE);

        AddClassInfo(CLSID_WbemPerformanceConsumer, 
            new CClassFactory<CPerfConsumer>(GetLifeControl()), 
            "Performance measurement Event Consumer Provider", TRUE);
        AddClassInfo(CLSID_WbemPagerConsumer,
            new CClassFactory<CPagerConsumer>(GetLifeControl()), 
            "Pager Event Consumer Provider", TRUE);
#endif // INCLUDE_NON_PULSAR
        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\prockiller.cpp ===
#include "precomp.h"
#include "ProcKiller.h"

// the only one we'll ever need
CProcKillerTimer g_procKillerTimer;

// terminate process
void CProcKiller::Die()
{
    bool bDoIt = true;
    DWORD exitCode;
    
    // sleazy attempt to ensure that the proc is still running when we try to kill it
    // proc could still terminate on its own in the interim.
    if (GetExitCodeProcess(m_hProc, &exitCode))
        bDoIt = (exitCode == STILL_ACTIVE); 
    
    if (bDoIt)
        TerminateProcess(m_hProc, 1);
    
    CloseHandle(m_hProc);
    m_hProc = NULL;
}


// hVictim is a handle to a process
// last meal is the scheduled execution date
HRESULT CProcKillerTimer::ScheduleAssassination(HANDLE hVictim, FILETIME lastMeal)
{
    HRESULT hr = WBEM_E_FAILED;

    CProcKiller* pKiller;
    // gotta dup the handle - caller may close it.
    HANDLE hMyHandle;

    if (DuplicateHandle(GetCurrentProcess(), hVictim, GetCurrentProcess(), &hMyHandle, 0, false, DUPLICATE_SAME_ACCESS))
	{
		if (pKiller = new CProcKiller(hMyHandle, lastMeal, m_pControl))
		{
			hr = CKillerTimer::ScheduleAssassination(pKiller);
		}
		else
		{
			// allocation failed
			CloseHandle(hMyHandle);
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		ERRORTRACE((LOG_ESS, "DuplicateHandle failed, 0x%08X\n", GetLastError()));
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\prockiller.h ===
#ifndef __PROC_KILLER_COMPILED__
#define __PROC_KILLER_COMPILED__

#include "KillTimer.h"

// only need one of these laying around
class CProcKillerTimer;
extern CProcKillerTimer g_procKillerTimer;

// specialized to kill processes
class CProcKillerTimer : public CKillerTimer
{
public:
    
    // who to kill & when
    HRESULT ScheduleAssassination(HANDLE hVictim, FILETIME lastMeal);            
};

/* CLASS CProcKiller DEFINITION */

// hold process that needs to be killed
// owner of process handle, responsible for closing it
class CProcKiller : public CKiller
{
public:
    CProcKiller(HANDLE hProc, FILETIME deathDate, CLifeControl* pControl) :
      CKiller(deathDate, pControl), m_hProc(hProc)
        {
        }

    virtual ~CProcKiller()
    {
        // we don't kill off the process if we're shutdown prematurely
        if (m_hProc)
            CloseHandle(m_hProc);
    }

    // terminate process, 
    virtual void Die();

protected:

private:
    HANDLE m_hProc;

};

#endif //__PROC_KILLER_COMPILED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\datep.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#include <windows.h>
#include <comdef.h>
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>

#include "dnf.h"
#include "datep.h"

/******************************************************************/


COrderedUniqueSet64::COrderedUniqueSet64(void)
{
  m_BitField = SETEMPTY;
}

COrderedUniqueSet64 COrderedUniqueSet64::Set(ULONGLONG n)
{
  m_BitField = n;

 return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Add(ULONGLONG n) 
{ 
  ULONGLONG iBit = SETMIN;

  if((n <= 63))
    m_BitField |= iBit << n;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Remove(ULONGLONG n)
{
  ULONGLONG iBit = SETMIN;

  if((n >= 1) && (n <= 64))
    m_BitField &= ~(iBit << n);

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Union(COrderedUniqueSet64 n)
{
  m_BitField |= n.m_BitField;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Intersection(COrderedUniqueSet64 n)
{
  m_BitField &= n.m_BitField;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::UpperBound(ULONGLONG n)
{
  if((n <= 63))
  {
    n = 63 - n;
    m_BitField = (m_BitField << n) >> n;
  }

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::LowerBound(ULONGLONG n)
{
  if((n <= 63))
    m_BitField = (m_BitField >> n) << n;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Rotate(int n)
{
  while(n > 64) n -= 64;
  while(n < 0) n += 64;

  m_BitField = (m_BitField << n) | (m_BitField >> (64 - n));

  return *this;
}

BOOL COrderedUniqueSet64::Member(ULONGLONG n)
{
  return ((n <= 63) ? m_BitField & (SETMIN << n) : 0);
}

unsigned COrderedUniqueSet64::Next(ULONGLONG n)
{
  ULONGLONG nStart = n;
  ULONGLONG 
    SetValue = SETMIN << n;

  if(0x0 == m_BitField)
    return -1;

  while(! (SetValue & m_BitField))
  {
    SetValue <<= 1;
    n++;

    if(SETEMPTY == SetValue)
    {
      SetValue = SETMIN;
      n = 0;
    }
  }

  return (unsigned)n;
}

unsigned COrderedUniqueSet64::Prev(ULONGLONG n)
{
  ULONGLONG nStart = n;
  ULONGLONG SetValue = SETMIN << n;

  if(0x0 == m_BitField)
    return -1;

  while(! (SetValue & m_BitField))
  {
    SetValue >>= 1;
    n--;

    if(SETEMPTY == SetValue)
    {
      SetValue = SETMAX;
      n = 63;
    }
  }

  return (unsigned)n;
}

/******************************************************************/

unsigned CPattern::GetNextValue(unsigned NextValue)
{
  unsigned i;

  // **** perform quick sanity check 

  if((m_FieldsUsed & LOWERBOUND) && 
     (m_FieldsUsed & UPPERBOUND) &&
     (m_UpperBound < m_LowerBound))
    return -1;
  
  if(m_FieldsUsed & EQUALTO)
  {
    if(NextValue > m_EqualTo)
      return -1;
    else
      NextValue = m_EqualTo;

    // **** perform sanity checks for equality

    if((m_FieldsUsed & LOWERBOUND) &&
       (m_EqualTo < m_LowerBound))
      return -1;

    if((m_FieldsUsed & UPPERBOUND) &&
       (m_EqualTo > m_UpperBound))
      return -1;

    if(m_FieldsUsed & NOTEQUALTO)
    {
      for(i = 0; i < m_CountNotEqualTo; i++)
        if(NextValue == m_NotEqualTo[i])
          return -1;
    }
  }
  else
  {
    if(m_FieldsUsed & LOWERBOUND)
    {
      if(NextValue < m_LowerBound)
        NextValue = m_LowerBound;
    }

    if(m_FieldsUsed & NOTEQUALTO)
    {
      int
        YearGotBumpedUp = 1;

      while(YearGotBumpedUp)
      {
        YearGotBumpedUp = 0;

        for(i = 0; i < m_CountNotEqualTo; i++)
          if(NextValue == m_NotEqualTo[i])
          {
            NextValue += 1;
            YearGotBumpedUp = 1;
          }
      }
    }

    if(m_FieldsUsed & UPPERBOUND)
    {
      if(NextValue > m_UpperBound)
        return -1;
    }
  }

  return NextValue;
}
/******************************************************************/

// this belongs to CDatePattern but is stuck outside
// of scope because of compiler bug (re: C2334)

wchar_t* m_FieldName[] =
{
  L"Year",
  L"Month",
  L"Day",
  L"DayOfWeek",
  L"WeekInMonth",
  L"Quarter",
  L"Hour",
  L"Minute",
  L"Second"
};


int CDatePattern::FieldIndx(const wchar_t *suName)
{
  int 
    iField;

  if(NULL == suName) return -1;

  for(iField = INDX_Year; 
      (iField < INDX_MAX) && wbem_wcsicmp(m_FieldName[iField], suName);
      iField++);

  if(INDX_MAX == iField) iField = -1;

  return iField;
}

HRESULT CDatePattern::AugmentPattern(QL_LEVEL_1_TOKEN *pExp)
{
  int
    i = pExp->PropertyName.GetNumElements(),
    iField = FieldIndx(pExp->PropertyName.GetStringAt(i - 1));

  unsigned 
    j,
    testVal;

  VARIANT
    iValue;

  VariantInit(&iValue);

  if(-1 == iField)
  {
    if(wbem_wcsicmp(L"TargetInstance", pExp->PropertyName.GetStringAt(i - 1)))
      return WBEM_E_INVALID_PROPERTY;
    else
      return WBEM_S_NO_ERROR;
  }

  if(FAILED(VariantChangeType(&iValue, &(pExp->vConstValue), 0x0, VT_I4)))
    return WBEM_E_INVALID_QUERY;

  switch(pExp->nOperator)
  {
    case QL_LEVEL_1_TOKEN::OP_EQUAL : 

      // **** first make sure that value can be in pattern

      testVal = m_Pattern[iField].GetNextValue(iValue.lVal);
      if(testVal == iValue.lVal)
      {
        m_Pattern[iField].m_FieldsUsed |= CPattern::EQUALTO;
        m_Pattern[iField].m_EqualTo = iValue.lVal;
      }
      break;

    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL : 
      m_Pattern[iField].m_FieldsUsed |= CPattern::NOTEQUALTO;
      j = m_Pattern[iField].m_CountNotEqualTo;
      if(j < 64)
      {
        m_Pattern[iField].m_NotEqualTo[j] = iValue.lVal;
        m_Pattern[iField].m_CountNotEqualTo++;
      }
      else
      {
        return WBEM_E_FAILED;
      }

      break;

    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::LOWERBOUND))
      {
        m_Pattern[iField].m_LowerBound = 0;
        m_Pattern[iField].m_FieldsUsed |= CPattern::LOWERBOUND;
      }
      if(m_Pattern[iField].m_LowerBound < iValue.lVal)
        m_Pattern[iField].m_LowerBound = iValue.lVal;
      break;

    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::UPPERBOUND))
      {
        m_Pattern[iField].m_UpperBound = -1;
        m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      }
      m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      if(m_Pattern[iField].m_UpperBound > iValue.lVal)
        m_Pattern[iField].m_UpperBound = iValue.lVal;
      break;

    case QL_LEVEL_1_TOKEN::OP_LESSTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::UPPERBOUND))
      {
        m_Pattern[iField].m_UpperBound = -1;
        m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      }
      m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      if(m_Pattern[iField].m_UpperBound >= iValue.lVal)
        m_Pattern[iField].m_UpperBound = iValue.lVal - 1;
      break;

    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::LOWERBOUND))
      {
        m_Pattern[iField].m_LowerBound = 0;
        m_Pattern[iField].m_FieldsUsed |= CPattern::LOWERBOUND;
      }
      m_Pattern[iField].m_FieldsUsed |= CPattern::LOWERBOUND;
      if(m_Pattern[iField].m_LowerBound <= iValue.lVal)
        m_Pattern[iField].m_LowerBound = iValue.lVal + 1;
      break;

    case QL_LEVEL_1_TOKEN::OP_LIKE : 
    default : ;
      return WBEM_E_INVALID_QUERY;
  }

  return WBEM_S_NO_ERROR;
}

HRESULT CDatePattern::BuildSetsFromPatterns(void)
{
  // Second

  m_Set[INDX_Second].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Second], &m_Set[INDX_Second]);
  m_Set[INDX_Second].UpperBound(59);

  // Minute

  m_Set[INDX_Minute].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Minute], &m_Set[INDX_Minute]);
  m_Set[INDX_Minute].UpperBound(59);

  // Hour

  m_Set[INDX_Hour].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Hour], &m_Set[INDX_Hour]);
  m_Set[INDX_Hour].UpperBound(23);

  // Quarter

  m_Set[INDX_Quarter].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Quarter], &m_Set[INDX_Quarter]);
  m_Set[INDX_Quarter].LowerBound(1);
  m_Set[INDX_Quarter].UpperBound(4);

  // WeekInMonth

  m_Set[INDX_WeekInMonth].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_WeekInMonth], &m_Set[INDX_WeekInMonth]);
  m_Set[INDX_WeekInMonth].LowerBound(1);
  m_Set[INDX_WeekInMonth].UpperBound(7);

  // DayOfWeek

  m_Set[INDX_DayOfWeek].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_DayOfWeek], &m_Set[INDX_DayOfWeek]);
  m_Set[INDX_DayOfWeek].LowerBound(1);
  m_Set[INDX_DayOfWeek].UpperBound(7);

  // Day

  m_Set[INDX_Day].Set(SETEMPTY);

  // Month

  m_Set[INDX_Month].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Month], &m_Set[INDX_Month]);
  m_Set[INDX_Month].LowerBound(1);
  m_Set[INDX_Month].UpperBound(12);

  // Year

  m_Set[INDX_Year].Set(SETEMPTY);

  return WBEM_S_NO_ERROR;
}

HRESULT CDatePattern::MapPatternToSet(CPattern *pPattern, COrderedUniqueSet64 *pSet)
{
  unsigned i;

  if(pPattern->m_FieldsUsed & CPattern::EQUALTO)
  {
    pSet->Set(SETEMPTY);
    pSet->Add(pPattern->m_EqualTo);
  }
  else
  {
    if(pPattern->m_FieldsUsed & CPattern::NOTEQUALTO)
    {
      for(i = 0; i < pPattern->m_CountNotEqualTo; i++)
        pSet->Remove(pPattern->m_NotEqualTo[i]);
    }

    if(pPattern->m_FieldsUsed & CPattern::UPPERBOUND)
    {
      pSet->UpperBound(pPattern->m_UpperBound);
    }

    if(pPattern->m_FieldsUsed & CPattern::LOWERBOUND)
    {
      pSet->LowerBound(pPattern->m_LowerBound);
    }
  }

  return WBEM_S_NO_ERROR;
}

HRESULT CDatePattern::GetDaysInMonth(WORD iYear, WORD iMonth)
{
  ULONGLONG
    Time1,
    Time2;

  int
    i, j, k,
    DayOfWeek,
    DaysInMonth;

  SYSTEMTIME
    SystemTime;

  FILETIME
    FileTime1,
    FileTime2;

  SystemTime.wYear = iYear;
  SystemTime.wMonth = iMonth;
  SystemTime.wDay = 1;
  SystemTime.wHour = 0;
  SystemTime.wMinute = 0;
  SystemTime.wSecond = 0;
  SystemTime.wMilliseconds = 0;

  if(m_Set[INDX_Month].Member(iMonth) && 
     m_Set[INDX_Quarter].Member(1 + (iMonth - 1) / 3))
  {
    // **** get DayOfWeek

    SystemTimeToFileTime(&SystemTime, &FileTime1);

    if(12 == SystemTime.wMonth)
    {
      SystemTime.wMonth = 1;
      SystemTime.wYear++;
    }
    else
      SystemTime.wMonth++;

    SystemTimeToFileTime(&SystemTime, &FileTime2);
    FileTimeToSystemTime(&FileTime1, &SystemTime);

    DayOfWeek = SystemTime.wDayOfWeek; // 0..6

    // **** get DaysInMonth

    Time1 = FileTime1.dwHighDateTime;
    Time1 = (Time1 << 32) + FileTime1.dwLowDateTime;
    Time2 = FileTime2.dwHighDateTime;
    Time2 = (Time2 << 32) + FileTime2.dwLowDateTime;

    DaysInMonth = (int) ((Time2 - Time1) / 864000000000);

    // **** get set for DaysInMonth

    m_Set[INDX_Day].Set(SETFULL);
    m_Set[INDX_Day].LowerBound(1);
    m_Set[INDX_Day].UpperBound(DaysInMonth);
    MapPatternToSet(&m_Pattern[INDX_Day], &m_Set[INDX_Day]);

    // build bitfield from DayOfWeek and WeekInMonth sets

    m_Set[INDX_MAX].Set(SETEMPTY);

    for(i = 0; i < DaysInMonth; i++)
    {
      j = (DayOfWeek + i) % 7 + 1;  // Day of week
      k = (DayOfWeek + i) / 7 + 1;  // Week in Month

      if(m_Set[INDX_DayOfWeek].Member(j) &&
         m_Set[INDX_WeekInMonth].Member(k))
        m_Set[INDX_MAX].Add(i + 1);
    }

    m_Set[INDX_Day].Intersection(m_Set[INDX_MAX]);
  }
  else
    m_Set[INDX_Day].Set(SETEMPTY);

  return WBEM_S_NO_ERROR;
}

ULONGLONG CDatePattern::GetNextTime(SYSTEMTIME *pSystemTime)
{
  WORD
    wCurrValue,
    wCurrValue2,
    ThresholdYear = 12;

  FILETIME
    FileTime;

  ULONGLONG
    NewTime;

  /*
     Assumptions:

       1. ASSUME EACH SET HAS AT LEAST ONE MEMBER EXCEPT 'Day'
       2. set values start at 1 but hours, mins and secs start at 0
  */

  // **** second

  wCurrValue = m_CurrentTime.wSecond + 1;
  m_CurrentTime.wSecond = (USHORT) m_Set[INDX_Second].Next(wCurrValue);
  if(m_CurrentTime.wSecond < wCurrValue)
  {
    // **** minute

    wCurrValue = m_CurrentTime.wMinute + 1;
    m_CurrentTime.wMinute = (USHORT) m_Set[INDX_Minute].Next(wCurrValue);
    if(m_CurrentTime.wMinute < wCurrValue)
    {
      // **** hour

      wCurrValue = m_CurrentTime.wHour + 1;
      m_CurrentTime.wHour = (USHORT) m_Set[INDX_Hour].Next(wCurrValue);
      if(m_CurrentTime.wHour < wCurrValue)
      {
        // **** day

        wCurrValue = m_CurrentTime.wDay + 1;
        m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);

        while((SETEMPTY == m_Set[INDX_Day].m_BitField) || 
              (m_CurrentTime.wDay < wCurrValue))
        {
          // **** Month

          wCurrValue2 = m_CurrentTime.wMonth + 1;
          m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(wCurrValue2);
          if(m_CurrentTime.wMonth < wCurrValue2)
          {
            if(!ThresholdYear--)
              return -1;

            // **** year

            m_CurrentTime.wYear = (USHORT)
              m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear + 1);

            if((WORD)-1 == m_CurrentTime.wYear)
              return -1;
          }

          GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);

          wCurrValue = 1;
          m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);
        }
      }
    }
  }

  SystemTimeToFileTime(&m_CurrentTime, &FileTime);
    
  NewTime = FileTime.dwHighDateTime;
  NewTime = (NewTime << 32) + FileTime.dwLowDateTime;

  if(NULL != pSystemTime)
    *pSystemTime = m_CurrentTime;

  return NewTime;
}

ULONGLONG CDatePattern::SetStartTime(SYSTEMTIME StartTime)
{
  WORD
    wCurrValue,
    ThresholdYear = 12;

  FILETIME
    FileTime;

  ULONGLONG
    NewTime;

  m_CurrentTime = StartTime;

  // **** check that there are at least one each of
  // **** year, month, hour, min and sec

  if((SETEMPTY == m_Set[INDX_Second].m_BitField) ||
     (SETEMPTY == m_Set[INDX_Minute].m_BitField) ||
     (SETEMPTY == m_Set[INDX_Hour].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_Quarter].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_WeekInMonth].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_DayOfWeek].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_Month].m_BitField))
    return -1;

  // **** find first Month/year combo following current time

  m_CurrentTime.wYear =
    (USHORT) m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear);

  if(m_CurrentTime.wYear == (USHORT)-1)
    return -1;

  if(m_CurrentTime.wYear != StartTime.wYear)
    m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(1);

  // **** now find first month/year that has at least
  // **** one day in it

  GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);

  while(SETEMPTY == m_Set[INDX_Day].m_BitField)
  {
    wCurrValue = m_CurrentTime.wMonth + 1;
    m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(wCurrValue);

    if(m_CurrentTime.wMonth < wCurrValue)
      m_CurrentTime.wYear
        = (USHORT) m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear + 1);

    if(m_CurrentTime.wYear == (USHORT)-1)
      return -1;

    GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);
  }

  // **** NOTE: it is still possible, at this point, to have a 
  // **** day in month for the current year/month that is before
  // **** the current day.  But, this is taken care of below.

  // **** align hour:min:sec to first valid date

  if((m_CurrentTime.wYear != StartTime.wYear) || 
     (m_CurrentTime.wMonth != StartTime.wMonth))
  {
    m_CurrentTime.wSecond = (USHORT) m_Set[INDX_Second].Next(0);
    m_CurrentTime.wMinute = (USHORT) m_Set[INDX_Minute].Next(0);
    m_CurrentTime.wHour = (USHORT) m_Set[INDX_Hour].Next(0);
    m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(1);
  }
  else
  {
    wCurrValue = m_CurrentTime.wSecond;
    m_CurrentTime.wSecond = (USHORT) m_Set[INDX_Second].Next(wCurrValue);
    if(m_CurrentTime.wSecond < wCurrValue)
      m_CurrentTime.wMinute += 1;

    wCurrValue = m_CurrentTime.wMinute;
    m_CurrentTime.wMinute = (USHORT) m_Set[INDX_Minute].Next(wCurrValue);
    if(m_CurrentTime.wMinute < wCurrValue)
      m_CurrentTime.wHour += 1;

    wCurrValue = m_CurrentTime.wHour;
    m_CurrentTime.wHour = (USHORT) m_Set[INDX_Hour].Next(wCurrValue);
    if(m_CurrentTime.wHour < wCurrValue)
      m_CurrentTime.wDay += 1;

    wCurrValue = m_CurrentTime.wDay;
    m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);

    while((SETEMPTY == m_Set[INDX_Day].m_BitField) ||
          (m_CurrentTime.wDay < wCurrValue))
    {
      wCurrValue = m_CurrentTime.wMonth + 1;
      m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(wCurrValue);
  
      if(m_CurrentTime.wMonth < wCurrValue)
        m_CurrentTime.wYear 
          = (USHORT) m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear + 1);
  
      if(m_CurrentTime.wYear == (USHORT)-1)
        return -1;

      GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);

      wCurrValue = 1;
      m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);
    }
  }

  SystemTimeToFileTime(&m_CurrentTime, &FileTime);

  NewTime = FileTime.dwHighDateTime;
  NewTime = (NewTime << 32) + FileTime.dwLowDateTime;

  return NewTime;
}

/******************************************************************/


HRESULT WQLDateTime::Init(QL_LEVEL_1_RPN_EXPRESSION *pExp)
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  int i, j;

  CDNFExpression 
    DNFExpression;

  CConjunction 
    *pConjunction;

  QL_LEVEL_1_TOKEN 
    *pToken, 
    *pTokens;

  pTokens = pExp->pArrayOfTokens + pExp->nNumTokens - 1;

  DNFExpression.CreateFromTokens(pTokens);

  if(pTokens != pExp->pArrayOfTokens - 1)
    return WBEM_E_CRITICAL_ERROR;

  DNFExpression.Sort();

  // **** first, if there is a previous definition, delete it

  if(m_NLeaves > 0)
  {
    m_NLeaves = 0;
    delete[] m_ParseTreeLeaves;
  }

  // **** now, build new logic

  m_NLeaves = DNFExpression.GetNumTerms();

  m_ParseTreeLeaves = new _DatePattern[m_NLeaves];

  if(NULL == m_ParseTreeLeaves)
    return WBEM_E_OUT_OF_MEMORY;

  for(i = 0; (i < m_NLeaves) && SUCCEEDED(hres); i++)
  {
    #ifdef WQLDEBUG 
      if(i > 0) printf(" V ");
    #endif

    pConjunction = DNFExpression.GetTermAt(i);
    m_ParseTreeLeaves[i].m_Datum = new CDatePattern;

    if(NULL == m_ParseTreeLeaves[i].m_Datum)
      return WBEM_E_OUT_OF_MEMORY;

    #ifdef WQLDEBUG 
      printf("(");
    #endif
    for(j = 0; j < pConjunction->GetNumTokens(); j++)
    {
      #ifdef WQLDEBUG 
        if(j > 0) printf(" ^ ");
      #endif
      pToken = pConjunction->GetTokenAt(j);
      #ifdef WQLDEBUG 
        wprintf(L"%s", pToken->GetText());
      #endif

      hres = m_ParseTreeLeaves[i].m_Datum->AugmentPattern(pToken);
      if(FAILED(hres)) return WBEM_E_INVALID_QUERY;
    }
    m_ParseTreeLeaves[i].m_Index = 0;
    m_ParseTreeLeaves[i].m_Next = NULL;
    #ifdef WQLDEBUG 
      printf(")");
    #endif

    hres = m_ParseTreeLeaves[i].m_Datum->BuildSetsFromPatterns();
    if(FAILED(hres)) return WBEM_E_INVALID_QUERY;
  }

  return hres;
}

ULONGLONG WQLDateTime::SetStartTime(SYSTEMTIME *StartTime)
{
  int i;

  if(NULL == StartTime)
    return -1;

  // **** insert all alternatives into ordered list

  m_ListHead = NULL;

  for(i = 0; i < m_NLeaves; i++)
  {
     m_ParseTreeLeaves[i].m_Next = NULL;
     m_ParseTreeLeaves[i].m_Index = m_ParseTreeLeaves[i].m_Datum->SetStartTime(*StartTime);

     if((ULONGLONG)-1 != m_ParseTreeLeaves[i].m_Index)
       InsertOrdered(m_ParseTreeLeaves + i);
  }

  return GetNextTime(StartTime);
}

void WQLDateTime::InsertOrdered(_DatePattern *pNode)
{
  _DatePattern
    *pPrevDatePattern = NULL,
    *pDatePattern = m_ListHead;

  while(NULL != pDatePattern && (pNode->m_Index > pDatePattern->m_Index))
  {
    pPrevDatePattern = pDatePattern;
    pDatePattern = pDatePattern->m_Next;
  }

  pNode->m_Next = pDatePattern;
  if(NULL != pPrevDatePattern)
    pPrevDatePattern->m_Next = pNode;
  else
    m_ListHead = pNode;
}

ULONGLONG WQLDateTime::GetNextTime(SYSTEMTIME *NextTime)
{
  _DatePattern
    *pDate;

  ULONGLONG
    FiringTime;

  if(NULL != m_ListHead)
  {
    pDate = m_ListHead;
    m_ListHead = m_ListHead->m_Next;

    FiringTime = pDate->m_Index;

    if(NULL != NextTime)
      *NextTime = pDate->m_Datum->m_CurrentTime;

    pDate->m_Index = pDate->m_Datum->GetNextTime();

    // **** if next time is -1 then there are no future times
    // **** so don't add back into list

    if((ULONGLONG)-1 != pDate->m_Index)
      InsertOrdered(pDate);

    return FiringTime;
  }

  return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\makefile.inc ===
$(O)\wmitimep.mof $(O)\wmitimep.mfl: wmitimep.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmitimepTmp.mof -MFL:$(O)\wmitimepTmp.mfl wmitimep.mof
    copy copyright.mof+$(O)\wmitimepTmp.mof+$(O)\wmitimepTmp.mfl $(O)\wmitimep.mof
    copy copyright.mof+$(O)\wmitimepTmp.mfl $(O)\wmitimep.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\dnf.h ===
#include <parmdefs.h>
#include <ql.h>
#include <sync.h>
#include <limits.h>
#include <sortarr.h>

#ifndef __WBEM_EVALUTAION_TREE__H_
#define __WBEM_EVALUTAION_TREE__H_

class CConjunction
{
protected:
    CUniquePointerArray<QL_LEVEL_1_TOKEN> m_apTokens;

public:
    CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate);
    CConjunction(CConjunction& Other);
    CConjunction(CConjunction& Other1, CConjunction& Other2);

    long GetNumTokens() {return m_apTokens.GetSize();}
    INTERNAL QL_LEVEL_1_TOKEN* GetTokenAt(int nIndex)
        {return m_apTokens[nIndex];}
    void AddToken(ACQUIRE QL_LEVEL_1_TOKEN* pNew)
        {m_apTokens.Add(pNew);}

//    HRESULT BuildTree(CContextMetaData* pNamespace,
//                                  CImplicationList& Implications,
//                                  CEvalNode** ppRes);
    void Sort();
    static int NegateOperator(int nOperator);
};

class CDNFExpression
{
protected:
    CUniquePointerArray<CConjunction> m_apTerms;

protected:
    void CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate = FALSE);
    void CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2);
    void CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2);

public:
    long GetNumTerms() {return m_apTerms.GetSize();}
    INTERNAL CConjunction* GetTermAt(int nIndex)
        {return m_apTerms[nIndex];}
    void AddTerm(ACQUIRE CConjunction* pNew)
        {m_apTerms.Add(pNew);}
//    HRESULT BuildTree(CContextMetaData* pNamespace,
//                                  CImplicationList& Implications,
//                                  CEvalNode** ppRes);

    void CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken, BOOL bNegate = FALSE);
    void Sort();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\datep.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

/******************************************************************/

#ifndef __WBEM_TIME__DATEP__H_
#define __WBEM_TIME__DATEP__H_

#include <ql.h>
#define SETMIN ((__int64)0x0000000000000001)
#define SETMAX ((__int64)0x8000000000000000)
#define SETEMPTY ((__int64)0x0000000000000000)
#define SETFULL ((__int64)0xFFFFFFFFFFFFFFFF)

struct COrderedUniqueSet64
{
  ULONGLONG
    m_BitField; // m_BitField MUST be an unsigned type

  COrderedUniqueSet64(void);

  COrderedUniqueSet64 
    Set(ULONGLONG n),
    Add(ULONGLONG n),
    Remove(ULONGLONG n),
    Union(COrderedUniqueSet64 n),
    Intersection(COrderedUniqueSet64 n),
    UpperBound(ULONGLONG n),
    LowerBound(ULONGLONG n),
    Rotate(int n);

  int 
    Member(ULONGLONG n);

  unsigned 
    Next(ULONGLONG n),
    Prev(ULONGLONG n);
};

/******************************************************************/

struct CPattern
{
  enum
  {
    UPPERBOUND = 0x00000001,
    LOWERBOUND = 0x00000002,
    MODULUS    = 0x00000004,
    EQUALTO    = 0x00000008,
    NOTEQUALTO = 0x00000010
  };

  unsigned 
    m_FieldsUsed,
    m_UpperBound,
    m_LowerBound,
    m_Modulus,
    m_EqualTo,
    m_CountNotEqualTo,
    m_NotEqualTo[64];

  CPattern(void) 
  { m_FieldsUsed = 0x0; m_CountNotEqualTo = 0x0; }

  unsigned
    GetNextValue(unsigned x);
};

/******************************************************************/

struct CDatePattern
{
  enum
  {
    INDX_Year = 0,
    INDX_Month,
    INDX_Day,
    INDX_DayOfWeek,
    INDX_WeekInMonth,
    INDX_Quarter,
    INDX_Hour,
    INDX_Minute,
    INDX_Second,
    INDX_MAX
  };

  COrderedUniqueSet64        
    m_Set[CDatePattern::INDX_MAX + 1]; // use extra set as buffer in
                         // GetDayInMonth()

  CPattern
    m_Pattern[CDatePattern::INDX_MAX];

  SYSTEMTIME
    m_CurrentTime;

  int 
    FieldIndx(const wchar_t *suName);

  ULONGLONG 
    GetNextTime(SYSTEMTIME *pSystemTime = NULL),
    SetStartTime(SYSTEMTIME StartTime);

  HRESULT
    AugmentPattern(QL_LEVEL_1_TOKEN *pExp),
    BuildSetsFromPatterns(void),
    MapPatternToSet(CPattern *pPattern, COrderedUniqueSet64 *pSet),
    GetDaysInMonth(WORD iYear, WORD iMonth);
};

/******************************************************************/

struct WQLDateTime
{
  struct _DatePattern
  {
    CDatePattern 
      *m_Datum;

    ULONGLONG 
      m_Index;

    _DatePattern
      *m_Next;

    _DatePattern(void)
    { m_Datum = NULL; m_Next = NULL; m_Index = 0; }

    ~_DatePattern(void)
    { if(NULL != m_Datum) delete m_Datum; }
  } 
    *m_ParseTreeLeaves, 
    *m_ListHead;

  int
    m_NLeaves;

  WQLDateTime(void)
  { m_ParseTreeLeaves = m_ListHead = NULL; m_NLeaves = 0; }
  
  ~WQLDateTime(void)
  { if(NULL != m_ParseTreeLeaves) delete [] m_ParseTreeLeaves; }

  HRESULT 
    Init(QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL);

  ULONGLONG 
    SetStartTime(SYSTEMTIME *StartTime),
    GetNextTime(SYSTEMTIME *NextTime = NULL);

  void 
    InsertOrdered(_DatePattern *pNode);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\dnf.cpp ===
#include <windows.h>
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "dnf.h"
// #include "TwoPropNode.h"
// #include "dumbnode.h"

void CDNFExpression::CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken,
                                        BOOL bNegate)
{
    QL_LEVEL_1_TOKEN& Head = *pLastToken;
    if(Head.nTokenType == QL1_OP_EXPRESSION)
    {
        CreateFromToken(Head, bNegate);
        pLastToken--;
        return;
    }

    // Build arguments
    // ===============

    pLastToken--;

    if(Head.nTokenType == QL1_NOT)
    {
        CreateFromTokens(pLastToken, !bNegate);
        return;
    }

    CDNFExpression Arg1;
    Arg1.CreateFromTokens(pLastToken, bNegate);

    CDNFExpression Arg2;
    Arg2.CreateFromTokens(pLastToken, bNegate);

    if(Head.nTokenType == QL1_AND)
    {
        CreateAnd(Arg1, Arg2);
    }
    else
    {
        CreateOr(Arg1, Arg2);
    }
}

void CDNFExpression::CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2)
{
    for(long lFirst = 0; lFirst < Arg1.GetNumTerms(); lFirst++)
        for(long lSecond = 0; lSecond < Arg2.GetNumTerms(); lSecond++)
        {
            CConjunction* pNewTerm =
                new CConjunction(*Arg1.GetTermAt(lFirst),
                                    *Arg2.GetTermAt(lSecond));
            m_apTerms.Add(pNewTerm);
        }
}

void CDNFExpression::CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2)
{
    int i;
    for(i = 0; i < Arg1.GetNumTerms(); i++)
    {
        m_apTerms.Add(new CConjunction(*Arg1.GetTermAt(i)));
    }
    for(i = 0; i < Arg2.GetNumTerms(); i++)
    {
        m_apTerms.Add(new CConjunction(*Arg2.GetTermAt(i)));
    }
}

void CDNFExpression::CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    m_apTerms.Add(new CConjunction(Token, bNegate));
}

#ifdef UNDEFINED
HRESULT CDNFExpression::BuildTree(CContextMetaData* pNamespace,
                                  CImplicationList& Implications,
                                  CEvalNode** ppRes)
{
    HRESULT hres;

    // Check if there is only one conjunction to talk about
    // ====================================================

    if(m_apTerms.GetSize() == 1)
    {
        // Just build that one
        // ===================

        return m_apTerms[0]->BuildTree(pNamespace, Implications, ppRes);
    }

    // Build them for all conjunctions and OR together
    // ===============================================

    COrNode* pRes = new COrNode;
    if(pRes == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        CEvalNode* pNew;
        hres = m_apTerms[i]->BuildTree(pNamespace, Implications, &pNew);
        if(FAILED(hres))
        {
            delete pRes;
            return hres;
        }

        hres = pRes->AddBranch(pNew);
        if(FAILED(hres))
        {
            delete pRes;
            return hres;
        }
    }

    *ppRes = pRes;
    return WBEM_S_NO_ERROR;
}
#endif

void CDNFExpression::Sort()
{
    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        m_apTerms[i]->Sort();
    }
}


CConjunction::CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    m_apTokens.Add(new QL_LEVEL_1_TOKEN(Token));
    if(bNegate)
    {
        m_apTokens[0]->nOperator = NegateOperator(m_apTokens[0]->nOperator);
    }
}

CConjunction::CConjunction(CConjunction& Other)
{
    for(int i = 0; i < Other.GetNumTokens(); i++)
    {
        m_apTokens.Add(new QL_LEVEL_1_TOKEN(*Other.GetTokenAt(i)));
    }
}

CConjunction::CConjunction(CConjunction& Other1, CConjunction& Other2)
{
    int i;
    for(i = 0; i < Other1.GetNumTokens(); i++)
    {
        m_apTokens.Add(new QL_LEVEL_1_TOKEN(*Other1.GetTokenAt(i)));
    }

    for(i = 0; i < Other2.GetNumTokens(); i++)
    {
        m_apTokens.Add(new QL_LEVEL_1_TOKEN(*Other2.GetTokenAt(i)));
    }
}

int CConjunction::NegateOperator(int nOperator)
{
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_ISNOTA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_INV_ISA;
    }

    return nOperator;
}

#ifdef UNDEFINED
HRESULT CConjunction::BuildTree(CContextMetaData* pNamespace,
                                  CImplicationList& Implications,
                                  CEvalNode** ppRes)
{
    HRESULT hres;

    // Build them for all tokens and AND together
    // ==========================================

    *ppRes = NULL;
    CImplicationList BranchImplications(Implications);
    for(int i = 0; i < m_apTokens.GetSize(); i++)
    {
        CEvalNode* pNew = NULL;
        hres = CEvalTree::BuildFromToken(pNamespace, BranchImplications,
            *m_apTokens[i], &pNew);
        if(FAILED(hres))
        {
            delete *ppRes;
            return hres;
        }

        if(i > 0)
        {
            CEvalNode* pOld = *ppRes;
            CEvalTree::Combine(pOld, pNew, EVAL_OP_AND, pNamespace,
                Implications, true, true, ppRes); // delete both
        }
        else
        {
            *ppRes = pNew;
        }
    }
    return WBEM_S_NO_ERROR;
}
#endif

void CConjunction::Sort()
{
    int i = 0;

    while(i < m_apTokens.GetSize() - 1)
    {
        int nLeft = m_apTokens[i]->PropertyName.GetNumElements();
        int nRight = m_apTokens[i+1]->PropertyName.GetNumElements();
        if(nLeft > nRight)
        {
            m_apTokens.Swap(i, i+1);
            if(i != 0)
            {
                i--;
            }
        }
        else
        {
            i++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\timemain.cpp ===
#include <windows.h>
#include <commain.h>
#include <clsfac.h>
#include <win32clock.h>

#include <tchar.h>

// {C4819C8D-9AB8-4b2f-B8AE-C77DABF553D5}
static const CLSID CLSID_CurrentTimeProvider = {0xc4819c8d, 0x9ab8, 0x4b2f, {0xb8, 0xae, 0xc7, 0x7d, 0xab, 0xf5, 0x53, 0xd5}};

class CMyServer : public CComServer
{
protected:
    HRESULT Initialize()
    {
        AddClassInfo( CLSID_CurrentTimeProvider, 
                      new CSimpleClassFactory<CWin32Clock>(GetLifeControl()),
                      _T("Current Time Provider"), TRUE );

        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\win32clock.cpp ===
/*
  CWin32Clock.CPP

  Module: WMI Current Time Instance Provider

  Purpose: The methods of CWin32Clock class are defined here.  

  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
*/

#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemcomn.h>
#undef _ASSERT
#include <atlbase.h>
#include "genlex.h"
#include "objpath.h"
#include "dnf.h"
#include "datep.h"
#include "Win32Clock.h"

// **** long glNumInst = sizeof(MyDefs)/sizeof(InstDef);

/****************************************************************************/

CWin32Clock::CScheduledEvent::CScheduledEvent(void)
{
  
  m_Type = TypeNONE;
  m_cRef = 0;
  m_dwId = -1;
  m_stLastFiringTime = 0;
  m_pWin32Clock = NULL;
  m_WQLStmt = NULL;
}

CWin32Clock::CScheduledEvent::~CScheduledEvent(void)
{
  if(0 != m_cRef)
  {
    // ****  error
  }

  if(NULL != m_WQLStmt)
    delete[] m_WQLStmt;
}

HRESULT CWin32Clock::CScheduledEvent::Init(CWin32Clock *pClock,
                                           wchar_t *WQLStmt,
                                           ULONG dwId)
{
  HRESULT
    hr = S_OK;

  // ****  check for valid arguments

  if((NULL == pClock) || (NULL == WQLStmt) || (-1 == dwId))
    return WBEM_E_FAILED;

  // ****  copy to local arguments

  if((NULL != m_pWin32Clock) || (NULL != m_WQLStmt))
    return WBEM_E_FAILED;

  m_dwId = dwId;

  m_pWin32Clock = pClock;  // ****  note: no AddRef() is done here because 
                           // ****  the lifetime of this CScheduledEvent obj is
                           // ****  ALWAYS encapsulated within that of pClock

  // ****  now parse m_WQLStmt to determine values for timer start and interval

  hr = ReInit(WQLStmt);

  return hr;
}

HRESULT CWin32Clock::CScheduledEvent::ReInit(wchar_t *WQLStmt)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  int 
    nRes;

  if(NULL != m_WQLStmt)
    delete[] m_WQLStmt;

  // ****  save WQL expression

  m_WQLStmt = new wchar_t[wcslen(WQLStmt) + 1];
  if(NULL == m_WQLStmt)
    return WBEM_E_OUT_OF_MEMORY;

  wcscpy(m_WQLStmt, WQLStmt);

  // ****  parse WQL expression

  CTextLexSource src(m_WQLStmt);
  QL1_Parser parser(&src);
  QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
  QL_LEVEL_1_TOKEN *pToken = NULL;

  #ifdef WQLDEBUG
     wchar_t classbuf[128];
     *classbuf = 0;
     printf("[1] ----GetQueryClass----\n");
     nRes = parser.GetQueryClass(classbuf, 128);
     if (nRes)
     {
       printf("ERROR %d: line %d, token %S\n",
         nRes,
         parser.CurrentLine(),
         parser.CurrentToken());
     }
     printf("Query class is %S\n", classbuf);
  #endif

  if(nRes = parser.Parse(&pExp))
  {
    #ifdef WQLDEBUG
      if (nRes)
      {
        printf("ERROR %d: line %d, token %S\n",
          nRes,
          parser.CurrentLine(),
          parser.CurrentToken());
      }
      else
      {
        printf("No errors.\n");
      }
    #endif

    hr = WBEM_E_INVALID_QUERY;
    goto cleanup;
  }

  // ****  validate WQL statement

  if((NULL == pExp) ||
     (NULL == pExp->bsClassName) ||
     (wbem_wcsicmp(L"__InstanceModificationEvent", pExp->bsClassName)) ||
     (pExp->nNumTokens < 1))
  {
    #ifdef WQLDEBUG
      printf("WQL statement failed validation\n");
    #endif

    hr = WBEM_E_INVALID_QUERY;
    goto cleanup;
  }

  // **** determine type

  for(int i = 0; i < pExp->nNumTokens && (m_Type == TypeNONE); i++)
  {
    pToken = pExp->pArrayOfTokens + i;

    if(NULL == pToken) continue;

    if ( (pToken->nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION) &&
       (pToken->vConstValue.vt == VT_BSTR))
    {
        long nElts = pToken->PropertyName.GetNumElements();
        LPCWSTR pAttrName = pToken->PropertyName.GetStringAt(nElts -1);

        if ( pAttrName != NULL && 
             0 == wbem_wcsicmp(L"targetinstance", pAttrName))
        {
            if(0 == wbem_wcsicmp(WIN32LOCALTIMECLASS, pToken->vConstValue.bstrVal)) m_Type = TypeLocal;
            else if(0 == wbem_wcsicmp(WIN32UTCTIMECLASS, pToken->vConstValue.bstrVal)) m_Type = TypeUTC;
        }
    }
  }

  if(TypeNONE == m_Type)
  {
    hr = WBEM_E_INVALID_QUERY;
    goto cleanup;
  }

  // **** interpret WQL Expression

  #ifdef WQLDEBUG
    printf("\n[2] ----ShowParseTree----\n");
    pExp->Dump("CON");
    printf("\n[3] ----ShowRebuiltQuery----\n");
    LPWSTR wszText = pExp->GetText();
    printf("--WQL passed to provider--\n");
    printf("%S\n", wszText);
    printf("\n[4] ----ShowInterpretation----\n");
  #endif

  try
  {
    hr = m_WQLTime.Init(pExp);
  }
  catch(...)
  {
    hr = WBEM_E_FAILED;
    goto cleanup;
  }

  #ifdef WQLDEBUG
    printf("\n\n[5] ----End of WQL Compilation----\n");
    delete [] wszText;
  #endif

cleanup:

  delete pExp;

  return hr;
}

void CWin32Clock::CScheduledEvent::AddRef()
{
  InterlockedIncrement((long *)&m_cRef);
}

void CWin32Clock::CScheduledEvent::Release()
{
  ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

  if(0L == nNewCount)
    delete this;
}

int CWin32Clock::CScheduledEvent::GetInstructionType()
{
  return INSTTYPE_WBEM;
}

CWbemTime CWin32Clock::CScheduledEvent::GetNextFiringTime(CWbemTime LastFiringTime,
                                                          long *plFiringCount) const
{
  FILETIME
    FileTime,
    FileTime2;

  ULONGLONG
    NextFiringTime,
    CurrentTime;

  CWbemTime
    ResultTime;

  int
    nMisses = 0;

  // **** save the firing time for event just fired from LastFiringTime

  ((CWin32Clock::CScheduledEvent*)this)->m_stLastFiringTime = LastFiringTime.Get100nss();

  // ****  calculate the next firing time after LastFiringTime and after the current time

  GetFileTime(&FileTime);

  CurrentTime = FileTime.dwHighDateTime;
  CurrentTime = (CurrentTime << 32) + FileTime.dwLowDateTime;

  while((NextFiringTime = ((WQLDateTime*)&m_WQLTime)->GetNextTime()) <= CurrentTime)
    nMisses += 1;

  if(-1 == NextFiringTime)
  {
    // ****  no future event to be scheduled so, so indicate

    return CWbemTime::GetInfinity();
  }

  if(NULL != plFiringCount)
    *plFiringCount = nMisses;

  // **** if local time, convert to UTC time for the scheduling logic

  if(TypeLocal == m_Type)
  {
    FileTime.dwLowDateTime = ((NextFiringTime << 32) >> 32);
    FileTime.dwHighDateTime = (NextFiringTime >> 32);

    LocalFileTimeToFileTime(&FileTime, &FileTime2);

    NextFiringTime = FileTime2.dwHighDateTime;
    NextFiringTime = (NextFiringTime << 32) + FileTime2.dwLowDateTime;
  }

  ResultTime.Set100nss(NextFiringTime);

  return ResultTime;
}

CWbemTime CWin32Clock::CScheduledEvent::GetFirstFiringTime() const
{
  SYSTEMTIME
    CurrentTime;

  CWbemTime
    ResultTime;

  ULONGLONG
    ullStartTime;

  GetTime(&CurrentTime);

  /*
    Since the finest granularity used by the time provider is seconds, set milliseconds
    to zero so that we can compare two FILETIME values in the Fire method and have
    the numbers agree.
  */

  CurrentTime.wMilliseconds = 0;

  ullStartTime = ((WQLDateTime*)&m_WQLTime)->SetStartTime(&CurrentTime);

  if(TypeLocal == m_Type)
  {
    FILETIME
      FileTime,
      FileTime2;

    FileTime.dwLowDateTime = ((ullStartTime << 32) >> 32);
    FileTime.dwHighDateTime = (ullStartTime >> 32);

    LocalFileTimeToFileTime(&FileTime, &FileTime2);

    ullStartTime = FileTime2.dwHighDateTime;
    ullStartTime = (ullStartTime << 32) + FileTime2.dwLowDateTime;
  }

  ResultTime.Set100nss(ullStartTime);

  return ResultTime;
}

HRESULT CWin32Clock::CScheduledEvent::Fire(long lNumTimes, 
                                           CWbemTime NextFiringTime)
{
  HRESULT
    hr = WBEM_E_FAILED;

  FILETIME
    ft,
    ft2;

  SYSTEMTIME
    SystemTime;

  CComPtr<IWbemClassObject>
    pSystemTime;

  // ****  Do a check of arguments and make sure we have pointer to sink obj

  if((NULL == m_pWin32Clock) || (NULL == m_pWin32Clock->m_ClockResetThread))
  {
    hr = WBEM_E_INVALID_PARAMETER;
  }

  // ****  create an instance of Win32_CurrentTime for each timezone

  else
  {
    CInCritSec 
      ics(&(m_pWin32Clock->m_csWin32Clock));

    // **** reconstitute a SYSTEMTIME from the current firing time

    ft.dwLowDateTime = ((m_stLastFiringTime << 32) >> 32);
    ft.dwHighDateTime = (m_stLastFiringTime >> 32);

    if(((TypeLocal == m_Type) && (m_pWin32Clock->m_MostRecentLocalFiringTime != m_stLastFiringTime)) ||
       ((TypeUTC == m_Type) && (m_pWin32Clock->m_MostRecentUTCFiringTime != m_stLastFiringTime)))
    {
      if(TypeLocal == m_Type) 
      {
        m_pWin32Clock->m_MostRecentLocalFiringTime = m_stLastFiringTime;
        FileTimeToLocalFileTime(&ft, &ft2);
        ft = ft2;
      }
      else if(TypeUTC == m_Type) 
        m_pWin32Clock->m_MostRecentUTCFiringTime = m_stLastFiringTime;

      if(FileTimeToSystemTime(&ft, &SystemTime))
      {
        #ifdef WQLDEBUG
          printf("[%d] Fire: Misses(%d) %d/%d/%d %d:%d:%d",
            m_dwId,
            lNumTimes,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
        #else
          // ****  Send the object to the caller

          if(TypeUTC == m_Type)
            hr = CWin32Clock::SystemTimeToWin32_CurrentTime(m_pWin32Clock->m_pUTCTimeClassDef, &pSystemTime, &SystemTime);
          else if(TypeLocal == m_Type)
            hr = CWin32Clock::SystemTimeToWin32_CurrentTime(m_pWin32Clock->m_pLocalTimeClassDef, &pSystemTime, &SystemTime);

          hr = m_pWin32Clock->SendEvent(pSystemTime);
        #endif
      }
      else
        hr = WBEM_E_FAILED;
    }
  }

  return hr;
}

/******************************************************************/

LRESULT CALLBACK Win32ClockProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   return DefWindowProc(hWnd, msg, wParam, lParam);
}

DWORD CWin32Clock::AsyncEventThread(LPVOID pArg)
{
  if(NULL == pArg) 
    return -1;

  CWin32Clock 
    *pCWin32Clock = (CWin32Clock*)pArg;

  WNDCLASS wndclass;
  MSG msg;

  BOOL bRet;

  // **** create top level window to receive system messages

  wndclass.style = 0;
  wndclass.lpfnWndProc = Win32ClockProc;
  wndclass.cbClsExtra = 0;
  wndclass.cbWndExtra = sizeof(DWORD);
  wndclass.hInstance = GetModuleHandle(NULL);
  wndclass.hIcon = NULL;
  wndclass.hCursor = NULL;
  wndclass.hbrBackground = NULL;
  wndclass.lpszMenuName = NULL;
  wndclass.lpszClassName = TEXT("Win32Clock");

  if(!RegisterClass(&wndclass))
  {
    if(GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
    {
      return NULL;
    }
  }

  HMODULE
    hModule = GetModuleHandle(NULL);

  if(NULL == hModule)
    return -1;

  try
  {
    pCWin32Clock->m_hEventWindowHandle = CreateWindow(TEXT("Win32Clock"),
                                        TEXT("Win32ClockMsgs"),
                                        WS_OVERLAPPED,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        HWND_MESSAGE, 
                                        NULL, 
                                        hModule,
                                        NULL);
  }
  catch(...)
  {
    return -1;
  }

  if(NULL == pCWin32Clock->m_hEventWindowHandle)
  {
    return NULL;
  }

  ShowWindow(pCWin32Clock->m_hEventWindowHandle, SW_HIDE);

  // **** start the message loop

  while(GetMessage(&msg, pCWin32Clock->m_hEventWindowHandle, 0, 0))
  {
    switch (msg.message)
    {
      case WM_TIMECHANGE:
        pCWin32Clock->ReAlignToCurrentTime();
        break;

      default:
        DefWindowProc(pCWin32Clock->m_hEventWindowHandle, msg.message, msg.wParam, msg.lParam);
    }
  }

  // **** cleanup

  bRet = DestroyWindow(pCWin32Clock->m_hEventWindowHandle);

  bRet = UnregisterClass(TEXT("Win32Clock"), 0);

  return 0;
}

void CWin32Clock::CScheduledEvent::GetTime(SYSTEMTIME *TheTime) const
{
  if(NULL != TheTime)
  {
    memset(TheTime, 0, sizeof(SYSTEMTIME));

    if(TypeLocal == m_Type)
      GetLocalTime(TheTime);
    else if(TypeUTC == m_Type)
      GetSystemTime(TheTime);
  }
}

void CWin32Clock::CScheduledEvent::GetFileTime(FILETIME *TheTime) const
{
  SYSTEMTIME
    SysTime;

  if(NULL != TheTime)
  {
    memset(TheTime, 0, sizeof(FILETIME));

    if(TypeLocal == m_Type)
    {
      GetLocalTime(&SysTime);
      SystemTimeToFileTime(&SysTime, TheTime);
    }
    else if(TypeUTC == m_Type)
    {
      GetSystemTime(&SysTime);
      SystemTimeToFileTime(&SysTime, TheTime);
    }
  }
}

HRESULT CWin32Clock::SendEvent(IWbemClassObject *pSystemTime)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  CComPtr<IWbemClassObject>
    pInstanceModEvnt;

  CComVariant
    v;

  // **** if m_pSink has not been provided by winmgmt just drop
  // **** generated events on the floor

  if((NULL != m_pSink) && (NULL != pSystemTime))
  {
    // ****  create and init instance of __InstanceModificationEvent
 
    hr = m_pInstModClassDef->SpawnInstance(0, &pInstanceModEvnt);
    if(FAILED(hr)) return hr;

    // ****  put Win32_CurrentTime into __InstanceModificationEvent

    v.vt = VT_UNKNOWN;
    v.punkVal = NULL;
    hr = pSystemTime->QueryInterface(IID_IUnknown, (void**)&(v.punkVal));
    if(FAILED(hr)) return hr;

    hr = pInstanceModEvnt->Put(L"TargetInstance", 0, &v, 0);
    if(FAILED(hr)) return hr;

    // ****  deliver new event to WMI

    hr = m_pSink->Indicate(1, &pInstanceModEvnt);
  }

  return hr;
}

HRESULT CWin32Clock::ReAlignToCurrentTime()
{
  CInCritSec 
    ics(&m_csWin32Clock);

  HRESULT 
    hr = S_OK;

  ULONG 
    i,
    nElts;

  CScheduledEvent
    *pcEvent;

  #ifdef WQLDEBUG
    printf("System Clock Resync\n");
  #endif

  m_EventArray.Lock();

  nElts = *(ULONG *)(&(this->m_EventArray)); // voodoo

  m_MostRecentLocalFiringTime = 0;
  m_MostRecentUTCFiringTime = 0;

  for(i = 0; i < nElts; i++)
  {
    // **** pull event from the event queue

    pcEvent = m_EventArray[i];

    if(NULL != pcEvent)
    {
      // **** change time for event obj and re-queue

      m_Timer.Remove(&CIdentityTest(pcEvent));
      m_Timer.Set(pcEvent);
    }
  }

  m_EventArray.UnLock();

  return hr;
}

CWin32Clock::CWin32Clock(CLifeControl* pControl)
: m_Timer(), m_EventArray(), m_pControl(pControl)
{
  pControl->ObjectCreated((IWbemServices*)this);

  m_cRef = 0;
  m_MostRecentLocalFiringTime = 0;
  m_MostRecentUTCFiringTime = 0;
  m_pNs = NULL;
  m_pSink = NULL;
  m_pInstModClassDef = NULL;
  m_pLocalTimeClassDef = NULL;
  m_pUTCTimeClassDef = NULL;
  m_ClockResetThread = NULL;
  m_hEventWindowHandle = NULL;
}

CWin32Clock::~CWin32Clock(void)
{
  // ****  Kill Async thread if it has been started

  if(NULL != m_ClockResetThread)
  {
    BOOL
      bRes;

    do
    {
      bRes = PostMessage(m_hEventWindowHandle, WM_QUIT, 0, 0);
    }
    while(WAIT_TIMEOUT == WaitForSingleObject(m_ClockResetThread, 6000));
  }

  // **** shutdown event thread

  m_Timer.Shutdown();

  // **** release all held COM objects

  if(NULL != m_pNs) m_pNs->Release();
  if(NULL != m_pSink) m_pSink->Release();
  if(NULL != m_pInstModClassDef) m_pInstModClassDef->Release();
  if(NULL != m_pLocalTimeClassDef) m_pLocalTimeClassDef->Release();
  if(NULL != m_pUTCTimeClassDef) m_pUTCTimeClassDef->Release();

  m_pControl->ObjectDestroyed((IWbemServices*)this);
}

// **** ***************************************************************************
// **** 
// ****  CWin32Clock::QueryInterface
// ****  CWin32Clock::AddRef
// ****  CWin32Clock::Release
// **** 
// ****  Purpose: IUnknown members for CWin32Clock object.
// **** ***************************************************************************


STDMETHODIMP CWin32Clock::QueryInterface(REFIID riid, PVOID *ppv)
{
  *ppv=NULL;

  // ****  cast to the type of the base class specified by riid

  if(IID_IWbemEventProvider == riid)
  {
    *ppv = (IWbemEventProvider *)this;
  }
  else if(IID_IWbemEventProviderQuerySink == riid)
  {
    *ppv = (IWbemEventProviderQuerySink *)this;
  }
  else if(IID_IWbemServices == riid)
  {
    *ppv=(IWbemServices*)this;
  }
  else if(IID_IUnknown == riid || IID_IWbemProviderInit == riid)
  {
    *ppv=(IWbemProviderInit*)this;
  }
    
  if(NULL!=*ppv) 
  {
    AddRef();

    return S_OK;
  }
  else
    return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CWin32Clock::AddRef(void)
{
  return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CWin32Clock::Release(void)
{
  ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

  if(0L == nNewCount)
    delete this;
    
  return nNewCount;
}

/*
  IWbemProviderInit::Initialize

  Purpose: This is the implementation of IWbemProviderInit. The method
           is need to initialize with CIMOM.

           The members set up include:
           m_pNs
           m_pLocalTimeClassDef
           m_pUTCTimeClassDef
           m_pInstModClassDef
*/

HRESULT CWin32Clock::Initialize(LPWSTR pszUser, 
                                LONG lFlags,
                                LPWSTR pszNamespace, 
                                LPWSTR pszLocale,
                                IWbemServices *pNamespace, 
                                IWbemContext *pCtx,
                                IWbemProviderInitSink *pInitSink)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  if((NULL != pNamespace) && (NULL != pInitSink))
  {
    m_pNs = pNamespace;
    m_pNs->AddRef();

    // ****  get needed class definitions 

    hr = m_pNs->GetObject(WIN32LOCALTIMECLASS, 
                          0, pCtx, &m_pLocalTimeClassDef, 0);

    if(SUCCEEDED(hr))
      hr = m_pNs->GetObject(WIN32UTCTIMECLASS, 
                            0, pCtx, &m_pUTCTimeClassDef, 0);

    if(SUCCEEDED(hr))
      hr = m_pNs->GetObject(INSTMODEVCLASS,
                            0, pCtx, &m_pInstModClassDef, 0);

    if(WBEM_S_NO_ERROR == hr)
    {
      pInitSink->SetStatus(WBEM_S_INITIALIZED,0);

      hr = WBEM_NO_ERROR;
    }
  }

  // ****  if there was a problem, release the resources we have aquired

  if(FAILED(hr))
  {
    if(NULL != m_pLocalTimeClassDef) { m_pLocalTimeClassDef->Release(); m_pLocalTimeClassDef = NULL; }
    if(NULL != m_pUTCTimeClassDef) { m_pUTCTimeClassDef->Release(); m_pUTCTimeClassDef = NULL; }
    if(NULL != m_pInstModClassDef) { m_pInstModClassDef->Release(); m_pInstModClassDef = NULL; }
  }

  return hr;
}

/*
  IWbemEventProvider::ProvideEvents

  Purpose: register to provide events to the WMI service
*/

HRESULT CWin32Clock::ProvideEvents(IWbemObjectSink *pSink,
                                   long lFlags)
{
  HRESULT 
    hr = WBEM_S_NO_ERROR;

  // ****  copy object sink for future event registrations

  m_pSink = pSink;
  if(NULL != m_pSink)
    m_pSink->AddRef();
  else
    hr = WBEM_E_FAILED;

  // **** start system clock change adj. thread

  DWORD dwThreadId;

  if(NULL == m_ClockResetThread)
  {
    m_ClockResetThread = CreateThread(
        NULL,                // pointer to thread security attributes
        0,                   // initial thread stack size, in bytes
        (LPTHREAD_START_ROUTINE)AsyncEventThread, // pointer to thread function
        (LPVOID)this,                // argument for new thread
        0,                   // creation flags
        &dwThreadId);        // pointer to returned thread identifier

    if(NULL == m_ClockResetThread)
      hr = WBEM_E_FAILED;
  }
  else
    hr = WBEM_E_FAILED;

  return hr;
}

/*
  IWbemEventProviderQuerySink::NewQuery

  Purpose: add a new query for event generation
*/

HRESULT CWin32Clock::NewQuery(ULONG dwId,
                              wchar_t *wszQueryLanguage,
                              wchar_t *wszQuery)
{
  HRESULT
    hr = WBEM_E_FAILED;

  CScheduledEvent
    *pNewEvent = NULL;

  if(wbem_wcsicmp(L"WQL", wszQueryLanguage) || (NULL == wszQuery))
    return WBEM_E_FAILED;

  // ****  see if event obj with dwId is already in queue

  pNewEvent = m_EventArray(dwId, TRUE); // find registered event query

  if(NULL != pNewEvent)
  {
    #ifdef WQLDEBUG
      printf("[%d] Redefinition: %s\n", dwId, wszQuery);
    #endif

    if(wbem_wcsicmp(wszQuery, pNewEvent->m_WQLStmt))
    {
      hr = m_Timer.Remove(&CIdentityTest(pNewEvent)); // may or may not be in queue
      hr = pNewEvent->ReInit(wszQuery); // on failure, NewEvent is preserved
      m_Timer.Set(pNewEvent);
    }

    m_EventArray.UnLock();
  }

  // ****  this is a new event, create it and place it in the event queue

  else
  {
    #ifdef WQLDEBUG
      printf("[%d] Definition: %s\n", dwId, wszQuery);
    #endif

    // ****  create new event and initialize

    pNewEvent = new CScheduledEvent();

    if(NULL == pNewEvent)
      hr = WBEM_E_OUT_OF_MEMORY;
    else
    {
      pNewEvent->AddRef();

      hr = pNewEvent->Init(this, wszQuery, dwId);

      // ****  add event to queue

      if(SUCCEEDED(hr))
      {
        m_EventArray.Insert(pNewEvent, dwId);
        hr = m_Timer.Set(pNewEvent);
      }
      else
      {
        pNewEvent->Release();
        pNewEvent = NULL;
      }
    }
  }

  return hr;
}

/*
  IWbemEventProviderQuerySink::CancelQuery

  Purpose: remove an event generator from the queue
*/

HRESULT CWin32Clock::CancelQuery(ULONG dwId)
{
  CInCritSec
    ics(&m_csWin32Clock);

  CScheduledEvent
    *pDeadEvent = NULL;

  HRESULT hr = WBEM_S_NO_ERROR;

  // ****  first find element in list and remove it

  pDeadEvent = m_EventArray(dwId, TRUE);

  if(NULL != pDeadEvent)
  {
    m_EventArray.Remove(pDeadEvent);
    m_EventArray.UnLock();

    hr = m_Timer.Remove(&CIdentityTest(pDeadEvent));

  // ****  now kill it dead

    pDeadEvent->Release();
    pDeadEvent = NULL;
  }

  return hr;
}

/*
  IWbemServices::CreateInstanceEnumAsync

  Purpose: Asynchronously enumerates the instances.  
*/

HRESULT CWin32Clock::CreateInstanceEnumAsync(const BSTR RefStr, 
                                             long lFlags, 
                                             IWbemContext *pCtx,
                                             IWbemObjectSink FAR* pHandler)
{
  HRESULT 
    sc = WBEM_E_FAILED;

  IWbemClassObject 
    FAR* pNewInst = NULL;

  SYSTEMTIME
    TheTime;

  // ****  Do a check of arguments and make sure we have pointer to Namespace

  if(NULL == pHandler)
  {
    return WBEM_E_INVALID_PARAMETER;
  }

  // ****  Create Win32_CurrentTime instance

  else if(0 == wbem_wcsicmp(RefStr, WIN32LOCALTIMECLASS))
  {

    GetLocalTime(&TheTime);
    sc = SystemTimeToWin32_CurrentTime(m_pLocalTimeClassDef, &pNewInst, &TheTime);
 
    // ****  Send the object to the caller

    pHandler->Indicate(1,&pNewInst);
    pNewInst->Release();
  }

    // ****  Create Win32_CurrentTime instance

  else if(0 == wbem_wcsicmp(RefStr, WIN32UTCTIMECLASS))
  {
    GetSystemTime(&TheTime);
    sc = SystemTimeToWin32_CurrentTime(m_pUTCTimeClassDef, &pNewInst, &TheTime);

    // ****  Send the object to the caller

    pHandler->Indicate(1,&pNewInst);
    pNewInst->Release();
  }
  else if(0 == wbem_wcsicmp(RefStr, L"Win32_CurrentTime"))
  {}
  else
  {
    sc = WBEM_E_INVALID_CLASS;
  }

  // ****  Set status

  pHandler->SetStatus(0, sc, NULL, NULL);

  return sc;
}

/*
  IWbemServices::GetObjectByPathAsync

  Purpose: Creates an instance given a particular path value.
*/

HRESULT CWin32Clock::GetObjectAsync(const BSTR ObjectPath, 
                                    long lFlags,
                                    IWbemContext  *pCtx,
                                    IWbemObjectSink FAR* pHandler)
{
  HRESULT 
    sc = WBEM_E_FAILED;

  IWbemClassObject 
    FAR* pObj = NULL;

  WCHAR
    *pwcTest = NULL,
    *pwcVALUE = NULL;

  CObjectPathParser
    ObjPath(e_ParserAcceptRelativeNamespace);

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  SYSTEMTIME
    SystemTime;

  // ****  Parse ObjectPath into a key member name and value
  // ****  <CLASS>.<MEMBER>="<VALUE>"

  if(NULL == ObjectPath)
    return WBEM_E_INVALID_OBJECT_PATH;

  // **** parse object path

  if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) || (NULL == pParsedObjectPath))
  {
    ERRORTRACE((LOG_ESS, "Win32_LocalTime: Parse error for object: %S\n", ObjectPath));
    sc = WBEM_E_INVALID_QUERY;
  }

  // ****  do the get, pass the object on to the notify
    
  if(0 == wbem_wcsicmp(WIN32LOCALTIMECLASS, pParsedObjectPath->m_pClass))
  {
    GetLocalTime(&SystemTime);
    sc = SystemTimeToWin32_CurrentTime(m_pLocalTimeClassDef, &pObj, &SystemTime);

    if(WBEM_S_NO_ERROR == sc) 
    {
      pHandler->Indicate(1,&pObj);
      pObj->Release();
    }
  }
  else if(0 == wbem_wcsicmp(WIN32UTCTIMECLASS, pParsedObjectPath->m_pClass))
  {
    GetSystemTime(&SystemTime);
    sc = SystemTimeToWin32_CurrentTime(m_pUTCTimeClassDef, &pObj, &SystemTime);

    if(WBEM_S_NO_ERROR == sc)
    {
      pHandler->Indicate(1,&pObj);
      pObj->Release();
    }
  }
  else
  {
    ERRORTRACE((LOG_ESS, "Win32_LocalTime: Parse error for object: %S\n", ObjectPath));
    sc = WBEM_E_INVALID_QUERY;
  }

  // ****  Set Status

  pHandler->SetStatus(0,sc, NULL, NULL);

  return sc;
}

/*
  CWin32Clock::CreateInstCurrentTime

  Purpose: creates an instance of the object Win32_CurrentTime representing
           the current time with the given offset UTCOffset
*/

HRESULT CWin32Clock::SystemTimeToWin32_CurrentTime(IWbemClassObject *pClassDef, IWbemClassObject ** pNewInst, SYSTEMTIME *TheTime)
{ 
  HRESULT 
    sc = WBEM_E_FAILED;

  VARIANT
    v;

  // ****  create blank instance of class InstTime

  sc = pClassDef->SpawnInstance(0, pNewInst);
 
  if(FAILED(sc))
    return sc;

  // ****  Create Win32_CurrentTime instance

  v.vt = VT_I4;

  v.lVal = TheTime->wYear; 
  sc = (*pNewInst)->Put(L"Year", 0, &v, 0);

  v.lVal = TheTime->wMonth; 
  sc = (*pNewInst)->Put(L"Month", 0, &v, 0);

  v.lVal = TheTime->wDay; 
  sc = (*pNewInst)->Put(L"Day", 0, &v, 0);

  v.lVal = TheTime->wDayOfWeek; 
  sc = (*pNewInst)->Put(L"DayOfWeek", 0, &v, 0);

  v.lVal = (((8 - (TheTime->wDay - TheTime->wDayOfWeek + 7) % 7) % 7) + TheTime->wDay -1) / 7 + 1; 
  sc = (*pNewInst)->Put(L"WeekInMonth", 0, &v, 0);

  v.lVal = (TheTime->wMonth - 1) / 3 + 1; 
  sc = (*pNewInst)->Put(L"Quarter", 0, &v, 0);

  v.lVal = TheTime->wHour; 
  sc = (*pNewInst)->Put(L"Hour", 0, &v, 0);

  v.lVal = TheTime->wMinute; 
  sc = (*pNewInst)->Put(L"Minute", 0, &v, 0);

  v.lVal = TheTime->wSecond; 
  sc = (*pNewInst)->Put(L"Second", 0, &v, 0);

  VariantClear(&v);

  return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\win32clock.h ===
/*
  Copyright (c) 1997-1999 Microsoft Corporation.

  File:  Win32Clock.H

  Description:
        Alarm event provider - header file defines alarm provider class

  History:
*/


#ifndef _WIN32CLOCKPROV_H_
#define _WIN32CLOCKPROV_H_

#include <objbase.h>
#include <wbemprov.h>
#include "tss.h"
#include "datep.h"
#include <unk.h>

/*
class Win32_CurrentTime
{
  uint16 Year;
  uint32 Month;
  uint32 Day;
  uint32 DayOfWeek;
  uint32 WeekInMonth;
  uint32 Quarter;
  uint32 Hour;
  uint32 Minute;
  uint32 Second;
};
*/

#define WIN32LOCALTIMECLASS  L"Win32_LocalTime"
#define WIN32UTCTIMECLASS  L"Win32_UTCTime"
#define INSTMODEVCLASS  L"__InstanceModificationEvent"

template <class T> class CArray
{
  int
    m_nElts;

  struct _Node { ULONG m_Key; T *m_pT; _Node *m_pNext; }
    *m_pHead;

  CRITICAL_SECTION
    m_hModificationLock;

public:

  CArray(void)
  { 
    m_pHead = NULL; m_nElts = 0; 
    InitializeCriticalSection(&m_hModificationLock); 
  }

  ~CArray(void)
  {
    DeleteCriticalSection(&m_hModificationLock);
  }

  void Lock(void) 
  { EnterCriticalSection(&m_hModificationLock); }

  void UnLock(void)
  { LeaveCriticalSection(&m_hModificationLock); }

  void Insert(T *pT, ULONG Key)  
  // **** to check for dup. keys, change this to sorted order
  {
    Lock();

    _Node
      *pNewNode = NULL;

    if(Key == -1) return;

    pNewNode = new _Node();

    if(NULL == pNewNode) return;

    pNewNode->m_pT = pT; pT->AddRef();
    pNewNode->m_Key = Key;
    pNewNode->m_pNext = m_pHead;
    m_pHead = pNewNode;

    m_nElts++;

    UnLock();
  }

  void Remove(T *pT)
  {
    Lock();

    _Node
      *pCurrent = m_pHead,
      *pPrev = NULL;

    // **** find element using pointer

    while((NULL != pCurrent) && (pCurrent->m_pT != pT))
    {
      pPrev = pCurrent;
      pCurrent = pCurrent->m_pNext;
    }

    // **** remove element, if found, from queue

    if(NULL != pCurrent)
    {
      if(NULL == pPrev)
        m_pHead = m_pHead->m_pNext;
      else
        pPrev->m_pNext = pCurrent->m_pNext;

      pCurrent->m_pT->Release();
      delete pCurrent;
      m_nElts--;
    }

    UnLock();
  }

  // **** find element by Index

  T* operator[] (ULONG Index)
  {
    _Node
      *pCurrent = m_pHead;

    // **** get element using array index
  
    if( Index >= m_nElts )
      return NULL;

    while((NULL != pCurrent) && (Index > 0))  // optimize?
    {
      pCurrent = pCurrent->m_pNext;
      Index--;
    }

    if(NULL != pCurrent)
      return pCurrent->m_pT;

    return NULL;
  }

  // **** get element by key

  T* operator() (ULONG Key, BOOL bLock = FALSE)
  {
    if(TRUE == bLock) Lock();

    _Node
      *pCurrent = m_pHead;

    // **** find element using Key

    while((pCurrent != NULL) && (pCurrent->m_Key != Key))  // optimize?
      pCurrent = pCurrent->m_pNext;

    if(NULL != pCurrent)
      return pCurrent->m_pT;
    else
      if(TRUE == bLock) UnLock();

    return NULL;
  }
};
      
class CWin32Clock
: 
public IWbemEventProvider, 
public IWbemEventProviderQuerySink, 
public IWbemServices,
public IWbemProviderInit
{
public:

  class CScheduledEvent : public CTimerInstruction
  {
  public:

    enum { TypeNONE = 0, TypeUTC, TypeLocal };

    ULONG
      m_Type,
      m_cRef,        // reference count on this object
      m_dwId;        // unique id assigned by WMI

    ULONGLONG
      m_stLastFiringTime;    // the first, and possibly only, firing
                     // time for the event generator

    CWin32Clock
      *m_pWin32Clock; // ptr back to clock obj containing 
                      // this CScheduledEvent object

    wchar_t
      *m_WQLStmt;     // WQL stmt that defines behavior for
                      // this CScheduledEvent object

    int 
      m_nDatePatterns; // # of date pattern objects

    WQLDateTime
      m_WQLTime;       // interprets WQL statement and 
                       // calculates next firing time

    // Local members

    CScheduledEvent();
    ~CScheduledEvent();

    HRESULT Init(CWin32Clock *pClock, wchar_t *WQLStmt, ULONG dwId);
    HRESULT ReInit(wchar_t *WQLStmt);

    void GetTime(SYSTEMTIME *CurrentTime) const;
    void GetFileTime(FILETIME *CurrentTime) const;

    // Inherited from CTimerInstruction

    void AddRef();
    void Release();
    int GetInstructionType();

    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
                                long* plFiringCount) const;
    CWbemTime GetFirstFiringTime() const;
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
  };

  CLifeControl* m_pControl;
  CCritSec      m_csWin32Clock;

  // **** WMI attributes for both Event and Instance providers

  CTimerGenerator   m_Timer;             // timer object to hold pending events
  ULONG             m_cRef;              // reference count on this object
  IWbemServices     *m_pNs;              // resource handle to wmi service daemon
  IWbemClassObject  *m_pLocalTimeClassDef;    // CIM class def for Win32_CurrentTime
  IWbemClassObject  *m_pUTCTimeClassDef;    // CIM class def for Win32_CurrentTime

  // **** WMI Event Provider specific attributes

  ULONGLONG         m_MostRecentLocalFiringTime;
  ULONGLONG         m_MostRecentUTCFiringTime;
  IWbemObjectSink   *m_pSink;            // sink object in which to place inst. objs
  IWbemClassObject  *m_pInstModClassDef; // class def for __InstanceModificationEvent
  HANDLE            m_ClockResetThread;  // holds thread that adjusts firing times
                                         // when the clock is reset
  HWND              m_hEventWindowHandle;

  CArray<CScheduledEvent> m_EventArray;  // array of clock provider objects

public:

  CWin32Clock(CLifeControl* pControl);
 ~CWin32Clock();

  // local members

  static DWORD AsyncEventThread(LPVOID pArg);

  static HRESULT SystemTimeToWin32_CurrentTime(IWbemClassObject *pClassDef, IWbemClassObject ** pNewInst, SYSTEMTIME *TheTime);

  HRESULT SendEvent(IWbemClassObject *pSystemTime);

  HRESULT ReAlignToCurrentTime(void);

  // IUnknown members

  STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
  STDMETHODIMP_(ULONG) AddRef(void);
  STDMETHODIMP_(ULONG) Release(void);

  // Inherited from IWbemEventProvider

  HRESULT STDMETHODCALLTYPE ProvideEvents( 
          /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
          /* [in] */ long lFlags);

  // Inherited from IWbemEventProviderQuerySink

  HRESULT STDMETHODCALLTYPE NewQuery(
          /* [in] */ unsigned long dwId,
          /* [in] */ wchar_t *wszQueryLanguage,
          /* [in] */ wchar_t *wszQuery);

  HRESULT STDMETHODCALLTYPE CancelQuery(
          /* [in] */ unsigned long dwId);

  // Inherited from IWbemProviderInit

  HRESULT STDMETHODCALLTYPE Initialize(
          /* [in] */ LPWSTR pszUser,
          /* [in] */ LONG lFlags,
          /* [in] */ LPWSTR pszNamespace,
          /* [in] */ LPWSTR pszLocale,
          /* [in] */ IWbemServices __RPC_FAR *pNamespace,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);

  // Inherited from IWbemServices

  HRESULT STDMETHODCALLTYPE OpenNamespace( 
          /* [in] */ const BSTR Namespace,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
          /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE QueryObjectSink( 
          /* [in] */ long lFlags,
          /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE GetObject( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE GetObjectAsync( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
      
  HRESULT STDMETHODCALLTYPE PutClass( 
          /* [in] */ IWbemClassObject __RPC_FAR *pObject,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE PutClassAsync( 
          /* [in] */ IWbemClassObject __RPC_FAR *pObject,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteClass( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateClassEnum( 
          /* [in] */ const BSTR Superclass,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
          /* [in] */ const BSTR Superclass,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE PutInstance( 
          /* [in] */ IWbemClassObject __RPC_FAR *pInst,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
          /* [in] */ IWbemClassObject __RPC_FAR *pInst,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteInstance( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
      
  HRESULT STDMETHODCALLTYPE ExecQuery( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
  HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
          IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

  HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
          IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\callsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

History:

    raymcc      29-Jul-98        First draft.

--*/

#include "precomp.h"
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdio.h>
#include <Aclapi.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include "CallSec.h"
#include <helper.h>

//
// code duplicated from WbemComn (same Include file Name :-( )
//

void AdjustPrivIfLocalSystem(HANDLE hPrimary)
{
	////////////////////
	// if we are in LocalSystem, enable all the privileges here
	// to prevent the AdjustTokenPrivileges call done
	// when ESS calls into WmiPrvSe, and preventing WmiPrvSe to 
	// build a HUGE LRPC_SCONTEXT dictionary
	// from now on, if we fail, we bail out with success,
	// since the Token Duplication has succeeded

	DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));       
	BYTE Array[sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))];
	TOKEN_USER * pTokenUser = (TOKEN_USER *)Array;

	BOOL bRet = GetTokenInformation(hPrimary,TokenUser,pTokenUser,dwSize,&dwSize);

	if (!bRet) return;

	SID SystemSid = { SID_REVISION,
	                  1,
	                  SECURITY_NT_AUTHORITY,
	                  SECURITY_LOCAL_SYSTEM_RID 
	                };
	PSID pSIDUser = pTokenUser->User.Sid;
	DWORD dwUserSidLen = GetLengthSid(pSIDUser);
	DWORD dwSystemSid = GetLengthSid(&SystemSid);
	BOOL bIsSystem = FALSE;
	if (dwUserSidLen == dwSystemSid)
	{
		bIsSystem = (0 == memcmp(&SystemSid,pSIDUser,dwUserSidLen));
	};

	if (bIsSystem) // enable all the priviliges
	{
	    DWORD dwReturnedLength = 0;
	    if (FALSE == GetTokenInformation(hPrimary,TokenPrivileges,NULL,0,&dwReturnedLength))
	    {
	        if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) return;
	    }

		BYTE * pBufferPriv = (BYTE *)LocalAlloc(0,dwReturnedLength);
		
		if (NULL == pBufferPriv) return;
		OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMe(pBufferPriv);

		bRet = GetTokenInformation(hPrimary,TokenPrivileges,pBufferPriv,dwReturnedLength,&dwReturnedLength);
		if (!bRet) return;

		TOKEN_PRIVILEGES *pPrivileges = ( TOKEN_PRIVILEGES * ) pBufferPriv ;
		BOOL bNeedToAdjust = FALSE;

		for ( ULONG lIndex = 0; lIndex < pPrivileges->PrivilegeCount ; lIndex ++ )
		{
			if (!(pPrivileges->Privileges [lIndex].Attributes & SE_PRIVILEGE_ENABLED))
			{
				bNeedToAdjust = TRUE;
				pPrivileges->Privileges[lIndex].Attributes |= SE_PRIVILEGE_ENABLED ;
			}
		}

	    if (bNeedToAdjust)
	    {
			bRet = AdjustTokenPrivileges (hPrimary, FALSE, pPrivileges,0,NULL,NULL);            
	    }
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT IsNetworkLogin (

	HANDLE a_Token ,
	BOOL &a_Truth 
)
{
	HRESULT t_Result = S_OK ;

	PSID t_NetworkSid = NULL ;

    SID_IDENTIFIER_AUTHORITY t_NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL t_Status = AllocateAndInitializeSid (

        &t_NtAuthority,
        1,
        SECURITY_NETWORK_RID,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_NetworkSid
    ) ;

    if ( t_Status )
    {
		t_Status = CheckTokenMembership ( a_Token, t_NetworkSid, & a_Truth ) ;
		if ( t_Status ) 
		{
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}

		FreeSid ( t_NetworkSid ) ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetImpersonationLevel (

	HANDLE a_Token ,
	SECURITY_IMPERSONATION_LEVEL &a_Level ,
	TOKEN_TYPE &a_TokenType
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_ReturnLength = 0 ;
	BOOL t_TokenStatus = GetTokenInformation (

		a_Token ,
		TokenType ,
		( void * ) & a_TokenType ,
		sizeof ( a_TokenType ) ,
		& t_ReturnLength
	) ;

	if ( t_TokenStatus )
	{
		if ( a_TokenType == TokenImpersonation )
		{
			t_TokenStatus = GetTokenInformation (

				a_Token ,
				TokenImpersonationLevel ,
				( void * ) & a_Level ,
				sizeof ( a_Level ) ,
				& t_ReturnLength
			) ;

			if ( t_TokenStatus )
			{
				t_Result = S_OK ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						if ( a_Sid )
						{
							if ( *a_Size >= t_ReturnLength )
							{
								t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
								if ( t_TokenUser )
								{
									t_TokenStatus = GetTokenInformation (

										a_Token ,
										t_TokenInformationClass ,
										t_TokenUser ,
										t_ReturnLength ,
										& t_ReturnLength
									) ;

									if ( t_TokenStatus )
									{
										DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
										*a_Size = t_SidLength ;

										CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

										t_Result = S_OK ;
									}

									delete [] t_TokenUser ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_BUFFER_TOO_SMALL ;
							}
						}
						else
						{
							*a_Size = t_ReturnLength ;

							t_Result = S_OK ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUser (

	HANDLE a_Token ,
    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

    if ( a_Token )
	{
		if ( a_Size && a_Buffer ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;

						t_TokenStatus = GetTokenInformation (

							a_Token ,
							t_TokenInformationClass ,
							t_TokenUser ,
							t_ReturnLength ,
							& t_ReturnLength
						) ;
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			if ( t_TokenStatus )
			{
				SID_NAME_USE t_SidNameUse ;
				wchar_t *t_Domain = NULL ;
				wchar_t *t_User = NULL ;
				ULONG t_DomainSize = 0 ;
				ULONG t_UserSize = 0 ;

				BOOL t_LookupStatus = LookupAccountSidW (

					NULL ,
					t_TokenUser->User.Sid ,
					t_User ,
					& t_UserSize ,
					t_Domain ,
					& t_DomainSize ,
					& t_SidNameUse
				) ;

				if ( ! t_LookupStatus )
				{
					DWORD t_LastError = GetLastError () ;

					switch ( t_LastError ) 
					{
						case ERROR_INSUFFICIENT_BUFFER:
						{
							t_User = new wchar_t [ t_UserSize ] ;
							if ( t_User )
							{
								t_Domain = new wchar_t [ t_DomainSize ] ;
								if ( t_Domain ) 
								{
									t_LookupStatus = LookupAccountSidW (

										NULL ,
										t_TokenUser->User.Sid ,
										t_User ,
										& t_UserSize ,
										t_Domain ,
										& t_DomainSize ,
										& t_SidNameUse
									) ;

									if ( t_LookupStatus )
									{
										ULONG t_Size = wcslen ( t_User ) + wcslen ( t_Domain ) + 2 ;

										if ( *a_Size >= t_Size )
										{
											StringCchPrintfW ( a_Buffer , t_Size, L"%s\\%s" , t_Domain , t_User ) ;
										}
										else
										{
											t_Result = WBEM_E_BUFFER_TOO_SMALL ;
										}

										*a_Size = t_Size ;
									}
									else
									{
										if ( GetLastError () == ERROR_NONE_MAPPED )
										{
											t_Result = WBEM_E_NOT_FOUND ;
										}
										else
										{
											t_Result = WBEM_E_FAILED ;
										}
									}

									delete [] t_Domain ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								delete [] t_User ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						break ;

						case ERROR_NONE_MAPPED:
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_FAILED ;
						}
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
				DWORD t_LastError = GetLastError () ;
			}

			if ( t_TokenUser )
			{
				delete [] ( ( BYTE * ) t_TokenUser ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetAuthenticationLuid ( 

	HANDLE a_Token ,
	LPVOID a_Luid
)
{
    if ( a_Token )
	{
		TOKEN_STATISTICS t_Statistics ;

		DWORD t_Returned = 0 ;
		BOOL t_Status = GetTokenInformation (

			a_Token, 
			TokenStatistics, 
			( void * ) & t_Statistics , 
			sizeof ( t_Statistics ) , 
			& t_Returned 
		) ;

		if ( t_Status )
		{
			* ( ( LUID * ) a_Luid ) = t_Statistics.AuthenticationId ;
		}
		else
		{
			return WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
        return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( CLifeControl *a_Control ) : 

	m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( a_Control ) 
{
    if ( m_Control )
    {
        m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( 

	const CWbemThreadSecurityHandle &a_Copy

) : m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( NULL ) 
{
    *this = a_Copy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: ~CWbemThreadSecurityHandle ()
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
	}

    if ( m_ServerPrincipalName )
	{
        CoTaskMemFree ( m_ServerPrincipalName ) ;
	}

    if ( m_Identity )
	{
        CoTaskMemFree ( m_Identity ) ;
	}

    if ( m_Control )
    {
        m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle &CWbemThreadSecurityHandle :: operator= ( const CWbemThreadSecurityHandle &a_Copy )
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
		m_ThreadToken = NULL ;
	}

	if ( a_Copy.m_ThreadToken )
	{
		BOOL t_Status = DuplicateHandle (

			GetCurrentProcess () ,
			a_Copy.m_ThreadToken ,
			GetCurrentProcess () ,
			& m_ThreadToken ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;
	}

	m_Origin = a_Copy.m_Origin ;
    m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

    m_AuthenticationService = a_Copy.m_AuthenticationService ;
    m_AuthorizationService = a_Copy.m_AuthorizationService ;
    m_AuthenticationLevel = a_Copy.m_AuthenticationLevel ;
 
    if ( m_ServerPrincipalName )
    {
        CoTaskMemFree ( m_ServerPrincipalName ) ;
        m_ServerPrincipalName = NULL ;
    }

    if ( a_Copy.m_ServerPrincipalName )
    {        
        size_t length =  wcslen ( a_Copy.m_ServerPrincipalName ) + 1;
	m_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc (length * 2) ;
        if ( m_ServerPrincipalName )
		{
            	StringCchCopyW ( m_ServerPrincipalName , length  , a_Copy.m_ServerPrincipalName ) ;
		}
    }

    if ( m_Identity )
    {
        CoTaskMemFree ( m_Identity ) ;
        m_Identity = NULL ;
    }

    if ( a_Copy.m_Identity )
    {
	size_t lenght = wcslen ( a_Copy.m_Identity ) + 1;
        m_Identity = ( LPWSTR ) CoTaskMemAlloc ( lenght * 2 ) ;
        if ( m_Identity )
		{
            	StringCchCopyW ( m_Identity , lenght  , a_Copy.m_Identity ) ;
		}
    }

    if ( a_Copy.m_Control )
    {
        m_Control = a_Copy.m_Control ;

        if ( m_Control )
        {
            m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
        }
    }

    return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiThreadSecHandle )
    {
        *a_Void = ( void ** ) ( _IWmiThreadSecHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemThreadSecurityHandle )
    {
        *a_Void = ( void ** ) ( CWbemThreadSecurityHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: GetToken ( HANDLE *a_ThreadToken )
{
	HRESULT t_Result = S_OK ;

	if ( a_ThreadToken )
	{
		if ( m_ThreadToken )
		{
			HANDLE t_ThreadToken = NULL ;

			BOOL t_Status = DuplicateHandle (

				GetCurrentProcess () ,
				m_ThreadToken ,
				GetCurrentProcess () ,
				& t_ThreadToken ,
				0 ,
				TRUE ,
				DUPLICATE_SAME_ACCESS
			) ;

			if ( t_Status )
			{
				*a_ThreadToken = t_ThreadToken ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUser ( m_ThreadToken , a_Size , a_Buffer ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUserSid ( m_ThreadToken , a_Size , a_Sid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetAuthenticationLuid ( m_ThreadToken , a_Luid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{		
		if ( a_Level )
		{
			SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
			TOKEN_TYPE t_TokenType = TokenImpersonation ;

			t_Result = :: GetImpersonationLevel ( 

				m_ThreadToken , 
				t_ImpersonationLevel ,
				t_TokenType 		
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				switch ( t_ImpersonationLevel )
				{
					case SecurityAnonymous:
					{
						*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
					}
					break ;
    
					case SecurityIdentification:
					{
						*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
					}
					break ;

					case SecurityImpersonation:
					{
						*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
					}
					break ;

					case SecurityDelegation:
					{
						*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
					}
					break ;

					default:
					{
						*a_Level = 0 ;
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		*a_Level = GetAuthenticationLevel () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: CloneRpcContext ( 

	IServerSecurity *a_Security 
)
{
	HRESULT t_Result = S_OK ;

	// If here, we are not impersonating and we want to gather info
	// about the client's call.
	// ============================================================

	RPC_AUTHZ_HANDLE t_Authorization = NULL ;

	// Ensures auto release of the mutex if we crash

//	CAutoSecurityMutex t_SecurityMutex ;

	DWORD t_ImpersonationLevel = 0 ;

	t_Result = a_Security->QueryBlanket (

		& m_AuthenticationService ,
		& m_AuthorizationService ,
		& m_ServerPrincipalName ,
		& m_AuthenticationLevel ,
		& t_ImpersonationLevel ,
		& t_Authorization ,
		NULL
	) ;

	if ( FAILED ( t_Result ) )
	{

		// In some cases, we cant get the name, but the rest is ok.  In particular
		// the temporary SMS accounts have that property.  Or nt 4 after IPCONFIG /RELEASE

		t_Result = a_Security->QueryBlanket (

			& m_AuthenticationService ,
			& m_AuthorizationService ,
			& m_ServerPrincipalName ,
			& m_AuthenticationLevel ,
			& t_ImpersonationLevel ,
			NULL ,
			NULL
		) ;

		t_Authorization = NULL ;
	}

	// We don't need this anymore.

//	t_SecurityMutex.Release () ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Authorization )
		{
			size_t length = wcslen ( LPWSTR ( t_Authorization ) ) + 1 ;
			m_Identity = LPWSTR ( CoTaskMemAlloc ( length * 2 ) ) ;
			if ( m_Identity )
			{
				StringCchCopyW ( m_Identity, length, LPWSTR ( t_Authorization ) ) ;
			}
		}

		// Impersonate the client long enough to clone the thread token.
		// =============================================================

		BOOL t_Impersonating = a_Security->IsImpersonating () ;
		if ( ! t_Impersonating )
		{
			t_Result = a_Security->ImpersonateClient () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CloneThreadContext () ;

			if ( ! t_Impersonating )
			{
				a_Security->RevertToSelf () ;
			}
		}
	}
	else
	{        
		// THIS IS A WORKAROUND FOR COM BUG:
		// This failure is indicative of an anonymous-level client. 
		// ========================================================

		m_ImpersonationLevel = 0 ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneThreadContext ()
{
	HRESULT t_Result = S_OK ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& m_ThreadToken
	) ;

    if ( t_Status ) 
	{
		// Find out token info.
		// =====================

		DWORD t_ImpersonationLevel = 0 ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			m_ThreadToken ,
			TokenImpersonationLevel ,
			& t_ImpersonationLevel ,
			sizeof ( DWORD ) ,
			& t_Returned
		) ;

		if ( t_Status )
		{
			switch ( t_ImpersonationLevel )
			{
				case SecurityAnonymous:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
            
				case SecurityIdentification:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					m_ImpersonationLevel = 0 ;
				}
				break ;
			}
		}
		else
		{
			if ( GetLastError () == ERROR_ACCESS_DENIED )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
	}
	else
	{
		if ( GetLastError () == ERROR_ACCESS_DENIED )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
		
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneProcessContext ()
{
	HRESULT t_Result = S_OK ;

	m_AuthenticationService = RPC_C_AUTHN_WINNT ;
	m_AuthorizationService = RPC_C_AUTHZ_NONE ;
	m_AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
	m_ServerPrincipalName = NULL ;
	m_Identity = NULL ;
	m_ImpersonationLevel = 0;

	HANDLE hProcessToken = NULL ;
	BOOL bRet;
	bRet = OpenProcessToken(GetCurrentProcess(),
		                   TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
		                   &hProcessToken);
	if (!bRet) return E_FAIL ;
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> ClMe(hProcessToken);

	bRet = DuplicateTokenEx(hProcessToken,MAXIMUM_ALLOWED,NULL,
                    	 ( SECURITY_IMPERSONATION_LEVEL )SecurityImpersonation,
	                     TokenImpersonation,&m_ThreadToken);

	if (!bRet) return E_FAIL;

	// This is the basic process thread. 
	m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	t_Result = S_OK ;

    AdjustPrivIfLocalSystem(m_ThreadToken); 
				
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle  *CWbemThreadSecurityHandle :: New ()
{
	return new CWbemThreadSecurityHandle ( NULL ) ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: CWbemCallSecurity ( 

	CLifeControl *a_Control

) : m_ReferenceCount ( 0 ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_ThreadSecurityHandle ( NULL ) ,
	m_ThreadToken ( NULL ) ,
	m_Control ( a_Control ) 
{
	if ( m_Control ) 
	{
		m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
	}
#ifdef WMI_PRIVATE_DBG
	m_currentThreadID = 0;
	m_lastRevert = 0;
#endif
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: ~CWbemCallSecurity ()
{
	if ( m_ThreadToken )
	{
		CloseHandle ( m_ThreadToken ) ;
	}

    if ( m_ThreadSecurityHandle )
	{
        m_ThreadSecurityHandle->Release () ;
	}

	if ( m_Control ) 
	{
		m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity &CWbemCallSecurity :: operator= ( const CWbemCallSecurity &a_Copy )
{
	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_Copy.m_Control )
	{
		m_Control = a_Copy.m_Control ;

                if ( m_Control )
                {
                    m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
                }
	}

	if ( a_Copy.m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle = new CWbemThreadSecurityHandle ( * ( a_Copy.m_ThreadSecurityHandle ) ) ;
	}

	m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

	m_ReferenceCount = 1 ;

	return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_IServerSecurity )
    {
        *a_Void = ( void ** ) ( IServerSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemCallSecurity )
    {
        *a_Void = ( void ** ) ( CWbemCallSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiCallSec )
    {
        *a_Void = ( void ** ) ( _IWmiCallSec  *) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryBlanket ( 

	DWORD *a_AuthenticationService ,
	DWORD *a_AuthorizationService ,
	OLECHAR **a_ServerPrincipalName ,
	DWORD *a_AuthenticationLevel ,
	DWORD *a_ImpersonationLevel ,
	void **a_Privileges ,
	DWORD *a_Capabilities
)
{
	if ( m_ThreadSecurityHandle )
	{
		if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
		{
			return E_FAIL ;
		}

		if ( a_AuthenticationService )
		{
			*a_AuthenticationService = m_ThreadSecurityHandle->GetAuthenticationService () ;
		}

		if ( a_AuthorizationService )
		{
			*a_AuthorizationService = m_ThreadSecurityHandle->GetAuthorizationService () ;
		}

		if ( a_ImpersonationLevel )
		{
			*a_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ;
		}

		if ( a_AuthenticationLevel )
		{
			*a_AuthenticationLevel = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}

		if ( a_ServerPrincipalName )
		{
			*a_ServerPrincipalName = 0 ;
        
			if ( m_ThreadSecurityHandle->GetServerPrincipalName () )
			{       
				size_t length =  wcslen ( m_ThreadSecurityHandle->GetServerPrincipalName () ) + 1;
				*a_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( length  * 2 ) ;
				if ( *a_ServerPrincipalName )
				{
					StringCchCopyW ( *a_ServerPrincipalName , length , m_ThreadSecurityHandle->GetServerPrincipalName () ) ;	
				}
				else
				{
					return E_OUTOFMEMORY ;
				}
			}
		}        

		if ( a_Privileges )
		{
			*a_Privileges = m_ThreadSecurityHandle->GetIdentity () ;  // Documented to point to an internal!!
		}
	}
	else
	{
		return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CWbemCallSecurity :: ImpersonateClient ()
{
#ifdef WMI_PRIVATE_DBG
    _DBG_ASSERT(m_currentThreadID == 0 || m_currentThreadID == GetCurrentThreadId());
    m_currentThreadID = GetCurrentThreadId();
#endif
	if ( m_ImpersonationLevel != 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
			{
				return ( ERROR_CANT_OPEN_ANONYMOUS | 0x80070000 ) ;
			}

			BOOL t_Status = OpenThreadToken (

				GetCurrentThread () ,
				TOKEN_IMPERSONATE ,
				TRUE ,
				& m_ThreadToken
			) ;

			if ( t_Status == FALSE ) 
			{
				DWORD t_LastError = GetLastError () ;
				if ( ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
				{
				}
				else
				{
					return ( ERROR_ACCESS_DENIED | 0x80070000 ) ;
				}
			}

			t_Status = SetThreadToken ( NULL , m_ThreadSecurityHandle->GetThreadToken () ) ;
			if ( t_Status )
			{
				m_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ; 

				return S_OK ;
			}
			else
			{
				CloseHandle ( m_ThreadToken ) ;

				m_ThreadToken = NULL ;	
			}
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return E_FAIL ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: RevertToSelf ()
{
#ifdef WMI_PRIVATE_DBG
    _DBG_ASSERT(m_currentThreadID == GetCurrentThreadId() || m_currentThreadID == 0);
    m_currentThreadID = 0;
    m_lastRevert = GetCurrentThreadId();
#endif

	if ( m_ImpersonationLevel == 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			// If here,we are impersonating and can definitely revert.
			// =======================================================

			BOOL t_Status = SetThreadToken ( NULL , m_ThreadToken ) ;
			if ( t_Status == FALSE )
			{
				return ( GetLastError () |  0x80070000 ) ;
			}

			CloseHandle ( m_ThreadToken ) ;

			m_ThreadToken = NULL ;

			m_ImpersonationLevel = 0 ;
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
BOOL CWbemCallSecurity :: IsImpersonating ()
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
    IServerSecurity * privateDbgCallSec = NULL;
    CoGetCallContext(IID_IUnknown,(void **)&privateDbgCallSec);

    if (m_ImpersonationLevel && privateDbgCallSec == this)
    {
        HANDLE hToken = NULL;
        BOOL bRes = OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,TRUE,&hToken);
       _DBG_ASSERT(bRes);
       if (hToken) CloseHandle(hToken);
   };
   if (privateDbgCallSec) privateDbgCallSec->Release();
#endif
#endif

	if ( m_ImpersonationLevel != 0 )
	{
		return TRUE ;
	}

	return FALSE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetThreadSecurity ( 

	WMI_THREAD_SECURITY_ORIGIN a_Origin , 
	_IWmiThreadSecHandle **a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_ValidOrigin = ( ( a_Origin & WMI_ORIGIN_THREAD ) || ( a_Origin & WMI_ORIGIN_EXISTING ) || ( a_Origin & WMI_ORIGIN_RPC ) ) ;

	if ( a_ThreadSecurity && t_ValidOrigin )
	{
		if ( a_Origin & WMI_ORIGIN_THREAD )
		{
			*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
			if ( *a_ThreadSecurity )
			{
				( *a_ThreadSecurity )->AddRef () ;

				( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

				t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneThreadContext () ;
				if ( FAILED ( t_Result ) )
				{	
					( *a_ThreadSecurity )->Release () ;
					*a_ThreadSecurity = NULL;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( a_Origin & WMI_ORIGIN_RPC || a_Origin & WMI_ORIGIN_EXISTING )
			{
				// Figure out if the call context is ours or RPCs
				// ==============================================

				IServerSecurity *t_Security = NULL ;
				t_Result = CoGetCallContext ( IID_IServerSecurity , ( void ** ) & t_Security ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemCallSecurity *t_Internal = NULL ;
					if ( SUCCEEDED ( t_Security->QueryInterface ( IID_CWbemCallSecurity , ( void ** ) & t_Internal ) ) )
					{
						
						// This is our own call context --- this must be an in-proc object
						// calling us from our thread.  Behave depending on the flags
						// ===============================================================

						if ( a_Origin & WMI_ORIGIN_EXISTING ) 
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( *t_Internal->GetThreadSecurityHandle () ) ;
							if ( *a_ThreadSecurity )
							{
								(*a_ThreadSecurity)->AddRef () ;

								t_Result = S_OK ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}

						t_Internal->Release () ;
					}
					else
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}

					if ( t_Result == WBEM_E_NOT_FOUND ) 
					{
						if ( a_Origin & WMI_ORIGIN_RPC )
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
							if ( *a_ThreadSecurity )
							{
								( *a_ThreadSecurity )->AddRef () ;

								t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneRpcContext ( 

									t_Security 
								) ;

								if ( SUCCEEDED( t_Result ) )
								{
									( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity) ->SetOrigin ( WMI_ORIGIN_RPC ) ;
								}
								else
								{	
									( *a_ThreadSecurity )->Release ();
									*a_ThreadSecurity = NULL;
								}

							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}

					t_Security->Release();
				}
				else
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					if ( a_Origin & WMI_ORIGIN_THREAD )
					{
						*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
						if ( *a_ThreadSecurity )
						{
							( *a_ThreadSecurity )->AddRef () ;

							( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

							t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			else
			{
				if ( a_Origin & WMI_ORIGIN_THREAD )
				{
					*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
					if ( *a_ThreadSecurity )
					{
						( *a_ThreadSecurity )->AddRef () ;

						( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

						t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: SetThreadSecurity ( 

	_IWmiThreadSecHandle *a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_ThreadSecurity ) 
	{
		CWbemThreadSecurityHandle *t_ThreadHandle = NULL ; 
		t_Result = a_ThreadSecurity->QueryInterface ( IID_CWbemThreadSecurityHandle , ( void ** ) & t_ThreadHandle ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			m_ThreadSecurityHandle = t_ThreadHandle ;

			IUnknown *t_Unknown = NULL ;
			IUnknown *t_SwitchUnknown = NULL ;
			t_Result = this->QueryInterface ( IID_IUnknown , ( void **) & t_SwitchUnknown ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoSwitchCallContext ( t_SwitchUnknown, & t_Unknown ) ;
		
				t_SwitchUnknown->Release () ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess() ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUser ( t_Token , a_Size , a_Buffer ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUserSid ( t_Token , a_Size , a_Sid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetAuthenticationLuid ( t_Token , a_Luid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		HANDLE t_Token = NULL ;

		BOOL t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			& t_Token
		) ;

		DWORD t_LastError = GetLastError () ;
		if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
		{
			*a_Level = 0 ;
		}
		else
		{
			if ( t_Status ) 
			{
				SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
				TOKEN_TYPE t_TokenType = TokenImpersonation ;
 
				t_Result = :: GetImpersonationLevel ( 

					t_Token , 
					t_ImpersonationLevel ,
					t_TokenType 		
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					switch ( t_ImpersonationLevel )
					{
						case SecurityAnonymous:
						{
							*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
						}
						break ;
            
						case SecurityIdentification:
						{
							*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
						}
						break ;

						case SecurityImpersonation:
						{
							*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
						}
						break ;

						case SecurityDelegation:
						{
							*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
						}
						break ;

						default:
						{
							*a_Level = 0 ;
						}
						break ;
					}
				}

				CloseHandle ( t_Token ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		if ( m_ThreadSecurityHandle )
		{
			*a_Level = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity  *CWbemCallSecurity :: New ()
{
	// NULL instead of g_pLifeControl
	// provider subsystem links statically
	return new CWbemCallSecurity ( NULL ) ;
}


//
//
//
///////////////////////////////////////////////

CIdentitySec::CIdentitySec()
{
    SID SystemSid = { SID_REVISION,
                      1,
                      SECURITY_NT_AUTHORITY,
                      SECURITY_LOCAL_SYSTEM_RID 
                    };
    
    CNtSid tempSystem((PSID)&SystemSid);
    m_sidSystem = tempSystem;
    if (!m_sidSystem.IsValid())
        throw CX_Exception();

    HRESULT hres = RetrieveSidFromCall(m_sidUser);
    if(FAILED(hres))
           throw CX_Exception();
}

CIdentitySec::~CIdentitySec()
{
}

HRESULT 
CIdentitySec::GetSidFromThreadOrProcess(/*out*/ CNtSid & UserSid)
{
    HANDLE hToken = NULL;
    BOOL bRet = OpenThreadToken(GetCurrentThread(),TOKEN_QUERY, TRUE, &hToken);
    if (FALSE == bRet)
    {
        long lRes = GetLastError();
        if(ERROR_NO_IMPERSONATION_TOKEN == lRes || ERROR_NO_TOKEN == lRes)            
        {
            bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken);
            if (FALSE == bRet) HRESULT_FROM_WIN32(GetLastError());
        }
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> CloseMe(hToken);

    DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));       
    BYTE Array[sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))];
    TOKEN_USER * pTokenUser = (TOKEN_USER *)Array;

    bRet = GetTokenInformation(hToken,TokenUser,pTokenUser,dwSize,&dwSize);
    if (!bRet) return HRESULT_FROM_WIN32(GetLastError());

    PSID pSIDUser = pTokenUser->User.Sid;
    CNtSid tempSid(pSIDUser);
    UserSid = tempSid;

    if (UserSid.IsValid())
        return S_OK;
    else
        return WBEM_E_OUT_OF_MEMORY;
    
}

HRESULT 
CIdentitySec::RetrieveSidFromCall(/*out*/ CNtSid & UserSid)
{
    HRESULT hr;
    IServerSecurity * pCallSec = NULL;
    if (S_OK == CoGetCallContext(IID_IServerSecurity,(void **)&pCallSec))
    {
        OnDelete<IUnknown *,void(*)(IUnknown *),RM> dm(pCallSec);
        if (pCallSec->IsImpersonating())
            return GetSidFromThreadOrProcess(UserSid);
        else
        {
            RETURN_ON_ERR(pCallSec->ImpersonateClient());
            OnDeleteObj0<IServerSecurity ,
                         HRESULT(__stdcall IServerSecurity:: * )(void),
                         &IServerSecurity::RevertToSelf> RevertSec(pCallSec);
            
            return GetSidFromThreadOrProcess(UserSid); 
        }
    } 
    else
        return GetSidFromThreadOrProcess(UserSid);
}

BOOL CIdentitySec::AccessCheck()
{
    // Find out who is calling
    // =======================

    CNtSid sidCaller;
    HRESULT hres = RetrieveSidFromCall(sidCaller);
    if(FAILED(hres))
        return FALSE;

    // Compare the caller to the issuing user and ourselves
    // ====================================================

    if(sidCaller == m_sidUser || sidCaller == m_sidSystem)
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\callsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:


History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _CALLSEC_H_
#define _CALLSEC_H_

#include <winntsec.h>

// {4551AB1A-C16F-40f3-A192-6A6264FE89D6}
DEFINE_GUID(IID_CWbemCallSecurity, 
0x4551ab1a, 0xc16f, 0x40f3, 0xa1, 0x92, 0x6a, 0x62, 0x64, 0xfe, 0x89, 0xd6);

// {60B9F5CA-036E-4795-BB7C-017B9807E9B3}
DEFINE_GUID(IID_CWbemThreadSecurityHandle, 
0x60b9f5ca, 0x36e, 0x4795, 0xbb, 0x7c, 0x1, 0x7b, 0x98, 0x7, 0xe9, 0xb3);


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class COREPROX_POLARITY CWbemThreadSecurityHandle : public _IWmiThreadSecHandle
{
private:

    LONG m_ReferenceCount ;

    HANDLE m_ThreadToken ;
    DWORD m_ImpersonationLevel ;
	DWORD m_AuthenticationService ;
	DWORD m_AuthorizationService ;
	DWORD m_AuthenticationLevel ;
	LPWSTR m_ServerPrincipalName ;
	LPWSTR m_Identity ;

	WMI_THREAD_SECURITY_ORIGIN m_Origin ;

	CLifeControl *m_Control ;

public:

    CWbemThreadSecurityHandle ( CLifeControl *a_Control ) ;
	CWbemThreadSecurityHandle ( const CWbemThreadSecurityHandle &a_Copy ) ;
   ~CWbemThreadSecurityHandle () ;

    CWbemThreadSecurityHandle &operator= ( const CWbemThreadSecurityHandle &a_Copy ) ;

	HRESULT CloneRpcContext (

		IServerSecurity *a_Security
	) ;

	HRESULT CloneThreadContext () ;

	HRESULT CloneProcessContext () ;

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 *
 */

	HRESULT STDMETHODCALLTYPE GetHandleType ( ULONG *a_Type ) { return WMI_HANDLE_THREAD_SECURITY; }

	HRESULT STDMETHODCALLTYPE GetTokenOrigin ( WMI_THREAD_SECURITY_ORIGIN *a_Origin ) { return m_Origin ; }

/*
 *	_IWmiThreadSecHandle
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

		DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetToken ( HANDLE *a_ThreadToken ) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

/*
 * Implementation publics
 */

    HANDLE GetThreadToken () { return m_ThreadToken ; }
    DWORD GetImpersonationLevel () { return m_ImpersonationLevel ; }
	DWORD GetAuthenticationService () { return m_AuthenticationService ; }
	DWORD GetAuthorizationService () { return m_AuthorizationService ; }
	DWORD GetAuthenticationLevel () { return m_AuthenticationLevel ; }
	LPWSTR GetServerPrincipalName () { return m_ServerPrincipalName ; }
	LPWSTR GetIdentity () { return m_Identity ; }

	void SetOrigin ( WMI_THREAD_SECURITY_ORIGIN a_Origin ) { m_Origin = a_Origin ; }

	static CWbemThreadSecurityHandle *New () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class COREPROX_POLARITY CWbemCallSecurity : public IServerSecurity  , public _IWmiCallSec
{
private:

    LONG m_ReferenceCount ;
	DWORD m_ImpersonationLevel ;
	CWbemThreadSecurityHandle *m_ThreadSecurityHandle ;
	HANDLE m_ThreadToken ;

	CLifeControl *m_Control ;

#ifdef WMI_PRIVATE_DBG
	DWORD m_currentThreadID;
	DWORD m_lastRevert;
#endif

public:

	CWbemCallSecurity ( CLifeControl *a_Control ) ;
   ~CWbemCallSecurity () ;

    CWbemCallSecurity &operator= ( const CWbemCallSecurity &a_Copy ) ;

public:

	CWbemThreadSecurityHandle *GetThreadSecurityHandle () { return m_ThreadSecurityHandle ; }

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 * IServerSecurity.
 */

    HRESULT STDMETHODCALLTYPE QueryBlanket (

		DWORD *a_AuthenticationService ,
		DWORD *a_AuthorizationService ,
		OLECHAR **a_ServerPrincipleName ,
		DWORD *a_AuthorizationLevel ,
		DWORD *a_ImpersonationLevel ,
		void **a_Privileges ,
		DWORD *a_Capabilities
	) ;

	HRESULT STDMETHODCALLTYPE ImpersonateClient () ;

	HRESULT STDMETHODCALLTYPE RevertToSelf () ;

	BOOL STDMETHODCALLTYPE IsImpersonating () ;

/*
 *	_IWmiCallSec
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

        DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

    HRESULT STDMETHODCALLTYPE GetThreadSecurity ( WMI_THREAD_SECURITY_ORIGIN a_Origin , _IWmiThreadSecHandle **a_ThreadSecurity ) ;

    HRESULT STDMETHODCALLTYPE SetThreadSecurity ( _IWmiThreadSecHandle *a_ThreadSecurity ) ;

	static CWbemCallSecurity *New () ;
} ;

class CIdentitySec
{
private:
    CNtSid m_sidUser;
    CNtSid m_sidSystem;	

    HRESULT GetSidFromThreadOrProcess(CNtSid & UserSid);
    HRESULT RetrieveSidFromCall(CNtSid & UserSid);
public:	
	CIdentitySec();
	~CIdentitySec();
    BOOL AccessCheck();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\cloadhpenum.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLOADHPENUM.H

Abstract:

    Client Loadable Hi-Perf Enumerator

History:

--*/

#ifndef __CLIENTLOADABLEHPENUM__H_
#define __CLIENTLOADABLEHPENUM__H_

#include <unk.h>
#include <wbemcomn.h>

// 
//  implements ClearElements ()
//  we garbage collect from the rear
//
//////////////////////////////////////////////////////////
class CHPRemoteObjectArray : public CGarbageCollectArray
{
public:
    CHPRemoteObjectArray() :
        CGarbageCollectArray( FALSE ) // not from the front
    {};
    ~CHPRemoteObjectArray()
    {};

    void ClearElements( int nNumToClear );

};

class CClientLoadableHiPerfEnum : public CHiPerfEnum
{
public:

    CClientLoadableHiPerfEnum( CLifeControl* pLifeControl );
    ~CClientLoadableHiPerfEnum();

    // Our own function for copying objects into an allocated array
    HRESULT Copy( CClientLoadableHiPerfEnum* pEnumToCopy );
    HRESULT Copy( long lBlobType, long lBlobLen, BYTE* pBlob );
	HRESULT Replace( BOOL fRemoveAll, LONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );

protected:

    // Ensure that we have enough objects and object data pointers to handle
    // the specified number of objects
    HRESULT EnsureObjectData( DWORD dwNumRequestedObjects, BOOL fClone = TRUE );

    CLifeControl*               m_pLifeControl;
    CHPRemoteObjectArray        m_apRemoteObj;
};

//
// prohibits client from removing objects
// only GetObjects is allowed to be called
//
///////////////////////////////////////////////////////////
class CReadOnlyHiPerfEnum : public CClientLoadableHiPerfEnum
{
public:

    CReadOnlyHiPerfEnum( CLifeControl* pLifeControl );
    ~CReadOnlyHiPerfEnum();

    STDMETHOD(AddObjects)( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );
    STDMETHOD(RemoveObjects)( long lFlags, ULONG uNumObjects, long* apIds );
    STDMETHOD(RemoveAll)( long lFlags );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\cloadhpenum.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLOADHPENUM.CPP

Abstract:

    Client Loadable Hi-Perf Enumerator

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <hiperfenum.h>
#include "cloadhpenum.h"

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::CClientLoadableHiPerfEnum
//
//  Purpose:
//      Constructor.
//
//  Inputs:
//      CLifeControl*   pLifeControl - Controls the DLL lifetime.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CClientLoadableHiPerfEnum::CClientLoadableHiPerfEnum( CLifeControl* pLifeControl ):   
    m_pLifeControl( pLifeControl ),
    m_apRemoteObj()
{
    m_pLifeControl->ObjectCreated( this );
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::~CClientLoadableHiPerfEnum
//
//  Purpose:
//      Destructor.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CClientLoadableHiPerfEnum::~CClientLoadableHiPerfEnum()
{
    // Release all the pointers in this array
    IWbemClassObject*   pObj = NULL;
    for( DWORD dwCtr = 0; dwCtr < m_apRemoteObj.Size(); dwCtr++ )
    {
        pObj = (IWbemClassObject*) m_apRemoteObj[dwCtr];
        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }
    m_pLifeControl->ObjectDestroyed( this );
}


/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Copy
//
//  Purpose:
//      Copies objects from one enumerator into this one.
//
//  Inputs:
//      CClientLoadableHiPerfEnum*  pEnumToCopy - Enumerator to copy.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      New Objects are cloned from a template.
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Copy( CClientLoadableHiPerfEnum* pEnumToCopy )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( m_Lock );
    CHiPerfLockAccess   lockSrc( pEnumToCopy->m_Lock );

    // Get through both locks first
    if ( lock.IsLocked() && lockSrc.IsLocked() )
    {
        // Make sure we have enough object data and BLOBs to handle data copying
        hr = EnsureObjectData( pEnumToCopy->m_aIdToObject.Size() );

        // Now copy out the BLOBs
        if ( SUCCEEDED( hr ) )
        {

            DWORD   dwCtr = 0;

            // Write the objects and ids out to the array
            for ( dwCtr = 0; SUCCEEDED( hr ) && dwCtr < pEnumToCopy->m_aIdToObject.Size(); dwCtr++ )
            {
                // Make sure the object is not-NULL, otherwise we need to clone the supplied
                // object.  It may be NULL because someone used the standard Remove methods
                // on the HiPerf Enumerator

                if ( ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj != NULL )
                {
                    hr = ((CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj)->CopyBlobOf(
                            (CWbemObject*) ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_pObj );
                }
                else
                {
                    // Clone the object
                    IWbemClassObject*   pObj = NULL;
                    IWbemObjectAccess*  pAccess = NULL;
                    hr = ((CWbemObject*)
                            ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_pObj)->Clone( &pObj );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );

                        // Clean up the objects
                        pObj->Release();

                        if ( SUCCEEDED( hr ) )
                        {
                            // It's sleazy, but quicker than a QI
                            ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->SetObject( pAccess );

                            // Data object should have the AddRef() here.
                            pAccess->Release();
                        }
                    }
                }

                ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_lId = 
                    ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_lId;
            }

            // if everything is okay, go ahead and do any necessary garbage collection on
            // our arrays.

            if ( SUCCEEDED( hr ) )
            {
                m_aReusable.GarbageCollect();
                pEnumToCopy->m_aReusable.GarbageCollect();

                // We don't use remote objects here, so don't worry about garbage
                // collecting that array here.


            }

        }   // IF EnsureObjectData

    }
    else
    {
        // If we can't get access to the enumerator to figure out the objects
        // we need to add to enumeration, something is pretty badly wrong.
        hr = WBEM_E_REFRESHER_BUSY;
    }


    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Copy
//
//  Purpose:
//      Resets this enumerator using a transfer BLOB and other
//      data.  This is so we can support remote refreshable
//      enumerations.
//
//  Inputs:
//      long                lBlobType - Blob Type
//      long                lBlobLen - Blob Length
//      BYTE*               pBlob - Raw Data to initialize from
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Internal function
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Copy( long lBlobType, long lBlobLen, BYTE* pBlob )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( m_Lock );

    if ( ! lock.IsLocked() ) return  WBEM_S_TIMEDOUT;

    long    lNumObjects = 0;

    hr = CWbemInstance::CopyTransferArrayBlob( m_pInstTemplate, lBlobType, lBlobLen, pBlob, m_apRemoteObj, &lNumObjects );

    if ( SUCCEEDED( hr ) )
    {
        // The objects cloned above will do quite nicely
        hr = EnsureObjectData( lNumObjects, FALSE );

        if ( SUCCEEDED( hr ) )
        {
            // Now walk the array of remote objects and the Object-To-ID Array, and reset objects
            // and ids

            IWbemObjectAccess*  pAccess = NULL;

            for ( long  lCtr = 0; lCtr < lNumObjects; lCtr++ )
            {
                // It's sleazy, but quicker than a QI
                ((CHiPerfEnumData*) m_aIdToObject[lCtr])->SetObject(
                                    (IWbemObjectAccess*) m_apRemoteObj[lCtr] );
                ((CHiPerfEnumData*) m_aIdToObject[lCtr])->SetId( lCtr );
            }

            // if everything is okay, go ahead and do any necessary garbage collection on
            // our arrays.

            m_aReusable.GarbageCollect();

            // On this one, since the remote object array should contain the same
            // number of objects as what is in the main array the number of objects
            // to garbage collect is the difference between the two.
            m_apRemoteObj.GarbageCollect(
                m_apRemoteObj.Size() - m_aIdToObject.Size() );


        }   // IF EnsureObjectData

    }   // IF CopyTransferArray Blob

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Replace
//
//  Purpose:
//      Resets this enumerator if appropriate and adds elements.
//
//  Inputs:
//      BOOL            fRemoveAll - Flag whether or not to remove
//                                        all elements.
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      Internal functions
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Replace( BOOL fRemoveAll, LONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( m_Lock );
    if ( !lock.IsLocked() ) return WBEM_S_TIMEDOUT;;

    // Use the base class implementations so we actually update the enumerator
    if ( fRemoveAll )
    {
        CHiPerfEnum::RemoveAll( 0L );
    }

    hr = CHiPerfEnum::AddObjects( 0L, uNumObjects, apIds, apObj );

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::EnsureObjectData
//
//  Purpose:
//      Ensures that we have enough objects and object data
//      pointers to handle the requested number of objects.
//
//  Inputs:
//      DWORD   dwNumRequestedObjects - Number of requested objects.
//      BOOL    fClone -    Indicates whether we should clone objects
//                          when we allocate object data pointers.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      New Objects are cloned from a template if necessary.
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::EnsureObjectData( DWORD dwNumRequestedObjects, BOOL fClone /*=TRUE*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwNumObjects = m_aIdToObject.Size() + m_aReusable.Size();

    // See if we will have enough hiperfenum data pointers to handle the objects
    if ( dwNumRequestedObjects > dwNumObjects )
    {
        DWORD               dwNumNewObjects = dwNumRequestedObjects - dwNumObjects;
        CHiPerfEnumData*    pData = NULL;
        IWbemClassObject*   pObj = NULL;
        IWbemObjectAccess*  pAccess = NULL;

        // Clone new instance objects and stick them in the id to object array
        for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumNewObjects; dwCtr++ )
        {
            if ( fClone )
            {
                hr = m_pInstTemplate->Clone( &pObj );

                if ( SUCCEEDED( hr ) )
                {
                    hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );

                    // Release the object
                    pObj->Release();
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                pData = new CHiPerfEnumData( 0, pAccess );

                // Should be AddRefd by data objects
                if ( NULL != pAccess )
                {
                    pAccess->Release();
                }

                if ( NULL != pData )
                {
                    if ( m_aIdToObject.Add( (void*) pData ) != CFlexArray::no_error )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF Clone

        }   // FOR allocate new objects

    }   // IF we need new objects

    if ( SUCCEEDED( hr ) )
    {
        // Move objects from the reusable array if we don't have enough
        // or move them into the reusable array if we have to many

        if ( dwNumRequestedObjects > m_aIdToObject.Size() )
        {
            DWORD   dwNumObjectsNeeded = dwNumRequestedObjects - m_aIdToObject.Size();

            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumObjectsNeeded; dwCtr++ )
            {
                if ( m_aIdToObject.Add( m_aReusable[m_aReusable.Size() - 1] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aReusable.RemoveAt( m_aReusable.Size() - 1 );
                }
            }

        }
        else if ( dwNumRequestedObjects < m_aIdToObject.Size() )
        {
            DWORD   dwNumExtraObjects = m_aIdToObject.Size() - dwNumRequestedObjects;

            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumExtraObjects; dwCtr++ )
            {
                if ( m_aReusable.Add( m_aIdToObject[m_aIdToObject.Size() - 1] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aIdToObject.RemoveAt( m_aIdToObject.Size() - 1 );
                }
            }

        }

    }   // IF we ensured enough Object Data Pointers

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::CReadOnlyHiPerfEnum
//
//  Purpose:
//      Constructor.
//
//  Inputs:
//      CLifeControl*   pLifeControl - Controls the DLL lifetime.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CReadOnlyHiPerfEnum::CReadOnlyHiPerfEnum( CLifeControl* pLifeControl )
:   CClientLoadableHiPerfEnum( pLifeControl )
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::~CReadOnlyHiPerfEnum
//
//  Purpose:
//      Destructor.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CReadOnlyHiPerfEnum::~CReadOnlyHiPerfEnum()
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::AddObjects
//
//  Purpose:
//      Adds new objects to the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::AddObjects( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    return WBEM_E_ACCESS_DENIED;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::Remove
//
//  Purpose:
//      Removes specified objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::RemoveObjects( long lFlags, ULONG uNumObjects, long* apIds )
{
    return WBEM_E_ACCESS_DENIED;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveAll
//
//  Purpose:
//      Removes all objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::RemoveAll( long lFlags )
{
    return WBEM_E_ACCESS_DENIED;
}

// Walks the array and cleans up the specified number of elements
void CHPRemoteObjectArray::ClearElements( int nNumToClear )
{

    // We need to clear from the end
    for ( int nCtr = ( m_nSize - nNumToClear ); nCtr < m_nSize; nCtr++ )
    {
        IWbemObjectAccess* pAcc = (IWbemObjectAccess*) GetAt(nCtr);

        _ASSERT( NULL != pAcc, "Tried to clear a NULL Element!" );
        if ( NULL != pAcc )
        {
            pAcc->Release();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\context.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CONTEXT.CPP

Abstract:

    CWbemContext Implementation

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "context.h"
#include <corex.h>
#include <algorithm>
#include <helper.h>
#include <fastobj.h>

#define MAX_VARIANT_SIZE 8 // sizeof UINT64

DWORD GetBSTRMarshalSize(BSTR str)
{
    return wcslen(str)*2 + sizeof(long);
}

HRESULT MarshalBSTR(IStream* pStream, BSTR str)
{
    HRESULT hres;
    long lLen = wcslen(str);
    hres = pStream->Write((void*)&lLen, sizeof(lLen), NULL);
    if(FAILED(hres)) return hres;
    return pStream->Write((void*)str, lLen*2, NULL);
}

auto_bstr UnmarshalBSTR (IStream* pStream,DWORD & dwStreamSize)
{
  long lLen;
  
  HRESULT hres;
  hres = pStream->Read((void*)&lLen, sizeof(lLen), NULL);
  _com_util::CheckError (hres);
  dwStreamSize -= sizeof(lLen);

  if ((lLen*2) > dwStreamSize ) throw CX_Exception();
  
  auto_bstr str (SysAllocStringLen (NULL, lLen));
  if (str.get() == NULL && lLen !=0)
    throw CX_MemoryException();
  hres = pStream->Read((void*)str.get(), lLen*2, NULL);
  _com_util::CheckError (hres);

  dwStreamSize -= (lLen*2);
  return str;
}

HRESULT UnmarshalBSTR(IStream* pStream, BSTR& str,DWORD & dwStreamSize)
{
    long lLen;
    HRESULT hres;
    hres = pStream->Read((void*)&lLen, sizeof(lLen), NULL);
    if(FAILED(hres)) return hres;

    dwStreamSize -= sizeof(lLen);

    if ((lLen*2) > dwStreamSize) return E_FAIL;

    str = SysAllocStringLen(NULL, lLen);
	if (!str)
		return WBEM_E_OUT_OF_MEMORY;
    hres = pStream->Read((void*)str, lLen*2, NULL);
    if(FAILED(hres)) 
    {
        SysFreeString(str);
        return hres;
    }
    dwStreamSize -= (lLen*2);
    return S_OK;
}

DWORD GetSafeArrayMarshalSize(VARTYPE vt, SAFEARRAY* psa)
{
    HRESULT hres;

    DWORD dwLen = sizeof(long)*2; // num elements and size of element

    // Compute vital statistics
    // ========================

    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lNumElements = lUBound - lLBound + 1;
    DWORD dwElemSize = SafeArrayGetElemsize(psa);

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);

    if(vt == VT_BSTR)
    {
        // Add all BSTR sizes
        // ==================

        BSTR* pstrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            dwLen += GetBSTRMarshalSize(pstrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            DWORD dwThis = 0;
            hres = CoGetMarshalSizeMax(&dwThis, IID_IWbemClassObject, 
                                apObjects[i], 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            if(FAILED(hres)) return hres;
            dwLen += dwThis;
        }
    }
    else
    {
        dwLen += lNumElements*dwElemSize;
    }
    return dwLen;
}
    

HRESULT MarshalSafeArray(IStream* pStream, VARTYPE vt, SAFEARRAY* psa)
{
    HRESULT hres;

    // First, write the number of elements
    // ===================================

    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lNumElements = lUBound - lLBound + 1;

    hres = pStream->Write((void*)&lNumElements, sizeof(lNumElements), NULL);
    if(FAILED(hres)) return hres;

    // Second, write element size
    // ==========================

    DWORD dwElemSize = SafeArrayGetElemsize(psa);
    hres = pStream->Write((void*)&dwElemSize, sizeof(dwElemSize), NULL);
    if(FAILED(hres)) return hres;

    // Now, write all the elements out
    // ===============================

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);

    if(vt == VT_BSTR)
    {
        BSTR* astrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            MarshalBSTR(pStream, astrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = CoMarshalInterface(pStream, IID_IWbemClassObject, 
                           apObjects[i], MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            if(FAILED(hres)) return hres;
        }
    }
    else
    {
        // Just dump the data
        // ==================

        hres = pStream->Write((void*)pData, dwElemSize*lNumElements, NULL);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}


HRESULT UnmarshalSafeArray(IStream* pStream, 
	                       VARTYPE vt, 
	                       SAFEARRAY*& psa,
	                       DWORD & dwStreamSize)
{
    HRESULT hres;

    // Read the number of elements
    // ===========================

    long lNumElements;
    hres = pStream->Read((void*)&lNumElements, sizeof(lNumElements), NULL);
    if(FAILED(hres)) return hres;
    dwStreamSize -= sizeof(lNumElements);
    
    // Read the size of an element
    // ===========================

    DWORD dwElemSize;
    hres = pStream->Read((void*)&dwElemSize, sizeof(dwElemSize), NULL);
    if(FAILED(hres)) return hres;
    dwStreamSize -= sizeof(dwElemSize);
    
    // Create the appropriate SafeArray
    // ================================

    SAFEARRAYBOUND sab;
    sab.lLbound = 0;
    sab.cElements = lNumElements;

    psa = SafeArrayCreate(vt, 1, &sab);
    if(psa == NULL) return E_FAIL;
    OnDeleteIf<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> desme(psa);

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    OnDelete<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayUnaccessData> um(psa);

    if(vt == VT_BSTR)
    {
        // Read all the BSTRs
        // ==================

        BSTR* astrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = UnmarshalBSTR(pStream, astrData[i], dwStreamSize);
            if (FAILED(hres)) return hres;
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        // Read all the objects
        // ====================

        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = CoUnmarshalInterface(pStream, IID_IWbemClassObject, 
                           (void**)(apObjects + i));
            if(FAILED(hres)) return hres;
        } 
        
        STATSTG StatStg;
        if (FAILED(hres = pStream->Stat(&StatStg,STATFLAG_DEFAULT))) return hres;
        
		LARGE_INTEGER li; li.QuadPart = 0;
		ULARGE_INTEGER Position;
		hres = pStream->Seek(li,STREAM_SEEK_CUR,&Position);
		dwStreamSize = StatStg.cbSize.LowPart - Position.LowPart; 
    }
    else
    {
        // Read the block
        // ==============
        UINT ExpectedElemSize = SafeArrayGetElemsize(psa);
        if (ExpectedElemSize != dwElemSize) return E_FAIL;

        ULONG TotRead = dwElemSize*lNumElements;
        if (TotRead > dwStreamSize ) return E_FAIL;
        
        hres = pStream->Read((void*)pData,TotRead , NULL);
        if(FAILED(hres)) return hres;
        dwStreamSize -= TotRead;
    }
    desme.dismiss();
    return S_OK;
}
        

CWbemContext::CContextObj::CContextObj(LPCWSTR wszName, 
				       long lFlags, 
                                       VARIANT* pvValue)
    : m_lFlags(lFlags), m_strName (clone (wszName)), m_vValue (pvValue)
{
}

CWbemContext::CContextObj::CContextObj(const CContextObj& Obj)
    : m_lFlags(Obj.m_lFlags), m_strName (clone (Obj.m_strName.get ())), m_vValue (Obj.m_vValue)
{
}
    
CWbemContext::CContextObj::CContextObj(IStream* pStream,DWORD & dwStreamSize)
{
  HRESULT hres;
  // Read the name
  // =============
  m_strName = UnmarshalBSTR (pStream,dwStreamSize);

  // Read the flags
  // ==============
  hres = pStream->Read((void*)&m_lFlags, sizeof(m_lFlags), NULL);
  _com_util::CheckError (hres);

  dwStreamSize -= sizeof(m_lFlags);

  // Read the VARTYPE
  // ================
  VARIANT Var;

  hres = pStream->Read((void*)&(V_VT(&Var)), sizeof(VARTYPE), NULL);
  _com_util::CheckError (hres);

  dwStreamSize -= sizeof(VARTYPE);

  // Read the data
  // =============

  switch(V_VT(&Var))
  {
  case VT_NULL:
      break;
  case VT_BSTR:
      hres = UnmarshalBSTR(pStream, V_BSTR(&Var),dwStreamSize);
      break;
  case VT_EMBEDDED_OBJECT:
      hres = CoUnmarshalInterface(pStream, 
      	                          IID_IWbemClassObject, 
			                      (void**)&V_EMBEDDED_OBJECT(&Var));
      if (SUCCEEDED(hres))
      {
          STATSTG StatStg;
          _com_util::CheckError(pStream->Stat(&StatStg,STATFLAG_DEFAULT));
      
          LARGE_INTEGER li; li.QuadPart = 0;
          ULARGE_INTEGER Position;
          hres = pStream->Seek(li,STREAM_SEEK_CUR,&Position);
          
          dwStreamSize = StatStg.cbSize.LowPart - Position.LowPart; 
      }
      break;
  default:
	  if ( ( V_VT(&Var) & ~VT_ARRAY ) == VT_DISPATCH )
	  {
		  V_VT(&Var) = VT_EMPTY;
		  throw CX_ContextMarshalException();
	  }
      else if(V_VT(&Var) & VT_ARRAY)
      {
	  hres = UnmarshalSafeArray(pStream, 
	  	                        V_VT(&Var) & ~VT_ARRAY,
			                    V_ARRAY(&Var),
			                    dwStreamSize);
      }
      else
      {
    	  hres = pStream->Read(&V_UI1(&Var), MAX_VARIANT_SIZE, NULL);
	      dwStreamSize -= MAX_VARIANT_SIZE;
      }
      break;
  }
  _com_util::CheckError (hres);

  m_vValue.Attach(Var);
}


CWbemContext::CContextObj::~CContextObj()
{
}
    
int CWbemContext::CContextObj::legalTypes[]={ VT_NULL, VT_I2, VT_I4, VT_R4, VT_R8,
					      VT_BSTR, VT_BOOL, VT_UNKNOWN, VT_I1, 
					      VT_UI1, VT_UI2, VT_UI4 };

bool 
CWbemContext::CContextObj::supportedType(const VARIANT& var)
{
  const size_t size = sizeof(legalTypes)/sizeof(legalTypes[0]);
  return (std::find(legalTypes, legalTypes+size, V_VT(&var) & ~VT_ARRAY) != (legalTypes+size));
}


HRESULT CWbemContext::CContextObj::GetMarshalSizeMax( DWORD* pdwSize )
{
    // First, the name
    // ===============

    DWORD dwLength = GetBSTRMarshalSize(m_strName.get ());

    // Then the flags
    // ==============

    dwLength += sizeof(m_lFlags);

    // Then the VARTYPE
    // ================

    dwLength += sizeof(VARTYPE);

    // Then the actual data
    // ====================

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        dwLength += GetBSTRMarshalSize(V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        {
            DWORD dwThis = 0;
            CoGetMarshalSizeMax(&dwThis, IID_IWbemClassObject, 
                                V_EMBEDDED_OBJECT(&m_vValue), 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            dwLength += dwThis;
        }
        break;
    default:

		// We will not allow VT_DISPATCH to marshal as it can cause
		// a crash
		if ( ( V_VT( &m_vValue ) & ~VT_ARRAY ) == VT_DISPATCH )
		{
			return E_FAIL;
		}
        else if(V_VT(&m_vValue) & VT_ARRAY)
        {
            dwLength += GetSafeArrayMarshalSize(V_VT(&m_vValue) & ~VT_ARRAY,
                                                V_ARRAY(&m_vValue));
        }
        else
        {
            dwLength += MAX_VARIANT_SIZE;
        }
    }

	*pdwSize = dwLength;

    return WBEM_S_NO_ERROR;
}
            
HRESULT CWbemContext::CContextObj::Marshal(IStream* pStream)
{
    HRESULT hres;  

    // Write the name
    // ==============
    hres = MarshalBSTR(pStream, m_strName.get());
    if (FAILED (hres)) return hres;
    // Write the flags
    // ===============

    hres = pStream->Write((void*)&m_lFlags, sizeof(m_lFlags), NULL);
    if (FAILED (hres)) return hres;
    // Write the VARTYPE
    // =================

    hres = pStream->Write((void*)&V_VT(&m_vValue), sizeof(VARTYPE), NULL);
    if (FAILED (hres)) return hres;

    // Write the data
    // ==============

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        hres = MarshalBSTR(pStream, V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        hres = CoMarshalInterface(pStream, IID_IWbemClassObject, 
                           V_EMBEDDED_OBJECT(&m_vValue), 
                           MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
        break;
    default:
		// We will not allow VT_DISPATCH to marshal as it can cause
		// a crash
		if ( ( V_VT( &m_vValue ) & ~VT_ARRAY ) == VT_DISPATCH )
		{
			return E_FAIL;
		}
        else if(V_VT(&m_vValue) & VT_ARRAY)
        {
            hres = MarshalSafeArray(pStream, V_VT(&m_vValue) & ~VT_ARRAY,
                                V_ARRAY(&m_vValue));
        }
        else
        {
            hres = pStream->Write(&V_UI1(&m_vValue), MAX_VARIANT_SIZE, NULL);
        }
        break;
    }

    return hres;
}

CWbemContext::CWbemContext(CLifeControl* pControl) 
    : m_lRef(0), m_dwCurrentIndex(0xFFFFFFFF), m_lNumChildren(0),
        m_lNumParents(0), m_lNumSiblings(0), m_pControl( pControl )
{
    m_dwNumRequests = 1;
    m_aRequests = new GUID;

	if ( NULL == m_aRequests )
	{
		throw CX_MemoryException();
	}

    AssignId();

    m_pControl->ObjectCreated((IWbemContext*)this);
}

CWbemContext::CWbemContext(const CWbemContext& Other, DWORD dwExtraSpace) 
    : m_lRef(0), m_dwCurrentIndex(0xFFFFFFFF), m_lNumChildren(0),
        m_lNumParents(0), m_lNumSiblings(0), m_pControl(Other.m_pControl)
{
    // Copy data
    // =========

    for(int i = 0; i < Other.m_aObjects.GetSize(); i++)
    {
      CContextObj* pObj = new CContextObj(*Other.m_aObjects[i]);
      
      if (NULL == pObj || m_aObjects.Add( pObj ) == -1)
        {
        delete pObj;
        throw CX_MemoryException();
	    }
    }

    // Allocate causality string
    // =========================

    m_dwNumRequests = Other.m_dwNumRequests + dwExtraSpace;
    m_aRequests = new GUID[m_dwNumRequests];

    if ( NULL == m_aRequests )
      {
      throw CX_MemoryException();
      }

    // Copy the current string, leaving space
    // ======================================

    if(Other.m_dwNumRequests > 0)
    {
        memcpy(m_aRequests + dwExtraSpace, Other.m_aRequests, // OK CR DPRAVAT
            Other.m_dwNumRequests * sizeof(GUID));  
    }

    m_pControl->ObjectCreated((IWbemContext*)this);
}

CWbemContext::~CWbemContext()
{
    delete [] m_aRequests;
    m_pControl->ObjectDestroyed((IWbemContext*)this);
}

#if defined(_M_IA64)
#pragma optimize("", off)
#endif
STDMETHODIMP CWbemContext::CreateChild(IWbemCausalityAccess** ppChild)
{
    CInCritSec ics(&m_cs);

	try
	{
		CWbemContext* pNewCtx = new CWbemContext(*this, 1);

		if ( NULL == pNewCtx )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		pNewCtx->AssignId();
		pNewCtx->m_lNumSiblings = m_lNumSiblings + m_lNumChildren;
		pNewCtx->m_lNumParents = m_lNumParents + 1;

		m_lNumChildren++;
		return pNewCtx->QueryInterface(IID_IWbemCausalityAccess, (void**)ppChild);
	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
#if defined(_M_IA64)
#pragma optimize("", on)
#endif

STDMETHODIMP CWbemContext::GetRequestId(GUID* pId)
{
    CInCritSec ics(&m_cs);

    if(m_dwNumRequests == 0)
    {
        *pId = GUID_NULL;
        return S_FALSE;
    }
    else
    {
        *pId = m_aRequests[0];
        return S_OK;
    }
}

STDMETHODIMP CWbemContext::GetParentId(GUID* pId)
{
    CInCritSec ics(&m_cs);

    if(m_dwNumRequests < 2)
    {
        *pId = GUID_NULL;
        return S_FALSE;
    }
    else
    {
        *pId = m_aRequests[1];
        return S_OK;
    }
}

STDMETHODIMP CWbemContext::IsChildOf(GUID Id)
{
    CInCritSec ics(&m_cs);

    for(DWORD dw = 0; dw < m_dwNumRequests; dw++)
    {
        if(m_aRequests[dw] == Id)
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CWbemContext::GetHistoryInfo(long* plNumParents, 
                                            long* plNumSiblings)
{
    CInCritSec ics(&m_cs);

    *plNumParents = m_lNumParents;
    *plNumSiblings = m_lNumSiblings;
    return S_OK;
}

void CWbemContext::AssignId()
{
    CInCritSec ics(&m_cs);

    CoCreateGuid(m_aRequests);
}

DWORD CWbemContext::FindValue(LPCWSTR wszIndex)
{
  for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        if(!wbem_wcsicmp(wszIndex, m_aObjects[i]->m_strName.get()))
        {
            return i;
        }
    }
    return 0xFFFFFFFF;
}

STDMETHODIMP CWbemContext::QueryInterface(REFIID riid, void** ppv)
{
  if (ppv == 0)
    return E_POINTER;

  if (riid == IID_IUnknown || riid == IID_IWbemContext)
    {
        *ppv = static_cast<IWbemContext*>(this);
    }
  else if (riid == IID_IMarshal)
    {
        *ppv = static_cast<IMarshal*>(this);
    }
  else if (riid == IID_IWbemCausalityAccess)
    {
        *ppv = static_cast<IWbemCausalityAccess*>(this);
    }
  else
    {
      *ppv = NULL;
      return E_NOINTERFACE;
    };
  reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  return S_OK;
}
    


STDMETHODIMP CWbemContext::Clone(IWbemContext** ppCopy)
{
    if ( NULL == ppCopy )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CInCritSec ics(&m_cs);

	try
	{
		*ppCopy = new CWbemContext(*this);

		if ( NULL == *ppCopy )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		(*ppCopy)->AddRef();
		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

STDMETHODIMP CWbemContext::GetNames(long lFlags, SAFEARRAY** pNames)
{
  HRESULT hres = WBEM_S_NO_ERROR;  
  CInCritSec ics(&m_cs);

    SAFEARRAYBOUND sab;
    if(lFlags != 0 || !pNames)
        return WBEM_E_INVALID_PARAMETER;
    sab.cElements = m_aObjects.GetSize();
    sab.lLbound = 0;
    
    SAFEARRAY* names = SafeArrayCreate(VT_BSTR, 1, &sab);
    
    if (names == 0) return WBEM_E_OUT_OF_MEMORY ;
    
    for(long i = 0; i < m_aObjects.GetSize(); i++)
    {
        if (FAILED (hres = SafeArrayPutElement(names, &i, m_aObjects[i]->m_strName.get())))
	    break;
    }

    if ( SUCCEEDED (hres))
      *pNames = names;
    else
      {
      SafeArrayDestroy(names);
      return WBEM_E_OUT_OF_MEMORY;
      }
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::BeginEnumeration(long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;
    if(m_dwCurrentIndex != 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;
    m_dwCurrentIndex = 0;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::Next(long lFlags, BSTR* pName, VARIANT* pVal)
{
  HRESULT hres = S_OK;  
  CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;
    if (pName == NULL)
    	return WBEM_E_INVALID_PARAMETER;
    if(m_dwCurrentIndex == 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;

    if(m_dwCurrentIndex >= m_aObjects.GetSize())
        return WBEM_S_NO_MORE_DATA;
    
    
    if(pName)
    {
        *pName = SysAllocString(m_aObjects[m_dwCurrentIndex]->m_strName.get());
	if (*pName == 0 && m_aObjects[m_dwCurrentIndex]->m_strName.get() != 0)
	  {
	  return WBEM_E_OUT_OF_MEMORY;
	  }
    }

    if (0 == pVal)
        return WBEM_E_INVALID_PARAMETER;    

    VARIANT local;
    
    VariantInit (&local);
    hres = VariantCopy (&local, &m_aObjects[m_dwCurrentIndex]->m_vValue);
    
    if (SUCCEEDED (hres))
      {
      memcpy(pVal, &local, sizeof(local));  // OK CR DPRAVAT
      V_VT(&local) = VT_EMPTY;
      m_dwCurrentIndex++;
      }
    else
      return WBEM_E_OUT_OF_MEMORY;

    return hres;
}

STDMETHODIMP CWbemContext::EndEnumeration()
{
    CInCritSec ics(&m_cs);

    if(m_dwCurrentIndex == 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;
    m_dwCurrentIndex = 0xFFFFFFFF;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::SetValue(LPCWSTR NameIndex, long lFlags, 
                                    VARIANT* pValue)
{
    CInCritSec ics(&m_cs);

    // These are all invalid parameters
    if( lFlags != 0 || NULL == NameIndex || NULL == pValue)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	// Removed VT validation as it is causing too many problems for scripting.
    DWORD dwIndex = FindValue(NameIndex);
    
    try{
      if(dwIndex == 0xFFFFFFFF)
      {
	CContextObj * newEntry = new CContextObj(NameIndex, lFlags, pValue);
	if (newEntry == 0 || m_aObjects.Add (newEntry) == -1)
	  {
	  delete newEntry;
	  return WBEM_E_OUT_OF_MEMORY;
	  }
      }
      else
      {
	  CContextObj* pObj = m_aObjects[dwIndex];
	  pObj->m_vValue = *pValue;
	  pObj->m_lFlags = lFlags;
      }
    }
    catch(...)
    {
      return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}
        
STDMETHODIMP CWbemContext::GetValue(LPCWSTR NameIndex, long lFlags, 
                                    VARIANT* pValue)
{
  HRESULT hres = WBEM_S_NO_ERROR;
  
  CInCritSec ics(&m_cs);

    if(lFlags != 0 || NameIndex == NULL || pValue == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwIndex = FindValue(NameIndex);
    if(dwIndex == 0xFFFFFFFF)
        return WBEM_E_NOT_FOUND;

    VARIANT local;
    
    VariantInit (&local);
    hres = VariantCopy (&local, &m_aObjects[dwIndex]->m_vValue);
    
    if (SUCCEEDED (hres))
      {
      memcpy(pValue, &local, sizeof(local));
      V_VT(&local) = VT_EMPTY;
      return S_OK;
      }
    return hres;
}
    
STDMETHODIMP CWbemContext::DeleteValue(LPCWSTR NameIndex, long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0 || NameIndex == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwIndex = FindValue(NameIndex);
    if(dwIndex == 0xFFFFFFFF)
    {
        return WBEM_S_FALSE;
    }

    m_aObjects.RemoveAt(dwIndex);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::DeleteAll()
{
    CInCritSec ics(&m_cs);

    m_aObjects.RemoveAll();
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::MakeSpecial()
{
    CInCritSec ics(&m_cs);

    // Make the ID of this context NULL
    // ================================

    m_aRequests[0] = CLSID_NULL;
    return S_OK;
}

STDMETHODIMP CWbemContext::IsSpecial()
{
    CInCritSec ics(&m_cs);

    // Check if the first GUID is NULL
    // ===============================

    if(m_aRequests[m_dwNumRequests-1] == CLSID_NULL)
        return S_OK;
    else
        return S_FALSE;
}

// IMarshal methods

STDMETHODIMP CWbemContext::GetUnmarshalClass(REFIID riid, void* pv, 
                             DWORD dwDestContext, void* pvReserved, 
                             DWORD mshlFlags, CLSID* pClsid)
{
    *pClsid = CLSID_WbemContext;
    return S_OK;
}
                                             
STDMETHODIMP CWbemContext::GetMarshalSizeMax(REFIID riid, void* pv, 
                             DWORD dwDestContext, void* pvReserved, 
                             DWORD mshlFlags, ULONG* plSize)
{
    CInCritSec ics(&m_cs);

    DWORD dwLength = sizeof(DWORD); // length of causality string
    dwLength += m_dwNumRequests * sizeof(GUID); // causality string

    dwLength += sizeof(DWORD); // number of objects
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
		DWORD	dwSize = 0;
		HRESULT	hr = m_aObjects[i]->GetMarshalSizeMax( &dwSize );
		if ( FAILED( hr ) )
		{
			return hr;
		}

        dwLength += dwSize;
    }

    *plSize = dwLength;
    return S_OK;
}

STDMETHODIMP CWbemContext::MarshalInterface(IStream* pStream, REFIID riid, 
                            void* pv, DWORD dwDestContext, void* pvReserved, 
                            DWORD mshlFlags)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;
    hres = pStream->Write((void*)&m_dwNumRequests, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;
    hres = pStream->Write((void*)m_aRequests, sizeof(GUID) * m_dwNumRequests, 
                            NULL);
    if(FAILED(hres)) return hres;
    
    DWORD dwNum = m_aObjects.GetSize();
    hres = pStream->Write((void*)&dwNum, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        hres = m_aObjects[i]->Marshal(pStream);
        if(FAILED(hres)) return hres;
    }
    return S_OK;
}
    
STDMETHODIMP CWbemContext::UnmarshalInterface(IStream* pStream, REFIID riid, 
                            void** ppv)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;
    DWORD i;
    STATSTG StatStg;

    if (FAILED(hres = pStream->Stat(&StatStg,STATFLAG_DEFAULT))) return hres;

	LARGE_INTEGER li; li.QuadPart = 0;
	ULARGE_INTEGER Position;
	if (FAILED(hres = pStream->Seek(li,STREAM_SEEK_CUR,&Position))) return hres;

	// simply TotalBytesInStream - CurrentPosition
	// the stram will contain the MEOW header, ecc, ecc
	DWORD dwTotSizeStream = StatStg.cbSize.LowPart - Position.LowPart;
    
    if (dwTotSizeStream > g_ContextLimit) return E_FAIL;
    
    if (FAILED(hres = pStream->Read((void*)&m_dwNumRequests, sizeof(DWORD), NULL))) return hres;
    dwTotSizeStream -= sizeof(DWORD);
    if(m_dwNumRequests > 0)
    {
        DWORD dwSizeToAlloc = sizeof(GUID) * m_dwNumRequests;
        if (dwSizeToAlloc > dwTotSizeStream) return E_FAIL;
        delete [] m_aRequests;
        if (NULL == (m_aRequests = new GUID[m_dwNumRequests])) return WBEM_E_OUT_OF_MEMORY;
      
		if(FAILED(hres = pStream->Read((void*)m_aRequests, 
				                 dwSizeToAlloc ,
				                 NULL))) return hres;
			
		dwTotSizeStream -= dwSizeToAlloc;
    }

    DWORD dwNum;
    if(FAILED(hres = pStream->Read((void*)&dwNum, sizeof(DWORD), NULL))) return hres;
    dwTotSizeStream -= sizeof(DWORD);

    try
    {
        for(i = 0; i < dwNum; i++)
        {
	        CContextObj * newEntry = new CContextObj(pStream,dwTotSizeStream);
		    if (newEntry == 0 || m_aObjects.Add (newEntry)==-1)
		    {
		        delete newEntry;
		        return E_FAIL;
		    }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }
    return QueryInterface(riid, ppv);
}
    
STDMETHODIMP CWbemContext::ReleaseMarshalData(IStream* pStream)
{
    return S_OK;
}

STDMETHODIMP CWbemContext::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\enummrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    ENUMMRSH.CPP

Abstract:

    Object Enumerator Marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "enummrsh.h"
#include <fastall.h>
#include <cominit.h>
#include <lockst.h>

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CEnumFactoryBuffer::XEnumFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CEnumFactoryBuffer::XEnumFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IEnumWbemClassObject)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    SCODE sc = E_OUTOFMEMORY;

    try // CWbemClassCache throws
    {
	    CEnumProxyBuffer* pProxy = new CEnumProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);
	    
	    if ( NULL != pProxy )
	    {
	        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
	        sc = pProxy->QueryInterface(riid, (void**)ppv);
	    }
    }
    catch (CX_Exception &)
    {
    }

    return sc;
}

//***************************************************************************
//
//  CEnumFactoryBuffer::XEnumFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IEnumWbemClassObject 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CEnumFactoryBuffer::XEnumFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IEnumWbemClassObject)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CEnumStubBuffer* pStub = new CEnumStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {

        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CEnumFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CEnumFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CEnumFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XEnumFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CEnumProxyBuffer::CEnumProxyBuffer
//  ~CEnumProxyBuffer::CEnumProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CEnumProxyBuffer::CEnumProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IEnumWbemClassObject ),
        m_XEnumFacelet(this), m_pOldProxyEnum( NULL ), m_fTriedSmartEnum( FALSE ),
        m_fUseSmartEnum( FALSE ), m_SinkSecurity( pUnkOuter ),
        m_pSmartEnum( NULL ), m_cs(THROW_LOCK)
{

}

CEnumProxyBuffer::~CEnumProxyBuffer()
{
    if ( NULL != m_pSmartEnum )
    {
        m_pSmartEnum->Release();
    }

    // This MUST be released before releasing
    // the Proxy pointer
    if ( NULL != m_pOldProxyEnum )
    {
        m_pOldProxyEnum->Release();
    }
}

void* CEnumProxyBuffer::GetInterface( REFIID riid )
{
    if(riid == IID_IEnumWbemClassObject)
        return &m_XEnumFacelet;
    else return NULL;
}

void** CEnumProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxyEnum;
}

void CEnumProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxyEnum )
    {
        m_pOldProxyEnum->Release();
        m_pOldProxyEnum = NULL;
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return our security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

        // Make sure we have a smart enumerator and that we are going to
        // be using it.  If so, make sure the values applied to us are also
        // applied to it's proxy

        if ( SUCCEEDED( m_pObject->InitSmartEnum( TRUE, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities ) ) && m_pObject->m_fUseSmartEnum )
        {
            // Now repeat the above operation for the smart enumerator
            // Set the proxy blanket, ignore IUnknown if we are not going remote
            hr = WbemSetProxyBlanket( m_pObject->m_pSmartEnum, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_pObject->m_fRemote );

        }   // If initialized smart enumerator

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

//  IEnumWbemClassObject Methods -- Pass Thrus for now

//////////////////////////////////////////////
//////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Reset()
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Reset();

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Next(long lTimeout, ULONG uCount, IWbemClassObject** apObj, ULONG FAR* puReturned)
{

    // At this point we will Query for the new, improved IEnumWCOSmartNext interface.
    // If we get it, we will maintain a pointer to that interface and
    // pass through to that interface.  We will also call CoCreateGuid() so
    // we get a unique identifier on the other end for sending wbem objects
    // back and forth cleanly.

    // The interface will have a single method IEnumWCOSmartNext::Next
    // This will take a GUID identifying this proxy, lTimeout, uCount,
    // puReturned, then dwBuffSize and BYTE**.

    // The other end will allocate memory via CoTaskMemAlloc and this side will
    // Free it via CoTaskMemFree.

    // The other side will Marshal returned objects into the memory block.
    // This side will Unmarshal it (and then free the block).

    //
    //  SAMPLE IDL:
    //  IEnumWCOSmartNext::Next(    [in] GUID proxyGUID,
    //                              [in] LONG lTimeout,
    //                              [in] unsigned long uCount,
    //                              [in, out] DWORD* puReturned,
    //                              [in, out] DWORD* pdwBuffSize,
    //                              [in, out, size_is[,*pdwBuffSize] BYTE** pBuffer
    //

    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure the timeout value makes sense and that puReturned and apObj are non-NULL
    if ( ( lTimeout < 0 && lTimeout != WBEM_INFINITE )  ||
        ( NULL == puReturned ) ||
        ( NULL == apObj ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartEnum();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartEnum && NULL != m_pObject->m_pSmartEnum )
    {

        BYTE*   pBuffer = NULL;
        ULONG   uSizeOfBuffer = 0;

        // Ask the server for objects
        hr = m_pObject->m_pSmartEnum->Next( m_pObject->m_guidSmartEnum, lTimeout, uCount, puReturned, &uSizeOfBuffer, &pBuffer );

        // Only need to unmarshal if objects are in the buffer
        if ( SUCCEEDED( hr ) && *puReturned > 0 )
        {

            CWbemSmartEnumNextPacket packet( (LPBYTE) pBuffer, uSizeOfBuffer );
            long lObjectCount = 0L; 
            IWbemClassObject ** pObjArray = NULL;

            // hr will contain the call's proper return code.  Make sure we don't override it unless
            // the unmarshaling fails.
            HRESULT hrUnmarshal = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

            if ( SUCCEEDED( hrUnmarshal ) && lObjectCount > 0 && NULL != pObjArray )
            {
                // Copy *puReturned pointers from the allocated pObjArray into apObj.
                CopyMemory( apObj, pObjArray, ( *puReturned * sizeof(IWbemClassObject*) ) );

                // Clean up pObjArray  It is the caller's responsibility to free
                // the IWbemClassObject* pointers.
                delete [] pObjArray;

            }   // IF UnmarshalPacket
			else if ( SUCCEEDED( hr ) )
			{
				// If the unmarshal succeeded but we got no objects or no array,
				// something is badly wrong
				hr = WBEM_E_UNEXPECTED;
			}
            else
            {
                hr = hrUnmarshal;
            }

            // Free the memory buffer (allocated by WinMgmt via CoTaskMemAlloc)
            CoTaskMemFree( pBuffer );
        }
    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyEnum->Next( lTimeout, uCount, apObj, puReturned );
    }

    return hr;

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      NextAsync(ULONG uCount, IWbemObjectSink* pSink)
{
    HRESULT hr = m_pObject->EnsureSinkSecurity( pSink );

    if ( FAILED(hr) )
        return hr;

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->NextAsync( uCount, pSink );
}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Clone(IEnumWbemClassObject** pEnum)
{

	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == pEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Clone( pEnum );

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Skip(long lTimeout, ULONG nNum)
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Skip( lTimeout, nNum );

}

//***************************************************************************
//
//  HRESULT CEnumProxyBuffer::InitSmartEnum(void)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  This function sets up
//  the smart enumerator pointer so we can perform intelligent marshaling.
//  This cannot be called during a Connect operation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CEnumProxyBuffer::InitSmartEnum( BOOL fSetBlanket, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If we haven't tried to estalish smart enumeration, do so now

    // If we haven't tried to get a smart enumerator, try to get one.  If
    // we are able to get one, initialize member data we will use in all
    // operations from this proxy.

    if ( NULL == m_pSmartEnum )
    {

        // We'll only get this interface pointer if the server is a new
        // version that understands this interface.  If it does, the pointer
        // will be marshaled through for us.  To get to this pointer,
        // we go directly through our punkOuter.  From the "fetcher" interface
        // we will then get the actual smart enumerator.  We can then free up
        // the fetcher and release it's lock on the proxy manager.  The
        // smart enumerator will be handled on its own.

        IWbemFetchSmartEnum*    pFetchSmartEnum;

        hr = m_pUnkOuter->QueryInterface( IID_IWbemFetchSmartEnum, (void**) &pFetchSmartEnum );

        // Generate a GUID to identify us when we call the smart enumerator
        if ( SUCCEEDED( hr ) )
        {

            // If we need to, set the blanket on the proxy, otherwise, the call to GetSmartEnum
            // may fail.
            if ( fSetBlanket )
            {
                // Ignore the IUnknown if we are not remoting
                hr = WbemSetProxyBlanket( pFetchSmartEnum, AuthnSvc, AuthzSvc, pServerPrincName,
                            AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_fRemote );
            }

            if ( SUCCEEDED( hr ) )
            {

                IWbemWCOSmartEnum * pSmartEnum = 0;
                GUID guidSmartEnum;
                hr = pFetchSmartEnum->GetSmartEnum( &pSmartEnum );

                if ( SUCCEEDED( hr ) )
                {
                    // We need a GUID
                    hr = CoCreateGuid( &guidSmartEnum );
                    
                    if ( SUCCEEDED( hr ) )
                    {
                        CS_GUARD(ics,m_cs);

                        if (NULL == m_pSmartEnum)
                        {
                            // Function MUST be thread safe
                            m_pSmartEnum = pSmartEnum;
                            m_guidSmartEnum = guidSmartEnum;
                            m_fUseSmartEnum = TRUE;
                        }
                        else
                        {
                            pSmartEnum->Release();    
                        }
                    }
                    else
                    {
                        pSmartEnum->Release();
                    };
                }   // IF got Smart Enumerator

            }   // IF security OK
            
            // Done with the fetcher interface
            pFetchSmartEnum->Release();

        }   // IF QueryInterface
        else
        {
            hr = WBEM_S_NO_ERROR;
        }

    }   // IF NULL == m_pSmartEnum

    return hr;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CEnumFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CEnumFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CEnumStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XEnumStublet;
    else
        return NULL;
}

CEnumStubBuffer::XEnumStublet::XEnumStublet(CEnumStubBuffer* pObj) 
    : CBaseStublet( pObj, IID_IEnumWbemClassObject ), m_pServer(NULL)
{
}

CEnumStubBuffer::XEnumStublet::~XEnumStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CEnumStubBuffer::XEnumStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CEnumStubBuffer::XEnumStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CEnumStubBuffer::XEnumStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\context.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CONTEXT.H

Abstract:

    CWbemContext Implementation

History:

--*/

#ifndef __WBEM_CONTEXT__H_
#define __WBEM_CONTEXT__H_

#include <arrtempl.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <unk.h>
#include <sync.h>
#include <comdef.h>
#include <corex.h>


class CWbemContext : public IWbemContext, public IMarshal, 
                    public IWbemCausalityAccess
{
protected:
    long m_lRef;
    DWORD m_dwCurrentIndex;
	CLifeControl*	m_pControl;

    struct CContextObj
    {
        auto_bstr m_strName;
        long m_lFlags;
        _variant_t m_vValue;
	    static int legalTypes[];
        static bool supportedType(const VARIANT&);
    public:
        CContextObj();
        CContextObj(LPCWSTR wszName, long lFlags, VARIANT* pvValue);
        CContextObj(const CContextObj& Obj);
        CContextObj(IStream* pStream,DWORD & dwStreamSize);
        ~CContextObj();

        HRESULT GetMarshalSizeMax ( DWORD* pdwSize );
        HRESULT Marshal(IStream* pStream);
    };

    CUniquePointerArray<CContextObj> m_aObjects;
    DWORD m_dwNumRequests;
    GUID *m_aRequests;

    long m_lNumParents;
    long m_lNumSiblings;
    long m_lNumChildren;
    CCritSec m_cs;

private:
    DWORD FindValue(LPCWSTR wszIndex);
    void AssignId();

public:
    CWbemContext(CLifeControl* pControl = NULL);
    CWbemContext(const CWbemContext& Other, DWORD dwExtraSpace = 0);
    ~CWbemContext();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)() 
    {
        return InterlockedIncrement(&m_lRef);
    }
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0) delete this;
        return lRef;
    }

    // IWbemContext methods

    STDMETHOD(Clone)(IWbemContext** ppCopy);
    STDMETHOD(GetNames)(long lFlags, SAFEARRAY** pNames);
    STDMETHOD(BeginEnumeration)(long lFlags);
    STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal);
    STDMETHOD(EndEnumeration)();
    STDMETHOD(SetValue)(LPCWSTR NameIndex, long lFlags, VARIANT* pValue);
    STDMETHOD(GetValue)(LPCWSTR NameIndex, long lFlags, VARIANT* pValue);
    STDMETHOD(DeleteValue)(LPCWSTR NameIndex, long lFlags);
    STDMETHOD(DeleteAll)();

    // IWbemCausalityAccess methods

    STDMETHOD(GetRequestId)(GUID* pId);
    STDMETHOD(IsChildOf)(GUID Id);
    STDMETHOD(CreateChild)(IWbemCausalityAccess** ppChild);
    STDMETHOD(GetParentId)(GUID* pId);
    STDMETHOD(GetHistoryInfo)(long* plNumParents, long* plNumSiblings);
    STDMETHOD(MakeSpecial)();
    STDMETHOD(IsSpecial)();

    // IMarshal methods

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\enummrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    ENUMMRSH.H

Abstract:

    Object Enumerator Marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include "wbemclasscache.h"
#include "wbemclasstoidmap.h"
#include "smartnextpacket.h"
#include "mrshbase.h"
#include "locks.h"
//***************************************************************************
//
//  class CEnumFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CEnumFactoryBuffer : public CUnkInternal
{

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XEnumFactory : public CImpl<IPSFactoryBuffer, CEnumFactoryBuffer>
    {
    public:
        XEnumFactory(CEnumFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CEnumFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XEnumFactory;
public:
    CEnumFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_XEnumFactory(this), m_pLifeControl( pControl )
    {
    }
    ~CEnumFactoryBuffer()
    {
    }

    void* GetInterface(REFIID riid);

	friend XEnumFactory;

};


//***************************************************************************
//
//  class CEnumProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CEnumProxyBuffer : public CBaseProxyBuffer
{
private:
    IEnumWbemClassObject*	m_pOldProxyEnum;
    BOOL			m_fTriedSmartEnum;
    BOOL			m_fUseSmartEnum;
    GUID			m_guidSmartEnum;
    IWbemWCOSmartEnum*		m_pSmartEnum;
    CriticalSection		m_cs;
    CProxySinkSecurity          m_SinkSecurity;
    
    
    HRESULT EnsureSinkSecurity( IWbemObjectSink* pSink )
        { return m_SinkSecurity.EnsureSinkSecurity(pSink); }

protected:
    class XEnumFacelet : public IEnumWbemClassObject, IClientSecurity
    {
    protected:
        CEnumProxyBuffer*	m_pObject;
        CWbemClassCache		m_ClassCache;

    public:
        XEnumFacelet(CEnumProxyBuffer* pObject) : m_pObject(pObject){};
        ~XEnumFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

		// IEnumWbemClassObject Methods

		STDMETHOD(Reset)();
		STDMETHOD(Next)(long lTimeout, ULONG uCount,  
			IWbemClassObject** apObj, ULONG FAR* puReturned);
		STDMETHOD(NextAsync)(ULONG uCount, IWbemObjectSink* pSink);
		STDMETHOD(Clone)(IEnumWbemClassObject** pEnum);
		STDMETHOD(Skip)(long lTimeout, ULONG nNum);

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XEnumFacelet;
    friend XEnumFacelet;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

	// Initialize the smart enumerator
	HRESULT InitSmartEnum( BOOL fSetBlanket = FALSE, DWORD AuthnSvc = RPC_C_AUTHN_WINNT,
			DWORD AuthzSvc = RPC_C_AUTHZ_NONE, OLECHAR* pServerPrincName = NULL,
			DWORD AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT, DWORD ImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE,
			void* pAuthInfo = NULL, DWORD Capabilities = EOAC_NONE );

public:
    CEnumProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CEnumProxyBuffer();
};

//***************************************************************************
//
//  class CEnumStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CEnumStubBuffer : public CBaseStubBuffer
{
protected:
    class XEnumStublet : public CBaseStublet
    {
        IWbemObjectSink* m_pServer;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XEnumStublet(CEnumStubBuffer* pObj);
        ~XEnumStublet();

        friend CEnumStubBuffer;
    } m_XEnumStublet;
    friend XEnumStublet;

public:
    CEnumStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer(pControl, pUnkOuter), m_XEnumStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastall.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTALL.H

Abstract:

    This is the include file for all clients of fastobj functionality.
    See member header files for documentation.

History:

    3/10/97     a-levn  Fully documented

--*/

#ifndef _FASTALL_H_
#define _FASTALL_H_

#include <corex.h>

// Parameter flow indicators.
// ==========================

#define READONLY
    // The value should be treated as read-only

#define ACQUIRED
    // Ownership of the object/pointer is acquired.

#define COPIED
    // The function makes a copy of the object/pointer.

#define PREALLOCATED
    // The out-param uses caller's memory.

#define NEWOBJECT
    // The return value or out parameter is a new
    // allocation which must be deallocated by
    // the caller if the call succeeds.

#define READWRITE
    // The in-param is will be treated as read-write,
    // but will not be deallocated.

#define INTERNAL
    // Returns a pointer to internal memory object
    // which should not be deleted.

#define ADDREF
    // On a parameter, indicates that the called
    // function will do an AddRef() on the interface
    // and retain it after the call completes.

#define TYPEQUAL L"CIMTYPE"

#include "fastcls.h"
#include "fastinst.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastcls.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTCLS.CPP

Abstract:

  This file implements out-of-line functions for the classes related to
  class representation in WbemObjects. 

    For complete documentation of all classes and methods, see fastcls.h

  Classes implemented:
      CClassPart              Derived class definition
      CWbemClass               Complete class definition.

History:

    3/10/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
#include "wbemutil.h"
#include "fastall.h"
#include <wbemint.h>
#include "olewrap.h"
#include <arrtempl.h>

#define TYPEQUAL L"CIMTYPE"

LPMEMORY CDerivationList::CreateLimitedRepresentation(CLimitationMapping* pMap,
                                            LPMEMORY pWhere)
{
    if(pMap->ShouldIncludeDerivation())
    {
        memcpy(pWhere, GetStart(), GetLength());
        return pWhere + GetLength();
    }
    else
    {
        return CreateEmpty(pWhere);
    }
}


 LPMEMORY CClassPart::CClassPartHeader::CreateEmpty()
{
    nLength = CClassPart::GetMinLength();
    fFlags = 0;
    ptrClassName = INVALID_HEAP_ADDRESS;
    nDataLength = 0;
    return LPMEMORY(this) + sizeof CClassPartHeader;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 LPMEMORY CClassPart::CreateEmpty(LPMEMORY pStart)
{
    LPMEMORY pCurrent;
    pCurrent = ((CClassPartHeader*)pStart)->CreateEmpty();
    pCurrent = CDerivationList::CreateEmpty(pCurrent);
    pCurrent = CClassQualifierSet::CreateEmpty(pCurrent);
    pCurrent = CPropertyLookupTable::CreateEmpty(pCurrent);
    pCurrent = CDataTable::CreateEmpty(pCurrent);
    pCurrent = CFastHeap::CreateEmpty(pCurrent);

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF so cast is ok

    ((CClassPartHeader*)pStart)->nLength = (length_t) (pCurrent - pStart);

    return pCurrent;
}


//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

 void CClassPart::SetData(LPMEMORY pStart,
                          CClassPartContainer* pContainer,
                          CClassPart* pParent)
{
    m_pContainer = pContainer;
    m_pParent = pParent;

    m_pHeader = (CClassPartHeader*)pStart;

    m_Derivation.SetData(pStart + sizeof(CClassPartHeader));
    
    m_Qualifiers.SetData(EndOf(m_Derivation), this,
        (pParent) ? &pParent->m_Qualifiers : NULL);
    m_Properties.SetData( EndOf(m_Qualifiers), this);
    m_Defaults.SetData( EndOf(m_Properties),
        m_Properties.GetNumProperties(), m_pHeader->nDataLength, this);
    m_Heap.SetData( EndOf(m_Defaults), this);
}

size_t CClassPart::ValidateBuffer(LPMEMORY start, size_t cbMax)
 {
	int step = sizeof(CClassPartHeader);
	if (step > cbMax) throw CX_Exception();

	CClassPartHeader * header = (CClassPartHeader*)start;

	if (header->nLength > cbMax ) throw CX_Exception();
	
	step += CDerivationList::ValidateBuffer(start+sizeof(CClassPartHeader), cbMax-step);

	step += CClassQualifierSet::ValidateBuffer(start+step, cbMax-step);

	size_t propStep = CPropertyLookupTable::ValidateBuffer(start+step, cbMax-step);

	CPropertyLookupTable prop;
	prop.SetData(start+step, 0);
	int numProps = prop.GetNumProperties();

	step+=propStep;

	if (header->nDataLength > cbMax - step) throw CX_Exception();

	step += CDataTable::ValidateBuffer(start+step, header->nDataLength, numProps);	
	size_t heapStep = CFastHeap::ValidateBuffer(start+step, cbMax-step);	

	CFastHeap classHeap;
	classHeap.SetData(start+step,0);

	step += heapStep;

	if (step > header->nLength) throw CX_Exception();	

	return header->nLength;
 };
 //******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

 void CClassPart::SetDataWithNumProps(LPMEMORY pStart,
                                CClassPartContainer* pContainer,
                                DWORD dwNumProperties,
                                CClassPart* pParent )
{
    m_pContainer = pContainer;
    m_pParent = pParent;

    m_pHeader = (CClassPartHeader*)pStart;

    m_Derivation.SetData(pStart + sizeof(CClassPartHeader));
    m_Qualifiers.SetData(EndOf(m_Derivation), this,
        (pParent) ? &pParent->m_Qualifiers : NULL);
    m_Properties.SetData( EndOf(m_Qualifiers), this);

    // The datatable in this case is initialized with the
    // total number of properties, so we will be able to
    // access the default values.
    m_Defaults.SetData( EndOf(m_Properties),
        ( dwNumProperties == 0 ? m_Properties.GetNumProperties() : dwNumProperties ),
        m_pHeader->nDataLength, this);

    m_Heap.SetData( EndOf(m_Defaults), this);
}
//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CClassPart::Rebase(LPMEMORY pNewMemory)
{
    m_pHeader = (CClassPartHeader*)pNewMemory;

    m_Derivation.Rebase(pNewMemory + sizeof(CClassPartHeader));
    m_Qualifiers.Rebase( EndOf(m_Derivation));
    m_Properties.Rebase( EndOf(m_Qualifiers));
    m_Defaults.Rebase( EndOf(m_Properties));
    m_Heap.Rebase( EndOf(m_Defaults));
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::ReallocAndCompact(length_t nNewTotalLength)
{
    BOOL    fReturn = TRUE;

    Compact();

    // Reallocate if required (will call rebase)
    // =========================================

    if(nNewTotalLength > m_pHeader->nLength)
    {
        // Check the return in case of allocation failure.
        fReturn = m_pContainer->ExtendClassPartSpace(this, nNewTotalLength);

        if ( fReturn )
        {
            m_pHeader->nLength = nNewTotalLength;
        }
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CClassPart::Compact()
{
    // Compact
    // =======

    MoveBlock(m_Derivation, GetStart() + sizeof(CClassPartHeader));
    MoveBlock(m_Qualifiers, EndOf(m_Derivation));
    MoveBlock(m_Properties, EndOf(m_Qualifiers));
    MoveBlock(m_Defaults, EndOf(m_Properties));
    MoveBlock(m_Heap, EndOf(m_Defaults));
    m_Heap.Trim();
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 CPropertyInformation* CClassPart::FindPropertyInfo(LPCWSTR wszName)
{
    CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
    if(pLookup == NULL) return NULL;
    return (CPropertyInformation*)
        m_Heap.ResolveHeapPointer(pLookup->ptrInformation);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetDefaultValue(CPropertyInformation* pInfo,
                                        CVar* pVar)
{
    if(m_Defaults.IsNull(pInfo->nDataIndex))
    {
        pVar->SetAsNull();
        return WBEM_S_NO_ERROR;
    }
    CUntypedValue* pValue = m_Defaults.GetOffset(pInfo->nDataOffset);

    if ( !pValue->StoreToCVar(pInfo->GetType(), *pVar, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetDefaultValue(LPCWSTR wszName, CVar* pVar)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;
    return GetDefaultValue(pInfo, pVar);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetDefaultValue(CPropertyInformation* pInfo,
                                           CVar* pVar)
{
    // If new value is NULL, set the bit and return
    // ============================================

    m_Defaults.SetDefaultness(pInfo->nDataIndex, FALSE);
    m_Defaults.SetNullness(pInfo->nDataIndex, TRUE);

    if(pVar->IsNull() || pVar->IsDataNull())
    {
    }
    else
    {
        // Check the type
        // ==============

        if(!CType::DoesCIMTYPEMatchVARTYPE(pInfo->GetType(),
                                            (VARTYPE) pVar->GetOleType()))
        {
            // Attempt coercion
            // ================

            if(!pVar->ChangeTypeTo(CType::GetVARTYPE(pInfo->GetType())))
                return WBEM_E_TYPE_MISMATCH;
        }

        // Create a value pointing to the right offset in the data table
        // =============================================================

        int nDataIndex = pInfo->nDataIndex;
        CDataTablePtr ValuePtr(&m_Defaults, pInfo->nDataOffset);

        // Load it (types have already been checked)
        // =========================================

        // Check return values (this may fail in a memory allocation)
        Type_t  nReturnType;
        HRESULT hr = CUntypedValue::LoadFromCVar(&ValuePtr, *pVar,
                        CType::GetActualType(pInfo->GetType()), &m_Heap, nReturnType, FALSE); // reuse old
        if ( FAILED( hr ) )
        {
            // 
            // BUG: in the perfect world, we should remove the property if it
            // wasn't there before since the value supplied for it was invalid
            // But as it is, we'll simply leave the property there and the 
            // value default

            return hr;
        }

        // Check for invalid return types
        if ( CIM_ILLEGAL == nReturnType )
            return WBEM_E_TYPE_MISMATCH;

        pInfo = NULL; // invalidated

        // Reset special bits
        // ==================

        m_Defaults.SetNullness(nDataIndex, FALSE);
        m_Defaults.SetDefaultness(nDataIndex, FALSE);
    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::EnsureProperty(LPCWSTR wszName, VARTYPE vtValueType,
                                        CIMTYPE ctNativeType, BOOL fForce)
{
    if((CIMTYPE)CType::GetActualType(ctNativeType) != ctNativeType)
        return WBEM_E_INVALID_PROPERTY_TYPE;

    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo)
    {
        // Make sure it is of the right property type
        // ==========================================

        if(ctNativeType &&
            ctNativeType != (CIMTYPE)CType::GetActualType(pInfo->nType))
        {
            // Wrong type. Delete the property and start from scratch
            // ======================================================

            if(CType::IsParents(pInfo->nType))
                return WBEM_E_PROPAGATED_PROPERTY;

            CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
            m_Properties.DeleteProperty(pLookup,
                CPropertyLookupTable::e_UpdateDataTable);
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }

    // Make sure we will not exceed the maximum number of properties
    // Remember that we haven't added the new property yet, so we need
    // to check that we are not already at the property limit.
    if ( m_Properties.GetNumProperties() >= CSystemProperties::MaxNumProperties() )
    {
        return WBEM_E_TOO_MANY_PROPERTIES;
    }

    // =====================================
    // The property does not exist (anymore)

    if(ctNativeType == 0)
        ctNativeType = CType::VARTYPEToType(vtValueType);

    // Check the name for validity
    // ===========================

    // Each check below will be ignored if the fForce flag is TRUE

    // We allow underscores now
    if(!IsValidElementName2(wszName,g_IdentifierLimit, TRUE) && !fForce)
        return WBEM_E_INVALID_PARAMETER;

    // Check type for validity
    // =======================

    CType Type = ctNativeType;
    if(CType::GetLength(Type.GetBasic()) == 0 && !fForce)
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    // Insert it (automatically set to NULL)
    // =====================================

    int nLookupIndex = 0;

    // Check for failure (out of memory)
    HRESULT hr = m_Properties.InsertProperty(wszName, Type, nLookupIndex );
    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropertyLookup* pLookup = m_Properties.GetAt(nLookupIndex);
    pInfo = (CPropertyInformation*)
        GetHeap()->ResolveHeapPointer(pLookup->ptrInformation);

    // Add "cimtype" qualifier to it
    // ============================

    LPWSTR wszSyntax = CType::GetSyntax(pInfo->nType);
    if(wszSyntax == NULL) return WBEM_S_NO_ERROR;

    CVar vSyntax;
    vSyntax.SetBSTR(wszSyntax);
    return SetPropQualifier(wszName, TYPEQUAL,
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE, &vSyntax);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::DeleteProperty(LPCWSTR wszName)
{
    CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
    if(pLookup == NULL) return WBEM_E_NOT_FOUND;
    m_Properties.DeleteProperty(pLookup,
        CPropertyLookupTable::e_UpdateDataTable);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::CopyParentProperty(CClassPart& ParentPart,
                                              LPCWSTR wszName)
{
    // Find the property in the parent
    // ===============================

    CPropertyInformation* pParentInfo = ParentPart.FindPropertyInfo(wszName);
    if(pParentInfo == NULL) return WBEM_E_NOT_FOUND;

    propindex_t nDataIndex = pParentInfo->nDataIndex;
    offset_t nDataOffset = pParentInfo->nDataOffset;
    Type_t nParentType = pParentInfo->nType;

    // Create a property information sturcture on our heap, large enough to
    // accomodate the part of the parent's qualifier set that propagates to
    // us.
    // ====================================================================

    length_t nNewInfoLen = pParentInfo->ComputeNecessarySpaceForPropagation();

    // Check for allocation failure
    heapptr_t ptrNewInfo;
    if ( !m_Heap.Allocate(nNewInfoLen, ptrNewInfo) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // NOTE: invalidated pParentInfo
    pParentInfo = ParentPart.FindPropertyInfo(wszName);

    CPropertyInformation* pNewInfo =
        (CPropertyInformation*)m_Heap.ResolveHeapPointer(ptrNewInfo);

    // Create propagated property information structure
    // ================================================

    CClassPartPtr ParentInfoPtr(&ParentPart, (LPMEMORY)pParentInfo);
    CHeapPtr NewInfoPtr(&m_Heap, ptrNewInfo);

    // Check for allocation failure
    if ( !CPropertyInformation::WritePropagatedVersion(
            &ParentInfoPtr, &NewInfoPtr,
            &ParentPart.m_Heap, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pParentInfo = NULL; // became invalid

    CPropertyLookup Lookup;

    // Check for allocation failures
    if ( !m_Heap.CreateNoCaseStringHeapPtr(wszName, Lookup.ptrName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    Lookup.ptrInformation = ptrNewInfo;

    // Now, insert a new property into the property table
    // ==================================================
    int nIndex = 0;

    // Check for failure (out of memory)
    HRESULT hr = m_Properties.InsertProperty(Lookup, nIndex);

    if ( FAILED(hr) )
    {
        return hr;
    }

    // Set the value to the parent's one and mark as DEFAULT
    // =====================================================

    if(ParentPart.m_Defaults.IsNull(nDataIndex))
    {
        m_Defaults.SetNullness(nDataIndex, TRUE);
    }
    else
    {
        m_Defaults.SetNullness(nDataIndex, FALSE);

        CDataTablePtr ParentValuePtr(&ParentPart.m_Defaults, nDataOffset);
        CDataTablePtr NewValuePtr(&m_Defaults, nDataOffset);

        // Check for allocation errors.
        if ( !CUntypedValue::CopyTo(&ParentValuePtr, nParentType,
                &NewValuePtr, &ParentPart.m_Heap, &m_Heap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    m_Defaults.SetDefaultness(nDataIndex, TRUE);

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetDefaultValue(LPCWSTR wszName, CVar* pVar)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;
    return SetDefaultValue(pInfo, pVar);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetClassQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor /*=NULL*/, CIMTYPE* pct /*=NULL*/)
{
    int nKnownIndex; // garbage
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally(wszName, nKnownIndex);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;
    if(plFlavor) *plFlavor = pQual->fFlavor;

    if ( NULL != pct )
    {
        *pct = pQual->Value.GetType();
    }

    // Check for allocation failure
    if ( NULL != pVar )
    {
        if ( !pQual->Value.StoreToCVar(*pVar, &m_Heap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_NO_ERROR;
}

HRESULT CClassPart::GetClassQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
                                    CFastHeap** ppHeap, BOOL fValidateSet )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    int nKnownIndex; // garbage
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally(wszName, nKnownIndex);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Make sure a set will actually work - Ostensibly we are calling this API because we need
    // direct access to a qualifier's underlying data before actually setting (possibly because
    // the qualifier is an array).
    if ( fValidateSet )
    {
        hr = m_Qualifiers.ValidateSet( wszName, pQual->fFlavor, pTypedValue, TRUE, TRUE );
    }

    if ( SUCCEEDED( hr ) )
    {
        if(plFlavor)
        {
            *plFlavor = pQual->fFlavor;
        }

        // Copy out the qualifier data
        // ==============

        // Local, so it's our heap
        *ppHeap = &m_Heap;

        if ( NULL != pTypedValue )
        {
            pQual->Value.CopyTo( pTypedValue );
        }

    }

    return hr;
}


//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetClassQualifier(LPCWSTR wszName, CVar* pVar,
                                    long lFlavor)
{
    if(pVar->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVar, &m_Heap);
    if ( SUCCEEDED( hr ) )
    {
        hr = m_Qualifiers.SetQualifierValue(wszName, (BYTE)lFlavor,
            &Value, TRUE);
    }

    return hr;
}

 // Helper that deals directly with a typed value
HRESULT CClassPart::SetClassQualifier(LPCWSTR wszName,long lFlavor, CTypedValue* pTypedValue )
{
     return m_Qualifiers.SetQualifierValue( wszName, (BYTE)lFlavor, pTypedValue, TRUE);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor, CIMTYPE* pct /*=NULL*/)
{
    return m_Qualifiers.GetQualifier( wszName, pVar, plFlavor, pct );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 LPMEMORY CClassPart::GetPropertyQualifierSetData(LPCWSTR wszName)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL) return NULL;
    return pInfo->GetQualifierSetData();
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::InitPropertyQualifierSet(LPCWSTR wszName,
                                            CClassPropertyQualifierSet* pSet)
{
    CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
    if(pLookup == NULL) return WBEM_E_NOT_FOUND;

    CPropertyInformation* pInfo = (CPropertyInformation*)
        m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

    pSet->SetData(pInfo->GetQualifierSetData(), this, pLookup->ptrName, NULL);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                           long* plFlags)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL)
    {
        return CSystemProperties::GetPropertyType(wszName, pctType, plFlags);
    }

    HRESULT    hr = GetPropertyType( pInfo, pctType, plFlags );

    return hr;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                           long* plFlags)
{
    if(pctType)
    {
        *pctType = CType::GetActualType(pInfo->nType);
    }
    if(plFlags)
    {
        *plFlags = (CType::IsParents(pInfo->nType))?
                        WBEM_FLAVOR_ORIGIN_PROPAGATED:
                        WBEM_FLAVOR_ORIGIN_LOCAL;
    }
    return WBEM_NO_ERROR;
}

HRESULT CClassPart::GetPropQualifier(CPropertyInformation* pInfo,
                                    LPCWSTR wszQualifier,
                                    CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    // Access that property's qualifier set
    // ====================================

    CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
        pInfo->GetQualifierSetData(), &m_Heap, wszQualifier);

    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Convert to CVar
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

    // Store the type if requested
    if ( NULL != pct )
    {
        *pct = pQual->Value.GetType();
    }

    // Check for possible allocation failure
    if ( NULL != pVar )
    {
        if ( !pQual->Value.StoreToCVar(*pVar, &m_Heap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_NO_ERROR;
}

HRESULT CClassPart::GetPropQualifier(LPCWSTR wszProp,
        LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
        CFastHeap** ppHeap, BOOL fValidateSet)
{
    // Access that property's qualifier set
    // ====================================

    HRESULT    hr = WBEM_S_NO_ERROR;

    CClassPropertyQualifierSet PQSet;
    if(InitPropertyQualifierSet(wszProp, &PQSet) != WBEM_NO_ERROR)
    {
        return WBEM_E_NOT_FOUND;
    }

    int nKnownIndex; // garbage
    CQualifier* pQual = PQSet.GetQualifierLocally(wszQualifier, nKnownIndex);

    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Make sure a set will actually work - Ostensibly we are calling this API because we need
    // direct access to a qualifier's underlying data before actually setting (possibly because
    // the qualifier is an array).
    if ( fValidateSet )
    {
        hr = PQSet.ValidateSet( wszQualifier, pQual->fFlavor, pTypedVal, TRUE, TRUE );
    }

    // Store the flavor
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

    // This class's heap since we're getting locally
    *ppHeap = &m_Heap;

    // Check for possible allocation failure
    if ( NULL != pTypedVal )
    {
        pQual->Value.CopyTo( pTypedVal );
    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetClassName(CVar* pVar)
{
    if(m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS)
    {
        // Check for possible allocation failure
        if ( !m_Heap.ResolveString(m_pHeader->ptrClassName)->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetSuperclassName(CVar* pVar)
{
    CCompressedString* pcs = GetSuperclassName();
    if(pcs != NULL)
    {
        // Check for possible allocation failure
        if ( !pcs->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetDynasty(CVar* pVar)
{
    CCompressedString* pcs = GetDynasty();
    if(pcs != NULL)
    {
        // Check for possible allocation failure
        if ( !pcs->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if(m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS)
    {
        // Check for possible allocation failure
        if ( !m_Heap.ResolveString(m_pHeader->ptrClassName)->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetPropertyCount(CVar* pVar)
{
    int    nNumProperties = m_Properties.GetNumProperties();

    // Enumerate the properties and for each one we find, if the property starts
    // with a "__", then it is a system property and does not count against the
    // actual property count.
    for( int nCtr = 0, nTotal = nNumProperties; nCtr < nTotal; nCtr++ )
    {
        CPropertyLookup* pLookup;
        CPropertyInformation* pInfo;

        pLookup = GetPropertyLookup(nCtr);

        if ( m_Heap.ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
        {
            nNumProperties--;
        }
    }

    pVar->SetLong(nNumProperties);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetDerivation(CVar* pVar)
{
    try
    {
        wmilib::auto_ptr<CVarVector> pvv(new CVarVector(VT_BSTR));
        

        if ( NULL != pvv.get() )
        {
            CCompressedString* pcsCurrent = m_Derivation.GetFirst();

            while(pcsCurrent != NULL)
            {
                wmilib::auto_ptr<CVar> pv(new CVar);

                // Check for allocation failures

                if ( NULL == pv.get() )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

                if ( !pcsCurrent->StoreToCVar(*pv) )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

                if ( pvv->Add(pv.get()) != CVarVector::no_error )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }
                pv.release();
                pcsCurrent = m_Derivation.GetNext(pcsCurrent);
            }

            pVar->SetVarVector(pvv.get(), TRUE);
            pvv.release();
            return WBEM_S_NO_ERROR;

        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetClassName(CVar* pVar)
{
    if( pVar->GetType() != VT_BSTR &&
        pVar->GetType() != VT_LPWSTR )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    // Check that this is not a reserved word
    if ( CReservedWordTable::IsReservedWord( pVar->GetLPWSTR() ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // returns a circular reference if 'this' class and
    // the super class name are the same.

    if ( NULL != pVar->GetLPWSTR() )
    {
        CVar    var;
        GetSuperclassName( &var );

        if ( var == *pVar )
        {
            return WBEM_E_CIRCULAR_REFERENCE;
        }
    }

    if(m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS)
    {
        m_Heap.FreeString(m_pHeader->ptrClassName);
    }

    // Check for allocation errors
    heapptr_t   ptrClassName;
    if ( !m_Heap.AllocateString(pVar->GetLPWSTR(), ptrClassName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pHeader->ptrClassName = ptrClassName;

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 BOOL CClassPart::IsKeyed()
{
    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        if(m_Properties.GetAt(i)->GetInformation(&m_Heap)->IsKey())
            return TRUE;
    }
    // perhaps it's singleton
    if(m_Qualifiers.GetQualifier(L"singleton") != NULL)
    {
        return TRUE;
    }

    return FALSE;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 
BOOL CClassPart::CheckLocalBoolQualifier( LPCWSTR pwszName )
{
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally( pwszName );
    return (pQual &&
            pQual->Value.GetType().GetActualType() == VT_BOOL &&
            pQual->Value.GetBool()
            );
}

BOOL CClassPart::CheckBoolQualifier( LPCWSTR pwszName )
{
    CQualifier* pQual = m_Qualifiers.GetQualifier( pwszName );

    return (pQual &&
            pQual->Value.GetType().GetActualType() == VT_BOOL &&
            pQual->Value.GetBool()
            );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 BOOL CClassPart::GetKeyProps(CWStringArray& awsNames)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    BOOL bFound = FALSE;
    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
        if(pInfo->IsKey())
        {
            bFound = TRUE;

            if ( awsNames.Add(m_Heap.ResolveString(pLookup->ptrName)->
                CreateWStringCopy()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
        }       
    }
    return bFound;
}

 //******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetKeyOrigin(WString& wsClass)
{
    // Check for out of memory
    try
    {
        BOOL bFound = FALSE;

        // Look for keys.  When we find one, get it's class of origin and
        // stuff it in the wsClass parameter.

        for(int i = 0; i < m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_Properties.GetAt(i);
            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
            if(pInfo->IsKey())
            {
                CCompressedString* pcs = m_Derivation.GetAtFromLast(pInfo->nOrigin);
                if(pcs == NULL)
                    pcs = GetClassName();
                if(pcs == NULL)
                    return WBEM_E_INVALID_OBJECT;

                // Check for out of memory
                wsClass = pcs->CreateWStringCopy();

                bFound = TRUE;
            }
        }

        return ( bFound ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 BOOL CClassPart::GetIndexedProps(CWStringArray& awsNames)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    BOOL bFound = FALSE;
    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
        if(pInfo->IsKey())
            continue;

        CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
            pInfo->GetQualifierSetData(), &m_Heap, L"indexed");

        if(pQual != NULL)
        {
            bFound = TRUE;

            // Check for OOM
            if ( awsNames.Add(m_Heap.ResolveString(pLookup->ptrName)->
                CreateWStringCopy()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
    return bFound;

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::IsPropertyKeyed( LPCWSTR pwcsKeyProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsKeyProp )
    {
        // Find the key in the local property table.  If we find it,
        // then see if it's keyed.

        CPropertyLookup* pLookup = m_Properties.FindProperty(pwcsKeyProp);

        if ( NULL != pLookup )
        {

            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

            fReturn = ( NULL != pInfo && pInfo->IsKey() );
        }   
    }  

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::IsPropertyIndexed( LPCWSTR pwcsIndexProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsIndexProp )
    {
        // Find the key in the local property table.  If we find it,
        // then see if it's indexed.

        CPropertyLookup* pLookup = m_Properties.FindProperty(pwcsIndexProp);

        if ( NULL != pLookup )
        {

            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

            if ( NULL != pInfo )
            {
                // Look for the "indexed" qualifier
                CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
                    pInfo->GetQualifierSetData(), &m_Heap, L"indexed");

                fReturn = ( pQual != NULL );
            }

        }   // If we got a local lookup

    }   // IF NULL != pwcsKeyProp

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
    try
    {
        CPropertyInformation* pInfo = FindPropertyInfo(wszProperty);
        if(pInfo == NULL)
        {
            if(CSystemProperties::FindName(wszProperty) >= 0)
            {
                *pstrClassName = COleAuto::_SysAllocString(L"___SYSTEM");
                return WBEM_S_NO_ERROR;
            }
            else
            {
                return WBEM_E_NOT_FOUND;
            }
        }
        else
        {
            CCompressedString* pcs = m_Derivation.GetAtFromLast(pInfo->nOrigin);
            if(pcs == NULL)
                pcs = GetClassName();
            if(pcs == NULL)
                return WBEM_E_INVALID_OBJECT;

            *pstrClassName = pcs->CreateBSTRCopy();

            // check for allocation failures
            if ( NULL == *pstrClassName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            return WBEM_S_NO_ERROR;
        }
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::InheritsFrom(LPCWSTR wszClassName)
{
    CCompressedString*    pClsName = GetClassName();

    if ( NULL != pClsName )
    {
        if( pClsName->CompareNoCase(wszClassName) == 0 )
            return TRUE;
    }

    return (m_Derivation.Find(wszClassName) >= 0);
}

HRESULT CClassPart::GetPropertyHandle(LPCWSTR wszName, CIMTYPE* pct, long* plHandle)
{
    // Check required params
    if ( NULL == wszName || NULL == plHandle )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL)
        return WBEM_E_NOT_FOUND;

    // We don't support arrays or embedded objects
    if( CType::IsArray(pInfo->nType) ||
        CType::GetBasic(pInfo->nType) == CIM_OBJECT )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    // Retrieve the handle from the property info object
    *plHandle = pInfo->GetHandle();

    if(pct)
    {
        *pct = CType::GetActualType(pInfo->nType);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::GetPropertyHandleEx(LPCWSTR wszName, CIMTYPE* pct, long* plHandle)
{
    // This helper function does not filter ot any properties.

    // If the value starts with an underscore see if it's a System Property
    // DisplayName, and if so, switch to a property name - otherwise, this
    // will just return the string we passed in
    
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL)
    {
        if ( wbem_wcsicmp( wszName, L"__CLASS" ) == 0 )
        {
            *plHandle = FASTOBJ_CLASSNAME_PROP_HANDLE;
        }
        else if ( wbem_wcsicmp( wszName, L"__SUBCLASS" ) == 0 )
        {
            *plHandle = FASTOBJ_SUPERCLASSNAME_PROP_HANDLE;
        }
        else
        {
            return WBEM_E_NOT_FOUND;
        }

        if ( NULL != pct )
        {
            *pct = CIM_STRING;
        }

        return WBEM_S_NO_ERROR;
    }

    // Retrieve the handle from the property info object

    // This function will NOT perform any special filtering of handles.  It
    // is assumed that if somebody comes in from this route, they will know to
    // special case handles for embedded objects and arrays, since the normal
    // IWbemObjectAccess functions will not handle those types.

    *plHandle = pInfo->GetHandle();

    // Store the type if it was requested
    if(pct)
    {
        *pct = CType::GetActualType(pInfo->nType);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::GetPropertyInfoByHandle(long lHandle,
                                        BSTR* pstrName, CIMTYPE* pct)
{
    CPropertyLookup* pLookup =
        m_Properties.FindPropertyByOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));

    if(pLookup == NULL)
        return WBEM_E_NOT_FOUND;

    CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

    if(pct)
        *pct = CType::GetActualType(pInfo->nType);
    if(pstrName)
    {
        *pstrName = m_Heap.ResolveString(pLookup->ptrName)->CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == *pstrName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::IsValidPropertyHandle ( long lHandle )
{
    BOOL    fFound = FALSE;

    for ( int nIndex = 0; !fFound && nIndex < m_Properties.GetNumProperties(); nIndex++ )
    {
        CPropertyLookup* pLookup = m_Properties.GetAt( nIndex );

        if ( NULL != pLookup )
        {
            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

            if ( NULL != pInfo )
            {
                fFound = ( lHandle == pInfo->GetHandle() );
            }  
        } 
    } 
    return ( fFound ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
}

HRESULT CClassPart::GetDefaultByHandle(long lHandle, long lNumBytes,
                                        long* plRead, BYTE* pData )
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {
        // Handle strings.

        CCompressedString* pcs = m_Heap.ResolveString(
            *(PHEAPPTRT)(m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));

        long lNumChars = pcs->GetStringLength();
        *plRead = (lNumChars + 1) * 2;
        if(*plRead > lNumBytes)
        {
            return E_OUTOFMEMORY;
        }

        if(pcs->IsUnicode())
        {
            memcpy(pData, pcs->GetRawData(), lNumChars * 2);
        }
        else
        {
            WCHAR* pwcDest = (WCHAR*)pData;
            char* pcSource = (char*)pcs->GetRawData();
            long lLeft = lNumChars;
            while(lLeft--)
            {
                *(pwcDest++) = (WCHAR)*(pcSource++);
            }
        }

        ((LPWSTR)pData)[lNumChars] = 0;

        return WBEM_S_NO_ERROR;
    }
    else
    {
        // Just copy
        // =========

        *plRead = WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle);
        memcpy(pData, (void*) m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)),
                *plRead);
        return WBEM_S_NO_ERROR;
    }
}


HRESULT CClassPart::GetDefaultPtrByHandle(long lHandle, void** ppData )
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {
        *ppData = (void*) m_Heap.ResolveHeapPointer(
            *(PHEAPPTRT)(m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }
    else
    {
        // Set the value properly
        *ppData = m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));
    }

    return WBEM_S_NO_ERROR;

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendHeapSize(LPMEMORY pStart, length_t nOldLength,
    length_t nExtra)
{
    if(EndOf(*this) - EndOf(m_Heap) > (int)nExtra)
        return TRUE;

    int nNeedTotalLength = GetTotalRealLength() + nExtra;

    // Check for allocation failure
    return ReallocAndCompact(nNeedTotalLength);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendDataTableSpace(LPMEMORY pOld, length_t nOldLength,
    length_t nNewLength)
{
    if(m_Heap.GetStart() - pOld > (int)nNewLength)
    	{
	    m_pHeader->nDataLength = nNewLength;
        return TRUE;
    	}

    int nExtra = nNewLength-nOldLength;
    BOOL    fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
	    m_pHeader->nDataLength = nNewLength;
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
void CClassPart::ReduceDataTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement)
{
    m_pHeader->nDataLength -= nDecrement;
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendPropertyTableSpace(LPMEMORY pOld, length_t nOldLength,
    length_t nNewLength)
{
    if(m_Defaults.GetStart() - pOld > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength-nOldLength;
    BOOL    fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
        MoveBlock(m_Defaults, m_Defaults.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
    length_t nNewLength)
{
    if(m_Properties.GetStart() - pSet->GetStart() > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength - pSet->GetLength();

    BOOL    fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
        MoveBlock(m_Defaults, m_Defaults.GetStart() + nExtra);
        MoveBlock(m_Properties, m_Properties.GetStart() + nExtra);
    }

    return fReturn;
}

//*****************************************************************************
//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

length_t CClassPart::EstimateMergeSpace(CClassPart& ParentPart,
                                       CClassPart& ChildPart)
{
    // TBD better
    length_t nLength = ParentPart.GetLength() + ChildPart.GetLength();
    return nLength;
}
//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

LPMEMORY CClassPart::Merge(CClassPart& ParentPart, CClassPart& ChildPart,
        LPMEMORY pDest, int nAllocatedLength)
{
    // Allocate a header
    // =================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;
    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Place our heap at the end of the allocated area. Make it as large as
    // the sum of the other two
    // ====================================================================

    int nHeapSize = ParentPart.m_Heap.GetUsedLength() +
                    ChildPart.m_Heap.GetUsedLength();

    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapSize -
                                                    CFastHeap::GetMinLength();

    memset(pHeapStart,0,nHeapSize+CFastHeap::GetMinLength());
    	
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    // Check for memory allocation failures
    if ( !CCompressedString::CopyToNewHeap(
            ChildPart.m_pHeader->ptrClassName,
            &ChildPart.m_Heap, &Heap,
            pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create merged derivation list
    // =============================

    pCurrentEnd = CDerivationList::Merge(
        ParentPart.m_Derivation, ChildPart.m_Derivation, pCurrentEnd);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create merged class qualifier set
    // =================================

    pCurrentEnd = CClassQualifierSet::Merge(
        ParentPart.m_Qualifiers.GetStart(), &ParentPart.m_Heap,
        ChildPart.m_Qualifiers.GetStart(), &ChildPart.m_Heap,
        pCurrentEnd, &Heap);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create merged property lookup table
    // ===================================

    LPMEMORY pLookupTable = pCurrentEnd;
    pCurrentEnd = CPropertyLookupTable::Merge(
        &ParentPart.m_Properties, &ParentPart.m_Heap,
        &ChildPart.m_Properties, &ChildPart.m_Heap,
        pCurrentEnd, &Heap);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create merged data table
    // ========================

    CPropertyLookupTable LookupTable;
    LookupTable.SetData(pLookupTable, NULL);

    pCurrentEnd = CDataTable::Merge(
        &ParentPart.m_Defaults, &ParentPart.m_Heap,
        &ChildPart.m_Defaults, &ChildPart.m_Heap,
        &LookupTable,
        pCurrentEnd, &Heap);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }
    
    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap,pCurrentEnd,pDest+nAllocatedLength-pCurrentEnd);

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );
    pHeader->fFlags = ChildPart.m_pHeader->fFlags;
    pHeader->nDataLength = ChildPart.m_pHeader->nDataLength;

    return EndOf(Heap);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

HRESULT CClassPart::Update(CClassPart& UpdatePart, CClassPart& ChildPart, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First set the class name of the Update part

    CVar    vTemp;

    hr = ChildPart.GetClassName( &vTemp );

    if ( SUCCEEDED( hr ) )
    {
        // Check that we're not about to create a circular reference
        hr = UpdatePart.TestCircularReference( (LPCWSTR) vTemp );

        if ( SUCCEEDED( hr ) )
        {
            hr = UpdatePart.SetClassName( &vTemp );

            // Next update the class qualifiers and the properties
            if ( SUCCEEDED( hr ) )
            {

                hr = UpdatePart.m_Qualifiers.Update( ChildPart.m_Qualifiers, lFlags );

                if ( SUCCEEDED( hr ) )
                {
                    hr = CClassPart::UpdateProperties( UpdatePart, ChildPart, lFlags );
                } 
            }   
        }  
    }   

    return hr;
}

HRESULT CClassPart::UpdateProperties(CClassPart& UpdatePart, CClassPart& ChildPart, long lFlags )
{
    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        WString wstrPropName;

        // Now try to upgrade the property table by walking the child class part's
        // property table which should only have local properties.  For each property
        // found, get the name and try to get it's type from the parent class.  If
        // we can't because the property can't be found, add the property and value
        // to the new class, otherwise check for type mismatch errors and resolve
        // accordingly.

        for(int i = 0; SUCCEEDED( hr ) && i < ChildPart.m_Properties.GetNumProperties(); i++)
        {
            CIMTYPE ctUpdateProperty, ctChildPropType;

            CPropertyLookup* pLookup = ChildPart.m_Properties.GetAt(i);
            CPropertyInformation* pInfo = pLookup->GetInformation(&ChildPart.m_Heap);

            wstrPropName = ChildPart.m_Heap.ResolveString(pLookup->ptrName)->CreateWStringCopy();

            // This is the type of the child class property
            ctChildPropType = CType::GetActualType(pInfo->nType);

            HRESULT hrProp = UpdatePart.GetPropertyType( wstrPropName, &ctUpdateProperty, NULL );

            // If this succeeded, and types are different, we have a problem.  Otherwise
            // if types match, we can safely store default values, or if we couldn't
            // get the property, then it must be added.

            if ( SUCCEEDED( hrProp ) && ctChildPropType != ctUpdateProperty )
            {
                hr = WBEM_E_TYPE_MISMATCH;
            }
            else
            {
                hr = WBEM_S_NO_ERROR;

                CVar        vVal;

                // Get the property default value, then add the property
                // to 'this' class part.  If the property already existed,
                // this won't cause any problems.

                hr = ChildPart.GetDefaultValue( wstrPropName, &vVal );

                if ( SUCCEEDED( hr ) )
                {
                    // Makes sure the property exists, adding if necessary
                    hr = UpdatePart.EnsureProperty( wstrPropName, (VARTYPE) vVal.GetOleType(),
                                                    ctChildPropType, FALSE );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = UpdatePart.SetDefaultValue( wstrPropName, &vVal );
                    }

                }   // IF GotDefaultValue

            }   // IF GotPropertyType

            // At this point if we have a success, we should have properties in both
            // classes, so now check out the qualifiers for each.

            if ( SUCCEEDED( hr ) )
            {
                CClassPropertyQualifierSet qsUpdateProp;
                CBasicQualifierSet qsChildProp;

                hr = UpdatePart.InitPropertyQualifierSet( wstrPropName, &qsUpdateProp );

                if ( SUCCEEDED( hr ) )
                {
                    // We already have everything we need
                    qsChildProp.SetData( pInfo->GetQualifierSetData(), &ChildPart.m_Heap );

                    // Update the new class property qualifier set

                    // Make sure CIMTYPE is copied here as well, since for "ref"
                    // type properties, it's value will override what was specified
                    // in the base class.

                    hr = qsUpdateProp.Update( qsChildProp, lFlags, NULL );
                }   // IF Got PQS for UpdatePart

            }   // IF ok

        }   // FOR enum properties

        return hr;

    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
length_t CClassPart::EstimateUnmergeSpace()
{
    return GetLength();
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
LPMEMORY CClassPart::Unmerge(LPMEMORY pDest, int nAllocatedLength)
{
    // Allocate the header
    // ===================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Note that no flags are written out here, so we don't need to do any
    // fancy behind the back switching with the localization flags.

    // Place our heap at the end of the allocated area. Make it as large as
    // the sum of the other two
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapSize -
                                                    CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    // Check for allocation failures
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName,
            &m_Heap, &Heap,
            pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create unmerged deirvation list (just the superclass)
    // =====================================================

    // This does not perform any allocations
    pCurrentEnd = m_Derivation.Unmerge(pCurrentEnd);

    // Create unmerged class qualifier set
    // ===================================

    pCurrentEnd = CClassQualifierSet::Unmerge(
        m_Qualifiers.GetStart(), &m_Heap,
        pCurrentEnd, &Heap);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create unmerged property lookup table (overriden and new)
    // =========================================================

    pCurrentEnd = m_Properties.Unmerge(&m_Defaults, &m_Heap,
        pCurrentEnd, &Heap);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Unmerge defaults table: copy only overriden values
    // ==================================================

    pCurrentEnd = m_Defaults.Unmerge(&m_Properties, &m_Heap,
        pCurrentEnd, &Heap);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Now, relocate the heap to its actual location
    // =============================================

    Heap.Trim();
    MoveBlock(Heap, pCurrentEnd);

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting length
    // > 0xFFFFFFFF so cast is ok

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );
    pHeader->fFlags = m_pHeader->fFlags;
    pHeader->nDataLength = m_pHeader->nDataLength;

    return EndOf(Heap);
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
length_t CClassPart::EstimateDerivedPartSpace()
{
    return GetLength() + CDerivationList::EstimateExtraSpace(GetClassName());
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
LPMEMORY CClassPart::CreateDerivedPart(LPMEMORY pDest,
                                       int nAllocatedLength)
{
    // Allocate the header
    // ===================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Place our heap at the end of the allocated area. Make it as large as
    // the sum of the other two
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapSize -
                                              CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    pHeader->ptrClassName = INVALID_HEAP_ADDRESS;

    // Create propagated derivation list
    // =================================

    // This call performs no allocations
    pCurrentEnd = m_Derivation.CreateWithExtra(pCurrentEnd, GetClassName());

    // Create propagated qualifier set
    // ===============================

    CStaticPtr OriginalStartPtr(m_Qualifiers.GetStart());
    CStaticPtr CurrentEndPtr(pCurrentEnd);
    pCurrentEnd = CBasicQualifierSet::WritePropagatedVersion(
        &OriginalStartPtr,
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS,
        &CurrentEndPtr, &m_Heap, &Heap);

    // Check for allocation failure.
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create combined property lookup table
    // =====================================

    pCurrentEnd = m_Properties.WritePropagatedVersion(
        &m_Heap, pCurrentEnd, &Heap);

    // Check for allocation failure.
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create propagated data table
    // ============================

    pCurrentEnd = m_Defaults.WritePropagatedVersion(
        &m_Properties, &m_Heap, pCurrentEnd, &Heap);

    // Check for allocation failure.
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Now, relocate the heap to its actual location
    // =============================================

    MoveBlock(Heap, pCurrentEnd);
    Heap.Trim();

    // Finish up tbe header
    // ====================

    pHeader->nLength = nAllocatedLength; // save overallocation for lated
    pHeader->nDataLength = m_pHeader->nDataLength;

    return pDest + nAllocatedLength;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

EReconciliation CClassPart::CanBeReconciledWith(CClassPart& NewPart)
{
    // Check that the class names match
    // ================================

    if(m_Heap.ResolveString(m_pHeader->ptrClassName)->CompareNoCase(
         *NewPart.m_Heap.ResolveString(NewPart.m_pHeader->ptrClassName)) != 0)
    {
        return e_DiffClassName;
    }

    // Check that the superclass names match
    // =====================================

    CCompressedString* pcsOldSuperclass = GetSuperclassName();
    CCompressedString* pcsNewSuperclass = NewPart.GetSuperclassName();
    if(pcsOldSuperclass == NULL || pcsNewSuperclass == NULL)
    {
        if(pcsOldSuperclass != pcsNewSuperclass)
            return e_DiffParentName;
    }
    else
    {
        if(pcsOldSuperclass->CompareNoCase(*pcsNewSuperclass) != 0)
        {
            return e_DiffParentName;
        }
    }

    // Check singleton-ness
    // ====================

    if((IsSingleton() == TRUE) != (NewPart.IsSingleton() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check abstract-ness
    // ===================

    if((IsAbstract() == TRUE) != (NewPart.IsAbstract() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check amendment-ness
    // ===================

    if((IsAmendment() == TRUE) != (NewPart.IsAmendment() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    if((GetAbstractFlavor() == TRUE) != (NewPart.GetAbstractFlavor() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check compress-ness
    // ===================

    if((IsCompressed() == TRUE) != (NewPart.IsCompressed() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check dynamic-ness
    // ==================

    if((IsDynamic() == TRUE) != (NewPart.IsDynamic() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Make sure that the unimportant qualifiers can be reconciled with
    // each other

    CBasicQualifierSet* pqsBasicThis = &m_Qualifiers;
    CBasicQualifierSet* pqsBasicThat = &NewPart.m_Qualifiers;

    // Make sure we filter out the conflict qualifier
    if ( !pqsBasicThis->CanBeReconciledWith( *pqsBasicThat ) )
    {
        return e_DiffClassQualifier;
    }

    // Check that all the properties are the same
    // ==========================================

    if(m_Properties.GetNumProperties() !=
        NewPart.m_Properties.GetNumProperties())
    {
        return e_DiffNumProperties;
    }

    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);
        CPropertyLookup* pNewLookup = NewPart.m_Properties.GetAt(i);

        // Compare names
        // =============

        if(m_Heap.ResolveString(pLookup->ptrName)->CompareNoCase(
            *NewPart.m_Heap.ResolveString(pNewLookup->ptrName)) != 0)
        {
            return e_DiffPropertyName;
        }

        // Get property information structures
        // ===================================

        CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
        CPropertyInformation* pNewInfo =
            pNewLookup->GetInformation(&NewPart.m_Heap);

        // Compare types
        // =============

        if(pInfo->nType != pNewInfo->nType)
        {
            return e_DiffPropertyType;
        }

        // Compare vtable information
        // ==========================

        if(pInfo->nDataIndex != pNewInfo->nDataIndex ||
            pInfo->nDataOffset != pNewInfo->nDataOffset)
        {
            return e_DiffPropertyLocation;
        }

        // Compare 'key'-ness and 'index'-ness
        // ===================================

        BOOL bIsKey = pInfo->IsKey();
        BOOL bNewIsKey = pNewInfo->IsKey();
        if((bIsKey && !bNewIsKey) || (!bIsKey && bNewIsKey))
        {
            return e_DiffKeyAssignment;
        }

        BOOL bIsIndexed = pInfo->IsIndexed(&m_Heap);
        BOOL bNewIsIndexed = pNewInfo->IsIndexed(&NewPart.m_Heap);
        if((bIsIndexed && !bNewIsIndexed) || (!bIsIndexed && bNewIsIndexed))
        {
            return e_DiffIndexAssignment;
        }

        // Compare CIMTYPE qualifiers
        // ==========================

        CVar vCimtype;
        GetPropQualifier(pInfo, L"cimtype", &vCimtype);
        CVar vNewCimtype;
        NewPart.GetPropQualifier(pNewInfo, L"cimtype", &vNewCimtype);

        if(wbem_wcsicmp(vCimtype.GetLPWSTR(), vNewCimtype.GetLPWSTR()))
        {
            return e_DiffPropertyType;
        }

        // Compare property values
        // ==========================

        CVar    vThisProp,
                vThatProp;

        // Check for allocation failures
        HRESULT hr = GetDefaultValue( pInfo, &vThisProp );

        if ( FAILED(hr) )
        {
            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                return e_OutOfMemory;
            }

            return e_WbemFailed;
        }

        // Check for allocation failures
        hr = NewPart.GetDefaultValue( pNewInfo, &vThatProp );

        if ( FAILED(hr) )
        {
            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                return e_OutOfMemory;
            }

            return e_WbemFailed;
        }

        if ( !( vThisProp == vThatProp ) )
        {
            return e_DiffPropertyValue;
        }

        // Make sure that unimportant qualifiers can be reconciled with
        // each other

        // Compare qualifier values
        // ==========================

        CBasicQualifierSet  qsThisProp,
                            qsThatProp;

        qsThisProp.SetData( pInfo->GetQualifierSetData(), &m_Heap );
        qsThatProp.SetData( pNewInfo->GetQualifierSetData(), &NewPart.m_Heap );

        if ( !qsThisProp.CanBeReconciledWith( qsThatProp ) )
        {
            return e_DiffPropertyQualifier;
        }

    }
    return e_Reconcilable;
}

BYTE CClassPart::GetAbstractFlavor()
{
    CQualifier* pQual = m_Qualifiers.GetQualifier(L"abstract");
    if(pQual == NULL)
        return 0;
    else
        return pQual->GetFlavor();
}
//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

EReconciliation CClassPart::ReconcileWith( CClassPart& NewPart )
{
    // Check if we can
    // ===============

    EReconciliation eRes = CanBeReconciledWith(NewPart);
    if(eRes != e_Reconcilable)
        return eRes;

    // Compact NewPart and replace ourselves with it
    // =============================================

    NewPart.Compact();

    if(NewPart.GetLength() > GetLength())
    {
        if (!m_pContainer->ExtendClassPartSpace(this, NewPart.GetLength()))
            return e_OutOfMemory;
    }

    memcpy(GetStart(), NewPart.GetStart(), NewPart.GetLength());
    SetData(GetStart(), m_pContainer, m_pParent);

    return eRes;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

EReconciliation CClassPart::CompareExactMatch(CClassPart& thatPart, BOOL fLocalized /* = FALSE */ )
{
    // Check for out of memory
    try
    {
        // Check that the class names match
        // ================================

        if(m_Heap.ResolveString(m_pHeader->ptrClassName)->CompareNoCase(
             *thatPart.m_Heap.ResolveString(thatPart.m_pHeader->ptrClassName)) != 0)
        {
            return e_DiffClassName;
        }

        // Check that the superclass names match
        // =====================================

        CCompressedString* pcsOldSuperclass = GetSuperclassName();
        CCompressedString* pcsNewSuperclass = thatPart.GetSuperclassName();
        if(pcsOldSuperclass == NULL || pcsNewSuperclass == NULL)
        {
            if(pcsOldSuperclass != pcsNewSuperclass)
                return e_DiffParentName;
        }
        else
        {
            if(pcsOldSuperclass->CompareNoCase(*pcsNewSuperclass) != 0)
            {
                return e_DiffParentName;
            }
        }


        // Set up the array of filters to use while dealing with qualifiers
        // We must NOT filter out the CIMTYPE qualifier for properties, since
        // that qualifier is where we will find out if a reference changed
        // for a "ref" types property.

        LPCWSTR apFilters[1];
        apFilters[0] = UPDATE_QUALIFIER_CONFLICT;

        // Check that qualifiers are the same
        CBasicQualifierSet* pqsBasicThis = &m_Qualifiers;
        CBasicQualifierSet* pqsBasicThat = &thatPart.m_Qualifiers;

        if ( fLocalized )
        {
            // The CompareLocalized function will create a special set of filters
            // based on localization rules
            if ( !pqsBasicThis->CompareLocalizedSet( *pqsBasicThat ) )
            {
                return e_DiffClassQualifier;
            }
        }
        else
        {
            // Make sure we filter out the conflict qualifier

            if ( !pqsBasicThis->Compare( *pqsBasicThat, WBEM_FLAG_LOCAL_ONLY, apFilters, 1 ) )
            {
                return e_DiffClassQualifier;
            }
        }

        // Check that all the properties are the same
        // ==========================================

        if(m_Properties.GetNumProperties() !=
            thatPart.m_Properties.GetNumProperties())
        {
            return e_DiffNumProperties;
        }

        // Construct this once
        WString wstrPropertyName;

        for(int i = 0; i < m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_Properties.GetAt(i);
            CPropertyLookup* pNewLookup = thatPart.m_Properties.GetAt(i);

            // Compare names
            // =============

            if(m_Heap.ResolveString(pLookup->ptrName)->CompareNoCase(
                *thatPart.m_Heap.ResolveString(pNewLookup->ptrName)) != 0)
            {
                return e_DiffPropertyName;
            }

            // Store the name for later
            wstrPropertyName = m_Heap.ResolveString(pLookup->ptrName)->CreateWStringCopy();

            // Get property information structures
            // ===================================

            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
            CPropertyInformation* pNewInfo =
                pNewLookup->GetInformation(&thatPart.m_Heap);

            // Compare types
            // =============

            if(pInfo->nType != pNewInfo->nType)
            {
                return e_DiffPropertyType;
            }

            // Compare vtable information
            // ==========================

            if(pInfo->nDataIndex != pNewInfo->nDataIndex ||
                pInfo->nDataOffset != pNewInfo->nDataOffset)
            {
                return e_DiffPropertyLocation;
            }

            // Compare values
            // ==========================

            CVar    vThisProp,
                    vThatProp;

            // Check for allocation failures
            HRESULT hr = GetDefaultValue( wstrPropertyName, &vThisProp );

            if ( FAILED(hr) )
            {
                if ( WBEM_E_OUT_OF_MEMORY == hr )
                {
                    return e_OutOfMemory;
                }

                return e_WbemFailed;
            }

            // Check for allocation failures
            hr = thatPart.GetDefaultValue( wstrPropertyName, &vThatProp );

            if ( FAILED(hr) )
            {
                if ( WBEM_E_OUT_OF_MEMORY == hr )
                {
                    return e_OutOfMemory;
                }

                return e_WbemFailed;
            }

            if ( !( vThisProp == vThatProp ) )
            {
                return e_DiffPropertyValue;
            }

            // Compare qualifier values
            // ==========================

            CBasicQualifierSet  qsThisProp,
                                qsThatProp;

            qsThisProp.SetData( pInfo->GetQualifierSetData(), &m_Heap );
            qsThatProp.SetData( pNewInfo->GetQualifierSetData(), &thatPart.m_Heap );

            // Remember, do NOT filter out "CIMTYPE"

            if ( fLocalized )
            {
                // The CompareLocalized function will create a special set of filters
                // based on localization rules
                if ( !qsThisProp.CompareLocalizedSet( qsThatProp ) )
                {
                    return e_DiffClassQualifier;
                }
            }
            else
            {
                if ( !qsThisProp.Compare( qsThatProp, WBEM_FLAG_LOCAL_ONLY, apFilters, 1 ) )
                {
                    return e_DiffPropertyQualifier;
                }

            }

        }   // FOR EnumProperties

        return e_ExactMatch;
    }
    catch (CX_MemoryException)
    {
        return e_OutOfMemory;
    }
    catch (...)
    {
        return e_WbemFailed;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::CompareDefs(CClassPart& OtherPart)
{
    // Check that the class names match
    // ================================

    // Check that the class names match
    // ================================
    CCompressedString* pcsOld = GetClassName();
    CCompressedString* pcsNew = OtherPart.GetClassName();
    if(pcsOld == NULL || pcsNew == NULL)
    {
        if(pcsOld != pcsNew)
            return FALSE;
    }
    else
    {
        if(pcsOld->CompareNoCase(*pcsNew) != 0)
        {
            return FALSE;
        }
    }

    // Check that the superclass names match
    // =====================================

    pcsOld = GetSuperclassName();
    pcsNew = OtherPart.GetSuperclassName();
    if(pcsOld == NULL || pcsNew == NULL)
    {
        if(pcsOld != pcsNew)
            return FALSE;
    }
    else
    {
        if(pcsOld->CompareNoCase(*pcsNew) != 0)
        {
            return FALSE;
        }
    }

    // Check that the number of properties is the same
    // ===============================================

    if(m_Properties.GetNumProperties() !=
        OtherPart.m_Properties.GetNumProperties())
    {
        return FALSE;
    }

    return TRUE;
}

//*****************************************************************************
//
//  See fastcls.h for documentation
//
//*****************************************************************************

BOOL CClassPart::IsIdenticalWith(CClassPart& OtherPart)
{
    Compact();
    OtherPart.Compact();

    if(GetLength() != OtherPart.GetLength())
    {
        DEBUGTRACE((LOG_WBEMCORE, "Class parts have different lengths: "
                        "%d != %d\n", GetLength(), OtherPart.GetLength()));
        return FALSE;
    }

    if(memcmp(GetStart(), OtherPart.GetStart(), GetLength()))
    {
        ERRORTRACE((LOG_WBEMCORE, "FATAL ERROR: Client application provided a "
            "mismatched class part!!!!\n"));

        return FALSE;
    }


    return TRUE;
}

//*****************************************************************************
//
//  See fastcls.h for documentation
//
//*****************************************************************************
BOOL CClassPart::MapLimitation(
    IN long lFlags,
    IN CWStringArray* pwsNames,
    OUT CLimitationMapping* pMap)
{
    if(!m_Properties.MapLimitation(lFlags, pwsNames, pMap)) return FALSE;

    // Optimization: if this class is keyed, then clear "include child keys"
    // bit since children can't have any
    // =====================================================================

    if(pMap->ShouldAddChildKeys() && IsKeyed())
    {
        pMap->SetAddChildKeys(FALSE);
    }

    // Check whether to include derivation
    // ===================================

    BOOL bIncludeDerivation;
    if(pwsNames->FindStr(L"__DERIVATION", CWStringArray::no_case) !=
                                                CWStringArray::not_found ||
       pwsNames->FindStr(L"__SUPERCLASS", CWStringArray::no_case) !=
                                                CWStringArray::not_found ||
       pwsNames->FindStr(L"__DYNASTY", CWStringArray::no_case) !=
                                                CWStringArray::not_found
      )
    {
        bIncludeDerivation = TRUE;
    }
    else
    {
        bIncludeDerivation = FALSE;
    }

    pMap->SetIncludeDerivation(bIncludeDerivation);

    return TRUE;
}
//*****************************************************************************
//
//  See fastcls.h for documentation
//
//*****************************************************************************

LPMEMORY CClassPart::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys)
{
    // Clear any specific into in the map --- we may need to store our own
    // for the instance part's sake.
    // ===================================================================

    pMap->RemoveSpecific();

    // Allocate the header
    // ===================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Place new heap at the end of the allocated area. Make it as large as
    // the current one.
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedSize - nHeapSize -
                                              CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    // Check for allocation problems
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName,
            &m_Heap, &Heap,
            pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create limited derivation list
    // ==============================

    pCurrentEnd = m_Derivation.CreateLimitedRepresentation(pMap, pCurrentEnd);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create limited qualifier set
    // ============================

    if(pMap->GetFlags() & WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS)
    {
        // No qualifiers need to be written
        // ================================

        pCurrentEnd = CBasicQualifierSet::CreateEmpty(pCurrentEnd);
    }
    else
    {
        // Copy them all
        // =============

        int nLength = m_Qualifiers.GetLength();
        memcpy(pCurrentEnd, m_Qualifiers.GetStart(), nLength);

        CStaticPtr CurrentEndPtr(pCurrentEnd);

        // Check for allocation failures
        if ( !CBasicQualifierSet::TranslateToNewHeap(&CurrentEndPtr, &m_Heap, &Heap) )
        {
            return NULL;
        }

        pCurrentEnd += nLength;
    }

    // Create limited property lookup table and data table
    // ===================================================

    // Check for allocation failures
    pCurrentEnd = m_Properties.CreateLimitedRepresentation(pMap, &Heap,
                                        pCurrentEnd, bRemovedKeys);
    if ( NULL == pCurrentEnd ) return NULL;

    // Create limited data table
    // =========================

    // Check for allocation failures
    LPMEMORY pNewEnd = m_Defaults.CreateLimitedRepresentation(pMap, TRUE,
                                            &m_Heap, &Heap, pCurrentEnd);
    if(pNewEnd == NULL) return NULL;

    // Set the data length in the part header
    // ======================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    pHeader->nDataLength = (length_t) ( pNewEnd - pCurrentEnd );

    pCurrentEnd = pNewEnd;

    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap, pCurrentEnd,pDest+nAllocatedSize-pCurrentEnd);
    Heap.Trim();

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );

    return EndOf(Heap);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

HRESULT CClassPart::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                    long lFlavor, CVar *pVal)
{
    if(pVal->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    // Access that property's qualifier set
    // ====================================

    CClassPropertyQualifierSet PQSet;
    if(InitPropertyQualifierSet(wszProp, &PQSet) != WBEM_NO_ERROR)
    {
        return WBEM_E_NOT_FOUND;
    }

    // Create the value
    // ================

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVal, &m_Heap);

    if ( SUCCEEDED( hr ) )
    {
        // The last call may have moved us --- rebase
        // ==========================================

        PQSet.SelfRebase();
        hr = PQSet.SetQualifierValue(wszQualifier, (BYTE)lFlavor, &Value, TRUE);
    }

    return hr;
}

HRESULT CClassPart::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                    long lFlavor, CTypedValue* pTypedVal)
{
    // Access that property's qualifier set
    // ====================================

    CClassPropertyQualifierSet PQSet;
    if(InitPropertyQualifierSet(wszProp, &PQSet) != WBEM_NO_ERROR)
    {
        return WBEM_E_NOT_FOUND;
    }

    HRESULT hr = PQSet.SetQualifierValue(wszQualifier, (BYTE)lFlavor, pTypedVal, TRUE);

    return hr;
}

HRESULT CClassPart::SetInheritanceChain(long lNumAntecedents,
                        LPWSTR* awszAntecedents)
{
    // The underlying functions should handle any OOM exceptions, so we don't
    // need to add any OOM handling here.  Everything else is just playing
    // with memory that's already been alloced.

    classindex_t nOldClassOrigin = m_Derivation.GetNumStrings();

    // Compute the necessary space
    // ===========================

    length_t nDerLength = CDerivationList::GetHeaderLength();
    long i;
    for(i = 0; i < lNumAntecedents; i++)
    {
        nDerLength += CDerivationList::EstimateExtraSpace(awszAntecedents[i]);
    }

    // Move everything forward
    // =======================

    int nExtra = nDerLength - m_Derivation.GetLength();

    // Check for an allocation error
    if ( !ReallocAndCompact(GetTotalRealLength() + nExtra) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
    MoveBlock(m_Defaults, m_Defaults.GetStart() + nExtra);
    MoveBlock(m_Properties, m_Properties.GetStart() + nExtra);
    MoveBlock(m_Qualifiers, m_Qualifiers.GetStart() + nExtra);

    // Reset the derivation table
    // ==========================

    m_Derivation.Reset();

    // Add all the strings in reverse order
    // ====================================

    for(i = lNumAntecedents - 1; i >= 0; i--)
    {
        m_Derivation.AddString(awszAntecedents[i]);
    }

    // Go through all the properties and reset the origin
    // ==================================================

    int nNewClassOrigin = m_Derivation.GetNumStrings();
    for(i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyInformation* pInfo =
                m_Properties.GetAt(i)->GetInformation(&m_Heap);
        if(pInfo->nOrigin == nOldClassOrigin)
            pInfo->nOrigin = nNewClassOrigin;
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::SetPropertyOrigin(LPCWSTR wszPropertyName, long lOriginIndex)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    // Find the property
    // =================

    CPropertyInformation* pInfo = FindPropertyInfo(wszPropertyName);
    if(pInfo == NULL)
        return WBEM_E_NOT_FOUND;

    pInfo->nOrigin = lOriginIndex;
    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::CanContainAbstract( BOOL fValue )
{
    // The following code should be uncommented when we determine it is safe to
    // let this code go in.

    // Can add "abstract" ONLY if we are a top level class or the parent is
    // also abstract
    if ( IsTopLevel() )
    {
        return WBEM_S_NO_ERROR;
    }

    long    lFlavor = 0;
    BOOL    bIsLocal = FALSE;
    CVar    var;

    // If we didn't get a qualifier or it wasn't local and it doesn't propagate to
    // derived classes, we're done.

    // In each case, since the located qualifier is not local or propagated to classes,
    // assume our parent class is non-abstract, hence our return is indicated by the
    // abstractness we are trying to set

    if ( FAILED( m_pParent->m_Qualifiers.GetQualifier( L"abstract", &var, &lFlavor ) ) )
    {
        return ( fValue ? WBEM_E_CANNOT_BE_ABSTRACT : WBEM_S_NO_ERROR );
    }

    if ( !CQualifierFlavor::IsLocal( (BYTE) lFlavor ) &&
        !CQualifierFlavor::DoesPropagateToDerivedClass( (BYTE) lFlavor ) )
    {
        return ( fValue ? WBEM_E_CANNOT_BE_ABSTRACT : WBEM_S_NO_ERROR );
    }

    // If the parent was abstract, then the child can also be abstract or shut this off.

    if ( var.GetBool() == VARIANT_TRUE )
    {
        return WBEM_S_NO_ERROR;
    }

    // If the parent is non-abstract, then the child can only be abstract if this
    // is to be non-abstract (basically a redundant qualifier at this point).
    return ( fValue ? WBEM_E_CANNOT_BE_ABSTRACT : WBEM_S_NO_ERROR );
}

HRESULT CClassPart::IsValidClassPart( void )
{

    LPMEMORY    pClassPartStart = GetStart();
    LPMEMORY    pClassPartEnd = GetStart() + GetLength();

    // Check that the header is in the BLOB
    if ( !((LPMEMORY) m_pHeader < pClassPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Class Part Header!" ));
        return WBEM_E_FAILED;
    }


    // Check the derivation
    LPMEMORY    pTestStart = m_Derivation.GetStart();
    LPMEMORY    pTestEnd = m_Derivation.GetStart() + m_Derivation.GetLength();

    if ( !( pTestStart == (pClassPartStart + sizeof(CClassPartHeader)) &&
            pTestEnd > pTestStart && pTestEnd < pClassPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Derivation List in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the qualifier set
    pTestStart = m_Qualifiers.GetStart();
    pTestEnd = m_Qualifiers.GetStart() + m_Qualifiers.GetLength();

    if ( !( pTestStart == EndOf(m_Derivation) &&
            pTestEnd > pTestStart && pTestEnd < pClassPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Qualifier Set in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the Property lookup table
    pTestStart = m_Properties.GetStart();
    pTestEnd = m_Properties.GetStart() + m_Properties.GetLength();

    // A delete qualifier on a class part, can cause a gap between it and the
    // lookup table, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pTestStart >= EndOf(m_Qualifiers) &&
            pTestEnd > pTestStart && pTestEnd < pClassPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Property Lookup Table in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the Defaults
    pTestStart = m_Defaults.GetStart();
    pTestEnd = m_Defaults.GetStart() + m_Defaults.GetLength();

    // We could have a zero property object, or during a delete property on a class part,
    // the property lookup table can shrink, causing a gap between it and the
    // data table, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pTestStart >= EndOf(m_Properties) &&
            pTestEnd >= pTestStart && pTestEnd < pClassPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Default Property Table Set in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the Heap
    LPMEMORY    pHeapStart = m_Heap.GetStart();
    LPMEMORY    pHeapEnd = m_Heap.GetStart() + m_Heap.GetLength();

    // the data table can shrink, causing a gap between it and the
    // heap when a property is deleted.  So as long as this is in
    // the BLOB, we'll call it okay.

    if ( !( pHeapStart >= EndOf(m_Defaults) &&
            pHeapEnd > pHeapStart && pHeapEnd <= pClassPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Heap in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Get the heap data start
    pHeapStart = m_Heap.GetHeapData();

    // Check that the classname pointer is in the BLOB (if it's not 0xFFFFFFFF)
    if ( m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS )
    {
        LPMEMORY    pClassName = m_Heap.ResolveHeapPointer( m_pHeader->ptrClassName );
        if ( !( pClassName >= pHeapStart && pClassName < pHeapEnd ) )
        {
            _ASSERT( 0, __TEXT("Winmgmt: Bad Class Name Pointer in Class Part Header!" ));
            return WBEM_E_FAILED;
        }
    }

    // Now check the qualifier set
    HRESULT hres = m_Qualifiers.IsValidQualifierSet();
    if ( FAILED(hres) )
    {
        return hres;
    }

    // We're going to walk the instance property list and for every property
    // we find, if it's not NULL or DEFAULT , and a string, array or object,
    // verify that it actually points into a location in our heap.

    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);

        // This should be within the bounds of the class part as well.
        if ( !( (LPBYTE) pLookup >= pClassPartStart && (LPBYTE) pLookup < pClassPartEnd  ) )
        {
            _ASSERT( 0, __TEXT("Winmgmt: Bad Property Lookup Pointer!" ));
            return WBEM_E_FAILED;
        }

        // Check the property name
        LPMEMORY    pPropName = NULL;
        
        if ( !CFastHeap::IsFakeAddress( pLookup->ptrName ) )
        {
            pPropName = m_Heap.ResolveHeapPointer( pLookup->ptrName );
        }
        
        // This should be within the bounds of the class part as well.
        if ( !( NULL == pPropName || ( pPropName >= pClassPartStart && pPropName < pClassPartEnd  ) ) )
        {
            _ASSERT( 0, __TEXT("Winmgmt: Bad Property Name Pointer!" ));
            return WBEM_E_FAILED;
        }

        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_Heap);

        // This should be within the bounds of the class part as well.
        if ( !( (LPBYTE) pInfo >= pClassPartStart && (LPBYTE) pInfo < pClassPartEnd  ) )
        {
            _ASSERT( 0, __TEXT("Winmgmt: Bad Property Info Pointer!" ));
            return WBEM_E_FAILED;
        }

        // We only do this for non-NULL values
        if( !m_Defaults.IsNull(pInfo->nDataIndex) )
        {
            if ( CType::IsPointerType( pInfo->nType ) )
            {
                CUntypedValue*  pValue = m_Defaults.GetOffset( pInfo->nDataOffset );

                if ( (LPMEMORY) pValue >= pClassPartStart && (LPMEMORY) pValue < pClassPartEnd )
                {
                    LPMEMORY    pData = m_Heap.ResolveHeapPointer( pValue->AccessPtrData() );

                    if ( pData >= pHeapStart && pData < pHeapEnd  )
                    {
                        // We could, if an embedded object, validate the object,
                        // or if an array of ptr values, validate those as well

                        if ( CType::IsArray( pInfo->nType ) )
                        {
                            hres = ((CUntypedArray*) pData)->IsArrayValid( pInfo->nType, &m_Heap );

                            if ( FAILED( hres ) )
                            {
                                return hres;
                            }
                        }

                    }
                    else
                    {
                        _ASSERT( 0, __TEXT("Winmgmt: Bad Property Value Heap Pointer!" ));
                        return WBEM_E_FAILED;
                    }
                }
                else
                {
                    _ASSERT( 0, __TEXT("Winmgmt: Bad Untyped Value pointer in m_Defaults!" ));
                    return WBEM_E_FAILED;
                }

            }   // IF is Pointer

        }   // IF not NULL or default

        // Now check the qualifier set.
        CBasicQualifierSet  qsProp;

        qsProp.SetData( pInfo->GetQualifierSetData(), &m_Heap );
        hres = qsProp.IsValidQualifierSet();

        if ( FAILED( hres ) )
        {
            return hres;
        }

    }   // FOR iterate properties

    return WBEM_S_NO_ERROR;

}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

length_t CClassAndMethods::GetMinLength()
{
    return CClassPart::GetMinLength() + CMethodPart::GetMinLength();
}

void CClassAndMethods::SetData(LPMEMORY pStart, CWbemClass* pClass,
                CClassAndMethods* pParent)
{
    m_pClass = pClass;
    m_ClassPart.SetData(pStart, this,
        (pParent ? &pParent->m_ClassPart : NULL));

    m_MethodPart.SetData(EndOf(m_ClassPart), this,
        (pParent ? &pParent->m_MethodPart : NULL));
}

size_t CClassAndMethods::ValidateBuffer(LPMEMORY start, size_t cbSize) 
{
	
	size_t step = CClassPart::ValidateBuffer(start, cbSize);
	step += CMethodPart::ValidateBuffer(start+step, cbSize-step);
	return step;
};

void CClassAndMethods::SetDataWithNumProps(LPMEMORY pStart, 
							CWbemClass* pClass,
							DWORD dwNumProperties, 
							CClassAndMethods* pParent)
{
    m_pClass = pClass;

    // Initialize the class part with the total number of properties
    // so we will be able to access default values
    m_ClassPart.SetDataWithNumProps(pStart,this, dwNumProperties,
        (pParent ? &pParent->m_ClassPart : NULL));

    m_MethodPart.SetData(EndOf(m_ClassPart), this,
        (pParent ? &pParent->m_MethodPart : NULL));
}

void CClassAndMethods::Rebase(LPMEMORY pStart)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    int nOffset = (int) ( m_MethodPart.GetStart() - m_ClassPart.GetStart() );

    m_ClassPart.Rebase(pStart);
    m_MethodPart.Rebase(pStart + nOffset);
}

LPMEMORY CClassAndMethods::CreateEmpty(LPMEMORY pStart)
{
    LPMEMORY pCurrent = CClassPart::CreateEmpty(pStart);
    return CMethodPart::CreateEmpty(pCurrent);
}

length_t CClassAndMethods::EstimateDerivedPartSpace()
{
    return m_ClassPart.EstimateDerivedPartSpace() +
            m_MethodPart.EstimateDerivedPartSpace();
}

LPMEMORY CClassAndMethods::CreateDerivedPart(LPMEMORY pStart,
                                            length_t nAllocatedLength)
{
    LPMEMORY pCurrent = m_ClassPart.CreateDerivedPart(pStart,
        nAllocatedLength - m_MethodPart.EstimateDerivedPartSpace());

    // Check for allocation failure
    if ( NULL == pCurrent )
    {
        return NULL;
    }

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pStart + nAllocatedLength) - pStart).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    return m_MethodPart.CreateDerivedPart(pCurrent,
                                        (length_t) ( (pStart + nAllocatedLength) - pCurrent ) );
}

length_t CClassAndMethods::EstimateUnmergeSpace()
{
    return m_ClassPart.EstimateUnmergeSpace() +
            m_MethodPart.EstimateUnmergeSpace();
}

LPMEMORY CClassAndMethods::Unmerge(LPMEMORY pStart, length_t nAllocatedLength)
{
    LPMEMORY pCurrent = m_ClassPart.Unmerge(pStart,
        nAllocatedLength - m_MethodPart.EstimateUnmergeSpace());

    // Check for allocation failures
    if ( NULL == pCurrent )
    {
        return NULL;
    }

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value ( pStart + nAllocatedLength) - pStart).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    return m_MethodPart.Unmerge(pCurrent,
                                (length_t) ( (pStart + nAllocatedLength) - pCurrent) );
}

length_t CClassAndMethods::EstimateMergeSpace(CClassAndMethods& ParentPart,
                                   CClassAndMethods& ChildPart)
{
    return CClassPart::EstimateMergeSpace(ParentPart.m_ClassPart,
                                            ChildPart.m_ClassPart) +
           CMethodPart::EstimateMergeSpace(ParentPart.m_MethodPart,
                                            ChildPart.m_MethodPart);
}

LPMEMORY CClassAndMethods::Merge(CClassAndMethods& ParentPart,
                      CClassAndMethods& ChildPart,
                      LPMEMORY pDest, int nAllocatedLength)
{
    int nMethodEstimate = CMethodPart::EstimateMergeSpace(
                        ParentPart.m_MethodPart, ChildPart.m_MethodPart);

    LPMEMORY pCurrent = CClassPart::Merge(ParentPart.m_ClassPart,
                        ChildPart.m_ClassPart, pDest,
                        nAllocatedLength - nMethodEstimate);

    // Check for memory allocation failures
    if ( NULL == pCurrent )
    {
        return NULL;
    }

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pDest + nAllocatedLength) - pCurrent.
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    return CMethodPart::Merge(ParentPart.m_MethodPart, ChildPart.m_MethodPart,
                        pCurrent, (length_t) ( (pDest + nAllocatedLength) - pCurrent ) );
}

HRESULT CClassAndMethods::Update(CClassAndMethods& ParentPart,
                      CClassAndMethods& ChildPart, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Update the class part first
    hr =  CClassPart::Update( ParentPart.m_ClassPart, ChildPart.m_ClassPart, lFlags );

    // Successfully updated the class part, so update the method part
    if ( SUCCEEDED( hr ) )
    {
        hr = CMethodPart::Update( ParentPart.m_MethodPart, ChildPart.m_MethodPart, lFlags );
    }

    return hr;
}

EReconciliation CClassAndMethods::CanBeReconciledWith(
                                            CClassAndMethods& NewPart)
{
    EReconciliation eRes = m_ClassPart.CanBeReconciledWith(NewPart.m_ClassPart);
    if(eRes != e_Reconcilable)
        return eRes;
    return m_MethodPart.CanBeReconciledWith(NewPart.m_MethodPart);
}

EReconciliation CClassAndMethods::ReconcileWith(CClassAndMethods& NewPart)
{
    EReconciliation eRes = m_ClassPart.ReconcileWith(NewPart.m_ClassPart);
    if(eRes != e_Reconcilable)
        return eRes;
    return m_MethodPart.ReconcileWith(NewPart.m_MethodPart);
}

EReconciliation CClassAndMethods::CompareTo( CClassAndMethods& thatPart )
{
    EReconciliation eRes = m_ClassPart.CompareExactMatch( thatPart.m_ClassPart );
    if(eRes != e_ExactMatch)
        return eRes;
    return m_MethodPart.CompareExactMatch(thatPart.m_MethodPart);
}

void CClassAndMethods::Compact()
{
    m_ClassPart.Compact();
    m_MethodPart.Compact();
    MoveBlock(m_MethodPart, EndOf(m_ClassPart));
}

BOOL CClassAndMethods::ExtendClassPartSpace(CClassPart* pPart,
                                            length_t nNewLength)
{
    Compact();

    // No need to extend
    if(nNewLength <=
        (length_t)(m_MethodPart.GetStart() - m_ClassPart.GetStart()))
    {
        return TRUE;
    }

    BOOL    fReturn = m_pClass->ExtendClassAndMethodsSpace(nNewLength + m_MethodPart.GetLength());

    if ( fReturn )
    {
        MoveBlock(m_MethodPart, m_ClassPart.GetStart() + nNewLength);
    }

    return fReturn;
}

BOOL CClassAndMethods::ExtendMethodPartSpace(CMethodPart* pPart,
                                                length_t nNewLength)
{
    Compact();
    return m_pClass->ExtendClassAndMethodsSpace(nNewLength + m_ClassPart.GetLength());
}

IUnknown* CClassAndMethods::GetWbemObjectUnknown()
{
    return m_pClass->GetWbemObjectUnknown();
}

classindex_t CClassAndMethods::GetCurrentOrigin()
{
    return m_pClass->GetCurrentOrigin();
}

LPMEMORY CClassAndMethods::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys)
{

    LPMEMORY    pCurrent = pDest,
                pEnd = pCurrent + nAllocatedSize;

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pEnd - pCurrent).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    // Create a Limited representation of our class part, and if
    // that is successful then do the same for our method part
    pCurrent = m_ClassPart.CreateLimitedRepresentation(pMap,
                    (length_t) ( pEnd - pCurrent ), pCurrent, bRemovedKeys);

    if ( pCurrent != NULL )
    {
        // For now, just copy the method block.  We'll worry about creating an
        // actual limited representation, or remove them altogether at a later time.

        // Ensure we will have enough memory to do this

        if ( m_MethodPart.GetLength() <= (length_t) ( pEnd - pCurrent ) )
        {
            MoveMemory( pCurrent, m_MethodPart.GetStart(), m_MethodPart.GetLength() );
            // Add to pCurrent, accounting for the method part
            pCurrent += m_MethodPart.GetLength();
        }
        else
        {
            pCurrent = NULL;
        }

    }

    return pCurrent;
}

BOOL CClassAndMethods::GetIndexedProps( CWStringArray& awsNames, LPMEMORY pStart )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    // Create a temporary stack object on the BLOB and, then ask the class part
    // for indexed properties

    CClassAndMethods    tempClassAndMethods;
    tempClassAndMethods.SetData( pStart, NULL, NULL );

    return tempClassAndMethods.m_ClassPart.GetIndexedProps( awsNames );
}

HRESULT CClassAndMethods::GetClassName( WString& wsClassName, LPMEMORY pStart )
{
    // Check for out of memory
    try
    {
        // Create a temporary stack object on the BLOB and, then ask the class part
        // for class name

        CClassAndMethods    tempClassAndMethods;
        tempClassAndMethods.SetData( pStart, NULL, NULL );

        CVar    var;
        HRESULT hr = tempClassAndMethods.m_ClassPart.GetClassName( &var );

        if ( SUCCEEDED( hr ) )
        {
            wsClassName = (LPCWSTR) var;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CClassAndMethods::GetSuperclassName( WString& wsSuperclassName, LPMEMORY pStart )
{
    // Check for out of memory
    try
    {
        // Create a temporary stack object on the BLOB and, then ask the class part
        // for class name

        CClassAndMethods    tempClassAndMethods;
        tempClassAndMethods.SetData( pStart, NULL, NULL );

        CVar    var;
        HRESULT hr = tempClassAndMethods.m_ClassPart.GetSuperclassName( &var );

        if ( SUCCEEDED( hr ) )
        {
            if ( !var.IsNull() )
            {
                wsSuperclassName = (LPCWSTR) var;
            }
            else
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Destructor
CWbemClass::~CWbemClass( void )
{
    // Cleanup any allocated memory
    if ( NULL != m_pLimitMapping )
    {
        delete m_pLimitMapping;
    }
}

size_t CWbemClass::ValidateBuffer(LPMEMORY start, size_t cbMax)
 {
	
    int leftLength = cbMax;
	int step =  0;
    step = CDecorationPart::ValidateBuffer(start+step, cbMax-step);
    step += CClassAndMethods::ValidateBuffer(start+step, cbMax-step);
    step += CClassAndMethods::ValidateBuffer(start+step, cbMax-step);
    return step;
 };

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetPropQualifier(CPropertyInformation* pInfo,
                                    LPCWSTR wszQualifier,
                                    CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    return m_CombinedPart.m_ClassPart.GetPropQualifier(pInfo, wszQualifier,
                pVar, plFlavor, pct);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CWbemClass::ExtendClassAndMethodsSpace(length_t nNewLength)
{
    // (can only happen for m_CombinedPart --- m_ParentPart is read-only)

    // Check if there is enough space
    // ==============================

    if(GetStart() + m_nTotalLength >= m_CombinedPart.GetStart() + nNewLength)
        return TRUE;

    // Reallocate
    // ==========

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    int nNewTotalLength = (int) ( (m_CombinedPart.GetStart() + nNewLength) - GetStart() );

    LPMEMORY pNew = Reallocate(nNewTotalLength);

    // Make sure the memory allocation didn't fail
    if ( NULL != pNew )
    {
        Rebase(pNew);
        m_nTotalLength = nNewTotalLength;
    }

    return ( NULL != pNew );
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::WriteDerivedClass(LPMEMORY pStart, int nAllocatedLength,
                                    CDecorationPart* pDecoration)
{
    // Copy the decoration
    // ===================

    LPMEMORY pCurrentEnd;
    if(pDecoration)
    {
        memcpy(pStart, pDecoration, pDecoration->GetLength());
        *(BYTE*)pStart = OBJECT_FLAG_CLASS & OBJECT_FLAG_DECORATED;
        pCurrentEnd = pStart + pDecoration->GetLength();
    }
    else
    {
        *(BYTE*)pStart = OBJECT_FLAG_CLASS;
        pCurrentEnd = pStart + sizeof(BYTE);
    }

    // Copy the parent part
    // ====================

    memcpy(pCurrentEnd, m_CombinedPart.GetStart(), m_CombinedPart.GetLength());
    pCurrentEnd += m_CombinedPart.GetLength();

    // Create derived class part
    // =========================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (nAllocatedLength - (pCurrentEnd - pStart).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    pCurrentEnd = m_CombinedPart.CreateDerivedPart(pCurrentEnd,
        (length_t) ( nAllocatedLength - (pCurrentEnd - pStart) ) );

    if ( NULL == pCurrentEnd )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        return WBEM_NO_ERROR;
    }
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

HRESULT CWbemClass::Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace)
{
    CompactAll();

    Undecorate();

    // Check if there is enough space
    // ==============================

    length_t nDecorationSpace =
        CDecorationPart::ComputeNecessarySpace(wszServer, wszNamespace);

    length_t nNeededSpace =  nDecorationSpace +
        m_ParentPart.GetLength() + m_CombinedPart.GetLength();

    LPMEMORY pDest;
    if(nNeededSpace > m_nTotalLength)
    {
        m_CombinedPart.Compact();

        // Check that this succeeded.  If not, return an error
        pDest = Reallocate(nNeededSpace);

        if ( NULL == pDest )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        Rebase(pDest);
        m_nTotalLength = nNeededSpace;
    }
    else pDest = GetStart();

    // Move combined part
    // ==================

    MoveBlock(m_CombinedPart,
        pDest + nDecorationSpace + m_ParentPart.GetLength());

    // Move parent part
    // ================

    MoveBlock(m_ParentPart, pDest + nDecorationSpace);

    // Create decoration part
    // ======================

    m_DecorationPart.Create(OBJECT_FLAG_CLASS, wszServer, wszNamespace, pDest);

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
void CWbemClass::Undecorate()
{
    if(!m_DecorationPart.IsDecorated())
        return;
    // Create empty decoration
    // ========================

    LPMEMORY pStart = GetStart();
    m_DecorationPart.CreateEmpty(OBJECT_FLAG_CLASS, pStart);

    // Copy parent part back
    // =====================

    MoveBlock(m_ParentPart, EndOf(m_DecorationPart));

    // Copy combinedPart back
    // ======================

    MoveBlock(m_CombinedPart, EndOf(m_ParentPart));
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

LPWSTR CWbemClass::GetRelPath( BOOL bNormalized )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    if ( bNormalized == TRUE )
    {
        return NULL;
    }

    if(m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName ==
                                                        INVALID_HEAP_ADDRESS)
        return NULL;

    // Start with the class name
    // =========================

    return m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
        m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName)->
            CreateWStringCopy().UnbindPtr();
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

BOOL CWbemClass::MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap)
{
    // Get the decoration part to map its info
    // =======================================

    if(!CDecorationPart::MapLimitation(pwsNames, pMap)) return FALSE;

    // Get the combined part to do most of the work
    // ============================================

    if ( !m_CombinedPart.m_ClassPart.MapLimitation(lFlags, pwsNames, pMap) )
    {
        return FALSE;
    }
#ifdef DEBUG_CLASS_MAPPINGS
    // Finally, store 'this' class in the limitation mapping so we can verify that
    // instances that get passed through are kosher.

    pMap->SetClassObject( this );
#endif
    return TRUE;
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::GetQualifierSet(IWbemQualifierSet** ppQualifierSet)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        // This function doesn't cause any allocations so so need to perform out of memory
        // exception handling.

        if(ppQualifierSet == NULL)
            return WBEM_E_INVALID_PARAMETER;

        return m_CombinedPart.m_ClassPart.m_Qualifiers.QueryInterface(
            IID_IWbemQualifierSet, (void**)ppQualifierSet);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                            CIMTYPE ctType)
{
    // Check for out of memory
    try
    {
        CLock lock(this);

        if(wszName == NULL || 0L != ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
            return WBEM_E_INVALID_PARAMETER;

        // Check that the name is not a reserved word
        if ( CReservedWordTable::IsReservedWord( wszName ) )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        if((pVal == NULL || V_VT(pVal) == VT_NULL) && ctType == 0)
        {
            CVar    vTemp;
            // The above cases are only a failure if the property does not exist
            // If the property exists, this will clear the property without
            // changing the type.

            HRESULT hr = GetProperty(wszName, &vTemp );
            if( FAILED(hr) ) return WBEM_E_INVALID_PARAMETER;
        }

        if(CType::GetActualType(ctType) != (Type_t) ctType)
            return WBEM_E_INVALID_PROPERTY_TYPE;

        if ( wbem_wcsicmp(wszName, L"__CLASS") )
        {
            if ( CSystemProperties::FindName(wszName) >= 0)
                return WBEM_E_READ_ONLY;

            // The property name MUST be a valid element name (note that
            // this will preclude all of our new system properties).
            if ( !IsValidElementName( wszName, g_IdentifierLimit ) )
            {
                return WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            // Make sure there are no bad characters
            // We must allow underscores, though.

            if ((NULL == pVal) || (!IsValidElementName2(pVal->bstrVal, g_IdentifierLimit, TRUE)))
                return WBEM_E_INVALID_PARAMETER;
        }

        CVar Var;
        if(Var.SetVariant(pVal, TRUE) != CVar::no_error)
            return WBEM_E_TYPE_MISMATCH;

        HRESULT hres = SetPropValue(wszName, &Var, ctType);
        EndEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
        {
            hres = WBEM_E_FAILED;
        }

        return hres;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::ForcePut(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
    // Check for out of memory
    try
    {
        // This will force a property in.
        CLock lock(this);

        CVar Var;
        if(Var.SetVariant(pVal, TRUE) != CVar::no_error)
            return WBEM_E_TYPE_MISMATCH;

        HRESULT hres = ForcePropValue(wszName, &Var, ctType);
        EndEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
        {
            hres = WBEM_E_FAILED;
        }

        return hres;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::Delete(LPCWSTR wszName)
{
    // Check for out of memory.  The CopyParentProperty function could potentially cause
    // buffer reallocations to occur, so there is a chance we could hit an unhandled OOM,
    // but I strongly doubt it.

    try
    {
        CLock lock(this);

        if(wszName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Find the property
        // =================

        CPropertyInformation* pInfo = m_CombinedPart.m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL)
        {
            if(CSystemProperties::FindName(wszName) >= 0)
                return WBEM_E_SYSTEM_PROPERTY;
            else
                return WBEM_E_NOT_FOUND;
        }

        // Check if it is ours or parent's
        // ===============================

        EndEnumeration();

        if(!CType::IsParents(pInfo->nType))
        {
            m_CombinedPart.m_ClassPart.DeleteProperty(wszName);

            // Perform object validation here
            if ( FAILED( ValidateObject( 0L ) ) )
            {
                return WBEM_E_FAILED;
            }

            return WBEM_NO_ERROR;
        }
        else
        {
            // It is our parent's. Deleting it means simply that we remove all
            // overriden qualifiers and reset the value to the default
            // ===============================================================

            m_CombinedPart.m_ClassPart.CopyParentProperty(m_ParentPart.m_ClassPart,
                                                            wszName);

            // Perform object validation here
            if ( FAILED( ValidateObject( 0L ) ) )
            {
                return WBEM_E_FAILED;
            }

            return WBEM_S_RESET_TO_DEFAULT;
        }
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** ppQualifierSet)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszProperty == NULL || wcslen(wszProperty) == 0)
            return WBEM_E_INVALID_PARAMETER;

        if(wszProperty[0] == L'_')
            return WBEM_E_SYSTEM_PROPERTY;

        CClassPropertyQualifierSet* pSet = new CClassPropertyQualifierSet;

        if ( NULL == pSet )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        HRESULT hres = m_CombinedPart.m_ClassPart.InitPropertyQualifierSet(wszProperty,
                                                                pSet);
        if(FAILED(hres))
        {
            delete pSet;
            *ppQualifierSet = NULL;
            return hres;
        }
        return pSet->QueryInterface(IID_IWbemQualifierSet,
                                    (void**)ppQualifierSet);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::Clone(IWbemClassObject** ppCopy)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppCopy == NULL)
            return WBEM_E_INVALID_PARAMETER;
        m_CombinedPart.Compact();

        CWbemClass* pNewClass = new CWbemClass;
        if ( NULL == pNewClass ) return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1((_IWmiObject*)pNewClass);
        
        LPMEMORY pNewData = m_pBlobControl->Allocate(m_nTotalLength);
        if ( NULL == pNewData )  return WBEM_E_OUT_OF_MEMORY;

        memcpy(pNewData, GetStart(), m_nTotalLength);
                
        // There is a WString underneath this in a method part, so an exception
        // could get thrown here.  However, data buffer pointers will have been set
        // in the class by the time we get to the exception, so deleting
        // the class will effectively free the memory (yes it's a subtle behavior).

        pNewClass->SetData(pNewData, m_nTotalLength);
        pNewClass->CompactAll();
        return pNewClass->QueryInterface(IID_IWbemClassObject, (void**)ppCopy);
        
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

STDMETHODIMP CWbemClass::CloneAndDecorate(long lFlags,
	                                                                  WCHAR * pszServer,
	                                                                  WCHAR * pszNamespace,
	                                                                  IWbemClassObject ** ppDestObject)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);
        if(ppDestObject == NULL  || NULL == pszServer|| NULL == pszNamespace)
            return WBEM_E_INVALID_PARAMETER;
        
        m_CombinedPart.Compact();

        CWbemClass * pNewClass = new CWbemClass;
        if ( NULL == pNewClass ) return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe rm_((IWbemClassObject *)pNewClass);        
      
        BOOL IsAsciableSrv;
        long nByteServer  = CCompressedString::ComputeNecessarySpace(pszServer,IsAsciableSrv);
        BOOL IsAsciableNS;
        long nByteNamespace  = CCompressedString::ComputeNecessarySpace(pszNamespace,IsAsciableNS);        

        long nDecorationSpace = sizeof(BYTE) + nByteServer + nByteNamespace;
        long TotalLen = m_nTotalLength + nDecorationSpace - m_DecorationPart.GetLength();
        
        LPMEMORY pNewData = m_pBlobControl->Allocate(TotalLen);        
        if ( NULL == pNewData ) return WBEM_E_OUT_OF_MEMORY;
        LPMEMORY pStartHere = pNewData;

        LPMEMORY pStartNonDecorData = pNewData + nDecorationSpace;

        memcpy(pNewData, GetStart(),1);
        pNewData[0] |= OBJECT_FLAG_DECORATED;
        pNewData++;
        ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableSrv,pszServer);
        pNewData+=nByteServer;
        ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableNS,pszNamespace);
        	
        memcpy(pStartNonDecorData, GetStart()+m_DecorationPart.GetLength(), m_nTotalLength-m_DecorationPart.GetLength());

        // There is a WString underneath this in a method part, so an exception
        // could get thrown here.  However, data buffer pointers will have been set
        // in the class by the time we get to the exception, so deleting
        // the class will effectively free the memory (yes it's a subtle behavior).

        pNewClass->SetData(pStartHere, TotalLen);
        pNewClass->CompactAll();
        
        return pNewClass->QueryInterface(IID_IWbemClassObject, (void**)ppDestObject);        

    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::SpawnInstance(long lFlags,
                                      IWbemClassObject** ppNewInstance)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppNewInstance == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        *ppNewInstance = NULL;

        m_CombinedPart.Compact();

        HRESULT hr;
        CWbemInstance* pNewInstance = new CWbemInstance;
        if ( NULL == pNewInstance ) return  WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1((_IWmiObject*)pNewInstance);

        // Cleanup if initialization failed
        if( FAILED( hr = pNewInstance->InitNew(this)) )  return hr;

        if(!m_DecorationPart.IsDecorated())
        {
            pNewInstance->SetClientOnly();
        }
        
        hr = pNewInstance->QueryInterface(IID_IWbemClassObject,(void**)ppNewInstance);
        
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::SpawnDerivedClass(long lFlags,
                                          IWbemClassObject** ppNewClass)
{
    // The functions underneath us will handle any OOM exceptions, so no need for us
    // to do any exception handling at this level.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppNewClass == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(!m_DecorationPart.IsDecorated())
        {
            *ppNewClass = NULL;
            return WBEM_E_INCOMPLETE_CLASS;
        }
       
        CWbemClass* pNewClass = NULL;

        // Use the helper function to actually spawn the class
        HRESULT hr = CreateDerivedClass( &pNewClass );

        if ( SUCCEEDED( hr ) )
        {
            if ( SUCCEEDED( hr ) )
            {
                // This set the refcount on the object to 0 and do a QI
                hr = pNewClass->QueryInterface(IID_IWbemClassObject,
                                                (void**)ppNewClass);
                pNewClass->Release();
            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::CreateDerivedClass( CWbemClass** ppNewClass )
{
    

    try
    {
        HRESULT hr;

        // Allocate a memory block, write a derived class into the block,
        // then allocate a class object, sit it on the new blob and send that
        // back.

        m_CombinedPart.Compact();

        CWbemClass* pNewClass = new CWbemClass;
        if ( NULL == pNewClass ) return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1((_IWmiObject*)pNewClass);
        
        int nLength = EstimateDerivedClassSpace();

        LPMEMORY pNewData = m_pBlobControl->Allocate(nLength);
        if ( NULL == pNewData ) return WBEM_E_OUT_OF_MEMORY;
        OnDeleteObjIf<LPMEMORY,CBlobControl,
                              void(CBlobControl::*)(LPMEMORY),
                              &CBlobControl::Delete> relMe(m_pBlobControl,pNewData);

        memset(pNewData, 0, nLength);
        hr = WriteDerivedClass(pNewData, nLength, NULL);

        if (FAILED(hr)) return hr;

        relMe.dismiss();
        pNewClass->SetData(pNewData, nLength);

        pNewClass->AddRef();
        *ppNewClass = pNewClass;
        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::GetObjectText(long lFlags, BSTR* pstrText)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pstrText == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if((lFlags & ~WBEM_FLAG_NO_SEPARATOR & ~WBEM_FLAG_NO_FLAVORS) != 0)
            return WBEM_E_INVALID_PARAMETER;

        *pstrText = NULL;

        WString wsText;

        // start by writing the qualifiers
        // ===============================

        HRESULT    hres = m_CombinedPart.m_ClassPart.m_Qualifiers.GetText(lFlags, wsText);

        if ( FAILED( hres ) )
        {
            return hres;
        }

        // append the class header
        // =======================

        wsText += L"\nclass ";
        CVar varClass;
        if(FAILED(m_CombinedPart.m_ClassPart.GetClassName(&varClass)) ||
            varClass.IsNull())
        {
            // invalid class
            // =============
            *pstrText = NULL;
            return WBEM_E_INCOMPLETE_CLASS;
        }
        wsText += varClass.GetLPWSTR();

        // append derivation information
        // =============================

        CVar varSuper;
        if(SUCCEEDED(m_CombinedPart.m_ClassPart.GetSuperclassName(&varSuper)) &&
            !varSuper.IsNull())
        {
            wsText += L" : ";
            wsText += varSuper.GetLPWSTR();
        }

        wsText += L"\n{\n";

        // Go through all properties one by one
        // ====================================

        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;
        for(int i = 0; i < Properties.GetNumProperties(); i++)
        {
            // Search for the property with this data index
            // ============================================

            CPropertyLookup* pLookup = NULL;
            CPropertyInformation* pInfo = NULL;
            for(int j = 0; j < Properties.GetNumProperties(); j++)
            {
                pLookup = Properties.GetAt(j);
                pInfo = pLookup->GetInformation(&m_CombinedPart.m_ClassPart.m_Heap);

                if(pInfo->nDataIndex == i)
                    break;
            }

            // Check if it is overriden, or simply inherited from the parent
            // =============================================================

            if(pInfo->IsOverriden(&m_CombinedPart.m_ClassPart.m_Defaults))
            {
                // We will ignore apparent system properties
                if ( !GetClassPart()->GetHeap()->ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
                {
                    wsText += L"\t";
                    hres = AddPropertyText(wsText, pLookup, pInfo, lFlags);
                    wsText += L";\n";
                    if(FAILED(hres)) return hres;
                }
            }
        }

        // Append method information
        // =========================

        hres = m_CombinedPart.m_MethodPart.AddText(wsText, lFlags);

        if ( FAILED( hres ) )
        {
            return hres;
        }

        // finish the class
        // ================

        wsText += L"}";

        if((lFlags & WBEM_FLAG_NO_SEPARATOR) == 0)
        {
            wsText += L";\n";
        }

        *pstrText = COleAuto::_SysAllocString((LPCWSTR)wsText);
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::AddPropertyText(WString& wsText, CPropertyLookup* pLookup,
                                    CPropertyInformation* pInfo, long lFlags)
{
    // Check for out of memory
    try
    {
        // start with qualifiers
        // =====================
        WString wsTemp;
        HRESULT    hr = CBasicQualifierSet::GetText(pInfo->GetQualifierSetData(),
                    &m_CombinedPart.m_ClassPart.m_Heap, lFlags, wsTemp);

        if ( FAILED( hr ) )
        {
            return hr;
        }
        wsText += wsTemp;
        if(wsTemp.Length() != 0) wsText += L" ";

        // continue with the type
        // ======================

        CQualifier* pSyntaxQual = CBasicQualifierSet::GetQualifierLocally(
            pInfo->GetQualifierSetData(), &m_CombinedPart.m_ClassPart.m_Heap,
            TYPEQUAL);
        if(pSyntaxQual)
        {
            CVar varSyntax;

            // Check for possible allocation failures
            if ( !pSyntaxQual->Value.StoreToCVar(varSyntax,
                                                &m_CombinedPart.m_ClassPart.m_Heap) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            if(varSyntax.GetType() != VT_BSTR)
            {
                return WBEM_E_INVALID_CIM_TYPE;
            }

            LPWSTR wszSyntax = varSyntax.GetLPWSTR();
            CType::AddPropertyType(wsText, wszSyntax);
        }
        else
        {
            wsText += L"invalid";
        }
        wsText += L" ";

        // continue with the name
        // ======================

        wsText += m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
            pLookup->ptrName)->CreateWStringCopy();

        if(CType::IsArray(pInfo->nType))
        {
            wsText += L"[]";
        }

        // only specify the default value if it is not the same as parent's
        // ================================================================
        CDataTable& Defaults = m_CombinedPart.m_ClassPart.m_Defaults;
        if(!Defaults.IsDefault(pInfo->nDataIndex))
        {
            // Check if it is local and NULL
            // =============================
            if(CType::IsParents(pInfo->nType) ||!Defaults.IsNull(pInfo->nDataIndex))
            {
                wsText += L" = ";
                if(Defaults.IsNull(pInfo->nDataIndex))
                {
                    wsText += L"NULL";
                }
                else
                {
                    CVar varProp;

                    // Check for allocation failures
                    if ( !Defaults.GetOffset(pInfo->nDataOffset)
                            ->StoreToCVar(CType::GetActualType(pInfo->nType),
                                          varProp,
                                          &m_CombinedPart.m_ClassPart.m_Heap) )
                    {
                        return WBEM_E_OUT_OF_MEMORY;
                    }

                    // Get rid of any flags we may have munged in during
                    // method parameter evaluation.

                    LPWSTR wsz = GetValueText(lFlags & ~( WBEM_FLAG_IGNORE_IDS | WBEM_FLAG_IS_INOUT ),
                                    varProp,
                                    CType::GetActualType(pInfo->nType));

                    // We need to special case this one clean up wsz
                    try
                    {
                        if ( NULL != wsz )
                        {
                            wsText += wsz;
                            delete [] wsz;
                        }
                    }
                    catch (CX_MemoryException)
                    {
                        delete [] wsz;
                        return WBEM_E_OUT_OF_MEMORY;
                    }
                    catch (...)
                    {
                        delete [] wsz;
                        return WBEM_E_FAILED;
                    }

                }
            }
        }

        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::EnsureQualifier(LPCWSTR wszQual)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and changed to return an HRESULT

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        CVar vTrue(VARIANT_TRUE, VT_BOOL);
        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;
        for(int i = 0; SUCCEEDED( hr ) && i < Properties.GetNumProperties(); i++)
        {
            WString wsPropName =
                m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
                               Properties.GetAt(i)->ptrName)->CreateWStringCopy();

            hr = SetPropQualifier(wsPropName, wszQual, 0, &vTrue);
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::WritePropertyAsMethodParam(WString& wsText, int nIndex,
                    long lFlags, CWbemClass* pDuplicateParamSet, BOOL fIgnoreDups )
{

    // Check for out of memory
    try
    {
        HRESULT hres;

        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;
        for(int i = 0; i < Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = NULL;
            CPropertyInformation* pInfo = NULL;

            pLookup = Properties.GetAt(i);
            pInfo = pLookup->GetInformation(&m_CombinedPart.m_ClassPart.m_Heap);

            WString wsPropName = m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
                                    pLookup->ptrName)->CreateWStringCopy();
            if(wsPropName.EqualNoCase(L"ReturnValue"))
                continue;

            // Store the flags as we will be modifying them as necessary
            // e.g. IGNORE_IDS and IS_INOUT
            long lParamFlags = lFlags | WBEM_FLAG_IGNORE_IDS;

            // If we have a duplicate parameter set to check, look for the same property name
            // in the duplicate paramater set.  If it succeeds, the parameter is an [in,out]
            // parameter.  The assumption we make here is that this object and the duplicate
            // set have been validated for dupliate parameters.  If fIgnoreDuplicates is set
            // then we should just ignore the parameter, and get on with our lives.

            if ( NULL != pDuplicateParamSet )
            {
                CVar    vTemp;
                if ( SUCCEEDED( pDuplicateParamSet->GetProperty( wsPropName, &vTemp ) ) )
                {
                    if ( fIgnoreDups )
                    {
                        continue;
                    }
                    else
                    {
                        lParamFlags |= WBEM_FLAG_IS_INOUT;
                    }
                }
            }

            // Check its ID qualifier
            // ======================

            CVar vId;
            hres = GetPropQualifier(wsPropName, L"id", &vId);
            if(FAILED(hres))
                return WBEM_E_MISSING_PARAMETER_ID;
            if(vId.GetType() != VT_I4)
                return WBEM_E_INVALID_PARAMETER_ID;
            if(vId.GetLong() == nIndex)
            {
                return AddPropertyText(wsText, pLookup, pInfo, lParamFlags );
            }
        }

        return WBEM_E_NOT_FOUND;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::GetIds(CFlexArray& adwIds, CWbemClass* pDupParams /* = NULL */ )
{

    // Check for out of memory
    try
    {
        HRESULT hres;
        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;

        for(int i = 0; i < Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = NULL;
            CPropertyInformation* pInfo = NULL;
            pLookup = Properties.GetAt(i);
            pInfo = pLookup->GetInformation(&m_CombinedPart.m_ClassPart.m_Heap);

            WString wsPropName = m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
                                    pLookup->ptrName)->CreateWStringCopy();
            if(wsPropName.EqualNoCase(L"ReturnValue"))
            {
                // Check that there is no ID qualifier
                // ===================================

                CVar vId;
                hres = GetPropQualifier(wsPropName, L"id", &vId);
                if(SUCCEEDED(hres))
                    return WBEM_E_PARAMETER_ID_ON_RETVAL;
            }
            // Don't do this if this appears to be a system property
            else if ( !CSystemProperties::IsPossibleSystemPropertyName( wsPropName ) )
            {
                // Check its ID qualifier
                // ======================

                CVar vId;
                hres = GetPropQualifier(wsPropName, L"id", &vId);
                if(FAILED(hres))
                    return WBEM_E_MISSING_PARAMETER_ID;
                if(vId.GetType() != VT_I4)
                    return WBEM_E_INVALID_PARAMETER_ID;
                if(vId.GetLong() < 0)
                    return WBEM_E_INVALID_PARAMETER_ID;

                // If the pDupParams parameter is non-NULL, try to get the property we
                // are working on from the pDupParams object.  If we get it, the property
                // is a dup (previously identified), so ignore it.  If pDupParams is NULL,
                // add all properties

                if ( NULL != pDupParams )
                {
                    // Destructor will empty this out
                    CVar    vTemp;

                    if ( FAILED( pDupParams->GetProperty( wsPropName, &vTemp ) ) )
                    {
                        // DEVNOTE:WIN64:SJS - Casting 32-bit value to 64-bit size.
                        if ( adwIds.Add((void*) (__int64) vId.GetLong()) != CFlexArray::no_error )
                        {
                            return WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    // DEVNOTE:WIN64:SJS - Casting 32-bit value to 64-bit size.

                    // Add all properties found, regardless
                    if ( adwIds.Add((void*) (__int64) vId.GetLong()) != CFlexArray::no_error )
                    {
                        return WBEM_E_OUT_OF_MEMORY;
                    }
                }

            }   // ELSE Property !ReturnValue

        }   // FOR enuming properties

        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


WString CWbemClass::FindLimitationError(IN long lFlags,
                                  IN CWStringArray* pwsNames)
{
    try
    {
        // Verify that all property names are either in the class or are system
        // ====================================================================

        for(int i = 0; i < pwsNames->Size(); i++)
        {
            LPCWSTR wszProp = pwsNames->GetAt(i);
            if(FAILED(GetPropertyType(wszProp, NULL, NULL)))
            {
                return wszProp;
            }
        }

        return L"";
    }
    catch (CX_MemoryException)
    {
        throw;
    }
    catch (...)
    {
        throw;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 LPMEMORY CWbemClass::CreateEmpty(LPMEMORY pStart)
{
    CDecorationPart DecPart;
    LPMEMORY pCurrent = DecPart.CreateEmpty(OBJECT_FLAG_CLASS, pStart);

    pCurrent = CClassAndMethods::CreateEmpty(pCurrent);
    pCurrent = CClassAndMethods::CreateEmpty(pCurrent);
    return pCurrent;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CWbemClass::SetData(LPMEMORY pStart, int nTotalLength)
{
    int LengthConsumed = nTotalLength;
    
    m_DecorationPart.SetData(pStart);
    if (m_DecorationPart.GetLength() > LengthConsumed) throw CX_Exception();
    LengthConsumed -= m_DecorationPart.GetLength();
    
    m_ParentPart.SetData(EndOf(m_DecorationPart), this, NULL);
    if (m_ParentPart.GetLength() > LengthConsumed) throw CX_Exception();
    LengthConsumed -= m_ParentPart.GetLength();
    
    m_CombinedPart.SetData(EndOf(m_ParentPart), this, &m_ParentPart);
    if (m_CombinedPart.GetLength() > LengthConsumed) throw CX_Exception();
    LengthConsumed -= m_CombinedPart.GetLength();    

    m_nTotalLength = nTotalLength;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CWbemClass::Rebase(LPMEMORY pMemory)
{
    m_DecorationPart.Rebase(pMemory);
    m_ParentPart.Rebase(EndOf(m_DecorationPart));
    m_CombinedPart.Rebase(EndOf(m_ParentPart));
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 length_t CWbemClass::EstimateDerivedClassSpace(
        CDecorationPart* pDecoration)
{
    return m_CombinedPart.GetLength() +
        m_CombinedPart.EstimateDerivedPartSpace() +
        ((pDecoration)?
                pDecoration->GetLength()
                :CDecorationPart::GetMinLength());
}


//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CWbemClass::InitEmpty( int nExtraMem/* = 0*/, BOOL fCreateSystemProps/* = TRUE*/ )
{
    HRESULT    hr = WBEM_S_NO_ERROR;
    
     // Throws an exception in OOM
    int nLength = GetMinLength();

    // Slip in 128 extra bytes for the new system properties
    if ( fCreateSystemProps )
    {
        nLength += 128;
    }

    LPMEMORY pMem = m_pBlobControl->Allocate(nLength + nExtraMem);

    if ( NULL != pMem )
    {
        memset(pMem, 0, nLength + nExtraMem);
        CreateEmpty(pMem);

        SetData(pMem, nLength + nExtraMem);

        // Add the three new system properties (we should allocate enough memory to cover them
        // as well).  We'll probably want to make a binary snapshot of this class and just set
        // it in order to speed things up.

    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 length_t CWbemClass::EstimateMergeSpace(LPMEMORY pChildPart,  long lenDecorPart)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    CClassAndMethods ChildPart;
    ChildPart.SetData(pChildPart, this);
    return m_CombinedPart.GetLength() +
        CClassAndMethods::EstimateMergeSpace(m_CombinedPart, ChildPart) + lenDecorPart;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

LPMEMORY CWbemClass::Merge(LPMEMORY pChildPart,
                                 LPMEMORY pDest, int nAllocatedLength,
                                 int DecorationSize)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    CClassAndMethods ChildPart;
    ChildPart.SetData(pChildPart, this);

    LPMEMORY pCurrentEnd;
    // Start with the decoration
    // =========================

    if(DecorationSize)
    {
        *pDest = (OBJECT_FLAG_CLASS | OBJECT_FLAG_DECORATED);
        pCurrentEnd = pDest + DecorationSize;
    }
    else
    {
        *pDest = OBJECT_FLAG_CLASS;
        pCurrentEnd = pDest + sizeof(BYTE);
    }

    // Copy our combined part as his parent part
    // =========================================

    memcpy(pCurrentEnd, m_CombinedPart.GetStart(), m_CombinedPart.GetLength());
    pCurrentEnd += m_CombinedPart.GetLength();

    // Merge our combined part with the child part for his combined part
    // =================================================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (nAllocatedLength - (pCurrentEnd - pDest).
    // We do not support length > 0xFFFFFFFF, so cast is ok.

    // This will return NULL if anything beefs
    pCurrentEnd = CClassAndMethods::Merge(m_CombinedPart, ChildPart,
        pCurrentEnd, (length_t) ( nAllocatedLength - (pCurrentEnd - pDest) ));

    return pCurrentEnd;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CWbemClass::Update( CWbemClass* pOldChild, long lFlags, CWbemClass** ppUpdatedChild )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        // Safe Mode or Force Mode MUST be specified.

        if (    WBEM_FLAG_UPDATE_SAFE_MODE == ( lFlags & WBEM_MASK_UPDATE_MODE )
            ||  WBEM_FLAG_UPDATE_FORCE_MODE == ( lFlags & WBEM_MASK_UPDATE_MODE ) )
        {

            // To get to "local" data for our child class, Unmerge into a BLOB

            int nChildUnmergeSpace = pOldChild->EstimateUnmergeSpace();
            LPBYTE  pbUnmergedChild = new BYTE[ALIGN_FASTOBJ_BLOB(nChildUnmergeSpace)];
            CVectorDeleteMe<BYTE> vdm( pbUnmergedChild );

            if ( NULL != pbUnmergedChild )
            {
                // Handle out of memory here
                hr = pOldChild->Unmerge( pbUnmergedChild, nChildUnmergeSpace, NULL );

                if ( SUCCEEDED( hr ) )
                {

                    CWbemClass* pNewClass;

                    // Spawn a derived class.  From there, we can walk the combined part of the
                    // child and try to write "local" information from the child combined part
                    // into the new class.  If we have no class name, then we should simply make
                    // a clone.  The child class is a base class which we will update

                    CVar    varClass;

                    GetClassName( &varClass );

                    if ( varClass.IsNull() )
                    {
                        hr = Clone( (IWbemClassObject**) &pNewClass );
                    }
                    else
                    {
                        hr = CreateDerivedClass( &pNewClass );
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        // Make sure we pass in dwNumProperties so we can initialize the class
                        // part's data table with the total number of properties and thereby
                        // correctly access the default values.

                        CClassAndMethods ChildPart;
                        ChildPart.SetDataWithNumProps( pbUnmergedChild, pOldChild,
                            pOldChild->m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties() );

                        hr = CClassAndMethods::Update( pNewClass->m_CombinedPart, ChildPart, lFlags );

                        if ( SUCCEEDED( hr ) )
                        {
                            *ppUpdatedChild = pNewClass;
                        }
                        else
                        {
                            // The following errors are indicative of conflicts in derived
                            // classes, so tweak the error code to be more descriptive.
                            switch ( hr )
                            {
                                case WBEM_E_TYPE_MISMATCH :            hr = WBEM_E_UPDATE_TYPE_MISMATCH;            break;
                                case WBEM_E_OVERRIDE_NOT_ALLOWED :    hr = WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED;    break;
                                case WBEM_E_PROPAGATED_METHOD :        hr = WBEM_E_UPDATE_PROPAGATED_METHOD;        break;
                            };

                            pNewClass->Release();
                        }

                    }   // IF CreateDerivedClass()

                }   // IF Unmerge()

            }   // if NULL != pbUnmergedChild
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

// We will throw exceptions in OOM scenarios
CWbemClass* CWbemClass::CreateFromBlob(CWbemClass* pParent,
                                       LPMEMORY pChildPart, 
                                       size_t cbSize)
{
    CWbemClass * pClass = new CWbemClass;
    if ( NULL == pClass ) throw CX_MemoryException();
    CReleaseMe _1((_IWmiObject*)pClass);
    
    CWbemClass LocalParent;
    if(pParent == NULL)
    {
        if ( FAILED(LocalParent.InitEmpty(0)))  throw CX_MemoryException();
        pParent = &LocalParent;
    }

    int nSpace =  pParent->EstimateMergeSpace(pChildPart,CDecorationPart::GetMinLength());

    LPMEMORY pNewMem = pClass->m_pBlobControl->Allocate(nSpace);
    if ( NULL == pNewMem ) throw CX_MemoryException();
    OnDeleteObjIf<LPMEMORY,CBlobControl,
                          void(CBlobControl::*)(LPMEMORY),
                          &CBlobControl::Delete> relMe(pClass->m_pBlobControl,pNewMem);

    memset(pNewMem, 0, nSpace);    

    // Check for allocation errors
    if (NULL == pParent->Merge(pChildPart, pNewMem, nSpace, NULL)) return NULL;

    // If an exception is thrown here, the decoration part should have
    // the BLOB, so deleting the class should free the BLOB.
    relMe.dismiss();
    pClass->SetData(pNewMem, nSpace);

    // Perform object validation here
    if (FAILED(pClass->ValidateObject(0L))) return NULL;

    pClass->AddRef();
    return pClass;
}

CWbemClass* CWbemClass::CreateFromBlob2(CWbemClass* pParent,
                                        LPMEMORY pChildPart,
                                        WCHAR * pszServer,
                                        WCHAR * pszNamespace)
{
    CWbemClass* pClass = new CWbemClass;
    if ( NULL == pClass ) throw CX_MemoryException();    
    CReleaseMe _1((_IWmiObject*)pClass);
    
    CWbemClass LocalParent;
    if(pParent == NULL)
    {
        if (FAILED(LocalParent.InitEmpty(0)))  throw CX_MemoryException();
        pParent = &LocalParent;
    }

    BOOL IsAsciableSrv;
    long nByteServer  = CCompressedString::ComputeNecessarySpace(pszServer,IsAsciableSrv);
    BOOL IsAsciableNS;
    long nByteNamespace  = CCompressedString::ComputeNecessarySpace(pszNamespace,IsAsciableNS);        

    long nDecorationSpace = CDecorationPart::GetMinLength() + nByteServer + nByteNamespace;

    int nSpace =  pParent->EstimateMergeSpace(pChildPart, nDecorationSpace );

    LPMEMORY pNewMem = pClass->m_pBlobControl->Allocate(nSpace);
    if ( NULL == pNewMem ) throw CX_MemoryException();
    OnDeleteObjIf<LPMEMORY,CBlobControl,
                          void(CBlobControl::*)(LPMEMORY),
                          &CBlobControl::Delete> relMe(pClass->m_pBlobControl,pNewMem);
    
    //memset(pNewMem, 0, nSpace);

    BYTE * pNewData = pNewMem;

    *pNewData = OBJECT_FLAG_DECORATED;
    pNewData++;
    ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableSrv,pszServer);
    pNewData+=nByteServer;
    ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableNS,pszNamespace);

    // Check for allocation errors
    if ( NULL == pParent->Merge(pChildPart, pNewMem, nSpace, nDecorationSpace)) return NULL;

    // If an exception is thrown here, the decoration part should have
    // the BLOB, so deleting the class should free the BLOB.
    relMe.dismiss();
    pClass->SetData(pNewMem, nSpace);

    // Perform object validation here
    if ( FAILED( pClass->ValidateObject( 0L ) ) ) return NULL;

    pClass->AddRef();
    return pClass;
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetProperty(LPCWSTR wszName, CVar* pVal)
{
    HRESULT hres = GetSystemPropertyByName(wszName, pVal);
    if(hres == WBEM_E_NOT_FOUND)
        return m_CombinedPart.m_ClassPart.GetDefaultValue(wszName, pVal);
    else
        return hres;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                    long* plFlavor)
{
    return m_CombinedPart.m_ClassPart.GetPropertyType(wszName, pctType, plFlavor);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                    long* plFlavor)
{
    return m_CombinedPart.m_ClassPart.GetPropertyType(pInfo, pctType, plFlavor);
}


HRESULT CWbemClass::SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType)
{
    if(!wbem_wcsicmp(wszName, L"__CLASS"))
        return m_CombinedPart.m_ClassPart.SetClassName(pVal);

    // If the value starts with an underscore see if it's a System Property
    // DisplayName, and if so, switch to a property name - otherwise, this
    // will just return the string we passed in
    
    if(!CUntypedValue::CheckCVar(*pVal, ctType))
        return WBEM_E_TYPE_MISMATCH;

    HRESULT hres = m_CombinedPart.m_ClassPart.EnsureProperty(wszName,
                        (VARTYPE) pVal->GetOleType(), ctType, FALSE);
    if(FAILED(hres)) return hres;
    return m_CombinedPart.m_ClassPart.SetDefaultValue(wszName, pVal);
}

HRESULT CWbemClass::ForcePropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType)
{
    if(!wbem_wcsicmp(wszName, L"__CLASS"))
        return m_CombinedPart.m_ClassPart.SetClassName(pVal);

    // If the value starts with an underscore see if it's a System Property
    // DisplayName, and if so, switch to a property name - otherwise, this
    // will just return the string we passed in

    if(!CUntypedValue::CheckCVar(*pVal, ctType))
        return WBEM_E_TYPE_MISMATCH;

    // Force the property into existence if at all possible
    HRESULT hres = m_CombinedPart.m_ClassPart.EnsureProperty(wszName,
                        (VARTYPE) pVal->GetOleType(), ctType, TRUE);
    if(FAILED(hres)) return hres;
    return m_CombinedPart.m_ClassPart.SetDefaultValue(wszName, pVal);
}

HRESULT CWbemClass::GetQualifier(LPCWSTR wszName, CVar* pVal,
                                    long* plFlavor, CIMTYPE* pct /*=NULL*/ )
{
    //  We may want to separate this later...however for now, we'll only get
    //  local values.

    return m_CombinedPart.m_ClassPart.GetClassQualifier(wszName, pVal, plFlavor, pct);
}

HRESULT CWbemClass::GetQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
                                 CFastHeap** ppHeap, BOOL fValidateSet )
{
    //  We may want to separate this later...however for now, we'll only get
    //  local values.

    return m_CombinedPart.m_ClassPart.GetClassQualifier( wszName, plFlavor, pTypedValue,
                                                        ppHeap, fValidateSet );

}

HRESULT CWbemClass::SetQualifier(LPCWSTR wszName, CVar* pVal, long lFlavor)
{
    if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    return m_CombinedPart.m_ClassPart.SetClassQualifier(wszName, pVal, lFlavor);
}

HRESULT CWbemClass::SetQualifier( LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue )
{
    if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    return m_CombinedPart.m_ClassPart.SetClassQualifier(wszName, lFlavor, pTypedValue);
}

HRESULT CWbemClass::GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                        CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    CPropertyInformation* pInfo =
        m_CombinedPart.m_ClassPart.FindPropertyInfo(wszProp);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;
    return GetPropQualifier(pInfo, wszQualifier, pVar, plFlavor, pct);
}

HRESULT CWbemClass::GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
        CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
{
    return m_CombinedPart.m_ClassPart.GetPropQualifier(wszName, wszQualifier,
                    plFlavor, pTypedVal, ppHeap, fValidateSet);
}

HRESULT CWbemClass::GetPropQualifier(CPropertyInformation* pPropInfo, LPCWSTR wszQualifier, long* plFlavor,
        CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
{
    return E_NOTIMPL;;
}

HRESULT CWbemClass::FindMethod( LPCWSTR wszMethodName )
{
    classindex_t nIndex;
    return m_CombinedPart.m_MethodPart.GetMethodOrigin(wszMethodName, &nIndex);
}

HRESULT CWbemClass::GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
                                        CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    // Get the qualifier set. TBD: more efficiently
    // ============================================

    IWbemQualifierSet* pSet;
    HRESULT hres =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hres)) return hres;

    CQualifier* pQual = ((CQualifierSet*)pSet)->GetQualifier(wszQualifier);
    if(pQual == NULL)
    {
        pSet->Release();
        return WBEM_E_NOT_FOUND;
    }

    // Store the type if requested
    if ( NULL != pct )
    {
        *pct = pQual->Value.GetType();
    }

    // Convert to CVar
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

    // Check for allocation failure
    if ( !pQual->Value.StoreToCVar(*pVar, &m_CombinedPart.m_ClassPart.m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pSet->Release();
    return WBEM_NO_ERROR;
}

HRESULT CWbemClass::GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
                                    CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
{
    // Get the qualifier set. TBD: more efficiently
    // ============================================

    IWbemQualifierSet* pSet;
    HRESULT hr =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hr)) return hr;

    CQualifier* pQual = ((CQualifierSet*)pSet)->GetQualifier(wszQualifier);
    if(pQual == NULL)
    {
        pSet->Release();
        return WBEM_E_NOT_FOUND;
    }

    // Make sure a set will actually work - Ostensibly we are calling this API because we need
    // direct access to a qualifier's underlying data before actually setting (possibly because
    // the qualifier is an array).
    if ( fValidateSet )
    {
        hr = ((CQualifierSet*)pSet)->ValidateSet( wszQualifier, pQual->fFlavor, pTypedVal, TRUE, TRUE );
    }

    // Store the flavor
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

    // This class's heap since we're getting locally
    *ppHeap = &m_CombinedPart.m_ClassPart.m_Heap;

    // Check for possible allocation failure
    if ( NULL != pTypedVal )
    {
        pQual->Value.CopyTo( pTypedVal );
    }

    pSet->Release();
    return WBEM_NO_ERROR;
}

HRESULT CWbemClass::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
                                        CVar *pVal)
{
    // Access that method's qualifier set
    // ====================================

    IWbemQualifierSet* pSet;
    HRESULT hr =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hr)) return hr;

    // Create the value
    // ================

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVal, m_CombinedPart.m_MethodPart.GetHeap());

    if ( SUCCEEDED( hr ) )
    {
        // The last call may have moved us --- rebase
        // ==========================================

        ((CQualifierSet*)pSet)->SelfRebase();
        hr = ((CQualifierSet*)pSet)->SetQualifierValue(wszQualifier, (BYTE)lFlavor, &Value, TRUE);
    }

    return hr;
}

HRESULT CWbemClass::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
                                    long lFlavor, CTypedValue* pTypedVal)
{
    // Access that method's qualifier set
    // ====================================

    IWbemQualifierSet* pSet;
    HRESULT hr =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hr)) return hr;

    hr = ((CQualifierSet*)pSet)->SetQualifierValue(wszQualifier, (BYTE)lFlavor, pTypedVal, TRUE);

    return hr;
}

HRESULT CWbemClass::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                        long lFlavor, CVar *pVal)
{
    return m_CombinedPart.m_ClassPart.SetPropQualifier(wszProp, wszQualifier,
                lFlavor, pVal);
}

HRESULT CWbemClass::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                    long lFlavor, CTypedValue* pTypedVal)
{
    return m_CombinedPart.m_ClassPart.SetPropQualifier(wszProp, wszQualifier,
                lFlavor, pTypedVal);
}

STDMETHODIMP CWbemClass::GetMethod(LPCWSTR wszName, long lFlags,
                        IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
    // The lower level functions should handle any OOM exceptions, so no
    // need to do it up here.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszName == NULL || lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(ppInSig) *ppInSig = NULL;
        if(ppOutSig) *ppOutSig = NULL;

        CWbemObject* pInSig, *pOutSig;
        HRESULT hres = m_CombinedPart.m_MethodPart.GetMethod(wszName, lFlags, &pInSig, &pOutSig);
        if(FAILED(hres)) return hres;

        if(ppInSig)
            *ppInSig = pInSig;
        else if(pInSig)
            pInSig->Release();

        if(ppOutSig)
            *ppOutSig = pOutSig;
        else if(pOutSig)
            pOutSig->Release();
        return hres;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::PutMethod(LPCWSTR wszName, long lFlags,
                        IWbemClassObject* pInSig, IWbemClassObject* pOutSig)
{
    // Check for out of memory.  This function will perform allocations under
    // the covers, but I believe the lower levels should do the OOM handling.
    // Since I'm not sure, I'm adding handling here.

    try
    {
        CLock lock(this);

        if(wszName == NULL || lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        CWbemObject*    pWmiInSig = NULL;
        CWbemObject*    pWmiOutSig = NULL;

        // Check that these are our objects, or this don't fly
        HRESULT    hres = WbemObjectFromCOMPtr( pInSig, &pWmiInSig );
        CReleaseMe    rm1( (IWbemClassObject*) pWmiInSig );

        if ( SUCCEEDED( hres ) )
        {
            hres = WbemObjectFromCOMPtr( pOutSig, &pWmiOutSig );
            CReleaseMe    rm2( (IWbemClassObject*) pWmiOutSig );

            if ( SUCCEEDED( hres ) )
            {
                hres = m_CombinedPart.m_MethodPart.PutMethod( wszName, lFlags,
                                                           pWmiInSig, pWmiOutSig );
            }

        }    // IF gor WBEM Objects

        EndMethodEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
        {
            hres = WBEM_E_FAILED;
        }

        return hres;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

STDMETHODIMP CWbemClass::DeleteMethod(LPCWSTR wszName)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        CLock lock(this);

        if(wszName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hres = m_CombinedPart.m_MethodPart.DeleteMethod(wszName);
        EndMethodEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
        {
            hres = WBEM_E_FAILED;
        }

        return hres;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::BeginMethodEnumeration(long lFlags)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        CLock lock(this);
             
        if ((lFlags == WBEM_FLAG_LOCAL_ONLY) ||
            (lFlags == WBEM_FLAG_PROPAGATED_ONLY) ||
            (lFlags == (WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY)) ||            
            (lFlags == 0)) // old compatibility case
        {
            m_nCurrentMethod = 0;
            m_FlagMethEnum = (lFlags == 0)?(WBEM_FLAG_LOCAL_ONLY|WBEM_FLAG_PROPAGATED_ONLY):lFlags;
            return WBEM_S_NO_ERROR;        
        }
        else
            return WBEM_E_INVALID_PARAMETER;


    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::EndMethodEnumeration()
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        CLock lock(this);

        if(m_nCurrentMethod == -1)
            return WBEM_E_UNEXPECTED;
            
        m_nCurrentMethod = -1;
        m_FlagMethEnum = (WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY);
        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::NextMethod(long lFlags, BSTR* pstrName,
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
    // The lower level functions should be correctly handling any OOM exceptions,
    // so we should be okay at this level.

    try
    {
        CLock lock(this);

        if(pstrName) *pstrName = NULL;
        if(ppInSig) *ppInSig = NULL;
        if(ppOutSig) *ppOutSig = NULL;

        if(m_nCurrentMethod == -1)
            return WBEM_E_UNEXPECTED;

        CWbemObject* pInSig = NULL;
        CWbemObject* pOutSig = NULL;
        BSTR LocalBstrName = NULL;        
        HRESULT hres;

InnerNext:
        
        hres = m_CombinedPart.m_MethodPart.GetMethodAt(m_nCurrentMethod++, &LocalBstrName,
                                    &pInSig, &pOutSig);
        if (WBEM_S_NO_ERROR == hres)
        {
            if ((WBEM_FLAG_LOCAL_ONLY|WBEM_FLAG_PROPAGATED_ONLY) == (m_FlagMethEnum & (WBEM_FLAG_LOCAL_ONLY|WBEM_FLAG_PROPAGATED_ONLY)))
            {
                // both bit set, both kind of properties
            }
            else
            {
                BOOL bValid = FALSE;
                // is touched == Is Local or is Locally Overridden
                BOOL bRet = m_CombinedPart.m_MethodPart.IsTouched(m_nCurrentMethod-1,&bValid); //LocalBstrName);

      
                DBG_PRINTFA((pBuff, " %S %d fl %d\n",LocalBstrName,bRet,m_FlagMethEnum)); 
                _DBG_ASSERT(bValid);
                
                if (bRet && (m_FlagMethEnum & WBEM_FLAG_LOCAL_ONLY))
                {
                    // OK
                } 
                else if (!bRet && (m_FlagMethEnum & WBEM_FLAG_PROPAGATED_ONLY))
                {
                    // OK
                }
                else 
                {
                    if (pInSig){
                        pInSig->Release();
                        pInSig = NULL;
                    }
                    if (pOutSig){
                        pOutSig->Release();
                        pOutSig = NULL;
                    }
                    if (LocalBstrName) {
                        SysFreeString(LocalBstrName);
                        LocalBstrName = NULL;
                    }
                    goto InnerNext;
                }               
            }
        }
        
        if(hres != WBEM_S_NO_ERROR) return hres;

        if(ppInSig)
            *ppInSig = pInSig;
        else if(pInSig)
            pInSig->Release();

        if(ppOutSig)
            *ppOutSig = pOutSig;
        else if(pOutSig)
            pOutSig->Release();

        if (pstrName) {
            *pstrName = LocalBstrName;
        } else {
            if (LocalBstrName)
                SysFreeString(LocalBstrName);
        }
        return hres;
    }
    catch(...)
    {
           m_nCurrentMethod = -1;
    m_FlagMethEnum = (WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY);
    
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::GetMethodQualifierSet(LPCWSTR wszName,
                    IWbemQualifierSet** ppSet)
{
    // The lower level functions should be correctly handling any OOM exceptions,
    // so we should be okay at this level.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszName == NULL || ppSet == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *ppSet = NULL;

        return m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszName, ppSet);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::GetMethodOrigin(LPCWSTR wszMethodName,
                    BSTR* pstrClassName)
{
    // I believe the underlying functions will handle the OOM exceptions.  The
    // only one where any allocations will occur, is when we get the BSTR, which
    // will handle an exception and return NULL (which we are checking for).

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszMethodName == NULL || pstrClassName == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *pstrClassName = NULL;

        classindex_t nIndex;
        HRESULT hres = m_CombinedPart.m_MethodPart.GetMethodOrigin(wszMethodName, &nIndex);
        if(FAILED(hres)) return hres;

        CCompressedString* pcs = m_CombinedPart.m_ClassPart.m_Derivation.GetAtFromLast(nIndex);
        if(pcs == NULL)
            pcs = m_CombinedPart.m_ClassPart.GetClassName();
        if(pcs == NULL)
            *pstrClassName = NULL;
        else
        {
            *pstrClassName = pcs->CreateBSTRCopy();

            // Check for allocation failure
            if ( NULL == *pstrClassName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

STDMETHODIMP CWbemClass::SetInheritanceChain(long lNumAntecedents,
    LPWSTR* awszAntecedents)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        return m_CombinedPart.m_ClassPart.SetInheritanceChain(lNumAntecedents,
                                                              awszAntecedents);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}
STDMETHODIMP CWbemClass::SetPropertyOrigin(LPCWSTR wszPropertyName, long lOriginIndex)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        return m_CombinedPart.m_ClassPart.SetPropertyOrigin(wszPropertyName,
                                                            lOriginIndex);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}
STDMETHODIMP CWbemClass::SetMethodOrigin(LPCWSTR wszMethodName, long lOriginIndex)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        return m_CombinedPart.m_MethodPart.SetMethodOrigin(wszMethodName,
                                                            lOriginIndex);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

void CWbemClass::CompactAll()
{
    m_CombinedPart.Compact();
}

HRESULT CWbemClass::CreateDerivedClass(CWbemClass* pParent, int nExtraSpace,
    CDecorationPart* pDecoration)
{
    try
    {
        _DBG_ASSERT(GetStart()==0);
        int nLength = pParent->EstimateDerivedClassSpace();

        HRESULT hr = WBEM_E_OUT_OF_MEMORY;
        
        LPMEMORY pNewData = m_pBlobControl->Allocate(nLength);

        // Check for allocation failure
        if ( NULL != pNewData )
        {
            memset(pNewData, 0, nLength);

            // Check for allocation failure
            hr = pParent->WriteDerivedClass(pNewData, nLength, pDecoration);
            SetData(pNewData, nLength);
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        // IF SetData threw and exception, we will still have the memory, so
        // cleaning us up will clean up the memory.
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // IF SetData threw and exception, we will still have the memory, so
        // cleaning us up will clean up the memory.
        return WBEM_E_FAILED;
    }

}

length_t CWbemClass::EstimateUnmergeSpace()
{
    return m_CombinedPart.EstimateUnmergeSpace();
}

HRESULT CWbemClass::Unmerge(LPMEMORY pDest, int nAllocatedLength, length_t* pnUnmergedLength)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // See if the object looks okay before we pull it apart.
    hr = ValidateObject( 0L );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    // Check that unmerge succeeded
    LPMEMORY pUnmergedEnd = m_CombinedPart.Unmerge(pDest, nAllocatedLength);

    if ( NULL != pUnmergedEnd )
    {
        // Return the length in the supplied variable
        if ( NULL != pnUnmergedLength )
        {
            // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
            // signed/unsigned 32-bit value.  We do not support length
            // > 0xFFFFFFFF, so cast is ok.

            *pnUnmergedLength = (length_t) ( pUnmergedEnd - pDest );
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

EReconciliation CWbemClass::CanBeReconciledWith(CWbemClass* pNewClass)
{
    try
    {
        return m_CombinedPart.CanBeReconciledWith(pNewClass->m_CombinedPart);
    }
    catch ( CX_MemoryException )
    {
        return e_OutOfMemory;
    }
    catch(...)
    {
        return e_WbemFailed;
    }
}

EReconciliation CWbemClass::ReconcileWith(CWbemClass* pNewClass)
{
    try
    {
        return m_CombinedPart.ReconcileWith(pNewClass->m_CombinedPart);
    }
    catch ( CX_MemoryException )
    {
        return e_OutOfMemory;
    }
    catch(...)
    {
        return e_WbemFailed;
    }
}

// This function should throw an exception in OOM conditions.

HRESULT CWbemClass::CompareMostDerivedClass( CWbemClass* pOldClass )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pOldClass )
    {
        // Allocate buffera for unmerging
        int nNewUnmergeSpace = EstimateUnmergeSpace(),
            nOldUnmergeSpace = pOldClass->EstimateUnmergeSpace();

        // These pointers will clean up when we go out of scope
        LPMEMORY    pbNewUnmerged = new BYTE[ALIGN_FASTOBJ_BLOB(nNewUnmergeSpace)];
        CVectorDeleteMe<BYTE> vdm1( pbNewUnmerged );

        LPMEMORY    pbOldUnmerged = new BYTE[ALIGN_FASTOBJ_BLOB(nOldUnmergeSpace)];
        CVectorDeleteMe<BYTE> vdm2( pbOldUnmerged );

        if (    NULL != pbNewUnmerged
            &&  NULL != pbOldUnmerged )
        {
            // This will give us "most derived" class data

            // Get HRESULTS and return failures here.  Throw exceptions in OOM

            hr = Unmerge( pbNewUnmerged, nNewUnmergeSpace, NULL );

            if ( SUCCEEDED( hr ) )
            {
                hr = pOldClass->Unmerge( pbOldUnmerged, nOldUnmergeSpace, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    CClassAndMethods    mostDerivedClassAndMethods,
                                        testClassAndMethods;

                    // Initializes objects for comparison.  Make sure we specify a number of
                    // properties that will allow the CDataTable member to initialize correctly
                    // so we can get default values.

                    mostDerivedClassAndMethods.SetDataWithNumProps( pbNewUnmerged, NULL,
                        m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties(), NULL );

                    testClassAndMethods.SetDataWithNumProps( pbOldUnmerged, NULL,
                        pOldClass->m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties(),
                        NULL );

                    // Do the comparison
                    EReconciliation eTest = mostDerivedClassAndMethods.CompareTo( testClassAndMethods );

                    // Check for OOM
                    if ( e_OutOfMemory == eTest )
                    {
                        return WBEM_E_OUT_OF_MEMORY;
                    }

                    hr = ( eTest == e_ExactMatch )?WBEM_S_NO_ERROR : WBEM_S_FALSE;
                }
            }
        }   // If both Unmerge buffers allocated
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }   // IF NULL != pOldClass

    return hr;
}

HRESULT CWbemClass::CopyBlobOf(CWbemObject* pSource)
{
    try
    {
        CWbemClass* pOther = (CWbemClass*)pSource;

        length_t nLen = pOther->m_CombinedPart.GetLength();
        if(nLen > m_CombinedPart.GetLength())
        {
            // Check for allocation failure
            if ( !ExtendClassAndMethodsSpace(nLen) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        memcpy(m_CombinedPart.GetStart(), pOther->m_CombinedPart.GetStart(), nLen);
        m_CombinedPart.SetData(m_CombinedPart.GetStart(), this, &m_ParentPart);

        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

STDMETHODIMP CWbemClass::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
    // The lower level functions should handle any OOM exceptions, so no
    // need to do it up here.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pCompareTo == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // IMPORTANT: assumes that the other object was created by us as well.
        // ===================================================================

        CWbemObject* pOther = NULL;
        if ( FAILED( WbemObjectFromCOMPtr( pCompareTo, &pOther ) ) )
        {
            return WBEM_E_INVALID_OBJECT;
        }
        
        // Auto Release
        CReleaseMe    rmObj( (IWbemClassObject*) pOther );

        if( pOther->IsInstance() )
            return WBEM_S_FALSE;

        // Check the standard things first
        // ===============================

        HRESULT hres = CWbemObject::CompareTo(lFlags, pCompareTo);
        if(hres != WBEM_S_NO_ERROR)
            return hres;

        // Compare methods
        // ===============
        hres = m_CombinedPart.m_MethodPart.CompareTo(lFlags,
                                            ((CWbemClass*) pOther)->m_CombinedPart.m_MethodPart);
        return hres;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

BOOL CWbemClass::IsChildOf(CWbemClass* pClass)
{
    // This now reroutes if our class part is localized
    if ( m_ParentPart.m_ClassPart.IsLocalized() )
    {
        // We must perform an exhaustive comparison, filtering out localization data
        EReconciliation eTest = m_ParentPart.m_ClassPart.CompareExactMatch( pClass->m_CombinedPart.m_ClassPart, TRUE );

        if ( e_OutOfMemory == eTest )
        {
            throw CX_MemoryException();
        }

        return ( e_ExactMatch == eTest  );
    }
    
    return m_ParentPart.m_ClassPart.IsIdenticalWith(
                pClass->m_CombinedPart.m_ClassPart);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetLimitedVersion(IN CLimitationMapping* pMap,
                                      NEWOBJECT CWbemClass** ppNewClass)
{
    // Allocate memory for the new object
    // ==================================

    try
    {
        LPMEMORY pBlock = NULL; 
        
        pBlock = m_pBlobControl->Allocate(GetLength());
        if ( NULL == pBlock ) return WBEM_E_OUT_OF_MEMORY;
        OnDeleteObjIf<LPMEMORY,CBlobControl,
                              void(CBlobControl::*)(LPMEMORY),
                              &CBlobControl::Delete> relMe(m_pBlobControl,pBlock);


        memset(pBlock, 0, GetLength());
        LPMEMORY pCurrent = pBlock;
        LPMEMORY pEnd = pBlock + GetLength();

        // Write limited decoration part
        // =============================

        pCurrent = m_DecorationPart.CreateLimitedRepresentation(pMap, pCurrent);
        if(pCurrent == NULL)  return WBEM_E_OUT_OF_MEMORY;


        // We do NOT write a limited parent part.  We just splat the whole
        // thing down

        CopyMemory( pCurrent, m_ParentPart.GetStart(), m_ParentPart.GetLength() );
        pCurrent += m_ParentPart.GetLength();

        BOOL    fRemovedKeysCombined;

        // Write limited combined part, since this is where the property values, etc. will
        // actually be read from.

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  (pEnd - pCurrent)
        // We do not support length > 0xFFFFFFFF, so cast is ok.

        pCurrent = m_CombinedPart.CreateLimitedRepresentation(pMap,
                        (length_t) ( pEnd - pCurrent ), pCurrent, fRemovedKeysCombined);

        if(pCurrent == NULL)  return WBEM_E_OUT_OF_MEMORY;


        if ( fRemovedKeysCombined )
        {
            CDecorationPart::MarkKeyRemoval(pBlock);
        }

        // Now that we have the memory block for the new class, create the
        // actual class object itself
        // ==================================================================

        CWbemClass * pNew = new CWbemClass;
        if ( NULL == pNew )  return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe rm_((IWbemClassObject*)pNew);

        relMe.dismiss();
        pNew->SetData(pBlock, GetLength());

        pNew->AddRef();
        *ppNewClass = pNew;
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CWbemClass::IsKeyLocal( LPCWSTR pwcsKeyProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsKeyProp )
    {
        BOOL            fFoundInParent = FALSE;

        // Find the key in the combined class part.  If we find it there
        // and it is keyed, then see if it is keyed in the parent part.
        // If it is not keyed there, then it is keyed locally.

        if ( m_CombinedPart.m_ClassPart.IsPropertyKeyed( pwcsKeyProp ) )
        {
            fReturn = !m_ParentPart.m_ClassPart.IsPropertyKeyed( pwcsKeyProp );
        }

    }   
    
    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CWbemClass::IsIndexLocal( LPCWSTR pwcsIndexProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsIndexProp )
    {
        BOOL            fFoundInParent = FALSE;

        // Find the index in the combined class part.  If we find it there
        // and it is indexed, then see if it is indexed in the parent part.
        // If it is not indexed there, then it is indexed locally.

        if ( m_CombinedPart.m_ClassPart.IsPropertyIndexed( pwcsIndexProp ) )
        {
            fReturn = !m_ParentPart.m_ClassPart.IsPropertyIndexed( pwcsIndexProp );
        }

    }   // IF NULL != pwcsIndexProp
    
    return fReturn;
}

HRESULT CWbemClass::IsValidObj()
{
    HRESULT hres = m_CombinedPart.m_ClassPart.IsValidClassPart();

    if ( FAILED( hres ) )
    {
        return hres;
    }

    return m_CombinedPart.m_MethodPart.IsValidMethodPart();
}

HRESULT CWbemClass::GetDynasty( CVar* pVar )
{
    // We don't do this for Limited Representations
    if ( m_DecorationPart.IsLimited() )
    {
        pVar->SetAsNull();
        return WBEM_NO_ERROR;
    }

    return m_CombinedPart.m_ClassPart.GetDynasty(pVar);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CWbemClass::IsLocalized( void )
{
    return ( m_ParentPart.m_ClassPart.IsLocalized() ||
            m_CombinedPart.m_ClassPart.IsLocalized() );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
void CWbemClass::SetLocalized( BOOL fLocalized )
{        
    m_CombinedPart.m_ClassPart.SetLocalized( fLocalized );
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::CloneEx( long lFlags, _IWmiObject* pDestObject )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        CWbemClass*    pClassDest = (CWbemClass*) pDestObject;
        LPMEMORY pNewData = NULL;

        // See how big the class is.  If the underlying BLOB is big enough,
        // we'll just splat ourselves into it, if not, it should be reallocated

        BYTE* pMem = NULL;
        CompactAll();

        if ( NULL != pClassDest->GetStart() )
        {
            if(pClassDest->GetLength() < GetLength())
            {
                pMem = pClassDest->Reallocate( GetLength() );
            }
            else
            {
                pMem = pClassDest->GetStart();
            }

        }
        else
        {
            pMem = m_pBlobControl->Allocate(GetLength());
        }

        if(pMem == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy(pMem, GetStart(), GetLength());

        pClassDest->SetData(pMem, GetLength());

        return WBEM_S_NO_ERROR;;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance )
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Checks if the current object is a child of the specified class (i.e. is Instance of,
// or is Child of )
STDMETHODIMP CWbemClass::IsParentClass( long lFlags, _IWmiObject* pClass )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock(this);

        return ( IsChildOf( (CWbemClass*) pClass ) ? WBEM_S_NO_ERROR : WBEM_S_FALSE );

    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Compares the derived most class information of two class objects.
STDMETHODIMP CWbemClass::CompareDerivedMostClass( long lFlags, _IWmiObject* pClass )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock(this);

        CWbemClass*    pObj = NULL;

        HRESULT    hr = WbemObjectFromCOMPtr( pClass, (CWbemObject**) &pObj );
        CReleaseMe    rm( (_IWmiObject*) pObj );

        if ( SUCCEEDED( hr ) )
        {
            hr = CompareMostDerivedClass( pObj );
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation class for projection queries
STDMETHODIMP CWbemClass::GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass )
{
    try
    {
        // Can't do this if we already have a limitation mapping.
        // This means that we're already limited.

        if ( NULL != m_pLimitMapping || IsLimited() )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        HRESULT    hr = WBEM_S_NO_ERROR;

        // Create a new mapping
        CLimitationMapping*    pMapping = new CLimitationMapping;

        if ( NULL != pMapping )
        {
            // Initialize the new mapping
            CWStringArray    wstrPropArray;

            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumNames; dwCtr++ )
            {
                if ( wstrPropArray.Add( pPropNames[dwCtr] ) != CWStringArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

            if ( SUCCEEDED( hr ) )
            {

                // Initialize the map
                if ( MapLimitation( 0L, &wstrPropArray, pMapping ) )
                {
                    CWbemClass*    pClass = NULL;

                    // Now pony up a limited version
                    hr = GetLimitedVersion( pMapping, &pClass );

                    if ( SUCCEEDED( hr ) )
                    {
                        // New class is good to go
                        pClass->m_pLimitMapping = pMapping;
                        *pNewClass = (_IWmiObject*) pClass;
                    }
                }
                else
                {
                    // ??? Need to check appropriateness of this
                    hr = WBEM_E_FAILED;
                }
            }

            if ( FAILED( hr ) )
            {
                delete pMapping;
            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation instance for projection queries
// "this" _IWmiObject must be a limited class
STDMETHODIMP CWbemClass::MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance )
{
    try
    {
        CWbemInstance*    pRealInstance = NULL;

        HRESULT    hr = pInstance->_GetCoreInfo( 0L, (void**) &pRealInstance );
        CReleaseMe    rm( (_IWmiObject*) pRealInstance );

        // Can't do this if we don't have a limitation mapping, or the instance
        // is already limited

        if ( NULL != m_pLimitMapping && !pRealInstance->IsLimited() )
        {
            CWbemInstance*    pInst = NULL;

            hr = pRealInstance->GetLimitedVersion( m_pLimitMapping, &pInst );

            if ( SUCCEEDED( hr ) )
            {
                *pNewInstance = (_IWmiObject*) pInst;
            }

        }
        else
        {
            hr = WBEM_E_INVALID_OPERATION;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Merges a blob with the current object memory and creates a new object
STDMETHODIMP CWbemClass::Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj )
{
    try
    {
        // Flags must be valid and pbData must be valid
        if ( !( WMIOBJECT_MERGE_FLAG_CLASS == lFlags || WMIOBJECT_MERGE_FLAG_INSTANCE == lFlags ) || NULL == pbData )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

	if ( WMIOBJECT_MERGE_FLAG_CLASS == lFlags )
	{
	    CWbemClass*	pClass = CWbemClass::CreateFromBlob( this, (LPBYTE) pbData, uBuffSize );
	    *ppNewObj = pClass;
	}
	else
	{
	    CWbemInstance*	pInstance = CWbemInstance::CreateFromBlob( this, (LPBYTE) pbData, uBuffSize );
	    *ppNewObj = pInstance;
	}

        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

STDMETHODIMP CWbemClass::MergeAndDecorate(long lFlags,ULONG uBuffSize,LPVOID pbData,WCHAR * pServer,WCHAR * pNamespace,_IWmiObject** ppNewObj)
{
    try
    {
        // Flags must be valid and pbData must be valid
        if ( !( WMIOBJECT_MERGE_FLAG_CLASS == lFlags || WMIOBJECT_MERGE_FLAG_INSTANCE == lFlags ) || NULL == pbData )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if ( WMIOBJECT_MERGE_FLAG_CLASS == lFlags )
        {
            CWbemClass*    pClass = CWbemClass::CreateFromBlob2( this, (LPBYTE) pbData,pServer,pNamespace);
            *ppNewObj = pClass;
        }
        else
        {
            CWbemInstance*    pInstance = CWbemInstance::CreateFromBlob2( this, (LPBYTE) pbData,pServer,pNamespace);
            *ppNewObj = pInstance;
        }
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
// is specified this will only perform a test
STDMETHODIMP CWbemClass::ReconcileWith( long lFlags, _IWmiObject* pNewObj )
{
    try
    {
        // Get rid of invalid parameters now
        if ( NULL == pNewObj || ( 0L != lFlags && lFlags & ~WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CWbemClass*    pObj = NULL;

        HRESULT    hr = WbemObjectFromCOMPtr( pNewObj, (CWbemObject**) &pObj );
        CReleaseMe    rm( (_IWmiObject*) pObj );

        if ( SUCCEEDED( hr ) )
        {
            EReconciliation eRecon = CanBeReconciledWith( pObj );
            if ( eRecon == e_Reconcilable && lFlags != WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE )
            {
                eRecon = ReconcileWith( pObj );
            }

            if (eRecon == e_OutOfMemory)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else if ( eRecon != e_Reconcilable )
            {
                hr = WBEM_E_FAILED;
            }

        }    // IF Got a pointer

        return hr;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Upgrades class and instance objects
STDMETHODIMP CWbemClass::Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        HRESULT    hr = WBEM_S_NO_ERROR;

        // If the new parent class is NULL, then we need to create a new empty class we will
        // upgrade from (basically we will create a new base class to which the values
        // of the current class will be applied

        CWbemClass*    pParentClassObj = NULL;

        if ( NULL == pNewParentClass )
        {
            pParentClassObj = new CWbemClass;

            if ( NULL != pParentClassObj )
            {
                hr = pParentClassObj->InitEmpty();

                if ( FAILED( hr ) )
                {
                    delete pParentClassObj;
                    pParentClassObj = NULL;
                }

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            hr = WbemObjectFromCOMPtr( pNewParentClass, (CWbemObject**) &pParentClassObj );
        }

        CReleaseMe    rm((_IWmiObject*) pParentClassObj);

        if ( SUCCEEDED( hr ) )
        {
            hr = pParentClassObj->Update( this, WBEM_FLAG_UPDATE_FORCE_MODE, (CWbemClass**) ppNewChild );
        }

        return hr;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Updates derived class object using the safe/force mode logic
STDMETHODIMP CWbemClass::Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass )
{
    if  ( ( lFlags != WBEM_FLAG_UPDATE_FORCE_MODE && lFlags != WBEM_FLAG_UPDATE_SAFE_MODE ) ||
            NULL == pOldChildClass )    
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CLock    lock( this );

    CWbemClass*    pOldChild = NULL;

    HRESULT    hr = WbemObjectFromCOMPtr( pOldChildClass, (CWbemObject**) &pOldChild );;
    CReleaseMe    rm((_IWmiObject*) pOldChild);

    if ( SUCCEEDED( hr ) )
    {
        CWbemClass*    pNewChild = NULL;

        hr = Update( pOldChild, lFlags, &pNewChild );

        if ( SUCCEEDED( hr ) )
        {
            *ppNewChildClass = (_IWmiObject*) pNewChild;
        }
    }

    return hr;
}

STDMETHODIMP CWbemClass::SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst )
{
    // Validate parameters
    // ===================

    if( NULL == pwszPath || NULL == ppInst || 0L != lFlags )
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path
    // ==============
    ParsedObjectPath* pOutput = 0;

    CObjectPathParser p;
    int nStatus = p.Parse((LPWSTR)pwszPath,  &pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
    {
        // Cleanup the output pointer if it was allocated
        if ( NULL != pOutput )
        {
            p.Free(pOutput);
        }

        return WBEM_E_INVALID_OBJECT_PATH;
    }

    // Spawn and fill the instance
    // ===========================

    _IWmiObject* pInst = NULL;
    HRESULT    hres = SpawnInstance(0, (IWbemClassObject**) &pInst);
    CReleaseMe    rmInst( pInst );

    // Enumerate the keys and fill out the properties
    for(DWORD i = 0; i < pOutput->m_dwNumKeys; i++)
    {
        KeyRef* pKeyRef = pOutput->m_paKeys[i];

        WString wsPropName;
        if(pKeyRef->m_pName == NULL)
        {
            // No key name --- get the key.
            // ============================

            CWStringArray awsKeys;
            ((CWbemInstance*)pInst)->GetKeyProps(awsKeys);
            if(awsKeys.Size() != 1)
            {
                pInst->Release();
                p.Free(pOutput);
                return WBEM_E_INVALID_OBJECT;
            }
            wsPropName = awsKeys[0];
        }
        else wsPropName = pKeyRef->m_pName;

        // Compute variant type of the property
        // ====================================

        CIMTYPE ctPropType;
        hres = pInst->Get(wsPropName, 0, NULL, &ctPropType, NULL);
        if(FAILED(hres))
        {
            pInst->Release();
            p.Free(pOutput);
            return WBEM_E_INVALID_PARAMETER;
        }

        VARTYPE vtVariantType = CType::GetVARTYPE(ctPropType);

        // Set the value into the instance
        // ===============================

        if(vtVariantType != V_VT(&pKeyRef->m_vValue))
        {
            hres = VariantChangeType(&pKeyRef->m_vValue, &pKeyRef->m_vValue, 0,
                        vtVariantType);
        }
        if(FAILED(hres))
        {
            pInst->Release();
            p.Free(pOutput);
            return WBEM_E_INVALID_PARAMETER;
        }

        hres = pInst->Put(wsPropName, 0, &pKeyRef->m_vValue, 0);
        if(FAILED(hres))
        {
            pInst->Release();
            p.Free(pOutput);
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    // Caller must free this guy up
    *ppInst = pInst;
    pInst->AddRef();

    // Cleanup the output pointer if it was allocated
    p.Free(pOutput);

    return hres;
}

// Returns the parent class name from a BLOB
STDMETHODIMP CWbemClass::GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass )
{
    if ( NULL == pbData || NULL == pbstrParentClass )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT    hr = WBEM_S_NO_ERROR;

    // We only support retrieving parent class information from unmerged class Blobs
    if ( WMIOBJECT_MERGE_FLAG_CLASS == lFlags )
    {
        // Use the static method to get the info
        WString    wsSuperclassName;

        hr = CClassAndMethods::GetSuperclassName( wsSuperclassName, (LPMEMORY) pbData );

        if ( SUCCEEDED( hr ) )
        {
            *pbstrParentClass = SysAllocString( wsSuperclassName );

            if ( NULL == *pbstrParentClass )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastembd.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTEMBD.H

Abstract:

    Embedded Objects

History:

    3/10/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_EMBED__H_
#define __FAST_EMBED__H_


#include "fastsprt.h"
#include <vector>
#include <wstlallc.h>

class CWbemObject;
class CFastHeap;
class CVar;


typedef BYTE* LPMEMORY;

struct EmbeddedObj
{
	LPMEMORY m_start;
	size_t 	m_length;
	EmbeddedObj(LPMEMORY start, size_t length):
			m_start(start), m_length(length)
	{
	}
};

typedef std::vector<EmbeddedObj, wbem_allocator<EmbeddedObj> > DeferedObjList;

#pragma pack(push, 1)
class COREPROX_POLARITY CEmbeddedObject
{
private:
    length_t m_nLength;
    BYTE m_byFirstByte;
public:
    length_t GetLength() {return m_nLength + sizeof(m_nLength);}
    LPMEMORY GetStart() {return (LPMEMORY)this;}

public:
    static void ValidateBuffer(LPMEMORY start, size_t lenght, DeferedObjList&);
    
    CWbemObject* GetEmbedded();
    static length_t EstimateNecessarySpace(CWbemObject* pObject);
    void StoreEmbedded(length_t nLength, CWbemObject* pObject);

    void StoreToCVar(CVar& Var);
    void StoreEmbedded(length_t nLength, CVar& Var);
    static length_t EstimateNecessarySpace(CVar& Var);

    static BOOL CopyToNewHeap( heapptr_t ptrOld,
                             CFastHeap* pOldHeap,
                             CFastHeap* pNewHeap,
							 UNALIGNED heapptr_t& ptrResult );
};
#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\faster.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTER.H

Abstract:

  This is the include file for all clients of fastobj functionality.
  See member header files for documentation.

History:

  3/10/97     a-levn  Fully documented

--*/

#ifndef _FASTER_H_
#define _FASTER_H_


// Parameter flow indicators.
// ==========================

#define READONLY
    // The value should be treated as read-only

#define ACQUIRED
    // Ownership of the object/pointer is acquired.

#define COPIED
    // The function makes a copy of the object/pointer.

#define PREALLOCATED
    // The out-param uses caller's memory.

#define NEWOBJECT
    // The return value or out parameter is a new
    // allocation which must be deallocated by
    // the caller if the call succeeds.

#define READWRITE
    // The in-param is will be treated as read-write,
    // but will not be deallocated.

#define INTERNAL
    // Returns a pointer to internal memory object
    // which should not be deleted.

#define ADDREF
    // On a parameter, indicates that the called
    // function will do an AddRef() on the interface
    // and retain it after the call completes.

#define TYPEQUAL L"CIMTYPE"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastcls.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTCLS.H

Abstract:

  This file defines the classes related to class representation
  in WbemObjects

  Classes defined: 
      CClassPart              Derived class definition
      CClassPartContainer     Anything that contains CClassPart
      CWbemClass               Complete class definition.

History:

    3/10/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_WBEM_CLASS__H_
#define __FAST_WBEM_CLASS__H_

#include "fastobj.h"
#include "fastmeth.h"
#include "wbemutil.h"

//#pragma pack(push, 1)

    
//*****************************************************************************
//*****************************************************************************
//
//  class CClassPartContainer
//
//  See CClassPart definition first.
//
//  This class defines the functionality required by CClassPart of any object
//  whose memory block contains that of the CClassPart.
//
//*****************************************************************************
//
//  ExtendClassPartSpace
//
//  Called by CClassPart when it needs more memory for its memory block. The
//  container may have to relocate the entire memory block to get more memory. 
//  In this case, it will have to notify CClassPart of its new location using
//  Rebase.
//
//  PARAMETERS:
//
//      CClassPart* pClassPart      The class part making the request
//      length_t nNewLength         The required length
//
//*****************************************************************************
//
//  ReduceClassPartSpace
//
//  Called by CClassPart wen it wants to return some memory to the container.
//  The container may NOT relocate the class part's memory block in response to
//  this call.
//
//  PARAMETERS:
//
//      CClassPart* pClassPart      The class part making the request
//      length_t nDecrement         The amount of space to return
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Must return the pointer to the IUnknown of the containing CWbemObject
//  This is used by qualifier sets to ensure that the main object lasts at
//  least as long as they do.
//  
//  RETURN VALUES:
//
//      IUnknown*:   the pointer to the controlling IUnknown
//
//*****************************************************************************


class CClassPart;
class COREPROX_POLARITY CClassPartContainer
{
public:
    virtual BOOL ExtendClassPartSpace(CClassPart* pPart, 
        length_t nNewLength) = 0;
    virtual void ReduceClassPartSpace(CClassPart* pPart,
        length_t nDecrement) = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPart
//
//  This object represents information about a class. A complete class
//  definition consists of two of these: a part describing the class itself
//  as well as the part describing the parent. See CWbemClass (below) for 
//  more explanations.
//
//  The memory block of CClassPart has the following format:
//
//      The header:
//          length_t nLength            The length of the whole structure
//          BYTE fFlags                 Reserved
//          heapptr_t ptrClassName      The heap pointer to the name of the
//                                      class. INVALID_HEAP_POINTER if no name
//                                      has been assigned yet.
//          heapptr_t ptrParentName     The heap pointer to the name of the
//                                      parent class. INVALID_HEAP_POINTER if
//                                      top-level.
//          heapptr_t ptrDynasty        The heap pointer to the name of the
//                                      dynasty (top-level class we are derived
//                                      from).
//          length_t nDataLength        The length of the data table for this
//                                      class (CDataTable itself does not know)
//
//      Class Qualifiers: see CBasicQualfiierSet (fastqual.h) for details.
//      Property lookup table: see CPropertyLookupTable (fastprop.h)
//      Default values: see CDataTable (fastprop.h) for details
//      The heap where all the variable-length data is kept: see CFastHeap
//          in fastheap.h for details.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function.
//
//  PARAMETERS:
//
//      LPMEMORY pStart                 The memory block where we live.
//      CClassPartContainer* pContainer Out container (class or instance)
//      CClassPart* pParent = NULL      The parent's class part. Instances
//                                      don't have it. Classes do --- see 
//                                      CWbemClass (below) for details.
//
//*****************************************************************************
//
//  SetData
//
//  Overloaded Initialization function.
//
//  PARAMETERS:
//
//      LPMEMORY pStart                 The memory block where we live.
//      CClassPartContainer* pContainer Out container (class or instance)
//		DWORD dwNumProperties			Number of properties to initialize
//										DataTable with ( for CompareExactMatch()
//										and Update() ).
//      CClassPart* pParent = NULL      The parent's class part. Instances
//                                      don't have it. Classes do --- see 
//                                      CWbemClass (below) for details.
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to our memory block
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t;   the length of our memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs CClassPart that its memory block has moved.
//
//  PARAMETERS:
//
//      LPMEMORY pMemory        The new location of the memory block
//
//*****************************************************************************
//
//  GetPropertyLookup
//
//  Finds the property's CPropertyLookup structure by its index in the lookup
//  table. This function is only useful in the context of enumerating all 
//  properties. See fastprop.h for CPropertyLookup.
//
//  PARAMETERS:
//
//      int nIndex      The index of the property in the property lookup table.
//                      This is NOT the index in the data table!
//  RETURN VALUES:
//
//      CPropertyLookup*:   if the index is within range --- the property's
//                          lookup structure. Otherwise, NULL.
//
//*****************************************************************************
//
//  FindPropertyInfo
//
//  Finds the property information structure based on the name. See fastprop.h
//  for CPropertyInformation definition. The name is treated case-insensitively
//
//  PARAMETERS:
//
//      LPCWSTR wszName     The name of the property to find.
//  
//  RETURN VALUES:
//
//      CPropertyInformation*:  the information structure of the property or
//                              NULL if not found.
//
//*****************************************************************************
//
//  GetDefaultValue
//
//  Retrieves the deafult value of the property based on its information. See 
//  FindPropertyInfo for looking up information. There is also another flavor
//  of GetDefaultValue below.
//
//  PARAMETERS:
//
//      IN CPropertyInformation* pInfo  The information structure for the
//                                      property.
//      OUT CVar* pVar                  Destination for the value. Must not
//                                      already contain any value.
//
//*****************************************************************************
//
//  GetDefaultValue
//
//  Retrieves the default value of the property based on its name. 
//
//  PARAMETERS:
//
//      IN LPWCWSTR wszName             The name of the property.
//      OUT CVar* pVar                  Destination for the value. Must not
//                                      already contain any value.
//  RETURN VALUES:
//  
//      WBEM_S_NO_ERROR          success
//      WBEM_E_NOT_FOUND         property not found in this class
//
//*****************************************************************************
//
//  GetPropertyQualifierSetData
//
//  Finds the qualifier set data (see fastqual.h) for a given property.
//
//  PARAMETERS:
//
//      IN LPWCWSTR wszName             The name of the property.
//      
//  RETURN VALUES:
//
//      LPMEMORY:   the memory block of that property's qualifier set or NULL
//                  if property is not found.
//
//*****************************************************************************
//
//  EnsureProperty
//
//  Makes sure that a property with a given name and a given type exists. The
//  type is the actual VARIANT (CVar) type, and not our internal type.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property
//      IN VARTYPE vtType       The type of the VARIANT used as the value
//      IN CIMTYPE ctType       The type of the property
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      The property of the right name and type is now in
//                          the class.
//      WBEM_E_INVALID_PARAMETER     The name violates identifier naming rules.
//      WBEM_E_PROPAGATER_PROEPRTY   The parent class has the property with the
//                                  same name but different type.
//      WBEM_E_INVALID_PROPERTY_TYPE This type cannot be used as a property type.
//
//*****************************************************************************
//
//  SetDefaultValue
//
//  Sets the default value of a given property. The value must match the type
//  of the property precisely --- no coersion is attempted. The property must
//  already exist (see EnsureProperty).
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property to set.
//      IN CVar* pVar           The value to store.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              The value has been set.
//      WBEM_E_NOT_FOUND             The property does not exist.
//      WBEM_E_TYPE_MISMATCH         The value does not match the property type
//      WBEM_E_INVALID_PROPERTY_TYPE This type cannot be used as a property type.
//
//*****************************************************************************
//
//  GetClassQualifier
//
//  Gets the value of a class qualifier based on the qualifier name.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName         The name of the qualifier (insensitive).
//      OUT CVar* pVal             Destination for the value. Must not already
//                                 contain a value.
//      OUT long* plFlavor = NULL  Destination for the flavor
//                                 If NULL, not supplied
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success         
//      WBEM_E_NOT_FOUND     The qualifier was not found.
//
//*****************************************************************************
//
//  SetClassQualifier
//
//  Sets the value of a class qualifier.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the qualifier to set.
//      IN CVar* pVal           The value to assign to the qualifier. This must
//                              be of one of the valid qualifier types (see
//                              IsValidQualifierType in fastqual.h).
//      IN long lFlavor         The flavor to set.
//
//  RETURN VALUES:
//
//  Same values as CQualifierSet::SetQualifierValue, namely:
//      WBEM_S_NO_ERROR          The value was successfully changed
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//      
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a class or parent qualifier by its name.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve
//      OUT CVar* pVar          Destination for the value. Must not already 
//                              contain a value.
//      OUT long* plFlavor      Destinatino for the flavor. May be NULL if not
//                              required.
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_NOT_FOUND         No such qualifier
//
//*****************************************************************************
//
//  InitPropertyQualifierSet
//  
//  Class property qualifier sets take several tricky initialization
//  parameters (see CClassPropertyQualifierSet in fastqual.h). This function
//  initializes a qualifier set object to point to the qualifier set of a given
//  property. 
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName                      The name of the property.
//      OUT CClassPropertyQualifierSet* pSet    Destination set. this function
//                                              will call SetData on it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_S_NOT_FOUND     No such property.
//
//*****************************************************************************
//
//  DeleteProperty
//
//  Deletes a property from the class definition. The property is removed from
//  the property lookup table as well as from the data table, changing the
//  locations of the other properties. See CDataTable fastdata.h for details.
//  If the property was an overriden parent property, deleting it will simply
//  restore parent's settings --- qualifiers and the default value.
//
//  PARAMETERS:
//
//      LPCWSTR wszName         The property to delete.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_S_NOT_FOUND     No such property.
//
//*****************************************************************************
//      
//  CopyParentProperty
//
//  Copies all the information for a property from the parent class part. This
//  function is invoked when an overriden property is deleted, thus restoring
//  parent's settings.
//
//  PARAMETERS:
//
//      IN READ_ONLY CClassPart& ParentPart The parent's class part.
//      IN LPCWSTR wszName                  The name of the property
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_S_NOT_FOUND     No such property.
//
//*****************************************************************************
//      
//  GetPropertyType
//
//  Retrieves the type and the flavor of a given property. The flavor is either
//  WBEM_FLAVOR_FLAG_LOCAL or WBEM_FLAVOR_FLAG_PROPAGATED.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName  The name of the property to retrieve
//      OUT CIMTYPE* pctType Destination for the type. If NULL, not filled in
//      OUT long* plFlags   Destination for the flavor as described above. If
//                          NULL, not filled in.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*	pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//
//*****************************************************************************
//      
//  GetClassName
//
//  Retrieves the name of the class.
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the name of the class.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     Class name hasn't been assigned yet.
//
//*****************************************************************************
//
//  GetSuperclassName
//
//  Retrieves the name of the superclass.
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the name of the superclass.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     Top-level class.
//
//*****************************************************************************
//
//  GetDynasty
//
//  Retrieves the name of the dynasty --- the top-level class we are derived
//  from.
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the name of the dynasty.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     Class name hasn't been assigned yet.
//
//*****************************************************************************
//
//  GetPropertyCount
//
//  Retrieves the number of properties in the class as a CVar
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the number of properties.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//
//*****************************************************************************
//
//  SetClassName
//  
//  Sets the class name. 
//
//  PARAMETERS:
//
//      IN CVar* pVar           Contains the name of the class. 
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_TYPE_MISMATCH     pVar is not a string.
//
//*****************************************************************************
//
//  IsKeyed
//
//  Checks if this class has a key. A class has a key if at least one of its
//  properties has a 'key' qualifier or if it has the 'singleton' qualifier.
//
//  RETURN VALUES:
//
//      TRUE iff it has a key.
//
//*****************************************************************************
//
//  IsTopLevel
//
//  Check if a class is top-level. That is, if the parent name is not set.
//
//  RETURN VALUES:
//
//      TRUE iff it is top-level
//
//*****************************************************************************
//
//  IsDynamic
//
//  Check if a class is dynamic, that is, has a 'dynamic' qualifier.
//
//  RETURN VALUES:
//
//      TRUE iff it is dynamic
//
//*****************************************************************************
//
//  GetIndexedProps
//
//  Produces an array of names of the properties which are indexed, that is,
//  have the 'index' qualifier.
//
//  PARAMETERS:
//
//      CWStringArray& awsNames     Destination for the array of names. Assumed
//                                  to be empty.
//
//*****************************************************************************
//
//  GetKeyProps
//
//  Produces an array of names of the properties which are keys, that is,
//  have the 'key' qualifier.
//
//  PARAMETERS:
//
//      CWStringArray& awsNames     Destination for the array of names. Assumed
//                                  to be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  IsPropertyKeyed
//
//  Returns whether or not the specified property is a keyed property.
//
//  PARAMETERS:
//
//      LPCWSTR pwcsKeyProp - Property to check.
//
//	Returns:
//		BOOL TRUE if the property is keyed.
//
//*****************************************************************************
//
//  IsPropertyIndexed
//
//  Returns whether or not the specified property is an indexed property.
//
//  PARAMETERS:
//
//      LPCWSTR pwcsIndexProp - Property to check.
//
//	Returns:
//		BOOL TRUE if the property is indexed.
//
//*****************************************************************************
//
//  CanBeReconciledWith
//
//  This method is called when a definition of a class is about to be replaced 
//  with another one. If the class has no instances or derived classes, such
//  an operation presents no difficulties. If it does, however, we need to be
//  careful not to break them. Thus, only the following changes are allowed:
//
//      1) Qualifier changes
//      2) Default value changes
//
//  PARAMETERS:
//
//      IN READONLY CClassPart& NewPart The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          Can be reconciled --- i.e., compatible.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  ReconcileWith
//
//  See CanBeReconciledWith above. This method is the same, except that if
//  reconciliation is possible (e_Reconcilable is returned) this class part is
//  replaced with the new one (the size is adjusted accordingly).
//
//
//  PARAMETERS:
//
//      IN READONLY CClassPart& NewPart The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          We have been replaced with the new part.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  CanContainKey
//
//  Required by qualifier sets. Clearly, a class cannot be marked with 'key',
//  so this function
//
//  RETURN VALUES:
//
//      WBEM_E_INVALID_QUALIFIER
//
//*****************************************************************************
//
//  CanContainKeyedProps
//
//  Checks if this class can have keyed properties. It can unless the parent
//  class already has some.
//
//  RETURN VALUES:
//
//      TRUE if the parent class has no keys
//
//*****************************************************************************
//
//  GetTotalRealLength
//
//  Calculates how much space is really needed to store all the information in
//  the part. This may be less that what it currently takes up because of
//  holes between individual components.
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required to store us.
//
//*****************************************************************************
//
//  Compact
//
//  Removes any holes that might have developped between components.
//
//*****************************************************************************
//
//  ReallocAndCompact
//
//  Compacts (see Compact) and ensures that our memory block is at least the
//  given size (requesting more memory from our container if necessary.
//
//  PARAMETERS:
//
//      length_t nNewTotalLength        Required length of the memory block
//
//*****************************************************************************
//
//  ExtendHeapSize, ReduceHeapSize
//
//  Heap container functionality. See CFastHeapContainer in fastheap.h for
//  details. 
//
//*****************************************************************************
//
//  ExtendQualfierSetSpace, ReduceQualifierSetSpace
//
//  Qualifier set container functionality for the class qualifier set. See
//  CQualifierSetContainer in fastqual.h for details.
//
//*****************************************************************************
//
//  ExtendPropertyTableSpace, ReducePropertyTableSpace
//
//  Property table container functionality for the property table. See
//  CPropertyTableContainer in fastprop.h for details.
//
//*****************************************************************************
//
//  ExtendDataTableSpace, ReduceDataTableSpace
//
//  Data table container functionality. See CDataTableContainer in fastprop.h
//  for details.
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Returns the memory block of the class qualifier set.
//
//  Returns;
//
//      LPMEMORY:   the memory block of the qualifier set.
//
//*****************************************************************************
//
//  GetMinLength
//
//  Computes the minimum length of a class part --- one with no properties or
//  qualifiers or even a name.
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required
//
//*****************************************************************************
//
//  CreateEmpty
//
//  Creates an empty class part --- one with no properties or qualifiers --- 
//  on a given memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pStart     The memory to write on.
//
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the class part
//
//*****************************************************************************
//
//  static EstimateMergeSpace
//  
//  When a class is stored in the database, only the parts of it that are 
//  particular to that class (not inherited from the parent) are stored. So, 
//  when it is loaded back out, a "merge" between it and the parent needs to 
//  occur.
//
//  This function (over-)estimates how much space the merge is going to take.
//
//  PARAMETERS:
//
//      CClassPart& ParentPart      The parent class class part.
//      CClassPart& ChildPart       The child class class part.
//
//  RETURN VALUES:
//
//      length_t:   the (over-)estimate of the required space for the merge.
//
//*****************************************************************************
//
//  static Merge
//
//  See EstimateMergeSpace for an explanation of the merge process.
//
//  PARAMETERS:
//
//      CClassPart& ParentPart      The parent class class part.
//      CClassPart& ChildPart       The child class class part.
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the first byte after the merge
//
//*****************************************************************************
//
//  static Update
//
//  When a class object is Put to our database and it has derived classes
//	if we will unmerged derived classes with their new parents, which must
//	be done checking for conflicts and failing where necessary.
//
//  PARAMETERS:
//
//      CClassPart& ParentPart      The parent class class part.
//      CClassPart& ChildPart       The child class class part.
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//		long lFlags					Must be WBEM_FLAG_UPDATE_SAFE_MODE
//									or WBEM_FLAG_UPDATE_FORCE_MODE.
//		DWORD*						pdwMemUsed - Storage for memory used
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR if success.
//
//*****************************************************************************
//
//  EstimateUnmergeSpace
//
//  
//  When a class is stored in the database, only the parts of it that are 
//  particular to that class (not inherited from the parent) are stored. 
//  This function (over-)estimates how much space the unmerge is going to take.
//
//  RETURN VALUES:
//
//      length_t:   the (over-)estimate of the amount of space required.
//
//*****************************************************************************
//
//  Unmerge
//
//  See EstimateUnmergeSpace for an explanation of the unmerge process.
//
//  PARAMETERS:
//
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the first byte after the unmerge
//
//*****************************************************************************
//
//  EstimateDerivedPartSpace
//
//  When a derived class is created, its class part is created as a version
//  of the parent's. This function estimates the amount of space required for
//  the child's class part
//
//  RETURN VALUES:
//
//      length_t:   (over-)estimate of the number of bytes required.
//
//*****************************************************************************
//
//  CreateDerivedPart
//
//  When a derived class is created, its class part is created as a version
//  of the parent's. This function writes the child's class part to a given
//  memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the first byte after the new part.
//
//*****************************************************************************
//
//  MapLimitation
//
//  Produces an object representing a particular limitation on the objects, i.e.
//  which properties and what kinds of qualifiers should be in it.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      OUT CLimitationMapping* pMap    This mapping object (see fastprop.h) 
//                                      will be changed to reflect the 
//                                      parameters of the limitation. It can
//                                      then be used in CWbemInstance::
//                                      GetLimitedVersion function.
//  RETURNS:
//
//      BOOL:   TRUE.
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of this class part on a given block of 
//  memory as described in EstimateLimitedRepresentationLength in fastobj.h.
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap The mapping of the limitation to produce.
//                                  Obtained from CWbemClass::MapLimitation.
//      IN nAllocatedSize           The size of the memory block allocated for
//                                  the operation --- pDest.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************
//
//  SetPropQualifier
//
//  Sets the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  SetInheritanceChain
//
//  Configures the derivation of the class. This function is only used in rare
//  circumstances where an object is constructed not from its standard transport
//  form.
//
//  PARAMETERS:
//
//      IN long lNumAntecendents    The number of antecendets this class will
//                                  have. This includes all the classes this
//                                  class is derived from, but NOT itself
//
//      IN LPWSTR* awszAntecedents  The array of the names of the antecedent
//                                  classes. Starts from the top-most class.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR             On Success
//
//*****************************************************************************
//
//  SetPropertyOrigin
//
//  Sets the origin class of a property.  This function is only used in rare
//  circumstances where an object is constructed not from its standard transport
//  form.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszPropertyName   The name of the property tochange
//      IN long lOriginIndex        The index of the class of origin of this
//                                  property. Top-most class has index 0.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR             On Success
//      WBEM_E_NOT_FOUND            No such property
//      WBEM_E_INVALID_PARAMETER    Index out of range
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not a localization bit has been set.  The localization
//	bit is set in the class part header.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the class part header.  This bit is not
//	written out by Unmerge.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************

// Maximum number of properties we can have in a class object.  This is only
// because the handle returned by the IWbemObjectAccess only allows for 10-bits
// in order to store the data table index.

#define MAXNUM_CLASSOBJ_PROPERTIES	0x400

class COREPROX_POLARITY CClassPart : public CQualifierSetContainer, 
                   public CPropertyTableContainer,
                   public CDataTableContainer,
                   public CHeapContainer
{
public:
    CClassPartContainer* m_pContainer;
    CClassPart* m_pParent;

    friend CClassPQSContainer;

// The data in this structure is unaligned
#pragma pack(push, 1)
    struct CClassPartHeader
    {
        length_t nLength;
        BYTE fFlags;
        heapptr_t ptrClassName;
        length_t nDataLength;
    public:
         LPMEMORY CreateEmpty();
    };
#pragma pack(pop)

	CClassPartHeader* m_pHeader;

    CDerivationList m_Derivation;
    CClassQualifierSet m_Qualifiers;
    CPropertyLookupTable m_Properties;
    CDataTable m_Defaults;
    CFastHeap m_Heap;

public:
    CClassPart() : m_Qualifiers(1){}
     void SetData(LPMEMORY pStart, CClassPartContainer* pContainer,
        CClassPart* pParent = 0);
     void SetDataWithNumProps(LPMEMORY pStart, CClassPartContainer* pContainer,
		 DWORD dwNumProperties, CClassPart* pParent = NULL);
	 static size_t ValidateBuffer(LPMEMORY pStart, size_t cbSize);      
     LPMEMORY GetStart() {return LPMEMORY(m_pHeader);}
     length_t GetLength() {return m_pHeader->nLength;}
     void Rebase(LPMEMORY pMemory);

	 LPMEMORY ResolveHeapPointer( heapptr_t ptr ) { return m_Heap.ResolveHeapPointer( ptr ); }
	 CCompressedString* ResolveHeapString( heapptr_t ptr ) { return m_Heap.ResolveString( ptr ); }

public:
     CCompressedString* GetSuperclassName()
    {
        return m_Derivation.GetFirst();
    }
     CCompressedString* GetDynasty()
    {
        CCompressedString* pcs = m_Derivation.GetLast();
        if(pcs == NULL)
            return GetClassName();
        else
            return pcs;
    }
     CCompressedString* GetClassName()
    {
        if(m_pHeader->ptrClassName == INVALID_HEAP_ADDRESS)
            return NULL;
        else 
            return m_Heap.ResolveString(m_pHeader->ptrClassName);
    }
        
     CPropertyLookup* GetPropertyLookup(int nIndex)
    {
        if(nIndex < m_Properties.GetNumProperties())
            return m_Properties.GetAt(nIndex);
        else 
            return NULL;
    }
     CPropertyInformation* FindPropertyInfo(LPCWSTR wszName);
     HRESULT GetDefaultValue(CPropertyInformation* pInfo, CVar* pVar);
     LPMEMORY GetPropertyQualifierSetData(LPCWSTR wszName);
     HRESULT GetDefaultValue(LPCWSTR wszName, CVar* pVar);
     HRESULT EnsureProperty(LPCWSTR wszName, VARTYPE vtValueType, 
                                CIMTYPE ctNativeType, BOOL fForce);
     HRESULT SetDefaultValue(LPCWSTR wszName, CVar* pVar);
     HRESULT GetClassQualifier(LPCWSTR wszName, CVar* pVal, 
                                    long* plFlavor = NULL, CIMTYPE* pct = NULL);
     HRESULT GetClassQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
									CFastHeap** ppHeap, BOOL fValidateSet);
     HRESULT SetClassQualifier(LPCWSTR wszName, CVar* pVal, 
                                    long lFlavor = 0);
     HRESULT SetClassQualifier(LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue );
     HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal, 
					         long* plFlavor = NULL, CIMTYPE* pct = NULL);
     HRESULT InitPropertyQualifierSet(LPCWSTR wszName, 
                                            CClassPropertyQualifierSet* pSet);
     HRESULT DeleteProperty(LPCWSTR wszName);
     HRESULT CopyParentProperty(CClassPart& ParentPart, LPCWSTR wszName);
     HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                   long* plFlags);
     HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                   long* plFlags);

     HRESULT GetClassName(CVar* pVar);
     HRESULT GetSuperclassName(CVar* pVar);
     HRESULT GetDynasty(CVar* pVar);
     HRESULT GetPropertyCount(CVar* pVar);
     HRESULT GetDerivation(CVar* pVar);
     HRESULT SetClassName(CVar* pVar);
     BOOL IsKeyed();                                                         
     BOOL IsTopLevel() {return m_Derivation.IsEmpty();}
     BOOL CheckLocalBoolQualifier( LPCWSTR pwszName );
     BOOL CheckBoolQualifier( LPCWSTR pwszName );

     BOOL GetIndexedProps(CWStringArray& awsNames);
     BOOL GetKeyProps(CWStringArray& awsNames);
     HRESULT GetKeyOrigin(WString& wsClass);
     BOOL IsPropertyKeyed(LPCWSTR pwcsKeyProp);
     BOOL IsPropertyIndexed(LPCWSTR pwcsIndexProp);
     HRESULT GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName);
     BOOL InheritsFrom(LPCWSTR wszClassName);

    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

    void DeleteProperty(int nIndex)
    {
        m_Properties.DeleteProperty(m_Properties.GetAt(nIndex), 
                                    CPropertyLookupTable::e_UpdateDataTable);
    }

	BOOL IsLocalized( void )
	{
		return m_pHeader->fFlags & WBEM_FLAG_CLASSPART_LOCALIZATION_MASK;
	}

	void SetLocalized( BOOL fLocalized )
	{            
		m_pHeader->fFlags &= ~WBEM_FLAG_CLASSPART_LOCALIZATION_MASK;
		m_pHeader->fFlags |= ( fLocalized ? WBEM_FLAG_CLASSPART_LOCALIZED :
								WBEM_FLAG_CLASSPART_NOT_LOCALIZED );
	}

public:
    EReconciliation CanBeReconciledWith(CClassPart& NewPart);
    EReconciliation ReconcileWith(CClassPart& NewPart);

	EReconciliation CompareExactMatch(CClassPart& thatPart, BOOL fLocalized = FALSE );

	BOOL CompareDefs(CClassPart& OtherPart);
    BOOL IsIdenticalWith(CClassPart& OtherPart);
protected:
     HRESULT SetDefaultValue(CPropertyInformation* pInfo, CVar* pVar);

public: // container functionality

    CFastHeap* GetHeap() {return &m_Heap;}
    HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
     BOOL IsDynamic()
	 {
		 return CheckLocalBoolQualifier( L"Dynamic" );
	 }

     BOOL IsSingleton()
    {
        return CheckBoolQualifier(L"singleton");
    }

    BOOL IsAbstract()
    {
        return CheckBoolQualifier(L"abstract");
    }

    BOOL IsAssociation()
    {
        return CheckBoolQualifier(L"association");
    }

    BOOL IsAmendment()
    {
        return CheckBoolQualifier(L"amendment");
    }

    BOOL IsHiPerf()
    {
        return CheckBoolQualifier(L"HiPerf");
    }

    BOOL IsAutocook()
    {
        return CheckBoolQualifier(L"AutoCook");
    }

    BYTE GetAbstractFlavor();
    BOOL IsCompressed()
    {
        return m_Qualifiers.GetQualifier(L"compress") != NULL;
    }
    BOOL CanContainKeyedProps() 
    {
        return !m_pParent->IsKeyed() && !IsSingleton();
    }
    HRESULT CanContainSingleton() 
    {
		if ( !m_pParent->IsKeyed() && (IsSingleton() || !IsKeyed() ) )
		{
			return WBEM_S_NO_ERROR;
		}
		return WBEM_E_CANNOT_BE_SINGLETON;
    }
    HRESULT CanContainAbstract( BOOL fValue );
    HRESULT CanContainDynamic( void )
	{
		return WBEM_S_NO_ERROR;
	}
    BOOL CanHaveCimtype(LPCWSTR) 
    {
        return FALSE;
    }

    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetWbemObjectUnknown();}

     length_t GetTotalRealLength()
    {
        return sizeof(CClassPartHeader) + m_Derivation.GetLength() +
            m_Qualifiers.GetLength() + 
            m_Properties.GetLength() + m_Defaults.GetLength() + 
            m_Heap.GetLength();
    }

     void SetDataLength(length_t nDataLength)
        {m_pHeader->nDataLength = nDataLength;}

     void Compact();
     BOOL ReallocAndCompact(length_t nNewTotalLength);

    // CHeapContainer
    BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nExtra);
    void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nDecrement){}
    LPMEMORY GetMemoryLimit(){ return EndOf(*this); };
        
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement){}

    BOOL ExtendPropertyTableSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength);
    void ReducePropertyTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement){}

    BOOL ExtendDataTableSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength);
    void ReduceDataTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement);

    CDataTable* GetDataTable() {return &m_Defaults;}
	classindex_t GetClassIndex( LPCWSTR	pwszClassName )	{ return m_Derivation.Find( pwszClassName ); }
    classindex_t GetCurrentOrigin() {return m_Derivation.GetNumStrings();}
    LPMEMORY GetQualifierSetStart() {return m_Qualifiers.GetStart();}

    HRESULT GetPropQualifier(CPropertyInformation* pInfo, 
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);

    HRESULT GetPropQualifier(LPCWSTR wszName,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);

public:
    static  GetMinLength()
    {
        return sizeof(CClassPartHeader) + CDerivationList::GetHeaderLength()
            + CClassQualifierSet::GetMinLength()
            + CPropertyLookupTable::GetMinLength() 
            + CDataTable::GetMinLength() + CFastHeap::GetMinLength();
    }
    static  LPMEMORY CreateEmpty(LPMEMORY pStart);

    static length_t EstimateMergeSpace(CClassPart& ParentPart, 
                                       CClassPart& ChildPart);

    static LPMEMORY Merge(CClassPart& ParentPart, CClassPart& ChildPart, 
        LPMEMORY pDest, int nAllocatedLength);    

    static HRESULT Update(CClassPart& ParentPart, CClassPart& ChildPart, long lFlags ); 
    static HRESULT UpdateProperties(CClassPart& ParentPart, CClassPart& ChildPart,
									long lFlags );
	HRESULT TestCircularReference( LPCWSTR pwcsClassName )
	{
		// Basically if the name is in the derivation list, we gots a
		// circular reference
		return ( m_Derivation.Find( pwcsClassName ) >= 0 ?
					WBEM_E_CIRCULAR_REFERENCE : WBEM_S_NO_ERROR );
	}

    length_t EstimateUnmergeSpace();
    LPMEMORY Unmerge(LPMEMORY pDest, int nAllocatedLength);

    length_t EstimateDerivedPartSpace();
    LPMEMORY CreateDerivedPart(LPMEMORY pDest, int nAllocatedLength);

    BOOL MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap);

    LPMEMORY CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pWhere, 
        BOOL& bRemovedKeys);

    HRESULT GetPropertyHandle(LPCWSTR wszName, CIMTYPE* pvt, long* plHandle);
    HRESULT GetPropertyHandleEx(LPCWSTR wszName, CIMTYPE* pvt, long* plHandle);
    HRESULT GetPropertyInfoByHandle(long lHandle, BSTR* pstrName, 
                                    CIMTYPE* pct);
    HRESULT IsValidPropertyHandle( long lHandle );

	HRESULT GetDefaultByHandle(long lHandle, long lNumBytes,
                                        long* plRead, BYTE* pData );
	HRESULT GetDefaultPtrByHandle(long lHandle, void** ppData );
	heapptr_t GetHeapPtrByHandle( long lHandle )
	{ return *(PHEAPPTRT)(m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))); }

    HRESULT SetInheritanceChain(long lNumAntecedents, LPWSTR* awszAntecedents);
    HRESULT SetPropertyOrigin(LPCWSTR wszPropertyName, long lOriginIndex);

	HRESULT IsValidClassPart( void );
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPartPtr
//
//  See CPtrSource in fastsprt.h for explanation of pointer sourcing. This one
//  is for a given offset from the start of a class part (see CClassPart above)
//  and is used to reference objects in the class part of an instance. The 
//  layout of such a class part never changes, but the memory block itself can
//  move, hence the source.
//
//*****************************************************************************

class CClassPartPtr : public CPtrSource
{
protected:
    CClassPart* m_pPart;
    offset_t m_nOffset;
public:

	// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
	// signed/unsigned 32-bit value. (m_nOffset)  We do not
	// support length > 0xFFFFFFFF so cast is ok.

     CClassPartPtr(CClassPart* pPart, LPMEMORY pCurrent) 
        : m_pPart(pPart), m_nOffset( (offset_t) ( pCurrent - pPart->GetStart() ) ) {}
     LPMEMORY GetPointer() {return m_pPart->GetStart() + m_nOffset;}
};





class COREPROX_POLARITY CClassAndMethods : public CMethodPartContainer, 
                                    public CClassPartContainer
{
public:
    CClassPart m_ClassPart;
    CMethodPart m_MethodPart;
    CWbemClass* m_pClass;

public:
    LPMEMORY GetStart() {return m_ClassPart.GetStart();}

	// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
	// signed/unsigned 32-bit value.  We do not support length
	// > 0xFFFFFFFF so cast is ok.

    length_t GetLength() {return (length_t) ( EndOf(m_MethodPart) - GetStart() );}
    static length_t GetMinLength();

    void SetData(LPMEMORY pStart, CWbemClass* pClass, 
                    CClassAndMethods* pParent = NULL );
	static size_t ValidateBuffer(LPMEMORY start, size_t cbSize);
    void SetDataWithNumProps(LPMEMORY pStart, CWbemClass* pClass, 
			DWORD dwNumProperties, CClassAndMethods* pParent = NULL );
    void Rebase(LPMEMORY pStart);
    static LPMEMORY CreateEmpty(LPMEMORY pStart);
	static BOOL GetIndexedProps(CWStringArray& awsNames, LPMEMORY pStart);
	static HRESULT GetClassName( WString& wsClassName, LPMEMORY pStart);
	static HRESULT GetSuperclassName( WString& wsSuperClassName, LPMEMORY pStart);


    length_t EstimateDerivedPartSpace();
    LPMEMORY CreateDerivedPart(LPMEMORY pStart, length_t nAllocatedLength);

    length_t EstimateUnmergeSpace();
    LPMEMORY Unmerge(LPMEMORY pStart, length_t nAllocatedLength);

    static length_t EstimateMergeSpace(CClassAndMethods& ParentPart, 
                                       CClassAndMethods& ChildPart);

    static LPMEMORY Merge(CClassAndMethods& ParentPart, 
                          CClassAndMethods& ChildPart, 
                          LPMEMORY pDest, int nAllocatedLength);    

    static HRESULT Update(CClassAndMethods& ParentPart, 
                          CClassAndMethods& ChildPart,
						  long lFlags );

    EReconciliation CanBeReconciledWith(CClassAndMethods& NewPart);
    EReconciliation ReconcileWith(CClassAndMethods& NewPart);

	EReconciliation CompareTo( CClassAndMethods& thatPart );

    LPMEMORY CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pWhere, 
        BOOL& bRemovedKeys);

    void Compact();
public: // container functionality
    BOOL ExtendClassPartSpace(CClassPart* pPart, length_t nNewLength);
    void ReduceClassPartSpace(CClassPart* pPart, length_t nDecrement){}
    BOOL ExtendMethodPartSpace(CMethodPart* pPart, length_t nNewLength);
    void ReduceMethodPartSpace(CMethodPart* pPart, length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown();

    classindex_t GetCurrentOrigin();
};

//*****************************************************************************
//*****************************************************************************
//
//  class CWbemClass
//
//  Represents an WinMgmt class. Derived from CWbemObject and much of the
//  functionality is inherited.
//
//  The memory block of CWbemClass consists of three parts, one after another:
//
//  1) Decoration part (as described in CDecorationPart in fastobj.h) with the
//      information about the origins of the object. m_DecorationPart member
//      of CWbemObject mapos this data.
//  2) Parent class part containing all the information about my parent. Even
//      if this is a top-level class, this part is still present and pretends
//      that my parent is an unnamed class with no proeprties or qualifiers.
//      m_ParentPart member maps this data.
//  3) Actual class part containing all the information about this class.
//      m_CombinedPart member maps this data. It is called "combined" because
//      when a class is stored in the database, it is also in the form of a 
//      class part, but this one contains only the information that is 
//      different from my parent. Thus, when a class is loaded from the
//      database, the parent's part and the child's part are merged to produce
//      the combined part which becomes part of the in-memory object.
//
//  Since this class is derived from CWbemObject, it inherits all its functions.
//  Here, we describe only the functions implemented in CWbemClass.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function
//
//  PARAMETERS:
//
//      LPMEMORY pStart         The start of the memory block
//      int nTotalLength        The length of the memory block.
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t:       the length of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has moved.
//
//  PARAMETERS:
//
//      LPMEMORY pBlock     The new location of the memory block
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Computes the number of bytes required to hold an empty class definition.
//
//  RETURN VALUES:
//
//      length_t
//
//*****************************************************************************
//
//  CreateEmpty
//
//  Creates an empty class definition (without even a name) on a given block
//  of memory.
//
//  PARAMETERS:
//
//      LPMEMORY pStart     The memory block to create on.
//
//*****************************************************************************
//
//  EstimateDerivedClassSpace
//
//  Used when a derived class is created, this function (over-)estimates the
//  required space for a derived class (without any extra properties).
//
//  PARAMETERS:
//
//      CDecorationPart* pDecortation   Origin information to use. If NULL, the
//                                      estimate is for an undecorated class.
//  RETURN VALUES:
//
//      length_t;   the number of bytes required.
//
//*****************************************************************************
//
//  WriteDerivedClass
//
//  Creates the memory representation for a derived class with no extra 
//  properties or qualifiers (compared to ourselves).
//
//  PARAMETERS:
//
//      LPMEMORY pStart                 The memory block to write on. Assumed
//                                      to be large enough 
//                                      (see EstimateDerivedClassSpace)
//      CDecorationPart* pDecortation   Origin information to use. If NULL, the
//                                      estimate is for an undecorated class.
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the written data.
//
//*****************************************************************************
//
//  CreateDerivedClass
//
//  Initializes ourselves as a derived class of a given one. Allocates the
//  memory block.
//
//  PARAMETERS:
//
//      CWbemClass* pParent              Our parent class.
//      int nExtraSpace                 Extra space to pad the memory block.
//                                      This is for optimization only.
//      CDecorationPart* pDecortation   Origin information to use. If NULL, the
//                                      estimate is for an undecorated class.
//
//*****************************************************************************
//
//  EstimateUnmergeSpace
//
//  When a class is written to the database, only the information that is
//  different from the parent is written. That means that not only is 
//  m_CombinedPart the only part that is considered, but even it is further
//  "unmerged" to remove all the parent data.
//  This function estimates the amount of space that an unmerge would take.
//
//  RETURN VALUES:
//
//      length_t:   an (over-)estimate of the amount of space needed.
//
//*****************************************************************************
//
//  Unmerge
//
//  When a class is written to the database, only the information that is
//  different from the parent is written. That means that not only is 
//  m_CombinedPart the only part that is considered, but even it is further
//  "unmerged" to remove all the parent data.
//  This function creates this "unmerged" data which takes a form of a class
//  part.
//
//  PARAMETERS:
//
//      LPMEMORY pDest              Where to write to.
//      int nAllocatedLength        The size of the allocated block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   points to the first byte after the data written.
//
//*****************************************************************************
//
//  EstimateMergeSpace
//
//  As descrined in Unmerge, only a fraction of the class data is written to
//  the database. To recreate the class, one needs to take the parent class
//  (this) and merge it with the data from the database. This function
//  (over-)estimates the amount of space needed for the merge.
//
//  PARAMETERS:
//
//      LPMEMORY pChildPart             The data in the database
//      CDecorationPart* pDecoration    Origin information to use for the new
//                                      class. If NULL, create undecorated.
//  RETURN VALUES:
//
//      length_t:   (over-)estimate of the amount of space.
//
//*****************************************************************************
//
//  Merge
//
//  As descrined in Unmerge, only a fraction of the class data is written to
//  the database. To recreate the class, one needs to take the parent class
//  (this) and merge it with the data from the database. This function
//  creates the memory representation for the class given the parent (this) and
//  the database (unmerged) data.
//
//  PARAMETERS:
//
//      LPMEMORY pChildPart             The unmerged data in the database
//      LPMEMORY pDest                  Destination memory. Assumed to be large
//                                      enough (see EstimateMergeSpace)
//      int nAllocatedLength            Allocated size of the memory block.
//      CDecorationPart* pDecoration    Origin information to use for the new
//                                      class. If NULL, create undecorated.
//  RETURN VALUES:
//
//      LPMEMORY:   first byte after the data written
//
//*****************************************************************************
//
//  Update
//
//  As described in Unmerge, only a fraction of the class data is written to
//  the database. During an Update operation, a class may be reparented, in
//	which case its unmerged data needs to be merged with a potentially
//	destructive	class, so we will need to check what we are merging for potential
//	conflicts.
//
//  PARAMETERS:
//
//      CWbemClass*						pOldChild - Old Child class to update from.
//		long lFlags						Must be WBEM_FLAG_UPDATE_FORCE_MODE
//										or WBEM_FLAG_UPDATE_SAFE_MODE.
//		CWbemClass**					ppUpdatedChild - Storage for pointer to
//										updated child class.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR if successful
//
//*****************************************************************************
//
//  static CreateFromBlob
//
//  Helper function encapsulating Merge. Takes the parent class and the 
//  unmerged child class data from the database (see Merge and Unmerge for more
//  details) and creates the child class (allocating memory).
//
//  Parameters;
//
//      CWbemClass* pParent              The parent class
//      LPMEMORY pChildData             The unmerged child class data.
//
//  RETURN VALUES:
//
//      CWbemClass*: the newely created class. The caller must delete this
//          object when done.
//
//*****************************************************************************
//
//  InitEmpty
//
//  Creates an empty class. Allocates the data for the memory block. See
//  GetMinSpace for details.
//
//  PARAMETERS:
//
//      int nExtraMem       The amount of padding to add to the memory block.
//                          This is for optimization only.
//
//*****************************************************************************
//
//  CanBeReconciledWith
//
//  This method is called when a definition of a class is about to be replaced 
//  with another one. If the class has no instances or derived classes, such
//  an operation presents no difficulties. If it does, however, we need to be
//  careful not to break them. Thus, only the following changes are allowed:
//
//      1) Qualifier changes
//      2) Default value changes
//
//  PARAMETERS:
//
//      IN READONLY CWbemClass* pNewClass    The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          Can be reconciled --- i.e., compatible.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  ReconcileWith
//
//  See CanBeReconciledWith above. This method is the same, except that if
//  reconciliation is possible (e_Reconcilable is returned) this class part is
//  replaced with the new one (the size is adjusted accordingly).
//
//  PARAMETERS:
//
//      IN READONLY CWbemClass* pNewClass    The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          We have been replaced with the new part.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  CompareMostDerivedClass
//
//  This method is called when one needs to know if the most derived class
//	in a CWbemClass is different from the data contained in the supplied
//	class.  We do this by unmerging most derived class information from
//	the local class and the supplied class, and then performing a value by
//	value comparison of properties, methods and qualifiers.  All items must
//	match and be in	the same order.
//
//  PARAMETERS:
//
//      IN READONLY CWbemClass*	pOldClass - Class Data to compare to.
//
//  RETURN VALUES:
//
//  BOOL - TRUE if it has changed, FALSE if not
//      
//*****************************************************************************
//
//  MapLimitation
//
//  Produces an object representing a particular limitation on the objects, i.e.
//  which properties and what kinds of qualifiers should be in it.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      OUT CLimitationMapping* pMap    This mapping object (see fastprop.h) 
//                                      will be changed to reflect the 
//                                      parameters of the limitation. It can
//                                      then be used in CWbemInstance::
//                                      GetLimitedVersion function.
//  RETURNS:
//
//      BOOL:   TRUE.
//
//*****************************************************************************
//
//  FindLimitationError
//
//  Verifies if a limitation (based on the select clause) is a valid one, i.e.
//  that all the mentioned properties are indeed the properties of the class.
//
//  PARAMETERS:
//      
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//  RETURNS:
//
//      WString:    empty if no errors were found. If an invalid property was
//                  found, the name of that property is returned.
//
//*****************************************************************************
//
//  GetClassPart
//
//  Returns the pointer to the m_CombinedPart
//
//  RETURN VALUES:
//
//      CClassPart*: pointer to the class part describing this class.
//
//*****************************************************************************
//
//  GetProperty
//
//  Gets the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  PARAMETERS:
//
//      IN CPropertyInformation* pInfo  The information structure for the 
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has 
//      already been "found").
//
//*****************************************************************************
//
//  GetProperty
//
//  Returns the value of a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property to access.
//      OUT CVar* pVar          Destination for the value. Must not already
//                              contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the proeprty to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*	pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  SetPropValue
//
//  Sets the value of the property. The property will be added if not already 
//  present.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property to set.
//      IN CVar *pVal           The value to store in the property.
//      IN CIMTYPE ctType       Specifies the actual type of the property. If 0
//                              no type changes are required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_TYPE_MISMATCH     The value does not match the property type
//
//*****************************************************************************
//
//  SetPropQualifier
//
//  Sets the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  GetPropQualifier
//
//  Retrieves the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property or no such qualifier.
//
//*****************************************************************************
//
//  GetMethodQualifier
//
//  Retrieves the value of a given qualifier on a given method.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszMethod       The name of the method.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such method or no such qualifier.
//
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a qualifier from the class itself.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve.
//      OUT CVar* pVal          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//		BOOL fLocalOnly			Only get locals (default is TRUE)
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such qualifier.
//
//*****************************************************************************
//
//  GetNumProperties
//
//  Retrieves the number of properties in the object
//
//  RETURN VALUES:
//
//      int:
//
//*****************************************************************************
//
//  GetPropName
//
//  Retrieves the name of the property at a given index. This index has no 
//  meaning except inthe context of this enumeration. It is NOT the v-table
//  index of the property.
//
//  PARAMETERS:
//
//      IN int nIndex        The index of the property to retrieve. Assumed to
//                           be within range (see GetNumProperties).
//      OUT CVar* pVar       Destination for the name. Must not already contain
//                           a value.
//
//*****************************************************************************
//
//  IsKeyed
//
//  Verifies if this class has keys.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the object either has 'key' properties or is singleton.
//
//*****************************************************************************
//
//  IsKeyLocal
//
//  Verifies if the specified property is keyed locally.
//
//  RETURN VALUES:
//
//		BOOL:   TRUE if the property is a key and is defined as such locally
//
//*****************************************************************************
//
//  IsIndexLocal
//
//  Verifies if the specified property is Indexed locally.
//
//  RETURN VALUES:
//
//		BOOL:   TRUE if the property is an index and is defined as such locally
//
//*****************************************************************************
//
//  GetRelPath
//
//  Returns the class name --- that's the relative path to a class.
//  
//  RETURN VALUES:
//
//      LPCWSTR: the newnely allocated string containing the path or NULL on 
//              errors. The caller must delete this string.
//
//*****************************************************************************
//
//  Decorate
//
//  Sets the origin information for the object.
//
//  PARAMETERS:
//
//      LPCWSTR wszServer       the name of the server to set.
//      LPCWSTR wszNamespace    the name of the namespace to set.
//
//*****************************************************************************
//
//  Undecorate
//
//  Removes the origin informaiton from the object
//
//*****************************************************************************
//
//  CompactAll
//
//  Compacts memory block removing any
//  holes between components. This does not include heap compaction and thus
//  is relatively fast.
//
//*****************************************************************************
//
//  GetGenus
//
//  Retrieves the genus of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetClassName
//
//  Retrieves the class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetDynasty
//
//  Retrieves the dynasty of the object, i.e. the name of the top-level class
//  its class is derived from.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetSuperclassName
//
//  Retrieves the parent class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class is a top-levle class.
//
//*****************************************************************************
//
//  GetPropertyCount
//
//  Retrieves the number of proerpties in the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetIndexedProps
//
//  Returns the array of the names of all the proeprties that are indexed.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyProps
//
//  Returns the array of the names of all the proeprties that are keys.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  GetLimitedVersion
//
//  Produces a new CWbemClass based on this one and a limitation map 
//  (obtained from CWbemClass::MapLimitation, see fastcls.h).
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap     The map to use to limit the properties
//                                      and qualifiers to use in the new
//                                      instance.
//      OUT CWbemClass** ppNewClass    Destination for the new object May
//                                      not be NULL. The caller is responsible
//                                      for calling Release on this pointer 
//                                      when no longer needed.
//  RETURNS:
//
//      WBEM_S_NO_ERROR            On success
//      WBEM_E_FAILED              On errors (none to date).
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not any localization bits have been set.  Localization
//	bits can be in either the parent or the combined part.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the combined part.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************
//**************************** IWbemClassObject interface **********************
//
//  Most members of this interface are implemented in CWbemObject. Others are
//  implemented here. For the description of these methods and their return
//  values, see help
//
//*****************************************************************************

typedef CPropertyInformation CPropertyLocation;


class COREPROX_POLARITY CWbemClass : public CWbemObject
{
protected:
    length_t m_nTotalLength;
    //CDecorationPart m_DecorationPart;
    CClassAndMethods m_ParentPart;
    CClassAndMethods m_CombinedPart;

    int  m_nCurrentMethod;
    LONG m_FlagMethEnum;
	CLimitationMapping*	m_pLimitMapping;
    friend class CWbemInstance;

public:
     CWbemClass() 
        : m_ParentPart(), m_CombinedPart(), 
            CWbemObject(m_CombinedPart.m_ClassPart.m_Defaults, 
                        m_CombinedPart.m_ClassPart.m_Heap,
                        m_CombinedPart.m_ClassPart.m_Derivation),
        m_FlagMethEnum(WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY),
        m_nCurrentMethod(-1), m_pLimitMapping( NULL )
     {}
	 ~CWbemClass();
     void SetData(LPMEMORY pStart, int nTotalLength);
     length_t GetLength() {return m_nTotalLength;}
     void Rebase(LPMEMORY pMemory);

protected:
    HRESULT GetProperty(CPropertyInformation* pInfo, CVar* pVar)
	{ return m_CombinedPart.m_ClassPart.GetDefaultValue(pInfo, pVar); }

    DWORD GetBlockLength() {return m_nTotalLength;}
    CClassPart* GetClassPart() {return &m_CombinedPart.m_ClassPart;}
public:
    HRESULT GetProperty(LPCWSTR wszName, CVar* pVal);
    HRESULT SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType);
    HRESULT ForcePropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType);
    HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    virtual HRESULT GetQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);
    HRESULT SetQualifier(LPCWSTR wszName, CVar* pVal, long lFlavor = 0);
    HRESULT SetQualifier(LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue);
    HRESULT GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, CVar* pVar,
        long* plFlavor = NULL, CIMTYPE* pct = NULL);

    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, 
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);
	HRESULT FindMethod( LPCWSTR pwszMethod );

    HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType, 
							long* plFlavor = NULL);
     HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                   long* plFlags);


    HRESULT GetPropQualifier(CPropertyInformation* pInfo, 
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

    HRESULT GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet);

    HRESULT GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);


	BOOL IsLocalized( void );
	void SetLocalized( BOOL fLocalized );

     int GetNumProperties()
    {
        return m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties();
    }
    HRESULT GetPropName(int nIndex, CVar* pVal)
    {
		// Check for allocation failures
		 if ( !m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
				 m_CombinedPart.m_ClassPart.m_Properties.GetAt(nIndex)->ptrName)->
					StoreToCVar(*pVal) )
		 {
			 return WBEM_E_OUT_OF_MEMORY;
		 }

		 return WBEM_S_NO_ERROR;
    }

    HRESULT Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace);
    void Undecorate();

    BOOL IsKeyed() {return m_CombinedPart.m_ClassPart.IsKeyed();}
    BOOL IsDynamic() {return m_CombinedPart.m_ClassPart.IsDynamic();}
    BOOL IsSingleton() {return m_CombinedPart.m_ClassPart.IsSingleton();}
    BOOL IsAbstract() {return m_CombinedPart.m_ClassPart.IsAbstract();}
    BOOL IsAmendment() {return m_CombinedPart.m_ClassPart.IsAmendment();}
    BYTE GetAbstractFlavor() 
        {return m_CombinedPart.m_ClassPart.GetAbstractFlavor();}
    BOOL IsCompressed() {return m_CombinedPart.m_ClassPart.IsCompressed();}
    LPWSTR GetRelPath( BOOL bNormalized=FALSE );

    BOOL MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap);

    WString FindLimitationError(
        IN long lFlags,
        IN CWStringArray* pwsNames);
        
	HRESULT CreateDerivedClass( CWbemClass** ppNewClass );

	virtual HRESULT	IsValidObj( void );

public:
    static  length_t GetMinLength() 
    {
        return CDecorationPart::GetMinLength() + 
                    2* CClassAndMethods::GetMinLength();
    }
    static  LPMEMORY CreateEmpty(LPMEMORY pStart);
    void CompactAll();

    HRESULT CopyBlobOf(CWbemObject* pSource);

     length_t EstimateDerivedClassSpace(
        CDecorationPart* pDecoration = NULL);
    HRESULT WriteDerivedClass(LPMEMORY pStart, int nAllocatedLength,
        CDecorationPart* pDecoration = NULL);
     HRESULT CreateDerivedClass(CWbemClass* pParent, int nExtraSpace = 0, 
        CDecorationPart* pDecoration = NULL);

     length_t EstimateUnmergeSpace();
     HRESULT Unmerge(LPMEMORY pDest, int nAllocatedLength, length_t* pnUnmergedLength);

    static  CWbemClass* CreateFromBlob(CWbemClass* pParent, LPMEMORY pChildPart, size_t cbLenght);
    static size_t ValidateBuffer(LPMEMORY start, size_t cbMax);

    static  CWbemClass* CWbemClass::CreateFromBlob2(CWbemClass* pParent, LPMEMORY pChildPart,
    	                                                                            WCHAR * pszServer,WCHAR * pszNamespace);

     length_t EstimateMergeSpace(LPMEMORY pChildPart, long lenDecorPart);
     LPMEMORY Merge(LPMEMORY pChildPart, 
                               LPMEMORY pDest, 
                               int nAllocatedLength,
                               int DecorationSize);

     HRESULT Update( CWbemClass* pOldChild, long lFlags, CWbemClass** pUpdatedChild );

     HRESULT InitEmpty( int nExtraMem = 0, BOOL fCreateSystemProps = TRUE );

     EReconciliation CanBeReconciledWith(CWbemClass* pNewClass);
     EReconciliation ReconcileWith(CWbemClass* pNewClass);

	// This function will throw an exception in OOM scenarios.
	HRESULT CompareMostDerivedClass( CWbemClass* pOldClass );

    BOOL IsChildOf(CWbemClass* pClass);
public:
     HRESULT GetClassName(CVar* pVar)
        {return m_CombinedPart.m_ClassPart.GetClassName(pVar);}
     HRESULT GetSuperclassName(CVar* pVar)
        {return m_CombinedPart.m_ClassPart.GetSuperclassName(pVar);}
     HRESULT GetDynasty(CVar* pVar);
     HRESULT GetPropertyCount(CVar* pVar)
        {return m_CombinedPart.m_ClassPart.GetPropertyCount(pVar);}
     HRESULT GetGenus(CVar* pVar)
    {
        pVar->SetLong(WBEM_GENUS_CLASS);
        return WBEM_NO_ERROR;
    }

     BOOL GetIndexedProps(CWStringArray& awsNames)
        {return m_CombinedPart.m_ClassPart.GetIndexedProps(awsNames);}
     BOOL GetKeyProps(CWStringArray& awsNames)
        {return m_CombinedPart.m_ClassPart.GetKeyProps(awsNames);}
     HRESULT GetKeyOrigin(WString& wsClass)
        {return m_CombinedPart.m_ClassPart.GetKeyOrigin( wsClass );}

    HRESULT AddPropertyText(WString& wsText, CPropertyLookup* pLookup,
                                    CPropertyInformation* pInfo, long lFlags);
    HRESULT WritePropertyAsMethodParam(WString& wsText, int nIndex, 
                    long lFlags, CWbemClass* pDuplicateParamSet, BOOL fIgnoreDups );
    HRESULT GetIds(CFlexArray& adwIds, CWbemClass* pDupParams = NULL);
    HRESULT EnsureQualifier(LPCWSTR wszQual);

    HRESULT GetLimitedVersion(IN CLimitationMapping* pMap, 
                              NEWOBJECT CWbemClass** ppNewObj);

	BOOL IsKeyLocal( LPCWSTR pwcsKeyProp );
	BOOL IsIndexLocal( LPCWSTR pwcsIndexedProp );

public: // container functionality
    BOOL ExtendClassAndMethodsSpace(length_t nNewLength);
    void ReduceClassAndMethodsSpace(length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown() 
        {return (IUnknown*)(IWbemClassObject*)this;}
    classindex_t GetCurrentOrigin() {return m_CombinedPart.m_ClassPart.GetCurrentOrigin();}

    HRESULT ForcePut(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);

public:
    STDMETHOD(GetQualifierSet)(IWbemQualifierSet** ppQualifierSet);
    //STDMETHOD(Get)(BSTR Name, long lFlags, VARIANT* pVal, long* plType, long* plFlavor);
    STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    STDMETHOD(Delete)(LPCWSTR wszName);
    //STDMETHOD(GetNames)(LPCWSTR wszQualifierName, long lFlags, VARIANT* pVal, 
    //                    SAFEARRAY** pNames);
    //STDMETHOD(BeginEnumeration)(long lEnumFlags)
    //STDMETHOD(Next)(long lFlags, BSTR* pstrName, VARIANT* pVal)
    //STDMETHOD(EndEnumeration)()
    STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty, 
                                       IWbemQualifierSet** ppQualifierSet);        
    STDMETHOD(Clone)(IWbemClassObject** ppCopy);
    STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);
    STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
    STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);
    STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);

    STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig);
    STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig);
    STDMETHOD(DeleteMethod)(LPCWSTR wszName);
    STDMETHOD(BeginMethodEnumeration)(long lFlags);
    STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
    STDMETHOD(EndMethodEnumeration)();
    STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName);

    STDMETHOD(SetInheritanceChain)(long lNumAntecedents, 
        LPWSTR* awszAntecedents);
    STDMETHOD(SetPropertyOrigin)(LPCWSTR wszPropertyName, long lOriginIndex);
    STDMETHOD(SetMethodOrigin)(LPCWSTR wszMethodName, long lOriginIndex);

	// _IWmiObject Methods
    STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts )
	{ return E_NOTIMPL; }

    STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed )
	{ return E_NOTIMPL; }

    STDMETHOD(StripClassPart)()		{ return E_NOTIMPL; }

    STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
	{ return E_NOTIMPL; }
    STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize )
	{ return E_NOTIMPL; }
    STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart )
	{ return E_NOTIMPL; }

	STDMETHOD(ClearWriteOnlyProperties)(void)
	{ return WBEM_E_INVALID_OPERATION; }

	// _IWmiObject Methods
	STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject );
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

	STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance );
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass );
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass );
	// Compares the derived most class information of two class objects.

    STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass );
	// Creates a limited representation class for projection queries

    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance );
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj );
	// Merges a blob with the current object memory and creates a new object

	STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj );
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild );
	// Upgrades class and instance objects

	STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass );
	// Updates derived class object using the safe/force mode logic

	STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst );
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.

	STDMETHOD(GetParentClassFromBlob)( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass );
	// Returns the parent class name from a BLOB

	STDMETHOD(CloneAndDecorate)(long lFlags,WCHAR * pszServer,WCHAR * pszNamespace,IWbemClassObject** ppDestObject);	

	STDMETHOD(MergeAndDecorate)(long lFlags,ULONG uBuffSize,LPVOID pbData,WCHAR * pServer,WCHAR * pNamespace,_IWmiObject** ppNewObj);
};

//#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastheap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTHEAP.CPP

Abstract:

  This file defines the heap class used in WbemObjects.

  Classes defined: 
      CFastHeap   Local movable heap class.

History:

  2/20/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h" 
#include "faster.h"
#include "fastheap.h"

LPMEMORY CFastHeap::CreateEmpty(LPMEMORY pStart)
{
    *(PLENGTHT)pStart = OUTOFLINE_HEAP_INDICATOR;
    return pStart + sizeof(length_t);
}

LPMEMORY CFastHeap::CreateOutOfLine(LPMEMORY pStart, length_t nLength)
{
    m_pContainer = NULL;

    *(PLENGTHT)pStart = nLength | OUTOFLINE_HEAP_INDICATOR;

    m_pHeapData = pStart + sizeof(length_t);
    m_pHeapHeader = &m_LocalHeapHeader;

    m_pHeapHeader->nAllocatedSize = nLength;
#ifdef MAINTAIN_FREE_LIST
    m_pHeapHeader->ptrFirstFree = INVALID_HEAP_ADDRESS;
#endif
    m_pHeapHeader->nDataSize = 0;
    m_pHeapHeader->dwTotalEmpty = 0;

    return pStart + sizeof(length_t) + nLength;
}


BOOL CFastHeap::SetData(LPMEMORY pData, CHeapContainer* pContainer)
{
    m_pContainer = pContainer;

    if((*(PLENGTHT)pData) & OUTOFLINE_HEAP_INDICATOR)
    {
        m_pHeapData = pData + sizeof(length_t);
        m_pHeapHeader = &m_LocalHeapHeader;

        m_pHeapHeader->nAllocatedSize = 
            (*(PLENGTHT)pData) & ~OUTOFLINE_HEAP_INDICATOR;
#ifdef MAINTAIN_FREE_LIST
        m_pHeapHeader->ptrFirstFree = INVALID_HEAP_ADDRESS;
#endif
        m_pHeapHeader->nDataSize = m_pHeapHeader->nAllocatedSize;
        m_pHeapHeader->dwTotalEmpty = 0;
    }
    else
    {
        m_pHeapHeader = (CHeapHeader*)pData;
        m_pHeapData = pData + sizeof(CHeapHeader);
    }
    return TRUE;
}

size_t CFastHeap::ValidateBuffer(LPMEMORY start, size_t cbSize)
{
size_t step = sizeof(length_t);

if (step > cbSize ) throw CX_Exception();

CFastHeap probe;
probe.SetData(start, 0);
if (!probe.IsOutOfLine())
	{
	step = sizeof(CHeapHeader);	
	if (step > cbSize ) throw CX_Exception();
	}

step = probe.GetRealLength();

if (step > cbSize ) throw CX_Exception();
return step;	
};

void CFastHeap::SetInLineLength(length_t nLength)
{
    *(GetInLineLength()) = nLength | OUTOFLINE_HEAP_INDICATOR;
}

void CFastHeap::SetAllocatedDataLength(length_t nLength)
{
    m_pHeapHeader->nAllocatedSize = nLength;
    if(IsOutOfLine()) 
        SetInLineLength(nLength);
}

void CFastHeap::Rebase(LPMEMORY pNewMemory)
{
    if(IsOutOfLine())
    {
        m_pHeapData = pNewMemory + sizeof(length_t);
    }
    else
    {
        m_pHeapHeader = (CHeapHeader*)pNewMemory;
        m_pHeapData = pNewMemory + sizeof(CHeapHeader);
    }
}

BOOL CFastHeap::Allocate(length_t nLength, UNALIGNED heapptr_t& ptrResult )
{
#ifdef MAINTAIN_FREE_LIST
    // TBD
#endif
    // First, check if there is enough space at the end
    // ================================================

    length_t nLeft = m_pHeapHeader->nAllocatedSize - m_pHeapHeader->nDataSize;
    if(nLeft < nLength)
    {
        // Need more room!
        // ===============

        length_t nExtra = AugmentRequest(GetAllocatedDataLength(), nLength - nLeft);

        // this is the case where the Limitation Mapping is Out-Of-Sync with the instance
        if (!m_pContainer) throw CX_Exception();

        // Check for allocation failure
        if ( !m_pContainer->ExtendHeapSize(GetStart(), GetLength(), nExtra) )
        {
            return FALSE;
        }

        SetAllocatedDataLength(GetAllocatedDataLength() + nExtra);
    }

    // Now we have enough room at the end, allocate it
    // ===============================================

    ptrResult = m_pHeapHeader->nDataSize;
    m_pHeapHeader->nDataSize += nLength;

    return TRUE;
}

BOOL CFastHeap::Extend(heapptr_t ptr, length_t nOldLength, 
                          length_t nNewLength)
{
    // Check if we are at the end of used area
    // =======================================

    if(ptr + nOldLength == m_pHeapHeader->nDataSize)
    {
        // Check if there is enough allocated space
        // ========================================

        if(ptr + nNewLength <= m_pHeapHeader->nAllocatedSize)
        {
            m_pHeapHeader->nDataSize += nNewLength - nOldLength;
            return TRUE;
        }
        else return FALSE;
    }
    else return FALSE;
}

void CFastHeap::Reduce(heapptr_t ptr, length_t nOldLength, 
                          length_t nNewLength)
{
    // Check if we are at the end of used area
    // =======================================

    if(ptr + nOldLength == m_pHeapHeader->nDataSize)
    {
        m_pHeapHeader->nDataSize -= nOldLength - nNewLength;
    }
}

void CFastHeap::Copy(heapptr_t ptrDest, heapptr_t ptrSource, 
                            length_t nLength)
{
    memmove((void*)ResolveHeapPointer(ptrDest), 
        (void*)ResolveHeapPointer(ptrSource), nLength);
}

BOOL CFastHeap::Reallocate(heapptr_t ptrOld, length_t nOldLength,
        length_t nNewLength, UNALIGNED heapptr_t& ptrResult )
{
    if(nOldLength >= nNewLength)
    {
        Reduce(ptrOld, nOldLength, nNewLength);
        ptrResult = ptrOld;
        return TRUE;
    }
    if(Extend(ptrOld, nOldLength, nNewLength)) 
    {
        ptrResult = ptrOld;
        return TRUE;
    }
    else 
    {
        // TBD: wastes space if old area was at the end.

        heapptr_t ptrNew;

        // Check that this allocation succeeds
        BOOL fReturn = Allocate(nNewLength, ptrNew);

        if ( fReturn )
        {
            Copy(ptrNew, ptrOld, nOldLength);
            Free(ptrOld, nOldLength);
            ptrResult = ptrNew;
        }

        return fReturn;
    }
}

BOOL CFastHeap::AllocateString(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult)
{
    int nSize = CCompressedString::ComputeNecessarySpace(wszString);

    // Check for allocation failure
    BOOL fReturn = Allocate(nSize, ptrResult);

    if ( fReturn )
    {
        CCompressedString* pcsString = (CCompressedString*)ResolveHeapPointer(ptrResult);
        pcsString->SetFromUnicode(wszString);
    }

    return fReturn;
}

BOOL CFastHeap::AllocateString(COPY LPCSTR szString, UNALIGNED heapptr_t& ptrResult)
{
    int nSize = CCompressedString::ComputeNecessarySpace(szString);

    // Check for allocation failure
    BOOL fReturn = Allocate(nSize, ptrResult);

    if ( fReturn )
    {
        CCompressedString* pcsString = (CCompressedString*)ResolveHeapPointer(ptrResult);
        pcsString->SetFromAscii(szString, nSize);
    }

    return fReturn;
}

BOOL CFastHeap::CreateNoCaseStringHeapPtr(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult)
{
    int     nKnownIndex = CKnownStringTable::GetKnownStringIndex(wszString);
    BOOL    fReturn = TRUE;

    if(nKnownIndex < 0)
    {
        // Check for allocation failure
        fReturn = AllocateString(wszString, ptrResult);
        //ResolveString(ptr)->MakeLowercase();
    }
    else
    {
        ptrResult = CFastHeap::MakeFakeFromIndex(nKnownIndex);
    }

    return fReturn;
}

void CFastHeap::Free(heapptr_t ptr, length_t nSize)
{
    if(IsFakeAddress(ptr)) return;

    // Check if it is at the end of the allocated area
    // ===============================================

    if(ptr + nSize == m_pHeapHeader->nDataSize)
    {
        m_pHeapHeader->nDataSize = ptr;
        return;
    }

#ifdef MAINTAIN_FREE_LIST

    // Add it to the free list
    // =======================

    if(nSize >= sizeof(CFreeBlock))
    {
        CFreeBlock* pFreeBlock = (CFreeBlock*)ResolveHeapPointer(ptr);
        pFreeBlock->ptrNextFree = m_pHeapHeader->ptrFirstFree;
        pFreeBlock->nLength = nSize;

        m_pHeapHeader->ptrFirstFree = ptr;
    }
#endif
    m_pHeapHeader->dwTotalEmpty += nSize;
}

void CFastHeap::FreeString(heapptr_t ptrString)
{
    if(IsFakeAddress(ptrString)) return;
    CCompressedString* pcs = (CCompressedString*)ResolveHeapPointer(ptrString);
    Free(ptrString, pcs->GetLength());
}

void CFastHeap::Trim()
{
    if(m_pContainer)
    {
        if (EndOf(*this) > m_pContainer->GetMemoryLimit()) throw CX_Exception();
    }
	memset(GetHeapData()+m_pHeapHeader->nDataSize, 
		   0, 
		   m_pHeapHeader->nAllocatedSize - m_pHeapHeader->nDataSize);
	
    if(m_pContainer)
        m_pContainer->ReduceHeapSize(GetStart(), GetLength(), 
            m_pHeapHeader->nAllocatedSize - m_pHeapHeader->nDataSize);

    SetAllocatedDataLength(m_pHeapHeader->nDataSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastembd.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTEMBD.CPP

Abstract:

    This file implements out-of-line functions for the classes related to 
    embedded objects.

    For complete documentation of all classes and methods, see fastcls.h

History:

    3/10/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
#include "wbemutil.h"
#include "fastall.h"
#include "fastembd.h"
#include "fastobj.h"
#include "corex.h"





void CEmbeddedObject::ValidateBuffer(LPMEMORY start, size_t lenght, DeferedObjList& embededList)
{	 
	 if((*start & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_CLASS)
     {
            CWbemClass::ValidateBuffer(start, lenght);	 
	 } 
	 else if((*start & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_INSTANCE)
	 {
            CWbemInstance::ValidateBuffer(start, lenght, embededList);	 
	 }
	 else
	 {
		 throw CX_Exception();
	 }
};

CWbemObject* CEmbeddedObject::GetEmbedded()
{
    if(m_nLength == 0) return NULL;

    LPMEMORY pNewMemory = g_CBasicBlobControl.Allocate(m_nLength);

    if ( NULL == pNewMemory )
    {
        throw CX_MemoryException();
    }

    memcpy(pNewMemory, &m_byFirstByte, m_nLength);

    CWbemObject*    pObj = CWbemObject::CreateFromMemory(pNewMemory, m_nLength, TRUE,g_CBasicBlobControl);

    // Check for OOM
    if ( NULL == pObj )
    {
        throw CX_MemoryException();
    }

    return pObj;
}

length_t CEmbeddedObject::EstimateNecessarySpace(CWbemObject* pObject)
{
    if(pObject == NULL) return sizeof(length_t);
    pObject->CompactAll();

    // If it's an instance, we need to worry that the class part could be merged
    if ( pObject->IsInstance() )
    {
        DWORD   dwParts;

        pObject->QueryPartInfo( &dwParts );

        // Check the flags
        if (    (   dwParts & WBEM_OBJ_CLASS_PART   )
            &&  (   dwParts & WBEM_OBJ_CLASS_PART_SHARED    )   )
        {
            DWORD   dwLength = 0;

            // This will get us the full lengths of these parts
            pObject->GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwLength );

            // Account for the additional length_t
            return ( dwLength + sizeof(length_t) );
        }
        else
        {
            return pObject->GetBlockLength() + sizeof(length_t);
        }
    }
    else
    {
        return pObject->GetBlockLength() + sizeof(length_t);
    }

}

void CEmbeddedObject::StoreEmbedded(length_t nLength, CWbemObject* pObject)
{
    if(pObject == NULL)
    {
        m_nLength = 0;
    }
    else
    {
        m_nLength = nLength - sizeof(m_nLength);

        if ( NULL != pObject )
        {
            if ( pObject->IsInstance() )
            {
                DWORD   dwParts;

                // Check the flags
                pObject->QueryPartInfo( &dwParts );

                if (    (   dwParts & WBEM_OBJ_CLASS_PART   )
                    &&  (   dwParts & WBEM_OBJ_CLASS_PART_SHARED    )   )
                {
                    DWORD   dwLength = 0;

                    // This will write out the ENTIRE object.  If it fails, throw and exception
                    if ( FAILED( pObject->GetObjectParts( &m_byFirstByte, m_nLength, WBEM_INSTANCE_ALL_PARTS, &dwLength ) ) )
                    {
                        throw CX_MemoryException();
                    }

                }
                else
                {
                    memcpy(&m_byFirstByte, pObject->GetStart(), pObject->GetBlockLength());
                }
            }
            else
            {
                memcpy(&m_byFirstByte, pObject->GetStart(), pObject->GetBlockLength());
            }

        }   // IF we got an object

    }   // redundant check
    
}





void CEmbeddedObject::StoreToCVar(CVar& Var)
{
    // No allocations performed here
    I_EMBEDDED_OBJECT* pEmbed = 
        (I_EMBEDDED_OBJECT*)(IWbemClassObject*)GetEmbedded();
    Var.SetEmbeddedObject(pEmbed);
    if(pEmbed) pEmbed->Release();
}

void CEmbeddedObject::StoreEmbedded(length_t nLength, CVar& Var)
{
    I_EMBEDDED_OBJECT* pEmbed = Var.GetEmbeddedObject();
    StoreEmbedded(nLength, (CWbemObject*)(IWbemClassObject*)pEmbed);
    if(pEmbed) pEmbed->Release();
}

length_t CEmbeddedObject::EstimateNecessarySpace(CVar& Var)
{
    I_EMBEDDED_OBJECT* pEmbed = Var.GetEmbeddedObject();
    length_t nLength = 
        EstimateNecessarySpace((CWbemObject*)(IWbemClassObject*)pEmbed);
    if(pEmbed) pEmbed->Release();
    return nLength;
}

BOOL CEmbeddedObject::CopyToNewHeap(heapptr_t ptrOld,
                                         CFastHeap* pOldHeap,
                                         CFastHeap* pNewHeap,
                                         UNALIGNED heapptr_t& ptrResult)
{
    CEmbeddedObject* pOld = (CEmbeddedObject*)
        pOldHeap->ResolveHeapPointer(ptrOld);
    length_t nLength = pOld->GetLength();

    // Check for meory allocation failure
    heapptr_t ptrNew;
    BOOL    fReturn = pNewHeap->Allocate(nLength, ptrNew);

    if ( fReturn )
    {
        memcpy(pNewHeap->ResolveHeapPointer(ptrNew), pOld, nLength);
        ptrResult = ptrNew;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastheap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTHEAP.H

Abstract:

  This file defines the heap class used in WbemObjects.

  Classes defined: 
      CFastHeap   Local movable heap class.

History:

  2/20/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_HEAP__H_
#define __FAST_HEAP__H_

#include "fastsprt.h"
#include "faststr.h"

//#pragma pack(push, 1)

#define FAKE_HEAP_ADDRESS_INDICATOR MOST_SIGNIFICANT_BIT_IN_DWORD
#define OUTOFLINE_HEAP_INDICATOR MOST_SIGNIFICANT_BIT_IN_DWORD

#define INVALID_HEAP_ADDRESS 0xFFFFFFFF

//*****************************************************************************
//
//  CHeapHeader
//
//  This pseudo-structure preceeds the actual heap data in the memory block.
//  It starts with:
// 
//      length_t nAllocatedSize     The total amount of bytes allocated for
//                                  the heap data (not including the header)
//
//  If the most significant bit is set in nAllocatedSize, then the heap header
//  is assumed to be in a compressed form: no data other than nAllocatedSize
//  is present. This is convinient for many small read-only heaps. Such a heap
//  is referred to as out-of-line.
//
//  Otherwise (the most significant bit is not set in nAllocatedSize), the 
//  following two fields come right after nAllocatedSize:
//
//      length_t nDataSize          The upper bound of the highest actual
//                                  allocation in the heap. In other words,
//                                  it is guaranteed that everything above
//                                  nDataSize (through nAllocatedSize) is 
//                                  currently unused.
//
//      DWORD dwTotalFree           The total number of "holes", i.e., 
//                                  wasted space in the first nDataSize bytes
//                                  of the heap.
//
//  Such a heap is called in-line.
//
//*****************************************************************************

// The data in this structure is unaligned
#pragma pack(push, 1)
struct CHeapHeader
{
    length_t nAllocatedSize; // if msb is set, next 3 fields are omitted
    length_t nDataSize;
#ifdef MAINTAIN_FREE_LIST
    heapptr_t ptrFirstFree;
#endif
    DWORD dwTotalEmpty;
};
#pragma pack(pop)

#ifdef MAINTAIN_FREE_LIST
// The data in this structure is unaligned
#pragma pack(push, 1)
struct CFreeBlock
{
    length_t nLenght;
    heapptr_t ptrNextFree;
};
#pragma pack(pop)
#endif


//*****************************************************************************
//*****************************************************************************
//
//  class CHeapContainer
//
//  This abstract base class represents the capabilities that the CFastHeap
//  object requires from its container (in the sense of memory blocks; for
//  instance, a class part will "contain" a heap).
//
//*****************************************************************************
//
//  ExtendHeapSize = 0
//
//  CFastHeap will call this function when it runs out of space in its 
//  nAllocatedSize bytes. If this function determines that there is empty
//  space at the end of the current heap, it can simply mark it as occupied by
//  the heap and return. Otherwise, it must move the heap to another, large
//  enough block and inform the heap about its new location (see MoveBlock and
//  CopyBlock functions in fastsprt.h).
//
//  CFastHeap will automatically augment its requests to optimize reallocation/
//  wasted memory.
//
//  Parameters:
//
//      LPMEMORY pStart     The beginning of the heap's current memory block
//      length_t nOldLength Current length of the memory block
//      length_t nNewLength Required length of the memory block.
//
//*****************************************************************************
//
//  ReduceHeapSize
//
//  CFastHeap might call this function when it wants to return some space to
//  the container, but it never does.
//
//  Parameters:
//
//      LPMEMORY pStart     The beginning of the heap's current memory block
//      length_t nOldLength Current length of the memory block
//      length_t nDecrement How much space to return.
//      
//*****************************************************************************


class CHeapContainer
{
public:
    virtual BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, 
        length_t nExtra) = 0;
    virtual void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength,
        length_t nDecrement) = 0;
    virtual LPMEMORY GetMemoryLimit() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CFastHeap
//
//  This class represents a local heap implementation. The heap is a part of
//  every class's or instance's memory block --- this is where variable-length
//  structures are stored. The heap as currently implemented is rather 
//  primitive and is optimized for speed of access, not memory conservation. It
//  as assumed that objects have rather short lifetimes and heap compression 
//  is always performed automatically during object Merge/Unmerge opearations,
//  so the inefficiency does not propagate to disk.
//
//  The structure of the heap is that CHeapHeader (described above) followed by
//  the actual heap data. 
//
//  Items on the heap are represented as 'heap pointers' of type heapptr_t.
//  In actuality, these 'pointers' are offsets from the beginning of the data.
//  Thus, 0 is a valid heapptr_t and points to the very first item created.
//
//  The most significant bit of a heapptr_t may not be set in a valid
//  address. These 'fake' heap pointers are often used to represents offsets
//  into the known string table (see faststr,h). Thus, while heapptr_t of 1 
//  would indicate data at offset 1, heapptr_t of -2 would indicate a known
//  string with index of 2.
//
//**************************** members ****************************************
//
//  LPMEMORY m_pHeapData            The actual data on the heap.
//  CHeapHeader* m_pHeapHeader      Points to the heap header currently in use.
//                                  If the heap's own header (in the block) is
//                                  complete, m_pHeapHeader points ot it. 
//                                  Otherwise, it points to m_LocalHeapHeader.
//  CHeapHeader m_LocalHeapHeader   If the heap's own header (in the block) is
//                                  complete, this structure is unused. 
//                                  Otherwise, it contains the temporary copy
//                                  of the complete heap header data, as it is
//                                  necessary for the day-to-day operations.
//  CHeapContainer* m_pContainer    Points to the object whose block contains
//                                  our block (class part or instance part).
//                                  This member may be NULL if the heap is
//                                  used as read-only (see CreateOutOfLine).
//
//*****************************************************************************
//
//  SetData
//
//  Used to bind the CFastHeap object to a particular memory block which 
//  already contains a heap.
//
//  Parameters:
//
//      LPMEMORY pData                  The memory block to bind to. CFastHeap
//                                      assumes this memory last until Rebase
//                                      is called or this object is destroyed.
//      CHeapContainer* pContainer      The object whose memory block contains
//                                      ours. Assumed to survive longer than we
//                                      do (CFastHeap will not delete it).
//
//*****************************************************************************
//
//  CreateOutOfLine
//
//  Creates an empty out-of-line heap on the memory provided. See CHeapHeader
//  for description of in-line vs. out-of-line heap.
//
//  Parameters:
//
//      LPMEMORY pStart                 Points to the memory block to party on.      
//                                      Must be large enough to contain nLength
//                                      bytes of data plus the out-of-line 
//                                      header (GetMinLength()).
//      length_t nLength                Desired size of the data area.
//
//  Note:
//
//      
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns the minimum number of bytes required for an out-of-line heap.
//  See CHeapHeader for description of in-line vs. out-of-line heap.
//
//  Returns:
//
//      int 
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an out-of-line heap of length 0 on a piece of memory. See also
//  CreateOutOfLine.
//
//  Parameters:
//
//      LPMEMORY pMemory
//
//*****************************************************************************
//
//  SetContainer
//
//  Sets the container of the heap. The old container pointer is discarded.
//
//  Parameters:
//
//      CHeapContainer* pContainer      The new container pointer. 
//                                      Assumed to survive longer than we do 
//                                      (CFastHeap will not delete it).
//
//*****************************************************************************
//
//  GetStart
//
//  Returns the pointer to the beginning of the heap's memory block.
//
//  Returns:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      the length of the heap's memory block.
//
//*****************************************************************************
//
//  Skip
//
//  Returns:
//
//      LPMEMORY:   the pointer to the first byte following the heap's memory
//                  block.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has been moved.  The old memory
//  block may have already been deallocated, so the object will not touch the
//  old memory in any way.
//
//  Parameters:
//
//      LPMEMORY pMemory    Points to the new memory block. It is guaranteed to
//                          already cointain the heap's data. 
//
//*****************************************************************************
//
//  Empty
//
//  Remove all data allocations and bring the heap to the empty state.
//
//*****************************************************************************
//
//  GetUsedLength
//
//  Returns:
//
//      length_t    N such that all data allocations on the heap reside inside
//                  the first N bytes of the data area. In other words, the
//                  area above N is completely unused.
//
//*****************************************************************************
//
//  ResolveHeapPointer
//
//  'pointer' dereferencing function.
//
//  Parameters:
//
//      heapptr_t ptr       The 'pointer' to the data on the heap (see header
//                          for more information.
//  Returns:
//
//      LPMEMORY: the real pointer to the data referenced by ptr. Note, that,
//                  as with most real pointers to the inside of a block, it
//                  is temporary and will be invalidated the moment the block
//                  moves.
//
//*****************************************************************************
//
//  IsFakeAddress
//
//  Determines if a heapptr_t is not a real heap address but rather is
//  an index in the known string table (see faststr.h).
//
//  Parameters:
//
//      heapptr_t ptr   The heap pointer to examine.
//      
//  Returns:
//
//      BOOL:   TRUE iff the address is not a real heap address but rather is
//              an index in the known string table (see faststr.h).
//
//*****************************************************************************
//
//  GetIndexFromFake
//
//  Converts a fake heap address (see header) into the index in the known
//  string table.
//
//  Parameters:
//
//      heapptr_t ptr   The fake heap address to convert (must be fake,
//                      otherwise results are unpredictable. See IsFakeAddress)
//  Returns:
//      
//      int:    the index of the known string (see faststr.h) represented by 
//              this heap address.
//
//*****************************************************************************
//
//  MakeFakeFromIndex
//
//  Creates a fake heap address from an known string index (see class header 
//  and faststr.h).
//
//  Parameters:
//
//      int nIndex      The know string index to convert.
//
//  Returns:
//
//      heapptr_t:  a fake heap pointer representing that known string.
//
//*****************************************************************************
//
//  ResolveString
//
//  Returns a CCompressedString at a given heap pointer. This works whether the
//  pointer is real or fake.
//
//  Parameters:
//
//      heapptr_t ptr   
//
//  Returns:
//
//      CCompressedString*:     this pointer will point inside the heap if the
//          heap pointer was real (in which case the returned pointer is 
//          temporary) or into the known string table (see faststr.h) if the
//          heap pointer was fake.
//
//*****************************************************************************
//
//  Allocate
//
//  'Allocates' memory on the heap. If there is not enough room, the heap is
//  automatically grown (possibly causing the whole object to relocate).
//
//  Parameters:
//
//      length_t nLength    numbed of bytes to allocate.
//
//  Returns:
//
//      heapptr_t:  the heap pointer to the allocated area. There is no 
//                  not-enough-memory condition here.
//
//*****************************************************************************
//
//  Extend
//
//  Extends a given area on the heap if there is enough space at the end. See
//  also Reallocate.
//
//  Parameters:
//
//      heapptr_t ptr           The area to extend.
//      length_t nOldLength     Current length of the area.
//      length_t nNewLength     Desired length.
//      
//  Returns:
//
//      BOOL:   TRUE if successful, FALSE if there was not enough space.
//
//*****************************************************************************
//
//  Reduce
//
//  Reduces the size of a given area on the heap, allowing the heap to reclaim
//  the extra space.
//
//  Parameters:
//
//      heapptr_t ptr           The area to extend.
//      length_t nOldLength     Current length of the area.
//      length_t nNewLength     Desired length.
//      
//*****************************************************************************
//
//  Reallocate
//
//  Fulfills a request to increase the size of a given area on the heap, either
//  through growth (see Extend) or, if there is not enough space to extend it,
//  through reallocation. In the case of reallocation, the contents of the old
//  area are copied to the new and the old area is released. If there is not
//  enough room to allocate the data on the heap, the heap itself is grown.
//
//  Parameters:
//
//      heapptr_t ptr           The area to extend.
//      length_t nOldLength     Current length of the area.
//      length_t nNewLength     Desired length.
//      
//  Returns:
//
//      heapptr_t:  the heap pointer to the newely allocated area. No out-of-
//                  memory handling exists.
//
//*****************************************************************************
//
//  AllocateString
//
//  A helper function for allocating a compressed string on the heap based on
//  a conventional string. It allocates enough space for a compressed
//  representation of the string (see faststr.h) creates CCompressedString on
//  that area, and returns the heap pointer to it.
//
//  Parameters I:
//
//      LPCSTR szString
//
//  Parameters II:
//
//      LPCWSTR wszSting
//
//  Returns:
//
//      heapptr_t:  the heap pointer to the newely allocated area. No out-of-
//                  memory handling exists.
//
//*****************************************************************************
//      
//  CreateNoCaseStringHeapPtr
//
//  A helper function. Given a string, it looks it up in the known string
//  table (faststr.h) and, if successful returns a fake pointer representing 
//  the index (see class header). If not found, it allocates a 
//  CCompressedString on the heap and returns the real heap pointer to it.
//
//  Since known string table searches are case-insensitive, 'NoCase' appears
//  in the name. However, if the string is allocates on the heap, its case
//  is preserved.
//
//  Parameters:
//
//      LPCWSTR wszString
//
//  Returns:
//
//      heapptr_t:  the heap pointer. No out-of-memory handling exists.
//
//*****************************************************************************
//      
//  Free
//
//  Frees an area on the heap. Can be used with a fake pointer, in which case
//  it's a noop.
//
//  Parameters:
//
//      heapptr_t ptr       The heap pointer to free.
//      length_t nLength    The length of the area.
//
//*****************************************************************************
//
//  FreeString
//
//  Frees an area on the heap occupied by a string. The advantage of this 
//  function is that it determines the length of the area itself from the
//  string. Can be used with a fake pointer, in which case it's a noop.
//
//  Parameters:
//
//      heapptr_t ptr       The heap pointer to free.
//
//*****************************************************************************
//
//  Copy
//
//  Copies a given number of bytes from one heap location to another. Uses
//  memcpy, so THE AREAS MAY NOT OVERLAP!
//
//  Parameters:
//
//      heapptr_t ptrDest       Destination heap pointer.
//      heapptr_t ptrSrc        Source heap pointer.
//      length_t nLength        Numbed of bytes to copy.
//
//*****************************************************************************
//
//  Trim
//
//  Causes the heap to release all its unused memory (above GetUsedLength) to
//  its container (see CHeapContainer).
//
//*****************************************************************************

class COREPROX_POLARITY CFastHeap
{
protected:
    LPMEMORY m_pHeapData;
    CHeapHeader* m_pHeapHeader;
    CHeapHeader m_LocalHeapHeader;
    CHeapContainer* m_pContainer;

protected:
    BOOL IsOutOfLine() {return m_pHeapHeader == &m_LocalHeapHeader;}
    PLENGTHT GetInLineLength() {return ((PLENGTHT)m_pHeapData)-1;}
    void SetInLineLength(length_t nLength);

    length_t GetHeaderLength()
        {return (IsOutOfLine()) ? sizeof(length_t) : sizeof(CHeapHeader);}

public:
    BOOL SetData(LPMEMORY pData, CHeapContainer* pContainer);
	static size_t ValidateBuffer(LPMEMORY start, size_t cbSize);
	LPMEMORY GetHeapData( void )
	{ return m_pHeapData; }

    LPMEMORY CreateOutOfLine(LPMEMORY pStart, length_t nLength);
    void SetContainer(CHeapContainer* pContainer)
        {m_pContainer = pContainer;}

    LPMEMORY GetStart() 
    {
        return (IsOutOfLine()) ? 
            (LPMEMORY)GetInLineLength() : 
            (LPMEMORY)m_pHeapHeader;
    }

    length_t GetLength() 
        {return GetHeaderLength() + GetAllocatedDataLength();}

    length_t GetRealLength() 
        {return GetHeaderLength() + GetUsedLength();}

    LPMEMORY Skip() {return m_pHeapData + GetAllocatedDataLength();}

    void Rebase(LPMEMORY pMemory);

    void Empty() 
    {
        m_pHeapHeader->nDataSize = 0;
        m_pHeapHeader->dwTotalEmpty = 0;
    }
public:
    length_t GetUsedLength() 
    {
        return m_pHeapHeader->nDataSize;
    }

    void SetUsedLength( length_t nDataSize ) 
    {
        m_pHeapHeader->nDataSize = nDataSize;
    }

    length_t GetAllocatedDataLength()
        {return m_pHeapHeader->nAllocatedSize;}

    void SetAllocatedDataLength(length_t nLength);

    LPMEMORY ResolveHeapPointer(heapptr_t ptr)
    {
    	if (ptr > GetUsedLength()) throw CX_Exception();
        return m_pHeapData + ptr;
    }

	bool IsValidPtr(heapptr_t ptr)
	{
		if(IsFakeAddress(ptr)) return true;
		if (ResolveHeapPointer(ptr)) return true;
		return false;
	}

	int ElementMaxSize(heapptr_t ptr)
	{
		if(IsFakeAddress(ptr)) return 0;
		if (ptr > GetUsedLength()) return 0;
		return GetUsedLength()-ptr;
	}

    static IsFakeAddress(heapptr_t ptr)
    {
        return (ptr & FAKE_HEAP_ADDRESS_INDICATOR);
    }

    static int GetIndexFromFake(heapptr_t ptr)
    {
        return (ptr ^ FAKE_HEAP_ADDRESS_INDICATOR);
    }

    static heapptr_t MakeFakeFromIndex(int nIndex)
    {
        return (nIndex | FAKE_HEAP_ADDRESS_INDICATOR);
    }

    CCompressedString* ResolveString(heapptr_t ptr)
    {
        if(IsFakeAddress(ptr))
            return &CKnownStringTable::GetKnownString(ptr & 
                                                ~FAKE_HEAP_ADDRESS_INDICATOR);
        else 
            return (CCompressedString*)ResolveHeapPointer(ptr);
    }

public:
    BOOL Allocate(length_t nLength, UNALIGNED heapptr_t& ptrResult );
    BOOL Extend(heapptr_t ptr, length_t nOldLength, length_t nNewLength);
    void Reduce(heapptr_t ptr, length_t nOldLength, length_t nNewLength);
    BOOL Reallocate(heapptr_t ptrOld, length_t nOldLength,
        length_t nNewLength, UNALIGNED heapptr_t& ptrResult);
    BOOL AllocateString(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult);
    BOOL AllocateString(COPY LPCSTR szString, UNALIGNED heapptr_t& ptrResult);
    BOOL CreateNoCaseStringHeapPtr(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult);
    void Free(heapptr_t ptr, length_t nLength);
    void FreeString(heapptr_t ptrString);
    void Copy(heapptr_t ptrDest, heapptr_t ptrSource, length_t nLength);
    void Trim();

public:
    static length_t GetMinLength() {return sizeof(length_t);}
    static LPMEMORY CreateEmpty(LPMEMORY pStart);
protected:
    length_t AugmentRequest(length_t nCurrentLength, length_t nNeed)
    {
        return nNeed + nCurrentLength + 32;
    }
    heapptr_t AbsoluteToHeap(LPMEMORY pMem)
    {
		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned longs.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        return (heapptr_t) ( pMem - m_pHeapData );
    }
};

//*****************************************************************************
//*****************************************************************************
//
//  class CHeapPtr : public CPtrSource
//
//  This CPtrSource derivative encapsulates a heap pointer as a pointer source.
//  See CPtrSource description in fastsprt.h for more information on pointer
//  source. Suffice it to say that pointer sources must be capable of returning
//  an actual pointer at any given time, but that pointer value may change 
//  overtime.
//
//  Heap pointers are a prime example of that --- since the heap's memory block
//  may move during its lifetime, the actual C pointer to an item on the heap
//  may change. CHeapPtr takes care of that by storing the heap and the heap
//  pointer together and calling ResolveHeapPointer every time it needs to get
//  a C pointer to the data.
//
//*****************************************************************************
//
//  Constructor
//
//  Parameters:
//
//      CFastHeap* pHeap        The heap on which the data resides. Assumed to
//                              last longer than this object itself.
//      heapptr_t ptr           The heap pointer to the desired item.
//
//*****************************************************************************
//
//  GetPointer
//
//  Retrieves the current value of the corresponding C pointer.
//
//  Returns:
//
//      LPMEMORY    this pointer is temporary (that's the whole purpose ofthis
//                  class, after all!)
//
//*****************************************************************************

class CHeapPtr : public CPtrSource
{
protected:
    CFastHeap* m_pHeap;
    heapptr_t m_ptr;
public:
    CHeapPtr(CFastHeap* pHeap, heapptr_t ptr) 
        : m_pHeap(pHeap), m_ptr(ptr) {}

    LPMEMORY GetPointer() {return m_pHeap->ResolveHeapPointer(m_ptr);}
};



//#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastinst.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTINST.CPP

Abstract:

  This file implements all the functions for the classes related to instance
  representation in WbemObjects.

  The classes are defined in fastinst.h where the documentation can be found.

  Classes implemented:
      CInstancePart           Instance data.
      CWbemInstance            Complete instance definition.

History:

  3/10/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/
#include "precomp.h"
#include "fastall.h"

#include <genlex.h>
#include <qllex.h>
#include <objpath.h>
#define QUALNAME_SINGLETON L"singleton"

#include "helper.h"
#include "wbemutil.h"
#include "arrtempl.h"
#include "olewrap.h"
#include <scopeguard.h>

#include <algorithm>
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CInstancePart::ExtendHeapSize(LPMEMORY pStart, length_t nOldLength,
    length_t nExtra)
{
    if(EndOf(*this) - EndOf(m_Heap) > (int)nExtra)
        return TRUE;

    int nNeedTotalLength = GetTotalRealLength() + nExtra;

    // Check for allocation error
    return ReallocAndCompact(nNeedTotalLength);
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CInstancePart::ExtendQualifierSetListSpace(LPMEMORY pOld,
    length_t nOldLength, length_t nNewLength)
{
    if(m_Heap.GetStart() - pOld > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength-nOldLength;

    // Get the amount of space free in the heap
    int    nFreeInHeap = m_Heap.GetAllocatedDataLength() - m_Heap.GetUsedLength();

    BOOL    fReturn = FALSE;

    // If the amount of free space in the heap is  >= nExtra, we'll steal the space
    // from it.

    if ( nFreeInHeap >= nExtra )
    {
        // Compact without trim
        Compact( false );
        m_Heap.SetAllocatedDataLength( m_Heap.GetAllocatedDataLength() - nExtra );
        fReturn = TRUE;
    }
    else
    {
        // True reallocation and compact
        fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);
    }

    // Check for allocation error
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CInstancePart::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
    length_t nNewLength)
{
    if(m_PropQualifiers.GetStart() - pSet->GetStart() > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength - pSet->GetLength();

    // Get the amount of space free in the heap
    int    nFreeInHeap = m_Heap.GetAllocatedDataLength() - m_Heap.GetUsedLength();

    BOOL    fReturn = FALSE;

    // If the amount of free space in the heap is  >= nExtra, we'll steal the space
    // from it.

    if ( nFreeInHeap >= nExtra )
    {
        // Compact without trim
        Compact( false );
        m_Heap.SetAllocatedDataLength( m_Heap.GetAllocatedDataLength() - nExtra );
        fReturn = TRUE;
    }
    else
    {
        // True reallocation and compact
        fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);
    }

    // Check for allocation error
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
        MoveBlock(m_PropQualifiers, m_PropQualifiers.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
LPMEMORY CInstancePart::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest)
{
    // Allocate the header
    // ===================

    CInstancePartHeader* pHeader = (CInstancePartHeader*)pDest;

    pHeader->nLength = nAllocatedSize; // will be overridden down there
    pHeader->fFlags = m_pHeader->fFlags;

    LPMEMORY pCurrentEnd = pDest + sizeof(CInstancePartHeader);

    // Place new heap at the end of the allocated area. Make it as large as
    // the current one.
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedSize - nHeapSize -
                                              CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name
    // ===============

    // Check for allocation errors
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName,
            &m_Heap, &Heap, pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create limited data table
    // =========================

    pCurrentEnd = m_DataTable.CreateLimitedRepresentation(pMap, FALSE, &m_Heap,
                                                           &Heap, pCurrentEnd);
    if(pCurrentEnd == NULL) return NULL;

    // Create limited qualifier set
    // ============================

    if(pMap->GetFlags() & WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS)
    {
        // No qualifiers need to be written
        // ================================

        pCurrentEnd = CBasicQualifierSet::CreateEmpty(pCurrentEnd);
    }
    else
    {
        // Copy them all
        // =============

        int nLength = m_Qualifiers.GetLength();
        memcpy(pCurrentEnd, m_Qualifiers.GetStart(), nLength);

        CStaticPtr CurrentEndPtr(pCurrentEnd);

        // Check for allocation failures
        if ( !CBasicQualifierSet::TranslateToNewHeap(&CurrentEndPtr, &m_Heap, &Heap) )
        {
            return NULL;
        }

        pCurrentEnd += nLength;
    }

    // Create limited property qualifier set list
    // ==========================================

    // Check for allocation failures
    pCurrentEnd = m_PropQualifiers.CreateLimitedRepresentation(pMap, &m_Heap,
                                                           &Heap, pCurrentEnd);
    if(pCurrentEnd == NULL) return NULL;

    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap, pCurrentEnd,pDest+nAllocatedSize-pCurrentEnd);
    Heap.Trim();

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // lengths greater than 0xFFFFFFFF, so cast is ok

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );

    return EndOf(Heap);
}

//******************************************************************************
//******************************************************************************


//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::InitEmptyInstance(CClassPart& ClassPart, LPMEMORY pStart,
                                      int nAllocatedLength,
                                      CDecorationPart* pDecoration)
{
    // Copy the decoration
    // ===================

    LPMEMORY pCurrentEnd;
    if(pDecoration)
    {
        memcpy(pStart, pDecoration, pDecoration->GetLength());
        *(BYTE*)pStart = OBJECT_FLAG_INSTANCE & OBJECT_FLAG_DECORATED;
        pCurrentEnd = pStart + pDecoration->GetLength();
    }
    else
    {
        *(BYTE*)pStart = OBJECT_FLAG_INSTANCE;
        pCurrentEnd = pStart + sizeof(BYTE);
    }

    m_DecorationPart.SetData(pStart);

    // Copy the class part
    // ===================

    memcpy(pCurrentEnd, ClassPart.GetStart(),
                ClassPart.GetLength());
    m_ClassPart.SetData(pCurrentEnd, this);

    pCurrentEnd += m_ClassPart.GetLength();

    // Create empty instance part
    // ==========================

    // Check for a memory allocation failure
    HRESULT hr = WBEM_S_NO_ERROR;
    pCurrentEnd = m_InstancePart.Create(pCurrentEnd, &m_ClassPart, this);

    if ( NULL != pCurrentEnd )
    {

        m_nTotalLength = nAllocatedLength;
        // Everything is internal now
        m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                            WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CWbemInstance::ExtendInstancePartSpace(CInstancePart* pPart,
                                           length_t nNewLength)
{
    // Check if there is enough space
    // ==============================

    if(GetStart() + m_nTotalLength >= m_InstancePart.GetStart() + nNewLength)
        return TRUE;

    // Reallocate
    // ==========

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // lengths > 0xFFFFFFFF, so cast is ok

    length_t nNewTotalLength = (length_t)
        ( (m_InstancePart.GetStart() + nNewLength) - GetStart() );

    LPMEMORY pNew = Reallocate(nNewTotalLength);

    // Check that the allocation succeeded
    if ( NULL != pNew )
    {
        Rebase(pNew);
        m_nTotalLength = nNewTotalLength;
    }

    return ( NULL != pNew );
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace)
{
    CompactAll();

    Undecorate();

    // Check if there is enough space
    // ==============================

    length_t nDecorationSpace =
        CDecorationPart::ComputeNecessarySpace(wszServer, wszNamespace);

    length_t nNeededSpace = nDecorationSpace + m_InstancePart.GetLength();

    // Only add the class part in here if it is internal
    if ( IsClassPartInternal() )
    {
        nNeededSpace += m_ClassPart.GetLength();
    }

    LPMEMORY pDest;
    if(nNeededSpace > m_nTotalLength)
    {
        m_InstancePart.Compact();

        // Check that the reallocation succeeded.  If not, return an error
        pDest = Reallocate(nNeededSpace);

        if ( NULL == pDest )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        Rebase(pDest);
        m_nTotalLength = nNeededSpace;
    }
    else pDest = GetStart();

    // Move is different based on whether class part is internal or not
    if ( IsClassPartInternal() )
    {
        // Move instance part
        // ==================

        MoveBlock(m_InstancePart,
            pDest + nDecorationSpace + m_ClassPart.GetLength());

        // Move class part
        // ===============

        MoveBlock(m_ClassPart, pDest + nDecorationSpace);
    }
    else
    {
        // Move instance part
        // ==================

        MoveBlock(m_InstancePart, pDest + nDecorationSpace);
    }

    // Create decoration part
    // ======================

    m_DecorationPart.Create(OBJECT_FLAG_INSTANCE, wszServer, wszNamespace, pDest);

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
void CWbemInstance::Undecorate()
{
    if(!m_DecorationPart.IsDecorated()) return;

    // Create empty decoration
    // ========================

    LPMEMORY pStart = GetStart();
    m_DecorationPart.CreateEmpty(OBJECT_FLAG_INSTANCE, pStart);

    // Copy is different based on whether class part is internal or not.  We only need to copy the
    // class part if it is internal.

    //  We only need to copy the instance part if it is available.
    if ( IsClassPartInternal() )
    {

        // Copy class part back
        // ====================

        MoveBlock(m_ClassPart, EndOf(m_DecorationPart));

        if ( IsInstancePartAvailable() )
        {
            // Copy the instance part back after the class part
            MoveBlock(m_InstancePart, EndOf(m_ClassPart));
        }
    }
    else if ( IsInstancePartAvailable() )
    {
        // Copy instance part back to the decoration part
        // =======================

        MoveBlock(m_InstancePart, EndOf(m_DecorationPart));

    }
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
LPWSTR CWbemInstance::GetKeyStr()
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    // Loop through all properties.
    // ============================

    CPropertyLookupTable& Properties = m_ClassPart.m_Properties;
    WString KeyStr;

    BOOL bFirst = TRUE;
    for (int i = 0; i < Properties.GetNumProperties(); i++)
    {
        CPropertyInformation* pInfo =
            Properties.GetAt(i)->GetInformation(&m_ClassPart.m_Heap);

        // Determine if this property is marked with a 'key' Qualifier.
        // ============================================================

        if(pInfo->IsKey())
        {
            if (!bFirst)
                KeyStr += WINMGMT_COMPOUND_KEY_JOINER;

            // Determine the type of the key property.
            // =======================================

            WString KeyStrValue;

            CVar Val;
            if (FAILED(GetProperty(pInfo, &Val)))
            return 0;

            WCHAR Tmp[64];

            // Special case char16 and uint32
            if(CType::GetActualType(pInfo->nType) == CIM_CHAR16)
            {
                Tmp[0] = (WCHAR)Val.GetShort();
                Tmp[1] = 0;
                KeyStrValue = Tmp;
            }
            else if( CType::GetActualType(pInfo->nType) == CIM_UINT32 )
            {
                StringCchPrintfW(Tmp,64, L"%lu", (ULONG)Val.GetLong());
                KeyStrValue = Tmp;
            }
            else switch (Val.GetType())
            {
                case VT_I4:
                    StringCchPrintfW(Tmp, 64,L"%ld", Val.GetLong());
                    KeyStrValue = Tmp;
                    break;

                case VT_I2:
                    StringCchPrintfW(Tmp, 64,L"%hd", Val.GetShort());
                    KeyStrValue = Tmp;
                    break;

                case VT_UI1:
                    StringCchPrintfW(Tmp, 64,L"%u", (unsigned int)Val.GetByte());
                    KeyStrValue = Tmp;
                    break;

                case VT_BOOL:
                    KeyStrValue = ( Val.GetBool() ? L"TRUE":L"FALSE");
                    break;

                case VT_BSTR:
                case VT_LPWSTR:
                    KeyStrValue = Val.GetLPWSTR();
                    break;
                case VT_LPSTR:
                    KeyStrValue = WString(Val.GetLPSTR());
                    break;
                case VT_NULL:
                    return NULL;
            }

            if(!IsValidKey(KeyStrValue))
                return NULL;

            KeyStr += KeyStrValue;
            bFirst = FALSE;
        }
    }

    if (bFirst)
    {
        // Perhaps it's singleton
        // ======================

        CVar vSingleton;
        if(SUCCEEDED(GetQualifier(QUALNAME_SINGLETON, &vSingleton, NULL))
            && vSingleton.GetBool())
        {
            KeyStr = OPATH_SINGLETON_STRING;
        }
        else
        {
            return 0;
        }
    }

    // Allocate a new string to return.
    // ================================

    return KeyStr.UnbindPtr();

}

BOOL CWbemInstance::IsValidKey(LPCWSTR wszKey)
{
    const WCHAR* pwc = wszKey;
    while(*pwc != 0)
    {
        if(*pwc < 32)
            return FALSE;
        pwc++;
    }
    return TRUE;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
LPWSTR CWbemInstance::GetRelPath( BOOL bNormalized )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    WString RelPath;

    // Check if any of the keys have been removed
    // ==========================================

    if(m_DecorationPart.AreKeysRemoved())
    {
        return NULL;
    }

    // Start with the class name - if caller wants normalized path, then 
    // use KeyOrigin class.
    // =========================

    if ( !bNormalized )
    {
        RelPath += m_InstancePart.m_Heap.ResolveString(
                m_InstancePart.m_pHeader->ptrClassName)->CreateWStringCopy();
    }
    else
    {
        HRESULT hr = GetKeyOrigin(RelPath);
        if ( FAILED(hr) )
        { 
            throw CX_Exception();
        }
    }

    // Loop through all properties.
    // ============================

    CPropertyLookupTable& Properties = m_ClassPart.m_Properties;

    BOOL bFirst = TRUE;
    DWORD cKeyProps = 0;

    for (int i = 0; i < Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_ClassPart.m_Heap);

        // Determine if this property is marked with a 'key' Qualifier.
        // ============================================================

        if(pInfo->IsKey())
        {
            if ( cKeyProps++ > 0 )
            {
                RelPath += L',';
            }
            else
            {
                RelPath += L".";
            }

            // Determine the type of the key property.
            // =======================================

            RelPath += m_ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                    CreateWStringCopy();

            RelPath += L"=";

            WString KeyStrValue;

            CVar Val;
            if (FAILED(GetProperty(pInfo, &Val)))
            {                                
                throw CX_Exception();                
            }

            BSTR strVal = Val.GetText(0, CType::GetActualType(pInfo->nType));

            // Make sure the BSTR is freed when we go out of scope.
            CSysFreeMe  sfm( strVal );

            // ISSUE:525177
            // how to fix a bug with a bug, per War Team
            if (VT_NULL == Val.GetType()) return NULL;

            if(strVal == NULL || !IsValidKey(strVal))
            {
                throw CX_Exception();
            }
            RelPath += strVal;
        }
    }

    if (cKeyProps == 0)
    {
        // Perhaps it's singleton
        // ======================
        HRESULT hr;

        CVar vSingleton;
        hr = GetQualifier(QUALNAME_SINGLETON, &vSingleton, NULL);
        if (WBEM_S_NO_ERROR == hr && vSingleton.GetBool())
        {
            RelPath += L"=" OPATH_SINGLETON_STRING;
        }
        else if (WBEM_E_NOT_FOUND == hr)
        {
            return NULL;
        }
        else
        {
            throw CX_Exception(); 
        }
    }
    else if ( cKeyProps == 1 && bNormalized )
    {
        //
        // we want to remove the property name from the first key value.
        //

        LPWSTR wszRelpath = RelPath.UnbindPtr();
 
        WCHAR* pwch1 = wcschr( wszRelpath, '.' );
        WCHAR* pwch2 = wcschr( pwch1, '=' );
        
        //
        // shift the entire relpath down over the first key value.
        //
        StringCchCopyW( pwch1, wcslen(pwch1)+1, pwch2 );
        return wszRelpath;
    }
        
    return RelPath.UnbindPtr();
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                    long* plFlags)
{

    CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
    // No Info, so try in the system properties
    if(pInfo == NULL)
    {
        return CSystemProperties::GetPropertyType(wszName, pctType, plFlags);
    }

    return GetPropertyType( pInfo, pctType, plFlags );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CWbemInstance::GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                           long* plFlags)
{
    if(pctType)
    {
        *pctType = CType::GetActualType(pInfo->nType);
    }

    if(plFlags)
    {

        // For an instance, check if the value is defaulted or not to set the
        // Propagated or Local value.  If it is default, then check if it has
        // local qualifiers.  If not then it is propagetd.

        *plFlags = WBEM_FLAVOR_ORIGIN_PROPAGATED;

        if ( m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex) )
        {
            LPMEMORY pQualifierSetData = m_InstancePart.m_PropQualifiers.
                        GetQualifierSetData(pInfo->nDataIndex);

            if( NULL != pQualifierSetData &&
                    !CBasicQualifierSet::IsEmpty(pQualifierSetData) )
            {
                *plFlags = WBEM_FLAVOR_ORIGIN_LOCAL;
            }
        }
        else
        {
            *plFlags = WBEM_FLAVOR_ORIGIN_LOCAL;
        }

    }

    return WBEM_NO_ERROR;

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** ppQualifierSet)
{
    // Check for out of memory    
    try
    {
        CLock lock( this, WBEM_FLAG_ALLOW_READ );

        if(wszProperty == NULL || wcslen(wszProperty) == 0)
            return WBEM_E_INVALID_PARAMETER;

        if(wszProperty[0] == L'_')
            return WBEM_E_SYSTEM_PROPERTY;

        CInstancePropertyQualifierSet* pSet =
            new CInstancePropertyQualifierSet;

        if ( NULL == pSet )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        HRESULT hres = InitializePropQualifierSet(wszProperty, *pSet);
        if(FAILED(hres))
        {
            delete pSet;
            *ppQualifierSet = NULL;
            return hres;
        }
        return pSet->QueryInterface(IID_IWbemQualifierSet,
                                    (void**)ppQualifierSet);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::GetObjectText(long lFlags, BSTR* pstrText)
{
    // Check for out of memory
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        CLock lock( this, WBEM_FLAG_ALLOW_READ );

        if(pstrText == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if((lFlags & ~WBEM_FLAG_NO_SEPARATOR & ~WBEM_FLAG_NO_FLAVORS) != 0)
            return WBEM_E_INVALID_PARAMETER;

        *pstrText = NULL;

        WString wsText;

        // start by writing the qualifiers
        // ===============================

        hr = m_InstancePart.m_Qualifiers.GetText(lFlags, wsText);

        if ( FAILED( hr ) )
        {
            return hr;
        }

        // append the instance header
        // ==========================

        wsText += L"\ninstance of ";
        CVar varClass;
        if(FAILED(m_ClassPart.GetClassName(&varClass)))
        {
            // invalid class
            // =============
            *pstrText = NULL;
            return WBEM_E_INCOMPLETE_CLASS;
        }
        wsText += varClass.GetLPWSTR();

        wsText += L"\n{\n";

        // Go through all properties one by one
        // ====================================

        for(int i = 0; i < m_ClassPart.m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
            CPropertyInformation* pInfo =
                pLookup->GetInformation(&m_ClassPart.m_Heap);

            // Check if it has an actual value set, or  has instance
            // qualifiers
            // =====================================================

            LPMEMORY pQualifierSetData = m_InstancePart.m_PropQualifiers.
                GetQualifierSetData(pInfo->nDataIndex);

            if(!m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex) ||
                (pQualifierSetData &&
                    !CBasicQualifierSet::IsEmpty(pQualifierSetData))
              )
            {
                // start with qualifiers
                // =====================

                wsText += L"\t";

                if(pQualifierSetData &&
                    !CBasicQualifierSet::IsEmpty(pQualifierSetData))
                {
                    WString wsTemp;
                    hr = CBasicQualifierSet::GetText(
                            pQualifierSetData, &m_InstancePart.m_Heap, lFlags, wsTemp);

                    if ( FAILED( hr ) )
                    {
                        return hr;
                    }

                    wsText += wsTemp;
                    if(wsTemp.Length() != 0) wsText += L" ";
                }

                // then the name
                // =============

                BSTR strName = m_ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                    CreateBSTRCopy();
                // Check for allocation failures
                if ( NULL == strName )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

                CSysFreeMe  sfm( strName );
                wsText += strName;

                // then the value, if present
                // ==========================

                if(!m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex))
                {
                    wsText += L" = ";
                    if(m_InstancePart.m_DataTable.IsNull(pInfo->nDataIndex))
                    {
                        wsText += L"NULL";
                    }
                    else
                    {
                        CVar varProp;

                        // Check for allocation failures
                        if ( !m_InstancePart.m_DataTable.GetOffset(pInfo->nDataOffset)->
                                StoreToCVar(CType::GetActualType(pInfo->nType), varProp,
                                                             &m_InstancePart.m_Heap) )
                        {
                            return WBEM_E_OUT_OF_MEMORY;
                        }

                        // Cleanup the allocated string
                        LPWSTR wsz = NULL;
                        
                        try
                        {
                            wsz = GetValueText(lFlags, varProp,
                                            CType::GetActualType(pInfo->nType));

                            if ( NULL != wsz )
                            {
                                wsText += wsz;
                                delete [] wsz;
                            }
                        }
                        catch (CX_MemoryException)
                        {
                            delete [] wsz;
                            return WBEM_E_OUT_OF_MEMORY;
                        }
                        catch (...)
                        {
                            delete [] wsz;
                            return WBEM_E_FAILED;
                        }

                    }
                }

                wsText += L";\n";
            }
        }

        wsText += L"}";

        if((lFlags & WBEM_FLAG_NO_SEPARATOR) == 0)
        {
            wsText += L";\n";
        }

        *pstrText = COleAuto::_SysAllocString((LPCWSTR)wsText);
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::GetQualifierSet(IWbemQualifierSet** ppQualifierSet)
{
    // This function does not perform any allocations, so no need for any fancy
    // exception handling.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppQualifierSet == NULL)
            return WBEM_E_INVALID_PARAMETER;
        return m_InstancePart.m_Qualifiers.QueryInterface(
            IID_IWbemQualifierSet, (void**)ppQualifierSet);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                                CIMTYPE ctType)
{
    // Check for out of memory
    try
    {
        CLock lock(this);

        if (NULL == wszName)
            return WBEM_E_INVALID_PARAMETER;
        
        // Only flag we accept, and then only if the property
        // is one of the System Time properties
        if ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CVar Var;
        if(pVal)
        {
            if(Var.SetVariant(pVal, TRUE) != CVar::no_error)
                return WBEM_E_TYPE_MISMATCH;
        }
        else
        {
            Var.SetAsNull();
        }

        HRESULT hr = SetPropValue( wszName, &Var, ctType );

        // Perform object validation now
        if ( FAILED( ValidateObject( 0L ) ) )
        {
            hr = WBEM_E_FAILED;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType)
{
    // If any other system property, this fails
    if(CSystemProperties::FindName(wszName) >= 0)
        return WBEM_E_READ_ONLY;

    // If the value starts with an underscore see if it's a System Property
    // DisplayName, and if so, switch to a property name - otherwise, this
    // will just return the string we passed in
    
    CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;

    if(ctType != 0 && (Type_t)ctType != CType::GetActualType(pInfo->nType))
        return WBEM_E_TYPE_MISMATCH;

    // Do a special DateTime Check.  We know at this point, that
    // the value is one of the two valid date/time formats.
    // DMTF or DMTF Interval.  We now need to check that if the
    // "subtype" qualifier exists and is "interval" that the
    // datetime is an interval time.  We will, however, let VT_NULL
    // through, since that will effectively clear the property.

    if ( CType::GetActualType(pInfo->nType) == CIM_DATETIME &&
        !pVal->IsNull() )
    {
        CVar    var;

        if ( SUCCEEDED( GetPropQualifier( pInfo, L"SUBTYPE", &var, NULL ) ) )
        {
            if ( var.GetType() == VT_BSTR || var.GetType() == VT_LPWSTR )
            {
                if ( wbem_wcsicmp( var.GetLPWSTR(), L"interval" ) == 0 )
                {
                    if ( !CUntypedValue::CheckIntervalDateTime( *pVal ) )
                    {
                        return WBEM_E_TYPE_MISMATCH;
                    }
                }   
            }
        }
    }

    return m_InstancePart.SetActualValue(pInfo, pVal);
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::Delete(LPCWSTR wszName)
{
    // This function doesn't cause any allocations to be performed, so no need
    // for any OutOfMemory exception handling.

    try
    {
        CLock lock(this);

        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL)
        {
            if(CSystemProperties::FindName(wszName) >= 0)
                return WBEM_E_SYSTEM_PROPERTY;
            else
                return WBEM_E_NOT_FOUND;
        }

        // Delete the value
        // ================

        // Set the defaultness as well as nullness based on the class NULLness
        m_InstancePart.m_DataTable.SetDefaultness(pInfo->nDataIndex, TRUE);
        m_InstancePart.m_DataTable.SetNullness( pInfo->nDataIndex,
            m_ClassPart.m_Defaults.IsNull( pInfo->nDataIndex ) );

        // Delete the qualifier set
        // ========================

        if(!m_InstancePart.m_PropQualifiers.IsEmpty())
        {
            CBasicQualifierSet Set;
            LPMEMORY pData = m_InstancePart.m_PropQualifiers.
                                    GetQualifierSetData(pInfo->nDataIndex);
            Set.SetData(pData, &m_InstancePart.m_Heap);

            length_t nOldLength = Set.GetLength();
            CBasicQualifierSet::Delete(pData, &m_InstancePart.m_Heap);
            CBasicQualifierSet::CreateEmpty(pData);

            m_InstancePart.m_PropQualifiers.ReduceQualifierSetSpace(&Set,
                        nOldLength - CBasicQualifierSet::GetMinLength());
        }

        // Perform object validation now
        if ( FAILED( ValidateObject( 0L ) ) )
        {
            return WBEM_E_FAILED;
        }

        return WBEM_S_RESET_TO_DEFAULT;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::Clone(IWbemClassObject** ppCopy)
{
    LPMEMORY pNewData = NULL;

    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppCopy == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // We won't support this operation if the class part has been
        // stripped out
        if ( !IsClassPartAvailable() )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        m_InstancePart.Compact();

        // We want to copy the entire memory block
        pNewData = m_pBlobControl->Allocate(m_nTotalLength);

        if ( NULL != pNewData ) 
        {
            ScopeGuard deleteBlock = MakeObjGuard(*m_pBlobControl,CBlobControl::Delete,pNewData);
            memcpy(pNewData, GetStart(), m_nTotalLength);
            CWbemInstance* pNewInstance = new CWbemInstance;

            if ( NULL != pNewInstance )
            {
                // If the class part is internal, we can let SetData perform
                // normally.  Otherwise, we will need to setup our pointers with
                // that in mind.

                if ( IsClassPartInternal() )
                {
                    deleteBlock.Dismiss();                    
                    pNewInstance->SetData(pNewData, m_nTotalLength);
                    
                }
                else if ( IsClassPartShared() )
                {
                    // Setup the New Instance.  Decoration and Instance both come from the
                    // data block.  We can just merge the new Instance's class part with the
                    // same `object we are merged with.

            // SetData take ownershp and throws
                    deleteBlock.Dismiss();
                    pNewInstance->m_DecorationPart.SetData( pNewData );

                    // Because pNewInstance will merge with the same class part as us, pass
                    // our class part member as the class part for parameter for SetData (it
                    // just uses it for informational purposes ).

                    // The m_InstancePart.m_Qualifier.m_pSecondarySet pointer will be incorrect after
                    // this call ( it will point to the cloning source's secondary set ).  By setting
                    // the internal status properly, in the next line, MergeClassPart() will fix
                    // everything up properly.
                    pNewInstance->m_InstancePart.SetData( EndOf( pNewInstance->m_DecorationPart ), pNewInstance, m_ClassPart, m_InstancePart.GetLength() );

                    // This will "fake out" the status so it fixes up the class part correctly
                    pNewInstance->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART;

                    HRESULT hr = pNewInstance->MergeClassPart( m_pMergedClassObject );
                    if (FAILED(hr))
                    {
                        delete pNewInstance;
                        return hr;
                    }

                    // Copy the status and length variables.
                    pNewInstance->m_dwInternalStatus = m_dwInternalStatus;
                    pNewInstance->m_nTotalLength = m_nTotalLength;
                }

                pNewInstance->CompactAll();
                pNewInstance->m_nRef = 0;
                return pNewInstance->QueryInterface(IID_IWbemClassObject,
                    (void**)ppCopy);
            }
            else
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}


STDMETHODIMP CWbemInstance::CloneAndDecorate(long lFlags,
	                                                                  WCHAR * pszServer,
	                                                                  WCHAR * pszNamespace,
	                                                                  IWbemClassObject** ppDestObject)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppDestObject == NULL || NULL == pszServer || NULL == pszNamespace)
            return WBEM_E_INVALID_PARAMETER;

        // We won't support this operation if the class part has been
        // stripped out
        if ( !IsClassPartAvailable() )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        m_InstancePart.Compact();

        BOOL IsAsciableSrv;
        long nByteServer  = CCompressedString::ComputeNecessarySpace(pszServer,IsAsciableSrv);
        BOOL IsAsciableNS;
        long nByteNamespace  = CCompressedString::ComputeNecessarySpace(pszNamespace,IsAsciableNS);        

        long nDecorationSpace = sizeof(BYTE) + nByteServer + nByteNamespace;
        long TotalLen = m_nTotalLength + nDecorationSpace - m_DecorationPart.GetLength();
        
        LPMEMORY pNewData = m_pBlobControl->Allocate(TotalLen);        
        if ( NULL == pNewData )  return WBEM_E_OUT_OF_MEMORY;
        ScopeGuard deleteBlock = MakeObjGuard(*m_pBlobControl,CBlobControl::Delete,pNewData);        
        LPMEMORY pStartHere = pNewData;

        LPMEMORY pStartNonDecorData = pNewData + nDecorationSpace;

        memcpy(pNewData, GetStart(),1);
        pNewData[0] |= OBJECT_FLAG_DECORATED;
        pNewData++;
        ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableSrv,pszServer);
        pNewData+=nByteServer;
        ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableNS,pszNamespace);
        	
        memcpy(pStartNonDecorData, GetStart()+m_DecorationPart.GetLength(), m_nTotalLength-m_DecorationPart.GetLength());

        CWbemInstance* pNewInstance = new CWbemInstance;
        if (NULL == pNewInstance) return WBEM_E_OUT_OF_MEMORY;

        if ( IsClassPartInternal() )
        {
            deleteBlock.Dismiss();                    
            pNewInstance->SetData(pStartHere, TotalLen);  
        }
        else if ( IsClassPartShared() )
        {
            // Setup the New Instance.  Decoration and Instance both come from the
            // data block.  We can just merge the new Instance's class part with the
            // same `object we are merged with.

            // SetData take ownershp and throws
            deleteBlock.Dismiss();
            pNewInstance->m_DecorationPart.SetData( pStartHere );

            // Because pNewInstance will merge with the same class part as us, pass
            // our class part member as the class part for parameter for SetData (it
            // just uses it for informational purposes ).

            // The m_InstancePart.m_Qualifier.m_pSecondarySet pointer will be incorrect after
            // this call ( it will point to the cloning source's secondary set ).  By setting
            // the internal status properly, in the next line, MergeClassPart() will fix
            // everything up properly.
            pNewInstance->m_InstancePart.SetData( EndOf( pNewInstance->m_DecorationPart ), pNewInstance, m_ClassPart,m_InstancePart.GetLength() );

            // This will "fake out" the status so it fixes up the class part correctly
            pNewInstance->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART;

            HRESULT hr = pNewInstance->MergeClassPart( m_pMergedClassObject );
            if (FAILED(hr))
            {
                delete pNewInstance;
                return hr;
            }

            // Copy the status and length variables.
            pNewInstance->m_dwInternalStatus = m_dwInternalStatus;
            pNewInstance->m_nTotalLength = TotalLen;
        }

        pNewInstance->CompactAll();
        pNewInstance->m_nRef = 0;
        return pNewInstance->QueryInterface(IID_IWbemClassObject,(void**)ppDestObject);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}


//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::SpawnDerivedClass(long lFlags,
                                                IWbemClassObject** ppNewClass)
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::SpawnInstance(long lFlags,
                                IWbemClassObject** ppNewInstance)
{
    LPMEMORY pNewData = NULL;

    // Check for out of memory
    try
    {
        CLock lock( this, WBEM_FLAG_ALLOW_READ );

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(ppNewInstance == NULL)
            return WBEM_E_INVALID_PARAMETER;
        int nLength = EstimateInstanceSpace(m_ClassPart);

        HRESULT hr = WBEM_E_OUT_OF_MEMORY;

        pNewData = m_pBlobControl->Allocate(nLength);

        if ( NULL != pNewData )
        {
            memset(pNewData, 0, nLength);
            CWbemInstance* pNewInstance = new CWbemInstance;

            if ( NULL != pNewInstance )
            {
                // Checked the HRESULT
                hr = pNewInstance->InitEmptyInstance(m_ClassPart, pNewData, nLength);

                if ( SUCCEEDED(hr) )
                {
                    pNewInstance->m_nRef = 0;
                    hr =  pNewInstance->QueryInterface(IID_IWbemClassObject,
                        (void**)ppNewInstance);
                }
                else
                {
                    // Cleanup.  The Instance will have the data
                    delete pNewInstance;
                }

            }   // IF pNewInstance
            else
            {
                // Cleanup
                m_pBlobControl->Delete(pNewData);
            }

        }   // IF pNewData

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::Validate()
{
    for(int i = 0; i < m_ClassPart.m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_ClassPart.m_Heap);

        if(!pInfo->CanBeNull(&m_ClassPart.m_Heap))
        {
            // Make sure it is not null
            // ========================

            if(m_InstancePart.m_DataTable.IsNull(pInfo->nDataIndex))
            {
                return WBEM_E_ILLEGAL_NULL;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CWbemInstance::IsValidObj()
{
    //m_InstancePart.DumpHeapUsage( &m_ClassPart);

    HRESULT hres = m_ClassPart.IsValidClassPart();

    if ( SUCCEEDED( hres ) )
    {
        DeferedObjList EmbededObjects;
        hres = m_InstancePart.IsValidInstancePart( &m_ClassPart, EmbededObjects );
        while(!EmbededObjects.empty())
        {
            EmbeddedObj lastObject = EmbededObjects.back();
            EmbededObjects.pop_back();
            CEmbeddedObject::ValidateBuffer(lastObject.m_start, lastObject.m_length,EmbededObjects);
        }
    }
    return hres;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::PlugKeyHoles()
{
    for(int i = 0; i < m_ClassPart.m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_ClassPart.m_Heap);

        if(!pInfo->CanBeNull(&m_ClassPart.m_Heap))
        {
            // Make sure it is not null
            // ========================

            if(m_InstancePart.m_DataTable.IsNull(pInfo->nDataIndex))
            {
                if(pInfo->IsKey() &&
                    CType::GetActualType(pInfo->nType) == CIM_STRING)
                {
                    // Get a guid and put it there
                    // ===========================

                    GUID guid;
                    CoCreateGuid(&guid);
                    WCHAR wszBuffer[100];
                    StringFromGUID2(guid, wszBuffer, 100);
                    CVar v;
                    v.SetBSTR(wszBuffer);
                    if(SUCCEEDED(m_InstancePart.SetActualValue(pInfo, &v)))
                        continue;
                }
                return WBEM_E_ILLEGAL_NULL;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}


//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::GetLimitedVersion(IN CLimitationMapping* pMap,
                                        NEWOBJECT CWbemInstance** ppNewInst)
{
    // We may need to clean this up if an exception is thrown
    

    try
    {

        DWORD   dwLength = GetLength();

        // First, check if the class part is internal.  If not, then we
        // need to account for the class part when calculating the
        // length of the datablock for the new instance.

        // Exception handling will handle failure to allocate
        if ( !IsClassPartInternal() )
        {
            dwLength += m_ClassPart.GetLength();
        }

        // Allocate memory for the new object
        // ==================================

        LPMEMORY pBlock = CBasicBlobControl::sAllocate(dwLength);
        if ( NULL == pBlock ) return WBEM_E_OUT_OF_MEMORY;
        OnDeleteIf<LPMEMORY,void(*)(LPMEMORY),CBasicBlobControl::sDelete> relMe(pBlock);


        memset(pBlock, 0, dwLength);
        LPMEMORY pCurrent = pBlock;
        LPMEMORY pEnd = pBlock + dwLength;

        // Write limited decoration part
        // =============================

        pCurrent = m_DecorationPart.CreateLimitedRepresentation(pMap, pCurrent);
        if(pCurrent == NULL)  return WBEM_E_FAILED;


        // Write limited class part. This will augment the map if necessary
        // ================================================================

        BOOL bRemovedKeys;

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value (pEnd - pCurrent).  We are
        // not supporting length > 0xFFFFFFFF so cast is ok.

        pCurrent = m_ClassPart.CreateLimitedRepresentation(pMap,
                        (length_t) ( pEnd - pCurrent ), pCurrent, bRemovedKeys);

        if(pCurrent == NULL) return WBEM_E_OUT_OF_MEMORY;


        if(bRemovedKeys)
        {
            CDecorationPart::MarkKeyRemoval(pBlock);
        }

        // Write limited instance part.
        // ============================

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value (pEnd - pCurrent).  We are
        // not supporting length > 0xFFFFFFFF, so cast is ok

        pCurrent = m_InstancePart.CreateLimitedRepresentation(pMap,
                        (length_t) ( pEnd - pCurrent ), pCurrent);

        if(pCurrent == NULL) return WBEM_E_OUT_OF_MEMORY;


        // Now that we have the memory block for the new instance, create the
        // actual instance object itself
        // ==================================================================

        CWbemInstance* pNew = new CWbemInstance;
        if ( NULL == pNew )  return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe rm((IWbemClassObject*)pNew);

        relMe.dismiss();
        pNew->SetData(pBlock, dwLength);

        pNew->AddRef();
        *ppNewInst = pNew;
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

HRESULT CWbemInstance::AsymmetricMerge(CWbemInstance* pOldInstance,
                                       CWbemInstance* pNewInstance)
{
    // Verify that the new instance is derived from the old one
    // ========================================================

    CVar vOldName;
    pOldInstance->GetClassName(&vOldName);
    if(pNewInstance->InheritsFrom(vOldName.GetLPWSTR()) != S_OK)
    {
        return WBEM_E_INVALID_CLASS;
    }

    // Access data tables and the property definition table
    // ====================================================

    CDataTable& NewDataTable = pNewInstance->m_InstancePart.m_DataTable;
    CDataTable& OldDataTable = pOldInstance->m_InstancePart.m_DataTable;

    CPropertyLookupTable& LookupTable = pOldInstance->m_ClassPart.m_Properties;
    CFastHeap& ClassHeap = pOldInstance->m_ClassPart.m_Heap;

    CFastHeap& OldHeap = pOldInstance->m_InstancePart.m_Heap;
    CFastHeap& NewHeap = pNewInstance->m_InstancePart.m_Heap;


    // Go through all the properties of the old instance (base)
    // ========================================================

    for(int i = 0; i < LookupTable.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = LookupTable.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&ClassHeap);

        // Check if this property is NULL in the new instance ---- that means
        // we need to copy the old one
        // ==================================================================

        if(NewDataTable.IsDefault(pInfo->nDataIndex) &&
            !OldDataTable.IsDefault(pInfo->nDataIndex))
        {
            NewDataTable.SetDefaultness(pInfo->nDataIndex, FALSE);
            if(OldDataTable.IsNull(pInfo->nDataIndex))
            {
                NewDataTable.SetNullness(pInfo->nDataIndex, TRUE);
            }
            else
            {
                NewDataTable.SetNullness(pInfo->nDataIndex, FALSE);

                // Get the pointer sources to the old and new values
                // =================================================

                CDataTablePtr OldSource(&OldDataTable, pInfo->nDataOffset);
                CDataTablePtr NewSource(&NewDataTable, pInfo->nDataOffset);

                // Copy the old one over (nothing to erase)
                // ========================================

                // Check for allocation errors
                if ( !CUntypedValue::CopyTo(&OldSource, pInfo->nType, &NewSource,
                        &OldHeap, &NewHeap) )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
 void CInstancePart::SetData(LPMEMORY pStart,
                                   CInstancePartContainer* pContainer,
                                   CClassPart& ClassPart,
                                   size_t cbLength)
{
    m_pContainer = pContainer;
    m_pHeader = (CInstancePartHeader*)pStart;

    LPMEMORY pCurrent = pStart + sizeof(CInstancePartHeader);
    if (((ULONG_PTR)pCurrent-(ULONG_PTR)pStart) > cbLength) throw CX_Exception();

    m_DataTable.SetData(
        pCurrent,
        ClassPart.m_Properties.GetNumProperties(),
        ClassPart.m_pHeader->nDataLength,
        this);
    if (((ULONG_PTR)EndOf(m_DataTable)-(ULONG_PTR)pStart) > cbLength) throw CX_Exception();
    
    m_Qualifiers.SetData(
        EndOf(m_DataTable),
        this,
        &ClassPart.m_Qualifiers);
    if (((ULONG_PTR)EndOf(m_Qualifiers)-(ULONG_PTR)pStart) > cbLength) throw CX_Exception();
    
    m_PropQualifiers.SetData(
        EndOf(m_Qualifiers),
        ClassPart.m_Properties.GetNumProperties(),
        this);
    if (((ULONG_PTR)EndOf(m_PropQualifiers)-(ULONG_PTR)pStart) > cbLength) throw CX_Exception();
    
    m_Heap.SetData(
        EndOf(m_PropQualifiers),
        this);
    
    if (((ULONG_PTR)EndOf(m_Heap)-(ULONG_PTR)pStart) > cbLength) throw CX_Exception();
}


class DummyClassPartContainer : public CClassPartContainer
{
public:
    BOOL ExtendClassPartSpace(CClassPart* pPart, length_t nNewLength)  { _DBG_ASSERT(0);return TRUE;}
    void ReduceClassPartSpace(CClassPart* pPart, length_t nDecrement) { _DBG_ASSERT(0);}
    IUnknown* GetWbemObjectUnknown() { return 0;}
};


class DummyInstancePartContainer : public CInstancePartContainer
{
public:
    BOOL ExtendInstancePartSpace(CInstancePart* pPart,  length_t nNewLength)  { _DBG_ASSERT(0);return TRUE;}
    void ReduceInstancePartSpace(CInstancePart* pPart, length_t nDecrement) { _DBG_ASSERT(0);}
    IUnknown* GetInstanceObjectUnknown() { return 0;}
    void ClearCachedKeyValue()  { _DBG_ASSERT(0);}
};


size_t CInstancePart::ValidateBuffer(LPMEMORY start, size_t cbSize, CClassPart& classData,  DeferedObjList& embededList)
{
    CInstancePartHeader* header = (CInstancePartHeader*)start;
    size_t step = sizeof(CInstancePartHeader);
    if (step > cbSize) throw CX_Exception();
    if (header->nLength > cbSize) throw CX_Exception();

	step += CDataTable::ValidateBuffer(start+step, classData.m_pHeader->nDataLength, classData.m_Properties.GetNumProperties());	
	step += CInstanceQualifierSet::ValidateBuffer(start+step, cbSize-step);
	step += CQualifierSetList::ValidateBuffer(start+step, cbSize-step, classData.m_Properties.GetNumProperties());

	size_t heapStep = CFastHeap::ValidateBuffer(start+step, cbSize-step);	

	CFastHeap instanceHeap;
	instanceHeap.SetData(start+step,0);

	step += heapStep;
	if (step>header->nLength) throw CX_Exception();


	DummyInstancePartContainer dummyInstance;
	CInstancePart theInstance;
	theInstance.SetData(start, &dummyInstance , classData, cbSize);
	if (FAILED(theInstance.IsValidInstancePart(&classData,embededList))) throw CX_Exception();
	
	return header->nLength;
};

/*
struct CFastHeapUsage
{
    heapptr_t UNALIGNED * OffSetLocation_;
    LPMEMORY   pBegin_;
    length_t       LenData_;

    CFastHeapUsage( heapptr_t UNALIGNED * OffSetLocation,
                                 LPMEMORY   pBegin,
                                 length_t       LenData):
        OffSetLocation_(OffSetLocation),
        pBegin_(pBegin),
        LenData_(LenData)
    {};

    CFastHeapUsage & operator=(const CFastHeapUsage & other)
    {
        OffSetLocation_ = other.OffSetLocation_;
        pBegin_ = other.pBegin_;
        LenData_ = other.LenData_;
        return *this;
    }
};

bool LessAddr(CFastHeapUsage A,
	                   CFastHeapUsage B)
{
    return A.pBegin_ < B.pBegin_;
}

void CInstancePart::DumpHeapUsage(CClassPart * pClassPart)
{
    std::vector<CFastHeapUsage> arrUsage;

    CCompressedString * pStr = (CCompressedString *)m_Heap.ResolveHeapPointer(m_pHeader->ptrClassName);
    arrUsage.push_back(CFastHeapUsage(&m_pHeader->ptrClassName, 
    	                                                     (LPMEMORY)pStr,
    	                                                     pStr->GetLength()));

    if (!m_Qualifiers.IsEmpty())
    {

        LPMEMORY pStart = (LPMEMORY)m_Qualifiers.GetFirstQualifier();
        BYTE * pQualEnd = pStart + m_Qualifiers.GetLength() - sizeof(length_t);

       CQualifier  * pQual;
        for (pQual = (CQualifier *)pStart;
              (BYTE *)pQual < (BYTE *)pQualEnd;
              pQual = (CQualifier *)(pQual->GetStart() + pQual->GetLength()))
        {
        	DbgPrintfA(0,"I - pQual %p\n",pQual);

              CCompressedString * pStrQName = (CCompressedString *)m_Heap.ResolveHeapPointer(pQual->ptrName);
              arrUsage.push_back(CFastHeapUsage(&pQual->ptrName, 
                                                                      (LPMEMORY)pStrQName,
             	                                                        pStrQName->GetLength()));

              if ( CType::IsArray( pQual->Value.GetType() ) )
              {
	               CUntypedArray* pArray = (CUntypedArray*)m_Heap.ResolveHeapPointer(pQual->Value.AccessPtrData());
	               length_t LenArray = pArray->GetLengthByType(pQual->Value.GetType() );
	               arrUsage.push_back(CFastHeapUsage(&pQual->Value.AccessPtrData(), 
		                                                                (LPMEMORY)pArray,
	                 	                                                  LenArray));
              }        	
              else if(CIM_STRING == pQual->Value.GetType() )
	       {

                  CCompressedString * pStrQual = (CCompressedString *)m_Heap.ResolveHeapPointer(pQual->Value.AccessPtrData());
                  arrUsage.push_back(CFastHeapUsage(&pQual->Value.AccessPtrData(), 
                                                                      (LPMEMORY)pStrQual,
             	                                                        pStrQual->GetLength()));	       
              }
              
        }
    }


    if (!m_PropQualifiers.IsEmpty())
    {
        LPMEMORY pStart = m_PropQualifiers.GetStart() + m_PropQualifiers.GetHeaderLength();
        for (int IdxSet = 0;IdxSet < m_PropQualifiers.GetNumSets();IdxSet++)
      	 {
      	     length_t LenQualSet = *((length_t UNALIGNED *)pStart);
	        
	     BYTE * pQualEnd = pStart + LenQualSet;

	       DbgPrintfA(0,"Start %p End %p\n",pStart,pQualEnd);

	       CQualifier  * pQual;
	        for (pQual = (CQualifier *)(pStart+ sizeof(length_t));
	              (BYTE *)pQual < (BYTE *)pQualEnd;
	              pQual = (CQualifier *)(pQual->GetStart() + pQual->GetLength()))
	        {
	            	DbgPrintfA(0,"P - pQual %p\n",pQual);


	              CCompressedString * pStrQName = (CCompressedString *)m_Heap.ResolveHeapPointer(pQual->ptrName);
	              arrUsage.push_back(CFastHeapUsage(&pQual->ptrName, 
	                                                                      (LPMEMORY)pStrQName,
	             	                                                        pStrQName->GetLength()));

	              if ( CType::IsArray( pQual->Value.GetType() ) )
	              {
		               CUntypedArray* pArray = (CUntypedArray*)m_Heap.ResolveHeapPointer(pQual->Value.AccessPtrData());
		               length_t LenArray = pArray->GetLengthByType(pQual->Value.GetType() );
		               arrUsage.push_back(CFastHeapUsage(&pQual->Value.AccessPtrData(), 
			                                                                (LPMEMORY)pArray,
		                 	                                                  LenArray));
	              }
	              else if(CIM_STRING == pQual->Value.GetType() )
		       {

		              CCompressedString * pStrQual = (CCompressedString *)m_Heap.ResolveHeapPointer(pQual->Value.AccessPtrData());
		              arrUsage.push_back(CFastHeapUsage(&pQual->Value.AccessPtrData(), 
		                                                                  (LPMEMORY)pStrQual,
		         	                                                        pStrQual->GetLength()));	       
		       }	              
	        }

              pStart = pQualEnd;
        }
    }


    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        // At this point, we know the class part is valid
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);

        if( !m_DataTable.IsNull(pInfo->nDataIndex) &&
            !m_DataTable.IsDefault(pInfo->nDataIndex) )
        {
            if ( CType::IsPointerType( pInfo->nType ) )
            {
                CUntypedValue*  pValue = m_DataTable.GetOffset( pInfo->nDataOffset );
                LPMEMORY    pData = m_Heap.ResolveHeapPointer( pValue->AccessPtrData() );

                if ( CType::IsArray( pInfo->nType ) )
                {
                    CUntypedArray* pArray = (CUntypedArray*)pData;
                    length_t LenArray = pArray->GetLengthByActualLength(CType::GetLength(CType::MakeNotArray(pInfo->nType)));

                    DbgPrintfA(0,"Type %04x LenArray %x GetLength %d\n",pInfo->nType,LenArray,CType::GetLength(CType::MakeNotArray(pInfo->nType)));

                   arrUsage.push_back(CFastHeapUsage(&pValue->AccessPtrData(), 
	                                                                        pData,
                 	                                                   LenArray));
                    
                }
                else if (pInfo->nType == CIM_OBJECT)
                {
                    length_t LenEmbedded = *(length_t UNALIGNED *)pData;
                    
                    arrUsage.push_back(CFastHeapUsage(&pValue->AccessPtrData(), 
	                                                                         pData,
                 	                                                    LenEmbedded));                                               
                }
                else if(CIM_STRING == pInfo->nType ||
                	     CIM_DATETIME == pInfo->nType ||
                	     CIM_REFERENCE == pInfo->nType)
	         {

                    CCompressedString * pStrQual = (CCompressedString *)m_Heap.ResolveHeapPointer(pValue->AccessPtrData());
                    arrUsage.push_back(CFastHeapUsage(&pValue->AccessPtrData(), 
                                                                            (LPMEMORY)pStrQual,
             	                                                               pStrQual->GetLength()));	       
                }                
            }   // IF is Pointer
        }   // IF not NULL or default
    }   // FOR iterate properties

    std::sort(arrUsage.begin(),arrUsage.end(),LessAddr);

    ULONG_PTR GapSpace = 0;
    for (size_t j=0;j<arrUsage.size();j++)
    {
        DbgPrintfA(0," - %x - %p %p %x\n",
        	               j,
        	               arrUsage[j].OffSetLocation_,
                             arrUsage[j].pBegin_,
                             arrUsage[j].LenData_);        
        if (j>0)
        {
            GapSpace += (ULONG_PTR)arrUsage[j].pBegin_  - 
            	                   (ULONG_PTR)arrUsage[j-1].pBegin_ - arrUsage[j-1].LenData_ ;
        }
    }
    DbgPrintfA(0,"GapSpace %d bytes\n",GapSpace);
    DebugBreak();
    
}
*/

HRESULT CInstancePart::IsValidInstancePart( CClassPart* pClassPart, DeferedObjList& embededList )
{
    LPMEMORY    pInstPartStart = GetStart();
    LPMEMORY    pInstPartEnd = GetStart() + GetLength();

    // Check that the header is in the BLOB
    if ( !( (LPMEMORY) m_pHeader >= pInstPartStart &&
            (LPMEMORY) m_pHeader < pInstPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Instance Part Header!") );
        return WBEM_E_FAILED;
    }

    // Check the datatable
    //End and Start can be equal if no properties
    LPMEMORY    pTestStart = m_DataTable.GetStart();
    LPMEMORY    pTestEnd = m_DataTable.GetStart() + m_DataTable.GetLength();

    if ( !( pTestStart == (pInstPartStart + sizeof(CInstancePartHeader)) &&
            pTestEnd >= pTestStart && pTestEnd < pInstPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad DataTable in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Check the qualifier set
    pTestStart = m_Qualifiers.GetStart();
    pTestEnd = m_Qualifiers.GetStart() + m_Qualifiers.GetLength();

    if ( !( pTestStart == EndOf(m_DataTable) &&
            pTestEnd > pTestStart && pTestEnd < pInstPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Qualifier Set in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Check the Property Qualifiers
    pTestStart = m_PropQualifiers.GetStart();
    pTestEnd = m_PropQualifiers.GetStart() + m_PropQualifiers.GetLength();

    // A delete qualifier on an instance part, can cause a gap between it and the
    // property qualifiers, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pTestStart >= EndOf(m_Qualifiers) &&
            pTestEnd > pTestStart && pTestEnd < pInstPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Property Qualifier Set in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Check the Heap
    LPMEMORY    pHeapStart = m_Heap.GetStart();
    LPMEMORY    pHeapEnd = m_Heap.GetStart() + m_Heap.GetLength();

    // A delete qualifier on an property qualifier, can cause a gap between it and the
    // heap, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pHeapStart >= EndOf(m_PropQualifiers) &&
            pHeapEnd > pHeapStart && pHeapEnd <= pInstPartEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Heap in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Get the heap data start
    pHeapStart = m_Heap.GetHeapData();

    // Check that the classname pointer is in the BLOB
    LPMEMORY    pClassName = m_Heap.ResolveHeapPointer( m_pHeader->ptrClassName );
    if ( !( pClassName >= pHeapStart && pClassName < pHeapEnd ) )
    {
        _ASSERT( 0, __TEXT("Winmgmt: Bad Class Name pointer in Instance Part Header!") );
        return WBEM_E_FAILED;
    }

    // Now check the qualifier set
    HRESULT hres = m_Qualifiers.IsValidQualifierSet();
    if ( FAILED(hres) )
    {
        return hres;
    }

    // We're going to walk the instance property list and for every property
    // we find, if it's not NULL or DEFAULT , and a string, array or object,
    // verify that it actually points into a location in our heap.

    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        // At this point, we know the class part is valid
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);

        if( !m_DataTable.IsNull(pInfo->nDataIndex) &&
            !m_DataTable.IsDefault(pInfo->nDataIndex) )
        {
            if ( CType::IsPointerType( pInfo->nType ) )
            {
                CUntypedValue*  pValue = m_DataTable.GetOffset( pInfo->nDataOffset );

                if ( (LPMEMORY) pValue >= pInstPartStart && (LPMEMORY) pValue < pInstPartEnd )
                {
                    LPMEMORY    pData = m_Heap.ResolveHeapPointer( pValue->AccessPtrData() );

                    if ( pData >= pHeapStart && pData < pHeapEnd  )
                    {
                        // We could, if an embedded object, validate the object,
                        // or if an array of ptr values, validate those as well

                        if ( CType::IsArray( pInfo->nType ) )
                        {
                            hres = ((CUntypedArray*) pData)->IsArrayValid( pInfo->nType, &m_Heap );

                            if ( FAILED( hres ) )
                            {
                                return hres;
                            }
                        }
                        else if (pInfo->nType == CIM_OBJECT)
                        {
                            int BytesTillEndOfHeap = m_Heap.ElementMaxSize(pValue->AccessPtrData());
                            if (BytesTillEndOfHeap < sizeof(length_t)) return WBEM_E_FAILED;
                            BytesTillEndOfHeap -= sizeof(length_t);
                            length_t UNALIGNED * pLen = (length_t UNALIGNED *)pData;
                            if (*pLen > BytesTillEndOfHeap) return WBEM_E_FAILED;
                            pData += sizeof(length_t);

                            try
                            {
                                embededList.push_back(EmbeddedObj(pData,BytesTillEndOfHeap));
                            }
                            catch(CX_Exception&)
                            {
                                return WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                    }
                    else
                    {
                        _ASSERT( 0, __TEXT("Winmgmt: Bad Property Value in Instance Part!") );
                        return WBEM_E_FAILED;
                    }
                }
                else
                {
                    _ASSERT( 0, __TEXT("Winmgmt: Bad Untyped Value Pointer in Instance Part DataTable!") );
                    return WBEM_E_FAILED;
                }

            }   // IF is Pointer

        }   // IF not NULL or default

        // Now check the qualifier set.
        CInstancePropertyQualifierSet   ipqs;

         ipqs.SetData(&m_PropQualifiers, pInfo->nDataIndex,
            pClassPart, (length_t) ( pInfo->GetQualifierSetData() - pClassPart->GetStart() )
        );

        hres = ipqs.IsValidQualifierSet();

        if ( FAILED( hres ) )
        {
            return hres;
        }


    }   // FOR iterate properties

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 void CInstancePart::Rebase(LPMEMORY pNewMemory)
{
    m_pHeader = (CInstancePartHeader*)pNewMemory;

    LPMEMORY pCurrent = pNewMemory + sizeof(CInstancePartHeader);

    m_DataTable.Rebase( pCurrent );
    m_Qualifiers.Rebase( EndOf(m_DataTable) );
    m_PropQualifiers.Rebase( EndOf(m_Qualifiers) );
    m_Heap.Rebase( EndOf(m_PropQualifiers) );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
BOOL CInstancePart::ReallocAndCompact(length_t nNewTotalLength)
{
    BOOL    fReturn = TRUE;
    Compact();

    // Reallocate if required (will call rebase)
    // =========================================

    if(nNewTotalLength > m_pHeader->nLength)
    {
        fReturn = m_pContainer->ExtendInstancePartSpace(this, nNewTotalLength);

        if ( fReturn )
        {
            m_pHeader->nLength = nNewTotalLength;
        }
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 void CInstancePart::Compact( bool bTrim /* = true */)
{
    // Compact
    // =======
    LPMEMORY pCurrent = GetStart() + sizeof(CInstancePartHeader);

    MoveBlock( m_DataTable, pCurrent );
    MoveBlock(m_Qualifiers, EndOf(m_DataTable));
    MoveBlock(m_PropQualifiers, EndOf(m_Qualifiers));
    MoveBlock(m_Heap, EndOf(m_PropQualifiers));

    if ( bTrim )
        m_Heap.Trim();
}


//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 length_t CInstancePart::ComputeNecessarySpace(CClassPart* pClassPart)
{
    return sizeof(CInstancePartHeader) +
        CDataTable::ComputeNecessarySpace(
                        pClassPart->m_Properties.GetNumProperties(),
                        pClassPart->m_pHeader->nDataLength) +
        CInstanceQualifierSet::GetMinLength() +
        CInstancePropertyQualifierSetList::ComputeNecessarySpace(
                        pClassPart->m_Properties.GetNumProperties()) +
        CFastHeap::GetMinLength() +
        pClassPart->m_Heap.ResolveString(
        pClassPart->m_pHeader->ptrClassName)->GetLength();
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 LPMEMORY CInstancePart::Create(LPMEMORY pStart, CClassPart* pClassPart,
                                      CInstancePartContainer* pContainer)
{
    m_pContainer = pContainer;

    // Create instance header
    // ======================

    LPMEMORY pCurrent = pStart + sizeof(CInstancePartHeader);
    m_pHeader = (CInstancePartHeader*)pStart;

    // Create data table appropriate for the class
    // ===========================================

    int nNumProps = pClassPart->m_Properties.GetNumProperties();
    m_DataTable.SetData(
        pCurrent,
        nNumProps,
        pClassPart->m_pHeader->nDataLength,
        this);
    m_DataTable.SetAllToDefault();
    m_DataTable.CopyNullness(&pClassPart->m_Defaults);

    // Create empty instance qualifier set
    // ===================================

    pCurrent = EndOf(m_DataTable);
    CInstanceQualifierSet::CreateEmpty(pCurrent);
    m_Qualifiers.SetData(
        pCurrent,
        this,
        &pClassPart->m_Qualifiers);

    // Create a list of empty qualifier sets for all properties
    // ========================================================

    pCurrent = EndOf(m_Qualifiers);
    CInstancePropertyQualifierSetList::CreateListOfEmpties(pCurrent,
        nNumProps
    );
    m_PropQualifiers.SetData(
        pCurrent,
        nNumProps,
        this);

    // Create a heap that is just large enough to contain the class name
    // =================================================================

    CCompressedString* pcsName =
        pClassPart->m_Heap.ResolveString(pClassPart->m_pHeader->ptrClassName);
    int nNameLen = pcsName->GetLength();

    pCurrent = EndOf(m_PropQualifiers);
    m_Heap.CreateOutOfLine(pCurrent, nNameLen);
    m_Heap.SetContainer(this);

    // Copy the name to the heap
    // =========================

    // Check for Allocation failure
    if ( !m_Heap.Allocate(nNameLen, m_pHeader->ptrClassName) )
    {
        return NULL;
    }
    
    memcpy(m_Heap.ResolveHeapPointer(m_pHeader->ptrClassName),
        pcsName, nNameLen );

    // Configure the instance header structure properly
    // ================================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok

    m_pHeader->nLength = (length_t) ( EndOf(m_Heap) - GetStart() );

    return pStart + m_pHeader->nLength;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CInstancePart::GetActualValue(CPropertyInformation* pInfo,
                                          CVar* pVar)
{
    if(m_DataTable.IsNull(pInfo->nDataIndex))
    {
        pVar->SetAsNull();
        return WBEM_S_NO_ERROR;
    }
    CUntypedValue* pValue = m_DataTable.GetOffset(pInfo->nDataOffset);

    // Check for allocation failure
    if ( !pValue->StoreToCVar(pInfo->GetType(), *pVar, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;

}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CInstancePart::SetActualValue(CPropertyInformation* pInfo,
                                             CVar* pVar)
{
    if(pVar->IsNull() || pVar->IsDataNull())
    {
        m_DataTable.SetNullness(pInfo->nDataIndex, TRUE);
        m_DataTable.SetDefaultness(pInfo->nDataIndex, FALSE);
    }
    else
    {
        if(!CUntypedValue::CheckCVar(*pVar, pInfo->GetType()))
            return WBEM_E_TYPE_MISMATCH;

        // Check the type
        // ==============
        if(!CType::DoesCIMTYPEMatchVARTYPE(pInfo->GetType(),
                                            (VARTYPE) pVar->GetOleType()))
        {
            // Attempt coercion
            // ================

            if(!pVar->ChangeTypeTo(CType::GetVARTYPE(pInfo->GetType())))
                return WBEM_E_TYPE_MISMATCH;
        }

        // Check for special case of replacing a string with a shorted one
        // ===============================================================

        BOOL bUseOld = !m_DataTable.IsDefault(pInfo->nDataIndex) &&
                       !m_DataTable.IsNull(pInfo->nDataIndex);

        // Create a value pointing to the right offset in the data table
        // =============================================================

        CDataTablePtr ValuePtr(&m_DataTable, pInfo->nDataOffset);

        int nDataIndex = pInfo->nDataIndex;

        // Load it (types have already been checked)
        // =========================================

        // Check for possible memory allocation failures
        Type_t  nReturnType;
        HRESULT hr = CUntypedValue::LoadFromCVar(&ValuePtr, *pVar,
                        CType::GetActualType(pInfo->GetType()), &m_Heap, nReturnType, bUseOld);

        if ( FAILED( hr ) )
        {
            return hr;
        }

        if ( CIM_ILLEGAL == nReturnType )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        pInfo = NULL; // invalidated

        // Clear the special bits
        // ======================

        m_DataTable.SetNullness(nDataIndex, FALSE);
        m_DataTable.SetDefaultness(nDataIndex, FALSE);
        m_pContainer->ClearCachedKeyValue();

    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CInstancePart::GetObjectQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor)
{
    int nKnownIndex;    // garbage
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally(wszName, nKnownIndex);

    if(pQual == NULL) return WBEM_E_NOT_FOUND;
    if(plFlavor) *plFlavor = pQual->fFlavor;

    // Check for allocation failures
    if ( !pQual->Value.StoreToCVar(*pVar, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CInstancePart::SetInstanceQualifier(LPCWSTR wszName, CVar* pVar,
        long lFlavor)
{
    _DBG_ASSERT(wszName != 0);
    
    if(pVar->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVar, &m_Heap);

    if ( SUCCEEDED( hr ) )
    {
        hr = m_Qualifiers.SetQualifierValue(wszName, (BYTE)lFlavor,
                &Value, TRUE);
    }
    return hr;
}

// Helper that sends a value directly into a qualifier
HRESULT CInstancePart::SetInstanceQualifier( LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue )
{        
    return  m_Qualifiers.SetQualifierValue( wszName, (BYTE)lFlavor, pTypedValue, TRUE );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CInstancePart::GetQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor, CIMTYPE* pct /*=NULL*/)
{
    return m_Qualifiers.GetQualifier( wszName, pVar, plFlavor, pct /*=NULL*/ );
}

// Returns a copy of the live typed value
HRESULT CInstancePart::GetQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
                                    CFastHeap** ppHeap, BOOL fValidateSet )
{
    return m_Qualifiers.GetQualifier( wszName, plFlavor, pTypedValue, ppHeap, fValidateSet );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
BOOL CInstancePart::TranslateToNewHeap(CClassPart& ClassPart,
                                              CFastHeap* pOldHeap,
                                              CFastHeap* pNewHeap)
{
    // Use a stack variable, since a reallocation can occur here
    heapptr_t   ptrTemp;
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName, pOldHeap, pNewHeap, ptrTemp ) )
    {
        return FALSE;
    }

    // Store the new value
    m_pHeader->ptrClassName = ptrTemp;

    // Check for allocation failure
    if ( !m_DataTable.TranslateToNewHeap(&ClassPart.m_Properties, FALSE,
                                         pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    CStaticPtr QualPtr(m_Qualifiers.GetStart());

    // Check for allocation failure
    if ( !CBasicQualifierSet::TranslateToNewHeap(&QualPtr, pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !m_PropQualifiers.TranslateToNewHeap(pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    return TRUE;

}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************

void CInstancePart::DeleteProperty(CPropertyInformation* pInfo)
{
    _DBG_ASSERT(pInfo);
    m_DataTable.RemoveProperty(pInfo->nDataIndex, pInfo->nDataOffset,
                    CType::GetLength(pInfo->nType));
    m_PropQualifiers.DeleteQualifierSet(pInfo->nDataIndex);
    Compact();
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************

LPMEMORY CInstancePart::ConvertToClass(CClassPart& ClassPart, length_t nLen,
                                        LPMEMORY pMemory)
{
    LPMEMORY pCurrent = pMemory;
    memcpy(pCurrent, (LPMEMORY)m_pHeader, sizeof(CInstancePartHeader));
    CInstancePartHeader* pNewHeader = (CInstancePartHeader*)pCurrent;
    pNewHeader->nLength = nLen;

    // NOTE: class name is intentionally left old.

    pCurrent += sizeof(CInstancePartHeader);

    // Write the data table
    // ====================

    pCurrent = m_DataTable.WriteSmallerVersion(
                    ClassPart.m_Properties.GetNumProperties(),
                    ClassPart.m_pHeader->nDataLength,
                    pCurrent);

    // Write qualifiers
    // ================

    memcpy(pCurrent, m_Qualifiers.GetStart(), m_Qualifiers.GetLength());
    pCurrent += m_Qualifiers.GetLength();

    // Write property qualifiers
    // =========================

    pCurrent = m_PropQualifiers.WriteSmallerVersion(
                    ClassPart.m_Properties.GetNumProperties(), pCurrent);

    // Copy the heap
    // =============

    memcpy(pCurrent, m_Heap.GetStart(), m_Heap.GetLength());
    pCurrent += m_Heap.GetLength();

    return pCurrent;
}


//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 void CWbemInstance::SetData(LPMEMORY pStart, int nTotalLength)
{
    m_nTotalLength = nTotalLength;
    int LengthConsumed = nTotalLength;

    m_DecorationPart.SetData(pStart);
    if (m_DecorationPart.GetLength() > LengthConsumed) throw CX_Exception();
    LengthConsumed -=  m_DecorationPart.GetLength();
    
    m_ClassPart.SetData( m_DecorationPart.GetStart() + m_DecorationPart.GetLength(),this);
    if (m_ClassPart.GetLength() > LengthConsumed) throw CX_Exception();
    LengthConsumed -=  m_ClassPart.GetLength();

    
    m_InstancePart.SetData( m_ClassPart.GetStart() + m_ClassPart.GetLength(),
                                         this,m_ClassPart,LengthConsumed);
    
    if (m_InstancePart.GetLength() > LengthConsumed) throw CX_Exception();
    LengthConsumed -=  m_InstancePart.GetLength();
    
    // Everything is internal now
    m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                        WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;
}

 //******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
void CWbemInstance::SetData( LPMEMORY pStart, int nTotalLength, DWORD dwBLOBStatus )
{
    m_nTotalLength = nTotalLength;

    // Check for this, but don't fail, since this is internal, and only to prevent
    // lazy development
    _ASSERT( dwBLOBStatus & WBEM_OBJ_DECORATION_PART, __TEXT("CWbemInstance::SetData called without Decoration Part specified!"))

    // Decoration part is assumed
    m_DecorationPart.SetData(pStart);

    // Set Instance and Class only if they are available.  Note that for
    // Instance to work, we NEED to have the class, so even if the data is
    // available in the BLOB, without a class to describe it, the data
    // is effectively useless.

    if ( dwBLOBStatus & WBEM_OBJ_CLASS_PART )
    {
        nTotalLength -= m_DecorationPart.GetLength(),

        m_ClassPart.SetData(
            m_DecorationPart.GetStart() + m_DecorationPart.GetLength(),
            this);

        nTotalLength -= m_ClassPart.GetLength();


        if ( dwBLOBStatus & WBEM_OBJ_INSTANCE_PART )
        {
            m_InstancePart.SetData(
                m_ClassPart.GetStart() + m_ClassPart.GetLength(),
                this,
                m_ClassPart,
                nTotalLength);
        }
    }

    // Save the local BLOB Status
    m_dwInternalStatus = dwBLOBStatus;

}



size_t CWbemInstance::ValidateBuffer(LPMEMORY start, size_t cbSize, DeferedObjList& embeddedList)
{

size_t step = CDecorationPart::ValidateBuffer(start, cbSize);
size_t classSize = CClassPart::ValidateBuffer(start+step, cbSize-step);

DummyClassPartContainer containter;
CClassPart classData;
classData.SetData(start+step, &containter, 0);

step += classSize;
step += CInstancePart::ValidateBuffer(start+step, cbSize-step, classData, embeddedList);
return step;
};

size_t CWbemInstance::ValidateBuffer( LPMEMORY start, int cbSize, DWORD dwBLOBStatus, DeferedObjList& embeddedList )
{
size_t step = CDecorationPart::ValidateBuffer(start, cbSize);
if ( dwBLOBStatus & WBEM_OBJ_CLASS_PART )
	
{
	size_t classSize  = CClassPart::ValidateBuffer(start+step, cbSize-step);

	CClassPart classData;
	classData.SetData(start+step, 0, 0);

	step+=classSize;
	
    	if ( dwBLOBStatus & WBEM_OBJ_INSTANCE_PART )	
    	{
		step += CInstancePart::ValidateBuffer(start+step, cbSize-step, classData, embeddedList);
    	}
}
return step;
};



//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
void CWbemInstance::Rebase(LPMEMORY pMemory)
{
    m_DecorationPart.Rebase(pMemory);

    // Different based on whether the class is internal or not
    if ( IsClassPartInternal() )
    {
        m_ClassPart.Rebase( EndOf(m_DecorationPart));
        m_InstancePart.Rebase( EndOf(m_ClassPart));
    }
    else
    {
        m_InstancePart.Rebase( EndOf(m_DecorationPart));
    }
}



//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::InitializePropQualifierSet(LPCWSTR wszProp,
                                CInstancePropertyQualifierSet& IPQS)
{
    CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszProp);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;

    return InitializePropQualifierSet(pInfo, IPQS);
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::InitializePropQualifierSet(
                                CPropertyInformation* pInfo,
                                CInstancePropertyQualifierSet& IPQS)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pInfo->GetQualifierSetData() - m_ClassPart.GetStart().
    // We are not supporting length > 0xFFFFFFFF, so cast is ok

     IPQS.SetData(&m_InstancePart.m_PropQualifiers, pInfo->nDataIndex,
        &m_ClassPart, (length_t) ( pInfo->GetQualifierSetData() - m_ClassPart.GetStart() )
    );
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::GetPropQualifier(CPropertyInformation* pInfo,
                                              LPCWSTR wszQualifier,
                                              CVar* pVar, long* plFlavor,
                                              CIMTYPE* pct /*=NULL*/)
{
    // Access that property's qualifier set
    // ====================================
    CInstancePropertyQualifierSet IPQS;
    HRESULT hres = InitializePropQualifierSet(pInfo, IPQS);

    if (FAILED(hres)) return hres;

    // Get the qualifier
    // =================

    BOOL bIsLocal;
    CQualifier* pQual = IPQS.GetQualifier(wszQualifier, bIsLocal);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Convert to CVar
    // ===============

    if(plFlavor)
    {
        *plFlavor = pQual->fFlavor;
        CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, bIsLocal);
    }

    if ( NULL != pct )
    {
        *pct = pQual->Value.GetType();
    }

    // Check for allocation failures
    if ( NULL != pVar )
    {
        if ( !pQual->Value.StoreToCVar(*pVar,
                (bIsLocal)?&m_InstancePart.m_Heap:&m_ClassPart.m_Heap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_NO_ERROR;
}

HRESULT CWbemInstance::GetPropQualifier(CPropertyInformation* pInfo,
        LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
        CFastHeap** ppHeap, BOOL fValidateSet)
{
    // Access that property's qualifier set
    // ====================================
    CInstancePropertyQualifierSet IPQS;
    HRESULT hr = InitializePropQualifierSet(pInfo, IPQS);

    if ( FAILED(hr))
    {
        return hr;
    }

    // Get the qualifier
    // =================

    BOOL bIsLocal;
    CQualifier* pQual = IPQS.GetQualifier(wszQualifier, bIsLocal);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Make sure a set will actually work - Ostensibly we are calling this API because we need
    // direct access to a qualifier's underlying data before actually setting (possibly because
    // the qualifier is an array).
    if ( fValidateSet )
    {
        hr = IPQS.ValidateSet( wszQualifier, pQual->fFlavor, pTypedVal, TRUE, TRUE );
    }

    // 
    // Convert to CVar
    // ===============

    if(plFlavor)
    {
        *plFlavor = pQual->fFlavor;
        CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, bIsLocal);
    }

    // Store the heap
    *ppHeap = (bIsLocal)?&m_InstancePart.m_Heap:&m_ClassPart.m_Heap;

    if ( NULL != pTypedVal )
    {
        pQual->Value.CopyTo( pTypedVal );
    }

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::GetMethodQualifier(LPCWSTR wszMethodName,
                                              LPCWSTR wszQualifier,
                                              CVar* pVar, long* plFlavor,
                                              CIMTYPE* pct /*=NULL*/)
{
    return WBEM_E_INVALID_OPERATION;
}

HRESULT CWbemInstance::GetMethodQualifier(LPCWSTR wszMethodName,
        LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
        CFastHeap** ppHeap, BOOL fValidateSet)
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::SetPropQualifier(LPCWSTR wszProp,
                                              LPCWSTR wszQualifier,
                                       long lFlavor, CVar *pVal)
{
    if(pVal->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    // Access that property's qualifier set
    // ====================================

    CInstancePropertyQualifierSet IPQS;
    HRESULT hr = InitializePropQualifierSet(wszProp, IPQS);
    if (FAILED(hr)) return hr;

    // Set the qualifier
    // =================
    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Get errors directly from this call
    hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVal, &m_InstancePart.m_Heap);

    if ( SUCCEEDED( hr ) )
    {
        IPQS.SelfRebase();
        hr = IPQS.SetQualifierValue(wszQualifier, (BYTE)lFlavor, &Value, TRUE);
    }
    return hr;
}

HRESULT CWbemInstance::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                        long lFlavor, CTypedValue* pTypedVal)
{
    // Access that property's qualifier set
    // ====================================

    CInstancePropertyQualifierSet IPQS;
    HRESULT hr = InitializePropQualifierSet(wszProp, IPQS);

    if ( SUCCEEDED( hr ) )
    {
        hr = IPQS.SetQualifierValue(wszQualifier, (BYTE)lFlavor, pTypedVal, TRUE);
    }

    return hr;
}

HRESULT CWbemInstance::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
                                        CVar *pVal)
{
    return WBEM_E_INVALID_OPERATION;
}

HRESULT CWbemInstance::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
                                        long lFlavor, CTypedValue* pTypedVal)
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 length_t CWbemInstance::EstimateInstanceSpace(
                               CClassPart& ClassPart,
                               CDecorationPart* pDecoration)
{
    return ClassPart.GetLength() +
        CInstancePart::ComputeNecessarySpace(&ClassPart) +
        ((pDecoration)?
            pDecoration->GetLength()
            :CDecorationPart::GetMinLength());
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CWbemInstance::InitNew(CWbemClass* pClass, int nExtraMem,
                    CDecorationPart* pDecoration)
{
    if(pClass->m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName ==
                                                        INVALID_HEAP_ADDRESS)
        return WBEM_E_INCOMPLETE_CLASS;
    int nLength = EstimateInstanceSpace(pClass->m_CombinedPart.m_ClassPart) +
                                            nExtraMem;

    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    LPMEMORY pNewData = m_pBlobControl->Allocate(nLength);

    if ( NULL != pNewData )
    {
        memset(pNewData, 0, nLength);
        hr = InitEmptyInstance(pClass->m_CombinedPart.m_ClassPart, pNewData, nLength);
    }

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 CWbemInstance* CWbemInstance::CreateFromBlob(CWbemClass* pClass,
 											  LPMEMORY pInstPart,
 											  size_t cbLength)
{
    CWbemInstance* pInstance = new CWbemInstance;
    if ( NULL == pInstance ) throw CX_MemoryException();
    CReleaseMe rm_((IWbemClassObject *)pInstance);

    // Allocate new memory
    int nInstancePartLen = CInstancePart::GetLength(pInstPart);
    int nTotalLen = pClass->m_CombinedPart.m_ClassPart.GetLength() +
                            nInstancePartLen + CDecorationPart::GetMinLength();

    // Create decoration part
    LPMEMORY pNewMem =  pInstance->m_pBlobControl->Allocate(nTotalLen);
    if ( NULL == pNewMem ) throw CX_MemoryException();

    
    memset(pNewMem, 0, nTotalLen);

    // this one takes ownership of the memory
    LPMEMORY pCurrentEnd = pInstance->m_DecorationPart.CreateEmpty(OBJECT_FLAG_INSTANCE, pNewMem);

    // Create class part
    // =================
    memcpy(pCurrentEnd, pClass->m_CombinedPart.m_ClassPart.GetStart(),
                pClass->m_CombinedPart.m_ClassPart.GetLength());
    pInstance->m_ClassPart.SetData(pCurrentEnd, pInstance);

    pCurrentEnd += pInstance->m_ClassPart.GetLength();

    // Create instance part
    // ====================

    memcpy(pCurrentEnd, pInstPart, nInstancePartLen);
    pInstance->m_InstancePart.SetData(pCurrentEnd, pInstance,
                                                          pInstance->m_ClassPart,
                                                          nInstancePartLen);

    pInstance->m_nTotalLength = nTotalLen;

    // Everything is internal
    pInstance->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                                    WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;

    // Perform object validation here
    if ( FAILED( pInstance->ValidateObject( 0L ) ) ) return NULL;

    pInstance->AddRef();
    return pInstance;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
CWbemInstance* CWbemInstance::CreateFromBlob2(CWbemClass* pClass,LPMEMORY pInstPart,
                                                                               WCHAR * pszServer,WCHAR * pszNamespace)
{
    CWbemInstance* pInstance = new CWbemInstance;
    if ( NULL == pInstance )  throw CX_MemoryException();
    CReleaseMe rm((_IWmiObject*)pInstance);

   // Allocate new memory

    BOOL IsAsciableSrv;
    long nByteServer  = CCompressedString::ComputeNecessarySpace(pszServer,IsAsciableSrv);
    BOOL IsAsciableNS;
    long nByteNamespace  = CCompressedString::ComputeNecessarySpace(pszNamespace,IsAsciableNS);        

    long nDecorationSpace = CDecorationPart::GetMinLength() + nByteServer + nByteNamespace;
 
    int nInstancePartLen = CInstancePart::GetLength(pInstPart);
    int nTotalLen = pClass->m_CombinedPart.m_ClassPart.GetLength() + nInstancePartLen + nDecorationSpace ;

    // Create decoration part
    // ======================

    LPMEMORY pNewMem =  pInstance->m_pBlobControl->Allocate(nTotalLen);
    if ( NULL == pNewMem )  throw CX_MemoryException();

    //memset(pNewMem, 0, nTotalLen);

    BYTE * pNewData = pNewMem;

    *pNewData = OBJECT_FLAG_DECORATED |OBJECT_FLAG_INSTANCE;
    pNewData++;
    ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableSrv,pszServer);
    pNewData+=nByteServer;
    ((CCompressedString *)pNewData)->SetFromUnicode(IsAsciableNS,pszNamespace);
    pNewData+=nByteNamespace;

    pInstance->m_DecorationPart.SetData(pNewMem);
    LPMEMORY pCurrentEnd = pNewData;

    // Create class part
    // =================
    memcpy(pCurrentEnd, pClass->m_CombinedPart.m_ClassPart.GetStart(),
                pClass->m_CombinedPart.m_ClassPart.GetLength());
    pInstance->m_ClassPart.SetData(pCurrentEnd, pInstance);

    pCurrentEnd += pInstance->m_ClassPart.GetLength();

    // Create instance part
    // ====================

    memcpy(pCurrentEnd, pInstPart, nInstancePartLen);
    pInstance->m_InstancePart.SetData(pCurrentEnd, pInstance,
                                                          pInstance->m_ClassPart,
                                                          nInstancePartLen);

    pInstance->m_nTotalLength = nTotalLen;

    // Everything is internal
    pInstance->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                                    WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;

    // Perform object validation here
    if (FAILED(pInstance->ValidateObject(0L)))  return NULL;


    pInstance->AddRef();
    return pInstance;
}


//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CWbemInstance::Unmerge(LPMEMORY pStart, int nAllocatedLength, length_t* pnUnmergedLength )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // See if the object looks okay before we pull it apart
    hr = ValidateObject( 0L );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    if (m_InstancePart.GetLength() > nAllocatedLength) return WBEM_E_BUFFER_TOO_SMALL;
    
    // Before doing the memcpy, shut off the localization flag, then if it
    // was on, turn it back on again.

    BOOL    fLocalized = m_InstancePart.IsLocalized();

    // Turn it off
    if ( fLocalized )
    {
        m_InstancePart.SetLocalized( FALSE );
    }

    memcpy(pStart, m_InstancePart.GetStart(), m_InstancePart.GetLength());

    // Turn it back on
    if ( fLocalized )
    {
        m_InstancePart.SetLocalized( TRUE );
    }

    CInstancePart IP;
    IP.SetData(pStart, this, m_ClassPart,m_InstancePart.GetLength());
    IP.m_Heap.Empty();

    // Check for allocation failurtes
    if ( IP.TranslateToNewHeap(m_ClassPart, &m_InstancePart.m_Heap, &IP.m_Heap) )
    {
        IP.m_Heap.Trim();

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We are not supporting length
        // > 0xFFFFFFFF, so cast is ok

        IP.m_pHeader->nLength = (length_t) ( EndOf(IP.m_Heap) - IP.GetStart() );

        if ( NULL != pnUnmergedLength )
        {
            *pnUnmergedLength = IP.GetLength();
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}


HRESULT CWbemInstance::CopyBlob(LPMEMORY pBlob, int nLength)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting length
    // > 0xFFFFFFFF, so cast is ok

    int nOffset = (int) ( m_InstancePart.GetStart() - GetStart() );

    if(nLength - nOffset > m_InstancePart.GetLength())
    {
        // Check for insufficient memory
        if ( !ExtendInstancePartSpace(&m_InstancePart, nLength - nOffset) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    memcpy(m_InstancePart.GetStart(), pBlob + nOffset, nLength - nOffset);
    m_InstancePart.SetData(m_InstancePart.GetStart(), this, m_ClassPart,nLength - nOffset);
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemInstance::CopyBlobOf(CWbemObject* pSource)
{
    try
    {
        // Lock both BLOBs during this operation
        CLock lock1(this);
        CLock lock2(pSource, WBEM_FLAG_ALLOW_READ);

        CWbemInstance* pOther = (CWbemInstance*)pSource;

        int nLen = pOther->m_InstancePart.GetLength();

        // We will need to call SetData if the used data sizes are different,
        // or qualifier data is different

        BOOL fSetData =     ( m_InstancePart.m_Heap.GetUsedLength() !=
                                pOther->m_InstancePart.m_Heap.GetUsedLength() )
                        ||  ( m_InstancePart.m_Qualifiers.GetLength() !=
                                pOther->m_InstancePart.m_Qualifiers.GetLength() )
                        ||  ( m_InstancePart.m_PropQualifiers.GetLength() !=
                                pOther->m_InstancePart.m_PropQualifiers.GetLength() );

        if(nLen > m_InstancePart.GetLength())
        {
            // Check for insufficient memory
            if ( !ExtendInstancePartSpace(&m_InstancePart, nLen) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            // This needs to reflect the new length (normally this
            // is done in ReallocAndCompact
            m_InstancePart.m_pHeader->nLength = nLen;

            // If the lengths didn't match, we should also call SetData
            fSetData = TRUE;
        }

        memcpy(m_InstancePart.GetStart(), pOther->m_InstancePart.GetStart(), nLen);

        // This call properly sets up our data if any lengths changed.
        if ( fSetData )
        {
            m_InstancePart.SetData(m_InstancePart.GetStart(), this, m_ClassPart,nLen);
        }

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        // Something bad happened
        return WBEM_E_CRITICAL_ERROR;
    }
}

// A transfer blob consists of long specifying the length of the used heap data, and then
// instance data.  The used heap data is necessary so the client side will be able to
// correctly set up the heap.

void CWbemInstance::GetActualTransferBlob( BYTE* pBlob )
{
    // Set the used data length, then skip over that
    length_t UsedSize = m_InstancePart.m_Heap.GetUsedLength();
    length_t AllocatedSize = m_InstancePart.m_Heap.GetAllocatedDataLength();

    length_t ToBeSetSize = (AllocatedSize&0x80000000)?(UsedSize|0x8000000):UsedSize;

    m_InstancePart.m_Heap.SetAllocatedDataLength(ToBeSetSize);
    
    (*(UNALIGNED long*) pBlob) = UsedSize;
    pBlob += sizeof(long);

    // Only copies actual BLOB data
    memcpy( pBlob, m_InstancePart.m_DataTable.GetStart(), GetActualTransferBlobSize() );

    // restore old
    m_InstancePart.m_Heap.SetAllocatedDataLength(AllocatedSize);
}

HRESULT CWbemInstance::GetTransferBlob(long *plBlobType, long *plBlobLen,
                                /* CoTaskAlloced! */ BYTE** ppBlob)
{
    _DBG_ASSERT(plBlobType && plBlobLen && ppBlob);
    
    // Lock this BLOB during this operation
    CLock lock(this, WBEM_FLAG_ALLOW_READ);

    *plBlobType = WBEM_BLOB_TYPE_ALL;
    *plBlobLen = GetTransferBlobSize();



    // Check for insufficient memory
    *ppBlob = (LPMEMORY)CoTaskMemAlloc(*plBlobLen);
    if ( NULL == *ppBlob )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // This will setup the actual blob correctly
    GetActualTransferBlob( *ppBlob );

    return WBEM_S_NO_ERROR;
}

HRESULT CWbemInstance::GetTransferArrayBlob( long lBlobLen, BYTE** ppBlob, long* plBlobLen)
{
    _DBG_ASSERT(ppBlob && *ppBlob && plBlobLen);

    // Lock this BLOB during this operation
    CLock lock(this, WBEM_FLAG_ALLOW_READ);

    HRESULT hr = WBEM_S_NO_ERROR;
    BYTE*   pTemp = *ppBlob;

    *plBlobLen = GetTransferArrayBlobSize();

    // Make sure the buffer is big enough to hold the BLOB plus the long
    if ( *plBlobLen <= lBlobLen )
    {
        // This should indicate the actual size of the tramsfer blob.
        *((UNALIGNED long*) pTemp) = GetTransferBlobSize();

        // Now skip the long and set the heap used data value, then copy the blob data
        pTemp += sizeof(long);

        // This will setup the actual Transfer Blob portion correctly
        GetActualTransferBlob( pTemp );

        // Point ppBlob at the next available blob
        *ppBlob += *plBlobLen;
    }
    else
    {
        hr = WBEM_E_BUFFER_TOO_SMALL;
    }

    return hr;
}

//
// copy the Instance Transfer Blob into the "empty" instance
//
////////////////////////////////////////////////////////////////////
HRESULT CWbemInstance::CopyActualTransferBlob(long lBlobLen, BYTE* pBlob)

{
    _DBG_ASSERT(pBlob);
    _DBG_ASSERT(lBlobLen >= sizeof(long));
    // Lock this BLOB during this operation
    CLock lock(this);

    // The actual data is preceded by a long indicating the size of the
    // used data in the heap so we can set values correctly after copying data
    UNALIGNED long*   pUsedDataLen = (UNALIGNED long*) pBlob;
    pBlob += sizeof(long);

    // Make sure we adjust lBlobLen appropriately as well
    lBlobLen -= sizeof(long);

    // Make sure we will be big enough to copy the BLOB into

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok

    long lCurrentLength = (long) ( m_InstancePart.m_Heap.GetStart() +
                    m_InstancePart.m_Heap.GetRealLength() -
                    m_InstancePart.m_DataTable.GetStart() );

    if ( lBlobLen > lCurrentLength )
    {
        length_t    nNewLength = m_InstancePart.GetLength() + ( lBlobLen - lCurrentLength );

        if ( !ExtendInstancePartSpace( &m_InstancePart, nNewLength ) )
        {
            return  WBEM_E_OUT_OF_MEMORY;
        }

        // This needs to reflect the new length (normally this
        // is done in ReallocAndCompact
        m_InstancePart.m_pHeader->nLength = nNewLength;

    }
    else
    {
        // this the good case where the instance heap of the CWbemInstance
        // is big enough
    }

	size_t HeaderSize = (ULONG_PTR)m_InstancePart.m_DataTable.GetStart() - (ULONG_PTR)m_InstancePart.GetStart();
    memcpy(m_InstancePart.m_DataTable.GetStart(), pBlob, lBlobLen);

    // Reset the pointers then restore our actual allocated length    
    m_InstancePart.SetData( m_InstancePart.GetStart(), this, m_ClassPart,lBlobLen + HeaderSize);
    m_InstancePart.m_Heap.SetAllocatedDataLength( *pUsedDataLen );
    m_InstancePart.m_Heap.SetUsedLength( *pUsedDataLen );

    return WBEM_S_NO_ERROR;
}

HRESULT CWbemInstance::CopyTransferBlob(long lBlobType, long lBlobLen,
                                        BYTE* pBlob)
{
    // Lock this BLOB during this operation
    CLock lock(this);
    try
    {
	if(lBlobType == WBEM_BLOB_TYPE_ERROR)
	    return (HRESULT)lBlobLen;

	return CopyActualTransferBlob( lBlobLen, pBlob );
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//
//  LONG Version
//  LONG NumObjects
//  (LONG BytesPerInstance (BYTE Data * BytesPerInstance )) * NumObjects
//
//
////////////////////////////////////////////////////////////////

HRESULT CWbemInstance::CopyTransferArrayBlob(CWbemInstance* pInstTemplate, 
                                                                        long lBlobType, 
                                                                        long lBlobLen,
                                                                           BYTE* pBlob, 
                                                                           CFlexArray& apObj, 
                                                                           long* plNumArrayObj )
{
    try
    {
		if(lBlobType == WBEM_BLOB_TYPE_ERROR)
		    return (HRESULT)lBlobLen;

		HRESULT hr = WBEM_S_NO_ERROR;

		if ( NULL != pBlob )
		{
		    UNALIGNED long*   plVersion = (UNALIGNED long*) pBlob;
		    UNALIGNED long*   plNumObjects = (UNALIGNED long*) ( pBlob + sizeof(long) );
		    BYTE*   pNextObj = pBlob + (2*sizeof(long));
		    DWORD   dwCtr = 0;

		    // Check for version mismatches
		    if ( *plVersion == TXFRBLOBARRAY_PACKET_VERSION )
		    {
		        // See if the array is big enough.  If not, realloc it and insert new objects

		        if ( apObj.Size() < *plNumObjects )
		        {
		            IWbemClassObject*   pObj = NULL;

		            // Clone new instance objects and stick them in the array
		            for ( dwCtr = apObj.Size(); SUCCEEDED( hr ) && dwCtr < *plNumObjects; dwCtr++ )
		            {
		                hr = pInstTemplate->Clone( &pObj );
		                if ( SUCCEEDED( hr ) )
		                {
		                    if ( apObj.InsertAt( dwCtr, pObj ) != CFlexArray::no_error )
		                    {
		                        pObj->Release();
		                        return WBEM_E_OUT_OF_MEMORY;
		                    }
		                }
		            }

		        }   // IF reallocing array

		        if ( SUCCEEDED( hr ) )
		        {
		            // Store the number of returned objects
		            *plNumArrayObj = *plNumObjects;

		            // We have a size and a BLOB to worry about
		            UNALIGNED long*   plBlobSize = (UNALIGNED long*) pNextObj;

		            CWbemInstance*  pInst = NULL;

		            // Now pull out the Instance BLOBs
		            for ( dwCtr = 0; SUCCEEDED( hr ) && dwCtr < *plNumObjects; dwCtr++ )
		            {
		                pInst = (CWbemInstance*) apObj[dwCtr];

		                // Size is at the front of the BLOB
		                plBlobSize = (UNALIGNED long*) pNextObj;

		                // Point pNextObj at the BLOB after the size
		                pNextObj += sizeof(long);


		                hr = pInst->CopyActualTransferBlob( *plBlobSize, pNextObj );

		                // This will point pNextObj at the length header for the next BLOB
		                pNextObj += *plBlobSize;

		            }   // FOR enum BLOBs

		        }   // IF initialized array

		    }   // IF version match
		    else
		    {
		        hr = WBEM_E_UNEXPECTED;
		    }

		}   // IF NULL != pData

		return hr;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }    
}

HRESULT CWbemInstance::DeleteProperty(int nIndex)
{
    if (IsClassPartShared())
    {
        CLock lock(this);
    
        DWORD dwLen = m_DecorationPart.GetLength() +
                      m_ClassPart.GetLength() +
                      m_InstancePart.GetLength();
                      
        BYTE * pMem = m_pBlobControl->Allocate(dwLen);
        
        if (pMem)
        {
            BYTE * pDeleteMe = GetStart();
            BYTE * pDecoration = pMem;
            BYTE * pClassPart = pMem + m_DecorationPart.GetLength();
            BYTE * pInstancePart = pClassPart + m_ClassPart.GetLength();

            memcpy(pDecoration,m_DecorationPart.GetStart(),m_DecorationPart.GetLength());
            memcpy(pClassPart,m_ClassPart.GetStart(),m_ClassPart.GetLength());
            int SavedInstPartLen = m_InstancePart.GetLength();
            memcpy(pInstancePart,m_InstancePart.GetStart(),SavedInstPartLen);

            m_DecorationPart.SetData(pDecoration);
            m_ClassPart.SetData(pClassPart,this);
            m_InstancePart.SetData(pInstancePart,this,m_ClassPart,SavedInstPartLen);

           
            m_dwInternalStatus &= (~WBEM_OBJ_CLASS_PART_SHARED);
            m_dwInternalStatus |= WBEM_OBJ_CLASS_PART_INTERNAL;

            if(m_pMergedClassObject)
            {
                m_pMergedClassObject->Release();
                m_pMergedClassObject = NULL;                
            }

            m_pBlobControl->Delete(pDeleteMe);

            m_nTotalLength = dwLen;
            
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
            
    }
    
    CPropertyInformation* pInfo = m_ClassPart.m_Properties.GetAt(nIndex)->
        GetInformation(&m_ClassPart.m_Heap);
    m_InstancePart.DeleteProperty(pInfo);
    m_ClassPart.DeleteProperty(nIndex);

    return WBEM_S_NO_ERROR;
}

BOOL CWbemInstance::IsInstanceOf(CWbemClass* pClass)
{
    // This now reroutes if our class part is localized
    if ( m_ClassPart.IsLocalized() )
    {
        EReconciliation eTest = m_ClassPart.CompareExactMatch( pClass->m_CombinedPart.m_ClassPart, TRUE );

        if ( e_OutOfMemory == eTest )
        {
            throw CX_MemoryException();
        }

        // We must perform an exhaustive comparison, filtering out localization data
        return ( e_ExactMatch == eTest );
    }
    
    return m_ClassPart.IsIdenticalWith(pClass->m_CombinedPart.m_ClassPart);
}

void CWbemInstance::CompactClass()
{
    // Only Account for the class part if it is internal
    if ( IsClassPartInternal() )
    {
        m_ClassPart.Compact();
    }

    m_InstancePart.Compact();

    // Only Account for the class part if it is internal
    if ( IsClassPartInternal() )
    {
        MoveBlock(m_InstancePart, EndOf(m_ClassPart));
    }
}

HRESULT CWbemInstance::ConvertToClass(CWbemClass* pClass,
                                        CWbemInstance** ppInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Calculate required space
    // ========================

    length_t nRequired = m_DecorationPart.GetLength() +
        pClass->m_CombinedPart.GetLength() +
        m_InstancePart.GetLength();

    LPMEMORY pNewMem = m_pBlobControl->Allocate(nRequired);

    if ( NULL != pNewMem )
    {
        // Copy the decoration and the class parts
        // =======================================

        LPMEMORY pCurrent = pNewMem;
        memcpy(pCurrent, m_DecorationPart.GetStart(), m_DecorationPart.GetLength());
        pCurrent+= m_DecorationPart.GetLength();

        memcpy(pCurrent, pClass->m_CombinedPart.m_ClassPart.GetStart(),
                            pClass->m_CombinedPart.m_ClassPart.GetLength());

        pCurrent+= pClass->m_CombinedPart.m_ClassPart.GetLength();

        // Create a converted instance part
        // ================================

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value (nRequired - (pCurrent - pNewMem))
        // We are not supporting length > 0xFFFFFFFF so cast is ok

        pCurrent = m_InstancePart.ConvertToClass(
                            pClass->m_CombinedPart.m_ClassPart,
                            nRequired - (length_t) (pCurrent - pNewMem),
                            pCurrent);

        // Create an instance from it
        // ==========================

        CWbemInstance* pInst =
            (CWbemInstance*)CWbemObject::CreateFromMemory(pNewMem, nRequired,
                                    TRUE, *m_pBlobControl);

        // Set the class name
        // ==================

        if ( NULL != pInst )
        {
            CReleaseMe _1((_IWmiObject*)pInst);
            // Use a stack variable, since a reallocation can occur here
            heapptr_t   ptrTemp;

            // Check for allocation errors.
            if ( CCompressedString::CopyToNewHeap(
                        pClass->m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName,
                        &pClass->m_CombinedPart.m_ClassPart.m_Heap,
                        &pInst->m_InstancePart.m_Heap,
                        ptrTemp ) )
            {
                // Now copy the new pointer
                pInst->m_InstancePart.m_pHeader->ptrClassName = ptrTemp;
                pInst->AddRef();
                *ppInst = pInst;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CWbemInstance::Reparent(CWbemClass* pClass,
                                CWbemInstance** ppInst)
{
    // First, we need to spawn a new instance
    CWbemInstance*  pNewInst = NULL;
    HRESULT hr = pClass->SpawnInstance( 0L, (IWbemClassObject**) &pNewInst );

    if ( SUCCEEDED( hr ) )
    {

        // DEVNOTE:TODO:PAUL - Comment this out if it's getting in your way
        // i.e. (not working ).  This is what should copy properties.

        // Now walk the nonsystem properties and for each one we find, try to set the
        // value in the new instance

        for(int i = 0; SUCCEEDED( hr ) && i < m_ClassPart.m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
            CPropertyInformation* pInfo =
                pLookup->GetInformation(&m_ClassPart.m_Heap);

            BSTR strName = m_ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                CreateBSTRCopy();
            CSysFreeMe  sfm(strName);

            // Check for allocation failures
            if ( NULL != strName )
            {
                // Get the value and type
                CVar Var;
                if (FAILED(GetProperty(pInfo, &Var)))
                return WBEM_E_OUT_OF_MEMORY;

                CPropertyInformation*   pNewInstInfo = pNewInst->m_ClassPart.FindPropertyInfo(strName);

                // If types don't match or property not found, we'll ignore the property
                if ( NULL != pNewInstInfo && pInfo->nType == pNewInstInfo->nType )
                {
                    hr = pNewInst->m_InstancePart.SetActualValue(pNewInstInfo, &Var);

                    //
                    // reget-it, since it might have been moved by SetActualValue
                    //
                    pNewInstInfo = pNewInst->m_ClassPart.FindPropertyInfo(strName);

                    if ( SUCCEEDED( hr ) && pNewInstInfo)
                    {

                        // DEVNOTE:TODO:PAUL - Comment this out if it's getting in your way
                        // i.e. (not working ).  This is what should copy local property
                        // qualifiers.

                        // Access that property's qualifier set
                        // ====================================
                        CInstancePropertyQualifierSet IPQS;
                        hr = InitializePropQualifierSet(pInfo, IPQS);

                        if ( SUCCEEDED( hr ) )
                        {
                            CInstancePropertyQualifierSet IPQSNew;
                            hr = pNewInst->InitializePropQualifierSet(pNewInstInfo, IPQSNew);

                            if ( SUCCEEDED( hr ) )
                            {
                                hr = IPQSNew.CopyLocalQualifiers( IPQS );
                            }   
                        }   
                    }
                }   
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }   

        // DEVNOTE:TODO:PAUL - Comment this out if it's getting in your way
        // i.e. (not working ).  This is what should copy local instance
        // qualifiers.

        // Now do the instance qualifiers
        if ( SUCCEEDED( hr ) )
        {
            hr = pNewInst->m_InstancePart.m_Qualifiers.CopyLocalQualifiers( m_InstancePart.m_Qualifiers );
        }

    }   // IF Spawn Instance

    // Only save new instance if we succeeded
    if ( SUCCEEDED( hr ) )
    {
        *ppInst = pNewInst;
    }
    else
    {
        pNewInst->Release();
    }

    return hr;
}

// Functions to handle parts
STDMETHODIMP CWbemInstance::SetObjectParts( LPVOID pMem, DWORD dwMemSize, DWORD dwParts )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwRequiredLength = 0;

    // Copying the BLOB, so make sure nobody tears it out from underneath us
    CLock lock(this);

    if ( NULL != pMem )
    {
        // At least the decoration part must be specified
        if ( dwParts & WBEM_OBJ_DECORATION_PART )
        {
            m_pBlobControl->Delete(GetStart());

            // Use a new COM Blob control, as the supplied memory must
            // be CoTaskMemAlloced/Freed.
            m_pBlobControl = &g_CCOMBlobControl;

            SetData( (LPBYTE) pMem, dwMemSize, dwParts );

            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_INVALID_OPERATION;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

// Copies specified parts into a user provided buffer
STDMETHODIMP CWbemInstance::GetObjectParts( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed )
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        DWORD   dwRequiredLength = 0;

        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        // How big is the decoration part
        if ( dwParts & WBEM_OBJ_DECORATION_PART )
        {
            if ( IsDecorationPartAvailable() )
            {
                dwRequiredLength += m_DecorationPart.GetLength();
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }

        // How big is the class part
        if (    SUCCEEDED( hr )
            &&  dwParts & WBEM_OBJ_CLASS_PART )
        {
            if ( IsClassPartAvailable() )
            {
                dwRequiredLength += m_ClassPart.GetLength();
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }

        }

        // How big is the instance part
        if (    SUCCEEDED( hr )
            &&  dwParts & WBEM_OBJ_INSTANCE_PART )
        {
            if ( IsInstancePartAvailable() )
            {
                dwRequiredLength += m_InstancePart.GetLength();
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }

        // At this point, we at least know we requested valid data.
        if ( SUCCEEDED( hr ) )
        {
            *pdwUsed = dwRequiredLength;

            // Make sure the supplied buffer is big enough
            if ( dwDestBufSize >= dwRequiredLength )
            {
                // Now validate the buffer pointer
                if ( NULL != pDestination )
                {
                    LPBYTE  pbData = (LPBYTE) pDestination;

                    // Now copy the requested parts

                    // Decoration
                    if ( dwParts & WBEM_OBJ_DECORATION_PART )
                    {
                        CopyMemory( pbData, m_DecorationPart.GetStart(), m_DecorationPart.GetLength() );
                        pbData += m_DecorationPart.GetLength();
                    }

                    // Class
                    if ( dwParts & WBEM_OBJ_CLASS_PART )
                    {
                        CopyMemory( pbData, m_ClassPart.GetStart(), m_ClassPart.GetLength() );
                        pbData += m_ClassPart.GetLength();
                    }

                    // Instance (and we're done)
                    if ( dwParts & WBEM_OBJ_INSTANCE_PART )
                    {
                        CopyMemory( pbData, m_InstancePart.GetStart(), m_InstancePart.GetLength() );
                    }

                }
                else
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = WBEM_E_BUFFER_TOO_SMALL;
            }
        }   
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Copies class part into a user provided buffer
STDMETHODIMP CWbemInstance::GetClassPart( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
    // This function doesn't cause any allocations so no need to perform out of memory
    // exception handling.
    try
    {
        HRESULT hr = WBEM_E_INVALID_OPERATION;

        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        if ( IsClassPartAvailable() )
        {
            // How big does the buffer need to be
            *pdwUsed = m_ClassPart.GetLength();

            if ( dwDestBufSize >= m_ClassPart.GetLength() )
            {
                // Check the buffer now, before copying memory
                if ( NULL != pDestination )
                {
                    CopyMemory( pDestination, m_ClassPart.GetStart(), m_ClassPart.GetLength() );
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = WBEM_E_BUFFER_TOO_SMALL;
            }
        } 

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Resets the BLOB with a supplied class part
STDMETHODIMP CWbemInstance::SetClassPart( LPVOID pClassPart, DWORD dwSize )
{

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        if ( NULL != pClassPart )
        {
            // Resetting our BLOB
            CLock lock(this);

            int nInstPartLength = 0L;

            if ( IsClassPartAvailable() )
            {
                nInstPartLength = m_InstancePart.GetLength();
            }
            else
            {
                nInstPartLength = GetBlockLength() - m_DecorationPart.GetLength();
            }

            int nNewLength = m_DecorationPart.GetLength() + nInstPartLength + dwSize;
            LPMEMORY    pCurrentData, pNewData, pOldData;

            // This is the only point at which we should see an OOM exception, so don't worry
            // about freeing it.

            pNewData = m_pBlobControl->Allocate( ALIGN_FASTOBJ_BLOB(nNewLength) );

            if ( NULL != pNewData )
            {
                pCurrentData = pNewData;

                // Copy the old decoration data

                CopyMemory( pCurrentData, m_DecorationPart.GetStart(), m_DecorationPart.GetLength() );
                pCurrentData += m_DecorationPart.GetLength();

                // Copy in the new class part
                CopyMemory( pCurrentData, pClassPart, dwSize );
                pCurrentData += dwSize;

                // Finish with the Instance Part
                if ( IsClassPartAvailable() )
                {
                    CopyMemory( pCurrentData, m_InstancePart.GetStart(), m_InstancePart.GetLength() );
                }
                else
                {
                    CopyMemory( pCurrentData, EndOf( m_DecorationPart ), nInstPartLength );
                }
                
                // Save the old data pointer
                pOldData = GetStart();

                // Reset the values.
                SetData( pNewData, nNewLength );

                // Finally dump the old data.
                m_pBlobControl->Delete( pOldData );

                m_nTotalLength = nNewLength;

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF NULL != pClassPart

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Removes the class part from our BLOB, shrinking it
STDMETHODIMP CWbemInstance::StripClassPart( void )
{
    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_OPERATION;

        if ( IsClassPartInternal() )
        {
            // Resetting our BLOB
            CLock lock(this);

            int nNewLength = m_DecorationPart.GetLength() + m_InstancePart.GetLength();
            LPMEMORY    pNewData, pOldData;

            // No need to clean this up if an exception is thrown
            pNewData = m_pBlobControl->Allocate( ALIGN_FASTOBJ_BLOB(nNewLength) );

            if ( NULL != pNewData )
            {
                pOldData = GetStart();

                // Copy the old decoration data.  This will rebase the pointers
                CopyBlock( m_DecorationPart, pNewData, nNewLength );
                
                // Now copy the InstancePart
                CopyBlock( m_InstancePart, EndOf(m_DecorationPart), nNewLength - m_DecorationPart.GetLength());

                // Reset our internal status
                m_dwInternalStatus &= ~( WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL );
                
                // Finally dump the old data.
                m_pBlobControl->Delete( pOldData );

                m_nTotalLength = nNewLength;

                hr = WBEM_S_NO_ERROR;

            }   // IF NULL != pNewData
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // Class Part must be internal

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Merges us with the class part in another IWbemClassObject
STDMETHODIMP CWbemInstance::MergeClassPart( IWbemClassObject *pClassPart )
{
    // This function calls StripClassPart() which CAN cause an OOM exception, but that
    // function performs appropriate handling underneath the layers.

    HRESULT                 hr = WBEM_E_INVALID_PARAMETER;
    _IWmiObject*            pClsInternals;

    if ( NULL != pClassPart )
    {
        // Get an object internals interface.  If we can, this is a good
        // indication that the object that was passed to us is one of our
        // own, and we can do some sleazy casting.

        hr = pClassPart->QueryInterface( IID__IWmiObject, (void**) &pClsInternals );

        if ( SUCCEEDED(hr) )
        {
            // This should work.
            CWbemObject*    pWbemObject = NULL;
            
            // Gets the actual underlying WBEMObject
            hr = pClsInternals->_GetCoreInfo( 0L, (void**) &pWbemObject );
            CReleaseMe    rm( (IWbemClassObject*) pWbemObject );

            if ( SUCCEEDED( hr ) )
            {
                // If the object is an Instance, it's probably a CWbemInstance
                if ( pWbemObject->IsObjectInstance() == WBEM_S_NO_ERROR )
                {
                    CWbemInstance*  pWbemInstance = (CWbemInstance*) pWbemObject;

                    CLock   lock(this);

                    // This only makes sense if the class part is internal to the supplied object.
                    // We do need to strip our class part from our BLOB, however.
                    if ( pWbemInstance->IsClassPartInternal() )
                    {
                        if ( IsClassPartInternal() )
                        {
                            hr = StripClassPart();
                        }
                        else
                        {
                            hr = WBEM_S_NO_ERROR;
                        }

                        if (SUCCEEDED(hr))
                        {
                            // Now reset our class part to point to the data in the other class part
                            m_ClassPart.SetData( pWbemInstance->m_ClassPart.GetStart(), pWbemInstance );

                            // Instance Part should be reset here if we have one, in case it wasn't properly
                            // initialized before.  This could happen, for example, if the object data BLOB
                            // was preset without class information in it.

                            if ( m_dwInternalStatus & WBEM_OBJ_INSTANCE_PART )
                            {
/*                            	size_t dataLength = m_nTotalLength - m_DecorationPart.GetLength();

								CInstancePart::ValidateBuffer(
									EndOf( m_DecorationPart ), 
									dataLength, 
									m_ClassPart.m_Properties.GetNumProperties(),
									m_ClassPart.m_pHeader->nDataLength); */

                                CInstancePart::CInstancePartHeader UNALIGNED * pHdr = (CInstancePart::CInstancePartHeader UNALIGNED *)EndOf(m_DecorationPart);
                                int SavedInstPartLen = pHdr->nLength;                                
                                m_InstancePart.SetData( EndOf( m_DecorationPart ), this, m_ClassPart,SavedInstPartLen);
                            }

                            // Clean up a preexisting object we may have merged with
                            if ( NULL != m_pMergedClassObject )
                            {
                                m_pMergedClassObject->Release();
                            }

                            // maintain a pointer to the object whose memory we are referencing
                            m_pMergedClassObject = pClassPart;
                            m_pMergedClassObject->AddRef();

                            // set our internal state data.
                            m_dwInternalStatus |= WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_SHARED;
                        }

                    }   // IF other class part is internal
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    }
                }   // IF IsInstance
            }    
            pClsInternals->Release();
        }   
    }   

    return hr;
}

// CWbemObject override.  Handles case where our class part is shared.
HRESULT CWbemInstance::WriteToStream( IStream* pStrm )
{
    // Protect the BLOB during this operation
    CLock   lock( this, WBEM_FLAG_ALLOW_READ );

    // If our class part that is shared, we need to fake a contiguous
    // block of memory for the Unmarshaler.

    if ( IsClassPartShared() )
    {
        DWORD dwSignature = FAST_WBEM_OBJECT_SIGNATURE;

        // Write the signature
        // ===================

        HRESULT hres = pStrm->Write((void*)&dwSignature, sizeof(DWORD), NULL);
        if(FAILED(hres)) return hres;

        DWORD   dwLength = 0;

        // This will get us the full lengths of these parts
        GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwLength );

        hres = pStrm->Write((void*)&dwLength, sizeof(DWORD), NULL);
        if(FAILED(hres)) return hres;

        // Write each part individually
        // ============================

        // Decoration
        hres = pStrm->Write((void*)m_DecorationPart.GetStart(),
                              m_DecorationPart.GetLength(), NULL);
        if(FAILED(hres)) return hres;

        // Class
        hres = pStrm->Write((void*)m_ClassPart.GetStart(),
                              m_ClassPart.GetLength(), NULL);
        if(FAILED(hres)) return hres;

        // Instance
        hres = pStrm->Write((void*)m_InstancePart.GetStart(),
                              m_InstancePart.GetLength(), NULL);
        if(FAILED(hres)) return hres;
    }
    else
    {
        // Otherwise, call default implementation
        return CWbemObject::WriteToStream( pStrm );
    }
    return S_OK;
}

// CWbemObject override.  Handles case where our class part is shared.
HRESULT CWbemInstance::GetMaxMarshalStreamSize( ULONG* pulSize )
{
    // If our class part that is shared, we need to fake a contiguous
    // block of memory for the Unmarshaler.

    if ( IsClassPartShared() )
    {
        DWORD   dwLength = 0;

        // This will get us the full lengths of these parts
        HRESULT hr = GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwLength );

        // an expected error
        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            hr = S_OK;
            // Account for the additional DWORDs
            *pulSize = dwLength + sizeof(DWORD) * 2;
        }

        return hr;
    }
    else
    {
        // Otherwise, call default implementation
        return CWbemObject::GetMaxMarshalStreamSize( pulSize );
    }
    return S_OK;
}

HRESULT CWbemInstance::GetDynasty( CVar* pVar )
{
    // We don't do this for Limited Representations
    if ( m_DecorationPart.IsLimited() )
    {
        pVar->SetAsNull();
        return WBEM_NO_ERROR;
    }

    return m_ClassPart.GetDynasty(pVar);
}

HRESULT CWbemInstance::ConvertToMergedInstance( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check that the class part is not already shared (in which case
    // we're done).

    if ( IsClassPartInternal() )
    {
        // Now, we need to actually separate out the class part from the
        // instance and place it in its own object so the outside world
        // cannot touch the object.

        DWORD   dwClassObjectLength = 0;

        // Get length should fail with a buffer too small error
        hr = GetObjectParts( NULL, 0,
                WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwClassObjectLength );

        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            DWORD   dwTempLength;
            LPBYTE  pbData = CBasicBlobControl::sAllocate(dwClassObjectLength);

            if ( NULL != pbData )
            {

                hr = GetObjectParts( pbData, dwClassObjectLength,
                        WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwTempLength );

                if ( SUCCEEDED( hr ) )
                {
                    // Allocate an object to hold the class data and then
                    // stuff in the binary data.
                    CWbemInstance*  pClassData = new CWbemInstance;

                    if ( NULL != pClassData )
                    {
                        pClassData->SetData( pbData, dwClassObjectLength,
                            WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART |
                            WBEM_OBJ_CLASS_PART_INTERNAL );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Merge the full instance with this object
                            // and we're done

                            hr = MergeClassPart( pClassData );

                        }

                        // There will be one additional addref on the class data,
                        // object, so release it here.  If the object wasn't
                        // successfuly merged, this will free it.
                        pClassData->Release();

                    }   // IF pClassData
                    else
                    {
                        // Cleanup underlying memory
                        CBasicBlobControl::sDelete(pbData);
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }


                }   // IF GetObjectParts
                else
                {
                    // Cleanup underlying memory
                    CBasicBlobControl::sDelete(pbData);
                }

            }   // IF pbData
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF GetObjectParts

    }   // IF IsClassPartInternal

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
BOOL CWbemInstance::IsLocalized( void )
{
    return ( m_ClassPart.IsLocalized() ||
            m_InstancePart.IsLocalized() );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
void CWbemInstance::SetLocalized( BOOL fLocalized )
{    
    m_InstancePart.SetLocalized( fLocalized );
}

// Merges us with the class part in another IWbemClassObject
STDMETHODIMP CWbemInstance::ClearWriteOnlyProperties( void )
{
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::FastClone( CWbemInstance* pInstDest )
{
    // Protect the BLOB during this operation
    CLock   lock( this, WBEM_FLAG_ALLOW_READ );

    LPMEMORY pNewData = NULL;

    BYTE* pMem = NULL;
    CompactAll();

    if ( NULL != pInstDest->GetStart() )
    {
        if(pInstDest->GetLength() < GetLength())
        {
            pMem = pInstDest->Reallocate( GetLength() );
        }
        else
        {
            pMem = pInstDest->GetStart();
        }

    }
    else
    {
        pMem = CBasicBlobControl::sAllocate(GetLength());
    }

    if(pMem == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memcpy(pMem, GetStart(), GetLength());

    if ( !IsClassPartShared() )
    {
        pInstDest->SetData(pMem, GetLength());
    }
    else
    {
        // Setup the New Instance.  Decoration and Instance both come from the
        // data block.  We can just merge the new Instance's class part with the
        // same `object we are merged with.

        pInstDest->m_DecorationPart.SetData( pMem );

        // Because pNewInstance will merge with the same class part as us, pass
        // our class part member as the class part for parameter for SetData (it
        // just uses it for informational purposes ).

        // The m_InstancePart.m_Qualifier.m_pSecondarySet pointer will be incorrect after
        // this call ( it will point to the cloning source's secondary set ).  By setting
        // the internal status properly, in the next line, MergeClassPart() will fix
        // everything up properly.

        CInstancePart::CInstancePartHeader UNALIGNED * pHdr = (CInstancePart::CInstancePartHeader UNALIGNED *)EndOf(pInstDest->m_DecorationPart);
        int SavedInstPartLen = pHdr->nLength;
        pInstDest->m_InstancePart.SetData( EndOf( pInstDest->m_DecorationPart ), pInstDest, m_ClassPart,SavedInstPartLen);

        // This will "fake out" the status so it fixes up the class part correctly
        pInstDest->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART;

        HRESULT hr = pInstDest->MergeClassPart( m_pMergedClassObject );
        if (FAILED(hr))
        {
            return hr;
        }

        // Copy the status and length variables.
        pInstDest->m_dwInternalStatus = m_dwInternalStatus;
        pInstDest->m_nTotalLength = m_nTotalLength;
    }

    pInstDest->CompactAll();

    return WBEM_S_NO_ERROR; 

}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::CloneEx( long lFlags, _IWmiObject* pDestObject )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        // Verify it's an instance and Thread Safety
        return FastClone( (CWbemInstance*) pDestObject );
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        return CopyBlobOf( (CWbemInstance*) pSourceInstance );
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Checks if the current object is a child of the specified class (i.e. is Instance of,
// or is Child of )
STDMETHODIMP CWbemInstance::IsParentClass( long lFlags, _IWmiObject* pClass )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock(this);

        return ( IsInstanceOf( (CWbemClass*) pClass ) ? WBEM_S_NO_ERROR : WBEM_S_FALSE );
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Compares the derived most class information of two class objects.
STDMETHODIMP CWbemInstance::CompareDerivedMostClass( long lFlags, _IWmiObject* pClass )
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation class for projection queries
STDMETHODIMP CWbemInstance::GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass )
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation instance for projection queries
// "this" _IWmiObject must be a limited class
STDMETHODIMP CWbemInstance::MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance )
{
    return WBEM_E_INVALID_OPERATION;
}

// Merges a blob with the current object memory and creates a new object
STDMETHODIMP CWbemInstance::Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj )
{
    return WBEM_E_INVALID_OPERATION;
}

STDMETHODIMP CWbemInstance::MergeAndDecorate(long lFlags,ULONG uBuffSize,LPVOID pbData,WCHAR * pServer,WCHAR * pNamespace,_IWmiObject** ppNewObj)
{
    return WBEM_E_INVALID_OPERATION;    
}

// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
// is specified this will only perform a test
STDMETHODIMP CWbemInstance::ReconcileWith( long lFlags, _IWmiObject* pNewObj )
{
    return WBEM_E_INVALID_OPERATION;
}

// Upgrades class and instance objects
STDMETHODIMP CWbemInstance::Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        HRESULT    hr = WBEM_S_NO_ERROR;

        // If the new parent class is NULL, then we need to create a new empty class we will
        // upgrade from (basically we will create a new base class to which the values
        // of the current class will be applied

        if ( NULL != pNewParentClass )
        {
            CWbemClass*    pParentClassObj = NULL;

            hr = WbemObjectFromCOMPtr( pNewParentClass, (CWbemObject**) &pParentClassObj );
            CReleaseMe    rm( (_IWmiObject*) pParentClassObj );
            if (SUCCEEDED(hr)) 
            {
                    hr = Reparent( pParentClassObj, (CWbemInstance**) ppNewChild );
            }
        }
        else
        {
            hr = WBEM_E_INVALID_OPERATION;
        }

        return hr;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Updates derived class object using the safe/force mode logic
STDMETHODIMP CWbemInstance::Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass )
{
    return WBEM_E_INVALID_OPERATION;
}

STDMETHODIMP CWbemInstance::SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst )
{
    return WBEM_E_INVALID_OPERATION;
}
CVar * CWbemInstance::CalculateCachedKey()
{
    wmilib::auto_ptr<wchar_t> wszKey(GetKeyStr());
    if(wszKey.get() != NULL)
        m_CachedKey.SetBSTR(wszKey.get());
    else
        return NULL;
    return &m_CachedKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastmeth.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTMETH.H

Abstract:

    This file defines the method class used in WbemObjects.

History:

    12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __WBEM_FASTMETHOD__H_
#define __WBEM_FASTMETHOD__H_

#include <fastqual.h>
#include <fastheap.h>

typedef enum {METHOD_SIGNATURE_IN = 0, METHOD_SIGNATURE_OUT = 1,
                METHOD_NUM_SIGNATURES} METHOD_SIGNATURE_TYPE;

// DEVNOTE:WIN64:SJS - This may be backwards incompatible, so we
// may have to manually unalign method stuff in the BLOB

struct COREPROX_POLARITY CMethodDescription
{
    heapptr_t m_ptrName;
    BYTE m_nFlags;
    classindex_t m_nOrigin;
    heapptr_t m_ptrQualifiers;
    heapptr_t m_aptrSigs[METHOD_NUM_SIGNATURES];

public:
    static BOOL CreateDerivedVersion(
								 UNALIGNED CMethodDescription* pSource,
								 UNALIGNED CMethodDescription* pDest,
                                 CFastHeap* pOldHeap, CFastHeap* pNewHeap);
    static BOOL CreateUnmergedVersion(
								 UNALIGNED CMethodDescription* pSource,
								 UNALIGNED CMethodDescription* pDest,
                                 CFastHeap* pOldHeap, CFastHeap* pNewHeap);
    static BOOL IsTouched( UNALIGNED CMethodDescription* pThis, CFastHeap* pHeap);
    static HRESULT AddText(UNALIGNED CMethodDescription* pThis, WString& wsText, CFastHeap* pHeap, long lFlags);

	// Accessors
	void SetSig( int nIndex, heapptr_t ptr );
	heapptr_t GetSig( int nIndex );
};

typedef UNALIGNED CMethodDescription* PMETHODDESCRIPTION;

class CMethodPart;
class COREPROX_POLARITY CMethodPartContainer
{
public:
    virtual BOOL ExtendMethodPartSpace(CMethodPart* pPart, 
        length_t nNewLength) = 0;
    virtual void ReduceMethodPartSpace(CMethodPart* pPart,
        length_t nDecrement) = 0;
    virtual classindex_t GetCurrentOrigin() = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
};
    
class CWbemObject;
class COREPROX_POLARITY CMethodPart : public CHeapContainer
{

protected:

	// DEVNOTE:WIN64:SJS - This may be backwards incompatible, so we
	// may have to manually unalign method stuff in the BLOB

    struct CHeader
    {
        length_t m_nLength;
        propindex_t m_nNumMethods;

		static LPMEMORY EndOf( UNALIGNED CHeader* pHeader );
    };
	
	typedef UNALIGNED CHeader* PMETHODPARTHDR;

	PMETHODPARTHDR m_pHeader;
    PMETHODDESCRIPTION m_aDescriptions;

    CFastHeap m_Heap;
    CMethodPartContainer* m_pContainer;
    CMethodPart* m_pParent;

protected:
    int FindMethod(LPCWSTR wszName);
    int GetNumMethods() {return m_pHeader->m_nNumMethods;}
    CCompressedString* GetName(int nIndex);
    HRESULT CreateMethod(LPCWSTR wszName, CWbemObject* pInSig,
                    CWbemObject* pOutSig);
    BOOL DoSignaturesMatch(int nIndex, METHOD_SIGNATURE_TYPE nSigType, 
                                    CWbemObject* pSig);

    HRESULT SetSignature(int nIndex, METHOD_SIGNATURE_TYPE nSigType, 
                                    CWbemObject* pSig);
    void GetSignature(int nIndex, int nSigType, CWbemObject** ppObj);
    void DeleteSignature(int nIndex, int nSigType);
    BOOL IsPropagated(int nIndex);
    BOOL DoesSignatureMatchOther(CMethodPart& OtherPart, int nIndex, 
                                        METHOD_SIGNATURE_TYPE nType);
    HRESULT CheckIds(CWbemClass* pInSig, CWbemClass* pOutSig);
	HRESULT	CheckDuplicateParameters( CWbemObject* pObjInParams, CWbemObject* pOutParams );
	HRESULT	ValidateOutParams( CWbemObject* pOutParams );

    friend class CMethodQualifierSetContainer;
    friend class CMethodQualifierSet;
public:
    void SetData(LPMEMORY pStart, CMethodPartContainer* pContainer,
                    CMethodPart* pParent = NULL);
    static size_t ValidateBuffer(LPMEMORY start, size_t cbSize);
    LPMEMORY GetStart() {return LPMEMORY(m_pHeader);}
    length_t GetLength() {return m_pHeader->m_nLength;}
    void Rebase(LPMEMORY pMemory);

    static length_t GetMinLength();
    static LPMEMORY CreateEmpty(LPMEMORY pStart);
    length_t EstimateDerivedPartSpace();
    LPMEMORY CreateDerivedPart(LPMEMORY pStart, length_t nAllocatedLength);
    length_t EstimateUnmergeSpace();
    LPMEMORY Unmerge(LPMEMORY pStart, length_t nAllocatedLength);
    static length_t EstimateMergeSpace(CMethodPart& Parent, CMethodPart& Child);
    static LPMEMORY Merge(CMethodPart& Parent, CMethodPart& Child, 
                            LPMEMORY pDest, length_t nAllocatedLength);

    static HRESULT Update(CMethodPart& Parent, CMethodPart& Child, long lFlags );
    
    void Compact();
    EReconciliation CanBeReconciledWith(CMethodPart& NewPart);
    EReconciliation ReconcileWith(CMethodPart& NewPart);
	EReconciliation CompareExactMatch( CMethodPart& thatPart );

    HRESULT CompareTo(long lFlags, CMethodPart& OtherPart);
    HRESULT SetMethodOrigin(LPCWSTR wszMethodName, long lOriginIndex);

public:
    HRESULT PutMethod(LPCWSTR wszName, long lFlags, CWbemObject* pInSig,
                        CWbemObject* pOutSig);
    HRESULT GetMethod(LPCWSTR wszName, long lFlags, CWbemObject** ppInSig,
                        CWbemObject** ppOutSig);
    HRESULT GetMethodAt(int nIndex, BSTR* pstrName, CWbemObject** ppInSig,
                        CWbemObject** ppOutSig);
    HRESULT DeleteMethod(LPCWSTR wszName);
    HRESULT GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    HRESULT GetMethodOrigin(LPCWSTR wszName, classindex_t* pnIndex);

    HRESULT AddText(WString& wsText, long lFlags);
    HRESULT EnsureQualifier(CWbemObject* pOrig, LPCWSTR wszQual, CWbemObject** pObj);

    BOOL CMethodPart::IsTouched(LPCWSTR wszName, BOOL * pbValid);
    BOOL CMethodPart::IsTouched(int nIndex, BOOL * pbValid);

    
public:
    //CHeapContainer
    BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nExtra);
    void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nDecrement){};
    LPMEMORY  GetMemoryLimit(){ return EndOf(*this); };
    
    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetWbemObjectUnknown();}

	HRESULT IsValidMethodPart( void );
    CFastHeap* GetHeap() {return &m_Heap;}

};

class COREPROX_POLARITY CMethodQualifierSetContainer : public CQualifierSetContainer
{
protected:
    CMethodPart* m_pPart;
    CMethodPart* m_pParent;
    WString m_wsMethodName;
    heapptr_t m_ptrParentSet;

    CBasicQualifierSet m_SecondarySet;
public:
    void SetData(CMethodPart* pPart, CMethodPart* pParent, 
                    LPCWSTR wszMethodName);

    CFastHeap* GetHeap() {return &m_pPart->m_Heap;}
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,length_t nNewlength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet, length_t nReduceBy){}
    IUnknown* GetWbemObjectUnknown() {return m_pPart->GetWbemObjectUnknown();}
    HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainSingleton() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainDynamic() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainAbstract( BOOL fValue ) {return WBEM_E_INVALID_QUALIFIER;}
    BOOL CanHaveCimtype(LPCWSTR) {return FALSE;}
    LPMEMORY GetQualifierSetStart();

    CBasicQualifierSet* GetSecondarySet();
};

class COREPROX_POLARITY CMethodQualifierSet : public CClassQualifierSet
{
protected:
    CMethodQualifierSetContainer m_Container;
public:
    void SetData(CMethodPart* pPart, CMethodPart* pParent, 
                    LPCWSTR wszMethodName);
    // these guys are free-standing, hence they self delete with the Iunknown::Release
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        if( lRef == 0)
        {
            delete this;
        }
        return lRef;
    }
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastmeth.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTMETH.CPP

Abstract:

  This file defines the method class used in WbemObjects.

History:

  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemutil.h>
#include <fastall.h>

#include "fastmeth.h"
#include "olewrap.h"
#include <arrtempl.h>

void CMethodDescription::SetSig( int nIndex, heapptr_t ptr )
{
	PHEAPPTRT	pHeapPtrTemp = (PHEAPPTRT) &m_aptrSigs[nIndex];
    *pHeapPtrTemp = ptr;
}

heapptr_t CMethodDescription::GetSig( int nIndex )
{
	PHEAPPTRT	pHeapPtrTemp = (PHEAPPTRT) &m_aptrSigs[nIndex];
    return *pHeapPtrTemp;
}

BOOL CMethodDescription::CreateDerivedVersion(
                                            UNALIGNED CMethodDescription* pSource,
                                            UNALIGNED CMethodDescription* pDest,
                                            CFastHeap* pOldHeap,
                                            CFastHeap* pNewHeap)
{
    pDest->m_nFlags = WBEM_FLAVOR_ORIGIN_PROPAGATED;
    pDest->m_nOrigin = pSource->m_nOrigin;

    // This function assumes that no reallocations will occur, and that the supplied heap is sufficiently
    // large enough to handle the operation!

    // Check for allocation failure
    if ( !CCompressedString::CopyToNewHeap(pSource->m_ptrName, pOldHeap,
                                      pNewHeap, pDest->m_ptrName) )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !pNewHeap->Allocate(
            CBasicQualifierSet::ComputeNecessarySpaceForPropagation(
                pOldHeap->ResolveHeapPointer(pSource->m_ptrQualifiers),
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS), pDest->m_ptrQualifiers) )
    {
        return FALSE;
    }


    CHeapPtr OldQuals(pOldHeap, pSource->m_ptrQualifiers);
    CHeapPtr NewQuals(pNewHeap, pDest->m_ptrQualifiers);

    // Check for allocation failure
    if ( CBasicQualifierSet::WritePropagatedVersion(&OldQuals,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS,
                &NewQuals, pOldHeap, pNewHeap) == NULL )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_IN ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_IN]) )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_OUT ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_OUT]) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CMethodDescription::CreateUnmergedVersion(
                                            UNALIGNED CMethodDescription* pSource,
                                            UNALIGNED CMethodDescription* pDest,
                                            CFastHeap* pOldHeap,
                                            CFastHeap* pNewHeap)
{
    pDest->m_nFlags = pSource->m_nFlags;
    pDest->m_nOrigin = pSource->m_nOrigin;

    // This function assumes that no reallocations will occur, and that the supplied heap is sufficiently
    // large enough to handle the operation!

    // Check for allocation failures
    if ( !CCompressedString::CopyToNewHeap(pSource->m_ptrName, pOldHeap,
                                       pNewHeap, pDest->m_ptrName) )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( !pNewHeap->Allocate(
            CBasicQualifierSet::ComputeUnmergedSpace(
            pOldHeap->ResolveHeapPointer(pSource->m_ptrQualifiers)), pDest->m_ptrQualifiers) )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( CBasicQualifierSet::Unmerge(
                pOldHeap->ResolveHeapPointer(pSource->m_ptrQualifiers), pOldHeap,
                pNewHeap->ResolveHeapPointer(pDest->m_ptrQualifiers), pNewHeap) == NULL )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_IN ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_IN] ) )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_OUT ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_OUT]) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CMethodDescription::IsTouched(
                                   UNALIGNED CMethodDescription* pThis,
								   CFastHeap* pHeap)
{
    if((pThis->m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED) == 0)
        return TRUE; // local

    return CBasicQualifierSet::HasLocalQualifiers(
        pHeap->ResolveHeapPointer(pThis->m_ptrQualifiers));
}

HRESULT CMethodDescription::AddText(
								 UNALIGNED CMethodDescription* pThis,
								 WString& wsText, CFastHeap* pHeap, long lFlags)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

	try
	{
		HRESULT hres = WBEM_S_NO_ERROR;
		wsText += L"\t";

		// Get the qualifiers
		// ==================

		hres = CBasicQualifierSet::GetText(
			pHeap->ResolveHeapPointer(pThis->m_ptrQualifiers),
			pHeap, lFlags, wsText);

		if ( FAILED( hres ) )
		{
			return hres;
		}

		wsText += L" ";

		// Look for the return type
		// ========================

		CEmbeddedObject* pEmbed = (CEmbeddedObject*)pHeap->ResolveHeapPointer(
									pThis->GetSig( METHOD_SIGNATURE_OUT ) );

		// Release going out of scope
		CWbemClass* pOutSig = pEmbed ? (CWbemClass*)pEmbed->GetEmbedded() : 0;
		CReleaseMe  rmOut( (IWbemClassObject*) pOutSig );

		CVar vType;
		if(pOutSig && SUCCEEDED(pOutSig->GetPropQualifier(L"ReturnValue", TYPEQUAL,
							&vType)) && vType.GetType() == VT_BSTR)
		{
			CType::AddPropertyType(wsText, vType.GetLPWSTR());
		}
		else
		{
			wsText += L"void";
		}

		// Write the name
		// ==============

		wsText += " ";
		wsText += pHeap->ResolveString(pThis->m_ptrName)->CreateWStringCopy();
		wsText += "(";

		// Write the params
		// ================

		pEmbed = (CEmbeddedObject*)pHeap->ResolveHeapPointer(
											pThis->GetSig( METHOD_SIGNATURE_IN ) );

		// Release going out of scope
		CWbemClass* pInSig = pEmbed ? (CWbemClass*)pEmbed->GetEmbedded() : 0;
		CReleaseMe  rmIn( (IWbemClassObject*) pInSig );

		int nIndex = 0;
		BOOL bFirst = TRUE;
		BOOL bFound = TRUE;
		while(bFound)
		{
			bFound = FALSE;
			if(pInSig != NULL)
			{
				WString wsParam;

				// We should write out duplicate parameters as in,out this time
				hres = pInSig->WritePropertyAsMethodParam(wsParam, nIndex, lFlags, pOutSig, FALSE);
				if(FAILED(hres))
				{
					if(hres != WBEM_E_NOT_FOUND)
						return hres;
				}
				else
				{
					if(!bFirst)
						wsText += L", ";
					bFirst = FALSE;
					bFound = TRUE;
					wsText += wsParam;
				}
			}
			if(pOutSig != NULL)
			{
				WString wsParam;

				// This time, we want to ignore duplicate parameters
				hres = pOutSig->WritePropertyAsMethodParam(wsParam, nIndex, lFlags, pInSig, TRUE);
				if(FAILED(hres))
				{
					if(hres != WBEM_E_NOT_FOUND)
						return hres;
				}
				else
				{
					if(!bFirst)
						wsText += L", ";
					bFirst = FALSE;
					bFound = TRUE;
					wsText += wsParam;
				}
			}
			nIndex++;
		}

		wsText += ");\n";

		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

LPMEMORY CMethodPart::CHeader::EndOf( UNALIGNED CHeader* pHeader )
{
	return ( (LPMEMORY) pHeader) + sizeof(CHeader);
}

void CMethodPart::SetData(LPMEMORY pStart, CMethodPartContainer* pContainer,
                    CMethodPart* pParent)
{
    m_pContainer = pContainer;
    m_pParent = pParent;
    m_pHeader = (PMETHODPARTHDR)pStart;
    m_aDescriptions = (PMETHODDESCRIPTION) CMethodPart::CHeader::EndOf(m_pHeader);
    m_Heap.SetData((LPMEMORY)(m_aDescriptions + GetNumMethods()), this);
}

size_t CMethodPart::ValidateBuffer(LPMEMORY start, size_t cbSize)
{
	size_t step = sizeof(CHeader);
	if (cbSize < step) throw CX_Exception();
	UNALIGNED CHeader * header = (PMETHODPARTHDR)start;

	step+=header->m_nNumMethods*sizeof(CMethodDescription);
	if (step > cbSize) throw CX_Exception();

	step += CFastHeap::ValidateBuffer(start+step, cbSize-step);
	if (step>header->m_nLength) throw CX_Exception();
	return header->m_nLength;	
};

void CMethodPart::Rebase(LPMEMORY pStart)
{
    m_pHeader = (PMETHODPARTHDR)pStart;
    m_aDescriptions = (PMETHODDESCRIPTION) CMethodPart::CHeader::EndOf(m_pHeader);
    m_Heap.Rebase((LPMEMORY)(m_aDescriptions + GetNumMethods()));
}

BOOL CMethodPart::ExtendHeapSize(LPMEMORY pStart, length_t nOldLength,
                    length_t nExtra)
{
    // Extend our own size by as much
    // ==============================

    BOOL fReturn = m_pContainer->ExtendMethodPartSpace(this, GetLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        m_pHeader->m_nLength += nExtra;
    }

    return fReturn;
}

int CMethodPart::FindMethod(LPCWSTR wszName)
{
    for(int i = 0; i < GetNumMethods(); i++)
    {
        CCompressedString* pcs = m_Heap.ResolveString(m_aDescriptions[i].m_ptrName);
        if(pcs->CompareNoCase(wszName) == 0)
            return i;
    }
    return -1;
}

CCompressedString* CMethodPart::GetName(int nIndex)
{
    return m_Heap.ResolveString(m_aDescriptions[nIndex].m_ptrName);
}

HRESULT CMethodPart::EnsureQualifier(CWbemObject* pOrig, LPCWSTR wszQual, CWbemObject** ppNew )
{
    // If NULL, we're still ok.  The parameter will just be ignored.
    if(pOrig == NULL)
    {
        *ppNew = NULL;
        return WBEM_S_NO_ERROR;
    }

    IWbemClassObject* pNewOle;
    HRESULT hr = pOrig->Clone(&pNewOle);

    if ( SUCCEEDED( hr ) )
    {

        CWbemClass* pNew = (CWbemClass*)pNewOle;

        // Make sure we got the qualifier
        hr = pNew->EnsureQualifier(wszQual);

        if ( SUCCEEDED( hr ) )
        {
            *ppNew = pNew;
        }
        else
        {
            pNew->Release();
        }

    }

    return hr;
}

HRESULT CMethodPart::CheckDuplicateParameters( CWbemObject* pInParams, CWbemObject* pOutParams )
{
    CFixedBSTRArray aExcludeNames;

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        // If either one is NULL, we can safely assume no duplicates

        if ( NULL != pInParams && NULL != pOutParams )
        {

            // Allocate an array of qualifier names excluded from qualifier set
            // comparisons.  In this case, we only ignore "in" and "out" qualifiers.

            aExcludeNames.Create( 2 );
            aExcludeNames[0] = COleAuto::_SysAllocString( L"in" );
            aExcludeNames[1] = COleAuto::_SysAllocString( L"out" );

            DWORD   dwNumInParams = pInParams->GetNumProperties(),
                    dwNumOutParams = pOutParams->GetNumProperties();

            CVar    vPropName,
                    vTemp;

            // We should do this for the least number of parameters possible
            CWbemObject*    pLeastPropsObject = ( dwNumInParams <= dwNumOutParams ?
                                                    pInParams : pOutParams );
            CWbemObject*    pMostPropsObject = ( dwNumInParams <= dwNumOutParams ?
                                                    pOutParams : pInParams );
            DWORD           dwLeastNumParams =  min( dwNumInParams, dwNumOutParams );

            // Enum the properties, and for each one that is in both the in and
            // out lists, we MUST have exact matches for the qualifier sets, in and
            // out qualifiers notwithstanding

            for ( int i = 0; SUCCEEDED(hr) && i < dwLeastNumParams; i++ )
            {
                // Pull out the property name (use the least number of params object)
                hr = pLeastPropsObject->GetPropName( i, &vPropName );

                if ( SUCCEEDED( hr ) )
                {
                    // Try to get the property from the other list (i.e. object with most params)
					// We ignore system properties - those with "_" parameters
                    if ( SUCCEEDED( pMostPropsObject->GetProperty( (LPCWSTR) vPropName, &vTemp ) ) &&
						!CSystemProperties::IsPossibleSystemPropertyName( (LPCWSTR) vPropName ) )
                    {
                        // Get the qualifier sets from each property
                        // Note that since we know the property is in each
                        // object we no longer need to do the least prop/
                        // most prop dance
                        
                        IWbemQualifierSet*  pInQS   =   NULL;
                        IWbemQualifierSet*  pOutQS  =   NULL;

                        if (    SUCCEEDED( pInParams->GetPropertyQualifierSet( (LPCWSTR) vPropName, &pInQS ) )
                            &&  SUCCEEDED( pOutParams->GetPropertyQualifierSet( (LPCWSTR) vPropName, &pOutQS ) ) )
                        {

                            // Cast to qualifier sets and do a direct comparison
                            CQualifierSet*  pInQualSet = (CQualifierSet*) pInQS;
                            CQualifierSet*  pOutQualSet = (CQualifierSet*) pOutQS;

                            // Test equality.  We don't care in this case, that the
                            // order of the qualifiers is exactly the same.  Just that
                            // the qualifier sets (aside from in,out) contain the
                            // same values (so they should at least contain the same
                            // number of qualifiers).
                            if ( !pInQualSet->Compare(*pOutQualSet, &aExcludeNames, FALSE ) )
                            {
                                hr = WBEM_E_INVALID_DUPLICATE_PARAMETER;
                            }

                        }   // IF got qualifiers
                        else
                        {
                            // We failed to get a qualifier set.  Something is badly wrong
                            hr = WBEM_E_INVALID_PARAMETER;
                        }

                        // Clean up the qualifier sets
                        if ( NULL != pInQS )
                        {
                            pInQS->Release();
                        }

                        // Clean up the qualifier sets
                        if ( NULL != pOutQS )
                        {
                            pOutQS->Release();
                        }

                    }   // IF property in both

                    vPropName.Empty();
                    vTemp.Empty();

                }   // IF GetPropName()

            }   // FOR enum properties

            // Clean up the array
            aExcludeNames.Free();

        }   // IF both params non-NULL

        return hr;
    }
    catch (CX_MemoryException)
    {
        aExcludeNames.Free();
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        aExcludeNames.Free();
        return WBEM_E_FAILED;
    }

}

HRESULT CMethodPart::CheckIds(CWbemClass* pInSig, CWbemClass* pOutSig)
{
    HRESULT hres;
    CFlexArray adwIds;

    // Assumption is that CheckDuplicateParameters has been called and
    // validated any and all duplicate parameters.

    // Collect IDs from both signature objects
    // =======================================

    if(pInSig)
    {
        // Add all properties here.  Since this is first, assume we will always add
        // duplicates
        hres = pInSig->GetIds( adwIds, NULL );
        if(FAILED(hres))
            return hres;
    }

    if(pOutSig)
    {
        // Ignore duplicate properties here if pInSig is non-NULL
        hres = pOutSig->GetIds( adwIds, pInSig );
        if(FAILED(hres))
            return hres;
    }

    // Sort them
    // =========

    adwIds.Sort();

    // Verify that they are consecutive and 0-based
    // ============================================

    for(int i = 0; i < adwIds.Size(); i++)
    {
        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value. (this one OK, since the the
        // flex array is being used as a placeholder for 32-bit values
        // here).  Use PtrToUlong() to lose the warning.

        if( PtrToUlong(adwIds[i]) != i )
            return WBEM_E_NONCONSECUTIVE_PARAMETER_IDS;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::ValidateOutParams( CWbemObject* pOutSig )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    if ( NULL != pOutSig )
    {
        // If we get the return value property, make sure it is
        // not an array type.

        CIMTYPE ct;
        hres = pOutSig->GetPropertyType( L"ReturnValue", &ct, NULL );

        // IF the call failed, no return value, hence no error
        if ( SUCCEEDED( hres ) )
        {
            // It cannot be an array
            if ( CType::IsArray( ct ) )
            {
                hres = WBEM_E_INVALID_METHOD;
            }
        }
        else
        {
            hres = WBEM_S_NO_ERROR;
        }
    }

    return hres;
}

HRESULT CMethodPart::PutMethod(LPCWSTR wszName, long lFlags,
                    CWbemObject* pOrigInSig, CWbemObject* pOrigOutSig)
{
    if(pOrigInSig && pOrigInSig->IsInstance())
        return WBEM_E_INVALID_PARAMETER;

    if(pOrigOutSig && pOrigOutSig->IsInstance())
        return WBEM_E_INVALID_PARAMETER;

    CWbemObject* pInSig = NULL;
    CWbemObject* pOutSig = NULL;

    // Make sure we have in and out qualifiers in the right signatures
    HRESULT hres = EnsureQualifier(pOrigInSig, L"in", &pInSig);
    if ( FAILED( hres ) )
    {
        return hres;
    }
    CReleaseMe rmin((IWbemClassObject*)pInSig);


    hres = EnsureQualifier(pOrigOutSig, L"out", &pOutSig);
    if ( FAILED( hres ) )
    {
        return hres;
    }
    CReleaseMe rmout((IWbemClassObject*)pOutSig);

    // Check the out parameters for any anomalies
    hres = ValidateOutParams( pOutSig );
    if ( FAILED( hres ) )
    {
        return hres;
    }

    // Check for duplicate parameters
    hres = CheckDuplicateParameters( pInSig, pOutSig );

    if ( SUCCEEDED( hres ) )
    {

        // Now check that the ids are all consecutive
        hres = CheckIds((CWbemClass*)pOrigInSig, (CWbemClass*)pOrigOutSig);

        if ( SUCCEEDED( hres ) )
        {
            // Find it
            // =======

            int nIndex = FindMethod(wszName);
            if(nIndex < 0)
            {
                return CreateMethod(wszName, pInSig, pOutSig);
            }

            if(IsPropagated(nIndex))
            {
                if(!DoSignaturesMatch(nIndex, METHOD_SIGNATURE_IN, pInSig))
                {
                    return WBEM_E_PROPAGATED_METHOD;
                }

                if(!DoSignaturesMatch(nIndex, METHOD_SIGNATURE_OUT, pOutSig))
                {
                    return WBEM_E_PROPAGATED_METHOD;
                }
            }
            else
            {
                // Ensure signatures match
                // =======================

                SetSignature(nIndex, METHOD_SIGNATURE_IN, pInSig);
                SetSignature(nIndex, METHOD_SIGNATURE_OUT, pOutSig);
            }

        }   // IF CheckIds

    }   // IF CheckDuplicateParameters

    return hres;
}

HRESULT CMethodPart::CreateMethod(LPCWSTR wszName, CWbemObject* pInSig,
                    CWbemObject* pOutSig)
{
    // Validate the name
    // =================

    if(!IsValidElementName(wszName,g_IdentifierLimit))
        return WBEM_E_INVALID_PARAMETER;


    length_t nLength;

    length_t nLengthName;
    length_t nLengthQualSet;
    length_t nLengthInSig;
    length_t nLengthOutSig;


    nLengthName = CCompressedString::ComputeNecessarySpace(wszName);
    nLengthQualSet = CQualifierSet::GetMinLength();
    nLengthInSig = CEmbeddedObject::EstimateNecessarySpace(pInSig);
    nLengthOutSig = CEmbeddedObject::EstimateNecessarySpace(pOutSig);


    nLength = nLengthName + nLengthQualSet + nLengthInSig + nLengthOutSig;
        
    // Grow our length by the size of a method
    // =======================================

    if (!m_pContainer->ExtendMethodPartSpace(this,
                    GetLength() + sizeof(CMethodDescription) + nLength))
    {
        return WBEM_E_OUT_OF_MEMORY;
    };

    m_pHeader->m_nLength += (sizeof(CMethodDescription) + nLength);

    // Move the heap over
    // ==================

    MoveBlock(m_Heap, m_Heap.GetStart() + sizeof(CMethodDescription));

    int nIndex = m_pHeader->m_nNumMethods;
    m_pHeader->m_nNumMethods++;

    m_Heap.SetAllocatedDataLength(m_Heap.GetAllocatedDataLength() + nLength);
    
	// Create all the bits on the heap
    // ===============================
        
    // Check for allocation failure
    heapptr_t ptrName;
    if ( !m_Heap.Allocate(nLengthName, ptrName) )
    {
    	_DBG_ASSERT(0);
    	return WBEM_E_OUT_OF_MEMORY;
    }
    

    CCompressedString* pcs =
        (CCompressedString*)m_Heap.ResolveHeapPointer(ptrName);
    pcs->SetFromUnicode(wszName);
    pcs = NULL;

    // Check for allocation failure
    heapptr_t ptrQuals;
    if ( !m_Heap.Allocate(nLengthQualSet, ptrQuals) )
    {
    	_DBG_ASSERT(0);
    	return WBEM_E_OUT_OF_MEMORY;
    }

    CBasicQualifierSet::CreateEmpty(m_Heap.ResolveHeapPointer(ptrQuals));

    // Check for allocation failure
    heapptr_t ptrInSig;
    if ( !m_Heap.Allocate(nLengthInSig, ptrInSig) )
    {
    	_DBG_ASSERT(0);
        return WBEM_E_OUT_OF_MEMORY;
    }

    CEmbeddedObject* pInSigEmbedding =
        (CEmbeddedObject*)m_Heap.ResolveHeapPointer(ptrInSig);
    pInSigEmbedding->StoreEmbedded(nLengthInSig, pInSig);
    pInSigEmbedding = NULL;

    // Check for allocation failure
    heapptr_t ptrOutSig;
    if ( !m_Heap.Allocate(nLengthOutSig, ptrOutSig) )
    {
    	_DBG_ASSERT(0);
    	return WBEM_E_OUT_OF_MEMORY;
    }

    CEmbeddedObject* pOutSigEmbedding =
        (CEmbeddedObject*)m_Heap.ResolveHeapPointer(ptrOutSig);
    pOutSigEmbedding->StoreEmbedded(nLengthOutSig, pOutSig);
    pOutSigEmbedding = NULL;

    // Create a new method in nIndex
    // =============================

    PMETHODDESCRIPTION pMethod = m_aDescriptions + nIndex;
    pMethod->m_ptrName = ptrName;
    pMethod->m_ptrQualifiers = ptrQuals;

	pMethod->SetSig( METHOD_SIGNATURE_IN, ptrInSig );
	pMethod->SetSig( METHOD_SIGNATURE_OUT, ptrOutSig );

    pMethod->m_nFlags = 0;
    pMethod->m_nOrigin = m_pContainer->GetCurrentOrigin();

    return WBEM_S_NO_ERROR;
}

BOOL CMethodPart::DoSignaturesMatch(int nIndex,
                                    METHOD_SIGNATURE_TYPE nSigType,
                                    CWbemObject* pSig)
{
    // Get the signature as it exists
    // ==============================

    heapptr_t ptrOldSig = m_aDescriptions[nIndex].GetSig( nSigType );
    CEmbeddedObject* pOldSigEmbedding = (CEmbeddedObject*)
        m_Heap.ResolveHeapPointer(ptrOldSig);
    CWbemObject* pOldSig = pOldSigEmbedding->GetEmbedded();

    // Compare
    // =======

    BOOL bRes = CWbemObject::AreEqual(pOldSig, pSig,
                                        WBEM_FLAG_IGNORE_OBJECT_SOURCE);
    if(pOldSig)
        pOldSig->Release();
    return bRes;
}

HRESULT CMethodPart::SetSignature(int nIndex, METHOD_SIGNATURE_TYPE nSigType,
                                    CWbemObject* pSig)
{
    // Get the signature as it exists
    // ==============================

    heapptr_t ptrOldSig = m_aDescriptions[nIndex].GetSig( nSigType );
    CEmbeddedObject* pOldSigEmbedding = (CEmbeddedObject*)
        m_Heap.ResolveHeapPointer(ptrOldSig);
    CWbemObject* pOldSig = pOldSigEmbedding->GetEmbedded();

    // Compare
    // =======

    if(!CWbemObject::AreEqual(pOldSig, pSig, WBEM_FLAG_IGNORE_OBJECT_SOURCE))
    {
        // Change it
        // =========

        int nLength = CEmbeddedObject::EstimateNecessarySpace(pSig);
        int nOldLength = pOldSigEmbedding->GetLength();

        pOldSigEmbedding = NULL; // about to be invalidated

        // Check for an allocation failure
        heapptr_t ptrSig;
        if ( !m_Heap.Reallocate( ptrOldSig, nOldLength, nLength, ptrSig ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CEmbeddedObject* pSigEmbedding = (CEmbeddedObject*)
            m_Heap.ResolveHeapPointer(ptrSig);
        pSigEmbedding->StoreEmbedded(nLength, pSig);

        m_aDescriptions[nIndex].SetSig( nSigType, ptrSig );
    }

    if(pOldSig)
        pOldSig->Release();

    return WBEM_S_NO_ERROR;
}

void CMethodPart::GetSignature(int nIndex, int nSigType, CWbemObject** ppObj)
{
    if(ppObj)
    {
        CEmbeddedObject* pEmbed = (CEmbeddedObject*)m_Heap.ResolveHeapPointer(
                       m_aDescriptions[nIndex].GetSig( nSigType ) );
        *ppObj = pEmbed->GetEmbedded();
    }
}

void CMethodPart::DeleteSignature(int nIndex, int nSigType)
{
    CEmbeddedObject* pEmbed = (CEmbeddedObject*)m_Heap.ResolveHeapPointer(
                   m_aDescriptions[nIndex].GetSig( nSigType ) );
    m_Heap.Free(m_aDescriptions[nIndex].GetSig( nSigType ),
                   pEmbed->GetLength());
}

HRESULT CMethodPart::GetMethod(LPCWSTR wszName, long lFlags,
                                CWbemObject** ppInSig, CWbemObject** ppOutSig)
{
    // Find it
    // =======

    int nIndex = FindMethod(wszName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    // Get the data
    // ============

    GetSignature(nIndex, METHOD_SIGNATURE_IN, ppInSig);
    GetSignature(nIndex, METHOD_SIGNATURE_OUT, ppOutSig);

    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::GetMethodAt(int nIndex, BSTR* pstrName,
                            CWbemObject** ppInSig, CWbemObject** ppOutSig)
{
    if(nIndex >= GetNumMethods())
        return WBEM_S_NO_MORE_DATA;

    // Get the data
    // ============

    if(pstrName)
    {
        CCompressedString* pcs =
            m_Heap.ResolveString(m_aDescriptions[nIndex].m_ptrName);
        *pstrName = pcs->CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == *pstrName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    GetSignature(nIndex, METHOD_SIGNATURE_IN, ppInSig);
    GetSignature(nIndex, METHOD_SIGNATURE_OUT, ppOutSig);

    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::DeleteMethod(LPCWSTR wszName)
{
    // Find it first
    // =============

    int nIndex = FindMethod(wszName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    if(IsPropagated(nIndex))
    {
        // Replace the qualifier set
        // =========================

        heapptr_t ptrQuals = m_aDescriptions[nIndex].m_ptrQualifiers;
        length_t nOldLength = CBasicQualifierSet::GetLengthFromData(
            m_Heap.ResolveHeapPointer(ptrQuals));
        CBasicQualifierSet::Delete(m_Heap.ResolveHeapPointer(ptrQuals),&m_Heap);

        heapptr_t ptrParentQuals =
            m_pParent->m_aDescriptions[nIndex].m_ptrQualifiers;
        length_t nParentLength = CBasicQualifierSet::GetLengthFromData(
            m_pParent->m_Heap.ResolveHeapPointer(ptrParentQuals));

        // Check for allocation error
        if ( !m_Heap.Reallocate(ptrQuals, nOldLength, nParentLength, ptrQuals) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CHeapPtr ParentQuals(&m_pParent->m_Heap, ptrParentQuals);
        CHeapPtr Quals(&m_Heap, ptrQuals);

        // Check for allocation failure
        if ( CBasicQualifierSet::WritePropagatedVersion(&ParentQuals,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &Quals,
                &m_pParent->m_Heap, &m_Heap) == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_RESET_TO_DEFAULT;
    }
    else
    {
        // Remove the data from the heap
        // =============================

        m_Heap.FreeString(m_aDescriptions[nIndex].m_ptrName);
        DeleteSignature(nIndex, METHOD_SIGNATURE_IN);
        DeleteSignature(nIndex, METHOD_SIGNATURE_OUT);
        CBasicQualifierSet::Delete(
            m_Heap.ResolveHeapPointer(m_aDescriptions[nIndex].m_ptrQualifiers),
            &m_Heap);

        // Collapse the table
        // ==================

        memmove((void*)(m_aDescriptions + nIndex),
                (void*)(m_aDescriptions + nIndex + 1),
                sizeof(CMethodDescription) * (GetNumMethods() - nIndex - 1));

        m_pHeader->m_nNumMethods--;

        // Move the heap
        // =============

        MoveBlock(m_Heap,
            (LPMEMORY)(m_aDescriptions + m_pHeader->m_nNumMethods));

        m_pContainer->ReduceMethodPartSpace(this, sizeof(CMethodDescription));
        m_pHeader->m_nLength -= sizeof(CMethodDescription);

        return WBEM_S_NO_ERROR;
    }
}


HRESULT CMethodPart::GetMethodQualifierSet(LPCWSTR wszName,
                            IWbemQualifierSet** ppSet)
{
    CMethodQualifierSet* pSet = NULL;
    // Check for out of memory
    try
    {
        // Find it first
        // =============

        int nIndex = FindMethod(wszName);
        if(nIndex < 0)
            return WBEM_E_NOT_FOUND;

        pSet = new CMethodQualifierSet;

        if ( NULL == pSet )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // This may throw an exception natively, so we need to
        // make sure we clean up the allocated object above
        pSet->SetData(this, m_pParent, wszName);

        return pSet->QueryInterface(IID_IWbemQualifierSet, (void**)ppSet);
    }
    catch (CX_MemoryException)
    {
        // Cleanup the object in the event of OOM
        if ( NULL != pSet )
        {
            delete pSet;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // Cleanup the object in the event of an exception
        if ( NULL != pSet )
        {
            delete pSet;
        }

        return WBEM_E_FAILED;
    }

}


HRESULT CMethodPart::GetMethodOrigin(LPCWSTR wszName, classindex_t* pnIndex)
{
    // Find it first
    // =============

    int nIndex = FindMethod(wszName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    *pnIndex = m_aDescriptions[nIndex].m_nOrigin;
    return WBEM_S_NO_ERROR;
}

BOOL CMethodPart::IsPropagated(int nIndex)
{
    return ((m_aDescriptions[nIndex].m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED)
                != 0);
}

//
//  TRUE if is Local of Locally overridden
//
BOOL CMethodPart::IsTouched(LPCWSTR wszName, BOOL * pbValid)
{
    int nIndex = FindMethod(wszName);
    if (nIndex < 0)
    {
        if (pbValid) { *pbValid = FALSE; };
        return FALSE;
    }

    if (pbValid) { *pbValid = TRUE; };
        
    if((m_aDescriptions[nIndex].m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED) == 0)
        return TRUE; // local

    return CBasicQualifierSet::HasLocalQualifiers(
        m_Heap.ResolveHeapPointer(m_aDescriptions[nIndex].m_ptrQualifiers));
}

//
//  TRUE if is Local of Locally overridden
//
BOOL CMethodPart::IsTouched(int nIndex, BOOL * pbValid)
{
    if ((nIndex < 0) || (nIndex >= GetNumMethods()))
    {
        if (pbValid) { *pbValid = FALSE; };
        return FALSE;
    }

    if (pbValid) { *pbValid = TRUE; };

    if((m_aDescriptions[nIndex].m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED) == 0)
        return TRUE; // local

    return CBasicQualifierSet::HasLocalQualifiers(
        m_Heap.ResolveHeapPointer(m_aDescriptions[nIndex].m_ptrQualifiers));
}


length_t CMethodPart::GetMinLength()
{
    return sizeof(CHeader) + CFastHeap::GetMinLength();
}

LPMEMORY CMethodPart::CreateEmpty(LPMEMORY pStart)
{
    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pStart;
    pHeader->m_nNumMethods = 0;
    pHeader->m_nLength = GetMinLength();

    return CFastHeap::CreateEmpty(CMethodPart::CHeader::EndOf(pHeader));
}

length_t CMethodPart::EstimateDerivedPartSpace()
{
    // Exactly the same
    // ================

    return m_pHeader->m_nLength;
}

LPMEMORY CMethodPart::CreateDerivedPart(LPMEMORY pStart,
                                        length_t nAllocatedLength)
{
    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pStart;
    *pHeader = *m_pHeader;
    PMETHODDESCRIPTION aDescriptions =
			(PMETHODDESCRIPTION)CMethodPart::CHeader::EndOf(pHeader);

    CFastHeap Heap;
    Heap.CreateOutOfLine((LPMEMORY)(aDescriptions + pHeader->m_nNumMethods),
                            m_Heap.GetUsedLength());

    for(int i = 0; i < GetNumMethods(); i++)
    {
        // Check for allocation failure
        if ( !CMethodDescription::CreateDerivedVersion(
													&m_aDescriptions[i],
													aDescriptions + i,
                                                    &m_Heap, &Heap) )
        {
            return NULL;
        }
    }

    Heap.Trim();
    pHeader->m_nLength = EndOf(Heap) - pStart;
    return EndOf(Heap);
}

length_t CMethodPart::EstimateUnmergeSpace()
{
    return GetLength();
}

LPMEMORY CMethodPart::Unmerge(LPMEMORY pStart, length_t nAllocatedLength)
{
    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pStart;
    PMETHODDESCRIPTION aDescriptions =
			(PMETHODDESCRIPTION)CMethodPart::CHeader::EndOf(pHeader);

    CFastHeap Heap;
    Heap.CreateOutOfLine((LPMEMORY)(aDescriptions + GetNumMethods()),
                            m_Heap.GetUsedLength());

    int nNewIndex = 0;
    for(int i = 0; i < GetNumMethods(); i++)
    {
        if(CMethodDescription::IsTouched(&m_aDescriptions[i], &m_Heap))
        {
            // Check for allocation failures
            if ( !CMethodDescription::CreateUnmergedVersion(
                    &m_aDescriptions[i], aDescriptions + nNewIndex++, &m_Heap, &Heap) )
            {
                return NULL;
            }
        }
    }

    Heap.Trim();
    MoveBlock(Heap, (LPMEMORY)(aDescriptions + nNewIndex));

    pHeader->m_nNumMethods = (propindex_t) nNewIndex;
    pHeader->m_nLength = EndOf(Heap) - pStart;
    return EndOf(Heap);
}

length_t CMethodPart::EstimateMergeSpace(CMethodPart& Parent,
                                         CMethodPart& Child)
{
    return Parent.GetLength() + Child.GetLength() - sizeof(CHeader);
}

LPMEMORY CMethodPart::Merge(CMethodPart& Parent, CMethodPart& Child,
                        LPMEMORY pDest, length_t nAllocatedLength)
{

    // This function assumes that no reallocations will occur, and that the supplied heap is sufficiently
    // large enough to handle the operation!

    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pDest;
    PMETHODDESCRIPTION aDescriptions =
			(PMETHODDESCRIPTION)CMethodPart::CHeader::EndOf(pHeader);

    CFastHeap Heap;
    length_t nHeapLength =
        Parent.m_Heap.GetLength() + Child.m_Heap.GetLength();
    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapLength;

    Heap.CreateOutOfLine(pHeapStart, nHeapLength);

    int nChildIndex = 0;
    for(int i = 0; i < Parent.GetNumMethods(); i++)
    {

        // Check for memory allocation failures
        if ( !CCompressedString::CopyToNewHeap(
                Parent.m_aDescriptions[i].m_ptrName, &Parent.m_Heap, &Heap,
                aDescriptions[i].m_ptrName) )
        {
            return NULL;
        }

        aDescriptions[i].m_nFlags = WBEM_FLAVOR_ORIGIN_PROPAGATED;
        aDescriptions[i].m_nOrigin = Parent.m_aDescriptions[i].m_nOrigin;

        // Check for memory allocation failures
         if ( !CEmbeddedObject::CopyToNewHeap(
                        Parent.m_aDescriptions[i].GetSig( METHOD_SIGNATURE_IN ),
                        &Parent.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_IN]) )
         {
            return NULL;
         }

        // Check for memory allocation failures
        if ( !CEmbeddedObject::CopyToNewHeap(
                        Parent.m_aDescriptions[i].GetSig( METHOD_SIGNATURE_OUT ),
                        &Parent.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_OUT]) )
        {
            return NULL;
        }

        LPMEMORY pParentQuals = Parent.m_Heap.ResolveHeapPointer(
            Parent.m_aDescriptions[i].m_ptrQualifiers);

        // Compare names
        // =============

        if(nChildIndex < Child.GetNumMethods() &&
            Parent.GetName(i)->CompareNoCase(*Child.GetName(nChildIndex)) == 0)
        {
            // Same --- merge
            // ==============

            LPMEMORY pChildQuals = Child.m_Heap.ResolveHeapPointer(
                Child.m_aDescriptions[nChildIndex].m_ptrQualifiers);

            length_t nSize = CBasicQualifierSet::ComputeMergeSpace(
                pParentQuals, &Parent.m_Heap, pChildQuals, &Child.m_Heap, TRUE);

		if (nSize == -1) return NULL;
            // Check for memory allocation failures
            if ( !Heap.Allocate(nSize, aDescriptions[i].m_ptrQualifiers) )
            {
                return NULL;
            }

            LPMEMORY pDestQuals = Heap.ResolveHeapPointer(
                aDescriptions[i].m_ptrQualifiers);

            if ( CBasicQualifierSet::Merge(
                    pParentQuals, &Parent.m_Heap, pChildQuals, &Child.m_Heap,
                    pDestQuals, &Heap, FALSE) == NULL )
            {
                return NULL;
            }

            nChildIndex++;
        }
        else
        {
            // Different
            // =========

            length_t nLength =
                CBasicQualifierSet::ComputeNecessarySpaceForPropagation(
                    pParentQuals, WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

            // Check for memory allocation failures
            if ( !Heap.Allocate(nLength, aDescriptions[i].m_ptrQualifiers) )
            {
                return NULL;
            }

            LPMEMORY pDestQuals = Heap.ResolveHeapPointer(
                aDescriptions[i].m_ptrQualifiers);

            CHeapPtr ParentQuals(&Parent.m_Heap,
                                    Parent.m_aDescriptions[i].m_ptrQualifiers);
            CHeapPtr DestQuals(&Heap, aDescriptions[i].m_ptrQualifiers);

            // Check for memory allocation failures
            if ( !CBasicQualifierSet::WritePropagatedVersion(&ParentQuals,
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &DestQuals,
                        &Parent.m_Heap, &Heap) )
            {
                return NULL;
            }
        }
    }

    // Copy remaining child qualifiers
    // ===============================

    while(nChildIndex < Child.GetNumMethods())
    {
        // Check for memory allocation failures
        if ( !CCompressedString::CopyToNewHeap(
                Child.m_aDescriptions[nChildIndex].m_ptrName, &Child.m_Heap, &Heap,
                aDescriptions[i].m_ptrName) )
        {
            return NULL;
        }

        aDescriptions[i].m_nFlags = 0;
        aDescriptions[i].m_nOrigin = Child.m_aDescriptions[nChildIndex].m_nOrigin;

        // Check for memory allocation failures
        if ( !CEmbeddedObject::CopyToNewHeap(
                        Child.m_aDescriptions[nChildIndex].GetSig( METHOD_SIGNATURE_IN ),
                        &Child.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_IN]) )
        {
            return NULL;
        }

        // Check for memory allocation failures
        if ( !CEmbeddedObject::CopyToNewHeap(
                        Child.m_aDescriptions[nChildIndex].GetSig( METHOD_SIGNATURE_OUT ),
                        &Child.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_OUT]) )
        {
            return NULL;
        }

        LPMEMORY pChildQuals = Child.m_Heap.ResolveHeapPointer(
            Child.m_aDescriptions[nChildIndex].m_ptrQualifiers);

        length_t nLength = CBasicQualifierSet::GetLengthFromData(pChildQuals);

        // Check for memory allocation failures
        if ( !Heap.Allocate(nLength, aDescriptions[i].m_ptrQualifiers) )
        {
            return NULL;
        }

        memcpy(Heap.ResolveHeapPointer(aDescriptions[i].m_ptrQualifiers),
            pChildQuals, nLength);

        CHeapPtr DestQuals(&Heap, aDescriptions[i].m_ptrQualifiers);

        // Check for memory allocation failures
        if ( !CBasicQualifierSet::TranslateToNewHeap(&DestQuals, &Child.m_Heap,
                                                    &Heap) )
        {
            return NULL;
        }

        nChildIndex++;
        i++;
    }

    Heap.Trim();
    MoveBlock(Heap, (LPMEMORY)(aDescriptions + i));

    pHeader->m_nNumMethods = (propindex_t) i;
    pHeader->m_nLength = (EndOf(Heap) - pDest);
    return EndOf(Heap);
}

HRESULT CMethodPart::Update( CMethodPart& Parent, CMethodPart& Child, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Enum methods, adding them as appropriate
    for(int nChildIndex = 0; SUCCEEDED( hr ) && nChildIndex < Child.GetNumMethods();
        nChildIndex++)
    {
        BSTR            bstrName = NULL;
        CWbemObject*    pInSig = NULL;
        CWbemObject*    pOutSig = NULL;

        // Get the method from the child, and add it to the parent.  This will
        // fail if there are any problems/conflicts with the method

        hr = Child.GetMethodAt( nChildIndex, &bstrName, &pInSig, &pOutSig );

        // Scoping cleanup
        CReleaseMe      pigrm( (IUnknown*) (IWbemClassObject*) pInSig );
        CReleaseMe      pogrm( (IUnknown*) (IWbemClassObject*) pOutSig );
        CSysFreeMe      bsfm( bstrName );

        if ( SUCCEEDED( hr ) && NULL != bstrName )
        {
            hr = Parent.PutMethod( bstrName, 0L, pInSig, pOutSig );

            // Now we need to copy across any qualifiers
            if ( SUCCEEDED( hr ) )
            {
                CMethodQualifierSet qsUpdateMeth;
                CBasicQualifierSet qsChildMeth;

                // Use a helper function to set this up
                qsUpdateMeth.SetData( &Parent, Parent.m_pParent, bstrName );

                // We can access the child methods qualifier set directly
                qsChildMeth.SetData( Child.m_Heap.ResolveHeapPointer(
                                    Child.m_aDescriptions[nChildIndex].m_ptrQualifiers),
                                    &Child.m_Heap );

                // Update the method's qualifier set
                hr = qsUpdateMeth.Update( qsChildMeth, lFlags );

            }   // IF PutMethod

        }   // IF GetMethodAt
		else if ( SUCCEEDED( hr ) && NULL == bstrName )
		{
			// This means a valid index was unresolvable into a name
			// means we changed while operation was running - this should
			// never happen
			hr = WBEM_E_UNEXPECTED;
		}

    }   // FOR enum methods

    return hr;
}

void CMethodPart::Compact()
{
    m_Heap.Trim();
}

BOOL CMethodPart::DoesSignatureMatchOther(CMethodPart& OtherPart, int nIndex,
                                        METHOD_SIGNATURE_TYPE nType)
{
    CWbemObject* pThis;
    CWbemObject* pOther;

    GetSignature(nIndex, nType, &pThis);
    OtherPart.GetSignature(nIndex, nType, &pOther);
    BOOL bRes = CWbemObject::AreEqual(pThis, pOther,
                                        WBEM_FLAG_IGNORE_OBJECT_SOURCE);
    if(pThis)
        pThis->Release();
    if(pOther)
        pOther->Release();
    return bRes;
}

HRESULT CMethodPart::CompareTo(long lFlags, CMethodPart& OtherPart)
{
    // Check the sizes
    // ===============

    if(GetNumMethods() != OtherPart.GetNumMethods())
        return WBEM_S_FALSE;

    // Compare all methods
    // ===================

    for(int i = 0; i < GetNumMethods(); i++)
    {
        if(GetName(i)->CompareNoCase(*OtherPart.GetName(i)) != 0)
            return WBEM_S_FALSE;

        if(m_aDescriptions[i].m_nFlags != OtherPart.m_aDescriptions[i].m_nFlags)
            return WBEM_S_FALSE;

        if(m_aDescriptions[i].m_nOrigin !=
                                        OtherPart.m_aDescriptions[i].m_nOrigin)
            return WBEM_S_FALSE;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_IN))
            return WBEM_S_FALSE;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_OUT))
            return WBEM_S_FALSE;

    }
    return WBEM_S_NO_ERROR;
}

EReconciliation CMethodPart::CompareExactMatch( CMethodPart& thatPart )
{
    try
    {
        // Check the sizes
        // ===============

        if(GetNumMethods() != thatPart.GetNumMethods())
        {
            return e_DiffNumMethods;
        }

        // Set up the array of filters to use while dealing with qualifiers
        LPCWSTR apFilters[1];
        apFilters[0] = UPDATE_QUALIFIER_CONFLICT;

        // Compare all methods
        // ===================

        for(int i = 0; i < GetNumMethods(); i++)
        {

            // All Values MUST match
            if(GetName(i)->CompareNoCase(*thatPart.GetName(i)) != 0)
                return e_DiffMethodNames;

            if(m_aDescriptions[i].m_nFlags != thatPart.m_aDescriptions[i].m_nFlags)
                return e_DiffMethodFlags;

            if(m_aDescriptions[i].m_nOrigin !=
                                            thatPart.m_aDescriptions[i].m_nOrigin)
                return e_DiffMethodOrigin;

            if(!DoesSignatureMatchOther(thatPart, i, METHOD_SIGNATURE_IN))
                return e_DiffMethodInSignature;

            if(!DoesSignatureMatchOther(thatPart, i, METHOD_SIGNATURE_OUT))
                return e_DiffMethodOutSignature;

            // Check the qualifiers
            CBasicQualifierSet  qsThisMeth,
                                qsThatMeth;

            // We can access the child methods qualifier set directly
            qsThisMeth.SetData( m_Heap.ResolveHeapPointer(
                                m_aDescriptions[i].m_ptrQualifiers),
                                &m_Heap );
            qsThatMeth.SetData( thatPart.m_Heap.ResolveHeapPointer(
                                thatPart.m_aDescriptions[i].m_ptrQualifiers),
                                &thatPart.m_Heap );

            // Apply update conflict filter during comparison
            if ( !qsThisMeth.Compare( qsThatMeth, WBEM_FLAG_LOCAL_ONLY, apFilters, 1 ) )
            {
                return e_DiffMethodQualifier;
            }

        }

        return e_ExactMatch;

    }
    catch( CX_MemoryException )
    {
        return e_OutOfMemory;
    }
    catch(...)
    {
        return e_WbemFailed;
    }
}

EReconciliation CMethodPart::CanBeReconciledWith(CMethodPart& OtherPart)
{
    // Check the sizes
    // ===============

    if(GetNumMethods() != OtherPart.GetNumMethods())
        return e_DiffNumProperties;

    // Compare all methods
    // ===================

    for(int i = 0; i < GetNumMethods(); i++)
    {
        if(GetName(i)->CompareNoCase(*OtherPart.GetName(i)) != 0)
            return e_DiffPropertyName;

        if(m_aDescriptions[i].m_nFlags != OtherPart.m_aDescriptions[i].m_nFlags)
            return e_DiffPropertyType;

        if(m_aDescriptions[i].m_nOrigin !=
                                        OtherPart.m_aDescriptions[i].m_nOrigin)
            return e_DiffPropertyType;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_IN))
            return e_DiffMethodInSignature;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_OUT))
            return e_DiffMethodOutSignature;

        // Make sure that unimportant qualifiers can be reconciled with
        // each other

        CBasicQualifierSet  qsThisMeth,
                            qsThatMeth;

        // We can access the child methods qualifier set directly
        qsThisMeth.SetData( m_Heap.ResolveHeapPointer(
                            m_aDescriptions[i].m_ptrQualifiers),
                            &m_Heap );
        qsThatMeth.SetData( OtherPart.m_Heap.ResolveHeapPointer(
                            OtherPart.m_aDescriptions[i].m_ptrQualifiers),
                            &OtherPart.m_Heap );

        if ( !qsThisMeth.CanBeReconciledWith( qsThatMeth ) )
        {
            return e_DiffMethodQualifier;
        }


    }
    return e_Reconcilable;
}

EReconciliation CMethodPart::ReconcileWith(CMethodPart& NewPart)
{
    EReconciliation eRes = CanBeReconciledWith(NewPart);
    if(eRes != e_Reconcilable)
        return eRes;

    // Extend and copy
    // ===============

    if(NewPart.GetLength() > GetLength())
    {
        if (!m_pContainer->ExtendMethodPartSpace(this, NewPart.GetLength()))
        	return e_OutOfMemory;
    }

    memcpy(GetStart(), NewPart.GetStart(), NewPart.GetLength());

    SetData(GetStart(), m_pContainer, m_pParent);

    return e_Reconcilable; // TBD
}

HRESULT CMethodPart::SetMethodOrigin(LPCWSTR wszMethodName, long lOriginIndex)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    // Find it first
    // =============

    int nIndex = FindMethod(wszMethodName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    m_aDescriptions[nIndex].m_nOrigin = lOriginIndex;
    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::AddText(WString& wsText, long lFlags)
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    // Any thrown exceptions should bubble out of here
    for(int i = 0; SUCCEEDED( hr ) && i < GetNumMethods(); i++)
    {
        if(CMethodDescription::IsTouched(&m_aDescriptions[i], &m_Heap))
        {
            hr = CMethodDescription::AddText(&m_aDescriptions[i], wsText, &m_Heap, lFlags);
        }
    }

	return hr;
}

HRESULT CMethodPart::IsValidMethodPart( void )
{
    // Check the sizes
    // ===============

    //  Enumerate the methods, and check that names and ptr data
    //  Are inside the heap
    // ================================================================

    LPMEMORY    pHeapStart = m_Heap.GetHeapData();
    LPMEMORY    pHeapEnd = m_Heap.GetStart() + m_Heap.GetLength();

    // Compare all methods
    // ===================

    for(int i = 0; i < GetNumMethods(); i++)
    {
        LPMEMORY pData = m_Heap.ResolveHeapPointer(m_aDescriptions[i].m_ptrName);

        if ( pData >= pHeapStart && pData < pHeapEnd  )
        {
            pData =  m_Heap.ResolveHeapPointer( m_aDescriptions[i].GetSig( METHOD_SIGNATURE_IN ) );

            if ( NULL == pData || ( pData >= pHeapStart && pData < pHeapEnd  ) )
            {
                // We could validate the signature object as well
                pData =  m_Heap.ResolveHeapPointer( m_aDescriptions[i].GetSig( METHOD_SIGNATURE_OUT ) );

                if ( NULL == pData || ( pData >= pHeapStart && pData < pHeapEnd  ) )
                {
                    // We could validate the signature object as well
                }
                else
                {
                    _ASSERT( 0, __TEXT("Winmgmt: Bad out signature pointer!"));
                    return WBEM_E_FAILED;
                }

            }
            else
            {
                _ASSERT( 0, __TEXT("Winmgmt: Bad in signature pointer!") );
                return WBEM_E_FAILED;
            }

        }
        else
        {
            _ASSERT( 0, __TEXT("Winmgmt: Bad method name pointer!") );
            return WBEM_E_FAILED;
        }

    }
    return WBEM_S_NO_ERROR;
}

void CMethodQualifierSetContainer::SetData(CMethodPart* pPart,
                                CMethodPart* pParent, LPCWSTR wszMethodName)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    m_pPart = pPart;
    m_pParent = pParent;
    m_wsMethodName = wszMethodName;

    int nIndex = pPart->FindMethod(wszMethodName);
    if(pPart->IsPropagated(nIndex))
    {
        m_ptrParentSet = pParent->m_aDescriptions[nIndex].m_ptrQualifiers;
        m_SecondarySet.SetData(pParent->m_Heap.ResolveHeapPointer(
                                                            m_ptrParentSet),
                            &pParent->m_Heap);
    }
    else
    {
        m_ptrParentSet = INVALID_HEAP_ADDRESS;
    }

}

BOOL CMethodQualifierSetContainer::ExtendQualifierSetSpace(
                                CBasicQualifierSet* pSet, length_t nNewLength)
{
    int nIndex = m_pPart->FindMethod(m_wsMethodName);

    // Check for allocation failure
    heapptr_t ptrNew;
    if ( !m_pPart->m_Heap.Reallocate(
            m_pPart->m_aDescriptions[nIndex].m_ptrQualifiers,
            pSet->GetLength(), nNewLength, ptrNew) )
    {
        return FALSE;
    }

    // Move the qualifier set there
    // ============================

    pSet->Rebase(m_pPart->m_Heap.ResolveHeapPointer(ptrNew));

    // Change the lookup
    // =================

    m_pPart->m_aDescriptions[nIndex].m_ptrQualifiers = ptrNew;
    return TRUE;
}

LPMEMORY CMethodQualifierSetContainer::GetQualifierSetStart()
{
    if(m_ptrParentSet != INVALID_HEAP_ADDRESS)
        m_SecondarySet.Rebase(m_pParent->m_Heap.ResolveHeapPointer(
                                                        m_ptrParentSet));

    int nIndex = m_pPart->FindMethod(m_wsMethodName);
    if(nIndex < 0) return NULL;

    return m_pPart->m_Heap.ResolveHeapPointer(
                            m_pPart->m_aDescriptions[nIndex].m_ptrQualifiers);
}

CBasicQualifierSet* CMethodQualifierSetContainer::GetSecondarySet()
{
    if(m_ptrParentSet != INVALID_HEAP_ADDRESS)
        return &m_SecondarySet;
    else
        return NULL;
}

void CMethodQualifierSet::SetData(CMethodPart* pPart, CMethodPart* pParent,
                    LPCWSTR wszMethodName)
{
    m_Container.SetData(pPart, pParent, wszMethodName);
    CQualifierSet::SetData(m_Container.GetQualifierSetStart(), &m_Container,
            m_Container.GetSecondarySet());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastinst.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTINST.H

Abstract:

  This file defines the classes related to instance representation
  in WbemObjects

  Classes defined: 
      CInstancePart           Instance data.
      CInstancePartContainer  Anything that contains CInstancePart
      CWbemInstance            Complete instance definition.

History:

  3/10/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_WBEM_INSTANCE__H_
#define __FAST_WBEM_INSTANCE__H_

#include "fastcls.h"

//#pragma pack(push, 1)

// This is the unicode character used to join compound keys.
// This is a non-used unicode character and so is safe.  It is 
// reserved for just this task.
#define WINMGMT_COMPOUND_KEY_JOINER 0xFFFF

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancePartContainer
//
//  See CInstancePart definition first.
//
//  This class defines the functionality required by CInstancePart of any object
//  whose memory block contains that of the CInstancePart.
//
//*****************************************************************************
//
//  ExtendInstancePartSpace
//
//  Called by CInstancePart when it needs more memory for its memory block. The
//  container may have to relocate the entire memory block to get more memory. 
//  In this case, it will have to notify CInstancePart of its new location using
//  Rebase.
//
//  Parameters:
//
//      CInstancePart* pInstancePart      The instance part making the request
//      length_t nNewLength               The required length
//
//*****************************************************************************
//
//  ReduceInstancePartSpace
//
//  Called by CInstancePart wen it wants to return some memory to the container.
//  The container may NOT relocate the insatnce part's memory block in response
//  to this call.
//
//  Parameters:
//
//      CInstancePart* pInstancePart      The instance part making the request
//      length_t nDecrement               The amount of space to return
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Must return the pointer to the IUnknown of the containing CWbemObject
//  This is used by qualifier sets to ensure that the main object lasts at
//  least as long as they do.
//  
//  Returns:
//
//      IUnknown*:   the pointer to the controlling IUnknown
//
//*****************************************************************************
class CInstancePart;
class COREPROX_POLARITY CInstancePartContainer
{
public:
    virtual BOOL ExtendInstancePartSpace(CInstancePart* pPart, 
        length_t nNewLength) = 0;
    virtual void ReduceInstancePartSpace(CInstancePart* pPart,
        length_t nDecrement) = 0;
    virtual IUnknown* GetInstanceObjectUnknown() = 0;
    virtual void ClearCachedKeyValue() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancePart
//
//  This class represents the data of an instance. While all the information
//  is there, this class cannot function alone without its class definition.
//
//  The memory block of the instance part has the following structure
//
//      Header:
//          length_t nLength        The length of the entire structure
//          BYTE fFlags             Reserved
//          heapptr_t ptrClassName  Heap pointer to the class name (on the 
//                                  heap of the instance part (below))
//      Data table (see CDataTable in fastprop.h) with property values
//      Instance qualifier set (see CQualifierSet in fastqual.h)
//      Instance property qualifier set (see CQualifierSetList in fastqual.h)
//      Heap for variable-length data (see CFastHeap in fastheap.h)
//
//*****************************************************************************
//
//  SetData
//
//  Initializer.
//
//  Parameters:
//
//      LPMEMORY pStart                     The memory block
//      CInstancePartContainer* pContainer  The container (CWbemInstance itself)
//      CClassPart& ClassPart               Out class definition.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY:   the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t:   the length of the memory block.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs this object that its memory block has moved.
//
//  Parameters:
//
//      LPMEMORY pMemory        The new location of the memory block
//
//*****************************************************************************
//
//  GetActualValue
//
//  Retrieves the value of a property based on its information structure (see
//  fastprop.h).
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  Property information structure
//      OUT  CVar* pVar                 Destination for the value. Must not
//                                      already contain a value.
//
//*****************************************************************************
//
//  SetActualValue
//
//  Sets the actual value of a property based on its information structure (see
//  fastprop.h). The value must match the property type --- no coersion is 
//  attempted.
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  Property information structure
//      IN   CVar* pVar                 the value to set
//
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_TYPE_MISMATCH     Type mismatch.   
//
//*****************************************************************************
//
//  GetObjectQualifier
//
//  Retrieves an instance qualifier by its name.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve
//      OUT CVar* pVar          Destination for the value. Must not already 
//                              contain a value.
//      OUT long* plFlavor      Destinatino for the flavor. May be NULL if not
//                              required.
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_NOT_FOUND         No such qualifier
//
//*****************************************************************************
//
//  SetInstanceQualifier
//
//  Sets the value of an instance qualifier.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to set
//      IN CVar* pVar           The value for the qualifier.
//      IN long lFlavor         The flavor for the qualifier.
//
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//      
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a class or instance qualifier by its name.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve
//      OUT CVar* pVar          Destination for the value. Must not already 
//                              contain a value.
//      OUT long* plFlavor      Destinatino for the flavor. May be NULL if not
//                              required.
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_NOT_FOUND         No such qualifier
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of this instance part on a given block of 
//  memory as described in EstimateLimitedRepresentationLength in fastobj.h.
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap The mapping of the limitation to produce.
//                                  Obtained from CWbemClass::MapLimitation.
//      IN nAllocatedSize           The size of the memory block allocated for
//                                  the operation --- pDest.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************
//
//  static GetDataTableData
//
//  Returns the pointer to the instance data table based on the instance part
//  starting pointer. This can be used in table scans
//
//  Parameters:
//
//      LPMEMORY pStart     Where the instance part memory block starts.
//
//  Returns:
//
//      LPMEMORY:   where the data table starts
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the amount of space required for an empty instance of a given 
//  class (i.e. with all default values and no additional qualifiers).
//
//  Parameters:
//
//      CClassPart* pClassDef       The class definition (see fastcls.h)
//
//  Returns:
//
//      length_t:    exact amount of space required for the instance part.
//
//*****************************************************************************
//
//  Create
//
//  Creates an empty instance part for a given class on a given memory block
//  and initializes this object to point to that instance.
//
//  Parameters:
//
//      LPMEMORY pMemory            The memory block to create on.
//      CClassPart* pClassDef       Our class definition
//      CInstancePartContainer* pContainer  The container (CWbemInstance)
//
//  Retutns:
//
//      LPMEMORY:   points to the first byte after the data written
//
//*****************************************************************************
//
//  TranslateToNewHeap
//
//  Moves all the data currently on the instance part heap to another heap. The
//  point of this operation is that it performs heap compaction --- the new
//  heap will not contain any holes. The data is NOT removed from the old heap.
//
//  Parameters:
//
//      READONLY CClassPart& ClassPart  Our class definition
//      READONLY CFastHeap* pOldHeap    The current heap.
//      CFastHeap* pNewHeap             The new heap.
//
//*****************************************************************************
//
//  CanContainKey
//
//  Qualifier sets ask this question of their container. Instance part's 
//  answer is always no --- instance cannot be keys!
//
//  Returns:
//
//      WBEM_E_INVALID_QUALIFIER
//
//*****************************************************************************
//
//  GetTotalRealLength
//
//  Computes how much space is needed to represent this instance if we were to
//  eliminate the holes between components (but without heap compaction).
//
//  Returns:
//
//      length_t:   how much the instance part will take after Compact.
//
//*****************************************************************************
//
//  Compact
//
//  Removes all holes between components by moving their memory blocks
//  together.
//
//*****************************************************************************
//
//  ReallocAndCompact
//
//  Compacts (see Compact) and grows the memory block to a given size, possibly
//  reallocating it.
//
//  Parameters:
//
//      length_t nNewTotalLength        Required length of the memory block
//
//*****************************************************************************
//
//  ExtendHeapSize, ReduceHeapSize
//
//  Heap container functionality. See CFastHeapContainer in fastheap.h for info
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace, ReduceQualifierSetSpace
//
//  Qualifier set container functionality. See CQualifierSetConrainer in 
//  fastqual.h for info.
//
//*****************************************************************************
//
//  ExtendDataTableSpace, ReduceDataTableSpace
//
//  Data table container functionality. See CDataTableContainer in fastprop.h
//  for info.
//
//*****************************************************************************
//
//  ExtendQualifierSetListSpace, ReduceQualifierSetListSpace
//
//  Qualifier set list (property qualifier sets) container functionality. See
//  CQualifierSetListContainer in fastqual.h for info.
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not a localization bit has been set.  The localization
//	bit is set in the instance part header.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the instance part header. This bit is not
//	written out by Unmerge.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************

class COREPROX_POLARITY CInstancePart : public CHeapContainer, 
                      public CDataTableContainer,
                      public CQualifierSetContainer,
                      public CQualifierSetListContainer
{

public:
    CInstancePartContainer* m_pContainer;

// The data in this structure is unaligned
#pragma pack(push, 1)
    struct CInstancePartHeader
    {
        length_t nLength; 
        BYTE fFlags;
        heapptr_t ptrClassName;
    };
#pragma pack(pop)

	CInstancePartHeader*	m_pHeader;

public:
    CDataTable m_DataTable;
    CInstanceQualifierSet m_Qualifiers;
    CInstancePropertyQualifierSetList m_PropQualifiers;
    CFastHeap m_Heap;

public:
    CInstancePart() : m_Qualifiers(1){}
     void SetData(LPMEMORY pStart, 
                  CInstancePartContainer* pContainer, 
                  CClassPart& ClassPart,
                  size_t cbLength);

     static size_t ValidateBuffer(LPMEMORY start, size_t cbSize, CClassPart& classData, DeferedObjList& embededList);

     HRESULT IsValidInstancePart( CClassPart* pClassPart, DeferedObjList& embededList);

     LPMEMORY GetStart() {return LPMEMORY(m_pHeader);}
     static int GetLength(LPMEMORY pStart) 
    {
        return ((CInstancePartHeader*)pStart)->nLength;
    }
     int GetLength() {return m_pHeader->nLength;}
     void Rebase(LPMEMORY pNewMemory);

public:
     HRESULT GetActualValue(CPropertyInformation* pInfo, CVar* pVar);
     HRESULT SetActualValue(CPropertyInformation* pInfo, CVar* pVar);
     HRESULT GetObjectQualifier(LPCWSTR wszName, CVar* pVar, 
        long* plFlavor);
     HRESULT SetInstanceQualifier(LPCWSTR wszName, CVar* pVar, 
        long lFlavor);
     HRESULT SetInstanceQualifier( LPCWSTR wszName, long lFlavor,
		 CTypedValue* pTypedValue );
     HRESULT GetQualifier(LPCWSTR wszName, CVar* pVar, 
        long* plFlavor, CIMTYPE* pct = NULL);
    HRESULT GetQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal,
						CFastHeap** ppHeap, BOOL fValidateSet );

	BOOL IsLocalized( void )
	{
		return m_pHeader->fFlags & WBEM_FLAG_INSTANCEPART_LOCALIZATION_MASK;
	}

	void SetLocalized( BOOL fLocalized )
	{    
		m_pHeader->fFlags &= ~WBEM_FLAG_INSTANCEPART_LOCALIZATION_MASK;
		m_pHeader->fFlags |= ( fLocalized ? WBEM_FLAG_INSTANCEPART_LOCALIZED :
								WBEM_FLAG_INSTANCEPART_NOT_LOCALIZED );
	}

public:
     static LPMEMORY GetDataTableData(LPMEMORY pStart)
    {
        return pStart + sizeof(CInstancePartHeader);
    }
public:
     static length_t ComputeNecessarySpace(CClassPart* pClassPart);
     LPMEMORY Create(LPMEMORY pStart, CClassPart* pClassPart,
        CInstancePartContainer* pContainer);

     BOOL TranslateToNewHeap(CClassPart& ClassPart,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap);

    LPMEMORY CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest);

    void DeleteProperty(CPropertyInformation* pInfo);
    LPMEMORY ConvertToClass(CClassPart& ClassPart, length_t nLen, 
                                        LPMEMORY pMemory);

public: // container functionality

    CFastHeap* GetHeap() {return &m_Heap;}
    HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainSingleton() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainAbstract( BOOL fValue ) {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainDynamic() {return WBEM_E_INVALID_QUALIFIER;}
    BOOL CanHaveCimtype(LPCWSTR) {return FALSE;}
    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetInstanceObjectUnknown();}

     length_t GetTotalRealLength()
    {
        return sizeof(CInstancePartHeader) + m_Qualifiers.GetLength() + 
            m_PropQualifiers.GetLength() + m_DataTable.GetLength() + m_Heap.GetLength();
    }

     void Compact( bool bTrim = true );
     BOOL ReallocAndCompact(length_t nNewTotalLength);

    // CHeapContainer
    BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nExtra);
    void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength,  length_t nDecrement){}
    LPMEMORY GetMemoryLimit(){ return EndOf(*this); };
        
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement){}

    BOOL ExtendDataTableSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength){ return TRUE; } // never happens
    void ReduceDataTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement){} // never happens
     void SetDataLength(length_t nDataLength){} // never happens

    BOOL ExtendQualifierSetListSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength);
    void ReduceQualifierSetListSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nDecrement){}

    CDataTable* GetDataTable() {return &m_DataTable;}
    LPMEMORY GetQualifierSetStart() {return m_Qualifiers.GetStart();}
    LPMEMORY GetQualifierSetListStart() {return m_PropQualifiers.GetStart();}
//public:
//    void DumpHeapUsage(CClassPart * pClassPart);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CWbemInstance
//
//  Represents an WBEM instance. It is derived from CWbemObject (fastobj.h) and
//  much of the functionality is inherited from it.
//
//  The memory block of CWbemInstance consists of three parts:
//
//  1) Decoration part, containing the origin information for the object. It is
//      modeled by CDecorationPart class (see fastobj.h). m_DecorationPart 
//      member maps it.
//
//  2) Class part, containing the definition of the class, as described in 
//      CClassPart (see fastcls.h). m_ClassPart member maps it.
//
//  3) Instance part, containing all the instance data as descrined in 
//      CInstancePart (above). m_InstancePart maps it.
//
//  Here, we do not re-describe the methods implemented in CWbemObject, just the
//  ones implemented in this class.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function
//
//  Parameters:
//
//      LPMEMORY pStart         The start of the memory block
//      int nTotalLength        The length of the memory block.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t:       the length of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has moved.
//
//  Parameters:
//
//      LPMEMORY pBlock     The new location of the memory block
//
//*****************************************************************************
//
//  GetProperty
//
//  Gets the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  The information structure for the 
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has 
//      already been "found").
//
//*****************************************************************************
//
//  GetClassPart
//
//  Returns the pointer to the m_ClassPart
//
//  Returns:
//
//      CClassPart*: pointer to the class part describing out class.
//
//*****************************************************************************
//
//  GetProperty
//
//  Gets the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  The information structure for the 
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has 
//      already been "found").
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the proeprty to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*	pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetProperty
//
//  Returns the value of a given property.
//
//  Parameters:
//
//      IN LPCWSTR wszName      The name of the property to access.
//      OUT CVar* pVar          Destination for the value. Must not already
//                              contain a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  SetPropValue
//
//  Sets the value of the property. 
//
//  Parameters:
//
//      IN LPCWSTR wszProp       The name of the property to set.
//      IN CVar *pVal           The value to store in the property.
//      IN CIMTYPE ctType       Should be 0
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//      WBEM_E_TYPE_MISMATCH     The value does not match the property type
//
//*****************************************************************************
//
//  SetPropQualifier
//
//  Sets the value of a given qualifier on a given property.
//
//  Parameters:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  Returns:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  GetPropQualifier
//
//  Retrieves the value of a given qualifier on a given property.
//
//  Parameters:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  Returns:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property or no such qualifier.
//
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a qualifier from the instance itself.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve.
//      OUT CVar* pVal          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//		IN BOOL fLocalOnly		Only get locals (default is TRUE)
//  Returns:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such qualifier.
//
//*****************************************************************************
//
//  GetNumProperties
//
//  Retrieves the number of properties in the object
//
//  Returns:
//
//      int:
//
//*****************************************************************************
//
//  GetPropName
//
//  Retrieves the name of the property at a given index. This index has no 
//  meaning except inthe context of this enumeration. It is NOT the v-table
//  index of the property.
//
//  Parameters:
//
//      IN int nIndex        The index of the property to retrieve. Assumed to
//                           be within range (see GetNumProperties).
//      OUT CVar* pVar       Destination for the name. Must not already contain
//                           a value.
//
//*****************************************************************************
//
//  IsKeyed
//
//  Verifies if this class has keys.
//
//  Returns:
//
//      BOOL:   TRUE if the object either has 'key' properties or is singleton.
//
//*****************************************************************************
//
//  GetRelPath
//
//  Returns the relative path to the instance, or NULL if some of the key
//  values are not filled in or if the class is not keyed.
//  
//  Returns:
//
//      LPCWSTR: the newnely allocated string containing the path or NULL on 
//              errors. The caller must delete this string.
//
//*****************************************************************************
//
//  Decorate
//
//  Sets the origin information for the object.
//
//  Parameters:
//
//      LPCWSTR wszServer       the name of the server to set.
//      LPCWSTR wszNamespace    the name of the namespace to set.
//
//*****************************************************************************
//
//  Undecorate
//
//  Removes the origin informaiton from the object
//
//*****************************************************************************
//
//  GetGenus
//
//  Retrieves the genus of the object.
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetClassName
//
//  Retrieves the class name of the object
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetDynasty
//
//  Retrieves the dynasty of the object, i.e. the name of the top-level class
//  its class is derived from.
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetSuperclassName
//
//  Retrieves the parent class name of the object
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class is a top-levle class.
//
//*****************************************************************************
//
//  GetPropertyCount
//
//  Retrieves the number of proerpties in the object
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetIndexedProps
//
//  Returns the array of the names of all the proeprties that are indexed.
//
//  Parameters:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyProps
//
//  Returns the array of the names of all the proeprties that are keys.
//
//  Parameters:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  GetLimitedVersion
//
//  Produces a new CWbemInstance based on this one and a limitation map 
//  (obtained from CWbemClass::MapLimitation, see fastcls.h).
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap     The map to use to limit the properties
//                                      and qualifiers to use in the new
//                                      instance.
//      OUT CWbemInstance** ppNewInst    Destination for the new instance. May
//                                      not be NULL. The caller is responsible
//                                      for calling Release on this pointer 
//                                      when no longer needed.
//  RETURNS:
//
//      WBEM_S_NO_ERROR            On success
//      WBEM_E_FAILED              On errors (none to date).
//
//*****************************************************************************
//
//  InitializePropQualifierSet
//
//  Instance property qualifier sets take several tricky arguments during
//  initialization. This function takes care of initializing an instance 
//  property qualifier set.
//
//  Parameters I:
//
//      CPropertyInformation* pInfo         Property information structure.
//      CInstancePropertyQualifierSet& IPQS Qualifier set to initialize.
//
//  Parameters II:
//
//      LPCWSTR wszProp                     Property name.
//      CInstancePropertyQualifierSet& IPQS Qualifier set to initialize.
//
//  Returns:
//
//      WBEM_S_NO_ERROR          On success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  Validate
//
//  Verifies that all the properties that must have non-null values do. Such
//  properties include those marked with 'key', 'index', or 'not_null' 
//  qualifiers.
//
//  Returns:
//
//      WBEM_S_NO_ERROR          On success
//      WBEM_E_ILLEGAL_NULL      One of the non-null properties is null.
//
//*****************************************************************************
//
//  static EstimateInstanceSpace
//
//  Estimates the amount of space needed to represent an empty instance of a 
//  given class.
//
//  Parameters:
//
//      CClassPart& ClassPart           The class definition
//      CDecorationPart* pDecoration    Origin info to use on the instance. If
//                                      NULL, undecorated space is estimated.
//  Returns:
//
//      length_t    (over-)estimate on the amount of space.
//
//*****************************************************************************
//
//  InitEmptyInstance
//
//  Creates an empty instance of a given class on a given memory block and sets
//  this object to point to that instance.
//
//  Parameters:
//
//      CClassPart& ClassPart           The class definition.
//      LPMEMORY pStart                 The memory block to create on.
//      int nAllocatedLength            Allocated size of the block
//      CDecorationPart* pDecoration    Origin information to use. If NULL, 
//                                      the instance is created undecorated.
//
//*****************************************************************************
//
//  EstimateUnmergeSpace
//
//  When an instance is stored into the database, only its instance part is
//  written. Thus, this function returns the size of the instance part.
//
//  Returns:
//
//      length_t:  the number of bytes needed in the database for this instance
//
//*****************************************************************************
//
//  Unmerge
//
//  When an instance is stored into the database, only its instance part is
//  written. This function writes the database representation of the instance
//  to a memory block. Before doing so, it completely compacts the heap.
//
//  Parameters:
//
//      LPMEMORY pStart         The memory block to write to. Assumed to be
//                              large enough (see EstimateUnmergeSpace).
//      int nAllocatedLength    Allocated length of the block.
//  
//  Returns:
//
//      length_t:   the length of the data written
//
//*****************************************************************************
//
//  static CreateFromBlob
//
//  Helper function. Given a class an database representation of the instance
//  (instance part), creates an instance object. Allocates memory for the block
//
//  Parameters:
//
//      CWbemClass* pClass       The class definition to use
//      LPMEMORY pInstPart      The instance data (as CInstancePart describes)
//
//  Returns;
//
//      CWbemInstance*:  the new instance object or NULL on errors. The caller
//          must delete this object when no longer needed.
//
//*****************************************************************************
//
//  InitNew
//
//  A wrapper for InitEmptyInstance. Allocates enough memory for a new instance
//  of a given class, creates the appropriate representation and attaches us
//  to it.
//
//  Parameters:
//
//      CWbemClass* pClass               The class definition
//      int nExtraMem                   Extra padding to allocate. This is for
//                                      optimization purposes only.
//      CDecorationPart* pDecoration    Origin information to use. If NULL, the
//                                      instance is created undecorated.
//  Returns:
//
//      BOOL:   FALSE if the class is not a valid one, TRUE on success
//
//*****************************************************************************
//
//  ClearCachedKey
//
//  Clears the value of the instance "key string" that the instance keeps
//  cached. The next time GetKey is called, the "key string" will be recomputed
//  from scratch.
//
//*****************************************************************************
//
//  GetKeyStr
//
//  Computes the "key string" for the instance. This is what the database
//  engine uses to order instances. 
//
//  Returns:
//
//      LPWSTR: the key string. Must be deleted by the caller.
//
//*****************************************************************************
//
//  GetKey
//
//  Retrieves the "key string" for the instance in the form of a CVar. This
//  function caches the string and does not recompute it until ClearCachedKey
//  is called.
//
//  Returns:
//
//      CVar*; containes the key string. THIS IS AN INTERNAL POINTER AND SHOULD
//          NOT BE MODIFIED OR DELETED.
//
//*****************************************************************************
//
//  Reparent
//
//  Reparents the supplied instance.  We do this by spawning an instance from
//	the supplied class and copying values for all local properties, all and all
//	local qualifiers (instance and property).
//
//  PARAMETERS:
//
//      IN CWbemClass* pNewParent	IWbemClassObject for new parent class.
//
//      OUT CWbemInstance** ppNewInst	Reparented instance.
//
//  RETURN VALUES:
//
//      HRESULT	WBEM_S_NO_ERROR if success.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not any localization bits have been set.  Localization
//	bits can be in either the class part or the combined part.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the instance part.  This bit should not be
//	written out to the database.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************
//**************************** IWbemClassObject interface **********************
//
//  Most members of this interface are implemented in CWbemObject. Others are
//  implemented here. For the description of these methods and their return
//  values, see help
//
//*****************************************************************************

// The version of the array BLOB we are transfering during remote refresher operations
#define TXFRBLOBARRAY_PACKET_VERSION	1


class COREPROX_POLARITY CWbemInstance : public CWbemObject, 
                        public CInstancePartContainer, 
                        public CClassPartContainer
{
protected:
    length_t m_nTotalLength;
    CInstancePart m_InstancePart;
    CClassPart m_ClassPart;

    CVar m_CachedKey;

    friend class CWbemClass;
public:
    CWbemInstance() 
        : m_ClassPart(), m_InstancePart(), 
          CWbemObject(m_InstancePart.m_DataTable, m_InstancePart.m_Heap,
                        m_ClassPart.m_Derivation)
    {}
    ~CWbemInstance()
    {
    }
     void SetData(LPMEMORY pStart, int nTotalLength);
	 void SetData( LPMEMORY pStart, int nTotalLength, DWORD dwBLOBStatus );
     LPMEMORY GetStart() {return m_DecorationPart.GetStart();}
     length_t GetLength() {return m_nTotalLength;}
     void Rebase(LPMEMORY pMemory);

	 // Overrides CWbemObject implementation
	HRESULT WriteToStream( IStream* pStream );
	HRESULT GetMaxMarshalStreamSize( ULONG* pulSize );
	static size_t ValidateBuffer(LPMEMORY start, size_t cbSize, DeferedObjList& embededList);
	static size_t ValidateBuffer( LPMEMORY pStart, int nTotalLength, DWORD dwBLOBStatus, DeferedObjList& embededList );
	
protected:
    DWORD GetBlockLength() {return m_nTotalLength;}
    HRESULT GetProperty(CPropertyInformation* pInfo, CVar* pVar)
    {
		HRESULT	hr;

		// Check for allocation failures
        if(m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex))
		{
			hr = m_ClassPart.GetDefaultValue(pInfo, pVar);
		}
        else
		{
            hr = m_InstancePart.GetActualValue(pInfo, pVar); 
		}
            
        return hr;
    }  

    CClassPart* GetClassPart() {return &m_ClassPart;}
     HRESULT InitializePropQualifierSet(
                                CPropertyInformation* pInfo,
                                CInstancePropertyQualifierSet& IPQS);

     HRESULT InitializePropQualifierSet(LPCWSTR wszProp, 
                                        CInstancePropertyQualifierSet& IPQS);

	 // _IWmiObject Support

	 BOOL IsDecorationPartAvailable( void )
	 {
		 // Must have the part
		 return ( m_dwInternalStatus & WBEM_OBJ_DECORATION_PART );
	 }

	 BOOL IsInstancePartAvailable( void )
	 {
		 // Must have the part
		 return ( m_dwInternalStatus & WBEM_OBJ_INSTANCE_PART );
	 }

	 BOOL IsClassPartAvailable( void )
	 {
		 // Must have the part
		 return ( m_dwInternalStatus & WBEM_OBJ_CLASS_PART );
	 }

	 BOOL IsClassPartInternal( void )
	 {
		 // Must have the part and it must be internal
		 return (	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART	)
				&&	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART_INTERNAL	)	);
	 }

	 BOOL IsClassPartShared( void )
	 {
		 // Must have the part and it must be shared
		 return (	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART	)
				&&	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART_SHARED	)	);
	 }

public:
     HRESULT GetNonsystemPropertyValue(LPCWSTR wszName, CVar* pVar)
    {
        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL) return WBEM_E_NOT_FOUND;
        return GetProperty(pInfo, pVar);
    }
    HRESULT GetProperty(LPCWSTR wszName, CVar* pVal)
    {
        HRESULT hres = GetSystemPropertyByName(wszName, pVal);
        if(hres == WBEM_E_NOT_FOUND)
            return GetNonsystemPropertyValue(wszName, pVal);
        else
            return hres;
    }
    HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType, 
							long* plFlavor = NULL);
    HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                   long* plFlags);

    HRESULT SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType);
    HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal, long* plFlavor = NULL, CIMTYPE* pct = NULL)
    {
		//	We may want to separate this later...however for now, we'll get
		//	local and propagated values.
		return m_InstancePart.GetQualifier(wszName, pVal, plFlavor, pct);
    }

	HRESULT GetQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal, CFastHeap** ppHeap,
						BOOL fValidateSet )
	{
		return m_InstancePart.GetQualifier( wszName, plFlavor, pTypedVal, ppHeap, fValidateSet );
	}

    HRESULT SetQualifier(LPCWSTR wszName, CVar* pVal, long lFlavor = 0)
    {
        if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        return m_InstancePart.SetInstanceQualifier(wszName, pVal, lFlavor);
    }

    HRESULT SetQualifier( LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue )
    {
        if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        return m_InstancePart.SetInstanceQualifier(wszName, lFlavor, pTypedValue);
    }

    HRESULT GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, CVar* pVar,
        long* plFlavor = NULL, CIMTYPE* pct = NULL)
    {
        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszProp);
        if(pInfo == NULL) return WBEM_E_NOT_FOUND;
        return GetPropQualifier(pInfo, wszQualifier, pVar, plFlavor, pct);
    }

    HRESULT GetPropQualifier(CPropertyInformation* pInfo, 
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

    HRESULT GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
    {
        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL) return WBEM_E_NOT_FOUND;
        return GetPropQualifier( pInfo, wszQualifier, plFlavor, pTypedVal, ppHeap, fValidateSet );
    }

    HRESULT GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);

    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

	BOOL IsLocalized( void );
	void SetLocalized( BOOL fLocalized );

     int GetNumProperties()
    {
        return m_ClassPart.m_Properties.GetNumProperties();
    }
    HRESULT GetPropName(int nIndex, CVar* pVal)
    {
		// Check for allocation failures
        if ( !m_ClassPart.m_Heap.ResolveString(
				 m_ClassPart.m_Properties.GetAt(nIndex)->ptrName)->
					StoreToCVar(*pVal) )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		return WBEM_S_NO_ERROR;
    }

    HRESULT Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace);
    void Undecorate();
    BOOL IsKeyed() {return m_ClassPart.IsKeyed();}
    LPWSTR GetRelPath( BOOL bNormalized=FALSE );

	virtual HRESULT	IsValidObj( void );

    HRESULT Validate();
    BOOL IsValidKey(LPCWSTR wszKey);
    HRESULT PlugKeyHoles();

    void CompactAll()
    {
        m_InstancePart.Compact();
    }

    void CompactClass();

    HRESULT CopyBlob(LPMEMORY pBlob, int nLength);
    HRESULT CopyBlobOf(CWbemObject* pSource);
    HRESULT CopyTransferBlob(long lBlobType, long lBlobLen, BYTE* pBlob);
    HRESULT CopyActualTransferBlob(long lBlobLen, BYTE* pBlob);
    HRESULT GetTransferBlob(long *plBlobType, long *plBlobLen, 
                                /* CoTaskAlloced! */ BYTE** ppBlob);
	void GetActualTransferBlob( BYTE* pBlob );

	// Support for remotely refreshable enumerations
    static long GetTransferArrayHeaderSize( void )
	{ return 2*sizeof(long); }

	// A RemoteRefresher transfer blob consists of the datatable
	// qualifier sets, used heap data and a long describing the
	// length of the used heap data.

	// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
	// signed/unsigned 32-bit value.  We do not support length
	// > 0xFFFFFFFF so cast is ok.

	long GetActualTransferBlobSize( void )
	{ return (long) ( m_InstancePart.m_Heap.GetStart()-
                    m_InstancePart.m_DataTable.GetStart() +
                    m_InstancePart.m_Heap.GetRealLength() ); }

	long GetTransferBlobSize( void )
	{ return GetActualTransferBlobSize() + sizeof(long); }

	// A RemoteRefresher Transfer Array Blob is the regular BLOB
	// plus a long to hold the Blob size.
    long GetTransferArrayBlobSize( void )
	{ return GetTransferBlobSize() + sizeof(long); }

    static void WriteTransferArrayHeader( long lNumObjects, BYTE** ppBlob )
	{
		BYTE*	pTemp = *ppBlob;

		// Version
		*((UNALIGNED long*) pTemp) = TXFRBLOBARRAY_PACKET_VERSION;
		pTemp += sizeof(long);

		// Number of objects
		*((UNALIGNED long*) pTemp) = lNumObjects;

		// Reset the memory pointer
		*ppBlob = pTemp + sizeof(long);
	}

	HRESULT GetTransferArrayBlob( long lBloblen, BYTE** ppBlob, long* plBlobLen);

	static HRESULT CopyTransferArrayBlob(CWbemInstance* pInstTemplate, long lBlobType, long lBlobLen, 
											BYTE* pBlob, CFlexArray& apObj, long* plNumArrayObj );

    static  length_t EstimateInstanceSpace(CClassPart& ClassPart,
        CDecorationPart* pDecoration = NULL);

    HRESULT InitEmptyInstance(CClassPart& ClassPart, LPMEMORY pStart,
        int nAllocatedLength, CDecorationPart* pDecoration = NULL);

     length_t EstimateUnmergeSpace()
        {return m_InstancePart.GetLength();}
        
     HRESULT Unmerge(LPMEMORY pStart, int nAllocatedLength, length_t* pnUnmergedLength );

    static  CWbemInstance* CreateFromBlob(CWbemClass* pClass, LPMEMORY pInstPart, size_t cbLength);

    static CWbemInstance* CreateFromBlob2(CWbemClass* pClass,LPMEMORY pInstPart,
                                                                 WCHAR * pszServer,WCHAR * pszNamespace);
                                                                               
     HRESULT InitNew(CWbemClass* pClass, int nExtraMem = 0,
        CDecorationPart* pDecoration = NULL);

public:
     HRESULT GetClassName(CVar* pVar)
        {return m_ClassPart.GetClassName(pVar);}
     HRESULT GetSuperclassName(CVar* pVar)
        {return m_ClassPart.GetSuperclassName(pVar);}
     HRESULT GetDynasty(CVar* pVar);
     HRESULT GetPropertyCount(CVar* pVar)
        {return m_ClassPart.GetPropertyCount(pVar);}
     HRESULT GetGenus(CVar* pVar)
    {
        pVar->SetLong(WBEM_GENUS_INSTANCE);
        return WBEM_NO_ERROR;
    }

     void ClearCachedKey() { m_CachedKey.Empty(); }
    LPWSTR GetKeyStr();
    CVar * CalculateCachedKey();
     INTERNAL CVar* GetKey()
    {
        if(m_CachedKey.GetType() != VT_EMPTY)
        	return &m_CachedKey;
        else
        	return CalculateCachedKey();
    } 

     BOOL GetIndexedProps(CWStringArray& awsNames)
        {return m_ClassPart.GetIndexedProps(awsNames);}
     BOOL GetKeyProps(CWStringArray& awsNames)
        {return m_ClassPart.GetKeyProps(awsNames);}
     HRESULT GetKeyOrigin(WString& wsClass)
        {return m_ClassPart.GetKeyOrigin( wsClass );}

    HRESULT GetLimitedVersion(IN CLimitationMapping* pMap, 
                              NEWOBJECT CWbemInstance** ppNewInst);

    HRESULT DeleteProperty(int nIndex);
    BOOL IsInstanceOf(CWbemClass* pClass);
    static HRESULT AsymmetricMerge(CWbemInstance* pOldInstance,
                                       CWbemInstance* pNewInstance);
    HRESULT ConvertToClass(CWbemClass* pClass, CWbemInstance** ppInst);

	HRESULT Reparent( CWbemClass* pNewParent, CWbemInstance** pNewInst );

    HRESULT FastClone( CWbemInstance* pInst );

public: // container functionaliy
	// Class Part can't change once its in an instance
    BOOL ExtendClassPartSpace(CClassPart* pPart, length_t nNewLength){ return TRUE; }
    void ReduceClassPartSpace(CClassPart* pPart, length_t nDecrement){}
    BOOL ExtendInstancePartSpace(CInstancePart* pPart, length_t nNewLength);
    void ReduceInstancePartSpace(CInstancePart* pPart, length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown() {return (IUnknown*)(IWbemClassObject*)this;}
    IUnknown* GetInstanceObjectUnknown()  {return (IUnknown*)(IWbemClassObject*)this;}

    void ClearCachedKeyValue() {ClearCachedKey();}

	// Creates an instance with class data, and merges with it.
	HRESULT ConvertToMergedInstance( void );

public:
    STDMETHOD(GetQualifierSet)(IWbemQualifierSet** ppQualifierSet);
    STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    STDMETHOD(Delete)(LPCWSTR wszName);

    STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty, 
                                       IWbemQualifierSet** ppQualifierSet);
    STDMETHOD(Clone)(IWbemClassObject** ppCopy);
    STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);
    STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
    STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);

    STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(DeleteMethod)(LPCWSTR wszName)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(BeginMethodEnumeration)(long lFlags)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(EndMethodEnumeration)()
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName)
        {return WBEM_E_ILLEGAL_OPERATION;}

    STDMETHOD(SetInheritanceChain)(long lNumAntecedents, 
        LPWSTR* awszAntecedents)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(SetPropertyOrigin)(LPCWSTR wszPropertyName, long lOriginIndex)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(SetMethodOrigin)(LPCWSTR wszMethodName, long lOriginIndex)
        {return WBEM_E_ILLEGAL_OPERATION;}

	// _IWmiObject Methods
    STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts );
    STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed );

    STDMETHOD(StripClassPart)();

    STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
    STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize );
    STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart );

	STDMETHOD(ClearWriteOnlyProperties)(void);

	// _IWmiObject Methods
	STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject );
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

	STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance );
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass );
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass );
	// Compares the derived most class information of two class objects.

    STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass );
	// Creates a limited representation class for projection queries

    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance );
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj );
	// Merges a blob with the current object memory and creates a new object

	STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj );
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild );
	// Upgrades class and instance objects

	STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass );
	// Updates derived class object using the safe/force mode logic

	STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst );
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.
	
	STDMETHOD(CloneAndDecorate)(long lFlags,WCHAR * pszServer,WCHAR * pszNamespace,IWbemClassObject** ppDestObject);

    STDMETHOD(MergeAndDecorate)(long lFlags,ULONG uBuffSize,LPVOID pbData,WCHAR * pServer,WCHAR * pNamespace,_IWmiObject** ppNewObj);
};

//#pragma pack(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastobj.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTOBJ.CPP

Abstract:

  This file implements the classes related to generic object representation
  in WbemObjects. Its derived classes for instances (CWbemInstance) and
  classes (CWbemClass) are described in fastcls.h and fastinst.h.

  For complete documentation, see fastobj.h

  Classes implemented:
      CDecorationPart     Information about the origins of the object.
      CWbemObject          Any object --- class or instance.

History:

  3/10/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"

#include "wbemutil.h"
#include "fastall.h"
#include <wbemutil.h>

#include <wbemstr.h>
#include "olewrap.h"
#include <arrtempl.h>
#include "wmiarray.h"
#include "genutils.h"
#include "md5wbem.h"
#include "reg.h"
#include <scopeguard.h>
#include <autoptr.h>

#include <dbghelp.h>

// Define this to enable debugging of object refcounting
//#define DEBUGOBJREFCOUNT

//#define INSTRUMENTED_BUILD

// Default to enabled in DEBUG, disbaled in RELEASE
#ifdef _DEBUG
bool g_bObjectValidation = true;
#else
bool g_bObjectValidation = false;
#endif

CGetHeap CBasicBlobControl::m_Heap;

CCOMBlobControl g_CCOMBlobControl;
CBasicBlobControl g_CBasicBlobControl;

//
// till we known what is the right limit
//
DWORD g_ContextLimit = 0xFFFFFFFF; //32*1024;
DWORD g_ObjectLimit = 0xFFFFFFFF; //128*1024;

DWORD g_IdentifierLimit = WBEM_MAX_IDENTIFIER; // Max property, qualifier, class name (4K)

// system limits reg keys
#define MAX_IDENTIFIER_WBEM L"IdentifierLimit"
#define MINIMUM_MAX_IDENTIFIER 64

#define MAX_BUFFER_LENGTH (256)

#ifndef PAGE_HEAP_ENABLE_PAGE_HEAP
#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#endif 

#ifndef PAGE_HEAP_COLLECT_STACK_TRACES
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#endif

HANDLE CreatePageHeap(DWORD flOptions,       
                                      SIZE_T dwInitialSize,  
                                      SIZE_T dwMaximumSize)
{
    if (!SymInitialize(GetCurrentProcess(),NULL,FALSE)) return NULL;
    OnDelete<HANDLE,BOOL(*)(HANDLE),SymCleanup> CleanSym(GetCurrentProcess());
    
    DWORD64 dwAddr64 = SymLoadModule64(GetCurrentProcess(),NULL,
                                                                  "ntdll.dll",
                                                                   NULL,
                                                                   (DWORD64)GetModuleHandleW(L"ntdll.dll"),0);
    if (NULL == dwAddr64 ) return NULL;
    OnDelete2<HANDLE,DWORD64,BOOL(*)(HANDLE,DWORD64),SymUnloadModule64> UnlaodMe(GetCurrentProcess(),dwAddr64);

    class SymInfoBuff : public SYMBOL_INFO
    {
    public:
        CHAR buffer_[MAX_BUFFER_LENGTH];
    public:        
        SymInfoBuff()
        {
            SizeOfStruct = sizeof(SYMBOL_INFO);
            MaxNameLen = MAX_BUFFER_LENGTH;
            Address = 0;
        };
    } symInfoBuff;

    if (!SymFromName(GetCurrentProcess(),"ntdll!RtlpDebugPageHeap",&symInfoBuff)) return NULL;
    BOOLEAN * RtlpDebugPageHeap = (BOOLEAN *)symInfoBuff.Address;    

    symInfoBuff.Address = 0;
    symInfoBuff.MaxNameLen = MAX_BUFFER_LENGTH;    
    if (!SymFromName(GetCurrentProcess(),"ntdll!RtlpDphGlobalFlags",&symInfoBuff)) return NULL;
    DWORD * RtlpDphGlobalFlags = (DWORD *)symInfoBuff.Address;        

    BOOLEAN SaveDebug = *RtlpDebugPageHeap;
    DWORD SaveFlags = *RtlpDphGlobalFlags;
    *RtlpDebugPageHeap = 1;
    *RtlpDphGlobalFlags = PAGE_HEAP_ENABLE_PAGE_HEAP  | PAGE_HEAP_COLLECT_STACK_TRACES;

    HANDLE hHeap = HeapCreate(flOptions,dwInitialSize,dwMaximumSize);

    *RtlpDebugPageHeap = SaveDebug;
    *RtlpDphGlobalFlags  = SaveFlags;

    return hHeap;
}



CGetHeap::CGetHeap():m_bNewHeap(FALSE)
    {
#ifdef DBG 
        DWORD dwUsePrivateHeapForBlobs = 1;
#else
        DWORD dwUsePrivateHeapForBlobs = 0;
#endif
        HKEY hKey;
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 __TEXT("Software\\Microsoft\\WBEM\\CIMOM"),
                                 NULL,
                                 KEY_READ,
                                 &hKey);

        if (ERROR_SUCCESS == lRet)
        {
            DWORD dwType;
            DWORD dwSize = sizeof(DWORD);

            DWORD dwLastPID = 0;
            lRet = RegQueryValueEx(hKey,
                                   __TEXT("ProcessID"),
                                   NULL,
                                   &dwType,
                                   (BYTE *)&dwLastPID,
                                   &dwSize);
            if (dwLastPID == GetCurrentProcessId()) dwUsePrivateHeapForBlobs = 1;

              lRet = RegQueryValueEx(hKey,
                                   __TEXT("EnablePrivateObjectHeap"),
                                   NULL,
                                   &dwType,
                                   (BYTE *)&dwUsePrivateHeapForBlobs,
                                   &dwSize);

            dwSize = sizeof(DWORD);
            lRet = RegQueryValueEx(hKey,
                                   __TEXT("ContextLimit"),
                                   NULL,
                                   &dwType,
                                   (BYTE *)&g_ContextLimit,
                                   &dwSize);

            dwSize = sizeof(DWORD);
            lRet = RegQueryValueEx(hKey,
                                   __TEXT("ObjectLimit"),
                                   NULL,
                                   &dwType,
                                   (BYTE *)&g_ObjectLimit,
                                   &dwSize);            

		dwSize = sizeof(DWORD);
		DWORD dwVal;
		if (ERROR_SUCCESS == RegQueryValueExW(hKey,MAX_IDENTIFIER_WBEM,0,&dwType,(BYTE*)&dwVal,&dwSize))
		{
		    if (REG_DWORD == dwType) 
		    {
		        if (dwVal < MINIMUM_MAX_IDENTIFIER)
		            g_IdentifierLimit = MINIMUM_MAX_IDENTIFIER;
		        else                
		            g_IdentifierLimit = dwVal;
		    }
		}
            
            RegCloseKey(hKey);
        }
        
        if (dwUsePrivateHeapForBlobs)
        {
#ifdef INSTRUMENTED_BUILD
	      m_hHeap = CreatePageHeap(0,0,0);
#else
             m_hHeap  = NULL;
#endif
            if (NULL == m_hHeap)
	         m_hHeap = HeapCreate(0,0,0);

            if (m_hHeap)
                m_bNewHeap = TRUE;
        }
        else
        {
            m_hHeap = CWin32DefaultArena::GetArenaHeap();
        }
        if (NULL == m_hHeap)
            m_hHeap = GetProcessHeap();
    };

CGetHeap::~CGetHeap()
    {
        if (m_bNewHeap)
        {
            HeapDestroy(m_hHeap);
        }
    };





//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
//  static
BOOL CDecorationPart::MapLimitation(READ_ONLY CWStringArray* pwsNames,
                                    IN OUT CLimitationMapping* pMap)
{
    // Determine which of __SERVER and __NAMESPACE properties are needed
    // =================================================================

    if(pwsNames == NULL || pwsNames->FindStr(L"__PATH", CWStringArray::no_case)
                            != CWStringArray::not_found)
    {
        pMap->SetIncludeServer(TRUE);
        pMap->SetIncludeNamespace(TRUE);
    }
    else
    {
        pMap->SetIncludeServer(
                    pwsNames->FindStr(L"__SERVER", CWStringArray::no_case)
                            != CWStringArray::not_found);

        pMap->SetIncludeNamespace(
                    pwsNames->FindStr(L"__NAMESPACE", CWStringArray::no_case)
                            != CWStringArray::not_found);
    }

    return TRUE;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
LPMEMORY CDecorationPart::CreateLimitedRepresentation(
                                        READ_ONLY CLimitationMapping* pMap,
                                        OUT LPMEMORY pWhere)
{
    LPMEMORY pCurrent = pWhere;

    // Check if any decoration data is required
    // ========================================

    if(!pMap->ShouldIncludeServer() && !pMap->ShouldIncludeNamespace())
    {
        // We want to preserve the genus of the object
        *pCurrent = (*m_pfFlags & OBJECT_FLAG_MASK_GENUS) | OBJECT_FLAG_LIMITED | OBJECT_FLAG_UNDECORATED;
        return pCurrent + 1;
    }

    // Write the flags
    // ===============

    *pCurrent = *m_pfFlags | OBJECT_FLAG_LIMITED;
    pCurrent++;

    if((*m_pfFlags & OBJECT_FLAG_MASK_DECORATION) == OBJECT_FLAG_UNDECORATED)
    {
        // No further data
        // ===============

        return pCurrent;
    }

    // Write the server name if required
    // =================================

    int nLength = m_pcsServer->GetLength();
    memcpy((void*)pCurrent, (void*)m_pcsServer, nLength);
    pCurrent += nLength;

    // Write the namespace name if required
    // ====================================

    nLength = m_pcsNamespace->GetLength();
    memcpy((void*)pCurrent, (void*)m_pcsNamespace, nLength);
    pCurrent += nLength;

    return pCurrent;
}



//*****************************************************************************
//*****************************************************************************
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************

CWbemObject::CWbemObject(CDataTable& refDataTable, CFastHeap& refDataHeap,
                            CDerivationList& refDerivationList)
    : m_nRef(1), m_nCurrentProp(INVALID_PROPERTY_INDEX),
      m_bOwnMemory(TRUE), m_pBlobControl(& g_CBasicBlobControl),
      m_refDataTable(refDataTable), m_refDataHeap(refDataHeap),
      m_refDerivationList(refDerivationList),
      m_dwInternalStatus( 0 ),
      m_pMergedClassObject( NULL )
{
#ifdef _DEBUG_REFCOUNT
    BackTraceIndex = -1;
    Signature = 'carT';
    memset(Traces,0,sizeof(Traces));
#endif
    
    m_Lock.SetData(&m_LockData);
    ObjectCreated(OBJECT_TYPE_CLSOBJ,(_IWmiObject *)this);

#ifdef OBJECT_TRACKING
    ObjTracking_Add((CWbemObject *) this);
#endif

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
CWbemObject::~CWbemObject()
{
    m_pBlobControl->Delete(GetStart());
    //delete m_pBlobControl;

    // We're done with this pointer
    if ( NULL != m_pMergedClassObject )
    {
        m_pMergedClassObject->Release();
    }

    ObjectDestroyed(OBJECT_TYPE_CLSOBJ,(_IWmiObject *)this);
#ifdef OBJECT_TRACKING
    ObjTracking_Remove(this);
#endif
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if ( riid ==  IID_IUnknown)
    {
        *ppvObj = (void*) (IUnknown*) (IWbemClassObject*) this;
    }
    else if(riid == IID_IWbemClassObject)
    {
        *ppvObj = (void*)(IWbemClassObject*)this;
    }
    else if(riid == IID_IMarshal)
        *ppvObj = (void*)(IMarshal*)this;
    else if(riid == IID_IWbemPropertySource)
        *ppvObj = (void*)(IWbemPropertySource*)this;
    else if(riid == IID_IErrorInfo)
        *ppvObj = (void*)(IErrorInfo*)this;
    else if(riid == IID_IWbemObjectAccess)
        *ppvObj = (void*)(IWbemObjectAccess*)this;
    else if(riid == IID_IWbemConstructClassObject)
        *ppvObj = (void*)(IWbemConstructClassObject*)this;
    else if (riid == IID__IWmiObjectAccessEx)
        *ppvObj = (void*) (_IWmiObjectAccessEx*)this;
    else if (riid == IID__IWmiObject)
        *ppvObj = (void*) (_IWmiObject*)this;
    else return E_NOINTERFACE;

    ((IUnknown*)*ppvObj)->AddRef();
    return S_OK;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
ULONG CWbemObject::AddRef()
{
#ifdef _DEBUG_REFCOUNT
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));
    LONG lIndex = InterlockedIncrement(&BackTraceIndex)%64;

    ULONG Hash;
    RtlCaptureStackBackTrace(0,8,Traces[lIndex],&Hash);
#endif    
    return InterlockedIncrement((long*)&m_nRef);
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
ULONG CWbemObject::Release()
{
#ifdef _DEBUG_REFCOUNT
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));
    LONG lIndex = InterlockedIncrement(&BackTraceIndex)%64;

    ULONG Hash;
    RtlCaptureStackBackTrace(0,8,Traces[lIndex],&Hash);

    Traces[lIndex][7] = (PVOID)((ULONG_PTR)Traces[lIndex][7] | 0x80000000 );
#endif
    long lRef = InterlockedDecrement((long*)&m_nRef);
    _ASSERT(lRef >= 0, __TEXT("Reference count on IWbemClassObject went below 0!"))

#ifdef DEBUGOBJREFCOUNT

#pragma message("** Compiling Debug Object Ref Counting **")

    if ( lRef < 0 )
    {
        MessageBox( NULL, "BOOM!!!!!  CWbemObject RefCount went below 0!!!!  Please ensure a debugger is attached and contact a DEV IMMEDIATELY!!!\n\nPlease do this now --- we really mean it!!",
                    "WINMGMT CRITICAL ERROR!!!", MB_OK | MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION );
    }
#endif

    if(lRef == 0)
        delete this;
    return lRef;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
CWbemObject* CWbemObject::CreateFromStream(IStream* pStrm)
{
    // Read in and verify the signature
    // ================================
    STATSTG StatStg;

    if (FAILED(pStrm->Stat(&StatStg,STATFLAG_DEFAULT))) return NULL;

    LARGE_INTEGER li; li.QuadPart = 0;
    ULARGE_INTEGER Position;
    if (FAILED(pStrm->Seek(li,STREAM_SEEK_CUR,&Position))) return NULL;

    // simply TotalBytesInStream - CurrentPosition
    // the stream will contain the 'MEOW' header, ecc, ecc
    DWORD dwTotSizeStream = StatStg.cbSize.LowPart - Position.LowPart;
    
    if (dwTotSizeStream > g_ObjectLimit) return NULL;    

    DWORD dwSignature;
    if(pStrm->Read((void*)&dwSignature, sizeof(DWORD), NULL) != S_OK)
    {
        return NULL;
    }
    if(dwSignature != FAST_WBEM_OBJECT_SIGNATURE)
    {
        return NULL;
    }

    // Read in the length of the object
    // ================================

    dwTotSizeStream -= sizeof(DWORD);

    DWORD dwTotalLength;
    if(pStrm->Read((void*)&dwTotalLength, sizeof(DWORD), NULL) != S_OK)
    {
        return NULL;
    }

    dwTotSizeStream -= sizeof(DWORD);

    // declared size of the Blob is greater than the actual Stream size ?
    if (dwTotalLength > dwTotSizeStream) return NULL;
    
    // Read in the rest of the block
    // =============================

    // Check for allocation failures
    BYTE* abyMemory = g_CBasicBlobControl.sAllocate(dwTotalLength);
    if ( NULL == abyMemory )
    {
        return NULL;
    }

    ULONG actualRead = 0;
    if(pStrm->Read((void*)abyMemory, dwTotalLength, &actualRead) != S_OK || actualRead!=dwTotalLength)
    {
        g_CBasicBlobControl.sDelete(abyMemory);
        return NULL;
    }

    return CreateFromMemory(abyMemory, dwTotalLength, TRUE, g_CBasicBlobControl);
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************

CWbemObject* CWbemObject::CreateFromMemory(LPMEMORY pMemory,
                                         int nLength, BOOL bAcquire, CBlobControl& allocator)
{
    ScopeGuard deleteBlock = MakeObjGuardIF(bAcquire!=FALSE, allocator, CBlobControl::Delete, pMemory);
    
    if((*pMemory & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_CLASS)
    {
        // Check for allocation failure

        CWbemClass* pClass = NULL;

        try
        {
            // This can throw an exception
            pClass = new CWbemClass;
            if ( NULL == pClass )
            {
                return NULL;
            }
            
            
            CReleaseMe _1((_IWmiObject*)pClass);            

            CWbemClass::ValidateBuffer((LPBYTE) pMemory, nLength);

            deleteBlock.Dismiss();                        

            pClass->SetData(pMemory, nLength);
            pClass->m_bOwnMemory = bAcquire;            

            if ( FAILED( pClass->ValidateObject( 0L ) ) )  return NULL;            
            pClass->AddRef(); //Compensate
            return pClass;
        }
        catch(...)
        {
            return 0;
        }
    }
    else if ((*pMemory & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_INSTANCE)
    {
        // Check for allocation failure
        CWbemInstance* pInstance = NULL;
        
        try
        {
            pInstance = new CWbemInstance;
            if ( NULL == pInstance )
            {
                return NULL;
            }
              CReleaseMe _1((_IWmiObject*)pInstance);            

            DeferedObjList	EmbededObjects;
            EmbededObjects.reserve(2);

            CWbemInstance::ValidateBuffer((LPBYTE) pMemory, nLength, EmbededObjects);
            while(!EmbededObjects.empty())
            {
                EmbeddedObj lastObject = EmbededObjects.back();
                EmbededObjects.pop_back();
                CEmbeddedObject::ValidateBuffer(lastObject.m_start, lastObject.m_length,EmbededObjects);
            }

            deleteBlock.Dismiss();
		    pInstance->SetData(pMemory, nLength);
		    pInstance->m_bOwnMemory = bAcquire;
	        

            // Check that the object is valid
            if ( FAILED( pInstance->ValidateObject( 0L ) ) ) return 0;
            pInstance->AddRef();
            return pInstance;
        }
        catch(...)
        {
            return 0;
        }
    }
    else return 0;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************

HRESULT CWbemObject::WriteToStream( IStream* pStrm )
{

    // Protect the BLOB during this operation
    CLock   lock( this, WBEM_FLAG_ALLOW_READ );

    DWORD dwSignature = FAST_WBEM_OBJECT_SIGNATURE;

    // Write the signature
    // ===================

    HRESULT hres = pStrm->Write((void*)&dwSignature, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    // Write length
    // ============

    DWORD dwLength = GetBlockLength();
    hres = pStrm->Write((void*)&dwLength, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    // Write block
    // ===========

    hres = pStrm->Write((void*)m_DecorationPart.GetStart(),
                          GetBlockLength(), NULL);
    if(FAILED(hres)) return hres;

    return S_OK;

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
INTERNAL CCompressedString* CWbemObject::GetClassInternal()
{
    return GetClassPart()->GetClassName();
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
DELETE_ME LPWSTR CWbemObject::GetValueText(long lFlags, READ_ONLY CVar& vValue,
                                            Type_t nType)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    WString wsText;
    if ( CType::GetBasic(nType) == CIM_IUNKNOWN )
    {
        wsText += L"<interface>";
    }
    else if(vValue.GetType() == VT_EMBEDDED_OBJECT)
    {
        // Embedded object
        // ===============

        IWbemClassObject* pEmbedded =
            (IWbemClassObject*)vValue.GetEmbeddedObject();
        // Ensures cleanup during exception handling
        CReleaseMe  rm( pEmbedded );

        BSTR str = NULL;

        hr = pEmbedded->GetObjectText(lFlags | WBEM_FLAG_NO_SEPARATOR, &str);

        // Ensures cleanup during exception handling
        CSysFreeMe  sfm( str );

        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        if(str == NULL)
            return NULL;

        wsText += str;

    }
    else if(vValue.GetType() == VT_EX_CVARVECTOR &&
            vValue.GetVarVector()->GetType() == VT_EMBEDDED_OBJECT)
    {
        // Array of embedded objects
        // =========================

        CVarVector* pvv = vValue.GetVarVector();
        wsText += L"{";
        for(int i = 0; i < pvv->Size(); i++)
        {
            if(i != 0)
                wsText += L", ";

            // Get the value
            CVar    vTemp;
            pvv->FillCVarAt( i, vTemp );

            IWbemClassObject* pEmbedded = (IWbemClassObject*)vTemp.GetEmbeddedObject();

            // Ensures cleanup during exception handling
            CReleaseMe  rm( pEmbedded );

            // Free up the BSTR when we go out of scope
            BSTR str = NULL;

            hr = pEmbedded->GetObjectText(lFlags | WBEM_FLAG_NO_SEPARATOR, &str);
            CSysFreeMe  sfm( str );

            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                throw CX_MemoryException();
            }

            if(str == NULL)
                return NULL;

            wsText += str;
            
        }
        wsText += L"}";
    }
    else
    {
        // Normal value --- CVar can handle
        // ================================

        // Free up the BSTR when we go out of scope
        BSTR str = vValue.GetText(lFlags, CType::GetActualType(nType));
        CSysFreeMe  sfm( str );

        if(str == NULL)
            return NULL;

        wsText += str;

    }
    return wsText.UnbindPtr();

}



//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                             CIMTYPE* pctType, long* plFlavor)
{
    try
    {

        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hres;

        // If the value starts with an underscore see if it's a System Property
        // DisplayName, and if so, switch to a property name - otherwise, this
        // will just return the string we passed in
        
        //wszName = CSystemProperties::GetExtPropName( wszName );

        if(pVal != NULL)
        {
            CVar Var;
            hres = GetProperty(wszName, &Var);
            if(FAILED(hres)) return hres;
            VariantInit(pVal);

            // When we fill the variant, perform any appropriate optimizations
            // to cut down on memory allocations
            Var.FillVariant(pVal, TRUE);
        }
        if(pctType != NULL || plFlavor != NULL || pVal == NULL)
        {
            hres = GetPropertyType(wszName, pctType, plFlavor);
            if(FAILED(hres)) return hres;
        }
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetNames(
                    LPCWSTR wszQualifierName,
                    long lFlags, VARIANT* pQualValue, SAFEARRAY** ppArray)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        CClassPart& ClassPart = *GetClassPart();

        // Test parameter correctness
        // ==========================

        if(ppArray == NULL) return WBEM_E_INVALID_PARAMETER;
        *ppArray = NULL;

        long lPrimaryCond = lFlags & WBEM_MASK_PRIMARY_CONDITION;
        long lOriginCond = lFlags & WBEM_MASK_CONDITION_ORIGIN;
        long lClassCondition = lFlags & WBEM_MASK_CLASS_CONDITION;

        BOOL bKeysOnly = lFlags & WBEM_FLAG_KEYS_ONLY;
        BOOL bRefsOnly = lFlags & WBEM_FLAG_REFS_ONLY;

        if(lFlags & ~WBEM_MASK_PRIMARY_CONDITION & ~WBEM_MASK_CONDITION_ORIGIN &
            ~WBEM_FLAG_KEYS_ONLY & ~WBEM_FLAG_REFS_ONLY & ~WBEM_MASK_CLASS_CONDITION)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Cannot request a class conditin and be an instance
        if ( lClassCondition &&    IsInstance() )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CVar varQualValue;

        if(lPrimaryCond != WBEM_FLAG_ALWAYS)
        {
            if(wszQualifierName == NULL || wcslen(wszQualifierName) == 0)
                return WBEM_E_INVALID_PARAMETER;

            if(lPrimaryCond == WBEM_FLAG_ONLY_IF_TRUE ||
                lPrimaryCond == WBEM_FLAG_ONLY_IF_FALSE)
            {
                if(pQualValue != NULL) return WBEM_E_INVALID_PARAMETER;
            }
            else if(lPrimaryCond == WBEM_FLAG_ONLY_IF_IDENTICAL)
            {
                if(pQualValue == NULL) return WBEM_E_INVALID_PARAMETER;
                varQualValue.SetVariant(pQualValue, TRUE);
            }
            else return WBEM_E_INVALID_PARAMETER;
        }

        // Changed to AutoDelete so it gets destructed, however, to
        // access the array, we must now make a copy.

        CSafeArray SA(VT_BSTR, CSafeArray::auto_delete,
                        ClassPart.m_Properties.GetNumProperties() +
                        CSystemProperties::GetNumSystemProperties());

        // Add system properties, if required
        // ==================================

        if((lOriginCond == 0 || lOriginCond == WBEM_FLAG_SYSTEM_ONLY) &&
            (lPrimaryCond == WBEM_FLAG_ALWAYS ||
                lPrimaryCond == WBEM_FLAG_ONLY_IF_FALSE) &&
            !bKeysOnly && !bRefsOnly && !lClassCondition
        )
        {
            int nNumProps = CSystemProperties::GetNumSystemProperties();

            for(int i = 1; i <= nNumProps; i++)
            {
                BSTR strName = CSystemProperties::GetNameAsBSTR(i);
                CSysFreeMe  sfm( strName );

                SA.AddBSTR(strName);
            }
        }

        // Enumerate all regular properties, testing condition
        // ===================================================

        for(int i = 0; i < ClassPart.m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = ClassPart.GetPropertyLookup(i);
            if(pLookup == NULL) return WBEM_S_NO_MORE_DATA;

            CPropertyInformation* pInfo = (CPropertyInformation*)
                ClassPart.m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

            // Test condition
            // ==============

            if(lFlags != 0)
            {
                if((lOriginCond == WBEM_FLAG_LOCAL_ONLY) &&
                        CType::IsParents(pInfo->nType))
                    continue;

                if((lOriginCond == WBEM_FLAG_PROPAGATED_ONLY) &&
                        !CType::IsParents(pInfo->nType))
                    continue;

                // This means we're dealing with a class and we're only interested
                // in overridden properties
                if ( lClassCondition == WBEM_FLAG_CLASS_OVERRIDES_ONLY )
                {
                    // We ignore if it's local - since no way could it be overridden
                    // We ignore if it's not overridden
                    if ( !CType::IsParents(pInfo->nType) || !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
                    {
                        continue;
                    }
                }

                // This means we're dealing with a class and we're interested in
                // both local and overridden properties
                if ( lClassCondition == WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES )
                {
                    // We ignore if it's not one or the other
                    if ( CType::IsParents(pInfo->nType) && !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
                        continue;
                }

                // Check for a potential incorrect system property hit here
                if ( GetClassPart()->GetHeap()->ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
                {
                    if ( lOriginCond & WBEM_FLAG_NONSYSTEM_ONLY || 
                        lClassCondition ||
                        lOriginCond == WBEM_FLAG_LOCAL_ONLY ||
                        lOriginCond == WBEM_FLAG_PROPAGATED_ONLY )
                    {
                            continue;
                    }
                }
                else if ( lOriginCond == WBEM_FLAG_SYSTEM_ONLY )
                {
                    // We don't care about the property if this is a system only enumeration
                    continue;
                }

                if((lFlags & WBEM_FLAG_KEYS_ONLY) && !pInfo->IsKey())
                    continue;

                if((lFlags & WBEM_FLAG_REFS_ONLY) &&
                        !pInfo->IsRef(&ClassPart.m_Heap))
                    continue;

                // Need to try to find the qualifier
                // =================================

                if(lPrimaryCond != WBEM_FLAG_ALWAYS)
                {
                    CVar varActualQual;
                    HRESULT hres = GetPropQualifier(pInfo,
                        wszQualifierName, &varActualQual);

                    if(lPrimaryCond == WBEM_FLAG_ONLY_IF_TRUE && FAILED(hres))
                        continue;

                    if(lPrimaryCond == WBEM_FLAG_ONLY_IF_FALSE &&
                            SUCCEEDED(hres))
                        continue;

                    if(lPrimaryCond == WBEM_FLAG_ONLY_IF_IDENTICAL &&
                            (FAILED(hres) || !(varActualQual == varQualValue))
                      )
                        continue;
                }
            }

            // Passed the test
            // ===============

            BSTR strName = ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                CreateBSTRCopy();
            // Check for allocation failures
            if ( NULL == strName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            CSysFreeMe  sfm( strName );

            // This should throw an exception if we hit an OOM condition
            SA.AddBSTR(strName);

        }    // FOR enum regular properties

        // Create SAFEARRAY and return
        // ===========================

        SA.Trim();

        // Now we make a copy, since the member array will be autodestructed (this
        // allows us to write exception-handling code
        *ppArray = SA.GetArrayCopy();
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }


}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::BeginEnumeration(long lEnumFlags)
{
    // No Allocations take place here, so no need to catch exceptions

    try
    {
        CLock lock(this);

        long lOriginFlags = lEnumFlags & WBEM_MASK_CONDITION_ORIGIN;
        long lClassFlags = lEnumFlags & WBEM_MASK_CLASS_CONDITION;

        BOOL bKeysOnly = lEnumFlags & WBEM_FLAG_KEYS_ONLY;
        BOOL bRefsOnly = lEnumFlags & WBEM_FLAG_REFS_ONLY;

        // We allow CLASS Flags only on classes
        if( lClassFlags && IsInstance() )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if( lEnumFlags & ~WBEM_MASK_CONDITION_ORIGIN & ~WBEM_FLAG_KEYS_ONLY &
                ~WBEM_FLAG_REFS_ONLY & ~WBEM_MASK_CLASS_CONDITION )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if((lOriginFlags == 0 || lOriginFlags == WBEM_FLAG_SYSTEM_ONLY) &&
            !bKeysOnly && !bRefsOnly && !lClassFlags )
        {
            m_nCurrentProp = -CSystemProperties::GetNumSystemProperties();
        }
        else
            m_nCurrentProp = 0;

        m_lEnumFlags = lEnumFlags;

        // Always clear this
        m_lExtEnumFlags = 0L;

        return WBEM_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::Next(long lFlags, BSTR* pstrName, VARIANT* pvar,
                              CIMTYPE* pctType, long* plFlavor)
{
    // Check for out of memory

    BSTR strName = NULL;

    try
    {
        CLock lock(this);

        long    nOriginalProp = m_nCurrentProp;

        if(pvar)
            VariantInit(pvar);
        if(pstrName)
            *pstrName = NULL;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(m_nCurrentProp == INVALID_PROPERTY_INDEX)
            return WBEM_E_UNEXPECTED;

        CClassPart& ClassPart = *GetClassPart();

        // Search for a valid system property
        // ==================================

        while(m_nCurrentProp < 0)
        {
            // Don't use scoping to axe this BSTR, since iut's value may get sent to the
            // outside world.
            strName = CSystemProperties::GetNameAsBSTR(-m_nCurrentProp);

            if ( NULL == strName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            CVar Var;
            HRESULT hres = GetSystemProperty(-(m_nCurrentProp++), &Var);
            if(FAILED(hres))
            {
                COleAuto::_SysFreeString(strName);
                strName = NULL;
                continue;
            }

            CSystemProperties::GetPropertyType(strName, pctType, plFlavor);
            if(pvar)
            {
                Var.FillVariant(pvar, TRUE);
            }
            if(pstrName)
            {
                *pstrName = strName;
            }
            else
            {
                COleAuto::_SysFreeString(strName);
                strName = NULL;
            }

            return hres;
        }

        // Look for the non-system property
        // ================================

        // Loop until you find a match
        // ===========================
        CPropertyLookup* pLookup;
        CPropertyInformation* pInfo;
        while(1)
        {
            pLookup = ClassPart.GetPropertyLookup(m_nCurrentProp++);
            if(pLookup == NULL) return WBEM_S_NO_MORE_DATA;

            pInfo = (CPropertyInformation*)
                ClassPart.m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

            if((m_lEnumFlags & WBEM_FLAG_KEYS_ONLY) && !pInfo->IsKey())
                continue;
            if((m_lEnumFlags & WBEM_FLAG_REFS_ONLY) &&
                    !pInfo->IsRef(&ClassPart.m_Heap))
                continue;

            // Get the flavor and check if it passes our origin conditions
            long lFlavor = 0;
            GetPropertyType( pInfo, NULL, &lFlavor );

            if((m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN)==WBEM_FLAG_LOCAL_ONLY &&
                WBEM_FLAVOR_ORIGIN_PROPAGATED == lFlavor)
                continue;

            if((m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN)==WBEM_FLAG_PROPAGATED_ONLY &&
                WBEM_FLAVOR_ORIGIN_LOCAL == lFlavor)
                continue;

            // Check for a potential incorrect system property hit here
            if ( GetClassPart()->GetHeap()->ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
            {
                if ( ( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN ) == WBEM_FLAG_NONSYSTEM_ONLY ||
                    ( m_lEnumFlags & WBEM_MASK_CLASS_CONDITION ) ||
                    ( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN )==WBEM_FLAG_LOCAL_ONLY ||
                    ( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN ) == WBEM_FLAG_PROPAGATED_ONLY )
                {
                    // If the extended flag is set, then we really do want this property.
                    if ( !( m_lExtEnumFlags & WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS ) )
                        continue;
                }
            }
            else if ( ( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN ) == WBEM_FLAG_SYSTEM_ONLY )
            {
                // We don't care about the property if this is a system only enumeration
                continue;
            }
            else
            {

                // This means we're dealing with a class and interested in overridden properties
                if ( ( m_lEnumFlags & WBEM_MASK_CLASS_CONDITION ) == WBEM_FLAG_CLASS_OVERRIDES_ONLY )
                {
                    // We ignore if it's local - since no way could it be overridden
                    // We ignore if it's not overridden
                    if ( WBEM_FLAVOR_ORIGIN_LOCAL == lFlavor || !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
                        continue;

                }

                // This means we're dealing with a class and interested in local and overridden properties
                if ( ( m_lEnumFlags & WBEM_MASK_CLASS_CONDITION ) == WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES )
                {
                    // We ignore if it's not one or the other
                    if ( WBEM_FLAVOR_ORIGIN_LOCAL != lFlavor && !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
                        continue;
                }

            }

            break;
        }

        // Found our property. Get its value
        // =================================

        // Don't use scoping to axe this BSTR, since iut's value may get sent to the
        // outside world.
        strName = ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
            CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == strName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CVar Var;
        HRESULT    hr = GetProperty(pInfo, &Var);

        if ( FAILED( hr ) )
        {
            return hr;
        }

        GetPropertyType(strName, pctType, plFlavor);

        if(pvar)
        {
            Var.FillVariant(pvar, TRUE);
        }

        if(pstrName)
        {
            *pstrName = strName;
        }
        else
        {
            // Cleanup the BSTR if we don't need it
            COleAuto::_SysFreeString(strName);
            strName = NULL;
        }

        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        // Something blew.  Just go to the end of the enumeration
        m_nCurrentProp = INVALID_PROPERTY_INDEX;

        // Cleanup the strName if necessary
        if ( NULL != strName )
        {
            COleAuto::_SysFreeString(strName);
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        m_nCurrentProp = INVALID_PROPERTY_INDEX;

        // Cleanup the strName if necessary
        if ( NULL != strName )
        {
            COleAuto::_SysFreeString(strName);
        }

        return WBEM_E_CRITICAL_ERROR;
    }

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::EndEnumeration()
{
    CLock lock(this);
    m_nCurrentProp = INVALID_PROPERTY_INDEX;
    m_lExtEnumFlags = 0L;
    return WBEM_S_NO_ERROR;
}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//***************************************************************