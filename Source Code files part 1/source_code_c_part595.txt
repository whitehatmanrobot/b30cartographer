gItem);}; 
public:
    CDlgProcHandler(){m_hWnd=NULL;m_hModule=NULL;};
};

class CDlg:public CDlgProcHandler
{
protected:
    virtual INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
public:
    int Dlg(WORD wID,HMODULE  hModule,HWND hParent);
};

int CDlg::Dlg(WORD wID,HMODULE  hModule,HWND hParent)
{
    m_hModule=hModule;
    return DialogBoxParam(hModule,MAKEINTRESOURCE(wID),hParent,
        CDlgProcHandler::DialogProc,(LPARAM)this);
}

typedef list<GUID> LISTGUID;
class CMainDlg;
class CPreferredDlg:public CDlg
{
    LISTGUID m_ListCtrl;    
    bool m_bBlockUpdate;
    CCore *m_pCore;
    CMainDlg *m_pMainDlg;

    virtual BOOL InitDialog(HWND hFocus,LPARAM lParam);
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    void Preferred();
    INT_PTR Notify(int idCtrl,LPNMHDR pnmh);
public:
    CPreferredDlg(CMainDlg *pMainDlg,CCore *pCore)
        {m_pMainDlg=pMainDlg;m_pCore=pCore;m_bBlockUpdate=false;};
    void Update();
};

class CAddDlg:public CDlg
{
    CCore *m_pCore;
//    CMainDlg *m_pMainDlg;
    LISTSTRING m_ListCtrl;
    LISTSTRING m_GprtListCtrl;
    bool m_bBlockUpdate;

    BOOL InitDialog(HWND hFocus,LPARAM lParam);
    INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    void AddDev();
    INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
public:
    CAddDlg(/*CMainDlg *pMainDlg,*/CCore *pCore)
        {/*m_pMainDlg=pMainDlg;*/m_pCore=pCore;m_bBlockUpdate=false;};
    void Update();
};

class CCustomDlg:public CDlg
{
    CCore *m_pCore;
    String m_VIDPIDName;
    BOOL InitDialog(HWND hFocus,LPARAM lParam);
    INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
public:
    CCustomDlg(CCore *pCore){m_pCore=pCore;};
    LPCTSTR GetVIDPIDName(){return m_VIDPIDName.data();};
};

class CMainDlg:public CDlg
{
    LISTGUID m_ListCtrl;    
    bool m_bBlockUpdate;
    CCore *m_pCore;
    CPreferredDlg *m_pPrefDlg;
    CAddDlg *m_pAddDlg;
    bool m_bEditingName;

    virtual BOOL InitDialog(HWND hFocus,LPARAM lParam);
    virtual BOOL Timer(WPARAM wTimerID);
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
    INT_PTR Notify(int idCtrl,LPNMHDR pnmh);
    void Remove();
    void Prop();
protected:
    CMainDlg(){m_pCore=NULL;m_bBlockUpdate=false;m_pPrefDlg=NULL;m_pAddDlg=NULL;m_bEditingName=false;};
    void ConnectUI(CCore *pCore){m_pCore=pCore;};
    void Update();
    void CoreUpdate();
};

class CUpdate
{
    bool *m_pbBlockUpdate;
public:
    CUpdate(bool *pbBlockUpdate)
        {m_pbBlockUpdate=pbBlockUpdate;*m_pbBlockUpdate=true;};
    ~CUpdate(){*m_pbBlockUpdate=false;};
};

/******************************************************************************
End of UI header
******************************************************************************/

#define DEVICE_COLUMN 0
#define STATUS_COLUMN 1

LPTSTR Insert1String(LPCTSTR pS,LPCTSTR pI)
{
    LPTSTR pR=new TCHAR[_tcslen(pS)+_tcslen(pI)+1];
    wsprintf(pR,pS,pI);
    return pR;
}

LPTSTR Insert2Strings(LPCTSTR pS,LPCTSTR pI1,LPCTSTR pI2)
{
    LPTSTR pR=new TCHAR[_tcslen(pS)+_tcslen(pI1)+_tcslen(pI2)+1];
    wsprintf(pR,pS,pI1,pI2);
    return pR;
}

void MessageBox(HWND hWnd,HINSTANCE hInstance,UINT uTitleID,UINT uMsgID)
{
    TCHAR Title[128];
    TCHAR Msg[256];

    LoadString(hInstance,uTitleID, Title, cA(Title));
    LoadString(hInstance,uMsgID, Msg, cA(Msg));
    UINT uRTL = (GetWindowLongPtr(hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
    MessageBox(hWnd,Msg,Title,MB_ICONHAND|MB_OK|MB_APPLMODAL|uRTL);
}

void LVSetItem(HWND hCtrl,int nItem,int nSubItem, LPCTSTR lpStr)
{
    LVITEM Item;
    ZeroMemory(&Item,sizeof(Item));
    Item.mask=LVIF_TEXT;
    Item.iItem=nItem;
    Item.iSubItem=nSubItem;
    Item.cchTextMax=lstrlen(lpStr);
    Item.pszText=(LPTSTR)lpStr;

    SendMessage(hCtrl,LVM_SETITEM,0,(LPARAM)(const LPLVITEM)&Item);
}

void LVInsertItem(HWND hCtrl,int nItem,int nSubItem,LPCTSTR lpStr,LPARAM lData)
{
    LVITEM Item;
    ZeroMemory(&Item,sizeof(Item));
    Item.mask=LVIF_TEXT|LVIF_PARAM;
    Item.iItem=nItem;
    Item.cchTextMax=lstrlen(lpStr);
    Item.pszText=(LPTSTR)lpStr;
    Item.lParam=lData;

    SendMessage(hCtrl,LVM_INSERTITEM,0,(LPARAM)(const LPLVITEM)&Item);
}

void *LVGetItemDataPtr(HWND hCtrl,int nItem)
{
    LVITEM Item;
    ZeroMemory(&Item,sizeof(LVITEM));
    Item.mask=LVIF_PARAM;
    Item.iItem=nItem;
    if(SendMessage(hCtrl,LVM_GETITEM,0,(LPARAM)(LPLVITEM)&Item))
        return(void*)Item.lParam;
    return NULL;
}

const GUID &LVGetItemGUID(HWND hCtrl,int nItem)
{
    if(nItem<0)return NULLGUID;
    GUID *pG=(GUID*)LVGetItemDataPtr(hCtrl,nItem);
    if(pG)return *pG;
    return NULLGUID;
}

int LVFindGUIDIndex(HWND hCtrl,GUID &G)
{
    int nCnt=ListView_GetItemCount(hCtrl);
    for(int i=0;i<nCnt;i++)
        if(G==LVGetItemGUID(hCtrl,i))return i;
    return -1;
}

int LVGetSel(HWND hCtrl)
{
    return ListView_GetNextItem(hCtrl,-1,LVNI_SELECTED);
}

void LVSetSel(HWND hCtrl,int nItem,bool bSel=true)
{
    if(bSel)
        ListView_SetItemState(hCtrl,nItem,
                            LVIS_FOCUSED|LVIS_SELECTED,0x000F)
    else
        ListView_SetItemState(hCtrl,nItem,
                            0,0x000F);
}

void LVInsertColumn (HWND hCtrl,int nColumn,UINT uID,int nWidth,HINSTANCE hInstance)
{
    LVCOLUMN Col;
    ZeroMemory(&Col,sizeof(Col));
    Col.mask=LVCF_FMT|LVCF_TEXT|LVCF_WIDTH;
    Col.fmt=LVCFMT_CENTER;
    Col.cx=nWidth;

    TCHAR S[128];
    LoadString(hInstance,uID, S, cA(S));

    Col.pszText=(LPTSTR)S;
    SendMessage(hCtrl,LVM_INSERTCOLUMN,(WPARAM)(int)nColumn,(LPARAM)(const LPLVCOLUMN)&Col);
}

INT_PTR CDlgProcHandler::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        return InitDialog((HWND)wParam,lParam);
    case WM_TIMER:
        return Timer(wParam);
    case WM_COMMAND:
        return Command(HIWORD(wParam),LOWORD(wParam),(HWND)lParam);
    case WM_NOTIFY:
        return Notify((int)wParam,(LPNMHDR)lParam);
    case WM_CONTEXTMENU:
        {
            TCHAR HelpFileName[128];
            LoadString(m_hModule,IDS_HELPFILENAME, HelpFileName, cA(HelpFileName));
            WinHelp((HWND)wParam,HelpFileName,HELP_CONTEXTMENU,(ULONG_PTR)gaHelpIDs);
        }
        //Undocumented in msdn but otherwise
        //problem rightclicking title to close.
        return TRUE;
    default:
        return FALSE;
    }
    return FALSE;
}

INT_PTR CDlgProcHandler::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDC_WHATSTHIS:
        {
            TCHAR HelpFileName[128];
            LoadString(m_hModule,IDS_HELPFILENAME, HelpFileName, cA(HelpFileName));
            WinHelp(hwndCtl,HelpFileName,HELP_WM_HELP,(ULONG_PTR)gaHelpIDs);
        }
        return 0;
    }
    return 0;
};

INT_PTR CALLBACK CDlgProcHandler::DialogProc
            (HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    CDlgProcHandler* pH=NULL;

    try
    {
        if(uMsg==WM_INITDIALOG)
        {
            SetLastError(0);
            LONG lRet=SetWindowLongPtr(hwndDlg,GWLP_USERDATA,lParam);
            if(GetLastError()&&!lRet) {
                EndDialog(hwndDlg,E_FAIL);
            }
        }
        
        pH=(CDlgProcHandler*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
        if(pH && !IsBadReadPtr(pH, sizeof(CDlgProcHandler)))
        {
            if(uMsg==WM_INITDIALOG) {
                pH->m_hWnd=hwndDlg;
            } 
            
            if( pH->m_hWnd == hwndDlg ) {
                return pH->DialogProc(uMsg,wParam,lParam);
            }
        }
        return FALSE;
    }
    
    catch(JoyException E)
    {
        if(pH)
        {
            if(uMsg==WM_INITDIALOG) {
                EndDialog(pH->m_hWnd,IDCANCEL);
            }
        }
    }

    catch(...)
    {
        if(pH && !IsBadReadPtr(pH, sizeof(CDlgProcHandler))) {
            EndDialog(pH->m_hWnd, IDCANCEL);
        }
        //should report error here, and keep going.
    }

    if(uMsg==WM_INITDIALOG) {
        return TRUE;
    }

    return FALSE;
}

/******************************************************************************
CDlg
******************************************************************************/

INT_PTR CDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        if(!(wNotifyCode&~1))
            EndDialog(m_hWnd,IDOK);
        return 0;
    case IDCANCEL:
        if(!(wNotifyCode&~1))
            EndDialog(m_hWnd,IDCANCEL);
        return 0;
    }
    return CDlgProcHandler::Command(wNotifyCode,wID,hwndCtl);
};

INT_PTR CDlg::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_CLOSE:
        EndDialog(m_hWnd,0);
        return 0;
    }
    return CDlgProcHandler::DialogProc(uMsg,wParam,lParam);
}

/******************************************************************************
Main dialog CMainDlg
******************************************************************************/

void CMainDlg::Remove()
{
    {
        if(!m_pCore->Access())
        {
            MessageBox(m_hWnd,m_hModule,IDS_USER_MODE_TITLE,IDS_USER_MODE);
            return;
        }
        HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
        if(hListCtrl)
        {
            int nSelDev=LVGetSel(hListCtrl);
            if(nSelDev<0)return;
            GUID G=LVGetItemGUID(hListCtrl,nSelDev);
            CDIDev *pDev=m_pCore->FindDIDev(G);

            if(!pDev) {
                return;
            }

            TCHAR AreSure[256];
            LoadString(m_hModule,IDS_GEN_AREYOUSURE, AreSure, cA(AreSure));
            LPTSTR pT = Insert1String(AreSure,pDev->InstName());
            lstrcpy(AreSure, pT);
            delete[] pT;

            TCHAR Title[128];
            LoadString(m_hModule,IDS_GEN_AREYOUSURE_TITLE, Title, cA(Title));

            UINT uRTL = (GetWindowLongPtr(m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
            if(IDYES!=MessageBox(m_hWnd,AreSure,Title,MB_ICONQUESTION|MB_YESNO|MB_APPLMODAL|uRTL)) {
                return;
            }
            if(m_pCore->Remove(G)==DIERR_UNSUPPORTED) {
                MessageBox(m_hWnd,m_hModule,IDS_GEN_AREYOUSURE_TITLE,IDS_GEN_NO_REMOVE_USB);
            }
        }   
    }
    CoreUpdate();
}

void OnHelp(LPHELPINFO pHelpInfo,HINSTANCE hInstance)
{
    TCHAR FileName[256];
    LoadString(hInstance,IDS_HELPFILENAME, FileName, cA(FileName));
    if(pHelpInfo->iContextType==HELPINFO_WINDOW)
        WinHelp((HWND)pHelpInfo->hItemHandle,FileName,HELP_WM_HELP,(ULONG_PTR)gaHelpIDs);
}

INT_PTR CMainDlg::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_ACTIVATEAPP:
        CoreUpdate();
        return 0;
/*    case WM_POWERBROADCAST:
        switch( wParam )
        {
        return 0;
        case PBT_APMSUSPEND:
            // Suspend operation!
            KillTimer(hDlg, ID_MYTIMER);
            break;

        case PBT_APMRESUMESUSPEND:
        case PBT_APMRESUMECRITICAL:
            // Resume operation!
            SetActive(hDlg);
            break;
        }
        break;return 0;*/
    case WM_DEVICECHANGE:
        CoreUpdate();        
        return 0;
    case WM_HELP:
        OnHelp((LPHELPINFO)lParam,m_hModule);
        return 0;
/*        nFlags &= ~ON_PAGE;
        KillTimer(hDlg, ID_MYTIMER);
        OnContextMenu(wParam, lParam);
        nFlags |= ON_PAGE;
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        return(1);        return 0;???
*/
    case WM_SYSCOLORCHANGE:
        {
            HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
            if(hListCtrl)
            {
                SendMessage(hListCtrl,WM_SYSCOLORCHANGE,0,0);
            }
        }
        return 0;
    }
    return CDlg::DialogProc(uMsg,wParam,lParam);
}

void CMainDlg::Prop()
{
    HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
    if(hListCtrl)
    {
        int nSelDev=LVGetSel(hListCtrl);
        if(nSelDev<0)return;
        GUID G=LVGetItemGUID(hListCtrl,nSelDev);
        CDIDev *pDev=m_pCore->FindDIDev(G);
        //ISSUE-2001/03/29-timgill  internal error;SHOULD ASSERT HERE
        if(!pDev)return;
                //need to kill the timer before launching property sheet - see Whistler bug 260145 for details
                KillTimer(m_hWnd,1);
        switch(Properties(m_hModule,m_hWnd,m_pCore,pDev->Id()))
        {
        case E_NOINTERFACE:
            MessageBox(m_hWnd,m_hModule,IDS_INTERNAL_ERROR,IDS_NO_DIJOYCONFIG);
            break;
        default://Not handled for now or ever?
            break;
        };
                //now update and re-set the timer
                m_pCore->Update();
                SetTimer(m_hWnd,1,5000,NULL);
    }
}

INT_PTR CMainDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDC_BTN_ADV:
        if(!m_pCore->Access()) {
            MessageBox(m_hWnd,m_hModule,IDS_USER_MODE_TITLE,IDS_USER_MODE);
        } else {
            if(!m_pPrefDlg)
            {
                CPreferredDlg PrefDlg(this,m_pCore);
                m_pPrefDlg=&PrefDlg;
                PrefDlg.Dlg(IDD_ADV_CHANGE,m_hModule,m_hWnd);
                m_pPrefDlg=NULL;
            }
        }
        return 0;
    case IDC_BTN_REMOVE:
        Remove();
        return 0;
    case IDC_BTN_ADD:
        if(!m_pCore->Access()) {
            MessageBox(m_hWnd,m_hModule,IDS_USER_MODE_TITLE,IDS_USER_MODE);
        } else {
            if(!m_pAddDlg)
            {
                CAddDlg AddDlg(m_pCore);
                m_pAddDlg=&AddDlg;
                AddDlg.Dlg(IDD_ADD,m_hModule,m_hWnd);
                m_pAddDlg=NULL;
            }
        }
        return 0;
    case IDC_BTN_TSHOOT:
        {
            TCHAR ExeBuff[MAX_PATH];

            if( GetWindowsDirectory(ExeBuff,MAX_PATH) ) {
                TCHAR CmdBuff[256];
                LoadString(m_hModule,IDS_TSHOOT_CMD, CmdBuff, cA(CmdBuff));

                STARTUPINFO Si;
                PROCESS_INFORMATION Pi;
                ZeroMemory(&Si,sizeof(Si));
                ZeroMemory(&Pi,sizeof(Pi));
                Si.cb=sizeof(Si);
// ISSUE-2000/12/20-MarcAnd Quick Fix to use HSS
// In other places where HSS is used, STARTF_FORCEONFEEDBACK is not set 
// Changed IDS_TSHOOT_CMD from: "hh.exe joy.chm" 
// to "explorer.exe hcp://help/tshoot/tsInputDev.htm"
// Need to make this OS specific to allow backprop to Win2k (or further)
                Si.dwFlags=STARTF_USESHOWWINDOW|STARTF_FORCEONFEEDBACK;
                Si.wShowWindow=SW_NORMAL;

                ExeBuff[MAX_PATH-1]=0;
                String Exe=ExeBuff;
                String Cmd=CmdBuff;
                if(Exe[Exe.size()-1]!=_T('\\'))
                {
                    Exe+=_T('\\');
                }
                Exe+=_T("explorer.exe");
                Cmd=_T("\"")+Exe+_T("\"")+_T(" ")+Cmd;

                if(CreateProcess(Exe.data(),(LPTSTR)Cmd.data(),0,0,0,0,0,0,&Si,&Pi))
                {
                    CloseHandle(Pi.hThread);
                    CloseHandle(Pi.hProcess);
                }
            } else {
                // something is wrong when calling GetWindowsDirectory
                ;
            }
        }
        return 0;
    case IDC_BTN_PROPERTIES:
        Prop();
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
};

INT_PTR CMainDlg::Notify(int idCtrl,LPNMHDR pnmh)
{
    switch(pnmh->code )
    {
/*  Keeping this just in case someone changes his/her mind soon.  
    case LVN_BEGINLABELEDIT:
    {
        HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
        if(!hListCtrl)return TRUE;
        if(!m_pCore->Access())return TRUE;
        PostMessage((HWND)::SendMessage(hListCtrl,LVM_GETEDITCONTROL,0,0),EM_SETLIMITTEXT,MAX_PATH-1,0);
        m_bEditingName=true;
        return(FALSE);   
    }
    case LVN_ENDLABELEDIT:
    {
        m_bEditingName=false;
        HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
        if(!hListCtrl)
        {
            CoreUpdate();
            return FALSE;
        }

        HWND hCtrl=(HWND)SendMessage(hListCtrl,LVM_GETEDITCONTROL,0,0);
        if(hCtrl)
        {
            if(SendMessage(hCtrl,EM_GETMODIFY,0,0))
            {
                int nLen=lstrlen(((NMLVDISPINFO*)pnmh)->item.pszText);
                if((nLen>(MAX_PATH-1))||(nLen==0))
                    MessageBeep(MB_ICONHAND);
                //Make sure the name is usable.
                else if(_tcschr(((NMLVDISPINFO*)pnmh)->item.pszText,TEXT('\\')))
                    MessageBox(m_hWnd,m_hModule,IDS_INVALID_NAME_TITLE,IDS_INVALID_NAME);
                else
                {
                    int nSelDev=LVGetSel(hListCtrl);
                    GUID SelGUID=LVGetItemGUID(hListCtrl,nSelDev);
                    CDIDev *pSelDev=m_pCore->FindDIDev(SelGUID);

                    if(SUCCEEDED(pSelDev->Rename(((NMLVDISPINFO *)pnmh)->item.pszText)))
                    {
                        CoreUpdate();
                        return TRUE;
                    } 
                    else
                    {
                        MessageBox(m_hWnd,m_hModule,IDS_NO_RENAME_TITLE,IDS_NO_RENAME);
                    }
                }
            }
        }
        CoreUpdate();
        return FALSE;
    }*/
    case LVN_KEYDOWN:
        switch(((LV_KEYDOWN*)pnmh)->wVKey)
        {
        case VK_DELETE:
            Remove();
            return 0;

        case VK_F5:
            CoreUpdate();
            return 0;
        }
        return 0;
    case LVN_ITEMCHANGED:
        if(!(((LPNMLISTVIEW)pnmh)->uOldState&LVIS_SELECTED)&&
            (((LPNMLISTVIEW)pnmh)->uNewState&LVIS_SELECTED)&&
            (((LPNMLISTVIEW)pnmh)->uChanged&LVIF_STATE))
                Update();
        return 0;
    case NM_DBLCLK:
        switch(idCtrl)
        {
        case IDC_LIST_DEVICE:
            Prop();
            return 0;
        }
        return 0;
    }
    return 0;
}

void CMainDlg::CoreUpdate()
{
    m_pCore->Update();
    //KillTimer so if UI is updated for some other reason than WM_TIMER timer will be reset.
    //make sure nothing can fail between KillTimer and SetTimer.
    KillTimer(m_hWnd,1);
    SetTimer(m_hWnd,1,5000,NULL);
}

BOOL CMainDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    SetTimer(m_hWnd,1,5000,NULL);
    m_pCore->Initialize(m_hWnd);
//#wi315410. we need to decide...
//    m_pCore->UpdateType();
    
    HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
    if(hListCtrl)
    {
        SendMessage(hListCtrl,LVM_SETEXTENDEDLISTVIEWSTYLE,0,LVS_EX_FULLROWSELECT);
        RECT R;
        GetClientRect(hListCtrl,&R);
        int nWidth=(R.right>>2)*3;
        LVInsertColumn(hListCtrl,DEVICE_COLUMN,IDS_GEN_DEVICE_HEADING,nWidth,m_hModule);
        LVInsertColumn(hListCtrl,STATUS_COLUMN,IDS_GEN_STATUS_HEADING,R.right-nWidth,m_hModule);
    }
    CoreUpdate();
    return TRUE;
}

BOOL CMainDlg::Timer(WPARAM wTimerID)
{
    CoreUpdate();
    return FALSE;
}

void CMainDlg::Update()
{
    if(m_pPrefDlg)m_pPrefDlg->Update();

    if(m_bEditingName)return;//Do not update this dialog when editing name.
    if(m_bBlockUpdate)return;//Some actions may send notify messages which then Update and overflow stack.
    CUpdate U(&m_bBlockUpdate);

    int nSelDev=-1;
    GUID SelGUID=NULLGUID;
    
    HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
    if(hListCtrl)
    {
        nSelDev=LVGetSel(hListCtrl);
        SelGUID=LVGetItemGUID(hListCtrl,nSelDev);

        SendMessage(hListCtrl,WM_SETREDRAW,(WPARAM)FALSE,0);
        SendMessage(hListCtrl,LVM_DELETEALLITEMS,0,0);
        m_ListCtrl.clear();//Must be behind LVM_DELETEALLITEMS
        int nIndex=0;
        for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();
                It!=m_pCore->m_ListDIDev.end();It++)
        {
            GUID G=It->InstGUID();
            m_ListCtrl.push_back(G);
            LVInsertItem(hListCtrl,nIndex,DEVICE_COLUMN,
                It->InstName(),(LPARAM)&m_ListCtrl.back());

            TCHAR Status[256];
            if(It->Status()==ENotConnected) {
                LoadString(m_hModule,IDS_GEN_STATUS_NOTCONNECTED, Status, cA(Status));
            } else if(It->Status()==EConnected) {
                LoadString(m_hModule,IDS_GEN_STATUS_OK, Status, cA(Status));
            } else {
                LoadString(m_hModule,IDS_GEN_STATUS_UNKNOWN, Status, cA(Status));
            }
            LVSetItem(hListCtrl,nIndex,STATUS_COLUMN,Status);
            nIndex++;
        }

        nSelDev=LVFindGUIDIndex(hListCtrl,SelGUID);
        if(nSelDev>=0)
        {
            LVSetSel(hListCtrl,nSelDev);
        }
        else
            LVSetSel(hListCtrl,0);
        nSelDev=LVGetSel(hListCtrl);
        
        SendMessage(hListCtrl,WM_SETREDRAW,(WPARAM)TRUE,0);
        InvalidateRect(hListCtrl,NULL,TRUE);
        SelGUID=LVGetItemGUID(hListCtrl,nSelDev);
    }
    CDIDev *pSelDev=m_pCore->FindDIDev(SelGUID);
   
//#wi315410. we need to decide...
//    HWND hAddBtn=HDlgItem(IDC_BTN_ADD);
//    if(hAddBtn)
//    {
//        BOOL bE=(m_pCore->m_GprtBus.size()>0)?TRUE:FALSE;
//        EnableWindow(hAddBtn,bE);
//    }
    HWND hRemBtn=HDlgItem(IDC_BTN_REMOVE);
    if(hRemBtn)
    {
        BOOL bE=(nSelDev>=0)?TRUE:FALSE;
        EnableWindow(hRemBtn,bE);
    }
    HWND hPropBtn=HDlgItem(IDC_BTN_PROPERTIES);
    if(hPropBtn)
    {
        BOOL bE=FALSE;
        if((nSelDev>=0)&&pSelDev)
                if(pSelDev->Status()==EConnected)
                    bE=TRUE;
        EnableWindow(hPropBtn,bE);
    }
}

/******************************************************************************
Add dialog
******************************************************************************/

int CBGetCurSel(HWND hCtrl)
{
    int i=ComboBox_GetCurSel(hCtrl);
    if(i==CB_ERR)
        i=-1;
    return i;    
}

int CBGetCnt(HWND hCtrl)
{
    int i=ComboBox_GetCount(hCtrl);
    if(i==CB_ERR)
        i=0;
    return i;    
}

const GUID &CBGetItemGUID(HWND hCtrl,int iIndex)
{
    LRESULT p=ComboBox_GetItemData(hCtrl,iIndex);
    if(p==CB_ERR)return NULLGUID;
    if(p)
        return *(GUID*)p;
    return NULLGUID;
}

int CBFindGUIDIndex(HWND hCtrl,const GUID &G)
{
    int nCnt=ComboBox_GetCount(hCtrl);
    if(nCnt==CB_ERR)return -1;
    for(int i=0;i<nCnt;i++)
    {
        if(CBGetItemGUID(hCtrl,i)==G)
            return i;
    }
    return -1;
}

LPCTSTR CBGetItemTypeName(HWND hCtrl,int iIndex)
{
    LRESULT p=ComboBox_GetItemData(hCtrl,iIndex);
    if(p==CB_ERR)return NULL;
    if(p)
        return ((String*)p)->data();
    return NULL;
}

int CBFindTypeNameIndex(HWND hCtrl,LPCTSTR pTypeName)
{
    int nCnt=ComboBox_GetCount(hCtrl);
    if(nCnt==CB_ERR)return -1;
    String TN;
    if(pTypeName)
        TN=pTypeName;
    for(int i=0;i<nCnt;i++)
    {
        if(CBGetItemTypeName(hCtrl,i)==TN)
            return i;
    }
    return -1;
}

int LBGetCurSel(HWND hCtrl)
{
    int i=ListBox_GetCurSel(hCtrl);
    if(i==LB_ERR)return -1;
    return i;
}

LPCTSTR LBGetItemTypeName(HWND hCtrl,int iIndex)
{
    LRESULT p=ListBox_GetItemData(hCtrl,iIndex);
    if(p==LB_ERR)return NULL;
    if(p)
        return ((String*)p)->data();
    return NULL;
}

int LBFindTypeNameIndex(HWND hCtrl,LPCTSTR pTypeName)
{
    int nCnt=ListBox_GetCount(hCtrl);
    if(nCnt==LB_ERR)return -1;
    String TN;
    if(pTypeName)
        TN=pTypeName;
    for(int i=0;i<nCnt;i++)
    {
        if(LBGetItemTypeName(hCtrl,i)==TN)
            return i;
    }
    return -1;
}

BOOL CAddDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    m_pCore->UpdateType();
    Update();
    return TRUE;
}

void CAddDlg::Update()
{
    if(m_bBlockUpdate)return;//Some actions may send notify messages which then Update and overflow stack.
    CUpdate U(&m_bBlockUpdate);

    if(!m_hWnd)return;
//Update device list.    
    int nSelDev=-1;
    String TypeName;
    
    HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
    if(hListCtrl)
    {
        int nTopIndex=ListBox_GetTopIndex(hListCtrl);
        nSelDev=LBGetCurSel(hListCtrl);
        LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);
        if(pTypeName)TypeName=pTypeName;

        SetWindowRedraw(hListCtrl,FALSE);
        ListBox_ResetContent(hListCtrl);
        m_ListCtrl.clear();//Must be behind ListBox_ResetContent
        for(LISTGPRTDEV::iterator It=m_pCore->m_GprtDev.begin();
                It!=m_pCore->m_GprtDev.end();It++)
        {
            String S=It->TypeName();
            m_ListCtrl.push_back(S);
            int nIndex=ListBox_AddString(hListCtrl,It->Name());
            ListBox_SetItemData(hListCtrl,nIndex,&m_ListCtrl.back());
        }

        nSelDev=LBFindTypeNameIndex(hListCtrl,TypeName.data());
        if(nSelDev>=0)
            ListBox_SetCurSel(hListCtrl,nSelDev);
        else
            ListBox_SetCurSel(hListCtrl,0);
        
        ListBox_SetTopIndex(hListCtrl,nTopIndex);
        SetWindowRedraw(hListCtrl,TRUE);
        InvalidateRect(hListCtrl,NULL,TRUE);

        nSelDev=LBGetCurSel(hListCtrl);
    }

    HWND hRudder=HDlgItem(IDC_JOY1HASRUDDER);
    if(hRudder)
    {
        BOOL bE=FALSE;
        if(nSelDev>=0)
        {
            LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);
            if(pTypeName)
            {
                LISTGPRTDEV::iterator It;
                It=find(m_pCore->m_GprtDev.begin(),m_pCore->m_GprtDev.end(),pTypeName);
                if(It!=m_pCore->m_GprtDev.end())
                    bE=It->Rudder()?FALSE:TRUE;
            }
        }
        EnableWindow(hRudder,bE);
    }    

//Update gameport list.
    nSelDev=-1;
    TypeName;
    
    HWND hListCtrlTitle=HDlgItem(IDC_GAMEPORT);
    hListCtrl=HDlgItem(IDC_GAMEPORTLIST);
    if(hListCtrl&&hListCtrlTitle)
    {
        SetWindowRedraw(hListCtrl,FALSE);
        SetWindowPos(hListCtrl,NULL,NULL,NULL,NULL,NULL,
            SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_HIDEWINDOW);

        //How many gameports. Gameport list only if more than 1.
        if(m_pCore->m_GprtBus.size()>1)
        {
            ShowWindow(hListCtrlTitle,SW_SHOWNA);

            nSelDev=CBGetCurSel(hListCtrl);
            LPCTSTR pTypeName=CBGetItemTypeName(hListCtrl,nSelDev);
            if(pTypeName)TypeName=pTypeName;

            ComboBox_ResetContent(hListCtrl);
            m_GprtListCtrl.clear();//Must be behind ComboBox_ResetContent
            for(LISTGPRTDEV::iterator It=m_pCore->m_GprtBus.begin();
                    It!=m_pCore->m_GprtBus.end();It++)
            {
                String S=It->TypeName();
                m_GprtListCtrl.push_back(S);
                int nIndex=ComboBox_AddString(hListCtrl,It->Name());
                ComboBox_SetItemData(hListCtrl,nIndex,&m_GprtListCtrl.back());
            }

            nSelDev=CBFindTypeNameIndex(hListCtrl,TypeName.data());
            if(nSelDev>=0)
                ComboBox_SetCurSel(hListCtrl,nSelDev);
            else
                ComboBox_SetCurSel(hListCtrl,0);
            SetWindowPos(hListCtrl,NULL,NULL,NULL,NULL,NULL,
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
        }
        else
        {
            ShowWindow(hListCtrlTitle,SW_HIDE);
        }
        SetWindowRedraw(hListCtrl,TRUE);
        InvalidateRect(hListCtrl,NULL,TRUE);
    }

    HWND hCustomBtn=HDlgItem(IDC_CUSTOM);
    if(hCustomBtn)
    {
        BOOL bE=(m_pCore->m_GprtDev.size()<MAX_DEVICES)?TRUE:FALSE;
        EnableWindow(hCustomBtn,bE);
    }
}

void CAddDlg::AddDev()
{
    HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
    HWND hRudder=HDlgItem(IDC_JOY1HASRUDDER);
    if(hListCtrl&&hRudder)
    {
        int nSelDev=LBGetCurSel(hListCtrl);
        LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);

        HWND hListCtrlGprt=HDlgItem(IDC_GAMEPORTLIST);
        nSelDev=CBGetCurSel(hListCtrlGprt);
        LPCTSTR pGprtTypeName=CBGetItemTypeName(hListCtrlGprt,nSelDev);
        if(!pGprtTypeName)
        {
            pGprtTypeName=m_pCore->m_GprtBus.front().TypeName();
        }
        if(pTypeName&&pGprtTypeName)
        {
            GUID GOccupied=NULLGUID;
            HRESULT hRes=m_pCore->AddDevice(pTypeName,Button_GetCheck(hRudder)?true:false,pGprtTypeName,GOccupied);
            if(!SUCCEEDED(hRes))
            switch(hRes)
            {
            case E_FAIL:
                break;
            case E_ACCESSDENIED:
                if(GOccupied!=NULLGUID)
                {
                //Find device which occupies the port.
                    for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();It!=m_pCore->m_ListDIDev.end();It++)
                    {
                        if(It->PortGUID()==GOccupied)
                        {
                            TCHAR Title[128];
                            LoadString(m_hModule,IDS_ADD_PORT_OCCUPIED, Title, cA(Title));

                            TCHAR Msg[256];
                            LoadString(m_hModule,IDS_ADD_PORT_MSGFORMAT, Msg, cA(Msg));
                            //Get gameport name.
                            LPCTSTR pBus=_T(" ");
                            LISTGPRTDEV::iterator It;
                            It=find(m_pCore->m_GprtBus.begin(),m_pCore->m_GprtBus.end(),pGprtTypeName);
                            if(It!=m_pCore->m_GprtBus.end())
                                pBus=It->Name();
                            //Get device name.
                            LPCTSTR pDev=_T(" ");
                            LISTDIDEV::iterator ItDN;
                            for(ItDN=m_pCore->m_ListDIDev.begin();ItDN!=m_pCore->m_ListDIDev.end();ItDN++)
                                if(ItDN->PortGUID()==GOccupied)break;
                            if(ItDN!=m_pCore->m_ListDIDev.end())
                                pDev=ItDN->InstName();

                            LPTSTR pT = Insert2Strings(Msg,pDev,pBus);
                            lstrcpy(Msg, pT);
                            delete[] pT;
                            
                            UINT uRTL = (GetWindowLongPtr(m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
                            MessageBox(m_hWnd,Msg,Title,MB_ICONHAND|MB_OK|MB_APPLMODAL|uRTL);
                            break;
                        }
                    }
                }
                break;
            case DIERR_DEVICEFULL:
                MessageBox(m_hWnd,m_hModule,IDS_GAMEPORT_OCCUPIED_TITLE,IDS_GAMEPORT_OCCUPIED);
                break;
            case DIERR_NOTFOUND:
                MessageBox(m_hWnd,m_hModule,IDS_NO_IDS_TITLE,IDS_NO_IDS);
                break;
            case DIERR_DEVICENOTREG:
                MessageBox(m_hWnd,m_hModule,IDS_NO_GAMENUM_TITLE,IDS_NO_GAMENUM);
                break;
            }
        }
    }
    EndDialog(m_hWnd,IDOK);
}

INT_PTR CAddDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        AddDev();
        return 0;
    case IDC_CUSTOM:
        {
            CCustomDlg CustomDlg(m_pCore);
            if(CustomDlg.Dlg(IDD_CUSTOM,m_hModule,m_hWnd)==IDOK)
            {
                Update();
                //Now select new custom device in this dialog box.
                HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
                if(hListCtrl)
                {
                    int nSelDev=LBFindTypeNameIndex(hListCtrl,CustomDlg.GetVIDPIDName());
                    if(nSelDev>=0)
                    {
                        ListBox_SetCurSel(hListCtrl,nSelDev);
                    }
                }
            }
        }
        return 0;
    case IDC_DEVICE_LIST:
        switch(wNotifyCode)
        {
        case LBN_DBLCLK:
            AddDev();
            return 0;
        case LBN_SELCHANGE:
            Update();
            return 0;
        }
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
}

INT_PTR CAddDlg::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_VKEYTOITEM:
        if(LOWORD(wParam)==VK_DELETE)
        {
            HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
            if(hListCtrl)
            {
                int nSelDev=LBGetCurSel(hListCtrl);
                LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);
                if(pTypeName)
                {
                    if(m_pCore->IsCustomDevice(pTypeName))
                    {
                        if(!m_pCore->IsDeviceActive(pTypeName))
                        {
                            CGprtDev *pDev=m_pCore->FindGprtDev(pTypeName);
                            if(!pDev) {
                                //This should never happend, but just in case.
                                throw JOY_EXCEPTION(E_FAIL);
                            }

                            TCHAR S[128];
                            LoadString(m_hModule,IDS_GEN_AREYOUSURE, S, cA(S));
                            LPTSTR pT = Insert1String(S,pDev->Name());
                            lstrcpy(S, pT);
                            delete[] pT;

                            TCHAR Title[128];
                            LoadString(m_hModule,IDS_GEN_AREYOUSURE_TITLE, Title, cA(Title));

                            UINT uRTL = (GetWindowLongPtr(m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
                            if(MessageBox(m_hWnd,S,Title,
                                MB_ICONQUESTION|MB_YESNO|MB_APPLMODAL|uRTL)==IDYES)
                            {
                                m_pCore->DeleteType(pTypeName);
                            }
                        }
                        else
                        {
                            MessageBox(m_hWnd,m_hModule,IDS_GEN_AREYOUSURE_TITLE,IDS_NO_REMOVE);
                        }
                    }
                }
            }
        }
        else return -1;
        return 0;
    }
    return CDlg::DialogProc(uMsg,wParam,lParam);
}

/******************************************************************************
Custom dialog
******************************************************************************/

#define MAX_ANALOG_BUTTONS 4
#define MIN_ANALOG_AXIS    2
#define MAX_ANALOG_AXIS    4
#define MAX_STR_LEN 255

BOOL CCustomDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    if(!m_pCore->IsAvailableVIDPID(m_VIDPIDName))
    {
        MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_NOAVAILABLEVIDPID);
        EndDialog(m_hWnd,IDCANCEL);
        return TRUE;
    }
    HWND hButtons=HDlgItem(IDC_COMBO_BUTTONS);
    if(hButtons)
    {
        for(int i=0;i<=MAX_ANALOG_BUTTONS;i++)
        {
            TCHAR Str[32];
            _sntprintf(Str,32,_T("%d"),i);
            Str[31]=0;
            ComboBox_InsertString(hButtons,i,Str);
        }
        ComboBox_SetCurSel(hButtons,MAX_ANALOG_BUTTONS);
    }
    HWND hAxis=HDlgItem(IDC_COMBO_AXIS);
    if(hAxis)
    {
        for(int i=MIN_ANALOG_AXIS;i<=MAX_ANALOG_AXIS;i++)
        {
            TCHAR Str[32];
            _sntprintf(Str,32,_T("%d"),i);
            Str[31]=0;
            ComboBox_InsertString(hAxis,i-MIN_ANALOG_AXIS,Str);
        }
        ComboBox_SetCurSel(hAxis,0);
    }
    HWND hSpecJoy=HDlgItem(IDC_SPECIAL_JOYSTICK);
    if(hSpecJoy)
        Button_SetCheck(hSpecJoy,BST_CHECKED);
    HWND hEdit=HDlgItem(IDC_EDIT_NAME);
    if(hEdit)
        Edit_LimitText(hEdit,MAX_STR_LEN);
    HWND hHasZAxis=HDlgItem(IDC_HASZAXIS);
    if(hHasZAxis)
        Button_SetCheck(hHasZAxis,BST_CHECKED);

    return TRUE;
}

INT_PTR CCustomDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        {
            HWND hJoy=HDlgItem(IDC_SPECIAL_JOYSTICK);
            HWND hYoke=HDlgItem(IDC_SPECIAL_YOKE);
            HWND hPad=HDlgItem(IDC_SPECIAL_PAD);
            HWND hCar=HDlgItem(IDC_SPECIAL_AUTO);
            HWND hAxis=HDlgItem(IDC_COMBO_AXIS);
            HWND hRudder=HDlgItem(IDC_HASRUDDER);
            HWND hZAxis=HDlgItem(IDC_HASZAXIS);
            HWND hButtons=HDlgItem(IDC_COMBO_BUTTONS);
            HWND hPov=HDlgItem(IDS_CUSTOM_HASPOV);
            HWND hEdit=HDlgItem(IDC_EDIT_NAME);
            if(hJoy&&
                hYoke&&
                hPad&&
                hCar&&
                hAxis&&
                hRudder&&
                hZAxis&&
                hButtons&&
                hPov&&
                hEdit)//Possible internal error.
            {
                TCHAR *pStr=NULL;
                bool bErr=false;

                int nLen=Edit_LineLength(hEdit,0);//Possible internal error.
                if(!nLen)
                {
                    bErr=true;
                    MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_NO_NAME);
                }
                else
                {
                    pStr=new TCHAR[nLen+1];
                    if (pStr == NULL)
                        return 0; //Internal error
                    if(GetDlgItemText(m_hWnd,IDC_EDIT_NAME,pStr,nLen+1)!=nLen)
                        return 0;//Internal error.
                    if(_tcschr(pStr,_T('\\')))
                    {
                        bErr=true;
                        MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_INVALID_NAME);
                    }
                    else
                    {
                        if(m_pCore->DuplicateDeviceName(pStr))
                        {
                            bErr=true;
                            MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_DUPLICATE_TYPE);
                        }
                    }
                }
                
                if(bErr)//User entered invalid text for name.
                {
                    SetFocus(m_hWnd);
                    SetFocus(hEdit);
                    Edit_SetSel(hEdit,0,-1);
                    return 0;
                }

                m_pCore->AddCustomDevice(
                    (Button_GetCheck(hJoy)==BST_CHECKED)?true:false,
                    (Button_GetCheck(hPad)==BST_CHECKED)?true:false,
                    (Button_GetCheck(hYoke)==BST_CHECKED)?true:false,
                    (Button_GetCheck(hCar)==BST_CHECKED)?true:false,
                    ComboBox_GetCurSel(hAxis)+MIN_ANALOG_AXIS,
                    (Button_GetCheck(hZAxis)==BST_CHECKED)?true:false,
                    ComboBox_GetCurSel(hButtons),
                    (Button_GetCheck(hPov)==BST_CHECKED)?true:false,
                    pStr,
                    m_VIDPIDName.data());

                if( pStr ) {
                    delete[] pStr;
                }
            }
        }
        EndDialog(m_hWnd,IDOK);
        return 0;
    case IDC_COMBO_AXIS:
        if(wNotifyCode==CBN_SELCHANGE)
        {
            HWND hAxis=HDlgItem(IDC_COMBO_AXIS);
            if(hAxis)
            {
                UINT uShow=SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER;
                if((ComboBox_GetCurSel(hAxis)+MIN_ANALOG_AXIS)==3)//If 3 axis selected.
                    uShow|=SWP_SHOWWINDOW;
                else
                    uShow|=SWP_HIDEWINDOW;
                
                HWND hHasZAxis=HDlgItem(IDC_HASZAXIS);
                if(hHasZAxis)
                {
                    SetWindowPos(hHasZAxis,NULL,NULL,NULL,NULL,NULL,uShow);
                }
                HWND hHasRudder=HDlgItem(IDC_HASRUDDER);
                if(hHasRudder)
                {
                    SetWindowPos(hHasRudder,NULL,NULL,NULL,NULL,NULL,uShow);
                }
            }
        }
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
}

/******************************************************************************
Preferred dialog
******************************************************************************/

void CPreferredDlg::Preferred()
{
    HWND hListCtrl=HDlgItem(IDC_CHANGE_LIST);
    if(hListCtrl)
    {
        int nSelDev=CBGetCurSel(hListCtrl);
        GUID SelGUID=CBGetItemGUID(hListCtrl,nSelDev);
        if(SelGUID!=NULLGUID)
            m_pCore->Preferred(SelGUID);
    }
    EndDialog(m_hWnd,IDOK);
}

INT_PTR CPreferredDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        Preferred();
        return 0;
    }
    if(wNotifyCode==CBN_CLOSEUP)
    {
        Update();
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
}

BOOL CPreferredDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    Update();
    HWND hListCtrl=HDlgItem(IDC_CHANGE_LIST);
    if(hListCtrl)
    {
        for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();
                It!=m_pCore->m_ListDIDev.end();It++)
        {
            if(It->Id()==0)
            {
                int nSelDev=CBFindGUIDIndex(hListCtrl,It->InstGUID());
                if(nSelDev>=0)
                    ComboBox_SetCurSel(hListCtrl,nSelDev);
                break;
            }
        }
    }
    return TRUE;
}

void CPreferredDlg::Update()
{
    if(m_bBlockUpdate)return;//Some actions may send notify messages which then Update and overflow stack.
    CUpdate U(&m_bBlockUpdate);

    if(!m_hWnd)return;
    
    int nSelDev=-1;
    GUID SelGUID=NULLGUID;
    
    HWND hListCtrl=HDlgItem(IDC_CHANGE_LIST);
    if(hListCtrl)
    {
        if(ComboBox_GetDroppedState(hListCtrl))return;//No update when selecting preferred.

        int nCount=CBGetCnt(hListCtrl);
        nSelDev=CBGetCurSel(hListCtrl);
        SelGUID=CBGetItemGUID(hListCtrl,nSelDev);

        SetWindowRedraw(hListCtrl,FALSE);
        ComboBox_ResetContent(hListCtrl);
        m_ListCtrl.clear();//Must be behind ComboBox_ResetContent.
        int nId0Index=-1;//Index of preferred device.
        for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();
                It!=m_pCore->m_ListDIDev.end();It++)
        {
            GUID G=It->InstGUID();
            m_ListCtrl.push_back(G);
            int nIndex=ComboBox_AddString(hListCtrl,It->InstName());
            ComboBox_SetItemData(hListCtrl,nIndex,&m_ListCtrl.back());
            if(It->Id()==0)
                nId0Index=nIndex;                
        }
        
        int nNoneIndex=-1;
        if(nId0Index<0)//Only if there is no preferred device.
        {
            TCHAR None[256];
            LoadString(m_hModule,IDS_NONE, None, cA(None));
            nNoneIndex=ComboBox_AddString(hListCtrl,None);
        }

        if((!nCount)||//First update during init.
            (SelGUID==NULLGUID))//Or none is selected.
        {
            if(nId0Index>=0)//Preferred device was added.
                ComboBox_SetCurSel(hListCtrl,nId0Index);
            else//There is no preferred device.
                ComboBox_SetCurSel(hListCtrl,nNoneIndex);
        }
        else//List was not empty before update. Select same thing.
        {
            nSelDev=CBFindGUIDIndex(hListCtrl,SelGUID);
            if(nSelDev>=0)
                ComboBox_SetCurSel(hListCtrl,nSelDev);
            else//Selected device removed.
            {
                if(nId0Index>=0)//Then select original preferred device.
                    ComboBox_SetCurSel(hListCtrl,nId0Index);
                else//Select none.
                    ComboBox_SetCurSel(hListCtrl,nNoneIndex);
            }
        }
        
        SetWindowRedraw(hListCtrl,TRUE);
        InvalidateRect(hListCtrl,NULL,TRUE);
    }
}

INT_PTR CPreferredDlg::Notify(int idCtrl,LPNMHDR pnmh)
{
//    switch(pnmh->code)
//    {
    /*case LVN_KEYDOWN:
        switch(((LV_KEYDOWN*)pnmh)->wVKey)
        {
        case VK_F5:
            CoreUpdate();
            return 0;
        }
        return 0;
    case LVN_ITEMCHANGED:
        Update();
        return 0;*/
/*    case NM_DBLCLK:
        switch(pnmh->idFrom)
        {
        case IDC_CHANGE_LIST:
            Preferred();
            return 0;
        }
        return 0;*/
//    }
    return 0;
}

/******************************************************************************
Connect UI and core
******************************************************************************/

class CCP:public CCore,public CMainDlg
{
    virtual void UIUpdate(){CMainDlg::Update();};
public:
    CCP(){ConnectUI((CCore*)this);};
};

/******************************************************************************
Entry point.
******************************************************************************/

#define MUTEX_NAME  _T("$$$MS_GameControllers_Cpl$$$")

void Core(HANDLE  hModule,HWND hWnd)
{
    static HWND hPrevHwnd=NULL;
    static HANDLE hMutex=CreateMutex(NULL,TRUE,MUTEX_NAME);

    if(GetLastError()==ERROR_ALREADY_EXISTS)
    {
        SetForegroundWindow(hPrevHwnd); 
    }
    else
    {
        hPrevHwnd=hWnd;
    
        _PNH _old_handler;
        _old_handler = _set_new_handler(my_new_handler);

        if( SHFusionInitializeFromModuleID((HMODULE)hModule,124) )
        {
            // While not initializing would only cause theming to be inactive, 
            // a failure to initialize indicates a much worse problem so since 
            // PREFIX warns (656863) that the return needs to be tested, abort 
            // if the initialization fails.
            try
            {
                CCP CP;
                CP.Dlg(IDD_CPANEL,(HMODULE)hModule,hWnd);
            }
            catch(JoyException E)
            {
            }
            catch(exception)
            {
            }
            SHFusionUninitialize();
        }

        _set_new_handler(_old_handler);

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }
}

/******************************************************************************
Propertiy
******************************************************************************/

class CoInit
{
    HRESULT m_hRes;
public:
    ~CoInit()
    {
        if(SUCCEEDED(m_hRes))
        {
            CoFreeUnusedLibraries();//Free gcdef.dll.
            CoUninitialize();
        }
    };
    CoInit(){m_hRes=CoInitialize(NULL);};
    operator HRESULT(){return m_hRes;};
};
typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;
typedef AutoDeleteArray<LPHPROPSHEETPAGE> LPHPROPSHEETPAGE_ADAR;

//FUN! FUN! FUN! FUN!
//This is certain funny code written by some other, quite funny people,
//so I will put it in the funny code section at the end of the otherwise
//serious file.

//tmarkoc cleaned it up. No more memory/interface/freelib leaks, alloc failures handled, no unneccessary allocations.

/*
#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif
//WHAT IS THIS FOR????????????????????????????????????????????????????????
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
        private:
                DWORD                           m_cProperty_refcount;
                
        public:
                CDIGameCntrlPropSheet(void);
                ~CDIGameCntrlPropSheet(void);
                
                // IUnknown methods
            STDMETHODIMP            QueryInterface(REFIID, PPVOID);
            STDMETHODIMP_(ULONG)    AddRef(void);
            STDMETHODIMP_(ULONG)    Release(void);
                
                // CImpIServerProperty methods
                STDMETHODIMP                    GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
                STDMETHODIMP                    GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
                STDMETHODIMP                    SetID(USHORT nID);
            STDMETHODIMP_(USHORT)   GetID(void);
};*/
//typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;
typedef IDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;

typedef AutoRelease<LPCDIGAMECNTRLPROPSHEET> LPCDIGAMECNTRLPROPSHEET_AR;

HRESULT Properties(HMODULE hMod,HWND hWnd,CCore *pCore,DWORD dwId)
{
//    ASSERT(IsWindow(hWnd));

    CLSID clsidPropSheet=CLSID_LegacyServer;
    
    //Get type name.
    DIJOYCONFIG DIJoyCfg;
    ZeroMemory(&DIJoyCfg,sizeof(DIJoyCfg));
    DIJoyCfg.dwSize=sizeof(DIJoyCfg);
    if(SUCCEEDED(pCore->m_pDIJoyCfg->GetConfig(dwId,&DIJoyCfg,DIJC_REGHWCONFIGTYPE|DIJC_CALLOUT)))
    {
        //Get the clsidConfig.
        DIJOYTYPEINFO DIJoyType;
        ZeroMemory(&DIJoyType,sizeof(DIJoyType));
        DIJoyType.dwSize=sizeof(DIJoyType);
        if(SUCCEEDED(pCore->m_pDIJoyCfg->GetTypeInfo(DIJoyCfg.wszType,&DIJoyType,DITC_CLSIDCONFIG|DITC_REGHWSETTINGS|DITC_FLAGS1)))
        {
            if((DIJoyType.clsidConfig!=GUID_NULL)&&
                !(DIJoyType.dwFlags1&JOYTYPE_DEFAULTPROPSHEET))
                    clsidPropSheet=DIJoyType.clsidConfig;
        }
    }
    int nStartPage=(clsidPropSheet==CLSID_LegacyServer)?1:0;

    if(nStartPage>MAX_PAGES)
        return(DIGCERR_STARTPAGETOOLARGE);

    CoInit CI;//CoInitialize(NULL); Auto CoFreeUnusedLibraries();CoUninitialize();.
    LPCDIGAMECNTRLPROPSHEET_AR fnInterface;
    if(SUCCEEDED(CI))
    {
        IClassFactory* pCF;
        if(SUCCEEDED(CoGetClassObject(clsidPropSheet,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(LPVOID*)&pCF)))
        {
            pCF->CreateInstance(NULL,IID_IDIGameCntrlPropSheet,(LPVOID*)&fnInterface);
            pCF->Release();
        }
        else
        { 
            //reset to legacy server
            clsidPropSheet=CLSID_LegacyServer;
            nStartPage=1;
            if(SUCCEEDED(CoGetClassObject(clsidPropSheet,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(LPVOID*)&pCF)))
            {
                pCF->CreateInstance(NULL,IID_IDIGameCntrlPropSheet,(LPVOID*)&fnInterface);
                pCF->Release();
            }
        }
    }
    if(*((PVOID *)&fnInterface) == NULL)
    {
        return(E_NOINTERFACE);
    }
    //Send device Id to the property sheet.
    fnInterface->SetID(dwId);

    LPDIGCSHEETINFO pServerSheet=NULL;
    //Get the property sheet info from the server.
    if(FAILED(fnInterface->GetSheetInfo(&pServerSheet)))
    {
        return(E_FAIL);
    }
    //Verify data from server.
    if(pServerSheet->nNumPages==0)
        return(DIGCERR_NUMPAGESZERO);
    else if((pServerSheet->nNumPages>MAX_PAGES)||(pServerSheet->nNumPages<nStartPage))
        return(DIGCERR_NUMPAGESTOOLARGE);

    LPDIGCPAGEINFO pServerPage=NULL;
    //Get the information for all the pages from the server.
    if(FAILED(fnInterface->GetPageInfo(&pServerPage)))
    {
        return(E_FAIL);
    }

    // Allocate memory for the pages.
    LPHPROPSHEETPAGE_ADAR pPages=new HPROPSHEETPAGE[pServerSheet->nNumPages];
    if(*((PVOID *)&pPages) == NULL) return(E_OUTOFMEMORY);
    ZeroMemory((LPHPROPSHEETPAGE)pPages,sizeof(HPROPSHEETPAGE)*pServerSheet->nNumPages);

    // Allocate memory for the header!
    PROPSHEETHEADER SH;
    ZeroMemory(&SH,sizeof(SH));
    SH.dwSize=sizeof(SH);
    SH.hwndParent= hWnd;
    SH.hInstance=pServerPage[0].hInstance;
    if(pServerSheet->fSheetIconFlag)
    {
        if(pServerSheet->lpwszSheetIcon)
        {
            //Check to see if you are an INT or a WSTR.
            if(HIWORD((INT_PTR)pServerSheet->lpwszSheetIcon))
            {
                //You are a string.
                SH.pszIcon=pServerSheet->lpwszSheetIcon;
            }
            else
                SH.pszIcon=(LPCTSTR)(pServerSheet->lpwszSheetIcon);
            SH.dwFlags=PSH_USEICONID;
        }
        else return(DIGCERR_NOICON);
    }

    //Do we have a sheet caption?
    if(pServerSheet->lpwszSheetCaption)
    {
        SH.pszCaption=pServerSheet->lpwszSheetCaption;
        SH.dwFlags|=PSH_PROPTITLE;
    }

    SH.nPages=pServerSheet->nNumPages;  
    SH.nStartPage=nStartPage;

    //Set the property pages inofrmation into the header.
    SH.phpage=(LPHPROPSHEETPAGE)pPages;


    //Sheet stuff is done.Now do the pages.
    PROPSHEETPAGE PropPage;
    ZeroMemory(&PropPage,sizeof(PropPage));
    PropPage.dwSize=sizeof(PropPage);

    //Fill up each page.
    int nIndex=0;
    do
    {
        //Assign the things that there are not questionable.
        PropPage.lParam=pServerPage[nIndex].lParam;
        PropPage.hInstance=pServerPage[nIndex].hInstance;

        // Add the title.
        if(pServerPage[nIndex].lpwszPageTitle)
        {
            PropPage.dwFlags=PSP_USETITLE; 
            //Check to see if you are a string.
            if(HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageTitle))
            {
                PropPage.pszTitle=pServerPage[nIndex].lpwszPageTitle;
            }
            else
                PropPage.pszTitle=(LPTSTR)pServerPage[nIndex].lpwszPageTitle;
        }
        else PropPage.pszTitle=NULL;

        //If icon is required go ahead and add it.
        if(pServerPage[nIndex].fIconFlag)
        {
            PropPage.dwFlags|=PSP_USEICONID;
            //Check to see if you are an INT or a String.
            if(HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageIcon))
            {
                //You're a string.
                PropPage.pszIcon=pServerPage[nIndex].lpwszPageIcon;
            }
            else
                PropPage.pszIcon=(LPCTSTR)(pServerPage[nIndex].lpwszPageIcon);
        }

        //If a pre - post processing call back proc is required go ahead and add it.
        if(pServerPage[nIndex].fProcFlag)
        {
            if(pServerPage[nIndex].fpPrePostProc)
            {
                PropPage.dwFlags|=PSP_USECALLBACK;
                PropPage.pfnCallback=(LPFNPSPCALLBACK)pServerPage[nIndex].fpPrePostProc;
            }
            else 
                return(DIGCERR_NOPREPOSTPROC);
        }

        //And the essential "dialog" proc.
        if(pServerPage[nIndex].fpPageProc)
            PropPage.pfnDlgProc=pServerPage[nIndex].fpPageProc;
        else
            return(DIGCERR_NODLGPROC);

        //Assign the dialog template.
        if(HIWORD((INT_PTR)pServerPage[nIndex].lpwszTemplate))
        {
            PropPage.pszTemplate=pServerPage[nIndex].lpwszTemplate;
        }
        else
            PropPage.pszTemplate=(LPTSTR)pServerPage[nIndex].lpwszTemplate;

        if(clsidPropSheet!=CLSID_LegacyServer)//If third party software do not enforce theme.
            ((LPHPROPSHEETPAGE)pPages)[nIndex++]=SHNoFusionCreatePropertySheetPageW(&PropPage);
        else
            ((LPHPROPSHEETPAGE)pPages)[nIndex++]=CreatePropertySheetPage(&PropPage);
    }   
    while(nIndex<pServerSheet->nNumPages);

    //Launch modal property sheet dialog.
    PropertySheet(&SH);

    pCore->Update();

    return(S_OK);
}

#undef cA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\joyarray.h ===
#include "joyhelp.h"
#include "resource.h"

const DWORD gaHelpIDs[]=
{
    IDC_BTN_PROPERTIES,     IDH_101_1002,   // Game Controllers: "&Properties..." (Button)
    IDC_BTN_TSHOOT,         IDH_101_1036,   // Trouble Shoot Button
    IDC_LIST_DEVICE,        IDH_101_1058,   // Game Controllers: "List1" (SysListView32)
    IDC_LIST_HEADING,       IDH_101_1058,   // Game Controllers: "&Game Controllers" (Static)
    IDC_BTN_REMOVE,         IDH_101_1028,   // Game Controllers: "&Remove..." (Button)
    IDC_BTN_ADD,            IDH_101_1010,   // Game Controllers: "A&dd..." (Button)
    IDC_BTN_REFRESH,        IDH_101_1022,   // Game Controllers: "Refresh" (Button)
    IDC_BTN_ADV,            IDH_101_1311,   // Game Controllers: "A&dvanced" (Button)
    IDC_POLLFLAGS,          IDH_117_1100,   // -: "P&oll with interrupts enabled" (Button)
    IDC_COMBO1,             IDH_117_1101,   // -: "" (ComboBox)
    IDC_TEXT_PORTDRIVER,    IDH_117_1101,   // -: "&Port Driver:" (Static)
    IDC_GAMEPORT,           IDH_117_1101,   // 
    IDC_GAMEPORTLIST,       IDH_117_1101,   // 
    IDC_ADV_LIST_DEVICE,    IDH_117_8197,   // -: "" (ListBox)
    IDC_ADV_CHANGE,         IDH_117_8198,   // -: "Cha&nge..." (Button)
    IDC_ADV_USEOEMPAGE,     IDH_117_8199,   // Advanced: OEM property sheet check box
    IDC_ADD_NEW,            IDH_119_1039,   // Add Game Controller: "&Add Other..." (Button)
    IDC_CUSTOM,             IDH_119_1049,   // Add's Custom button!
    IDC_DEVICE_LIST_TAG,    IDH_119_1059,   // Add Game Controller: "&Controllers:" (Static)
    IDC_DEVICE_LIST,        IDH_119_1059,   // Add Game Controller: "List1" (SysListView32)
    IDC_COMBO_AXIS,         IDH_4099_1043,  // Custom Game Controller: "" (ComboBox)
    IDC_HASRUDDER,          IDH_4099_1044,  // Rudder checkbox from Custom Page
    IDC_COMBO_BUTTONS,      IDH_4099_1045,  // Custom Game Controller: "" (ComboBox)
    IDC_HASZAXIS,           IDH_4099_1046,  // Z Axis checkbox from Custom Page
    IDC_SPECIAL_YOKE,       IDH_4099_1051,  // Custom Game Controller: "Is a flight yoke/stick" (Button)
    IDC_SPECIAL_PAD,        IDH_4099_1052,  // Custom Game Controller: "Is a game pad" (Button)
    IDC_SPECIAL_AUTO,       IDH_4099_1053,  // Custom Game Controller: "Is a race car controller" (Button)
    IDS_CUSTOM_HASPOV,      IDH_4099_1054,  // Custom Game Controller: "Has a &point of view control" (Button)
    IDC_CUSTOM_NAME,        IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_EDIT_NAME,          IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_SPECIAL_JOYSTICK,   IDH_4099_1058,  // Custom Game Controller: "Is a Joystick" (Button)
    IDC_JOY1HASRUDDER,      IDH_4201_1019,  // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
    IDC_SPIN,               IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SPINBUDDY,          IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SELECTEDID,         IDH_8188_8191,  // Change Controller Assignment: "Selected ID" (ListBox)
    IDC_CHANGE_LIST,        IDH_8188_8194,  // Change Controller Assignment: "" (ListBox)
    IDC_LISTTXT,            IDH_8188_8194,
    IDC_ADV_GRP,            (DWORD)-1,
    IDC_ADV_GRP2,           (DWORD)-1,
    IDC_TEXT_DRIVER,        (DWORD)-1,
    IDC_ADD_STR1,           (DWORD)-1,
    IDC_ADD_STR2,           (DWORD)-1,
    IDC_GEN_ICON,           (DWORD)-1,
    IDC_GEN_INTRO,          (DWORD)-1,
    IDC_ASSIGNTXT,          (DWORD)-1,
    IDC_TEXT_TITLE,         (DWORD)-1,
    IDC_SEPERATOR,          (DWORD)-1,
    IDC_AXES_GROUP,         (DWORD)-1,  // Custom Game Controller: "&Axes" (Button)
    IDC_BUTTONS_GROUP,      (DWORD)-1,  // Custom Game Controller: "" (ComboBox)
    IDC_SPECIAL_GROUP,      (DWORD)-1,  // Custom Game Controller: "&Special Characteristics" (Button)

    IDC_VOICECHATGROUP,	    (DWORD)-1,
    IDC_VOICECHATTEXT,      (DWORD)-1,
    IDC_GAMESLISTHOTKEY,    (DWORD)-1,

    IDC_LIST_GAMES,         IDH_VOICE_LIST_GAMES,
    IDC_DETAILS,            IDH_VOICE_DETAILS,
	
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\guids.c ===
/*****************************************************************************
 *
 *  guids.c
 *
 *  Copyright (c) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *****************************************************************************/

#include <windows.h>
#include <initguid.h>
#include <gameport.h>
#include <dinput.h>
#include <dinputd.h>
#include "ifacesvr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\joyhelp.h ===
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "&Add..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1036    67548653    // Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)
#define IDH_101_1311    65667174    // Game Controllers: "A&dvanced" (Button)

#define IDH_117_1100    72089717    // -: "P&oll with interrupts enabled" (Button)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_117_8199    537385268   // Advanced: OEM property sheet check box

#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)

#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044   68358149    // Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046   68358151    // Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4099_1058   69410157    // Custom Game Controller: "Is a Joystick" (Button)

#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)

#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)

#define IDH_APPMAN_EXCLUDEDRIVE_INSTRUCTIONS		    2768L
#define IDH_APPMAN_RESTOREDEFAULTS_INSTRUCTIONS		  2767L
#define IDH_APPMAN_DISKUSAGE_SETTING_INSTRUCTIONS   2766L
#define IDH_VOICE_LIST_GAMES						            2765L
#define IDH_VOICE_DETAILS							              2764L

/*
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "A&dd..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1048   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1050   68816899    // Custom Game Controller: "&Special Characteristics" (Button)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4101_12293  805638149   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12308  806621189   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12309  806686725   // Joystick Calibration: "f" (Static)
#define IDH_4101_12328  807931909   // Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329  807997445   // Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330  808062981   // Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12331  808062983   // Joystick Calibration: "&Finish" (Button)
#define IDH_4101_12334  808325125   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12347  809177093   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12349  809308165   // Joystick Calibration: "" (ListBox)
#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291  805507177   // Settings: "&Calibrate..." (Button)
#define IDH_4202_12293  805638250   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308  806621290   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328  807932010   // Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12334  808325226   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_8199   537333866   // Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4203_1023   67047531    // -: "Buttons" (Button)
#define IDH_4203_12293  805638251   // -: "" (ListBox)
#define IDH_4203_12308  806621291   // -: "" (ListBox)
#define IDH_4203_12309  806686827   // -: "" (POVHAT)
#define IDH_4203_12334  808325227   // -: "" (ListBox)
#define IDH_4203_12347  809177195   // -: "" (ListBox)
#define IDH_4203_12349  809308267   // -: "" (ListBox)
#define IDH_4203_12350  809308265   // -: "" (Listbox--Slider 1)
#define IDH_4203_12351  809308269   // -: "" (Listbox--Slider 2)
#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)
#define IDH_4099_1046   68358149    // 
#define IDH_4099_1044   68358151    //
#define IDH_101_1036    67548653    //
#define IDH_4099_1058   69410157    //
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\res\dijoy.h ===
#define IDH_101_1002	65667173	// Game Controllers: "&Properties..." (Button)
#define IDH_101_1022	65667180	// Game Controllers: "Refresh" (Button)
#define IDH_101_1010	66191461	// Game Controllers: "A&dd..." (Button)
#define IDH_101_1028	67371109	// Game Controllers: "&Remove..." (Button)
#define IDH_101_1036	67548653	// Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058	69337189	// Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101	72155253	// -: "&Port Driver:" (Static)
#define IDH_117_8197	537198709	// -: "" (ListBox)
#define IDH_117_8198	537264245	// -: "Cha&nge..." (Button)
#define IDH_117_8199	537385268	// Advanced: OEM property sheet check box
#define IDH_119_1039	68092023	// Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049	68092025	// Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059	69402743	// Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043	68358147	// Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044	68358149	// Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046	68358151	// Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045	68685827	// Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051	68882435	// Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052	68947971	// Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053	69013507	// Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1056	69210115	// Custom Game Controller: "" (Edit)
#define IDH_4099_1058	69410157	// Custom Game Controller: "Is a Joy stick" (Button)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12290	805507175	// Settings: "Reset to &default" (Button)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox) (X/Y test box)
#define IDH_4203_12308	806621291	// -: "" (ListBox) (all other test boxes)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_8188_8189	536682492	// Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191	537010170	// Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194	537010172	// Change Controller Assignment: "" (ListBox)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gcmain.rc
//
#define IDD_CPANEL                      101
#define IDI_CPANEL                      102
#define IDD_PROPSHEET                   103
#define IDD_ASSIGN                      104
#define IDI_NOTCONNECTED                108
#define IDI_JOYSTICK                    110
#define IDR_MENU1                       116
#define IDD_ADVANCED                    117
#define IDD_ADD                         119
#define IDD_SMAPPER                     122
#define IDB_JOYSTICK                    126
#define IDD_MOREINFO                    127
#define IDI_DIRECTX                     129
#define IDI_CHECKBOX_EMPTY              131
#define IDD_DVOICE                      131
#define IDI_CHECKBOX_FULL               132
#define IDD_PROP_RETROFIT               133
#define IDS_DVOICE_TAB                  134
#define IDD_WIZARD_CANCELED             135
#define IDD_WIZARD_LAUNCH               136
#define IDD_VOICE_ENABLED               137
#define IDI_LIST_DEFAULT                138
#define IDD_CONFIRM_HALFDUPLEX          139
#define IDD_CONFIRM_SOUNDINITFAILURE    140
#define IDD_WIZARD_ERROR                141
#define IDD_DETAILS                     143
#define IDD_PREV_HALFDUPLEX             144
#define IDD_APPMAN_MORE_INFO            145
#define IDD_UPDATE                      146
#define IDC_COMBO1                      1000
#define IDC_TEXT_HELP                   1001
#define IDC_BTN_PROPERTIES              1002
#define IDC_BTN_SETTINGS                1003
#define IDC_BTN_TEST                    1004
#define IDC_TAB                         1005
#define IDC_BTN_APPLY                   1006
#define IDC_BTN_TSHOOT                  1007
#define IDC_TEXT_DEVICE                 1008
#define IDC_BTN_REFRESH                 1009
#define IDC_BTN_ASSIGN                  1010
#define IDC_BTN_ADD                     1011
#define IDC_COMBO_JOYSTICKID            1012
#define IDS_TSHOOT_CMD                  1013
#define IDC_BTN_UPDATE                  1014
#define IDC_LIST_DEVICE                 1020
#define IDC_TEXT_DEVICELIST             1025
#define IDC_TEXT_IDLIST                 1026
#define IDC_BTN_REMOVE                  1028
#define IDC_COMBO_AXIS                  1030
#define IDC_TEXT_TITLE                  1031
#define IDC_TEXT_DRIVER                 1032
#define IDC_TEXT_LBTAG                  1033
#define IDC_ADD_STR1                    1037
#define IDC_ADD_STR2                    1038
#define IDC_ADD_NEW                     1039
#define IDS_ADV_TITLE                   1039
#define IDS_ADV_GLOBAL_DESC             1040
#define IDS_ADV_GLOBAL_TAG              1041
#define IDS_ADV_DEVICE_HEADING          1042
#define IDC_AXES_GROUP                  1043
#define IDC_AXES2                       1044
#define IDC_AXES3                       1045
#define IDC_AXES4                       1046
#define IDC_BUTTONS_GROUP               1047
#define IDC_COMBO_BUTTONS               1048
#define IDC_SPECIAL_GROUP               1049
#define IDC_SPECIAL_CHECK               1050
#define IDC_SPECIAL_YOKE                1051
#define IDC_SPECIAL_PAD                 1052
#define IDC_SPECIAL_AUTO                1053
#define IDC_SPECIAL_JOYSTICK            1054
#define IDC_CUSTOM_NAME                 1055
#define IDC_EDIT_NAME                   1056
#define IDC_DEVICE_LIST                 1057
#define IDC_LIST_HEADING                1058
#define IDS_ADD_DESC                    1059
#define IDS_ADD_NEW_DESC                1060
#define IDS_ADD_NEW                     1061
#define IDS_CUSTOM_TITLE                1062
#define IDS_CUSTOM_AXES_GROUP           1063
#define IDS_CUSTOM_2AXES                1064
#define IDS_CUSTOM_3AXES                1065
#define IDS_CUSTOM_4AXES                1066
#define IDS_CUSTOM_BUTTONS_GROUP        1067
#define IDS_CUSTOM_SPECIAL              1068
#define IDS_CUSTOM_ISFLIGHTYOKE         1069
#define IDS_CUSTOM_ISGAMEPAD            1070
#define IDS_CUSTOM_ISRACECAR            1071
#define IDS_CUSTOM_HASPOV               1072
#define IDS_CUSTOM_NAME                 1073
#define IDS_CUSTOM_BUTTONS              1074
#define IDS_GEN_CPANEL_TITLE            1076
#define IDS_GENERAL_TAB                 1077
#define IDC_ADV_USEOEMPAGE              1078
#define IDS_ADVANCED_TAB                1079
#define IDS_NONE                        1080
#define IDC_SCROLLBAR1                  1081
#define IDC_SPIN1                       1083
#define IDS_ADV_DEVICE_FRIENDLY         1084
#define IDC_DATETIMEPICKER1             1085
#define IDC_SW_HACK                     1086
#define IDS_ADD_DEVICE_LIST_TAG         1091
#define IDS_OK                          1092
#define IDS_CANCEL                      1093
#define IDS_ADD_TITLE                   1094
#define IDS_NO_IDS                      1095
#define IDS_NO_IDS_TITLE                1096
#define IDS_NO_NAME                     1097
#define IDS_NO_NAME_TITLE               1098
#define IDS_GEN_CPANEL_INFO             1099
#define IDC_POLLFLAGS                   1100
#define IDC_TEXT_PORTDRIVER             1101
#define IDS_NO_GAMEPORT                 1102
#define IDS_NO_GAMEPORT_TITLE           1103
#define IDS_ADV_STATUS_HEADING          1143
#define IDS_ADV_STD_GAMEPORT            1144
#define IDS_WHATSTHIS                   1145
#define IDS_GEN_PROPERTIES              1146
#define IDS_GEN_REMOVE                  1147
#define IDS_GEN_ADD                     1148
#define IDS_GEN_LIST_HEADING            1149
#define IDS_GEN_TEXT_HELP               1150
#define IDS_GEN_DEVICE_HEADING          1151
#define IDS_GEN_STATUS_HEADING          1152
#define IDS_GEN_AREYOUSURE              1153
#define IDC_VIEW_CTRL                   1154
#define IDS_GEN_STATUS_OK               1155
#define IDS_GEN_STATUS_NOTCONNECTED     1157
#define IDS_GEN_STATUS_NOFORCES         1158
#define IDC_DEVICE_LIST_TAG             1159
#define IDC_ADV_GRP                     1161
#define IDC_ADV_GRP2                    1162
#define IDC_GEN_INTRO                   1164
#define IDC_GEN_ICON                    1166
#define IDC_GAMEPORT                    1167
#define IDC_GAMEPORTLIST                1168
#define IDC_CUSTOM                      1169
#define IDS_ADV_GAME_CONTROLLERS        1170
#define IDC_HASRUDDER                   1172
#define IDC_HASZAXIS                    1174
#define IDC_ADV_OEMSHEET                1175
#define IDC_WDM                         1176
#define IDS_ADV_DEVICE_PORT             1177
#define IDS_NOAVAILABLEVIDPID           1178
#define IDS_GAMES_COLUMN_HEADER         1188
#define IDS_ENABLED_COLUMN_HEADER       1189
#define IDS_GEN_AREYOUSURE_TITLE        1254
#define IDC_MOREINFO                    1280
#define IDC_INFO_ICON                   1300
#define IDC_ICON_NOTCOMPLETE            1301
#define IDC_ICON_INFORMATION            1302
#define IDC_ICON_WARNING                1303
#define IDC_ICON_ERROR                  1304
#define IDC_DETAILS                     1305
#define IDC_WARNING_ICON                1306
#define IDC_RUNTEST                     1307
#define IDC_VOICECHATTEXT               1308
#define IDC_GAMESLISTHOTKEY             1309
#define IDC_VOICECHATGROUP              1310
#define IDC_BTN_ADV                     1311
#define IDD_CUSTOM                      4099
#define IDD_ADV_CHANGE                  8188
#define IDC_CHANGE_BOARDER              8189
#define IDD_APPMAN_ADV                  8189
#define IDD_APPMAN_LOCKING              8189
#define IDC_SELECTEDID                  8190
#define IDD_APPMAN_ADVUSER              8191
#define IDC_CHANGEID                    8192
#define IDC_ASSIGNTXT                   8193
#define IDC_LISTTXT                     8194
#define IDC_CHANGE_LIST                 8195
#define IDS_DEVICEID                    8196
#define IDS_CONTROLLERS                 8197
#define IDC_ADV_LIST_DEVICE             8198
#define IDC_ADV_CHANGE                  8199
#define IDC_GROUPBOX                    8300
#define IDS_CONTROLLERID                8301
#define IDC_GROUPBOX_2                  8302
#define IDC_GROUPBOX_3                  8303
#define IDS_ADV_CHANGE                  8304
#define IDS_CUSTOM_STRING               8305
#define IDC_JOYHASPOV                   12322
#define IDC_JOYISYOKE                   12323
#define IDC_JOYISGAMEPAD                12324
#define IDC_JOYISCARCTRL                12325
#define IDC_JOY2BUTTON                  12326
#define IDC_JOY4BUTTON                  12327
#define IDC_JOYUSESPECIAL               12332
#define IDC_JOY2AXIS                    12336
#define IDC_JOY3AXIS                    12337
#define IDC_JOY4AXIS                    12338
#define IDC_BTN_DIAG                    40001
#define IDS_HELPFILENAME                40002
#define IDS_DUPLICATE_TYPE              40003
#define IDS_DUPLICATE_TYPE_TITLE        40004
#define IDS_INVALID_NAME                40005
#define IDS_INVALID_NAME_TITLE          40006
#define IDS_INTERNAL_ERROR              40007
#define IDS_NO_DIJOYCONFIG              40008
#define IDS_NO_GAMENUM                  40009
#define IDS_NO_GAMENUM_TITLE            40010
#define IDC_SEPERATOR                   40011
#define IDS_MAX_DEVICES_TITLE           40012
#define IDS_MAX_DEVICES_MSG             40013
#define IDS_NO_REMOVE                   40014
#define IDS_RENAME                      40016
#define IDC_RENAME                      40017
#define IDS_DONE                        40018
#define IDS_REFRESH                     40019
#define IDC_JOY1HASRUDDER               40022
#define IDC_SPIN                        40023
#define IDC_SPINBUDDY                   40024
#define IDS_ADD_PORT_MSGFORMAT          40025
#define IDS_ADD_PORT_OCCUPIED           40026
#define IDS_GEN_STATUS_UNKNOWN          40027
#define IDS_GEN_NO_REMOVE_USB           40028
#define IDS_WDMJOY                      40029
#define IDS_AUTO_DETECT                 40030
#define IDS_USER_MODE                   40031
#define IDS_USER_MODE_TITLE             40032
#define IDS_WDMJOY_INF                  40033
#define IDC_MYSTATIC                    40034
#define IDS_NO_RENAME                   40035
#define IDS_NO_RENAME_TITLE             40036
#define IDS_GAMEPORT_OCCUPIED           40037
#define IDS_GAMEPORT_OCCUPIED_TITLE     40038
#define IDS_DEST_ID_OCCUPIED            40039
#define IDS_DEST_ID_OCCUPIED_TITLE      40040
#define IDS_VOICEMOREINFO               40046
#define IDC_PEAKMETER                   41008
#define IDC_P1                          41013
#define IDC_P2                          41014
#define IDC_P3                          41015
#define IDC_WELCOME_IMAGE               41016
#define IDC_COMPLETE_IMAGE              41021
#define IDC_TITLE                       41022
#define IDC_PROGRESSBAR                 41023
#define IDC_RADIO_EXTERNAL              41024
#define IDC_RADIO_HEADSET               41025
#define IDC_COMPLETE_FAILED_GRAPHIC     41026
#define IDC_P4                          41027
#define IDC_DIVIDER                     41028
#define IDC_P5                          41029
#define IDC_LIST_GAMES                  41034
#define IDC_TEST_DEVICES                41042
#define IDC_VOICE_DEVICES               41043
#define IDC_GROUP1                      41044
#define IDC_GROUP2                      41045
#define IDS_UPDATE_SITEDIR              41046
#define IDS_UPDATE_INI                  41047
#define IDS_UPDATE_LASTUPDATED          41048
#define IDS_UPDATE_NOTCONNECTED_TITLE   41049
#define IDS_UPDATE_NOTCONNECTED         41050
#define IDS_UPDATE_FTP_ERROR            41051
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         41052
#define _APS_NEXT_CONTROL_VALUE         1312
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\sources.inc ===
!IFNDEF DXROOT
DXROOT = $(BASEDIR)\MultiMedia\DirectX
!ENDIF

!INCLUDE $(DXROOT)\Project.mk

#
#   Use an empty binplace file to dump this version in the DirectX build
#
!IFDEF DIRECTX_REDIST
BINPLACE_PLACEFILE=..\..\noplace.txt
!ENDIF

MAJORCOMP=shell
MINORCOMP=accessory

TARGETNAME=joy
TARGETEXT=cpl
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

USE_MSVCRT=0
USE_STL=1
USE_MAPSYM=1

DLLENTRY=DllMain

USER_C_FLAGS=$(USER_C_FLAGS) /EHsc
LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217 

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\uuid.lib \
           $(SDK_LIB_PATH)\dinput8.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\shlwapi.lib \
           $(SHELL_LIB_PATH)\shfusion.lib \
           
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.OptionallyYourGroupName.YourAppName
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=Joy.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
SXS_MANIFEST_RESOURCE_ID=124

INCLUDES=$(INCLUDES); \
     ..; \
     ..\..\handler; \
     $(DXROOT)\inc; \
     $(SHELL_INC_PATH); \

SOURCES= \
    ..\gcmain.rc \
    ..\guids.c \
    ..\main.cpp \
    ..\core.cpp \

DLLDEF=..\joy.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\main.cpp ===
/****************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include <windows.h>
#include <cpl.h>
#include "resource.h"

void Core(HANDLE hModule,HWND hWnd);

HINSTANCE ghInstance;

BOOL WINAPI DllMain(HANDLE hModule,ULONG uReason,LPVOID pv)
{
    switch(uReason)
    {
    case DLL_PROCESS_ATTACH:
        ghInstance=(HINSTANCE)hModule;
        break;
	case DLL_PROCESS_DETACH:
		break;
    case DLL_THREAD_ATTACH:
        DisableThreadLibraryCalls((HMODULE)hModule);
        break;
    case DLL_THREAD_DETACH:
        break;
    }
    return(TRUE);
}

LONG WINAPI CPlApplet(HWND hWnd,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    switch(uMsg)
    {
    case CPL_INIT:
        return 1;
    case CPL_GETCOUNT:
        return 1;
    case CPL_INQUIRE:
        ((LPCPLINFO)lParam2)->idIcon=IDI_CPANEL; 
        ((LPCPLINFO)lParam2)->idName=IDS_GEN_CPANEL_TITLE; 
        ((LPCPLINFO)lParam2)->idInfo=IDS_GEN_CPANEL_INFO; 
        ((LPCPLINFO)lParam2)->lData=0;
        //return 0;MSDN doc says this should be returned.
        return 1;
    case CPL_DBLCLK:
        Core(ghInstance,hWnd);
        return 0;
    }
    return 0;
}

// DO NOT REMOVE THIS!!!
// This is here because the games group loads the CPL from the exported function
// If you remove this Hellbender, Monster Truck Maddness, CART, etc will fail to
// load the Joystick CPL!!!
// DO NOT REMOVE THIS!!!
void WINAPI ShowJoyCPL(HWND hWnd)
{
    Core(ghInstance,hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\calocal.h ===
//===========================================================================
// CALOCAL.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#ifndef _CALOCAL_H
#define _CALOCAL_H

#include <regstr.h>

#define STR_MAX_LEN		255
#define	STR_LEN_128		128
#define STR_LEN_64		 64
#define	STR_LEN_32		 32

#define DELTA			  5
#define RANGE_MIN		  0
#define RANGE_MAX	  65535


#define ID_CAL_TIMER	 		18
#define CALIBRATION_INTERVAL 	85 

#define ACTIVE_COLOR	RGB( 255, 0, 0 )
#define INACTIVE_COLOR	RGB( 128, 0, 0 )

typedef enum {
    JCS_INIT=-1,
    JCS_XY_CENTER1,
    JCS_XY_MOVE,
    JCS_XY_CENTER2,
#ifdef DEADZONE
	JCS_DEADZONE,
#endif
    JCS_Z_MOVE,
    JCS_R_MOVE,
    JCS_U_MOVE,
    JCS_V_MOVE,
    JCS_S0_MOVE,
    JCS_S1_MOVE,
#ifdef WE_SUPPORT_CALIBRATING_POVS
    JCS_POV_MOVEUP,
    JCS_POV_MOVERIGHT,
    JCS_POV_MOVEDOWN,
    JCS_POV_MOVELEFT,
#endif // WE_SUPPORT_CALIBRATING_POVS
    JCS_FINI
} cal_states;



/***************************************************************************
 
			  CALIBRATION SPECIFIC FUNCTION DEFINITIONS
 
 ***************************************************************************/

static void		CalStateChange	  ( HWND hDlg, BYTE nDeviceFlags );
static void     EnableXYWindows   ( HWND hDlg );
static BOOL		GetOEMCtrlString  ( LPTSTR lptStr, DWORD *nStrLen);
static BOOL		CollectCalInfo	  ( HWND hDlg, LPDIJOYSTATE pdiJoyState );
static HRESULT	SetCalibrationMode( BOOL bSet );

#ifdef WE_SUPPORT_CALIBRATING_POVS
//static void		ChangeIcon		( HWND hDlg, short idi );
//static void		SetDefaultButton( HWND hDlg, HWND hCtrl );
#endif //WE_SUPPORT_CALIBRATING_POVS

#endif //_CALOCAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\cal.h ===
//===========================================================================
// CALIBRATE.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#ifndef _CALIBRATE_H
#define _CALIBRATE_H



/***************************************************************************
//
//					FUNCTION DEFINITIONS FOLLOW
//
 ***************************************************************************/

INT_PTR CALLBACK Calibrate_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef struct sliderranges_tag
{
	DWORD dwSlider0Max;
	DWORD dwSlider0Min;
	DWORD dwSlider0Centre;
	DWORD dwSlider1Max;
	DWORD dwSlider1Min;
	DWORD dwSlider1Centre;
}SLIDERRANGES, FAR *LPSLIDERRANGES;
#endif // *** _CALIBRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\button.cpp ===
/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
**
**    FILE:       BUTTON.CPP
**    DATE:       5/12/98
**    PROJ:       NT5
**    PROG:       BLJ
**    COMMENTS:   
**
**    DESCRIPTION: Window class custom buttons
**                    
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    5/12/98     a-brycej     Wrote it.
**    
**
** Copyright (C) Microsoft 1998.  All Rights Reserved.
**
**~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/

#include "resrc1.h"

#include "cplsvr1.h"
extern HINSTANCE ghInst;
extern CDIGameCntrlPropSheet_X *pdiCpl;

// Colour of text for buttons!
#define TEXT_COLOUR  RGB(202,202,202)

HICON hIconArray[2];

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  ButtonWndProc
//    REMARKS  :  The callback function for the CustomButton Window.
//                    
//    PARAMS   :  The usual callback funcs for message handling
//
//    RETURNS  :  LRESULT - Depends on the message
//    CALLS    :  
//    NOTES    :
//                

LRESULT CALLBACK ButtonWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch( iMsg )
    {
        case WM_PAINT:
            {
                PAINTSTRUCT *pps = new (PAINTSTRUCT);
                assert (pps);

                HDC hDC = BeginPaint(hWnd, pps);

                // Draw the appropriate icon                                                                                       
                DrawIconEx(hDC, 0, 0, hIconArray[GetWindowLong(hWnd, GWLP_USERDATA)], 0, 0, 0, NULL, DI_NORMAL);

                // Prepare the DC for the text
                SetBkMode   (hDC, TRANSPARENT);
                SetTextColor(hDC, TEXT_COLOUR);

                // Enforce the proper size!
                pps->rcPaint.top    = pps->rcPaint.left   = 0;
                pps->rcPaint.bottom = 33;
                pps->rcPaint.right  = 30;

              #define MAX_BUTTON_DIGITS  3
                TCHAR tsz[MAX_BUTTON_DIGITS+1]; //Maximum button number can be 999, more than enough.

                // Draw the Number                        
                DrawText (hDC, (LPCTSTR)tsz, GetWindowText(hWnd, tsz, MAX_BUTTON_DIGITS+1), &pps->rcPaint, DT_VCENTER|DT_CENTER|DT_NOPREFIX|DT_SINGLELINE|DT_NOCLIP);
                SetBkMode(hDC, OPAQUE);
                EndPaint (hWnd, pps);
             #undef MAX_BUTTON_DIGITS

                if( pps ) {
                    delete (pps);
                }
            }
            return(FALSE);

        default:
            return(DefWindowProc(hWnd, iMsg,wParam, lParam));
    }
    return(FALSE);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  RegisterCustomButtonClass
//    REMARKS  :  Registers the Custom Button control window.
//                    
//    PARAMS   :  hInstance - Used for the call to RegisterClassEx
//
//    RETURNS  :  TRUE - if successfully registered
//                FALSE - failed to register
//    CALLS    :  RegisterClassEx
//    NOTES    :
//

extern ATOM RegisterCustomButtonClass()
{
    WNDCLASSEX CustCtrlClass;

    ZeroMemory(&CustCtrlClass, sizeof(WNDCLASSEX));

    CustCtrlClass.cbSize        = sizeof(WNDCLASSEX);
    CustCtrlClass.style         = CS_CLASSDC; 
    CustCtrlClass.lpfnWndProc   = ButtonWndProc;
    CustCtrlClass.hInstance     = ghInst;
    CustCtrlClass.lpszClassName = TEXT("TESTBUTTON");

    return(RegisterClassEx( &CustCtrlClass ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\cplsvr1.cpp ===
//===========================================================================
// CPLSVR1.CPP
//
// Simple sample "Game Controllers" control panel extension server.
//
// Functions:
//  DLLMain()
//  DllGetClassObject()
//  DllCanUnloadNow()
//  CServerClassFactory::CServerClassFactory()
//  CServerClassFactory::~CServerClassFactory()
//  CServerClassFactory::QueryInterface()
//  CServerClassFactory::AddRef()
//  CServerClassFactory::Release()
//  CServerClassFactory::CreateInstance()
//  CServerClassFactory::LockServer()
//  CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X()
//  CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X()
//  CDIGameCntrlPropSheet_X::QueryInterface()
//  CDIGameCntrlPropSheet_X::AddRef()
//  CDIGameCntrlPropSheet_X::Release()
//  CDIGameCntrlPropSheet_X::GetSheetInfo()								 
//  CDIGameCntrlPropSheet_X::GetPageInfo()
//  CDIGameCntrlPropSheet_X::SetID()
//  CDIGameCntrlPropSheet_X::Initialize()
//  CDIGameCntrlPropSheet_X::SetDevice()
//  CDIGameCntrlPropSheet_X::GetDevice()
//  CDIGameCntrlPropSheet_X::SetJoyConfig()
//  CDIGameCntrlPropSheet_X::GetJoyConfig()
//  
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#define INITGUID
#define STRICT

#include "cplsvr1.h"
#include "pov.h"
#include "assert.h"

//---------------------------------------------------------------------------

// file global variables
static  BYTE  glDLLRefCount  = 0;     // DLL reference count
static  LONG  glServerLocks  = 0;     // Count of locks
CDIGameCntrlPropSheet_X *pdiCpl;
HINSTANCE            ghInst;
CRITICAL_SECTION     gcritsect;

DWORD   myPOV[2][JOY_POV_NUMDIRS+1];
BOOL    bPolledPOV;

//---------------------------------------------------------------------------


// LegacyServer GUID!!!
// {92187326-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_LegacyServer, 
	0x92187326, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);


//---------------------------------------------------------------------------

//===========================================================================
// DLLMain
//
// DLL entry point.
//
// Parameters:
//  HINSTANCE   hInst       - the DLL's instance handle 
//  DWORD       dwReason    - reason why DLLMain was called
//  LPVOID      lpvReserved - 
//
// Returns:
//  BOOL - TRUE if succeeded
//
//===========================================================================
int APIENTRY DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpvReserved)
{   
	switch (dwReason)
   {
   	case DLL_PROCESS_ATTACH:
      	ghInst = hInst;
         InitializeCriticalSection(&gcritsect);
         break;

      case DLL_PROCESS_DETACH:
         DeleteCriticalSection(&gcritsect);
         break;

 		case DLL_THREAD_ATTACH:
			DisableThreadLibraryCalls((HMODULE)hInst);
   	case DLL_THREAD_DETACH:
			break;
   } //** end switch(dwReason)
   return TRUE;
} //*** end DLLMain()


//===========================================================================
// DllGetClassObject
//
// Gets an IClassFactory object.
//
// Parameters:
//  REFCLSID    rclsid  - CLSID value (by reference)
//  REFIID      riid    - IID value (by reference)
//  PPVOID      ppv     - ptr to store interface ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    // did the caller pass in our CLSID?
    if(!IsEqualCLSID(rclsid, CLSID_LegacyServer))
    {
        // no, return class not available error
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // did the caller request our class factory?
    if(!IsEqualIID(riid, IID_IClassFactory))
    {
        // no, return no interface error
        return E_NOINTERFACE;
    }

    // instantiate class factory object
    CServerClassFactory *pClsFactory = new CServerClassFactory();
    if (NULL == pClsFactory)
    {
        // could not create the object
        //
        // chances are we were out of memory
        return E_OUTOFMEMORY;

    }

    // query for interface riid, and return it via ppv
    HRESULT hRes = pClsFactory->QueryInterface(riid, ppv);   

    // we're finished with our local object
    pClsFactory->Release();

    // return the result code from QueryInterface
    return hRes;

} //*** end DllGetClassObject()


//===========================================================================
// DllCanUnloadNow
//
// Reports whether or not the DLL can be unloaded.
//
// Parameters: none
//
// Returns
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDAPI DllCanUnloadNow(void)
{
    // unloading should be safe if the global dll refcount is zero and server lock ref is 0
	 return (glDLLRefCount == 0 && glServerLocks == 0) ? S_OK : S_FALSE;
} //*** end DllCanUnloadNow()


//===========================================================================
// CServerClassFactory::CServerClassFactory
//
// Class constructor.
//
// Parameters: none
//
// Returns:
//  CServerClassFactory* (implicit)
//
//===========================================================================
CServerClassFactory::CServerClassFactory(void)
{
    // initialize and increment the object refcount
    m_ServerCFactory_refcount = 0;
    AddRef();

    // increment the dll refcount
    InterlockedIncrement((LPLONG)&glDLLRefCount);

} //*** end CServerClassFactory::CServerClassFactory()


//===========================================================================
// CServerClassFactory::CServerClassFactory
//
// Class constructor.
//
// Parameters: none
//
// Returns:
//  CServerClassFactory* (implicit)
//
//===========================================================================
CServerClassFactory::~CServerClassFactory(void)
{
	// decrement the dll refcount
   InterlockedDecrement((LPLONG)&glDLLRefCount);
} //*** end CServerClassFactory::~CServerClassFactory()


//===========================================================================
// CServerClassFactory::QueryInterface
//
// Implementation of the QueryInterface() method.
//
// Parameters:
//  REFIID  riid    - the interface that is being looked for
//  PPVOID  ppv     - pointer to target interface pointer
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CServerClassFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
	// make sure that if anything fails, we return something reasonable
   *ppv = NULL;

   // we support IUnknown...
   if (IsEqualIID(riid, IID_IUnknown))
   {
   	// return our object as an IUnknown
		*ppv = (LPUNKNOWN)(LPCLASSFACTORY)this;
	}
	else
	{
   	// ... and our interface
    	if (IsEqualIID(riid, IID_IClassFactory))
      	// return our object as a class factory
			*ppv = (LPCLASSFACTORY)this;
    	else
      	// we do not support any other interfaces
        	return E_NOINTERFACE;
	}
   
	// we got this far, so we've succeeded
	// increment our refcount and return
	AddRef();
	return S_OK;
} //*** end CServerClassFactory::QueryInterface()


//===========================================================================
// CServerClassFactory::AddRef
//
// Implementation of the AddRef() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//
//===========================================================================
STDMETHODIMP_(ULONG) CServerClassFactory::AddRef(void)
{
	// update and return our object's reference count   
   InterlockedIncrement((LPLONG)&m_ServerCFactory_refcount);
   return m_ServerCFactory_refcount;
} //*** end CServerClassFactory::AddRef()


//===========================================================================
// CServerClassFactory::Release
//
// Implementation of the Release() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//
//===========================================================================
STDMETHODIMP_(ULONG) CServerClassFactory::Release(void)
{
	// update and return our object's reference count   
	InterlockedDecrement((LPLONG)&m_ServerCFactory_refcount);
	if (0 == m_ServerCFactory_refcount)
	{
   	// it's now safe to call the destructor
      delete this;
      return 0;
   }
   else return m_ServerCFactory_refcount;
} //*** end CServerClassFactory::Release()
    

//===========================================================================
// CServerClassFactory::CreateInstance
//
// Implementation of the CreateInstance() method.
//
// Parameters: none
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CServerClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, PPVOID ppvObj)
{
	CDIGameCntrlPropSheet_X *pdiGCPropSheet = NULL;
   HRESULT                 hRes            = E_NOTIMPL;

   // make sure that if anything fails, we return something reasonable
   *ppvObj = NULL;

   // we want pUnkOuter to be NULL
   //
   // we do not support aggregation
   if (pUnkOuter != NULL)
   {
   	// tell the caller that we do not support this feature
      return CLASS_E_NOAGGREGATION;
   }

   // Create a new instance of the game controller property sheet object
   pdiGCPropSheet = new CDIGameCntrlPropSheet_X();
   if (NULL == pdiGCPropSheet)
   {
      // we could not create our object
      // chances are, we have run out of memory
      return E_OUTOFMEMORY;
   }
    
    // initialize the object (memory allocations, etc)
    if (SUCCEEDED(pdiGCPropSheet->Initialize()))
	    // query for interface riid, and return it via ppvObj
   	 hRes = pdiGCPropSheet->QueryInterface(riid, ppvObj);   

    // release the local object
    pdiGCPropSheet->Release();

    // all done, return result from QueryInterface
    return hRes;
} //*** end CServerClassFactory::CreateInstance()


//===========================================================================
// CServerClassFactory::LockServer
//
// Implementation of the LockServer() method.
//
// Parameters: none
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CServerClassFactory::LockServer(BOOL fLock)
{
	//HRESULT hRes = E_NOTIMPL;

   // increment/decrement based on fLock
	if (fLock) 
   	InterlockedIncrement((LPLONG)&glDLLRefCount); 
	else
   	InterlockedDecrement((LPLONG)&glDLLRefCount);

   // all done
   return S_OK;
} //*** end CServerClassFactory::LockServer()

//===========================================================================
// CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X
//
// Class constructor.
//
// Parameters: none
//		
// Returns: nothing
//
//===========================================================================
CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X(void)
{

   // initialize and increment the object refcount
   m_cProperty_refcount = 0;
   AddRef();

   // initialize our device id to -1 just to be safe
   m_nID = (BYTE)-1;

   // init 
   m_bUser = FALSE;

   // initialize all of our pointers
   m_pdigcPageInfo = NULL;
   m_pdiDevice2    = NULL;
   m_pdiJoyCfg     = NULL;
   
   pdiCpl          = NULL;

   // increment the dll refcount
   InterlockedIncrement((LPLONG)&glDLLRefCount);

	// Register the POV hat class
	m_aPovClass = RegisterPOVClass();

   // Register the custom Button class
   m_aButtonClass = RegisterCustomButtonClass();

} //*** end CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X()


//===========================================================================
// CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X
//
// Class destructor.
//
// Parameters: none
//
// Returns: nothing
//
//===========================================================================
CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X(void)
{
    // free the DIGCPAGEINFO memory
    if (m_pdigcPageInfo)
       LocalFree(m_pdigcPageInfo);

	// free the DIGCSHEETINFO memory
	if (m_pdigcSheetInfo)
		LocalFree(m_pdigcSheetInfo);

	// free up the StateFlags memory!
	if (m_pStateFlags)
		delete (m_pStateFlags);

    // cleanup directinput objects
    // m_pdiDevice2
    if (m_pdiDevice2)
    {
        m_pdiDevice2->Unacquire();
        m_pdiDevice2->Release();
        m_pdiDevice2 = NULL;
    }
    // m_pdiJoyCfg
    if (m_pdiJoyCfg)
    {
        m_pdiJoyCfg->Unacquire();
        m_pdiJoyCfg->Release();
        m_pdiJoyCfg = NULL;
    }

	// Unregister the classes!!!
	if (m_aPovClass)
		UnregisterClass((LPCTSTR)m_aPovClass, ghInst);

	if (m_aButtonClass)
		UnregisterClass((LPCTSTR)m_aButtonClass, ghInst);

    // decrement the dll refcount
    InterlockedDecrement((LPLONG)&glDLLRefCount);

} //*** end CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X()


//===========================================================================
// CDIGameCntrlPropSheet_X::QueryInterface
//
// Implementation of the QueryInterface() method.
//
// Parameters:
//  REFIID  riid    - the interface that is being looked for
//  PPVOID  ppv     - pointer to target interface pointer
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::QueryInterface(REFIID riid, PPVOID ppv)
{
    // make sure that if anything fails, we return something reasonable
    *ppv = NULL;

    // we support IUnknown...
    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPUNKNOWN)(LPCDIGAMECNTRLPROPSHEET)this;
    }
    else
    {
        // ... and IID_IDIGameCntrlPropSheet
        if(IsEqualIID(riid, IID_IDIGameCntrlPropSheet))
            *ppv = (LPCDIGAMECNTRLPROPSHEET)this;
        else
            // we do not support any other interfaces
            return E_NOINTERFACE;
    }

    // we got this far, so we've succeeded
    // increment our refcount and return
    AddRef();
    return S_OK;
} //*** end CDIGameCntrlPropSheet_X::QueryInterface()


//===========================================================================
// CDIGameCntrlPropSheet_X::AddRef
//
// Implementation of the AddRef() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//===========================================================================
STDMETHODIMP_(ULONG) CDIGameCntrlPropSheet_X::AddRef(void)
{   
    // update and return our object's reference count
    InterlockedIncrement((LPLONG)&m_cProperty_refcount);
    return m_cProperty_refcount;
} //*** end CDIGameCntrlPropSheet_X::AddRef()


//===========================================================================
// CDIGameCntrlPropSheet_X::Release
//
// Implementation of the Release() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//===========================================================================
STDMETHODIMP_(ULONG) CDIGameCntrlPropSheet_X::Release(void)
{
	// update and return our object's reference count
   InterlockedDecrement((LPLONG)&m_cProperty_refcount);
   if (m_cProperty_refcount)
    	return m_cProperty_refcount;

	// it's now safe to call the destructor
   delete this;
   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::Release()


//===========================================================================
// CDIGameCntrlPropSheet_X::GetSheetInfo
//
// Implementation of the GetSheetInfo() method.
//
// Parameters:
//  LPDIGCSHEETINFO  *ppSheetInfo  - ptr to DIGCSHEETINFO struct ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetSheetInfo(LPDIGCSHEETINFO *ppSheetInfo)
{
	// pass back the our sheet information
   *ppSheetInfo = m_pdigcSheetInfo;

   // all done here
   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetSheetInfo()


//===========================================================================
// CDIGameCntrlPropSheet_X::GetPageInfo
//
// Implementation of the GetPageInfo() method.
//
// NOTE: This returns the information for ALL pages.  There is no mechanism
//  in place to request only page n's DIGCPAGEINFO.
//
// Parameters:
//  LPDIGCPAGEINFO  *ppPageInfo  - ptr to DIGCPAGEINFO struct ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetPageInfo(LPDIGCPAGEINFO  *ppPageInfo)
{
	// pass back the our page information
   *ppPageInfo = m_pdigcPageInfo;
    
   // all done here
   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetPageInfo()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetID
//
// Implementation of the SetID() method.
//
// Parameters:
//  USHORT  nID - identifier to set
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::SetID(USHORT nID)
{
	// store the device id
   m_nID = (BYTE)nID;

   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::SetID()


//===========================================================================
// CDIGameCntrlPropSheet::Initialize
//
// Implementation of the Initialize() method.
//
// Parameters: none
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
HRESULT CDIGameCntrlPropSheet_X::Initialize(void)
{
// provide the following information for each device page
//  { dialog template, callback function pointer }
	CPLPAGEINFO     grgcpInfo[NUMPAGES] = {
		IDD_SETTINGS,
	   Settings_DlgProc,           
		IDD_TEST,
	   Test_DlgProc
#ifdef FORCE_FEEDBACK
	   ,                // Template DlgProc
		IDD_FORCEFEEDBACK, 
		ForceFeedback_DlgProc
	#endif // FORCE_FEEDBACK
      };

   // allocate memory for the DIGCPAGEINFO structures
   m_pdigcPageInfo = (DIGCPAGEINFO *)LocalAlloc(LPTR, NUMPAGES * sizeof(DIGCPAGEINFO));

   if (!m_pdigcPageInfo){
       return E_OUTOFMEMORY;
   }

	m_pdigcSheetInfo = (DIGCSHEETINFO *)LocalAlloc(LPTR, sizeof(DIGCSHEETINFO));
    if (!m_pdigcSheetInfo) {
        LocalFree(m_pdigcPageInfo);

        return E_OUTOFMEMORY;
    }

   // populate the DIGCPAGEINFO structure for each sheet
	BYTE i = 0;
	do
   {
       m_pdigcPageInfo[i].dwSize        = sizeof(DIGCPAGEINFO);
       m_pdigcPageInfo[i].fIconFlag     = FALSE;
		 // This is done to test JOY.CPL...
		 // It's also better for Win9x, as it will not be required to convert it!
//       m_pdigcPageInfo[i].lpwszPageIcon = (LPWSTR)IDI_GCICON; //MAKEINTRESOURCE(IDI_GCICON);
       m_pdigcPageInfo[i].hInstance     = ghInst;
       m_pdigcPageInfo[i].lParam        = (LPARAM)this;

       // the following data is unique to each page
       m_pdigcPageInfo[i].fpPageProc    = grgcpInfo[i].fpPageProc;
       m_pdigcPageInfo[i].lpwszTemplate = (LPWSTR)grgcpInfo[i++].lpwszDlgTemplate;
   } while (i < NUMPAGES);

   // populate the DIGCSHEETINFO structure
   m_pdigcSheetInfo->dwSize               = sizeof(DIGCSHEETINFO);
   m_pdigcSheetInfo->nNumPages            = NUMPAGES;
   m_pdigcSheetInfo->fSheetIconFlag       = TRUE;
   m_pdigcSheetInfo->lpwszSheetIcon       = (LPWSTR)IDI_GCICON; //MAKEINTRESOURCEW(IDI_GCICON);

	// Do that device object enumeration thing!
	m_pStateFlags = new (STATEFLAGS);

	if (!m_pStateFlags) {
        LocalFree(m_pdigcPageInfo);
        LocalFree(m_pdigcSheetInfo);

		return E_OUTOFMEMORY;
    }

	ZeroMemory(m_pStateFlags, sizeof(STATEFLAGS));

   // all done
   return S_OK;
} //*** end CDIGameCntrlPropSheet::Initialize()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetDevice
//
// Implementation of the SetDevice() method.
//
// Parameters:
//  LPDIRECTINPUTDEVICE2 pdiDevice2 - device object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::SetDevice(LPDIRECTINPUTDEVICE2 pdiDevice2)
{
	// store the device object ptr
   m_pdiDevice2 = pdiDevice2;

   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::SetDevice()


//===========================================================================
// CDIGameCntrlPropSheet_X::GetDevice
//
// Implementation of the GetDevice() method.
//
// Parameters:
//  LPDIRECTINPUTDEVICE2 *ppdiDevice2   - ptr to device object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetDevice(LPDIRECTINPUTDEVICE2 *ppdiDevice2)
{
	// retrieve the device object ptr
	*ppdiDevice2 = m_pdiDevice2;

	return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetDevice()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetJoyConfig
//
// Implementation of the SetJoyConfig() method.
//
// Parameters:
//  LPDIRECTINPUTJOYCONFIG  pdiJoyCfg - joyconfig object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::SetJoyConfig(LPDIRECTINPUTJOYCONFIG pdiJoyCfg)
{
	// store the joyconfig object ptr
   m_pdiJoyCfg = pdiJoyCfg;

   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::SetJoyConfig()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetJoyConfig
//
// Implementation of the SetJoyConfig() method.
//
// Parameters:
//  LPDIRECTINPUTJOYCONFIG  *ppdiJoyCfg - ptr to joyconfig object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetJoyConfig(LPDIRECTINPUTJOYCONFIG *ppdiJoyCfg)
{
	// retrieve the joyconfig object ptr
	*ppdiJoyCfg = m_pdiJoyCfg;

	return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetJoyConfig()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\cal.cpp ===
//===========================================================================
// CAL.CPP... Would be CALIBRATE.CPP, but that's not 8.3 compliant :(
//
// Functions:
//
//    CalInitProc  
//    CalXYProc  	
//    CalSliderProc
//    CalPovProc
//    CalStateChange
//    CollectCalInfo
//    EnableXYWindows
//    GetOEMCtrlString
//
//===========================================================================

// This is necessary or PSH_WIZARD_LITE will not be defined!
#if (_WIN32_IE < 0x0500)
    #undef _WIN32_IE
    #define  _WIN32_IE  0x0500
#endif

// This is necessary for UnregisterDeviceNotification!
#if (WINVER < 0x0500)
    #undef WINVER
    #define WINVER 0x0500
#endif

// Uncomment if we decide to calibrate the POV!
#define WE_SUPPORT_CALIBRATING_POVS	1

#include "cplsvr1.h"
#include <mmsystem.h>

#ifdef _UNICODE
    #include <winuser.h>  // For RegisterDeviceNotification stuff!
    #include <dbt.h>      // for DBT_ defines!!!
#endif // _UNICODE

// remove to remove support for calibration of deadzones!
//#define DEADZONE 1

#include "resource.h"
#include "cal.h"			// Data to be shared with other modules
#include "calocal.h"		// Local Data to this module
#include "dicputil.h"	// for OnContextMenu and OnHelp
#include "pov.h"			// for SetDegrees()

#include <prsht.h>      // includes the property sheet functionality
#include <shlwapi.h>    // for the Str... functions!

#include <regstr.h>		// for pre-defined Registry string names
#include "Gradient.h" 	// for Gradient Fill Slider!

// Local function prototypes!
static void UpdateXYLabel           (const HWND hDlg);
static BOOL UpdateProgressLabel (const HWND hDlg);
// myitoa prototype is in cplsvr1.h
static void reverse                 (LPTSTR string);
static void RawDataSelected     (const HWND hWnd, BOOL bEnable);
static void WizFinish               (const HWND hWnd);

// Calibration procedures!
INT_PTR CALLBACK CalInitProc    (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CalXYProc          (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CalSliderProc  (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef WE_SUPPORT_CALIBRATING_POVS
INT_PTR CALLBACK CalPovProc   (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif //WE_SUPPORT_CALIBRATING_POVS

VOID CALLBACK TimerProc             (const HWND hWnd, UINT uMsg, UINT  idEvent, DWORD  dwTime);


//static void EnableSliderWindows	(const HWND hWnd, BOOL bEnable);


HWND ProgWndCal;                 // Handle to Progress Control Window
//DWORD dwUsage;  				 // Usage flags for the device being calibrated!
char nCalState;                  // Flag state variable!
char nPrevCalState;
LPMYJOYRANGE pRanges;        // Ranges recieved by the Calibration!
BOOL bShowRawData;
LPWSTR lpwszTypeName;        // Set in WM_INIT, Used in GetOEMCtrlString
LPDIJOYCONFIG_DX5 pJoyConfig; // DIJC_REGHWCONFIGTYPE information about the device!


// 
extern LPMYJOYRANGE lpCurrentRanges;
extern LPDIJOYSTATE lpDIJoyState;       // Defined in TEST.CPP
extern CDIGameCntrlPropSheet_X *pdiCpl;
extern HINSTANCE  ghInst;

HFONT hTitleFont;

static LPDIRECTINPUTDEVICE2 pdiDevice2; 
static CGradientProgressCtrl *pGradient;
static BOOL bGradient;

//****************************************************************************
//
//   FUNCTION: CreateWizard(HWND hwndOwner, LPARAM lParam)
//
//   PURPOSE: Create the Wizard control. 
//
//   COMMENTS:
//	
//      This function creates the wizard property sheet.
//****************************************************************************
short CreateWizard(const HWND hwndOwner, LPARAM lParam)
{
#ifdef WE_SUPPORT_CALIBRATING_POVS
    const BYTE nTempArray[]  = {IDD_INITIAL,  IDD_XY,     IDD_SLIDER,      IDD_POV };
    const DLGPROC pDlgProc[] = {CalInitProc,  CalXYProc,  CalSliderProc,   CalPovProc };
#else
    const BYTE nTempArray[]  = {IDD_INITIAL,  IDD_XY,     IDD_SLIDER };
    const DLGPROC pDlgProc[] = {CalInitProc,  CalXYProc,  CalSliderProc };
#endif

    HPROPSHEETPAGE  *pPages = new (HPROPSHEETPAGE[sizeof(nTempArray)/sizeof(BYTE)]);
    if( !pPages ) {
        return 0;
    }

    // Allocate and Zero the Page header memory
    PROPSHEETHEADER *ppsh = new (PROPSHEETHEADER);
    if( !ppsh ) {
        delete[] (pPages);
        return 0;
    }

    ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

    ppsh->dwSize     = sizeof(PROPSHEETHEADER);
    ppsh->dwFlags    = PSH_WIZARD_LITE | PSH_NOAPPLYNOW | PSH_USEICONID; 
    ppsh->hwndParent = hwndOwner;
    ppsh->pszIcon     = MAKEINTRESOURCE(IDI_GCICON);
    ppsh->hInstance  = ghInst;
    ppsh->phpage      = pPages;

    ppsh->pszbmWatermark = MAKEINTRESOURCE(IDB_CALHD);

    PROPSHEETPAGE *ppsp = new (PROPSHEETPAGE);
    if( !ppsp ) {
        delete[] (pPages);
        delete (ppsh);

        return 0;
    }

    ZeroMemory(ppsp, sizeof(PROPSHEETPAGE));

    ppsp->dwSize      = sizeof(PROPSHEETPAGE);
// ppsp->pszTitle    = MAKEINTRESOURCE(nTabID);
    ppsp->hInstance   = ghInst;
    ppsp->lParam        = lParam;

    while( ppsh->nPages < (sizeof(nTempArray)/sizeof(BYTE)) ) {
        ppsp->pfnDlgProc  = pDlgProc[ppsh->nPages];
        ppsp->pszTemplate = MAKEINTRESOURCE(nTempArray[ppsh->nPages]);

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(ppsp);

        ppsh->nPages++;
    }

    if( ppsp )
        delete (ppsp);

    short nRet = (short)PropertySheet(ppsh);

    if( pPages )
        delete[] (pPages);

    // Clean up!
    if( ppsh )
        delete (ppsh);

    return(nRet);
}

//*******************************************************************************
//
//   FUNCTION: CalInitProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure for Start-up screen
//
//   COMMENTS:	This function is responsible for display of text and bitmap.
//					Since it is also the only page that is Guarenteed to be hit,
//					it is also responsible for creating, deleteing, and storing 
//					everything for the calibration wizard.
//	
//*******************************************************************************
INT_PTR CALLBACK CalInitProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HFONT hBoldFont;
    static PVOID hNotifyDevNode;     

    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

#ifdef _UNICODE
    case WM_DEVICECHANGE:  
        if( (UINT)wParam == DBT_DEVICEREMOVECOMPLETE )
            ::PostMessage(GetParent(hWnd), WM_COMMAND, IDCANCEL, 0);
        break;
#endif
        // OnInit
    case WM_INITDIALOG:
        // Init to FALSE to turn off Gradient fill!
        bGradient = FALSE;

        // According to knowlege base artical Q138505, this is the prescribed method of removing 
        // the context sensitive help '?' from the title bar.
        {
            LONG style = ::GetWindowLong(GetParent(hWnd), GWL_EXSTYLE);
            style &= ~WS_EX_CONTEXTHELP;

            HWND hParent = GetParent(hWnd);

            ::SetWindowLong(hParent, GWL_EXSTYLE, style);


            // Set up the Device Notification
#ifdef _UNICODE
            RegisterForDevChange(hWnd, &hNotifyDevNode);
#endif
            HDC myDC = GetDC(hWnd);
            if( myDC ) {     // Prefix Whistler 45095
                hTitleFont = CreateFont(-MulDiv(8, GetDeviceCaps(myDC, LOGPIXELSY), 72), 0, 0, 
                                        0, FW_SEMIBOLD, FALSE, 
                                        FALSE, FALSE, DEFAULT_CHARSET, 
                                        OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, 
                                        DEFAULT_PITCH | FF_DONTCARE, TEXT("MS Shell Dlg"));

                // Do the Create font thing...
                hBoldFont = CreateFont(-MulDiv(15, GetDeviceCaps(myDC, LOGPIXELSY), 72), 0, 0, 
                                       0, FW_SEMIBOLD, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, 
                                       PROOF_QUALITY, DEFAULT_PITCH | FF_ROMAN, TEXT("MS Shell Dlg")); 

                ReleaseDC(hWnd, myDC);
            }
            
            if( hBoldFont )
                ::SendDlgItemMessage(hWnd, IDC_INIT_TITLE, WM_SETFONT, (WPARAM)hBoldFont, TRUE);

            CenterDialog(hWnd);

            ::PostMessage(hParent, PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT);

            bShowRawData = FALSE;

            // Allocate the memory for the ranges!
            pRanges = new MYJOYRANGE;
            assert(pRanges);

            // Set Everything to
            ZeroMemory(pRanges, sizeof(MYJOYRANGE));

            // Get the "best guess" ranges...
            CopyMemory(pRanges, lpCurrentRanges, sizeof(MYJOYRANGE));

            pdiCpl->GetDevice(&pdiDevice2);

            // Attempt to Set them... die if you can't!
            SetMyRanges(pdiDevice2, pRanges, pdiCpl->GetStateFlags()->nAxis);

            if( FAILED(GetLastError()) ) {
                Error(hWnd, (short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
                PostMessage(GetParent(hWnd), WM_SYSCOMMAND, SC_CLOSE, 0L);
            }

            pJoyConfig = new(DIJOYCONFIG_DX5);
            assert (pJoyConfig);

            pJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

            LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
            pdiCpl->GetJoyConfig(&pdiJoyConfig);

            HRESULT hres;

            // Retrieve and store Hardware Configuration about the device!
            hres = pdiJoyConfig->GetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE);

            if( SUCCEEDED(hres) ) {
                bPolledPOV = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_HASPOV) && (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL);
                CalibratePolledPOV( &pJoyConfig->hwc );
            }

        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        return(LRESULT)GetStockObject(WHITE_BRUSH);

    case WM_DESTROY:
        if( pJoyConfig )
            delete (pJoyConfig);

        if( lpwszTypeName )
            LocalFree(lpwszTypeName);

        pdiDevice2->Unacquire();
        SetCalibrationMode( FALSE );

        if( hTitleFont )
            DeleteObject((HGDIOBJ)hTitleFont);

        if( hBoldFont )
            DeleteObject((HGDIOBJ)hBoldFont);

// if you call this function you will hang up the system for 30 seconds or more!!!
#ifdef _UNICODE
        if( hNotifyDevNode )
            UnregisterDeviceNotification(hNotifyDevNode);
#endif // _UNICODE
        break;
    }               
    return(DefWindowProc(hWnd, uMsg, wParam, lParam));
}

//*******************************************************************************
//
//   FUNCTION: CalXYProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure for first three stages of calibration
//
//   COMMENTS:	This function is responsible for capture of X/Y and Center values!
//	
//*******************************************************************************
INT_PTR CALLBACK CalXYProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

        // OnInit
    case WM_INITDIALOG:
        {
            // set up the local globals
            nCalState = JCS_XY_CENTER1;
            nPrevCalState = JCS_INIT;

            // Get the JoyConfig Interface Pointer!
            LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
            pdiCpl->GetJoyConfig(&pdiJoyConfig);

            if( SUCCEEDED(pdiJoyConfig->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND)) ) {
                // Set the font for the 
                ::SendDlgItemMessage(hWnd, IDC_WIZARD_MSG_HDR, WM_SETFONT, (WPARAM)hTitleFont, TRUE);

                lpwszTypeName = StrDupW(pJoyConfig->wszType);

                // This sets up the Windows and the global ProgWndCal!
                UpdateXYLabel(hWnd);

                // Set up for first round
                CalStateChange( hWnd, (BYTE)pJoyConfig->hwc.hws.dwFlags );

                VERIFY(SUCCEEDED(SetCalibrationMode(TRUE)));
                VERIFY(FAILED(pdiDevice2->Acquire()));
            }
        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        // We only want to paint the background for the items in the top white rectangle!
        switch( GetDlgCtrlID((HWND)lParam) ) {
        case IDC_WIZARD_MSG:
        case IDC_HEADERFRAME:
        case IDC_WIZARD_MSG_HDR:
            return(LRESULT)GetStockObject(WHITE_BRUSH);
        }
        return(FALSE);

        // OnNotify
    case WM_NOTIFY:
        switch( ((NMHDR FAR *) lParam)->code ) {
        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_CAL_TIMER);
            break;

        case PSN_RESET:
            // reset to the original values
            KillTimer(hWnd, ID_CAL_TIMER);
            break;

        case PSN_SETACTIVE:
            SetTimer( hWnd, ID_CAL_TIMER, CALIBRATION_INTERVAL, (TIMERPROC)TimerProc);

            // Sorry, you can't go back to the first page... 
            if( nCalState > JCS_XY_CENTER1 )
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT | PSWIZB_BACK);
            else
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT);
            break;

        case PSN_WIZBACK:
            // Determine what the next calibration stage is!
            // Look out... we're backing up!
            if( nCalState == nPrevCalState )
                nPrevCalState--;

            nCalState = nPrevCalState;

            CalStateChange(hWnd, (BYTE)pJoyConfig->hwc.hws.dwFlags);

            // No more backing up!
            if( nCalState == JCS_XY_CENTER1 )
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT);

            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_XY_CENTER1) ? IDD_INITIAL : -1);
            return(nCalState < JCS_XY_CENTER1) ?  IDD_INITIAL : -1;


        case PSN_WIZNEXT:
            nPrevCalState = nCalState;

            ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT | PSWIZB_BACK);

#if 0
            // Determine what the next calibration stage is!
    #ifndef DEADZONE
            //while ((!(pdiCpl->GetStateFlags()->nAxis & 1<<nCalState++)) && (nCalState < JCS_FINI));
            nCalState++;
    #else
            nCalState++;
    #endif // DEADZONE
#endif

            while( (!(pdiCpl->GetStateFlags()->nAxis & (1<<nCalState++) )) && (nCalState < JCS_FINI) );

            if( nCalState > JCS_FINI )
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH | PSWIZB_BACK);
            else if( nCalState < JCS_Z_MOVE )
                CalStateChange( hWnd, (BYTE)pJoyConfig->hwc.hws.dwFlags );


            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_Z_MOVE) ? -1 : IDD_SLIDER );
            return(nCalState < JCS_Z_MOVE) ?  -1 : IDD_SLIDER;


        default:
            return(FALSE);
        }
        break;

        // OnCommand
    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        case IDC_RAWDATA:
            RawDataSelected(hWnd, bShowRawData = !bShowRawData);
            break;
        }
        break;

        // OnDestroy
    case WM_DESTROY:
        if( pRanges ) {
            delete (pRanges);
            pRanges = NULL;
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);   
}


//****************************************************************************
//
//   FUNCTION: CalSliderProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure 
//
//   COMMENTS:
//	
//      This function creates the wizard property sheet.
//****************************************************************************
INT_PTR CALLBACK CalSliderProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        // Set the Control font!
        ::SendDlgItemMessage(hWnd,IDC_WIZARD_MSG_HDR, WM_SETFONT, (WPARAM)hTitleFont, TRUE);

#ifdef DEADZONE
        ::SendDlgItemMessage(hWnd, IDC_DEADZONE_TITLE,   WM_SETFONT, (WPARAM)hTitleFont, TRUE);
        ::SendDlgItemMessage(hWnd, IDC_SATURATION_TITLE, WM_SETFONT, (WPARAM)hTitleFont, TRUE);
#endif //DEADZONE

        // Setup the Progress bar!
        ProgWndCal = GetDlgItem(hWnd, IDC_SLIDER);

        // do the Gradient fill maddness!
        {
            HDC hDC = ::GetWindowDC(hWnd);
            if( hDC ) {
                bGradient = (BOOL)(GetDeviceCaps(hDC, NUMCOLORS) < 0);

                if( bGradient ) {
                    pGradient = new (CGradientProgressCtrl);
                    pGradient->SubclassWindow(GetDlgItem(hWnd, IDC_SLIDER)); 
                    pGradient->SetDirection(HORIZONTAL);
                    //pGradient->ShowPercent();
                    pGradient->SetStartColor(COLORREF(RGB(0,0,255)));
                    pGradient->SetEndColor(COLORREF(RGB(0,0,0)));
                    pGradient->SetBkColor(COLORREF(RGB(180,180,180)));
                }
                ::ReleaseDC(hWnd, hDC);
            }
        }

        if( nCalState < JCS_FINI ) {
            // UpdateProgressLabel MUST be called Before CalStateChange!!!
            UpdateProgressLabel(hWnd);

            // If we're not using the gradient control, set the bar
            // colour PBM_SETBARCOLOR is WM_USER+9... YES, it's undocumented...
            if( !bGradient ) {
                ::PostMessage(ProgWndCal, WM_USER+9, 0, (LPARAM)ACTIVE_COLOR);
            }
        } else {
           ::PostMessage(GetParent(hWnd), PSM_PRESSBUTTON, (WPARAM)(int)PSBTN_NEXT, 0);
        }
        break;

    case WM_DESTROY:
        if( bGradient )
            if( pGradient )
                delete (pGradient);
        break;

        // OnCommand
    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        case IDC_RAWDATA:
            RawDataSelected(hWnd, bShowRawData = !bShowRawData);

            if( bGradient )
                pGradient->ShowPercent(bShowRawData);
            break;
        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        // We only want to paint the background for the items in the top white rectangle!
        switch( GetDlgCtrlID((HWND)lParam) ) {
        case IDC_WIZARD_MSG:
        case IDC_HEADERFRAME:
        case IDC_WIZARD_MSG_HDR:
            return(LRESULT)GetStockObject(WHITE_BRUSH);
        }
        return(FALSE);

    case WM_NOTIFY:
        switch( ((NMHDR FAR *) lParam)->code ) {
        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_CAL_TIMER);
            break;

        case PSN_SETACTIVE:
            // Set up for first round
            CalStateChange( hWnd, (BYTE)NULL );
            SetTimer( hWnd, ID_CAL_TIMER, CALIBRATION_INTERVAL, (TIMERPROC)TimerProc);
            ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT | PSWIZB_BACK);
            break;

        case PSN_WIZBACK:
            // Determine what the previous calibration stage is!
            if( nCalState == nPrevCalState ) {
                DWORD dwAxis = pdiCpl->GetStateFlags()->nAxis;
                nPrevCalState --;

                while( ( !(dwAxis & (1<<(--nPrevCalState)) ) ) && (nPrevCalState > JCS_XY_CENTER2) ){
                    ;
                }
                
                nPrevCalState ++;
            }

            nCalState = nPrevCalState;

            if( nCalState > JCS_XY_CENTER2 ) {
                // UpdateProgressLabel MUST be called Before CalStateChange!!!
                UpdateProgressLabel(hWnd);

                CalStateChange( hWnd, (BYTE)NULL );
            }

            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_Z_MOVE) ? IDD_XY : -1);
            return(nCalState < JCS_Z_MOVE) ?  IDD_XY : -1;

        case PSN_WIZNEXT:
            nPrevCalState = nCalState;

            // Determine what the next calibration stage is!
            while( (!(pdiCpl->GetStateFlags()->nAxis & 1<<nCalState++)) && (nCalState < JCS_FINI) );

            if( nCalState <=  JCS_S1_MOVE ) {
                UpdateProgressLabel(hWnd);
                
#ifdef WE_SUPPORT_CALIBRATING_POVS
            } else if( bPolledPOV ) {
                nCalState = JCS_S1_MOVE + 1;
                
                SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, IDD_POV );

                return(IDD_POV);
#endif
            } else {
                // Remove the dialog items you no longer need...
                //EnableSliderWindows(hWnd, FALSE);
                const short nCtrlArray[] = {IDC_SLIDER, IDC_RAWDATA, IDC_RAWX, IDC_RAWXOUTPUT, IDC_JOYLIST2_LABEL};
                BYTE nSize = sizeof(nCtrlArray)/sizeof(short);

                do {
                    SetWindowPos( GetDlgItem(hWnd, nCtrlArray[--nSize]), NULL, NULL, NULL, NULL, NULL, 
                                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW );
                } while( nSize );

                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH);
            }

            CalStateChange( hWnd, (BYTE)NULL );

            // we have no further pages, so don't allow them to go any further!
            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, -1);
            
            return(-1);


        case PSN_WIZFINISH:
            WizFinish(hWnd);
            break;

        default:
            return(FALSE);

        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);   
}

//*******************************************************************************
//
//   FUNCTION: EnableSliderWindows(HWND hWnd, BOOL bEnable)
//
//   PURPOSE: 	Procedure to Show/Hide dialog controls during CalSliderProc's life
//
//   COMMENTS:	
//	
//*******************************************************************************
/*
void EnableSliderWindows(const HWND hWnd, BOOL bEnable)
{
    const short nCtrlArray[] = {IDC_SLIDER, IDC_RAWDATA, IDC_RAWX, IDC_RAWXOUTPUT, IDC_JOYLIST2_LABEL};
    BYTE nSize = sizeof(nCtrlArray)/sizeof(short);

    do
    {
       SetWindowPos( GetDlgItem(hWnd, nCtrlArray[--nSize]), NULL, NULL, NULL, NULL, NULL, 
           SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | (bEnable ? SWP_SHOWWINDOW : SWP_HIDEWINDOW ));
    } while (nSize);
}
*/
#ifdef WE_SUPPORT_CALIBRATING_POVS 
//****************************************************************************
//
//   FUNCTION: CalPovProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure 
//
//   COMMENTS:
//	
//      This function creates the wizard property sheet.
//****************************************************************************
INT_PTR CALLBACK CalPovProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) {
    case WM_ACTIVATEAPP:
        if( lpDIJoyState )
            DoTestPOV(FORCE_POV_REFRESH, lpDIJoyState->rgdwPOV, hWnd);
        break;

    case WM_INITDIALOG:
    {
        // Set the POV position to the Up position and Set the Text!
        nCalState = JCS_POV_MOVEUP;

        HWND hwndPOV = GetDlgItem(hWnd, IDC_JOYPOV);
        // Disable RTL flag
        SetWindowLongPtr(hwndPOV, GWL_EXSTYLE, GetWindowLongPtr(hwndPOV,GWL_EXSTYLE)&~WS_EX_LAYOUTRTL);

        // Set the Control font!
        ::SendDlgItemMessage(hWnd,IDC_WIZARD_MSG_HDR, WM_SETFONT, (WPARAM)hTitleFont, TRUE);
        break;
    }
    
    case WM_DESTROY:
        break;

    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        case IDC_RAWDATA:
            RawDataSelected(hWnd, bShowRawData = !bShowRawData);
            break;

        case IDC_SETPOV:

            //if( joyGetPosEx(pdiCpl->GetID(), lpJoyInfo) == JOYERR_NOERROR ) {
            if( SUCCEEDED(DIUtilPollJoystick(pdiDevice2, lpDIJoyState)) ) {
                CollectCalInfo(hWnd, lpDIJoyState);
                // Insert the POV information!
                switch( nCalState ) {
                case JCS_POV_MOVEUP:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_FORWARD] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_FORWARD] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    
                    // Once you're here... disable the buttons... no going back and forth...
                    ::SendMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_DISABLEDFINISH);
                    break;

                case JCS_POV_MOVERIGHT:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_RIGHT] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_RIGHT] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    break;

                case JCS_POV_MOVEDOWN:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_BACKWARD] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_BACKWARD] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    break;

                case JCS_POV_MOVELEFT:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_LEFT] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_LEFT] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH);

                    // Take away the controls... it's all over!
                    DestroyWindow(GetDlgItem(hWnd, IDC_JOYPOV));
                    DestroyWindow(GetDlgItem(hWnd, IDC_SETPOV));
                    break;
                }
            }

            nCalState++;
            CalStateChange(hWnd, NULL);

            // Set the focus back to IDC_SETPOV button!
            SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, IDC_SETPOV), (LPARAM)TRUE);
            break;
        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        // We only want to paint the background for the items in the top white rectangle!
        switch( GetDlgCtrlID((HWND)lParam) ) {
        case IDC_WIZARD_MSG:
        case IDC_HEADERFRAME:
        case IDC_WIZARD_MSG_HDR:
            return(LRESULT)GetStockObject(WHITE_BRUSH);
        }
        return(FALSE);


    case WM_NOTIFY:
        switch( ((NMHDR FAR *) lParam)->code ) {
        
        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_CAL_TIMER);
            return(TRUE);

        case PSN_RESET:
            break;

        case PSN_SETACTIVE:
            if( nCalState == JCS_POV_MOVEUP ) {
                DoTestPOV(FORCE_POV_REFRESH, lpDIJoyState->rgdwPOV, hWnd);
            }
            CalStateChange(hWnd, NULL);
            break;

        case PSN_WIZFINISH:
            WizFinish(hWnd);
            break;

        case PSN_WIZBACK:
            // Determine what the next calibration stage is!
            if( nCalState == nPrevCalState ) {
                DWORD dwAxis = pdiCpl->GetStateFlags()->nAxis;
                nPrevCalState --;

                while( ( !(dwAxis & (1<<(--nPrevCalState)) ) ) && (nPrevCalState > JCS_XY_CENTER2) ){
                    ;
                }
                
                nPrevCalState ++;
            }

            nCalState = nPrevCalState;

            if( nCalState > JCS_XY_CENTER2 ) {
                if( nCalState <=  JCS_S1_MOVE ) {
                    UpdateProgressLabel(hWnd);
                    
                    CalStateChange( hWnd, (BYTE)NULL );
                } else if( bPolledPOV ) {
                    SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, IDD_POV );

                    return(IDD_POV);
                }
            } else {
                SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_Z_MOVE) ? IDD_XY : -1);
                return(nCalState < JCS_Z_MOVE) ?  IDD_XY : -1;
            }

            break;

        case PSN_WIZNEXT:
            // Take away the controls... it's all over!
            DestroyWindow(GetDlgItem(hWnd, IDC_JOYPOV));
            DestroyWindow(GetDlgItem(hWnd, IDC_SETPOV));

            // Go on to Finish!
            nCalState = JCS_FINI;
            CalStateChange(hWnd, NULL);

            // Get rid of Back and bring on Finish!
            ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH);

            break;

        default:
            return(FALSE);

        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);   
}
#endif // WE_SUPPORT_CALIBRATING_POVS 

//*******************************************************************************
//
//   FUNCTION: CalStateChange( HWND hDlg, BYTE nDeviceFlags )
//
//   PURPOSE: 	Procedure to set up the dialog for its' Next stage
//
//   COMMENTS:	
//	
//*******************************************************************************
void CalStateChange( HWND hDlg, BYTE nDeviceFlags )
{
    short nMsgID   = IDS_JOYCAL_MOVE;
    short nTitleID = IDS_AXIS_CALIBRATION;

#define MAX_CAL_VAL 0xfffffff

    switch( nCalState ) {
    case JCS_XY_CENTER1:
    case JCS_XY_CENTER2:
        // Set up the string ID
        if( nDeviceFlags & JOY_HWS_ISYOKE )
            nMsgID = IDS_JOYCALXY_CENTERYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL )
            nMsgID = IDS_JOYCALXY_CENTERCAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD )
            nMsgID = IDS_JOYCALXY_CENTERGAMEPAD;
        else nMsgID = IDS_JOYCALXY_CENTER;

        // Setup the Header TextID
        nTitleID    = (nCalState == JCS_XY_CENTER1) ? IDS_CENTER_HDR : IDS_VERIFY_CENTER_HDR;

        EnableXYWindows( hDlg ); 
        break;

    case JCS_XY_MOVE:

        // Set up the string ID
        if( nDeviceFlags & JOY_HWS_ISYOKE )
            nMsgID = IDS_JOYCALXY_MOVEYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL )
            nMsgID = IDS_JOYCALXY_MOVECAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD )
            nMsgID = IDS_JOYCALXY_MOVEGAMEPAD;
        else nMsgID = IDS_JOYCALXY_MOVE;

        // Blast the data so we are sure to get the correct data!
        pRanges->jpMin.dwX =  MAX_CAL_VAL;
        pRanges->jpMax.dwX = -MAX_CAL_VAL;

        pRanges->jpMin.dwY =  MAX_CAL_VAL;
        pRanges->jpMax.dwY = -MAX_CAL_VAL;

        EnableXYWindows( hDlg ); 
        break;

/*
    case JCS_XY_CENTER1:
      // Set up the string ID
      if ( nDeviceFlags & JOY_HWS_ISYOKE ) 
           nMsgID = IDS_JOYCALXY_CENTERYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL ) 
            nMsgID = IDS_JOYCALXY_CENTERCAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD ) 
            nMsgID = IDS_JOYCALXY_CENTERGAMEPAD;
        else nMsgID = IDS_JOYCALXY_CENTER;

        // Setup the Header TextID
        nTitleID	= IDS_CENTER_HDR;

      EnableXYWindows( hDlg ); 
        break;

   case JCS_XY_MOVE:

      // Set up the string ID
       if( nDeviceFlags & JOY_HWS_ISYOKE ) 
           nMsgID = IDS_JOYCALXY_MOVEYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL ) 
            nMsgID = IDS_JOYCALXY_MOVECAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD ) 
            nMsgID = IDS_JOYCALXY_MOVEGAMEPAD;
        else nMsgID = IDS_JOYCALXY_MOVE;

      // Blast the data so we are sure to get the correct data!
      pRanges->jpMin.dwX =  MAX_CAL_VAL;
      pRanges->jpMax.dwX = -MAX_CAL_VAL;

      pRanges->jpMin.dwY =  MAX_CAL_VAL;
      pRanges->jpMax.dwY = -MAX_CAL_VAL;

      EnableXYWindows( hDlg ); 
       break;

    case JCS_XY_CENTER2:

      // Set up the string ID
        if( nDeviceFlags & JOY_HWS_ISYOKE ) 
            nMsgID = IDS_JOYCALXY_CENTERYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL ) 
            nMsgID = IDS_JOYCALXY_CENTERCAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD ) 
            nMsgID = IDS_JOYCALXY_CENTERGAMEPAD;
        else nMsgID = IDS_JOYCALXY_CENTER;

        // Setup the Header TextID
        nTitleID	= IDS_VERIFY_CENTER_HDR;

        EnableXYWindows( hDlg );
       break;
*/
#ifdef DEADZONE
    case JCS_DEADZONE:
        // Set up the message string.
        if( nDeviceFlags & JOY_HWS_ISYOKE )
            nMsgID = IDS_YOKE_DEADZONE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL )
            nMsgID = IDS_CAR_DEADZONE;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD )
            nMsgID = IDS_GAMEPAD_DEADZONE;
        else nMsgID = IDS_JOYSTICK_DEADZONE;

        // Set up the title string!
        nTitleID = IDS_DEADZONE_TITLE;

        // Setup the controls!
        EnableXYWindows( hDlg );

        // Text Labels are sent in during UpdateXYLabel!
        // Text fonts are set on INIT!

        // Setup the Spin positions!
        {
            DIPROPDWORD DIPropDW;

            ZeroMemory(DIPropDW, sizeof(DIPROPDWORD));

            DIPropDW.diph.dwSize          = sizeof(DIPROPDWORD);
            DIPropDW.diph.dwHeaderSize    = sizeof(DIPROPHEADER);
            DIPropDW.diph.dwObj           = DIJOFS_X;
            DIPropDW.diph.dwHow           = DIPH_BYOFFSET;

            HWND hSpinCtrl;

            // Deadzone first...
            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_DEADZONE, &DIPropDW.diph)) ) {
                // First the Deadzone...
                hSpinCtrl = GetDlgItem(hDlg, IDC_X_DEADZONE_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(DIPropDW.dwData, 0));
            }

            // Setup the DIPROPDWORD struct!
            DIPropDW.diph.dwObj           = DIJOFS_Y;

            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_DEADZONE, &DIPropDW.diph)) ) {
                // First the Deadzone...
                hSpinCtrl = GetDlgItem(hDlg, IDC_Y_DEADZONE_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(DIPropDW.dwData, 0));
            }

            // Now, the Saturation!
            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_SATURATION, &DIPropDW.diph)) ) {
                hSpinCtrl = GetDlgItem(hDlg, IDC_Y_SATURATION_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(DIPropDW.dwData, 0));
            }

            // Setup the DIPROPDWORD struct!
            DIPropDW.diph.dwObj           = DIJOFS_X;


            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_SATURATION, &DIPropDW.diph)) ) {
                hSpinCtrl = GetDlgItem(hDlg, IDC_X_SATURATION_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(DIPropDW.dwData, 0));
            }
        }

        // Draw the rectangle!

        break;
#endif //DEADZONE

    case JCS_Z_MOVE:
        {
            static long nMin = pRanges->jpMin.dwZ;
            static long nMax = pRanges->jpMax.dwZ;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwZ =  MAX_CAL_VAL;
            pRanges->jpMax.dwZ = -MAX_CAL_VAL;
        }
        break;

    case JCS_R_MOVE:
        {
            static long nMin = pRanges->jpMin.dwRx;
            static long nMax    = pRanges->jpMax.dwRx;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwRx =  MAX_CAL_VAL;
            pRanges->jpMax.dwRx = -MAX_CAL_VAL;
        }
        break;

    case JCS_U_MOVE:
        {
            static long nMin = pRanges->jpMin.dwRy;
            static long nMax = pRanges->jpMax.dwRy;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwRy =  MAX_CAL_VAL;
            pRanges->jpMax.dwRy = -MAX_CAL_VAL;
        }
        break;

    case JCS_V_MOVE:
        {
            static long nMin = pRanges->jpMin.dwRz;
            static long nMax = pRanges->jpMax.dwRz;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwRz =  MAX_CAL_VAL;
            pRanges->jpMax.dwRz = -MAX_CAL_VAL;
        }
        break;

    case JCS_S0_MOVE:
        {
            static long nMin = pRanges->jpMin.dwS0;
            static long nMax    = pRanges->jpMax.dwS0;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwS0 =  MAX_CAL_VAL;
            pRanges->jpMax.dwS0 = -MAX_CAL_VAL;
        }
        break;

    case JCS_S1_MOVE:
        {
            static long nMin = pRanges->jpMin.dwS1;
            static long nMax    = pRanges->jpMax.dwS1;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwS1 =  MAX_CAL_VAL;
            pRanges->jpMax.dwS1 = -MAX_CAL_VAL;
        }
        break;

#ifdef WE_SUPPORT_CALIBRATING_POVS
    case JCS_POV_MOVEUP:
        lpDIJoyState->rgdwPOV[0] = JOY_POVFORWARD;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;

    case JCS_POV_MOVERIGHT:
        lpDIJoyState->rgdwPOV[0] = JOY_POVRIGHT;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;

    case JCS_POV_MOVEDOWN:
        lpDIJoyState->rgdwPOV[0] = JOY_POVBACKWARD;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;

    case JCS_POV_MOVELEFT:
        lpDIJoyState->rgdwPOV[0] = JOY_POVLEFT;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;
#endif //WE_SUPPORT_CALIBRATING_POVS

    case JCS_FINI:
        nMsgID   = IDS_JOYCAL_DONE;
        nTitleID = IDS_CALIBRATION_FINI;
        break;

    default:
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF.DLL: CAL.CPP: CalStateChange: nCalState doesn't match any known Calibration States!\n"));
#endif
        return;

    }  // END OF SWITCH

    // load and set the text
    TCHAR lptszMsg[MAX_STR_LEN];

    DWORD nStrLen =sizeof(lptszMsg) - 1;

    // see if there is any OEM text specified
    if( pJoyConfig->hwc.dwUsageSettings & JOY_US_ISOEM ) {
        GetOEMCtrlString(lptszMsg, &nStrLen);
    } else {
    	nStrLen = 0;
    }

    // nStrLen will be non-zero if GetOEMCtrlString is successfull!
    if( nStrLen == 0 ) {
        VERIFY(LoadString(ghInst, nMsgID, lptszMsg, MAX_STR_LEN));

        switch( nMsgID ) {
        case IDS_JOYCAL_MOVE:
            {
                TCHAR lptszBuff[STR_LEN_32];
                LPTSTR lpDup = StrDup(lptszMsg);

                if( lpDup ) {
                    ::SendDlgItemMessage(hDlg, IDC_JOYLIST2_LABEL, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)lptszBuff);
                    if( lstrlen(lpDup) + lstrlen(lptszBuff) < MAX_STR_LEN ) {
                        wsprintf(lptszMsg, lpDup, lptszBuff);
                    } else {
#ifdef _DEBUG
                        OutputDebugString(TEXT("Cal.cpp: can't make correct joycalmove label.\n"));
#endif
                    }
                    LocalFree(lpDup);
                }
            }
            break;
        }
    }

    // Send the smaller message
    ::SendDlgItemMessage(hDlg, IDC_WIZARD_MSG, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)lptszMsg);

    VERIFY(LoadString(ghInst, nTitleID, lptszMsg, MAX_STR_LEN));

    // Send the Bold Header message
    ::SendDlgItemMessage(hDlg, IDC_WIZARD_MSG_HDR, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)lptszMsg);

    // Take care of the RawData dialog items!
    switch( nCalState ) {
    // Don't do the raw data thing if you don't have the checkbox!
    case JCS_XY_CENTER1:
    case JCS_XY_CENTER2:
    case JCS_FINI:
        break;

        // Do the percent for the pages that need it!
    case JCS_Z_MOVE:
    case JCS_R_MOVE:
    case JCS_U_MOVE:
    case JCS_V_MOVE:
    case JCS_S0_MOVE:
    case JCS_S1_MOVE:
        if( bGradient ) {
            if( pGradient ) {
                pGradient->ShowPercent(bShowRawData);
            }
        }
        // Missing break intentional!!!

    default:
        RawDataSelected(hDlg, bShowRawData);
        ::SendDlgItemMessage(hDlg, IDC_RAWDATA, BM_SETCHECK, (bShowRawData) ? BST_CHECKED : BST_UNCHECKED, 0);
        break;
    }


} // *** end of CalStateChange 



//*******************************************************************************
//
//   FUNCTION: CollectCalInfo( HWND hDlg, LPDIJOYSTATE pdiJoyState )
//
//   PURPOSE: 	Procedure to Collect Calibration Data
//
//   COMMENTS:	
//	
//*******************************************************************************
BOOL CollectCalInfo( HWND hDlg, LPDIJOYSTATE pdiJoyState )
{
    TCHAR tsz[32]; //So the largest number can be 10^31 (>> 2^64).

    switch( nCalState ) {
    // remember XY center
    case JCS_XY_CENTER1:
        // store the initial centres!
        pRanges->jpCenter.dwY = pdiJoyState->lY;
        pRanges->jpCenter.dwX = pdiJoyState->lX;

        // We Have an X/Y, so let's check for our Pens!
        CreatePens();
        break;

        // remember max/min XY values
    case JCS_XY_MOVE:
        if( pdiJoyState->lX > pRanges->jpMax.dwX )
            pRanges->jpMax.dwX = pdiJoyState->lX;
        else if( pdiJoyState->lX < pRanges->jpMin.dwX )
            pRanges->jpMin.dwX = pdiJoyState->lX;

        if( pdiJoyState->lY > pRanges->jpMax.dwY )
            pRanges->jpMax.dwY = pdiJoyState->lY;
        else if( pdiJoyState->lY < pRanges->jpMin.dwY )
            pRanges->jpMin.dwY = pdiJoyState->lY;

        // if IDC_RAWXOUTPUT is visible, then so is IDC_RAWYOUTPUT...
        // no bother to even ask.
        if( bShowRawData ) {
            static POINT ptOld = {DELTA,DELTA};

            if( (ptOld.x != pdiJoyState->lX) || (ptOld.y != pdiJoyState->lY) ) {
                myitoa(pdiJoyState->lX, &tsz[0]);
                ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);

                myitoa(pdiJoyState->lY, &tsz[0]);
                ::SendDlgItemMessage(hDlg, IDC_RAWYOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);

                ptOld.x = pdiJoyState->lX;
                ptOld.y = pdiJoyState->lY;
            }
        }

        // Scale before send it to DoJoyMove!
        {
            RECT rc;
            GetClientRect(GetDlgItem(hDlg, IDC_JOYLIST1), &rc);

            // Casting to the UINT will change the sign!
            UINT nRange = (UINT)(pRanges->jpMax.dwX - pRanges->jpMin.dwX);

            float nScaledRange = (float)(rc.right-DELTA);

            if( nRange )
                nScaledRange /= (float)nRange;

            // Scale X
            pdiJoyState->lX = (long)((pdiJoyState->lX - pRanges->jpMin.dwX) * nScaledRange);

            // Scale Y
            if( nRange ) nScaledRange = (float)rc.bottom / (float)nRange;
            pdiJoyState->lY = (long)((pdiJoyState->lY - pRanges->jpMin.dwY) * nScaledRange);
        }
        DoJoyMove( hDlg, (BYTE)HAS_X|HAS_Y );
        break;

    case JCS_XY_CENTER2:
        // Average the Y
        pRanges->jpCenter.dwY = (pRanges->jpCenter.dwY += pdiJoyState->lY)>>1;

        //Average the X
        pRanges->jpCenter.dwX = (pRanges->jpCenter.dwX += pdiJoyState->lX)>>1;
        break;

        // remember max/min Z value
    case JCS_Z_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lZ  > pRanges->jpMax.dwZ ) {
            pRanges->jpMax.dwZ    = pdiJoyState->lZ; 
            pRanges->jpCenter.dwZ = (pRanges->jpMax.dwZ+pRanges->jpMin.dwZ)>>1;
        } else if( pdiJoyState->lZ  < pRanges->jpMin.dwZ ) {
            pRanges->jpMin.dwZ    = pdiJoyState->lZ; 
            pRanges->jpCenter.dwZ = (pRanges->jpMax.dwZ+pRanges->jpMin.dwZ)>>1;
        }

        // Do the position status
        // Update the text
        if( bShowRawData ) {
            myitoa(pdiJoyState->lZ, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lZ);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lZ, 0L);
        break;

        // remember max/min Rx value
    case JCS_R_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lRx  > pRanges->jpMax.dwRx ) {
            pRanges->jpMax.dwRx    = pdiJoyState->lRx; 
            pRanges->jpCenter.dwRx = (pRanges->jpMax.dwRx+pRanges->jpMin.dwRx)>>1;
        } else if( pdiJoyState->lRx  < pRanges->jpMin.dwRx ) {
            pRanges->jpMin.dwRx    = pdiJoyState->lRx; 
            pRanges->jpCenter.dwRx = (pRanges->jpMax.dwRx+pRanges->jpMin.dwRx)>>1;
        }

        // Do the position status
        // Update the text
        if( bShowRawData ) {
            myitoa(pdiJoyState->lRx, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lRx);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lRx, 0L);
        break;

        // remember max/min Ry value
    case JCS_U_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lRy > pRanges->jpMax.dwRy ) {
            pRanges->jpMax.dwRy    = pdiJoyState->lRy; 
            pRanges->jpCenter.dwRy = (pRanges->jpMax.dwRy+pRanges->jpMin.dwRy)>>1;
        } else if( pdiJoyState->lRy < pRanges->jpMin.dwRy ) {
            pRanges->jpMin.dwRy    = pdiJoyState->lRy; 
            pRanges->jpCenter.dwRy = (pRanges->jpMax.dwRy+pRanges->jpMin.dwRy)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->lRy, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lRy);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lRy, 0L);
        break;

        // remember max/min Rz value
    case JCS_V_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lRz > pRanges->jpMax.dwRz ) {
            pRanges->jpMax.dwRz    = pdiJoyState->lRz; 
            pRanges->jpCenter.dwRz = (pRanges->jpMax.dwRz+pRanges->jpMin.dwRz)>>1;
        } else if( pdiJoyState->lRz < pRanges->jpMin.dwRz ) {
            pRanges->jpMin.dwRz    = pdiJoyState->lRz; 
            pRanges->jpCenter.dwRz = (pRanges->jpMax.dwRz+pRanges->jpMin.dwRz)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->lRz, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lRz);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lRz, 0L);
        break;

        // remember max/min S0 value
    case JCS_S0_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->rglSlider[0] > pRanges->jpMax.dwS0 ) {
            pRanges->jpMax.dwS0    = pdiJoyState->rglSlider[0]; 
            pRanges->jpCenter.dwS0 = (pRanges->jpMax.dwS0+pRanges->jpMin.dwS0)>>1;
        } else if( pdiJoyState->rglSlider[0] < pRanges->jpMin.dwS0 ) {
            pRanges->jpMin.dwS0    = pdiJoyState->rglSlider[0]; 
            pRanges->jpCenter.dwS0 = (pRanges->jpMax.dwS0+pRanges->jpMin.dwS0)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->rglSlider[0], &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->rglSlider[0]);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->rglSlider[0], 0L);
        break;

        // remember max/min S1 value
    case JCS_S1_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->rglSlider[1] > pRanges->jpMax.dwS1 ) {
            pRanges->jpMax.dwS1    = pdiJoyState->rglSlider[1]; 
            pRanges->jpCenter.dwS1 = (pRanges->jpMax.dwS1+pRanges->jpMin.dwS1)>>1;
        } else if( pdiJoyState->rglSlider[1] < pRanges->jpMin.dwS1 ) {
            pRanges->jpMin.dwS1    = pdiJoyState->rglSlider[1]; 
            pRanges->jpCenter.dwS1 = (pRanges->jpMax.dwS1+pRanges->jpMin.dwS1)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->rglSlider[1], &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->rglSlider[1]);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->rglSlider[1], 0L);
        break;

    case JCS_POV_MOVEUP:
    case JCS_POV_MOVERIGHT:
    case JCS_POV_MOVEDOWN:
    case JCS_POV_MOVELEFT:
        // Do the position status
        /*
        if( bShowRawData ) {
            myitoa(pdiJoyState->rgdwPOV[0], &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }
        */
        break;
    }

    return(TRUE);
} // CollectCalInfo


//*******************************************************************************
//
//   FUNCTION: EnableXYWindows( HWND hDlg)
//
//   PURPOSE: 	Enables X/Y Windows
//
//   COMMENTS:	
//	
//*******************************************************************************
void EnableXYWindows( HWND hDlg )
{
    ////// set up the XY window controls ///////		  	 
    USHORT nCtrls[] = {IDC_RAWX, IDC_RAWY, IDC_RAWXOUTPUT, IDC_RAWYOUTPUT};
    BYTE nNumCtrls = sizeof(nCtrls)/sizeof(short);                                                    

    do {
        SetWindowPos( GetDlgItem( hDlg,  nCtrls[--nNumCtrls]), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);
    } while( nNumCtrls );

#ifdef DEADZONE
    {
        USHORT nDZCtrls[] = {IDC_X_DEADZONE_SPIN,   IDC_Y_DEADZONE_SPIN, IDC_X_SATURATION_SPIN,
            IDC_Y_SATURATION_SPIN, IDC_DEADZONE_TITLE,  IDC_X_DEADZONE,
            IDC_Y_DEADZONE,           IDC_X_AXIS_LABEL,    IDC_X_AXIS_LABEL,
            IDC_Y_AXIS_LABEL,     IDC_SATURATION_TITLE,IDC_X_SATURATION,
            IDC_Y_SATURATION,      IDC_X_AXIS_LABEL_SATURATION, IDC_Y_AXIS_LABEL_SATURATION};
        nNumCtrls = sizeof(nCtrls)/sizeof(short);                                                    

        do {
            // Use SetWindowPos here because internally, ShowWindow calls it!
            SetWindowPos( GetDlgItem( hDlg,  nCtrls[nNumCtrls]), NULL, NULL, NULL, NULL, NULL, 
                          SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((nCalState == JCS_DEADZONE) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
        } while( nNumCtrls-- );
    }
#endif // DEADZONE	

    nCtrls[0] = IDC_JOYLIST1;
    nCtrls[1] = IDC_JOYLIST1_LABEL;
    nCtrls[2] = IDC_RAWDATA;
    nNumCtrls = 2;

    do {
        // Use SetWindowPos here because internally, ShowWindow calls it!
        SetWindowPos( GetDlgItem( hDlg,  nCtrls[nNumCtrls]), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | (((nCalState == JCS_XY_MOVE) 
#ifdef DEADZONE
                                                                 || (nCalState == JCS_DEADZONE)
#endif
                                                                ) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
    } while( nNumCtrls-- );
    
    HWND hwndXY = GetDlgItem(hDlg, IDC_JOYLIST1);
    // Disable RTL flag
    SetWindowLongPtr( hwndXY, GWL_EXSTYLE, GetWindowLongPtr(hwndXY,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );
    
}

//*******************************************************************************
//
//   FUNCTION: GetOEMCtrlString(LPTSTR lptStr, BYTE *nStrLen)
//
//   PURPOSE: 	Gets string and string length for OEM controls
//
//   COMMENTS:	
//	
//*******************************************************************************
BOOL GetOEMCtrlString(LPTSTR lptStr, LPDWORD nStrLen)
{
    // there's no REGSTR_VAL_JOYOEM for the sliders so return false and take the defaults
    switch( nCalState ) {
        case JCS_S0_MOVE:
        case JCS_S1_MOVE:
            *nStrLen = 0;
            return(FALSE);
    }

    // Get the DIJOYCONFIG interface pointer!
    LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
    pdiCpl->GetJoyConfig(&pdiJoyConfig);

    BOOL bRet = FALSE;

    if( SUCCEEDED(pdiJoyConfig->Acquire()) ) {
        HKEY hKey;

        // Open the TypeKey
        if( SUCCEEDED(pdiJoyConfig->OpenTypeKey( lpwszTypeName, KEY_ALL_ACCESS, &hKey)) ) {
            // registry strings for calibration messages
            static LPCTSTR pszOEMCalRegStrs[] = { 
                REGSTR_VAL_JOYOEMCAL1, REGSTR_VAL_JOYOEMCAL2,
                REGSTR_VAL_JOYOEMCAL3, REGSTR_VAL_JOYOEMCAL4,
                REGSTR_VAL_JOYOEMCAL5, REGSTR_VAL_JOYOEMCAL6,
                REGSTR_VAL_JOYOEMCAL7, 

#ifdef WE_SUPPORT_CALIBRATING_POVS
                REGSTR_VAL_JOYOEMCAL8, REGSTR_VAL_JOYOEMCAL9, 
                REGSTR_VAL_JOYOEMCAL10,REGSTR_VAL_JOYOEMCAL11, 
#endif  // WE_SUPPORT_CALIBRATING_POVS
                REGSTR_VAL_JOYOEMCAL12
            };

            if( nCalState < (sizeof(pszOEMCalRegStrs)/sizeof(pszOEMCalRegStrs[0])) )
            {
                DWORD dwType = REG_SZ;
                // the -2 is because of JCS_S0_MOVE and JCS_S1_MOVE!
                if( RegQueryValueEx( hKey, pszOEMCalRegStrs[(nCalState == JCS_FINI) ? nCalState-2 : nCalState], NULL, &dwType, (CONST LPBYTE)lptStr, nStrLen ) == ERROR_SUCCESS )
                    bRet = TRUE;
                else
                    *nStrLen = 0;
            }
            else
            {
                *nStrLen = 0;
            }
            RegCloseKey(hKey);
        } else
        {
            *nStrLen = 0;
#ifdef _DEBUG
            OutputDebugString(TEXT("Cal.cpp: GetOEMCtrlString: OpenTypeKey FAILED!\n"));
#endif
        }

        pdiJoyConfig->Unacquire();
    }

    return(bRet);
} // *** end of GetOEMCtrlString


#ifdef WE_SUPPORT_CALIBRATING_POVS
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	SetDefaultButton( HWND hwdb )
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
void SetDefaultButton( HWND hDlg, HWND hCtrl )
{
    // make the specified button the default
    DWORD style = GetWindowLong( hCtrl, GWL_STYLE );
    style &= ~(BS_PUSHBUTTON|BS_DEFPUSHBUTTON);
    style |= BS_DEFPUSHBUTTON;
    SetWindowLong( hCtrl, GWL_STYLE, style );

} // SetDefaultButton
#endif //WE_SUPPORT_CALIBRATING_POVS

//===========================================================================
// SetCalibrationMode ( BOOL bSet )
// 
// Sets DirectInput Calibration mode (RAW/COOKED)
//
// Parameters:
//  BOOL					bSet			-		TRUE for RAW, FALSE for COOKED
//
// Returns:				return value from SetProperty (standard COM stuff)
//
//===========================================================================
HRESULT SetCalibrationMode( BOOL bSet)
{
    DIPROPDWORD DIPropDword;

    DIPropDword.diph.dwSize = sizeof(DIPROPDWORD);
    DIPropDword.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    DIPropDword.diph.dwObj  = 0x0;
    DIPropDword.diph.dwHow  = DIPH_DEVICE;
    DIPropDword.dwData = bSet ? DIPROPCALIBRATIONMODE_RAW : DIPROPCALIBRATIONMODE_COOKED;

    // Set the mode to Raw Data during Calibration!
    HRESULT hr = pdiDevice2->SetProperty(DIPROP_CALIBRATIONMODE, &DIPropDword.diph);
#ifdef _DEBUG
    if( FAILED(hr) ) {
        OutputDebugString(TEXT("GCDEF.DLL: CAL.CPP: SetCalibrationMode: SetProperty Failed with a return of "));

        switch( hr ) {
        case DI_PROPNOEFFECT:
            OutputDebugString(TEXT("DI_PROPNOEFFECT\n"));
            break;

        case DIERR_INVALIDPARAM:
            OutputDebugString(TEXT("DIERR_INVALIDPARAM\n"));
            break;

        case DIERR_OBJECTNOTFOUND:
            OutputDebugString(TEXT("DIERR_OBJECTNOTFOUND\n"));
            break;

        case DIERR_UNSUPPORTED:
            OutputDebugString(TEXT("DIERR_UNSUPPORTED\n"));
            break;

        default:
            {
                TCHAR szTmp[32];
                wsprintf(szTmp, TEXT("%x"), hr);
                OutputDebugString(szTmp);
            }
        }
    }
#endif
    return(hr);
}


//===========================================================================
// UpdateXYLabel(HWND hWnd)
//
// Displays the number and names of the device Axis in the provided dialog.
// This	EXPECTS that the controls are not visible by default!
//
// Parameters:
//  HWND             hDlg       - Dialog handle
//
// Returns:
//
//===========================================================================
void UpdateXYLabel(const HWND hDlg)
{
    BYTE nAxisFlags = pdiCpl->GetStateFlags()->nAxis;

    // X and Y use the same control so they are isolated!
    if( (nAxisFlags & HAS_X) || (nAxisFlags & HAS_Y) ) {
        LPDIDEVICEOBJECTINSTANCE_DX3 pDevObjInst = new (DIDEVICEOBJECTINSTANCE_DX3);
        assert (pDevObjInst);

        ZeroMemory(pDevObjInst, sizeof(DIDEVICEOBJECTINSTANCE_DX3));

        pDevObjInst->dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

        TCHAR ptszBuff[STR_LEN_32];

        ZeroMemory(ptszBuff, sizeof(ptszBuff));

        // Set it's text
        if( nAxisFlags & HAS_X ) {
            if( FAILED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_X, DIPH_BYOFFSET)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: GetObjectInfo Failed to find DIJOFS_X!\n"));
#endif
            }

            int nLen=lstrlen(pDevObjInst->tszName)+1;
            if(nLen>STR_LEN_32)
                nLen=STR_LEN_32;
            StrCpyN(ptszBuff, pDevObjInst->tszName, nLen);

            // Set the Output Label!
            ::SendDlgItemMessage(hDlg, IDC_RAWX, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);

#ifdef DEADZONE
            // Set text labels!
            ::SendDlgItemMessage(hDlg, IDC_X_AXIS_LABEL_DEADZONE,   WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
            ::SendDlgItemMessage(hDlg, IDC_X_AXIS_LABEL_SATURATION, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
#endif //DEADZONE

            // Remove the HAS_X flag
            nAxisFlags &= ~HAS_X;
        }

        if( nAxisFlags & HAS_Y ) {
            if( FAILED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_Y, DIPH_BYOFFSET)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: GetObjectInfo Failed to find DIJOFS_Y!\n"));
#endif
            }

#ifdef DEADZONE
            // Set text labels!
            ::SendDlgItemMessage(hDlg, IDC_Y_AXIS_LABEL_DEADZONE,   WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
            ::SendDlgItemMessage(hDlg, IDC_Y_AXIS_LABEL_SATURATION, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
#endif //DEADZONE

            // just in case it has Y but not X
            if( ptszBuff && lstrlen(ptszBuff) ) {   // Whisltler PREFIX 45092
                int nLen=STR_LEN_32-lstrlen(ptszBuff);
                StrNCat(ptszBuff, TEXT(" / "), nLen);
            }

            int nLen=STR_LEN_32-lstrlen(ptszBuff);
            StrNCat(ptszBuff, pDevObjInst->tszName, nLen);

            // Set the Output Label!
            ::SendDlgItemMessage(hDlg, IDC_RAWY, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);

            // Remove the HAS_Y flag
            nAxisFlags &= ~HAS_Y;
        }

        if( pDevObjInst )
            delete (pDevObjInst);

        ::SendDlgItemMessage(hDlg, IDC_JOYLIST1_LABEL, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)ptszBuff);

    }
} //*** end of UpdateXYLabel

//*******************************************************************************
//
//   FUNCTION: UpdateProgressLabel(HWND hDlg)
//
//   PURPOSE: 	Updates Axis specific labels based on the current Calibration stage.
//
//   COMMENTS:	
//	
//*******************************************************************************
BOOL UpdateProgressLabel(const HWND hDlg)
{
    // Array of supported axis!
    const DWORD dwOffsetArray[] = {DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};
    BOOL bRet = FALSE; 
    DIDEVICEOBJECTINSTANCE_DX3 DevObjInst;

    ZeroMemory(&DevObjInst, sizeof(DIDEVICEOBJECTINSTANCE_DX3));

    DevObjInst.dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

    // Get it's text
    if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)&DevObjInst, dwOffsetArray[nCalState-3], DIPH_BYOFFSET)) ) {
        // Set it's text
        ::SendDlgItemMessage(hDlg, IDC_JOYLIST2_LABEL, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)DevObjInst.tszName);
        ::SendDlgItemMessage(hDlg, IDC_RAWX,              WM_SETTEXT, 0, (LPARAM)(LPCTSTR)DevObjInst.tszName);
        bRet = TRUE;
    }

    return(bRet);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	myitoa(long n, LPTSTR lpStr)
//
// PARAMETERS:	BYTE   n     - Number to be translated
//             LPTSTR lpStr - Buffer to recieve translated value
//
// PURPOSE:	Convert BYTE values < 20 to strings.
///////////////////////////////////////////////////////////////////////////////
void myitoa(long n, LPTSTR lpStr)
{
    long sign = n;

    if( n < 0 )
        n = - n;

    LPTSTR pchStart = lpStr;

    do {
        *lpStr++ = (TCHAR)(n % 10 + '0');
    } while( (n /= 10) > 0 );

    if( sign < 0 )
        *lpStr++ = '-';
    *lpStr = '\0';
    reverse(pchStart);
}

void reverse(LPTSTR string)
{
    TCHAR c;
    short i, j;

    for( i = 0, j = lstrlen(string) - 1; i < j; i++, j-- ) {
        c = string[j];
        string[j] = string[i];
        string[i] = c;
    }
}

//*******************************************************************************
//
//   FUNCTION: RawDataSelected( HWND hWnd, BOOL bEnable )
//
//   PURPOSE: 	Shows/Hides Raw data associated windows.
//
//   COMMENTS:	
//	
//*******************************************************************************
void RawDataSelected( const HWND hWnd, BOOL bEnable )
{
    const USHORT nCtrlArray[] = {IDC_RAWX, IDC_RAWY, IDC_RAWXOUTPUT, IDC_RAWYOUTPUT};
    BYTE nCtrls = sizeof(nCtrlArray)/sizeof(short);

    do {
        SetWindowPos( GetDlgItem( hWnd,  nCtrlArray[--nCtrls]), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((bEnable) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
    } while( nCtrls );
}

//*******************************************************************************
//
//   FUNCTION: TimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
//
//   PURPOSE: 	TimerProc for the Calibration Wizard.
//					Searches for button presses, then moves to next stage/finish.
//
//   COMMENTS:	
//	
//*******************************************************************************
VOID CALLBACK TimerProc(const HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    if( SUCCEEDED(DIUtilPollJoystick(pdiDevice2, lpDIJoyState)) ) {
        CollectCalInfo(hWnd, lpDIJoyState);

        // Don't bother checking for key presses if the user is in the POV stage!
        if( nCalState <= JCS_S1_MOVE ) {
            // Catch button presses...
            static BYTE nDownButton = 0xff;
            BYTE i = 0;

            int nButtons = pdiCpl->GetStateFlags()->nButtons;

            // only attempt to check buttons we KNOW we have!!!
            while( nButtons ) {
                // check for a button press
                if( lpDIJoyState->rgbButtons[i] & 0x80 ) {
                    if( nDownButton != 0xff )
                        break;

                    // Let the Next button handle the processing
                    ::PostMessage(GetParent(hWnd), PSM_PRESSBUTTON, (WPARAM)(int)(nCalState > JCS_S1_MOVE) ? PSBTN_FINISH : PSBTN_NEXT, 0);

                    // Store the button that went down!
                    nDownButton = i;

                    // mission accomplished!
                    return;
                }
                // reset the nDownButton flag
                else if( i == nDownButton )
                    nDownButton = 0xff;

                nButtons &= ~(HAS_BUTTON1<<i++);
            } 
            // end of catch for button presses!
        }
    }
}

// This is because PSN_WIZFINISH is Documented to be sent to every page dlg proc on exit... but it doesn't!
static void WizFinish(const HWND hWnd)
{
    HRESULT hres;

    KillTimer(hWnd, ID_CAL_TIMER);

    // assign the new ranges
    SetMyRanges(pdiDevice2, pRanges, pdiCpl->GetStateFlags()->nAxis);

    LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
    pdiCpl->GetJoyConfig(&pdiJoyConfig);

    if( pdiCpl->GetStateFlags()->nPOVs ) {
        pdiDevice2->Unacquire();
        SetCalibrationMode( FALSE );
        pdiJoyConfig->Acquire();

        CopyRange( &pJoyConfig->hwc.hwv.jrvHardware, pRanges );
        memcpy( pJoyConfig->hwc.hwv.dwPOVValues, pRanges->dwPOV, sizeof(DWORD)*4 );

        hres = pdiJoyConfig->SetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE);
      #ifdef WE_SUPPORT_CALIBRATING_POVS
        if( SUCCEEDED(hres) ) {
            CalibratePolledPOV( &pJoyConfig->hwc );

            // set POV positions!
            if( bPolledPOV ) {
                SetMyPOVRanges(pdiDevice2);
            }
        }
      #endif
    }

    pdiJoyConfig->SendNotify();
    pdiDevice2->Unacquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\cplsvr1.h ===
//===========================================================================
// CPLSVR1.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

//---------------------------------------------------------------------------

// Comment out to remove FORCE_FEEDBACK PAGE!
//#define FORCE_FEEDBACK

#ifndef _CPLSVR1_H
#define _CPLSVR1_H

//---------------------------------------------------------------------------
#define INC_OLE2
#define DIRECTINPUT_VERSION      0x05B2

#ifndef PPVOID
#define PPVOID  LPVOID*
#endif

// included headers
#define STRICT
#include <afxcmn.h>
#include <windows.h>
#include <objbase.h>

#ifndef _UNICODE
#include <afxconv.h>
#endif

#include <dinput.h>
#include <dinputd.h>

#include "dicpl.h"
#include "resource.h"
#include "resrc1.h"
#include <assert.h>
#include "joyarray.h"
#include <mmsystem.h>

// symbolic constants
#define ID_POLLTIMER    50

#ifdef FORCE_FEEDBACK
#define NUMPAGES		3
#else
#define NUMPAGES        2
#endif // FORCE_FEEDBACK

// defines for calibration proc
#define MAX_STR_LEN		256
#define STR_LEN_128		128
#define STR_LEN_64		 64
#define STR_LEN_32		 32

// defines for the progress controls
#define NUM_WNDS  MAX_AXIS - 2
#define Z_INDEX  0
#define RX_INDEX 1
#define RY_INDEX 2
#define RZ_INDEX 3
#define S0_INDEX 4
#define S1_INDEX 5

// Defines for DrawCross()
#define JOYMOVE_DRAWXY	0x00000001
#define JOYMOVE_DRAWR	0x00000002
#define JOYMOVE_DRAWZ	0x00000004
#define JOYMOVE_DRAWU	0x00000008
#define JOYMOVE_DRAWV	0x00000010
#define JOYMOVE_DRAWALL	JOYMOVE_DRAWXY | JOYMOVE_DRAWR | JOYMOVE_DRAWZ | JOYMOVE_DRAWU | JOYMOVE_DRAWV

#define CAL_HIT     0x0001
#define RUDDER_HIT  0x0002
#define CALIBRATING 0x0004

#define POV_MIN    0
#define POV_MAX    1

#define HAS_CALIBRATED    0x40
#define FORCE_POV_REFRESH 254
void DoTestPOV ( BYTE nPov, PDWORD pdwPOV, HWND hDlg ); //in test.cpp
void CalibratePolledPOV( LPJOYREGHWCONFIG pHWCfg );     //in test.cpp

extern BOOL bPolledPOV;                                 //in cplsvr1.h
extern DWORD   myPOV[2][JOY_POV_NUMDIRS+1];             //in cplsvr1.h


typedef struct _CPLPAGEINFO
{
    //LPTSTR  lpwszDlgTemplate;
	USHORT lpwszDlgTemplate;
    DLGPROC fpPageProc;
} CPLPAGEINFO;

// Pop the structure packing 
//#include <poppack.h>

typedef struct _STATEFLAGS
{
	int  nButtons;
	BYTE nAxis;
	BYTE nPOVs;
} STATEFLAGS;


// prototypes
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv);
STDAPI DllCanUnloadNow(void);

// dialog callback functions
INT_PTR CALLBACK Settings_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK Test_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef FORCE_FEEDBACK
INT_PTR CALLBACK ForceFeedback_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif // FORCE_FEEDBACK

extern ATOM RegisterCustomButtonClass();
void myitoa(long n, LPTSTR lpStr); // held in cal.cpp
void CreatePens( void );

#ifdef _UNICODE
void RegisterForDevChange(HWND hDlg, PVOID *hNotifyDevNode);
#endif

// As the names imply, I had to create my own stucts because
// the DI ones doesn't support sliders!
typedef struct myjoypos_tag {
   long  dwX;
   long  dwY;
   long  dwZ;
   long  dwRx;
   long  dwRy;
   long  dwRz;
   long  dwS0;
   long  dwS1;
} MYJOYPOS, FAR *LPMYJOYPOS;

typedef struct myjoyrange_tag {
    MYJOYPOS      jpMin;
    MYJOYPOS      jpMax;
    MYJOYPOS      jpCenter;
#ifdef WE_SUPPORT_CALIBRATING_POVS
    DWORD         dwPOV[4];   // Currently only supports 1 POV w/4 possitions!
#endif    
} MYJOYRANGE,FAR *LPMYJOYRANGE;


// utility services
void DrawCross	( const HWND hwnd, LPPOINTS pPoint, short nFlag);
void DoJoyMove	( const HWND hDlg, BYTE nDrawFlags );
void SetOEMWindowText( const HWND hDlg, const short *nControlIDs, LPCTSTR *pszLabels, LPCWSTR wszType, LPDIRECTINPUTJOYCONFIG pdiJoyConfig, BYTE nCount );

// Wizard Services!
short CreateWizard(const HWND hwndOwner, LPARAM lParam);

//* NULL_GUID {00000000-0000-0000-0000-000000000000}
const GUID NULL_GUID = 
{ 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

// derive a new class from CDIGameCntrlPropSheet
//
// we want to store some additional data here
class CDIGameCntrlPropSheet_X : public IDIGameCntrlPropSheet
{
   private:
   BYTE 				m_cProperty_refcount;
   BYTE 			    m_nID;
   BOOL               	m_bUser;

   public:
   CDIGameCntrlPropSheet_X(void);
   ~CDIGameCntrlPropSheet_X(void);
   // IUnknown methods
   virtual STDMETHODIMP            	QueryInterface(REFIID, PPVOID);
   virtual STDMETHODIMP_(ULONG)    	AddRef(void);
   virtual STDMETHODIMP_(ULONG)    	Release(void);
   // IDIGameCntrlPropSheet methods		
   virtual STDMETHODIMP				GetSheetInfo(LPDIGCSHEETINFO *ppSheetInfo);
   virtual STDMETHODIMP				GetPageInfo (LPDIGCPAGEINFO  *ppPageInfo );
   virtual STDMETHODIMP				SetID(USHORT nID);
   virtual STDMETHODIMP_(USHORT)   	GetID(void)			{return m_nID;}
   virtual STDMETHODIMP       		Initialize(void);
   virtual STDMETHODIMP       		SetDevice(LPDIRECTINPUTDEVICE2 pdiDevice2);
   virtual STDMETHODIMP       		GetDevice(LPDIRECTINPUTDEVICE2 *ppdiDevice2);
   virtual STDMETHODIMP       		SetJoyConfig(LPDIRECTINPUTJOYCONFIG pdiJoyCfg);
   virtual STDMETHODIMP       		GetJoyConfig(LPDIRECTINPUTJOYCONFIG *ppdiJoyCfg);
   virtual STDMETHODIMP_(STATEFLAGS *)	GetStateFlags(void) {return m_pStateFlags;}
   virtual STDMETHODIMP_(BOOL) 		GetUser()  {return m_bUser;}
   virtual STDMETHODIMP       		SetUser(BOOL bUser) { m_bUser = bUser; return S_OK;}

   protected:
   DIGCSHEETINFO           *m_pdigcSheetInfo;
   DIGCPAGEINFO            *m_pdigcPageInfo;
   LPDIRECTINPUTDEVICE2    m_pdiDevice2;
   LPDIRECTINPUTJOYCONFIG  m_pdiJoyCfg;
   STATEFLAGS			   *m_pStateFlags;

   ATOM					   m_aPovClass, m_aButtonClass;
};

//---------------------------------------------------------------------------
#endif // _CPLSVR1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\dicputil.h ===
//===========================================================================
// DICPUTIL.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#ifndef _DICPUTIL_H
#define _DICPUTIL_H

// Max supported defines!
#define MAX_BUTTONS	32
#define MAX_AXIS		8
#define MAX_POVS		4

// State flag defines!!!
// State flags for axis
#define HAS_X			0x0001
#define HAS_Y			0x0002
#define HAS_Z			0x0004
#define HAS_RX			0x0008
#define HAS_RY			0x0010
#define HAS_RZ			0x0020
#define HAS_SLIDER0	0x0040
#define HAS_SLIDER1	0x0080

// State flags for buttons
#define HAS_BUTTON1	0x00000001
#define HAS_BUTTON2	0x00000002
#define HAS_BUTTON3	0x00000004
#define HAS_BUTTON4	0x00000008
#define HAS_BUTTON5	0x00000010
#define HAS_BUTTON6	0x00000020
#define HAS_BUTTON7	0x00000040
#define HAS_BUTTON8	0x00000080
#define HAS_BUTTON9	0x00000100
#define HAS_BUTTON10	0x00000200
#define HAS_BUTTON11	0x00000400
#define HAS_BUTTON12	0x00000800
#define HAS_BUTTON13	0x00001000
#define HAS_BUTTON14	0x00002000
#define HAS_BUTTON15	0x00004000
#define HAS_BUTTON16	0x00008000
#define HAS_BUTTON17	0x00010000
#define HAS_BUTTON18	0x00020000
#define HAS_BUTTON19	0x00040000
#define HAS_BUTTON20	0x00080000
#define HAS_BUTTON21	0x00100000
#define HAS_BUTTON22	0x00200000
#define HAS_BUTTON23	0x00400000
#define HAS_BUTTON24	0x00800000
#define HAS_BUTTON25	0x01000000
#define HAS_BUTTON26	0x02000000
#define HAS_BUTTON27	0x04000000
#define HAS_BUTTON28	0x08000000
#define HAS_BUTTON29	0x10000000
#define HAS_BUTTON30	0x20000000
#define HAS_BUTTON31	0x40000000
#define HAS_BUTTON32	0x80000000

// State flags for POVs
#define HAS_POV1		0x0001
#define HAS_POV2		0x0002
#define HAS_POV3		0x0004
#define	HAS_POV4		0x0008


//---------------------------------------------------------------------------

// prototypes
HRESULT DIUtilPollJoystick(LPDIRECTINPUTDEVICE2 pdiDevice2, LPDIJOYSTATE pdijs);


// helper functions
void GetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis);
void SetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis);
void SetMyPOVRanges(LPDIRECTINPUTDEVICE2 pdiDevice2);

//BOOL GetDeviceRanges( LPMYJOYRANGE lpMyRanges, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis);

void OnHelp(LPARAM lParam);
void OnContextMenu(WPARAM wParam);
BOOL GetHelpFileName(LPTSTR lpszHelpFileName, short* nSize);
//BOOL CALLBACK DIEnumDeviceObjectsProc( LPCDIDEVICEOBJECTINSTANCE_DX3 lpddoi, LPVOID pvStateFlags );
HRESULT InitDInput(HWND hWnd, CDIGameCntrlPropSheet_X *pdiCpl);
void EnumDeviceObjects(LPDIRECTINPUTDEVICE2 lpdiDevice2, STATEFLAGS *pStateFlags);
void SetTitle( HWND hDlg );
BOOL Error(HWND hWnd, short nTitleID, short nMsgID);
void CenterDialog(HWND hWnd);
void PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled);
void PostEnableWindow(HWND hCtrl, BOOL bEnabled);

void CopyRange( LPJOYRANGE lpjr, LPMYJOYRANGE lpmyjr );

//---------------------------------------------------------------------------
#endif _DICPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\ff.cpp ===
//===========================================================================
// FF.CPP
//
// Functions:
// ForceFeedback_DlgProc()
//
//===========================================================================
#include "cplsvr1.h"
#include "dicputil.h"

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#define ID_SLIDERTIMER	2800
#define TIMER_FREQ		850

//===========================================================================
// ForceFeedback_DlgProc
//
// Parameters:
//  HWND    hWnd    - handle to dialog window
//  UINT    uMsg    - dialog message
//  WPARAM  wParam  - message specific data
//  LPARAM  lParam  - message specific data
//
// Returns: BOOL
//
//===========================================================================
INT_PTR CALLBACK ForceFeedback_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDIGameCntrlPropSheet_X *pdiCpl; // = (CDIGameCntrlPropSheet_X*)GetWindowLong(hWnd, DWL_USER);

	static LPDIRECTINPUTDEVICE2 pdiDevice2  = NULL;
	static CSliderCtrl CReturnSlider, CForceSlider;

    switch(uMsg)
    {
		// OnInit
        case WM_INITDIALOG:
             {
				// get ptr to our object
				pdiCpl = (CDIGameCntrlPropSheet_X*)((LPPROPSHEETPAGE)lParam)->lParam;

	            // Save our pointer so we can access it later
		        SetWindowLong(hWnd, DWL_USER, (LPARAM)pdiCpl);

			    // initialize DirectInput
				if(FAILED(InitDInput(GetParent(hWnd), pdiCpl)))
	            {
		            OutputDebugString(TEXT("FF.CPP: WM_INIT: InitDInput FAILED!\n"));
			    }
                
				// Get the device2 interface pointer
				pdiCpl->GetDevice(&pdiDevice2);

				// Setup the Sliders
				HWND hCtrl = GetDlgItem(hWnd, IDC_SLIDER1);
				ASSERT (hCtrl);
				CReturnSlider.Attach(hCtrl);

				hCtrl = GetDlgItem(hWnd, IDC_SLIDER2);
				ASSERT (hCtrl);
				CForceSlider.Attach(hCtrl);


				// BLJ: TODO!!!
				// Setup the granularity of the sliders based on the device!

				// Set up timer to monitor button presses on the device!!!
				// SetTimer(hWnd, ID_SLIDERTIMER, TIMER_FREQ, 0);	
			 }
             break; // end of WM_INITDIALOG

		// OnTimer
		case WM_TIMER:
			
			 break;

		// OnDestroy
		case WM_DESTROY:
			// KillTimer(hWnd, ID_SLIDERTIMER);

			CForceSlider.Detach();
			CReturnSlider.Detach();

		 	// Get the device2 interface pointer
		 	pdiDevice2->Unacquire();
			break;  // end of WM_DESTROY
			

		// OnNotify
        case WM_NOTIFY:
			switch(((NMHDR *)lParam)->code)
			{
				case PSN_SETACTIVE:
					// Do that Acquire thing...
				    if(FAILED(pdiDevice2->Acquire()))
					{
				        OutputDebugString(TEXT("FF.CPP: PSN_SETACTIVE: Acquire() FAILED!\n"));
					}
					break;

				case PSN_KILLACTIVE:
					// Do that Unacquire thing...
				    pdiDevice2->Unacquire();
					break;
			}
            break;  // end of WM_NOTIFY
    }
      
    return FALSE;

} //*** end Test_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\dicpl.h ===
//
//                                                                       
//    This is a part of the Microsoft Direct Input SDK.                  
//    Copyright (C) 1992-1997 Microsoft Corporation                      
//    All rights reserved.                                               
//                                                                       
//    This source code is only intended as a supplement to the           
//    Microsoft Direct Input SDK References and related                  
//    electronic documentation provided with the SDK.                    
//    See these sources for detailed information regarding the           
//    Microsoft Direct Input API.                                        
//                                                                       
//

#ifndef _DX_CPL_
#define _DX_CPL_

// maximum pages allowed on a server
#define MAX_PAGES 26

// Interface ID
// {7854FB22-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IDIGameCntrlPropSheet, 
0x7854fb22, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);


//
//                                                                       
//                           STRUCTURES                                  
//                                                                       
//

// This pragma may not be supported by all compilers.
// Please consult your compiler documentation.
#include <pshpack8.h>

typedef struct 
{
	DWORD		      dwSize;           // Should be set to sizeof(DIGCPAGEINFO)
	LPWSTR  	      lpwszPageTitle;   // Text to be displayed on tab
	DLGPROC	      fpPageProc;       // Dialog Procedure for page
	BOOL		      fProcFlag;        // TRUE if you are using fpPrePostProc member
	DLGPROC	  	   fpPrePostProc;    // Pointer to Callback function that is Only called on Init!
	BOOL		      fIconFlag;        // TRUE if you are using lpwszPageIcon member
	LPWSTR		   lpwszPageIcon;    // Resource ID or name of icon
	LPWSTR         lpwszTemplate;    // Dialog template
	LPARAM		   lParam;           // Application defined data
	HINSTANCE	   hInstance;        // Handle of Instance to load Icon/Cursor
} DIGCPAGEINFO, *LPDIGCPAGEINFO;

typedef struct 
{
	DWORD		      dwSize;           // Should but set to sizeof(DIGCSHEETINFO)
	USHORT	      nNumPages;        // Number of pages on this sheet
	LPWSTR	      lpwszSheetCaption;// Text to be used in Sheet Window Title
	BOOL		      fSheetIconFlag;   // TRUE if you are using the lpwszSheetIcon member
	LPWSTR		   lpwszSheetIcon;   // Resource ID or name of icon
} DIGCSHEETINFO, *LPDIGCSHEETINFO;

#include <poppack.h>

//
//                                                                       
//         Interface as Exposed by the InProcServer Property Sheet       
//                                                                       
//
DECLARE_INTERFACE_( IDIGameCntrlPropSheet, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// IServerProperty Members
	STDMETHOD(GetSheetInfo)		(THIS_ LPDIGCSHEETINFO *) PURE; 	
	STDMETHOD(GetPageInfo)		(THIS_ LPDIGCPAGEINFO *) PURE; 	
	STDMETHOD(SetID)			(THIS_ USHORT nID) PURE;
	STDMETHOD_(USHORT,GetID)(THIS) PURE;
};
typedef IDIGameCntrlPropSheet *LPIDIGAMECNTRLPROPSHEET;

//
//                                                                       
//                CLASS DEFINITION for CServerClassFactory				     
//                                                                       
//
class CServerClassFactory : public IClassFactory
{
	protected:
		ULONG   			m_ServerCFactory_refcount;
    
	public:
		// constructor
		CServerClassFactory(void);
		// destructor
		~CServerClassFactory(void);
        
		// IUnknown methods
		STDMETHODIMP            QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG)    AddRef(void);
		STDMETHODIMP_(ULONG)    Release(void);
    
		// IClassFactory methods
		STDMETHODIMP    		CreateInstance(LPUNKNOWN, REFIID, PPVOID);
		STDMETHODIMP    		LockServer(BOOL);
};

//
//                                                                       
//				  CLASS DEFINITION for CDIGameCntrlPropSheet			        
//                                                                       
//
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	friend					      CServerClassFactory;

	private:
		DWORD				         m_cProperty_refcount;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	   STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	   STDMETHODIMP_(ULONG)    AddRef(void);
	   STDMETHODIMP_(ULONG)    Release(void);
		
		STDMETHODIMP			   GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
		STDMETHODIMP			   GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
		STDMETHODIMP			   SetID(USHORT nID);
      STDMETHODIMP_(USHORT)   GetID();
};
typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;


//
//                                                                       
//                             ERRORS                                    
//                                                                       
//
#define DIGCERR_ERRORSTART			   0x80097000
#define DIGCERR_NUMPAGESZERO	   	0x80097001
#define DIGCERR_NODLGPROC		   	0x80097002
#define DIGCERR_NOPREPOSTPROC		   0x80097003
#define DIGCERR_NOTITLE				   0x80097004
#define DIGCERR_NOCAPTION		   	0x80097005
#define DIGCERR_NOICON				   0x80097006
#define DIGCERR_STARTPAGETOOLARGE	0x80097007
#define DIGCERR_NUMPAGESTOOLARGE	   0x80097008
#define DIGCERR_INVALIDDWSIZE		   0x80097009
#define DIGCERR_ERROREND			   0x80097100

#endif // _DX_CPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\dicputil.cpp ===
//===========================================================================
// DICPUTIL.CPP
//
// DirectInput CPL helper functions.
//
// Functions:
//  DIUtilGetJoystickTypeName()
//  DIUtilPollJoystick()
//
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#include "cplsvr1.h"
#include "dicputil.h"
#include <shlwapi.h>  // for Str... functions!

extern HWND ghDlg;
extern CDIGameCntrlPropSheet_X *pdiCpl;
extern HINSTANCE  ghInst;
extern CRITICAL_SECTION gcritsect;


//===========================================================================
// DIUtilPollJoystick
//
// Polls the joystick device and returns the device state.
//
// Parameters:
//  LPDIRECTINPUTDEVICE2    pdiDevice2  - ptr to device object
//  DIJOYSTATE              *pdijs      - ptr to store joystick state
//
// Returns: HRESULT
//
//===========================================================================
HRESULT DIUtilPollJoystick(LPDIRECTINPUTDEVICE2 pdiDevice2, LPDIJOYSTATE pdijs)
{
    // clear the pdijs memory
    // this way, if we fail, we return no data
    pdijs->lX = pdijs->lY = pdijs->lZ = pdijs->lRx = pdijs->lRy = pdijs->lRz = pdijs->rglSlider[0] = pdijs->rglSlider[1] = 0;

    // poll the joystick
    HRESULT hRes; 

    if( SUCCEEDED(hRes = pdiDevice2->Poll()) )
    {
        static BOOL bFirstPoll = TRUE;

        // This is to disreguard the first poll!
        // DINPUT sends garbage the first poll.
        if( bFirstPoll )
        {
            pdiDevice2->GetDeviceState(sizeof(DIJOYSTATE), pdijs);
            bFirstPoll = FALSE;
        }

        // query the device state
        if( FAILED(hRes = pdiDevice2->GetDeviceState(sizeof(DIJOYSTATE), pdijs)) )
        {
            if( hRes == DIERR_INPUTLOST )
            {
                if( SUCCEEDED(hRes = pdiDevice2->Acquire()) )
                    hRes = pdiDevice2->GetDeviceState(sizeof(DIJOYSTATE), pdijs);
            }
        }
    }

    // done
    return(hRes);
} // *** end DIUtilPollJoystick()

//===========================================================================
// InitDInput
//
// Initializes DirectInput objects
//
// Parameters:
//  HWND                    hWnd    - handle of caller's window
//  CDIGameCntrlPropSheet_X *pdiCpl - pointer to Game Controllers property
//                                      sheet object
//
// Returns: HRESULT
//
//===========================================================================
HRESULT InitDInput(HWND hWnd, CDIGameCntrlPropSheet_X *pdiCpl)
{
    HRESULT                 hRes = S_OK;
    LPDIRECTINPUTDEVICE2    pdiDevice2;
    LPDIRECTINPUTJOYCONFIG  pdiJoyCfg;
    LPDIRECTINPUT           pdi = 0;

    // protect ourselves from multithreading problems
    EnterCriticalSection(&gcritsect);

    // validate pdiCpl
    if( (IsBadReadPtr((void*)pdiCpl, sizeof(CDIGameCntrlPropSheet_X))) ||
        (IsBadWritePtr((void*)pdiCpl, sizeof(CDIGameCntrlPropSheet_X))) )
    {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF.DLL: InitDInput() - bogus pointer\n"));
#endif
        hRes = E_POINTER;
        goto exitinit;
    }

    // retrieve the current device object
    pdiCpl->GetDevice(&pdiDevice2);   

    // retrieve the current joyconfig object
    pdiCpl->GetJoyConfig(&pdiJoyCfg);   

    // have we already initialized DirectInput?
    if( (NULL == pdiDevice2) || (NULL == pdiJoyCfg) )
    {
        // no, create a base DirectInput object
        if( FAILED(hRes = DirectInputCreate(ghInst, DIRECTINPUT_VERSION, &pdi, NULL)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DirectInputCreate() failed\n"));
#endif
            goto exitinit;
        }

        // have we already created a joyconfig object?
        if( NULL == pdiJoyCfg )
        {
            // no, create a joyconfig object
            if( SUCCEEDED(pdi->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pdiJoyCfg)) )
            {
                if( SUCCEEDED(pdiJoyCfg->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND)) )
                    pdiCpl->SetJoyConfig(pdiJoyCfg);
            } else
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: Unable to create joyconfig\n"));
#endif
                goto exitinit;
            }
        }

        // have we already created a device object?
        if( NULL == pdiDevice2 )
        {
            // no, create a device object
            if( NULL != pdiJoyCfg )
            {
                LPDIRECTINPUTDEVICE  pdiDevTemp;
                DIJOYCONFIG_DX5    DIJoyConfig;

                // get the type name
                ZeroMemory(&DIJoyConfig, sizeof(DIJOYCONFIG_DX5));

                // GetConfig will provide this information
                DIJoyConfig.dwSize = sizeof(DIJOYCONFIG_DX5);

                // Get the instance necessarey for CreateDevice
                if( SUCCEEDED(hRes = pdiJoyCfg->GetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)&DIJoyConfig, DIJC_GUIDINSTANCE)) )
                {
                    // Create the device
                    if( SUCCEEDED(hRes = pdi->CreateDevice(DIJoyConfig.guidInstance, &pdiDevTemp, NULL)) )
                    {
                        // Query the device for the Device2 interface!
                        if( SUCCEEDED(hRes = pdiDevTemp->QueryInterface(IID_IDirectInputDevice2, (LPVOID*)&pdiDevice2)) )
                        {
                            // release the temporary object
                            pdiDevTemp->Release();

                            // Set the DataFormat and CooperativeLevel!
                            if( SUCCEEDED(hRes = pdiDevice2->SetDataFormat(&c_dfDIJoystick)) )
                                hRes = pdiDevice2->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND);
                        }
                    }
                }

                if( SUCCEEDED(hRes) )
                {
                    // store the device object
                    pdiCpl->SetDevice(pdiDevice2);
                } else
                {
                    goto exitinit;
                }
            } else goto exitinit;
        }
    } else {
        goto exitinit;
    }

    // if everything is Zero, either you've never enumerated or the enumeration is suspectable
    if( (pdiCpl->GetStateFlags()->nButtons == 0) &&
        (pdiCpl->GetStateFlags()->nAxis    == 0) &&
        (pdiCpl->GetStateFlags()->nPOVs    == 0) )
    {
        EnumDeviceObjects(pdiDevice2, pdiCpl->GetStateFlags());

        /*
        if (FAILED(pdiDevice2->EnumObjects((LPDIENUMDEVICEOBJECTSCALLBACK)DIEnumDeviceObjectsProc, (LPVOID *)pdiCpl->GetStateFlags(), DIDFT_ALL)))
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DICPUTIL.CPP: WM_INIT: EnumObjects FAILED!\n"));
#endif
        }
        */
    }

exitinit:
    // release the base DirectInput object
    if( pdi ) {
        pdi->Release();
    }

    // we're done
    LeaveCriticalSection(&gcritsect);
    return(hRes);

} //*** end InitDInput()



void OnHelp(LPARAM lParam)
{                  
    assert ( lParam );

    short nSize = STR_LEN_32;

    // point to help file
    TCHAR pszHelpFileName[STR_LEN_32];

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, (UINT)HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
}

BOOL GetHelpFileName(TCHAR *lpszHelpFileName, short* pSize)
{
    if( LoadString(ghInst, IDS_HELPFILENAME, lpszHelpFileName, *pSize) )
        return(S_OK);
    else
        return(E_FAIL);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam)
{
    short nSize = STR_LEN_32;

    // point to help file
    TCHAR pszHelpFileName[STR_LEN_32];

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
}

// Instead of enumerating via EnumObjects
void EnumDeviceObjects(LPDIRECTINPUTDEVICE2 pdiDevice2, STATEFLAGS *pStateFlags)
{
    DIDEVICEOBJECTINSTANCE_DX3 DevObjInst;

    DevObjInst.dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

    const DWORD dwOffsetArray[] = {DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};

    // -1 is for 0 based dwOffsetArray!
    BYTE n = MAX_AXIS;

    do
    {
        if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)&DevObjInst, dwOffsetArray[--n], DIPH_BYOFFSET)) )
            pStateFlags->nAxis |= (HAS_X<<n);
    } while( n );


    n = MAX_BUTTONS;

    do
    {
        if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)&DevObjInst, DIJOFS_BUTTON(--n), DIPH_BYOFFSET)) )
            pStateFlags->nButtons |= (HAS_BUTTON1<<n);
    } while( n );


    n = MAX_POVS;

    do
    {
        if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)&DevObjInst, DIJOFS_POV(--n), DIPH_BYOFFSET)) )
            pStateFlags->nPOVs |= (HAS_POV1<<n);
    } while( n );
}

#define GETRANGE( n ) \
        DIPropCal.lMin    = lpMyRanges->jpMin.dw##n##;      \
        DIPropCal.lCenter = lpMyRanges->jpCenter.dw##n##;   \
        DIPropCal.lMax    = lpMyRanges->jpMax.dw##n##;      \


void SetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis)
{
    DIPROPCAL DIPropCal;

    DIPropCal.diph.dwSize       = sizeof(DIPROPCAL);
    DIPropCal.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    DIPropCal.diph.dwHow        = DIPH_BYOFFSET;

    const DWORD dwOffsetArray[] = {DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};
    BYTE n = 0;

    // You have to start with a "while" here because Reset to Default may not have Any Axis!!!
    while( nAxis )
    {
        if( nAxis & HAS_X )
        {
            GETRANGE(X);
        } else if( nAxis & HAS_Y )
        {
            GETRANGE(Y);
            n = 1;
        } else if( nAxis & HAS_Z )
        {
            GETRANGE(Z)
            n = 2;
        } else if( nAxis & HAS_RX )
        {
            GETRANGE(Rx);
            n = 3;
        } else if( nAxis & HAS_RY )
        {
            GETRANGE(Ry);
            n = 4;
        } else if( nAxis & HAS_RZ )
        {
            GETRANGE(Rz);
            n = 5;
        } else if( nAxis & HAS_SLIDER0 )
        {
            GETRANGE(S0);
            n = 6;
        } else if( nAxis & HAS_SLIDER1 )
        {
            GETRANGE(S1); 
            n = 7;
        }

        DIPropCal.diph.dwObj = dwOffsetArray[n];

        VERIFY(SUCCEEDED(lpdiDevice2->SetProperty(DIPROP_CALIBRATION, &DIPropCal.diph)));

        nAxis &= ~HAS_X<<n;
    }
}

// Removed 'till we calibrate POVs again!
void SetMyPOVRanges(LPDIRECTINPUTDEVICE2 pdiDevice2)
{
    DIPROPCALPOV *pDIPropCal = new (DIPROPCALPOV);
    assert (pDIPropCal);

    ZeroMemory(pDIPropCal, sizeof(*pDIPropCal));

    pDIPropCal->diph.dwSize = sizeof(*pDIPropCal);
    pDIPropCal->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropCal->diph.dwHow = DIPH_BYID; 
    pDIPropCal->diph.dwObj = DIDFT_POV; 

    memcpy( pDIPropCal->lMin, myPOV[POV_MIN], sizeof(pDIPropCal->lMin) );
    memcpy( pDIPropCal->lMax, myPOV[POV_MAX], sizeof(pDIPropCal->lMax) );
    
    if( FAILED(pdiDevice2->SetProperty(DIPROP_CALIBRATION, &pDIPropCal->diph)) )
    {
#if (defined(_DEBUG) || defined(DEBUG))
        OutputDebugString(TEXT("GCDEF.DLL: SetMyRanges: SetProperty failed to set POV!\n"));
#endif
    }

    if( pDIPropCal ) {
        delete (pDIPropCal);
    }
}


void SetTitle( HWND hDlg )
{
    // Set the title bar!
    LPDIRECTINPUTDEVICE2 pdiDevice2;
    pdiCpl->GetDevice(&pdiDevice2);

    DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
    ASSERT (pDIPropStr);

    ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

    pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
    pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropStr->diph.dwHow        = DIPH_DEVICE;

    if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
    {
        TCHAR  tszFormat[STR_LEN_64];
#ifndef _UNICODE
        CHAR   szOut[STR_LEN_128];
#endif

        LPWSTR lpwszTitle = new (WCHAR[STR_LEN_128]);
        ASSERT (lpwszTitle);

        // Shorten length, provide elipse, 
        if( wcslen(pDIPropStr->wsz) > 32 )
        {
            pDIPropStr->wsz[30] = pDIPropStr->wsz[31] = pDIPropStr->wsz[32] = L'.';
            pDIPropStr->wsz[33] = L'\0';
        }

        LoadString(ghInst, IDS_SHEETCAPTION, tszFormat, sizeof(tszFormat)/sizeof(tszFormat[0]));

#ifdef _UNICODE
        wsprintfW(lpwszTitle, tszFormat, pDIPropStr->wsz);
#else
        USES_CONVERSION;

        wsprintfA(szOut, tszFormat, W2A(pDIPropStr->wsz));
        StrCpyW(lpwszTitle, A2W(szOut));
#endif

        //SetWindowText(GetParent(hDlg), 
        ::SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)
#ifdef _UNICODE
                      lpwszTitle);
#else
                      W2A(lpwszTitle));
#endif 

        if( lpwszTitle )
            delete[] (lpwszTitle);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("GCDEF.DLL: DICPUTIL.CPP: SetTitle: GetProperty Failed!\n"));
#endif

    if( pDIPropStr )
        delete (pDIPropStr);
}

BOOL Error(HWND hWnd, short nTitleID, short nMsgID)
{
    TCHAR lptTitle[STR_LEN_64];
    BOOL bRet = FALSE;

    if( LoadString(ghInst, nTitleID, lptTitle, STR_LEN_64) )
    {
        TCHAR lptMsg[STR_LEN_128];

        if( LoadString(ghInst, nMsgID, lptMsg, STR_LEN_128) )
        {
            MessageBox(hWnd, lptMsg, lptTitle, MB_ICONHAND | MB_OK);
            bRet = TRUE;
        }
    }

    return(bRet);
}

void CenterDialog(HWND hWnd)
{
    RECT rc;
    HWND hParentWnd = GetParent(hWnd);

    GetWindowRect(hParentWnd, &rc);

    // Centre the Dialog!
    SetWindowPos(hParentWnd, NULL, 
                 (GetSystemMetrics(SM_CXSCREEN) - (rc.right-rc.left))>>1, 
                 (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom-rc.top))>>1, 
                 NULL, NULL, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);
}


#define SETRANGE( n ) \
      lpMyRanges->jpMin.dw##n##    = DIPropRange.lMin;        \
      lpMyRanges->jpCenter.dw##n## = DIPropRange.lCenter; \
      lpMyRanges->jpMax.dw##n##    = DIPropRange.lMax;        \

//===========================================================================
// BOOL GetMyRanges( LPMYJOYRANGE lpMyRanges, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis)
//
// Parameters:
//    LPMYJOYRANGE         lpMyRanges - Structure to fill with ranges
//    LPDIRECTINPUTDEVICE2 pdiDevice2 - Device in which axis ranges are requested
//    BYTE                 nAxis      - Bit mask of axis ranges to retrieve
//
// Returns: FALSE if failed
//
//===========================================================================
void GetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis)
{
    // Use DIPROPCAL to retrieve Range Information
    // Don't use DIPROPRANGE, as it doesn't have Center!
    DIPROPCAL DIPropRange;

    DIPropRange.diph.dwSize       = sizeof(DIPROPCAL);
    DIPropRange.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    DIPropRange.diph.dwHow        = DIPH_BYOFFSET;

    const DWORD dwOffsetArray[] = {DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};
    BYTE nIndex = 0;

    // Zero out the buffer members and the index!
    DIPropRange.lMin = DIPropRange.lCenter = DIPropRange.lMax = 0;

    // You don't have to start with "while" here because Reset to Default does not call this function!!1
    do
    {
        if( nAxis & HAS_X )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 0];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(X);
            }
        } else if( nAxis & HAS_Y )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 1];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(Y);
            }
        } else if( nAxis & HAS_Z )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 2];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(Z);
            }
        } else if( nAxis & HAS_RX )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 3];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(Rx);
            }
        } else if( nAxis & HAS_RY )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 4];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(Ry);
            }
        } else if( nAxis & HAS_RZ )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 5];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(Rz);
            }
        } else if( nAxis & HAS_SLIDER0 )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 6];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(S0);
            }
        } else if( nAxis & HAS_SLIDER1 )
        {
            DIPropRange.diph.dwObj = dwOffsetArray[nIndex = 7];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &DIPropRange.diph)) )
            {
                SETRANGE(S1); 
            }
        } else {
            break;
        }
    } while( nAxis &= ~HAS_X<<nIndex );
}

void PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled)
{
    HWND hCtrl = GetDlgItem(hDlg, nItem);

    if( hCtrl )
        PostEnableWindow(hCtrl, bEnabled);
}

void PostEnableWindow(HWND hCtrl, BOOL bEnabled)
{
    DWORD dwStyle = GetWindowLong(hCtrl, GWL_STYLE);

    // No point Redrawing the Window if there's no change!
    if( bEnabled )
    {
        if( dwStyle & WS_DISABLED )
            dwStyle &= ~WS_DISABLED;
        else return;
    } else
    {
        if( !(dwStyle & WS_DISABLED) )
            dwStyle |=  WS_DISABLED;
        else return;
    }

    SetWindowLongPtr(hCtrl, GWL_STYLE, (LONG_PTR)dwStyle);

    RedrawWindow(hCtrl, NULL, NULL, RDW_INTERNALPAINT | RDW_INVALIDATE); 
}

void CopyRange( LPJOYRANGE lpjr, LPMYJOYRANGE lpmyjr )
{
    memcpy( &lpjr->jpMin,    &lpmyjr->jpMin, sizeof(JOYPOS) );
    memcpy( &lpjr->jpCenter, &lpmyjr->jpCenter, sizeof(JOYPOS) );
    memcpy( &lpjr->jpMax,    &lpmyjr->jpMax, sizeof(JOYPOS) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\joyarray.h ===
#include "joyhelp.h"

const DWORD gaHelpIDs[]=
{
   	IDC_TEXT_CALHELP,       (DWORD)-1,
   	IDC_SETTINGSGRP,        (DWORD)-1,
   	IDC_TEXT_AXESHELP,      (DWORD)-1,
   	IDC_AXISGRP,            (DWORD)-1,
   	IDC_GROUP_POV,          (DWORD)-1, 
   	IDC_GROUP_BUTTONS,	   	(DWORD)-1,
   	IDC_RESETCALIBRATION,   IDH_4201_12290,   // Settings: "Reset to &default" (Button)
	IDC_JOYCALIBRATE,	    IDH_4201_12291,	// Settings: "&Calibrate..." (Button)

	IDC_JOYLIST1,	       	IDH_4203_12293,	// -: "" (ListBox)
	IDC_JOYLIST2,	       	IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST3,	       	IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST4,	       	IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST5,	       	IDH_4203_12308,	// -: "" (ListBox)
    IDC_JOYLIST6,          	IDH_4203_12308, 
    IDC_JOYLIST7,          	IDH_4203_12308, 
    IDC_JOYLIST1_LABEL,    	IDH_4203_12293,     
    IDC_JOYLIST2_LABEL,    	IDH_4203_12308,
    IDC_JOYLIST3_LABEL,    	IDH_4203_12308,
    IDC_JOYLIST4_LABEL,    	IDH_4203_12308,     
    IDC_JOYLIST5_LABEL,    	IDH_4203_12308,
    IDC_JOYLIST6_LABEL,    	IDH_4203_12308, 
    IDC_JOYLIST7_LABEL,    	IDH_4203_12308, 
    IDC_JOYPOV,	           	IDH_4203_12309,	// -: "" (POVHAT)
	IDC_TESTJOYBTNICON1,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON2,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON3,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON4,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON5,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON6,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON7,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON8,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON9,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON10,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON11,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON12,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON13,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON14,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON15,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON16,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON17,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON18,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON19,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON20,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON21,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON22,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON23,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON24,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON25,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON26,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON27,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON28,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON29,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON30,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON31,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON32,  	IDH_4203_1023,	// -: "x" (Static)
	0, 0
};

// Had to split into two arrays because the test and calibrate pages use the same
// IDs for their controls!  -tmc
/*
const DWORD gaHelpIDs_Cal[]=
{
   IDC_JOYLIST1,	IDH_4101_12293,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST2,	IDH_4101_12308,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST3,	IDH_4101_12334,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST4,	IDH_4101_12347,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST5,	IDH_4101_12349,	// Joystick Calibration: "" (ListBox)
	IDC_JOYPOV,	   IDH_4101_12309,	// Joystick Calibration: "f" (Static)
   IDC_JOYPICKPOV,IDH_4101_12328,	// Joystick Calibration: "Capture &POV" (Button)
   IDC_JOYCALBACK,IDH_4101_12329,	// Joystick Calibration: "< &Back" (Button)
   IDC_JOYCALNEXT,IDH_4101_12330,	// Joystick Calibration: "&Next >" (Button)
   IDC_JOYLIST1,	IDH_4202_12293,	// Game Controller Calibration: "" (ListBox)
	IDC_JOYLIST2,	IDH_4202_12308,	// Game Controller Calibration: "" (ListBox)
   IDC_JOYPICKPOV,IDH_4202_12328,	// Joystick Calibration: "Capture &POV" (Button)
   IDC_JOYCALBACK,IDH_4202_12329,	// Joystick Calibration: "< &Back" (Button)
   IDC_JOYCALNEXT,IDH_4202_12330,	// Joystick Calibration: "&Next >" (Button)
	IDC_JOYLIST3,	IDH_4202_12334,	// Game Controller Calibration: "" (ListBox)
	IDC_GROUPBOX,	IDH_4202_8199,	   // Game Controller Calibration: "Calibration Information" (Button)
	0, 0
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\gradient.h ===
#if !defined(AFX_ENHPROGRESSCTRL_H__12909D73_C393_11D1_9FAE_8192554015AD__INCLUDED_)
#define AFX_ENHPROGRESSCTRL_H__12909D73_C393_11D1_9FAE_8192554015AD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EnhProgressCtrl.h : header file
//


//
// GradientProgressCtrl.h : header file
//

#define HORIZONTAL	0x10
#define VERTICAL	0x20

/////////////////////////////////////////////////////////////////////////////
// CGradientProgressCtrl window

class CGradientProgressCtrl : public CProgressCtrl
{
// Construction
public:
	CGradientProgressCtrl();

// Attributes
public:
// Attributes
	
	void SetRange(long nLower, long nUpper);
	int StepIt(void);

// Operations
public:
	
	// Set Functions
	void SetBkColor(COLORREF color)		{m_clrBkGround = color;}
	void SetStartColor(COLORREF color)	{m_clrStart = color;}
	void SetEndColor(COLORREF color)	{m_clrEnd = color;}
	void SetDirection(BYTE nDirection)	{m_nDirection = nDirection;}
	void SetPos(long nPos)				{m_nCurrentPosition = nPos;}

	// Show the percent caption
	void ShowPercent(BOOL bShowPercent = TRUE)	{m_bShowPercent = bShowPercent;}
	
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGradientProgressCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGradientProgressCtrl();

	// Generated message map functions
protected:
	void DrawGradient(const HDC hDC, const RECT &rectClient, const short &nMaxWidth);	
    BYTE      m_nStep;
	long      m_nLower, m_nUpper, m_nCurrentPosition;
	BYTE	  m_nDirection;
	COLORREF  m_clrStart, m_clrEnd, m_clrBkGround, m_clrText;
	BOOL      m_bShowPercent; 

	//{{AFX_MSG(CGradientProgressCtrl)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENHPROGRESSCTRL_H__12909D73_C393_11D1_9FAE_8192554015AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\gradient.cpp ===
//
// GradientProgressCtrl.cpp : implementation file
//

#include "afxcmn.h"
#include "Gradient.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGradientProgressCtrl

CGradientProgressCtrl::CGradientProgressCtrl()
{
	// Defaults assigned by CProgressCtrl()
	m_nLower = 0;
	m_nUpper = 100;
	m_nCurrentPosition = 0;
	m_nStep = 10;	
	
	// Default is vertical, because the only clients are the Test page and
	// the calibration wizard, and hitting the test page is Far more common.
	m_nDirection = VERTICAL;  
	
	// Initial colors
//	m_clrStart	  = COLORREF(RGB(255, 0,0));
//	m_clrEnd	  = COLORREF(RGB(255,128,192));
	m_clrStart	  = COLORREF(RGB(255,0,0));	 
	m_clrEnd 	  = COLORREF(RGB(0,0,255)); 
	m_clrBkGround = GetSysColor(COLOR_WINDOW);
    m_clrText     = COLORREF(RGB(255,255,255));

	// Initial show percent
    m_bShowPercent = FALSE;
}

CGradientProgressCtrl::~CGradientProgressCtrl()
{
}


BEGIN_MESSAGE_MAP(CGradientProgressCtrl, CProgressCtrl)
	//{{AFX_MSG_MAP(CGradientProgressCtrl)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGradientProgressCtrl message handlers

void CGradientProgressCtrl::OnPaint() 
{
	PAINTSTRUCT ps;
	::BeginPaint(this->m_hWnd, &ps);
	
	CDC *pDC=GetDC();
    HDC hDC = pDC->m_hDC;

	if ((m_nLower < 0) || (m_nUpper < 0))
		m_nCurrentPosition -= m_nLower;

	// Figure out what part should be visible so we can stop the gradient when needed
	RECT rectClient;
	::GetClientRect(this->m_hWnd, &rectClient);

	float nTmp = ((float)m_nCurrentPosition/(float)abs(m_nLower - m_nUpper));

	// Draw the gradient
	DrawGradient(hDC, rectClient, (short)(nTmp * ((m_nDirection == VERTICAL) ? rectClient.bottom : rectClient.right)));

	// Show percent indicator if needed
   if (m_bShowPercent)
   {
		TCHAR tszBuff[5];
		wsprintf(tszBuff, TEXT("%d%%"), (short)(100*nTmp));

		::SetTextColor(hDC, m_clrText);
		::SetBkMode(hDC, TRANSPARENT);
		::DrawText(hDC, tszBuff, lstrlen(tszBuff), &rectClient, DT_VCENTER |  DT_CENTER | DT_SINGLELINE);
   }

   	ReleaseDC(pDC);

	::EndPaint(this->m_hWnd, &ps);
	// Do not call CProgressCtrl::OnPaint() for painting messages
}


/*************************************************************************/
// Need to keep track of where the indicator thinks it is.
/*************************************************************************/
void CGradientProgressCtrl:: SetRange(long nLower, long nUpper)
{
	m_nCurrentPosition = m_nLower = nLower;
	m_nUpper = nUpper;
}

/*************************************************************************/
// Where most of the actual work is done.  The general version would fill the entire rectangle with
// a gradient, but we want to truncate the drawing to reflect the actual progress control position.
/*************************************************************************/
void CGradientProgressCtrl::DrawGradient(const HDC hDC, const RECT &rectClient, const short &nMaxWidth)
{
	// First find out the largest color distance between the start and end colors.  This distance
	// will determine how many steps we use to carve up the client region and the size of each
	// gradient rect.

	// Get the color differences
	short r = (GetRValue(m_clrEnd) - GetRValue(m_clrStart));
	short g = (GetGValue(m_clrEnd) - GetGValue(m_clrStart));
	short b = (GetBValue(m_clrEnd) - GetBValue(m_clrStart));


	// Make the number of steps equal to the greatest distance
	short nSteps = max(abs(r), max(abs(g), abs(b)));

	// Determine how large each band should be in order to cover the
	// client with nSteps bands (one for every color intensity level)
	float fStep = ((m_nDirection == VERTICAL) ? (float)rectClient.bottom : (float)rectClient.right) / (float)nSteps;

	// Calculate the step size for each color
	float rStep = r/(float)nSteps;
	float gStep = g/(float)nSteps;
	float bStep = b/(float)nSteps;

	// Reset the colors to the starting position
	r = GetRValue(m_clrStart);
	g = GetGValue(m_clrStart);
	b = GetBValue(m_clrStart);

	RECT rectFill;			   // Rectangle for filling band

	// Start filling bands
	for (short iOnBand = 0; iOnBand < nSteps; iOnBand++) 
	{
		
		if (m_nDirection == VERTICAL)
		{
			// This provides the "velvet" look...
			::SetRect(&rectFill,
					(int)(iOnBand * fStep),       // Upper left X
					 0,									// Upper left Y
					(int)((iOnBand+1) * fStep),   // Lower right X
					rectClient.bottom+1);				// Lower right Y

			/* Use this if we want the gradient to go up/down
			::SetRect(&rectFill,
					 0,									// Upper left Y
					(int)(iOnBand * fStep),       // Upper left X
					rectClient.bottom+1,			// Lower right Y
					(int)((iOnBand+1) * fStep));  // Lower right X
			*/
		}
		else
		{
			// Use this if we want the gradient to go left/right
			::SetRect(&rectFill,
					(int)(iOnBand * fStep),       // Upper left X
					 0,								   // Upper left Y
					(int)((iOnBand+1) * fStep),   // Lower right X
					rectClient.bottom+1);			// Lower right Y
		}

        // Home-brew'd FillSolidRect... Much more effecient!
		::SetBkColor(hDC, RGB(r+rStep*iOnBand, g + gStep*iOnBand, b + bStep *iOnBand));
		::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rectFill, NULL, 0, NULL);
		
		if (m_nDirection == VERTICAL)
		{
		  	// Grey Rect
			::SetRect(&rectFill, 0, 0, rectClient.right, nMaxWidth);
			::SetBkColor(hDC, m_clrBkGround);
			::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rectFill, NULL, 0, NULL);
		}
		else
		{
			// If we are past the maximum for the current position we need to get out of the loop.
			// Before we leave, we repaint the remainder of the client area with the background color.
			if (rectFill.right > nMaxWidth)
			{
				::SetRect(&rectFill, rectFill.right, 0, rectClient.right, rectClient.bottom);
				::SetBkColor(hDC, m_clrBkGround);
				::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rectFill, NULL, 0, NULL);

				return;
			}
		}
	}
}

/*************************************************************************/
// All drawing is done in the OnPaint function
/*************************************************************************/
BOOL CGradientProgressCtrl::OnEraseBkgnd(CDC *pDC) 
{
	// TODO: Add your message handler code here and/or call default
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\joyhelp.h ===
#define IDH_4101_12293	805638149	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12308	806621189	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12309	806686725	// Joystick Calibration: "f" (Static)
#define IDH_4101_12328	807931909	// Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329	807997445	// Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330	808062981	// Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12334	808325125	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12347	809177093	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12349	809308165	// Joystick Calibration: "" (ListBox)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4202_8199	537333866	// Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4202_12293	805638250	// Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308	806621290	// Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328	807932010	// Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12329	807997546	// Game Controller Calibration: "<&Back" (Button)
#define IDH_4202_12330	808063082	// Game Controller Calibration: "&Next>" (Button)
#define IDH_4202_12334	808325226	// Game Controller Calibration: "" (ListBox)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox)
#define IDH_4203_12308	806621291	// -: "" (ListBox)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_4203_12334	808325227	// -: "" (ListBox)
#define IDH_4203_12347	809177195	// -: "" (ListBox)
#define IDH_4203_12349	809308267	// -: "" (ListBox)
#define IDH_4201_12290	805507175	// Settings: "Reset to &default" (Button)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\pinfo.h ===
//----------- Packet Info structure -------------
typedef struct _PACKETINFO
{
   DWORD iMode;			      // Interface mode. (see below defs)
   DWORD port;                // game port.
	DWORD Flags;			      // acquistion flags.
	DWORD nPackets;		      // number of packets
	DWORD TimeStamp;		      // last valid acquisition time stamp
	DWORD nClocksSampled;      // number of clocks sampled.
	DWORD nB4Transitions;      // number of B4 line transitions (std mode only).
	DWORD StartTimeout;        // Start timeout period (in samples).
	DWORD HighLowTimeout;      // Clock High to Low timeout period (in samples).
	DWORD LowHighTimeout;      // Clock Low to High timeout period (in samples).
	DWORD InterruptDelay;      // Delay between INTXA interrupts.
	DWORD nFailures;		      // Number of Packet Failures.
	DWORD nAttempts;		      // Number of Packet Attempts.
   DWORD nBufSize;            // size of Raw data buffer.
	DWORD *pData;      	      // pointer to Raw data (DWORD aligned).
} PACKETINFO, *PPACKETINFO;

//--------- Interface MODES ---------------------
#define IMODE_DIGITAL_STD     0        // Standard Digital Mode.
#define IMODE_DIGITAL_ENH     4        // Enhanced Digital Mode.
#define IMODE_ANALOG          8        // Analog Mode.
#define IMODE_NONE            -1       // Joystick Disconnected.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\pov.h ===
#ifndef __POV_H
#define __POV_H
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**
**    FILE:       POV.H
**    DATE:       3/31/97
**    PROJ:       ATLAS
**    PROG:       JKH
**    COMMENTS:   
**
**    DESCRIPTION:Header file for the POV control class
**				      
**				      
**
**    NOTE:       
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    3/31/97     a-kirkh        Wrote it.
**    
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~INCLUDES=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
//    
//
#include <windows.h>
#include <math.h>
#include <assert.h>

#include "resource.h"

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~STRUCTS~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
//    
//
typedef struct tag_VerticeInfo
{
   /*
   int   x;
   long  y;
   */
   short x;
   short y;
}VERTICEINFO, *PVERTICEINFO;



//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~DEFINES~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
// ARROWVERTICES DESCRIPTIONS
//                                /\  ------------- X/YARROWPOINT
//                              /    \
//                            /__    __\ ---------- X/YARROWRIGHT/LEFTOUT
//     X/YARROWBOTTOM  \         |  |\
//                       \_______|__|  \----------- X/YARROWRIGHT/LEFTIN 
//

#define        NUMARROWVERTICES           8									// IN ARROW BITMAP
#define        PIPI                       6.283185307179586476925286766559  // 2 * PI
#define        PM_MYJOYPOSCHANGED         WM_USER + 1000					// PRIVATE MESSAGE
#define        CIRCLECOLOR                RGB(96, 96, 96)

//VERTICES COORDINATES
//X
#define        XARROWPOINT                0     //USE TWICE, AT START AND AT END
#define        XARROWRIGHTOUT             150
#define        XARROWRIGHTIN              75
#define        XARROWRIGHTBOTTOM          75
#define        XARROWLEFTBOTTOM           -75
#define        XARROWLEFTIN               -75
#define        XARROWLEFTOUT              -150

//VERTICES COORDINATES
//Y
#define        YARROWPOINT                1000
#define        YARROWRIGHTOUT             850
#define        YARROWRIGHTIN              850
#define        YARROWRIGHTBOTTOM          750
#define        YARROWLEFTBOTTOM           750
#define        YARROWLEFTIN               850
#define        YARROWLEFTOUT              850

#define        CIRCLERADIUS               YARROWRIGHTOUT

#define 	   POV1_COLOUR	RGB(255,0,0)
#define 	   POV2_COLOUR	RGB(0,0,255)
#define 	   POV3_COLOUR	RGB(0,0,0)
#define 	   POV4_COLOUR	RGB(0,255,0)



//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~MACROS=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
// The sin function takes radians so use the conversion:
//
// DEGTORAD: DEGREES / 360 == RADIANS / 2PI -> DEGREES * 2PI == RADIANS    
//
// To rotate and translate a coordinate use the functions:
// 
// GETXCOORD: X' = Y * sin(angle) + X * cos(angle)
// where angle is in radians and
//
// GETYCOORD: Y' = Y * cos(angle) - X * sin(angle)
// where angle is in radians.
//

#define DEGTORAD(d) (double)((PIPI * (d))/360)

#define GETXCOORD(y, x, theta) (int)((((y) * sin((double)(DEGTORAD(theta))))) + (((x) * cos((double)(DEGTORAD(theta))))))
#define GETYCOORD(y, x, theta) (int)((((y) * cos((double)(DEGTORAD(theta))))) - (((x) * sin((double)(DEGTORAD(theta))))))

void SetDegrees(BYTE nPov, short *dDegrees, HWND hPOVWnd);
/*
void DrawROPLine(HDC hDC, POINT ptStart, 
                 POINT ptEnd, COLORREF rgb = RGB(0, 0, 0), 
                 int iWidth = 1, int iStyle = PS_SOLID, int iROPCode = R2_COPYPEN);

void     DrawControl(HDC hDC, LPRECT prcClient);
*/
void     GetCurrentArrowRegion(HRGN* hRegion, BYTE nPov);
extern   ATOM RegisterPOVClass();
LRESULT  CALLBACK POVWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
void     DrawBitmap(HDC hDC, HBITMAP hBitmap, BYTE xStart, BYTE yStart);
#endif
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=EOF=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\pov.cpp ===
/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
**
**    FILE:       POV.CPP
**    DATE:       3/31/97
**    PROJ:       ATLAS
**    PROG:       JKH
**    COMMENTS:   
**
**    DESCRIPTION: Window class for a 360 degree Point Of View control
**                    
**                    
**
**    NOTE:       There are some issues with using extern "C" in this file.
**                If you don't understand why they are there, you're not
**                alone.  For now, and probably for a while they will be
**                here though, because I can't get this file and others
**                that use these services to compile without them.
**                Unfortunately the dynamics of this project don't really
**                afford me the time at present to figure this out.
**                TODO: figure this out
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    3/31/97     a-kirkh        Wrote it.
**    
**
**
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/
#include "cplsvr1.h"       // for ghInst
#include "dicputil.h"   // for MAX_POVS
#include "POV.H"           //This module's stuff. 

#include "resrc1.h"

//static HWND hPOVWnd = NULL;
#define NUM_ARROW_POINTS    8
//static VERTICEINFO *paptVInfo;  
static const VERTICEINFO VInfo[] = {XARROWPOINT, YARROWPOINT, XARROWRIGHTOUT, YARROWRIGHTOUT, XARROWRIGHTIN, YARROWRIGHTIN,
    XARROWRIGHTBOTTOM, YARROWRIGHTBOTTOM, XARROWLEFTBOTTOM, YARROWLEFTBOTTOM, XARROWLEFTIN,
    YARROWLEFTIN, XARROWLEFTOUT, YARROWLEFTOUT, XARROWPOINT, YARROWPOINT};
static LPRECT prcOldRegionBox[MAX_POVS];
static LPRECT prcNewRegionBox[MAX_POVS];

#define  DEF_POV_POS -1

static double  degrees[MAX_POVS] = {DEF_POV_POS, DEF_POV_POS, DEF_POV_POS, DEF_POV_POS};

static BYTE   nPOV = MAX_POVS;
static HBRUSH hBrush[MAX_POVS];
static HRGN hRegion[MAX_POVS];

extern HINSTANCE ghInst;

void SetDegrees(BYTE nPov, short *nDegrees, HWND hPOVWnd)
{
    nPOV = nPov -= 1;

    POINT paptPoints[NUM_ARROW_POINTS];

    // Create the proper brush for the axis!
    do {
        degrees[nPov] = (double)nDegrees[nPov] / DI_DEGREES; // if angle == 180, degrees comes in as 18000

        paptPoints[0].x = GETXCOORD(VInfo[0].y, VInfo[0].x, degrees[nPov]);
        paptPoints[0].y = GETYCOORD(VInfo[0].y, VInfo[0].x, degrees[nPov]);                    
        paptPoints[1].x = GETXCOORD(VInfo[1].y, VInfo[1].x, degrees[nPov]);
        paptPoints[1].y = GETYCOORD(VInfo[1].y, VInfo[1].x, degrees[nPov]);
        paptPoints[2].x = GETXCOORD(VInfo[2].y, VInfo[2].x, degrees[nPov]);
        paptPoints[2].y = GETYCOORD(VInfo[2].y, VInfo[2].x, degrees[nPov]);                    
        paptPoints[3].x = GETXCOORD(VInfo[3].y, VInfo[3].x, degrees[nPov]);
        paptPoints[3].y = GETYCOORD(VInfo[3].y, VInfo[3].x, degrees[nPov]);                    
        paptPoints[4].x = GETXCOORD(VInfo[4].y, VInfo[4].x, degrees[nPov]);
        paptPoints[4].y = GETYCOORD(VInfo[4].y, VInfo[4].x, degrees[nPov]);                    
        paptPoints[5].x = GETXCOORD(VInfo[5].y, VInfo[5].x, degrees[nPov]);
        paptPoints[5].y = GETYCOORD(VInfo[5].y, VInfo[5].x, degrees[nPov]);                    
        paptPoints[6].x = GETXCOORD(VInfo[6].y, VInfo[6].x, degrees[nPov]);
        paptPoints[6].y = GETYCOORD(VInfo[6].y, VInfo[6].x, degrees[nPov]);                    
        paptPoints[7].x = GETXCOORD(VInfo[7].y, VInfo[7].x, degrees[nPov]);
        paptPoints[7].y = GETYCOORD(VInfo[7].y, VInfo[7].x, degrees[nPov]);                    

        if(hRegion[nPov])
        {
            DeleteObject(hRegion[nPov]);
            hRegion[nPov]=NULL;
        }
        hRegion[nPov] = CreatePolygonRgn(paptPoints, NUM_ARROW_POINTS, WINDING);

        //hBrush[nPov] = CreateSolidBrush((nPov < 1) ? POV1_COLOUR : 
        //                                (nPov < 2) ? POV2_COLOUR : 
        //                                (nPov < 3) ? POV3_COLOUR : POV4_COLOUR); */

        //if (hRegion[nPov] && hBrush[nPov])
        //{
        //    GetRgnBox(hRegion[nPov], prcNewRegionBox[nPov]);
        //
        //    //RedrawWindow(hPOVWnd, NULL, NULL, RDW_INTERNALPAINT | RDW_INVALIDATE | RDW_ERASE); 
        //    InvalidateRect(hPOVWnd, prcOldRegionBox[nPov], TRUE);
        //    InvalidateRect(hPOVWnd, prcNewRegionBox[nPov], TRUE);
        //}
        RECT R;
        GetClientRect(hPOVWnd,&R);

        POINT Pnt[2];
        Pnt[0].x=R.left;
        Pnt[0].y=R.top;
        Pnt[1].x=R.right;
        Pnt[1].y=R.bottom;
        MapWindowPoints(hPOVWnd,GetParent(hPOVWnd),Pnt,2);
        R.left=Pnt[0].x;
        R.top=Pnt[0].y;
        R.right=Pnt[1].x;
        R.bottom=Pnt[1].y;
        InvalidateRect(GetParent(hPOVWnd), &R, TRUE);
    
    } while( nPov-- );

}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  POVWndProc
//    REMARKS  :  The callback function for the POVHat Window.
//                    
//    PARAMS   :  The usual callback funcs for message handling
//
//    RETURNS  :  LRESULT - Depends on the message
//    CALLS    :  
//    NOTES    :
//                WM_PAINT - Just calls DrawControl
//
//                PM_MYJOYPOSCHANGED - This is a private (WM_USER) message that is
//                called whenever a change in the POV hat occurs.
//                
LRESULT CALLBACK POVWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch( iMsg ) {

//      case WM_CREATE:
//          hPOVWnd = hWnd;
//          return FALSE;

//      case WM_DESTROY:
//         return FALSE;
    
    case WM_DESTROY:
        {
            BYTE nPov=nPOV;
            do
            {
                if(hRegion[nPov])
                {
                    DeleteObject(hRegion[nPov]);
                    hRegion[nPov]=NULL;
                }
            }while(nPov--);
        }
        return 0;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd, &ps);

            // 1) Get client size information
            SetMapMode(hDC, MM_TEXT);                              
            RECT rClient;
            GetClientRect(hWnd, &rClient);
            BYTE nSizeX = (BYTE)rClient.right>>1;
            BYTE nSizeY = (BYTE)rClient.bottom>>1;

            // 2) Load the hub bitmap and display it
            //PREFIX #WI226648. False positive. There is no leak. DeleteObject frees.
            HBITMAP hPOVHubBitmap = (HBITMAP)LoadImage(ghInst, MAKEINTRESOURCE(IDB_POVHUB), IMAGE_BITMAP, 0, 0, NULL);
            assert(hPOVHubBitmap);
            DrawBitmap(hDC, hPOVHubBitmap, nSizeX-8, nSizeY-8);
            DeleteObject(hPOVHubBitmap);

            // 3) Setup the window to use symmetrical units on a 1000 X 1000 cartesian grid
            SetMapMode(hDC, MM_ISOTROPIC);
            SetWindowExtEx  (hDC, 1000, 1000, NULL);
            SetViewportExtEx(hDC, nSizeX, -nSizeY, NULL); 
            SetViewportOrgEx(hDC, nSizeX,  nSizeY, NULL);

            // 4) Draw the circle upon which the arrow seems to rotate
            SelectObject(hDC, (HBRUSH)GetStockObject(NULL_BRUSH));

            HPEN hPenOld = (HPEN)SelectObject(hDC, (HGDIOBJ)GetStockObject(DC_PEN)); 
            SetDCPenColor( hDC, GetSysColor(COLOR_WINDOWTEXT) );

            Ellipse(hDC, -CIRCLERADIUS, CIRCLERADIUS, CIRCLERADIUS, -CIRCLERADIUS);
            SelectObject(hDC, hPenOld);

            // 5) Paint the Arrow at the correct angle if POV active
            BYTE nPov = nPOV;
            HBRUSH hBrushOld;

            do {
                if( degrees[nPov] >= 0 ) {
                    hBrush[nPov] = CreateSolidBrush((nPov < 1) ? POV1_COLOUR : 
                                                    (nPov < 2) ? POV2_COLOUR : 
                                                    (nPov < 3) ? POV3_COLOUR : POV4_COLOUR);                

                    hBrushOld = (HBRUSH)SelectObject(hDC, (HGDIOBJ)hBrush[nPov]); 



                    assert(hBrushOld);

                    PaintRgn(hDC, hRegion[nPov]);

                    // GetRgnBox returns zero if it fails...
                    GetRgnBox(hRegion[nPov], prcOldRegionBox[nPov]);
                    SelectObject(hDC, hBrushOld); 

                    if(hRegion[nPov])
                    {
                        DeleteObject(hRegion[nPov]);
                        hRegion[nPov]=NULL;
                    }
                    DeleteObject(hBrush[nPov] ); 
                }
            }   while( nPov-- );

            EndPaint(hWnd, &ps);
        }
        //PREFIX #WI226648. False positive. See above.
        return(0);

    default:
        return(DefWindowProc(hWnd, iMsg,wParam, lParam));
    }
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  RegisterPOVClass
//    REMARKS  :  Registers the POV Hat window.
//                    
//    PARAMS   :  hInstance - Used for the call to RegisterClassEx
//
//    RETURNS  :  TRUE - if successfully registered
//                FALSE - failed to register
//    CALLS    :  RegisterClassEx
//    NOTES    :
//

extern ATOM RegisterPOVClass()
{
    WNDCLASSEX POVWndClass;

    ZeroMemory(&POVWndClass, sizeof(WNDCLASSEX));

    POVWndClass.cbSize        = sizeof(WNDCLASSEX);
    POVWndClass.style         = CS_HREDRAW; // | CS_VREDRAW;
    POVWndClass.lpfnWndProc   = POVWndProc;
    POVWndClass.hInstance     = ghInst;
    POVWndClass.hbrBackground = NULL;
    POVWndClass.lpszClassName = TEXT("POVHAT");

    return(RegisterClassEx( &POVWndClass ));
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  DrawBitmap
//    REMARKS  :  Copied verbatim from Petzold (WIN95 pg 190)
//    PARAMS   :  HDC - dc for drawing
//                HBITMAP - bitmap to draw
//                int xstart, ystart - where to place the bitmap
//
//    RETURNS  :  void
//    CALLS    :  
//    NOTES    :
//
void DrawBitmap(HDC hDC, HBITMAP hBitmap, BYTE xStart, BYTE yStart)
{
    HDC hdcMem = CreateCompatibleDC(hDC);

    // Found by prefix: Millen Bug129155. manbugs 29339
    // If CreateCompatibleDC fails, we should'nt proceed.
    if( hdcMem == NULL ) return;

    SelectObject(hdcMem, hBitmap);
    SetMapMode(hdcMem,GetMapMode(hDC));

    // Be aware!  This is the size of the current BITMAP...
    // IF IT CHANGES THIS WILL FAIL!!!
    POINT ptSize = {16, 16};
    DPtoLP(hDC, &ptSize, 1);

    POINT ptOrg = {0,0};
    DPtoLP(hdcMem, &ptOrg, 1);

    BitBlt(hDC, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x, ptOrg.y, SRCAND);

    DeleteDC(hdcMem);
}

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=EOF=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cplsvr1.rc
//
#define IDS_SHEETCAPTION                1
#define IDS_ERROR                       2
#define IDS_NOFORCEFEEDBACK             3
#define IDS_ACQUIRED                    4
#define IDS_UNACQUIRED                  5
#define IDS_DEFAULT                     6

#define IDD_INITIAL                     10
#define IDD_XY							11
#define IDD_SLIDER                      12
#define IDD_POV                         13
//#define IDC_POVLABEL					14

#define IDI_WINFLAG                     105
#define IDI_CONFIG                      108
#define IDC_STOP                        1001
#define IDC_XDATA                       1002
#define IDC_YDATA                       1003
#define IDC_ZDATA                       1004
#define IDC_RXDATA                      1005
#define IDC_RYDATA                      1006
#define IDC_RZDATA                      1007
#define IDC_S0DATA                      1008
#define IDC_S1DATA                      1009
#define IDC_POV0DATA                    1010
#define IDC_POV1DATA                    1011
#define IDC_POV2DATA                    1012
#define IDC_POV3DATA                    1013
#define IDC_BUTTONSDOWN                 1014
#define IDC_EFFECTLIST                  1018
#define IDC_NUMAXES                     1019
#define IDC_NUMBUTTONS                  1020
#define IDC_NUMPOVS                     1021
#define IDC_AXISLIST                    1022
#define IDC_BUTTONLIST                  1023
#define IDC_POVLIST                     1024
#define IDC_DISPNAME                    1025
#define IDC_TYPENAME                    1026
#define IDC_CLSID                       1027
#define IDC_CALLOUT                     1028
#define IDC_DEVSTATUS                   1029


// blj: Calibration ID's 
#define IDD_CALIBRATE                   1032
#define IDD_CALIBRATE1                  1033
#define IDC_CALIBRATE                   1034
#define IDC_GROUPBOX					       1035

#define IDC_JOYLIST1					       1036
#define IDC_JOYLIST1_LABEL			   	 	   1037

// THESE ID's MUST REMAIN UNDESTURBED!
#define IDC_JOYLIST2					       1038
#define IDC_JOYLIST3					       IDC_JOYLIST2+1
#define IDC_JOYLIST4					       IDC_JOYLIST2+2
#define IDC_JOYLIST5					       IDC_JOYLIST2+3
#define IDC_JOYLIST6                    	   IDC_JOYLIST2+4
#define IDC_JOYLIST7                    	   IDC_JOYLIST2+5

//******************************************************
#define IDC_JOYLIST2_LABEL				       1071
#define IDC_JOYLIST3_LABEL				       IDC_JOYLIST2_LABEL+1
#define IDC_JOYLIST4_LABEL				       IDC_JOYLIST2_LABEL+2
#define IDC_JOYLIST5_LABEL			       	   IDC_JOYLIST2_LABEL+3
#define IDC_JOYLIST6_LABEL				       IDC_JOYLIST2_LABEL+4
#define IDC_JOYLIST7_LABEL			       	   IDC_JOYLIST2_LABEL+5

#define IDC_JOYPOV_LABEL				       IDC_JOYLIST2_LABEL+7

// ID's related to items on the IDD_CALIBRATE page
#define IDC_JOYPICKPOV                  1101
#define IDC_JOYCALBACK                  1102
#define IDC_JOYCALNEXT                  1103
#define IDC_JOYCALDONE                  1104
#define IDC_JOYCALMSG                   1105
#define IDC_JOYPOV                      1106

// IDS's related to items on the IDD_CALIBRATE page
#define IDS_JOYCALCAPN					1200
#define IDS_JOYCALBACK					1201
#define IDS_JOYCALNEXT					1202
#define IDS_JOYCALDONE					1203

#define IDS_JOYCALXY_CENTERYOKE         1205
#define IDS_JOYCALXY_CENTERCAR          1206
#define IDS_JOYCALXY_CENTERGAMEPAD      1207
#define IDS_JOYCALXY_CENTER             1208
#define IDS_JOYCALXY_MOVEYOKE           1209
#define IDS_JOYCALXY_MOVECAR            1210
#define IDS_JOYCALXY_MOVEGAMEPAD        1211
#define IDS_JOYCALXY_MOVE               1212
#define IDS_JOYCALXY_CENTERYOKE2        1213
#define IDS_JOYCALXY_CENTERCAR2         1214
#define IDS_JOYCALXY_CENTERGAMEPAD2     1215
#define IDS_JOYCALXY_CENTER2            1216

#ifdef DEADZONE
// String defines!
#define IDS_DEADZONE_TITLE				2000
#define IDS_JOYSTICK_DEADZONE			2001
#define IDS_GAMEPAD_DEADZONE			2002
#define IDS_CAR_DEADZONE				2003
#define IDS_YOKE_DEADZONE				2004

// Spin Control defines!
#define IDC_X_DEADZONE_SPIN				2005
#define IDC_Y_DEADZONE_SPIN				2006
#define IDC_X_SATURATION_SPIN			2007
#define IDC_Y_SATURATION_SPIN			2008

// Edit Controls associated with the
// Spin controls above!
#define IDC_X_DEADZONE					2010
#define IDC_Y_DEADZONE					2011
#define	IDC_X_SATURATION				2015
#define	IDC_Y_SATURATION				2016

// Static text field defines!
#define IDC_DEADZONE_TITLE				2009
#define IDC_SATURATION_TITLE			2014
#define IDC_X_AXIS_LABEL_DEADZONE		2012
#define IDC_Y_AXIS_LABEL_DEADZONE		2013
#define IDC_X_AXIS_LABEL_SATURATION		2017
#define	IDC_Y_AXIS_LABEL_SATURATION		2018
#endif // DEADZONE
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

USE_NTDLL=1
WIN32_WINNT_VERSION=0x500
!ENDIF

MAJORCOMP=shell
MINORCOMP=accesory
USE_PDB=1

TARGETNAME=GCDEF
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=DllMain
DLLBASE=0x71000000

LINKER_STACKSIZE=-STACK:4096,1024

! IF defined( DIRECTX_REDIST )
WIN32_WINNT_VERSION=0x0500
! ENDIF

!IFDEF TARGET_WIN95
CHICAGO_PRODUCT=1
USE_MAPSYM = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_ 
USE_MFC=1
!ELSE
C_DEFINES=$(C_DEFINES) -DWINNT -D_UNICODE 
LINKER_FLAGS=$(LINKER_FLAGS) -WS:AGGRESSIVE -HEAP:0x30D40,0x2000
USE_MFCUNICODE=1
!ENDIF

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\uuid.lib     \
           $(SDK_LIB_PATH)\dinput.lib   \
           $(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\shlwapi.lib


INCLUDES=$(INCLUDES);                   \
     ..;                                \
     ..\..\default;                     \
     $(DXROOT)\inc;                     \
 

DLLENTRY=DllMain
DLLDEF=..\GCDEF.DEF

SOURCES=\
        ..\button.cpp    \
        ..\CAL.cpp       \
        ..\CPLSVR1.cpp   \
        ..\CPLSVR1.rc    \
        ..\DICPUTIL.cpp  \
        ..\GRADIENT.CPP  \
        ..\POV.cpp       \
        ..\SETTINGS.CPP  \
        ..\TEST.cpp     
#		..\ff.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\settings.cpp ===
//===========================================================================
// SETTINGS.CPP
//
// Functions:
//  Settings_DlgProc()
//  DisplayJoystickState()
//
//===========================================================================

// Uncomment if we decide to calibrate the POV!
#define WE_SUPPORT_CALIBRATING_POVS	1

#include "cplsvr1.h"
#include "dicputil.h"
#include "resource.h"
#include "assert.h"
#include "cal.h"
#include <regstr.h>

// Flag to stop centering of DLG if it's already happend!
// This is needed because of the args that allow any page to be the first!
BOOL bDlgCentered = FALSE;

// This is global because Test.cpp needs it to determine
// if the ranges need to be updated!
BYTE nStatic;

LPMYJOYRANGE lpCurrentRanges = NULL;

extern CDIGameCntrlPropSheet_X *pdiCpl;

//===========================================================================
// FullJoyOemAccess()
//
// Check whether current user has full access to:
//   HKLM\SYSTEM\CurrentControlSet\Control\MediaProperties\PrivateProperties\Joystick\OEM
//
// Returns: 
//    true: has access
//   false: no access
//
//===========================================================================
bool FullJoyOemAccess()
{
    LONG lRc;
    HKEY hk;
    bool bRc;

    lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                       REGSTR_PATH_JOYOEM, 
                       0, 
                       KEY_ALL_ACCESS, 
                       &hk);
    
    if( lRc == ERROR_SUCCESS ) {
        bRc = true;
        RegCloseKey(hk);
    } else {
        bRc = false;
    }

    return bRc;
}

//===========================================================================
// Settings_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// Callback proceedure for Settings Page
//
// Parameters:
//  HWND    hWnd    - handle to dialog window
//  UINT    uMsg    - dialog message
//  WPARAM  wParam  - message specific data
//  LPARAM  lParam  - message specific data
//
// Returns: BOOL
//
//===========================================================================
INT_PTR CALLBACK Settings_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
//   static LPDIJOYCONFIG_DX5 pDIJoyConfig;

    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

        // OnHelp
    case WM_HELP:
        OnHelp(lParam);
        return(TRUE);

        // OnContextMenu
    case WM_CONTEXTMENU:
        OnContextMenu(wParam);
        return(TRUE);

        // OnDestroy
    case WM_DESTROY:
        bDlgCentered = FALSE;

//          if (pDIJoyConfig)
//              delete (pDIJoyConfig);
        break;

        // OnInitDialog
    case WM_INITDIALOG:
        // get ptr to our object
        if( !pdiCpl )
            pdiCpl = (CDIGameCntrlPropSheet_X*)((LPPROPSHEETPAGE)lParam)->lParam;

        // initialize DirectInput
        if( FAILED(InitDInput(GetParent(hWnd), pdiCpl)) ) {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: WM_INITDIALOG: InitDInput FAILED!\n"));
#endif
            Error(hWnd, (short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            PostMessage(GetParent(hWnd), WM_SYSCOMMAND, SC_CLOSE, 0);

            return(FALSE);
        }

        {
            if( !FullJoyOemAccess() ) {
                pdiCpl->SetUser(TRUE);
            }

            // Center the Dialog!
            // If it's not been centered!
            if( !bDlgCentered ) {
                // Set the title bar!
                SetTitle(hWnd);

                CenterDialog(hWnd);
                bDlgCentered = TRUE;
            }

            // Disable the Calibration button if they don't have any axis!!!
            // Leave the Reset to default...
            if( pdiCpl->GetStateFlags()->nAxis == 0 )
                PostDlgItemEnableWindow(hWnd, IDC_JOYCALIBRATE, FALSE);
        }
        break;

        // OnNotify
    case WM_NOTIFY:
        // perform any WM_NOTIFY processing, but there is none...
        // return TRUE if you handled the notification (and have set
        // the result code in SetWindowLong(hWnd, DWL_MSGRESULT, lResult)
        // if you want to return a nonzero notify result)
        // or FALSE if you want default processing of the notification.
        switch( ((NMHDR*)lParam)->code ) {
        case PSN_APPLY:
            // Kill the memory allocated for the Ranges struct
            Sleep(100);
            if( lpCurrentRanges ) {
                delete (lpCurrentRanges);
                lpCurrentRanges = NULL;
            }
/* We've removed the rudder stuff... but just in case it comes back...
                    if (nStatic & RUDDER_HIT)
                    {
                        LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
                        pdiCpl->GetJoyConfig(&pdiJoyConfig);

                        // get the status of the Rudder checkbox and assign it!
                  // THEN Add the rudder to the Axis mask!
                        if (pDIJoyConfig->hwc.dwUsageSettings & JOY_US_HASRUDDER)
                  {
                            pDIJoyConfig->hwc.dwUsageSettings &= ~JOY_US_HASRUDDER;
                     pdiCpl->GetStateFlags()->nAxis    &= ~HAS_RX;
                  }
                        else
                  {
                            pDIJoyConfig->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
                     pdiCpl->GetStateFlags()->nAxis    |= HAS_RX;
                  }

                        if (FAILED(pdiJoyConfig->Acquire()))
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: Settings_DlgProc: PSN_APPLY: Acquire FAILED!\n"));
#endif
                            break;
                        }

                  // Set the GUID to NULL to ask DINPUT to recreate!
                  pDIJoyConfig->guidInstance = NULL_GUID;

                        if (FAILED(pdiJoyConfig->SetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)pDIJoyConfig, DIJC_REGHWCONFIGTYPE)))
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: Settings_DlgProc: PSN_APPLY: SetConfig FAILED!\n"));
#endif
                            break;
                        }

                  // Remove the mask from nStatic
                  nStatic &= ~RUDDER_HIT;

                        if (FAILED(pdiJoyConfig->SendNotify()))
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: Settings_DlgProc: PSN_APPLY: SendNotify FAILED!\n"));
#endif
                        }
                        pdiJoyConfig->Unacquire();
                    }
*/
            break;

        case PSN_RESET:
            // if the user has changed the calibration... Set it back!
            if( lpCurrentRanges ) {
                LPDIRECTINPUTDEVICE2 pdiDevice2;
                pdiCpl->GetDevice(&pdiDevice2);

                SetMyRanges(pdiDevice2, lpCurrentRanges, pdiCpl->GetStateFlags()->nAxis);

                // Set POV possitions!
                //if (pdiCpl->GetStateFlags()->nPOVs)
                //   SetMyPOVRanges(pdiDevice2, lpCurrentRanges->dwPOV);

                LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
                pdiCpl->GetJoyConfig(&pdiJoyConfig);

                pdiJoyConfig->Acquire();
                pdiJoyConfig->SendNotify();

                delete (lpCurrentRanges);
                lpCurrentRanges = NULL;
            }
            break;

        default:
            break;
        }

        return(FALSE);

        // OnCommand
    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        // Set to Default button!!!
        case IDC_RESETCALIBRATION:
            if( pdiCpl->GetUser() ) {
                Error(hWnd, (short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
            } else
            {
                MYJOYRANGE ResetRanges;

                ZeroMemory(&ResetRanges, sizeof(MYJOYRANGE));

                LPDIRECTINPUTDEVICE2 pdiDevice2;
                pdiCpl->GetDevice(&pdiDevice2);

                SetMyRanges(pdiDevice2, &ResetRanges, pdiCpl->GetStateFlags()->nAxis);

                LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
                pdiCpl->GetJoyConfig(&pdiJoyConfig);

                pdiJoyConfig->Acquire();
                pdiJoyConfig->SendNotify();
            }
            break;

        case IDC_JOYCALIBRATE:
            if( pdiCpl->GetUser() ) {
                Error(hWnd, (short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
            } else 
            {
                nStatic |= CALIBRATING;
    
                if( !lpCurrentRanges ) {
                    lpCurrentRanges = new (MYJOYRANGE);
                    assert (lpCurrentRanges);
    
                    ZeroMemory (lpCurrentRanges, sizeof(MYJOYRANGE));
    
                    LPDIRECTINPUTDEVICE2 pdiDevice2;
                    pdiCpl->GetDevice(&pdiDevice2);
    
                    // Get Current Ranges!
                    GetMyRanges(pdiDevice2, lpCurrentRanges, pdiCpl->GetStateFlags()->nAxis);
                }
    
                if( CreateWizard(hWnd, (LPARAM)pdiCpl) ) {
    
                    // Set the flags
                    nStatic |= CAL_HIT;
    
                    HWND hSheet = GetParent(hWnd);
    
                    // take care of the Apply Now Button...
                    ::SendMessage(hSheet, PSM_CHANGED, (WPARAM)hWnd, 0L);
    
                    // Bug #179010 NT - Move to Test sheet after calibration!
                    ::PostMessage(hSheet, PSM_SETCURSELID, 0, (LPARAM)IDD_TEST);
                } else {
                    // if you canceled and it's your first time Kill the struct...
                    // then Reset the flag
                    if( !(nStatic & CAL_HIT) ) {
                        // Kill the memory allocated for the Ranges struct
                        if( lpCurrentRanges ) {
                            delete (lpCurrentRanges);
                            lpCurrentRanges = NULL;
                        }
                    }
                }
    
                nStatic &= ~CALIBRATING;
            }
            
            break;
        }
    }

    return(FALSE);

} //*** end Settings_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CPLSVR1.RC
//
#define IDI_JOYBTN                      101
#define IDI_GCICON                      108
#define IDD_FORCEFEEDBACK               111
#define IDB_CAL                         115
#define IDB_POVHUB                      127
#define IDB_CALSTART                    128
#define IDB_CALHD                       129
#define IDS_HELPFILENAME                850
#define IDC_GROUP_RUDDER                1018
#define IDC_TEXT_RUDDERHELP             1019
#define IDC_TEXT_AXESHELP               1021
#define IDC_GROUP_BUTTONS               1023
#define IDC_SLIDER1                     1032
#define IDC_MAGNITUDE_SLIDER            1032
#define IDC_SLIDER2                     1033
#define IDC_COEFFICIENT_SLIDER          1033
#define IDC_FF_RETURN                   1034
#define IDC_GAIN_SLIDER                 1034
#define IDC_FF_RETURN2                  1035
#define IDC_FF_RETURN3                  1036
#define IDC_FF_FEEDBACK                 1037
#define IDC_FF_FEEDBACK2                1038
#define IDC_FF_FEEDBACK3                1039
#define IDC_FF_DESC                     1040
#define IDC_FF_CENTREGRP                1041
#define IDC_FF_FFGRP                    1042
#define IDC_PROGRESS1                   1044
#define IDC_TEXT_CALHELP                1045
#define IDC_HEADERFRAME                 1045
#define IDC_SETTINGSGRP                 1046
#define IDC_RAWDATA                     1046
#define IDC_AXISGRP                     1047
#define IDC_RAWX                        1047
#define IDC_RAWY                        1048
#define IDC_RAWXOUTPUT                  1049
#define IDC_RAWYOUTPUT                  1050
#define IDC_WHITEFILL                   1051
#define IDC_INIT_TITLE                  1052
#define IDC_INIT_SUBTITLE               1055
#define IDC_JOYLIST2_SPIN               1056
#define IDC_JOYLIST3_SPIN               1057
#define IDC_JOYLIST2_SPIN3              1058
#define IDC_                            1059
#define IDC_X_DEADZONE                  1060
#define IDC_X_DEADZONE_SPIN             1061
#define IDC_X_DEADZONE2                 1062
#define IDC_X_DEADZONE_SPIN2            1063
#define IDC_JOYLIST5_SPIN               1064
#define IDC_X_AXIS_LABEL                1064
#define IDC_JOYLIST6_SPIN               1065
#define IDC_SATURATION_TITLE            1065
#define IDC_JOYLIST7_SPIN               1066
#define IDC_X_SATURATION                1066
#define IDC_X_SATURATION_SPIN           1067
#define IDC_X_AXIS_LABEL1               1068
#define IDC_X_DEADZONE3                 1069
#define IDC_X_DEADZONE_SPIN3            1070
#define IDC_Y_AXIS_LABEL1               1071
#define IDC_Y_AXIS_LABEL                1072
#define IDC_MAGNITUDE_GRP               1073
#define IDC_COEFFICIENT_GRP             1074
#define IDC_SETPOV                      1075
#define IDD_SETTINGS                    4201
#define IDD_TEST                        4203
#define IDS_GENERAL_TAB_1               5010
#define IDS_DEVICE_DESC_1               5020
#define IDS_DEVICE_DESC_2               5021
#define IDS_ASSIGN_1                    5030
#define IDS_PROPERTIES_1                5040
#define IDS_TEST_1                      5050
#define IDS_OK_1                        5060
#define IDS_CANCEL_1                    5070
#define IDS_APPLY_1                     5080
#define IDS_POSITION_LBL_1              5130
#define IDS_JOYSTICK_LBL_1              5150
#define IDS_THROTTLE_LBL_1              5160
#define IDS_RUDDER_LBL_1                5170
#define IDS_POVHAT_LBL_1                5180
#define IDS_BUTTONS_LBL_1               5190
#define IDS_PROP_TAB_1                  5300
#define IDS_RUDDERS_DESC_1              5310
#define IDS_RUDDERS_DESC_2              5311
#define IDS_LEGPROP_TBAR_1              5340
#define IDS_ASSIGN_TBAR_1               5360
#define IDS_DEVSEL_COBOX_1              5370
#define IDS_ASSIGN_COBOX_1              5380
#define ID_MAINCP_TBAR_1                5400
#define IDS_CALIBRATE_DESC_1            5410
#define IDS_SETTING_PRODUCT_NAME_1      5420
#define IDS_SETTING_PRODUCT_NAME_2      5421
#define IDS_SETTING_PRODUCT_NAME_3      5422
#define IDS_VERSION_1                   5430
#define IDS_COPYRIGHT_1                 5440
#define IDS_COPYRIGHT_2                 5441
#define IDS_PID_1                       5450
#define IDS_NUM_DEVICES_1               5460
#define IDS_DIAGNOSTICS_1               5470
#define IDS_ERROR_1                     5520
#define IDS_LVHEADING_DEVICE_1          5700
#define IDS_LVHEADING_STATUS_1          5710
#define IDS_LVHEADING_ASSIGN_1          5720
#define IDS_STATUS_OK_1                 5730
#define IDS_STATUS_NOTCONNECTED_1       5740
#define IDS_CPANEL_TITLE                5760
#define IDS_JOYINFO_1                   6000
#define IDS_JOY_1                       6010
#define IDS_JOY2_1                      6020
#define IDS_JOY2S_1                     6030
#define IDS_JOYCALXY_CENTER_1           6040
#define IDS_JOYCALXY_MOVE_1             6050
#define IDS_JOYCALZ_MOVE_1              6060
#define IDS_JOYCALPOV_MOVE_1            6070
#define IDS_JOYCAL_UP_1                 6080
#define IDS_JOYCAL_DOWN_1               6090
#define IDS_JOYCAL_LEFT_1               6100
#define IDS_JOYCAL_RIGHT_1              6110
#define IDS_JOYTESTCAPN_1               6120
#define IDS_JOYBUTTON1_1                6130
#define IDS_JOYBUTTON2_1                6140
#define IDS_JOYCALCAPN_1                6150
#define IDS_JOYUNPLUGGED_1              6160
#define IDS_JOYCALXY_MOVEYOKE_1         6170
#define IDS_JOYCAL_DONE_1               6180
#define IDS_JOYCALXY_MOVEGAMEPAD_1      6190
#define IDS_JOYCALXY_CENTERGAMEPAD_1    6200
#define IDS_JOYCALXY_CENTERYOKE_1       6210
#define IDS_JOYREADERROR_1              6220
#define IDS_JOYCALRUDDER_MOVE_1         6230
#define IDS_JOYCALXY_MOVECAR_1          6240
#define IDS_JOYCALXY_CENTERCAR_1        6250
#define IDS_JOYCALXY_CENTER2_1          6260
#define IDS_JOYCAL_YOKE_1               6270
#define IDS_JOYCAL_CAR_1                6280
#define IDS_JOYCAL_GAMEPAD_1            6290
#define IDS_JOYNOTPRESENT_1             6300
#define IDS_JOYCAL_NOTDONE_1            6310
#define IDS_JOYCALU_MOVE_1              6320
#define IDS_JOYCALV_MOVE_1              6330
#define IDS_JOYRESTARTMSG1_1            6340
#define IDS_JOYRESTARTMSG1_2            6341
#define IDS_JOYRESTARTMSG2_1            6350
#define IDS_JOYCALXY_CENTERGAMEPAD2_1   6360
#define IDS_JOYCALXY_CENTERYOKE2_1      6370
#define IDS_JOYCALXY_CENTERCAR2_1       6380
#define IDS_JOYCAL_YOKES_1              6390
#define IDS_JOYCAL_CARS_1               6400
#define IDS_JOYCAL_GAMEPADS_1           6410
#define IDS_JOYCALINDICATOR_1           6420
#define IDS_VAXIS_LABEL_1               6430
#define IDS_UAXIS_LABEL_1               6440
#define IDS_POVAXIS_LABEL_1             6450
#define IDS_ZAXIS_LABEL_1               6460
#define IDS_XYAXIS_LABEL_1              6470
#define IDS_RAXIS_LABEL_1               6480
#define IDS_JOYPICKPOV_1                6490
#define IDS_JOYCALBACK_1                6500
#define IDS_JOYCALNEXT_1                6510
#define IDS_JOYCALDONE_1                6520
#define IDS_JOYCALGROUP_1               6530
#define IDS_JOYCALS_MOVE                6531
#define IDS_JOYHW0_1                    7000
#define IDC_TESTJOYBTNICON1             7001
#define IDC_TESTJOYBTNICON2             7002
#define IDC_TESTJOYBTNICON3             7003
#define IDC_TESTJOYBTNICON4             7004
#define IDC_TESTJOYBTNICON5             7005
#define IDC_TESTJOYBTNICON6             7006
#define IDC_TESTJOYBTNICON7             7007
#define IDC_TESTJOYBTNICON8             7008
#define IDC_TESTJOYBTNICON9             7009
#define IDC_TESTJOYBTNICON10            7010
#define IDS_JOYHW1_1                    7010
#define IDC_TESTJOYBTNICON11            7011
#define IDC_TESTJOYBTNICON12            7012
#define IDC_TESTJOYBTNICON13            7013
#define IDC_TESTJOYBTNICON14            7014
#define IDC_TESTJOYBTNICON15            7015
#define IDC_TESTJOYBTNICON16            7016
#define IDC_TESTJOYBTNICON17            7017
#define IDC_TESTJOYBTNICON18            7018
#define IDC_TESTJOYBTNICON19            7019
#define IDC_TESTJOYBTNICON20            7020
#define IDC_TESTJOYBTNICON21            7021
#define IDC_TESTJOYBTNICON22            7022
#define IDC_TESTJOYBTNICON23            7023
#define IDC_TESTJOYBTNICON24            7024
#define IDC_TESTJOYBTNICON25            7025
#define IDC_TESTJOYBTNICON26            7026
#define IDC_TESTJOYBTNICON27            7027
#define IDC_TESTJOYBTNICON28            7028
#define IDC_TESTJOYBTNICON29            7029
#define IDC_TESTJOYBTNICON30            7030
#define IDC_TESTJOYBTNICON31            7031
#define IDC_TESTJOYBTNICON32            7032
#define IDS_CUSTOM_TBAR_1               8010
#define IDS_CUSTOM_AXES_1               8020
#define IDS_CUSTOM_SPECIAL_1            8090
#define IDS_SHEET_CAPTION               9000
#define IDS_PAGE_TITLE1                 9001
#define IDS_PAGE_TITLE2                 9002
#define IDI_BUTTONOFF                   9998
#define IDI_BUTTONON                    9999
#define IDS_TEXT_AXESHELP               10051
#define IDS_JOYREADERROR                10052
#define IDS_JOYUNPLUGGED                10053
#define IDS_JOYCAL_MOVE                 10054
#define IDS_JOYCALRUDDER_MOVE           10055
#define IDS_JOYCALU_MOVE                10056
#define IDS_JOYCALV_MOVE                10057
#define IDS_JOYCALPOV_MOVE              10058
#define IDS_JOYCAL_UP                   10059
#define IDS_JOYCAL_RIGHT                10060
#define IDS_JOYCAL_DOWN                 10061
#define IDS_JOYCAL_LEFT                 10062
#define IDS_JOYCAL_DONE                 10063
#define IDS_JOYCAL_NOTDONE              10064
#define IDS_JOYCAL_YOKES                10065
#define IDS_JOYCAL_YOKE                 10066
#define IDS_JOYCAL_CARS                 10067
#define IDS_JOYCAL_CAR                  10068
#define IDS_JOYCAL_GAMEPADS             10069
#define IDS_JOYCAL_GAMEPAD              10070
#define IDS_JOY2S                       10071
#define IDS_JOY2                        10072
#define IDC_JOYCALIBRATE                12291
#define IDC_JOY1HASRUDDER               12333
#define IDC_GROUP_POV                   12349
#define IDC_RESETCALIBRATION            12350
#define IDS_INTERNAL_ERROR              12351
#define IDS_NO_DIJOYCONFIG              12352
#define IDS_RENAME                      12353
#define IDC_RENAME                      12354
#define IDC_WIZARD_MSG                  12357
#define IDS_CALIBRATION                 12358
#define IDC_WIZARD_MSG_HDR              12358
#define IDS_INITIAL_CAL_TITLE           12359
#define IDS_SLIDER_CAL_TITLE            12360
#define IDS_POV_CAL_TITLE               12361
#define IDC_BLACKBAR                    12362
#define IDC_JOYLIST1_PROGRESS           12363
#define IDC_JOYLIST2_PROGRESS           12364
#define IDC_SLIDER                      12365
#define IDC_HEADERBITMAP                12366
#define IDS_RETRY                       12366
#define IDS_CENTER_HDR                  12367
#define IDS_VERIFY_CENTER_HDR           12368
#define IDS_AXIS_CALIBRATION            12369
#define IDS_CALIBRATION_FINI            12370
#define IDS_USER_MODE_TITLE             12371
#define IDS_USER_MODE                   12372
#define IDS_POV_CALIBRATION				12373
#define IDC_BITMAP                      -1
#define IDC_DEADZONE_TITLE              -1
#define IDC_GAIN_GRP                    -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1076
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\handler\hsvrguid.h ===
// --------------------------------------------
// Servers GUID's
// Author	: Guru Datta Venkatarama
// Date		: 1/20/1997
// Project	: ATLAS 1.0
// Notes 	: All the GUIDS here have been generated new as of 2/25/97. Hence
//			  They are guaranteed to be unique.
//				 {7854FB21-8EE3-11d0-A1AC-0000F8026977}
//				 {7854FB22-8EE3-11d0-A1AC-0000F8026977}
//				 {7854FB23-8EE3-11d0-A1AC-0000F8026977}
//				 {92187321-72B4-11d0-A1AC-0000F8026977}
//				 {92187322-72B4-11d0-A1AC-0000F8026977}
//				 {92187323-72B4-11d0-A1AC-0000F8026977}
//				 {92187323-72B4-11d0-A1AC-0000F8026977}
//				 {92187324-72B4-11d0-A1AC-0000F8026977}
//				 {92187325-72B4-11d0-A1AC-0000F8026977}
//				 {92187326-72B4-11d0-A1AC-0000F8026977}
// --------------------------------------------

// --------------------------------------------
// --------------------------------------------

#ifndef _HSVRGUID_
#define _HSVRGUID_
// These are the custom interfaces that we have defined
// {7854FB21-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IServerCharacteristics, 
0x7854fb21, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

#ifndef _DX_CPL_
// {7854FB22-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IDIGameCntrlPropSheet, 
0x7854fb22, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);
#endif //_DX_CPL_
// --------------------------------------------
// --------------------------------------------

// {92187321-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_FlashServer, 
0x92187321, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187322-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_MidasServer, 
0x92187322, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187323-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_ShazamServer, 
0x92187323, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187324-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_JoltServer, 
0x92187324, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187325-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_JunoServer, 
0x92187325, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187326-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_LegacyServer, 
0x92187326, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// --------------------------------------------
// --------------------------------------------
#endif
// -------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\default\test.cpp ===
//===========================================================================
// TEST.CPP
//
// Functions:
//    Test_DlgProc()
//    DoJoyMove()
//    DoTestButtons()
//    DoTestPOV()
//    DrawCross()
//    DisplayAvailableButtons()
//    JoyError()
//    DisplayAvailablePOVs()
//    SetOEMWindowText()
//
//===========================================================================

// This is necessary for UnregisterDeviceNotification!
#if (WINVER < 0x0500)
    #undef WINVER
    #define WINVER 0x0500
#endif

#include "cplsvr1.h"
#include <initguid.h>
#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!
#include <hidclass.h>

#include "dicputil.h"
#include "resource.h"
#include "pov.h"
#include "assert.h"
#include <regstr.h>  // for REGSTR_VAL_'s below
#include <commctrl.h> // for CProgressCtrl!
#include <shlwapi.h>  // for Str... functions!

#include "Gradient.h" // for Gradient Fill Slider!

#ifndef LONG2POINT
    #define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))
#endif // LONG2POINT

// local functions for services exclusive to this module!
static void DisplayAvailablePOVs    ( const HWND hWndToolTip, const HWND hDlg, BYTE nPOVs );
static void DisplayAvailableButtons( const HWND hWndToolTip, const HWND hDlg, const int nNumButtons );
static void DisplayAvailableAxisTest(const HWND hWndToolTip, const HWND hDlg, BYTE nAxisFlags, LPDIRECTINPUTDEVICE2 pdiDevice2);
static void DoTestButtons           ( const HWND hDlg, PBYTE pbButtons, int nButtons );
static short JoyError            ( const HWND hDlg );
static BOOL SetDeviceRanges     ( const HWND hDlg, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis );
static DWORD DecodeAxisPOV( DWORD dwVal );

// Local defines
#define DELTA              5
#define ID_JOY_TIMER       2002
#define TIMER_INTERVAL     45      // time between polls in milliseconds
#define MAX_SLIDER_POS     100
#define MIN_SLIDER_POS     0
#define FORCE_POV_REFRESH  254


#define ACTIVE_COLOR       RGB(255,0,0)
#define INACTIVE_COLOR     RGB(128,0,0)

extern BOOL bDlgCentered;
extern BYTE nStatic;
extern CDIGameCntrlPropSheet_X *pdiCpl;
extern HINSTANCE ghInst;

BOOL bGradient;

static HWND ProgWnd[NUM_WNDS];
static CGradientProgressCtrl *pProgs[NUM_WNDS];
static HPEN hTextPen;
static HPEN hWinPen;

LPDIJOYSTATE lpDIJoyState;

extern HICON hIconArray[2];

//===========================================================================
// Test_DlgProc
//
// Parameters:
//  HWND    hWnd    - handle to dialog window
//  UINT    uMsg    - dialog message
//  WPARAM  wParam  - message specific data
//  LPARAM  lParam  - message specific data
//
// Returns: BOOL
//
//===========================================================================
INT_PTR CALLBACK Test_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPDIRECTINPUTDEVICE2 pdiDevice2;
    static PVOID hNotifyDevNode;     
    static HWND hWndToolTip;
    static BYTE nAxis;

    switch( uMsg ) {
/*
#ifdef _UNICODE
       case WM_DEVICECHANGE:  
        if ((UINT)wParam == DBT_DEVICEREMOVECOMPLETE)
        {
                if (nStatic & CALIBRATING)
                    break;

                pdiDevice2->Unacquire();

                if (FAILED(pdiDevice2->Acquire()))
                {
                    KillTimer(hWnd, ID_JOY_TIMER);

                    Error(hWnd, (short)IDS_JOYREADERROR, (short)IDS_JOYUNPLUGGED);

// if you call this function you will hang up the system for 30 seconds or more!!!
               if (hNotifyDevNode)
                    UnregisterDeviceNotification(hNotifyDevNode);
                    ::PostMessage(GetParent(hWnd), WM_COMMAND, IDOK, 0);
                }
        }
        break;
#endif
*/
    case WM_ACTIVATEAPP:
        if( wParam ) {
            pdiDevice2->Acquire();

            // Hack for bug #228798
            if( lpDIJoyState ) {
                // This is to refresh the cross hair...
                lpDIJoyState->lX+=1;
                DoJoyMove( hWnd, nAxis );

                // This is to refresh the POV
                if( pdiCpl->GetStateFlags()->nPOVs )
                    DoTestPOV(FORCE_POV_REFRESH, lpDIJoyState->rgdwPOV, hWnd);
            }

            SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
        } else {
            KillTimer(hWnd, ID_JOY_TIMER);
            pdiDevice2->Unacquire();
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

        // OnHelp
    case WM_HELP:
        KillTimer(hWnd, ID_JOY_TIMER);
        OnHelp(lParam);
        SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
        return(TRUE);

        // OnContextMenu
    case WM_CONTEXTMENU:
        KillTimer(hWnd, ID_JOY_TIMER);
        OnContextMenu(wParam);
        SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
        return(TRUE);

        // OnInit
    case WM_INITDIALOG:
        // get ptr to our object
        if( !pdiCpl )
            pdiCpl = (CDIGameCntrlPropSheet_X*)((LPPROPSHEETPAGE)lParam)->lParam;

        hTextPen = hWinPen = NULL;

        // Establish if you have enough colours to display the gradient fill scroll bar!
        {
            HDC hDC = ::GetWindowDC(hWnd);
            if( hDC ) { // Prefix Whistler Bug#45099
                bGradient = (BOOL)(GetDeviceCaps(hDC, NUMCOLORS) < 0);
                ::ReleaseDC(hWnd, hDC);
            }
        }

        // load the up and down states!
        hIconArray[0] = (HICON)LoadImage(ghInst, (PTSTR)IDI_BUTTONON,  IMAGE_ICON, 0, 0, NULL);
        assert (hIconArray[0]);

        hIconArray[1] = (HICON)LoadImage(ghInst, (PTSTR)IDI_BUTTONOFF, IMAGE_ICON, 0, 0, NULL);
        assert (hIconArray[1]);

        // initialize DirectInput
        if( FAILED(InitDInput(GetParent(hWnd), pdiCpl)) ) {
            Error(hWnd, (short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hWnd), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            PostMessage(GetParent(hWnd), WM_SYSCOMMAND, SC_CLOSE, 0);

            return(FALSE);
        }

        // Get the device2 interface pointer
        pdiCpl->GetDevice(&pdiDevice2);

        nAxis = pdiCpl->GetStateFlags()->nAxis;

        // Set The scale for the Device Range!!!
        SetDeviceRanges(hWnd, pdiDevice2, nAxis);

        LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
        pdiCpl->GetJoyConfig(&pdiJoyConfig);

        // Create the Pens for X/Y axis!
        CreatePens();

        // Create ToolTip window!
        hWndToolTip = CreateWindowEx( 0, TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP, 
                                      CW_USEDEFAULT, CW_USEDEFAULT, 10, 10, hWnd, NULL, ghInst, NULL);

        // Show the available Axis!
        DisplayAvailableAxisTest(hWndToolTip, hWnd, nAxis, pdiDevice2);

        DisplayAvailableButtons(hWndToolTip, hWnd, pdiCpl->GetStateFlags()->nButtons);

        DisplayAvailablePOVs(hWndToolTip, hWnd, pdiCpl->GetStateFlags()->nPOVs);

        lpDIJoyState = new (DIJOYSTATE);
        assert(lpDIJoyState);

        ZeroMemory(lpDIJoyState, sizeof(DIJOYSTATE));

        // Clear the Static vars in DoJoyMove!
        DoJoyMove(hWnd, nAxis);

        // Center the Dialog!
        // If it's not been centered!
        if( !bDlgCentered ) {
            SetTitle(hWnd);
            CenterDialog(hWnd);
            bDlgCentered = TRUE;
        }

        {
            // Get the Type name
            DIJOYCONFIG_DX5 DIJoyConfig;

            ZeroMemory(&DIJoyConfig, sizeof(DIJOYCONFIG_DX5));

            DIJoyConfig.dwSize = sizeof(DIJOYCONFIG_DX5);

            if( SUCCEEDED(pdiJoyConfig->GetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)&DIJoyConfig, DIJC_REGHWCONFIGTYPE)) ) {
                if( DIJoyConfig.hwc.dwUsageSettings & JOY_US_ISOEM ) {
                    LPCTSTR pszLabels[] = { 
                        REGSTR_VAL_JOYOEMTESTMOVEDESC,
                        REGSTR_VAL_JOYOEMTESTMOVECAP,
                        REGSTR_VAL_JOYOEMTESTBUTTONCAP,
                        REGSTR_VAL_JOYOEMPOVLABEL,
                        REGSTR_VAL_JOYOEMTESTWINCAP};

                    const short nControlIDs[] = {
                        IDC_TEXT_AXESHELP,
                        IDC_AXISGRP,
                        IDC_GROUP_BUTTONS,
                        IDC_GROUP_POV,
                        0};

                    SetOEMWindowText(hWnd, nControlIDs, pszLabels, DIJoyConfig.wszType, pdiJoyConfig, (BYTE)(sizeof(nControlIDs)/sizeof(short))-1);
                }
                
                bPolledPOV = (DIJoyConfig.hwc.hws.dwFlags & JOY_HWS_HASPOV) && (DIJoyConfig.hwc.hws.dwFlags & JOY_HWS_POVISPOLL);
                CalibratePolledPOV( &DIJoyConfig.hwc );
            }

#ifdef _UNICODE     
            // Set up the Device Notification
            // Removed per Om...
            //RegisterForDevChange(hWnd, &hNotifyDevNode);
#endif
        }
        break; // end of WM_INITDIALOG

        // OnTimer
    case WM_TIMER:
        if( SUCCEEDED(DIUtilPollJoystick(pdiDevice2,  lpDIJoyState)) ) {
            if( nAxis )
                DoJoyMove( hWnd, nAxis );

            if( pdiCpl->GetStateFlags()->nButtons )
                DoTestButtons( hWnd, lpDIJoyState->rgbButtons, pdiCpl->GetStateFlags()->nButtons );

            if( pdiCpl->GetStateFlags()->nPOVs )
                DoTestPOV( pdiCpl->GetStateFlags()->nPOVs, lpDIJoyState->rgdwPOV, hWnd );
        } else {
            KillTimer(hWnd, ID_JOY_TIMER);
            pdiDevice2->Unacquire();
            if( JoyError( hWnd ) == IDRETRY ) {
                pdiDevice2->Acquire();
                SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
            } else {
                // Send a message back to the CPL to update list, as it may have changed!
                ::PostMessage(GetParent(hWnd), WM_COMMAND, IDOK, 0);
            }
        }
        break;  // end of WM_TIMER

        // All this has to be done because WM_MOUSEMOVE doesn't get sent to static text!
    case WM_MOUSEMOVE:
        if( hWndToolTip ) {
            POINT pt;
            LONG2POINT(lParam, pt);
            HWND hChildWnd = ::ChildWindowFromPoint(hWnd, pt);
            static HWND hPrev;

            if( hChildWnd != hPrev && hChildWnd !=NULL ) {
                switch( GetDlgCtrlID(hChildWnd) ) {
                case IDC_JOYLIST1_LABEL:
                case IDC_JOYLIST2_LABEL:
                case IDC_JOYLIST3_LABEL:
                case IDC_JOYLIST4_LABEL:
                case IDC_JOYLIST5_LABEL:
                case IDC_JOYLIST6_LABEL:
                case IDC_JOYLIST7_LABEL:
                    if( IsWindowVisible(hChildWnd) ) {
                        MSG   msg;

                        //we need to fill out a message structure and pass it to the tooltip 
                        //with the TTM_RELAYEVENT message
                        msg.hwnd    = hWnd;
                        msg.message = uMsg;
                        msg.wParam  = wParam;
                        msg.lParam  = lParam;
                        msg.time    = GetMessageTime();
                        GetCursorPos(&msg.pt);

                        ::SendMessage(hWndToolTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
                    }
                    break;

                    // We don't need to trap for anything else, as the rest are TTF_SUBCLASS'd
                default:
                    break;
                }

                // store the last one so we don't have to do this again...
                hPrev = hChildWnd;
            }
        }
        break;

        // OnDestroy
    case WM_DESTROY:
        bDlgCentered = FALSE;

        KillTimer(hWnd, ID_JOY_TIMER);

        // Delete the button icons...
        DestroyIcon(hIconArray[0]);
        DestroyIcon(hIconArray[1]);
        
        // Kill pProgs
        if( bGradient ) {
            BYTE nAxisCounter = MAX_AXIS - 3;

            BYTE nTmpFlags = nAxis;

            // Clear the X and Y flags... they don't have progress controls
            // associated with them!
            nTmpFlags &= ~(HAS_X | HAS_Y);

            while( nTmpFlags ) {
                if( nTmpFlags & (HAS_Z<<nAxisCounter) ) {
                    delete (pProgs[nAxisCounter]);
                    pProgs[nAxisCounter] = 0;
                    nTmpFlags &= ~(HAS_Z<<nAxisCounter);
                }
                nAxisCounter--;
            }
        }

        // Destroy the pens!
        if (hTextPen)
            DeleteObject(hTextPen);

        if( hWinPen )
            DeleteObject(hWinPen);

        if( lpDIJoyState ) {
            delete (lpDIJoyState);
            lpDIJoyState = NULL;
        }

        // Make sure you set this to NULL!
        pdiDevice2 = NULL;

        break;  // end of WM_DESTROY

        // OnNotify
    case WM_NOTIFY:
        switch( ((NMHDR*)lParam)->code ) {
        case PSN_SETACTIVE:
            if( pdiDevice2 ) {
                pdiDevice2->Acquire();

                // if you have this, you are safe to start the timer!
                if( lpDIJoyState )
                    SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);

                lpDIJoyState->lX+=1;
                DoJoyMove(hWnd, HAS_X | HAS_Y);
            }
            break;

        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_JOY_TIMER);
            pdiDevice2->Unacquire();
            break;
        }

        break;  // end of WM_NOTIFY

    case WM_SYSCOLORCHANGE:
        {
            //Destroy old pens.
            if (hTextPen)
            {
                DeleteObject(hTextPen);
                hTextPen=NULL;
            }

            if(hWinPen)
            {
                DeleteObject(hWinPen);
                hWinPen=NULL;
            }
            //Recreate pens with new colors.
            CreatePens();

            //Change colors of slider bars.
            for(int i=0;i<NUM_WNDS;i++)
            {
                if(pProgs[i]) {
                    pProgs[i]->SetBkColor(GetSysColor(COLOR_WINDOW));
                }
            }
        }
        break;

    }
    return(FALSE);
} //*** end Test_DlgProc()


//===========================================================================
// DoJoyMove( HWND hDlg, LPDIJOYSTATE pDIJoyState, int nDrawFlags )
//
// Reports to hDlg state information from pDIJoyState, dwDrawFlags, and pJoyRange;
//
// Parameters:
//  HWND                    hDlg                -       Handle to Dialog
//  LPDIJOYSTATE        pDIJoyState     -       State information about the device
//  LPJOYRANGE          pJoyRange
//
// Returns:             nichts
//
//===========================================================================
void DoJoyMove( const HWND hDlg, BYTE nDrawFlags )
{
    if( !::IsWindow(hDlg) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoJoyMove: hDlg: Not a valid window!\n"));
#endif
        return;
    }

    if( nDrawFlags == 0 ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoJoyMove: nDrawFlags is Zero!\n"));
#endif
        return;
    }

    // draw the cross in the XY box if needed
    if( (nDrawFlags & HAS_X) || (nDrawFlags & HAS_Y) ) {
        static POINTS ptOld = {DELTA,DELTA};

        HWND hCtrl = GetDlgItem( hDlg, IDC_JOYLIST1 );
        assert(hCtrl);

        //RedrawWindow(hCtrl, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

        RECT rc;
        GetClientRect(hCtrl, &rc);

        // The Real Max is rc.bottom-DELTA!
        rc.bottom -= DELTA;

        // Check for ranges - Y Axis
        if( lpDIJoyState->lY > rc.bottom ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved Y pos > Max Y pos!\n"));
#endif   
            lpDIJoyState->lY = rc.bottom;
        } else if( lpDIJoyState->lY < DELTA ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved Y pos < Min Y pos!\n"));
#endif   
            lpDIJoyState->lY = DELTA;
        }

        // Check for ranges - X Axis
        if( lpDIJoyState->lX > rc.right ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved X pos > Max X pos!\n"));
#endif   
            lpDIJoyState->lX = rc.right;
        } else if( lpDIJoyState->lX < DELTA ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved X pos < Min X pos!\n"));
#endif   
            lpDIJoyState->lX = DELTA;
        }

        // out with the old...
        if( (ptOld.x != (short)lpDIJoyState->lX) || (ptOld.y != (short)lpDIJoyState->lY) ) {
            // Sorry... no drawing outside of your RECT!
            if( (ptOld.x > (rc.right-DELTA)) || (ptOld.y > rc.bottom) ) {
                ptOld.x = ptOld.y = DELTA;
                return;
            }

            DrawCross(hCtrl, &ptOld, COLOR_WINDOW );

            ptOld.x = (short)lpDIJoyState->lX;
            ptOld.y = (short)lpDIJoyState->lY;

            // in with the new...
            DrawCross( hCtrl, &ptOld, COLOR_WINDOWTEXT );
        }

        nDrawFlags &= ~(HAS_X | HAS_Y);
    }

    // draw Z bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_Z ) {
            static BYTE nOldZ; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lZ != nOldZ ) {
                if( bGradient )
                    pProgs[Z_INDEX]->SetPos(lpDIJoyState->lZ);

                ::PostMessage(ProgWnd[Z_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lZ - MAX_SLIDER_POS), 0L);

                nOldZ = (BYTE)lpDIJoyState->lZ;
            }
            nDrawFlags &= ~HAS_Z;
        }
    } else return;

    // draw Slider0 bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_SLIDER0 ) {
            // Any value > 100, as that's the largest one we'll ever recieve!
            static BYTE nOldS0; //  = MAX_SLIDER_POS+1;

            if( lpDIJoyState->rglSlider[0] != nOldS0 ) {
                nOldS0 = (BYTE)lpDIJoyState->rglSlider[0];

                if( bGradient )
                    pProgs[S0_INDEX]->SetPos(lpDIJoyState->rglSlider[0]);

                ::PostMessage(ProgWnd[S0_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->rglSlider[0]-MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_SLIDER0;
        }
    } else return;

    // draw Rx bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_RX ) {
            static BYTE nOldRx; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lRx != nOldRx ) {
                nOldRx = (BYTE)lpDIJoyState->lRx;

                if( bGradient )
                    pProgs[RX_INDEX]->SetPos(lpDIJoyState->lRx);

                ::PostMessage(ProgWnd[RX_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lRx - MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_RX;
        }
    } else return;

    // draw Ry bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_RY ) {
            static BYTE nOldRy; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lRy != nOldRy ) {
                nOldRy = (BYTE)lpDIJoyState->lRy;

                if( bGradient )
                    pProgs[RY_INDEX]->SetPos(lpDIJoyState->lRy);

                ::PostMessage(ProgWnd[RY_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lRy - MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_RY;
        }
    } else return;

    // draw Rz bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_RZ ) {
            static BYTE nOldRz; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lRz != nOldRz ) {
                nOldRz = (BYTE)lpDIJoyState->lRz;

                if( bGradient )
                    pProgs[RZ_INDEX]->SetPos(lpDIJoyState->lRz);

                ::PostMessage(ProgWnd[RZ_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lRz - MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_RZ;
        }
    } else return;

    // draw Slider1 bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_SLIDER1 ) {
            static BYTE nOldS1; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->rglSlider[1] != nOldS1 ) {
                nOldS1 = (BYTE)lpDIJoyState->rglSlider[1];
                if( bGradient )
                    pProgs[S1_INDEX]->SetPos(lpDIJoyState->rglSlider[1]);

                ::PostMessage(ProgWnd[S1_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->rglSlider[1] - MAX_SLIDER_POS), 0L);
            }
        }
    }
} // *** end of DoJoyMove

//===========================================================================
// DoTestButtons( HWND hDlg, PBYTE pbButtons, short nButtons )
// 
// Lites whatever button(s) that may be pressed.
//
// Parameters:
//  HWND                    hDlg            -       Handle to Dialog
//  PBYTE                   pbButtons       -       Pointer to byte array of buttons and their states
//  int                     dwButtons       -       Number of buttons on device (per STATEFLAGS struct)
//
// Returns:                 nichts
//
//===========================================================================
static void DoTestButtons( const HWND hDlg, PBYTE pbButtons, int nButtons )
{
    // validate pointer(s)
    if( (IsBadReadPtr((void*)pbButtons, sizeof(BYTE))) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoTestButtons: Bad Read Pointer argument!\n"));
#endif
        return;
    }

    if( (IsBadWritePtr((void*)pbButtons, sizeof(BYTE))) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoTestButtons: Bad Write Pointer argument!\n"));
#endif
        return;
    }

    // Don't worry about the Zero Button condition!
    // It's being done in the timer!
    static BYTE bLookup[MAX_BUTTONS] = {NULL};

    BYTE i = 0;

    // Loop threw the buttons looking only at the ones we know we have!
    while( nButtons && (nButtons & (HAS_BUTTON1<<i)) ) {
        // check for a button press
        if( pbButtons[i] != bLookup[i] ) {
            // update the button with the proper bitmap
            HWND hCtrl = GetDlgItem(hDlg, IDC_TESTJOYBTNICON1+i);

            // Set the Extra Info
            SetWindowLongPtr(hCtrl, GWLP_USERDATA, (LONG_PTR)(pbButtons[i] & 0x80) ? 1 : 0);

            RedrawWindow(hCtrl, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            // update the lookup table
            bLookup[i] = pbButtons[i];
        }

        // strip the button!
        nButtons &= ~(HAS_BUTTON1<<i++);
    } 
} // end of DoTestButtons

//===========================================================================
// DoTestPOV( PDWORD pdwPOV )
//
// Routes a call to SetDegrees to set the degrees to pdwPOV 
//
// Parameters:
//  PDWORD                  pdwPOV          -       degrees at which to display the POV arrow
//
// Returns:                 nichts
//
//===========================================================================
void DoTestPOV( BYTE nPov, PDWORD pdwPOV, HWND hDlg )
{
    // Assume all POV's to be centred at start
    // JOY_POVCENTERED is defined as 0xffffffff
    static short dwOldPOV[MAX_POVS] = {-1,-1,-1,-1};
    BYTE nPovCounter = MAX_POVS-1;
    BYTE nPovs = 0;
    BOOL bChanged = FALSE;

    if( nPov == FORCE_POV_REFRESH ) {
        nPovs = 1;
        bChanged = TRUE;
    } else {
        // You Never have to worry about nPov being Zero, 
        // it is checked before entering this function!
        do {
            // Be aware that nPov is not just a number... it's a bit mask!
            if( nPov & (HAS_POV1<<nPovCounter) ) {
                DWORD dwPov = (nPov & HAS_CALIBRATED) ? pdwPOV[nPovCounter] : pdwPOV[nPovCounter];

                if( dwOldPOV[nPovCounter] != (int)dwPov ) {
                    dwOldPOV[nPovCounter] = (dwPov > 36001) ? -1 : (int)dwPov;

                    bChanged = TRUE;
                }

                nPovs++;
                nPov &= ~(HAS_POV1<<nPovCounter);
            }
        } while( nPovCounter-- && nPov );
    }

    if( bChanged ) {
        SetDegrees(nPovs, dwOldPOV, GetDlgItem(hDlg, IDC_JOYPOV));
    }

} // *** end of DoTestPOV 

//===========================================================================
// DrawCross( HWND hwnd, LPPOINTS pPoint, short nFlag)
//
// Draws a cross on hwnd at pPoint of type nFlag
//
// Parameters:
//  HWND                    hwnd
//  LPPOINTS            pPoint
//  int                 nFlag
//
// Returns:             nichts
//
//===========================================================================
static void DrawCross(const HWND hwnd, LPPOINTS pPoint, short nFlag)
{
    assert(hwnd);

    HDC hdc = GetDC( hwnd ); 

    HPEN holdpen = (struct HPEN__ *) SelectObject( hdc, (nFlag == COLOR_WINDOW) ? hWinPen : hTextPen );

    MoveToEx( hdc, pPoint->x-(DELTA-1), pPoint->y, NULL);

    LineTo( hdc, pPoint->x+DELTA, pPoint->y );
    MoveToEx( hdc, pPoint->x, pPoint->y-(DELTA-1), NULL );

    LineTo( hdc, pPoint->x, pPoint->y+DELTA );

    SelectObject( hdc, holdpen );

    ReleaseDC( hwnd, hdc );
} // *** end of DrawCross 

void CreatePens( void )
{
    // We always create both at the same time so checking one is sufficient!
    if( hTextPen == NULL ) {
        LOGPEN LogPen;

        LogPen.lopnStyle   = PS_SOLID;
        LogPen.lopnWidth.x = LogPen.lopnWidth.y = 0;
        LogPen.lopnColor = GetSysColor( COLOR_WINDOW );

        hWinPen  = CreatePenIndirect(&LogPen);
        
        LogPen.lopnColor = GetSysColor( COLOR_WINDOWTEXT );

        hTextPen = CreatePenIndirect(&LogPen); 
    }
}

//===========================================================================
// DisplayAvailableButtons(HWND hWnd, int nNumButtons)
//
// Removes buttons not found on the device!  
// 
//
// Parameters:
//  HWND                hDlg        - Dialog handle
//  int                 nNumButtons - Number of buttons to display
//
// Returns:
//
//===========================================================================
void DisplayAvailableButtons(const HWND hWndToolTip, const HWND hDlg, const int nButtonFlags)
{
    LPTOOLINFO pToolInfo;
    LPTSTR lpStr;

    if( nButtonFlags ) {
        if( hWndToolTip ) {
            pToolInfo = new (TOOLINFO);
            ASSERT (pToolInfo);

            lpStr = new (TCHAR[STR_LEN_32]);
            ASSERT(lpStr);

            ZeroMemory(pToolInfo, sizeof(TOOLINFO));

            pToolInfo->cbSize    = sizeof(TOOLINFO);
            pToolInfo->uFlags    = 0; 
            pToolInfo->hwnd        = hDlg;

            ::SendDlgItemMessage(hDlg, IDC_GROUP_BUTTONS, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)lpStr);
            pToolInfo->lpszText = lpStr;
        }
    }

    HWND hCtrl;

    // Show the ones we have...
    // Destroy the ones we don't!
    BYTE i = MAX_BUTTONS;

    do {
        hCtrl = GetDlgItem(hDlg, IDC_TESTJOYBTNICON1+(--i));

        if( (nButtonFlags & HAS_BUTTON1<<i) && pToolInfo ) {
            // Add the Control to the tool!
            pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
            pToolInfo->uId       = (ULONG_PTR) hCtrl;

            // Add the control!
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);

            continue;
        }
        DestroyWindow(hCtrl);
    } while( i );

    if( nButtonFlags ) {
        if( lpStr )
            delete[] (lpStr);

        if( pToolInfo )
            delete (pToolInfo);
    } else {
        // don't forget to remove the groupe!
        hCtrl = GetDlgItem(hDlg, IDC_GROUP_BUTTONS);
        DestroyWindow(hCtrl);
    }

} //*** end DisplayAvailableButtons()


//===========================================================================
// JoyError(HWND hwnd)
//
// Displays the "Device Not Connected" 
//
// Parameters:
//  HWND         hwnd - window handle
//                
// Returns:      rc - User selection from MessageBox 
//
//===========================================================================
short JoyError( const HWND hwnd )
{
    assert(hwnd);

    TCHAR lptszTitle[STR_LEN_32];

    short rc;

    if( LoadString(ghInst, IDS_JOYREADERROR, lptszTitle, STR_LEN_32) ) {
        TCHAR  lptszMsg[STR_LEN_128];

        if( LoadString(ghInst, IDS_JOYUNPLUGGED, lptszMsg, STR_LEN_128) ) {
            rc = (short)MessageBox( hwnd, lptszMsg, lptszTitle, MB_RETRYCANCEL | MB_ICONERROR );

            if( rc == IDCANCEL ) {
                // terminate the dialog if we give up
                PostMessage( GetParent(hwnd), WM_COMMAND, IDCANCEL, 0 );
            }
        }
    }

    return(rc);
} // *** end of JoyError 

//===========================================================================
// DisplayAvailablePOVs( const HWND hWndToolTip, const HWND hDlg, BYTE nPOVs )
//
// Displays POV window if there are any associated with the device.
//
// Parameters:
//    HWND              hDlg      - window handle
//     short                    nPOVs       - number of POVs
//
// Returns:                 nichts
//
//===========================================================================
static void DisplayAvailablePOVs ( const HWND hWndToolTip, const HWND hDlg, BYTE nPOVs )
{
    HWND hwndPOV = GetDlgItem(hDlg, IDC_JOYPOV);

    SetWindowPos( hwndPOV, NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((nPOVs) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

    SetWindowPos( GetDlgItem( hDlg, IDC_GROUP_POV ), NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((nPOVs) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

    if( nPOVs ) {
        // Disable RTL flag
        SetWindowLongPtr(hwndPOV, GWL_EXSTYLE, GetWindowLongPtr(hwndPOV,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );
        
        if( hWndToolTip ) {
            TOOLINFO ToolInfo;
            TCHAR lpStr[STR_LEN_32];

            ZeroMemory(&ToolInfo, sizeof(TOOLINFO));

            ToolInfo.cbSize    = sizeof(TOOLINFO);
            ToolInfo.uFlags    = 0; 
            ToolInfo.hwnd      = hDlg;

            ::SendDlgItemMessage(hDlg, IDC_GROUP_POV, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)lpStr);
            ToolInfo.lpszText  = lpStr;
            ToolInfo.uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
            ToolInfo.uId       = (ULONG_PTR)hwndPOV;

            // Add the control!
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ToolInfo);
        }
    }
} // *** end of DisplayAvailablePOVs


//===========================================================================
// SetOEMWindowText( HWND hDlg, short *nControlIDs, LPTSTR *pszLabels, BYTE nCount )
//
// Retrieves text from registry keys and Displays it in a Dialog Control or title!
//
// Parameters:
//  HWND             hDlg        - Handle to dialog where strings are to be sent
//                    nControlIDs - Pointer to array of Dialog Item ID's
//                                 Zero may be used if you want the Title!          
//                   pszLabels   - Pointer to array of Registry Keys to read
//                   nCount      - Number of ellements in the array
//
// Returns:            nichts
//
//===========================================================================
void SetOEMWindowText ( const HWND hDlg, const short *nControlIDs, LPCTSTR *pszLabels, LPCWSTR wszType, LPDIRECTINPUTJOYCONFIG pdiJoyConfig, BYTE nCount )
{
    if( nCount == 0 ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: Test.cpp: SetOEMWindowText: nCount is Zero!\n"));
#endif
        return;
    }

    // validate nControlIDs pointer
    if( IsBadReadPtr((void*)nControlIDs, sizeof(short)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: Test.cpp: SetOEMWindowText: nControlIDs is not a valid Read Pointer!\n"));
#endif
        return;
    }

    // validate pointers
    if( IsBadReadPtr((void*)pszLabels, sizeof(TCHAR)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: Test.cpp: SetOEMWindowText: pszLabels is not a valid Read Pointer!\n"));
#endif
        return;
    }

    HKEY hKey;

    pdiJoyConfig->Acquire();

    // Open the TypeKey
    if( FAILED(pdiJoyConfig->OpenTypeKey( wszType, KEY_ALL_ACCESS, &hKey)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("Test.cpp: SetOEMWindowText: OpenTypeKey FAILED!\n"));
#endif
        return;
    }

    TCHAR pszBuff[MAX_STR_LEN];
    DWORD dwCount = sizeof(pszBuff); 
    DWORD dwType  = REG_SZ;

    do {
        if( RegQueryValueEx( hKey, pszLabels[nCount], NULL, &dwType, (CONST LPBYTE)pszBuff, &dwCount ) == ERROR_SUCCESS ) {
            // This is because RegQueryValueEx returns dwCount size as the size
            // of the terminating char if the label is found w/o a string!
            if( dwCount > sizeof(TCHAR) ) {
                if( nControlIDs[nCount] )
                    ::SendMessage(GetDlgItem(hDlg, nControlIDs[nCount]), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pszBuff);
                else
                    ::SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pszBuff);
            }
#ifdef _DEBUG
            else OutputDebugString(TEXT("Test.cpp: SetOEMWindowText: ReqQueryValueEx failed to find Registry string!\n"));
#endif
        }
        dwCount = MAX_STR_LEN;
    } while( nCount-- );

    RegCloseKey(hKey);
} // *** end of SetOEMWindowText


//===========================================================================
// DisplayAvailableAxisTest(HWND hDlg, BYTE nAxisFlags, LPDIRECTINPUTDEVICE2 pdiDevice2)
//
// Displays the number and names of the device Axis in the provided dialog.
// This EXPECTS that the controls are not visible by default!
//
// Parameters:
//  HWND             hDlg       - Dialog handle
//  BYTE                    nAxisFlags - Flags for number of Axis to display
//
// Returns:
//
//===========================================================================
void DisplayAvailableAxisTest(const HWND hWndToolTip, const HWND hDlg, BYTE nAxisFlags, LPDIRECTINPUTDEVICE2 pdiDevice2)
{
    if( nAxisFlags == 0 ) {
        DestroyWindow(GetDlgItem(hDlg, IDC_AXISGRP));
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: Number of Axis is 0!\n"));
#endif
        return;
    }

    LPDIDEVICEOBJECTINSTANCE_DX3 pDevObjInst = new (DIDEVICEOBJECTINSTANCE_DX3);
    assert (pDevObjInst);

    pDevObjInst->dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

    LPTOOLINFO pToolInfo;

    if( hWndToolTip ) {
        pToolInfo = new (TOOLINFO);
        ASSERT (pToolInfo);


        ZeroMemory(pToolInfo, sizeof(TOOLINFO));

        pToolInfo->cbSize    = sizeof(TOOLINFO);
        pToolInfo->uFlags    = 0; 
        pToolInfo->hwnd        = hDlg;
    }

    HWND hCtrl;

    // X and Y use the same control so they are isolated!
    if( (nAxisFlags & HAS_X) || (nAxisFlags & HAS_Y) ) {
        HWND hwndXY = GetDlgItem(hDlg, IDC_JOYLIST1);

        // Show the Window
        SetWindowPos( hwndXY, NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        // Disable RTL flag
        SetWindowLongPtr(hwndXY, GWL_EXSTYLE, GetWindowLongPtr(hwndXY,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );

        hCtrl = GetDlgItem(hDlg, IDC_JOYLIST1_LABEL);

        // Show it's text
        SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        TCHAR ptszBuff[STR_LEN_64];

        ZeroMemory(ptszBuff, sizeof(TCHAR[STR_LEN_64]));

        // Set it's text
        if( nAxisFlags & HAS_X ) {
            if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_X, DIPH_BYOFFSET)) )
            {
                int nLen=lstrlen(pDevObjInst->tszName)+1;
                if(nLen>STR_LEN_64)
                    nLen=STR_LEN_64;
                StrCpyN(ptszBuff, pDevObjInst->tszName, nLen);
            }

            // Remove the HAS_X flag
            nAxisFlags &= ~HAS_X;
        }

        if( nAxisFlags & HAS_Y ) {
            if( FAILED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_Y, DIPH_BYOFFSET)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: GetObjectInfo Failed to find DIJOFS_Y!\n"));
#endif
            }

            if( ptszBuff && lstrlen(ptszBuff) ) {
                int nLen=STR_LEN_64-lstrlen(ptszBuff);
                StrNCat(ptszBuff, TEXT(" / "), nLen);
            }

            int nLen=STR_LEN_64-lstrlen(ptszBuff);
            StrNCat(ptszBuff, pDevObjInst->tszName, nLen);

            // Remove the HAS_Y flag
            nAxisFlags &= ~HAS_Y;

        }

        ::SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)ptszBuff);

        // CreateWindow could have failed... if so, no tooltips!
        if( hWndToolTip ) {
            GetWindowRect(hCtrl, &pToolInfo->rect);
            ScreenToClient(GetParent(hDlg), (LPPOINT)&pToolInfo->rect);
            ScreenToClient(GetParent(hDlg), ((LPPOINT)&pToolInfo->rect)+1);

            pToolInfo->lpszText = ptszBuff;

            // Add the Label...
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);

            // Add the Control!
            pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
            pToolInfo->uId       = (ULONG_PTR)hwndXY;

            // Add the control!
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);
        }
    }
    // if you have additional axis, keep going!
    if( nAxisFlags ) {
        // Array of supported axis!
        DWORD dwOffsetArray[] = {DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};

        BYTE nAxisCounter = MAX_AXIS - 3;

        // Go 'till you run out of axis!
        do {
            if( nAxisFlags & (HAS_Z<<nAxisCounter) ) {
                // Create and Assign to the global list!
                ProgWnd[nAxisCounter] = GetDlgItem(hDlg, nAxisCounter+IDC_JOYLIST2);
                ASSERT (ProgWnd[nAxisCounter]); 

                // Create Gradient Class
                if( bGradient ) {
                    pProgs[nAxisCounter] = new (CGradientProgressCtrl);
                    assert (pProgs[nAxisCounter]);

                    // Subclass the Progress Control Window
                    pProgs[nAxisCounter]->SubclassWindow(ProgWnd[nAxisCounter]); 

                } else {
                    // Set the colour
                    // PBM_SETBARCOLOR is WM_USER+9
                    ::PostMessage(ProgWnd[nAxisCounter], WM_USER+9, 0, (LPARAM)ACTIVE_COLOR);
                }

                // Show the control... ProgWnd[nAxisCounter]
                SetWindowPos( ProgWnd[nAxisCounter], NULL, NULL, NULL, NULL, NULL, 
                              SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

                hCtrl = GetDlgItem(hDlg, nAxisCounter+IDC_JOYLIST2_LABEL);

                // Now, Show it's text
                SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                              SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

                // Get it's text
                if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, dwOffsetArray[nAxisCounter], DIPH_BYOFFSET)) ) {
                    TCHAR tszAxisName[20];

                    int nLen=lstrlen(pDevObjInst->tszName)+1;
                    if(nLen>20)
                        nLen=20;
                    StrCpyN(tszAxisName, pDevObjInst->tszName, nLen);

                    if( lstrlen( tszAxisName ) > 4 ) {
                        tszAxisName[4] = L'.';
                        tszAxisName[5] = L'.';
                        tszAxisName[6] = 0;
                    }

                    ::SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tszAxisName);

                    // Just in case CreateWindow failed!!!
                    if( hWndToolTip ) {
                        GetWindowRect(hCtrl, &pToolInfo->rect);
                        ScreenToClient(GetParent(hDlg), (LPPOINT)&pToolInfo->rect);
                        ScreenToClient(GetParent(hDlg), ((LPPOINT)&pToolInfo->rect)+1);

                        pToolInfo->uFlags    = 0; 
                        pToolInfo->lpszText     = pDevObjInst->tszName;

                        // Add the Label...
                        ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);

                        // Add the Control!
                        pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
                        pToolInfo->uId       = (ULONG_PTR) ProgWnd[nAxisCounter];

                        // Now, Add the control!
                        ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);
                    }
                }

                // Remove the flag you just hit!
                nAxisFlags &= ~(HAS_Z<<nAxisCounter);
            }
        } while( nAxisCounter-- && nAxisFlags );
    }

    if( hWndToolTip ) {
        if( pToolInfo )
            delete (pToolInfo);
    }

    if( pDevObjInst )
        delete (pDevObjInst);
} //*** end of DisplayAvailableAxisTest



//===========================================================================
// BOOL SetDeviceRanges( HWND hDlg, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis)
//
// Parameters:
//    HWND                 hDlg       - Handle of Dialog containing controls to scale to
//    LPDIRECTINPUTDEVICE2 pdiDevice2 - Device2 Interface pointer
//    BYTE                 nAxis      - Bit mask of axis ranges to set
//
// Returns: FALSE if failed
//
//===========================================================================
BOOL SetDeviceRanges( const HWND hDlg, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis)
{
    if( !::IsWindow(hDlg) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: hDlg: Not a valid window!\n"));
#endif
        return(FALSE);
    }

    // validate pDIDevice2 pointer
    if( IsBadReadPtr((void*)pdiDevice2, sizeof(IDirectInputDevice2)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: pdiDevice2: Bad Read Pointer argument!\n"));
#endif
        return(FALSE);
    }

    if( !nAxis ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: nAxis is Zero!\n"));
#endif
        return(FALSE);
    }

    DIPROPRANGE DIPropRange;

    DIPropRange.diph.dwSize       = sizeof(DIPROPRANGE);
    DIPropRange.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    DIPropRange.diph.dwHow        = DIPH_BYOFFSET;


    BOOL bRet = TRUE;

    HWND hCtrl;
    RECT rc;

    // since X and Y share the same window..
    if( (nAxis & HAS_X) || (nAxis & HAS_Y) ) {
        hCtrl = GetDlgItem(hDlg, IDC_JOYLIST1);
        assert (hCtrl);

        GetClientRect( hCtrl, &rc );

        // Check if it's X
        if( nAxis & HAS_X ) {
            DIPropRange.diph.dwObj = DIJOFS_X;
            DIPropRange.lMin = DELTA;
            DIPropRange.lMax = rc.right-DELTA;

            if( FAILED(pdiDevice2->SetProperty(DIPROP_RANGE, &DIPropRange.diph)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF: SetDeviceRanges: SetProperty Failed to return X axis Ranges!\n"));
#endif
                bRet = FALSE;
            }

            // strip off the bits you just used
            nAxis &= ~HAS_X;
        }

        // Check if it's Y
        if( nAxis & HAS_Y ) {
            DIPropRange.diph.dwObj = DIJOFS_Y;
            DIPropRange.lMin = DELTA;
            DIPropRange.lMax = rc.bottom-DELTA;

            if( FAILED(pdiDevice2->SetProperty(DIPROP_RANGE, &DIPropRange.diph)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF: SetDeviceRanges: SetProperty Failed to return Y axis Ranges!\n"));
#endif
                bRet = FALSE;
            }

            // strip off the bits you just used
            nAxis &= ~HAS_Y;
        }
    }

    // you've got axes > X & Y...
    if( nAxis ) {
        const DWORD dwOfset[] = {DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};

        BYTE nAxisCounter = MAX_AXIS - 3;

        // These aren't random!
        // These are the default ranges for the CProgressCtrl!!!
        DIPropRange.lMin = MIN_SLIDER_POS;
        DIPropRange.lMax = MAX_SLIDER_POS;

        do {
            if( nAxis & (HAS_Z<<nAxisCounter) ) {
                DIPropRange.diph.dwObj = dwOfset[nAxisCounter];

                VERIFY(SUCCEEDED(pdiDevice2->SetProperty(DIPROP_RANGE, &DIPropRange.diph)));

                // Remove the flag you just hit!
                nAxis &= ~(HAS_Z<<nAxisCounter);
            }

            nAxisCounter--;

        } while( nAxis );
    }

    return(bRet);
}


#ifdef _UNICODE
///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    RegisterForDevChange ( HWND hDlg, PVOID *pNoditfyDevNode )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void RegisterForDevChange(HWND hDlg, PVOID *pNotifyDevNode)
{
    DEV_BROADCAST_DEVICEINTERFACE FilterData;

    ZeroMemory(&FilterData, sizeof(DEV_BROADCAST_DEVICEINTERFACE));

    FilterData.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    FilterData.dbcc_classguid  = GUID_CLASS_INPUT; 

    *pNotifyDevNode = RegisterDeviceNotification(hDlg, &FilterData, DEVICE_NOTIFY_WINDOW_HANDLE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DecodeAxisPOV ( DWORD dwVal )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////

static DWORD DecodeAxisPOV( DWORD dwVal )
{
    DWORD dwResult;

    if( bPolledPOV ) {
        /*
         * figure out which direction this value indicates...
         */
        if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_FORWARD])
          &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_FORWARD]) ) 
        {
            dwResult = JOY_POVFORWARD;
        } 
        else if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_BACKWARD])
               &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_BACKWARD]) ) 
        {
            dwResult = JOY_POVBACKWARD;
        } 
        else if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_LEFT])
               &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_LEFT]) ) 
        {
            dwResult = JOY_POVLEFT;
        } 
        else if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_RIGHT])
               &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_RIGHT]) ) 
        {
            dwResult = JOY_POVRIGHT;
        }
        else 
        {
            dwResult = JOY_POVCENTERED;
        }
    } else {
        dwResult = dwVal;
    }
        
    #if 0
    {
        TCHAR buf[100];
        if( bPolledPOV ) {
            wsprintf(buf, TEXT("calibrated pov: %d\r\n"), dwResult);
        } else {
            wsprintf(buf, TEXT("uncalibrated pov: %d\r\n"), dwResult);
        }
        OutputDebugString(buf);
    }
    #endif

    return dwResult;
}


/*
 * doPOVCal - compute calibration for POV for a direction
 */
static void __inline doPOVCal( LPJOYREGHWCONFIG pHWCfg, DWORD dwDir, LPDWORD dwOrder )
{
    DWORD   dwVal;
    int     nDir;

    for( nDir=0; nDir<JOY_POV_NUMDIRS; nDir++ ) 
    {
        if( dwOrder[nDir] == dwDir ) 
        {
            break;
        }
    }

    if( nDir == 0 ) 
    {
        dwVal = 1;
    } 
    else 
    {
        dwVal = (pHWCfg->hwv.dwPOVValues[dwDir] + pHWCfg->hwv.dwPOVValues[dwOrder[nDir-1]])/2;
    }
    
    myPOV[POV_MIN][dwDir] = dwVal;

    if( nDir == JOY_POV_NUMDIRS-1 ) {
        dwVal = pHWCfg->hwv.dwPOVValues[dwDir]/10l;
        dwVal += pHWCfg->hwv.dwPOVValues[dwDir];
    } else {
        dwVal = (pHWCfg->hwv.dwPOVValues[dwOrder[nDir+1]] + pHWCfg->hwv.dwPOVValues[dwDir])/2;
    }
    
    myPOV[POV_MAX][dwDir] = dwVal;

} /* doPOVCal */


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    CalibratePolledPOV( LPJOYREGHWCONFIG pHWCfg )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void CalibratePolledPOV( LPJOYREGHWCONFIG pHWCfg )
{
    DWORD       dwOrder[JOY_POV_NUMDIRS];
    DWORD       dwTmp[JOY_POV_NUMDIRS];
    DWORD       dwVal;
    int         nDir,nDir2;

    /*
     * calibrate POV for polling based ones
     */
    for( nDir=0; nDir<JOY_POV_NUMDIRS; nDir++ ) 
    {
        dwTmp[nDir]   = pHWCfg->hwv.dwPOVValues[nDir];
        dwOrder[nDir] = nDir;
    }

    /*
     * sort (did you ever think you'd see a bubble sort again?)
     */
    for( nDir=0;nDir<JOY_POV_NUMDIRS;nDir++ ) 
    {
        for( nDir2=nDir; nDir2<JOY_POV_NUMDIRS; nDir2++ ) 
        {
            if( dwTmp[nDir] > dwTmp[nDir2] ) 
            {
                dwVal          = dwTmp[nDir];
                dwTmp[nDir]    = dwTmp[nDir2];
                dwTmp[nDir2]   = dwVal;
                dwVal          = dwOrder[nDir];
                dwOrder[nDir]  = dwOrder[nDir2];
                dwOrder[nDir2] = dwVal;
            }
        }
    }

    for( nDir=0; nDir<JOY_POV_NUMDIRS; nDir++ ) 
    {
        doPOVCal( pHWCfg, nDir, dwOrder );
    }
    
    myPOV[POV_MIN][JOY_POV_NUMDIRS] = 0;
    myPOV[POV_MAX][JOY_POV_NUMDIRS] = 0;
} /* CalibratePolledPOV */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\handler\ifacesvr.h ===
/* ------------------------------------------------------------------------------------
----------																		-------
Plug In Server Interfaces Defintions.

Guru Datta Venkatarama		1/29/1997
----------																		-------
-------------------------------------------------------------------------------------*/
#include <objbase.h>
#include <hsvrguid.h>	// contains the handler and server inteface IID's and
						// the CLSID's for all our plug in servers
#include <sstructs.h>

#ifndef _PINTERFACEH_
#define _PINTERFACEH_
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
DECLARE_INTERFACE_( IServerCharacteristics, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// CImpIServerProperty methods
	STDMETHOD(Launch)			(THIS_ HWND, USHORT, USHORT) PURE; 	
	STDMETHOD(GetReport)		(THIS_ LPDIGCSHEETINFO *lpSvrSheetInfo, LPDIGCPAGEINFO *lpServerPageInfo) PURE;
};

typedef IServerCharacteristics *pIServerCharacteristics;

DECLARE_INTERFACE_( IDIGameCntrlPropSheet, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// IServerProperty Members
	STDMETHOD(GetSheetInfo)		(THIS_ LPDIGCSHEETINFO *) PURE; 	
	STDMETHOD(GetPageInfo)		(THIS_ LPDIGCPAGEINFO *) PURE; 	
	STDMETHOD(SetID)			(THIS_ USHORT nID) PURE;
	STDMETHOD_(USHORT, GetID)	(THIS) PURE; 	         	
											
};
typedef IDIGameCntrlPropSheet *LPIDIGAMECNTRLPROPSHEET;

#endif
//-----------------------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\handler\sstructs.h ===
/* ------------------------------------------------------------------------------------
----------																		-------
Plug In Server Classes, Types & function prototypes Defintions.

Guru Datta Venkatarama		1/29/1997
----------																		-------
-------------------------------------------------------------------------------------*/


#ifndef _SERVERSTRUCT_H
#define _SERVERSTRUCT_H
// ------------------------------------ * STRUCTURES * -------
// maximum pages allowed on a server
#define MAX_PAGES 26

// errors returned by the handler on failure of a call to Launch
#define DIGCERR_ERRORSTART			0x80097000
#define DIGCERR_NUMPAGESZERO		0x80097001
#define DIGCERR_NODLGPROC			0x80097002
#define DIGCERR_NOPREPOSTPROC		0x80097003
#define DIGCERR_NOTITLE				0x80097004
#define DIGCERR_NOCAPTION			0x80097005
#define DIGCERR_NOICON				0x80097006
#define DIGCERR_STARTPAGETOOLARGE	0x80097007
#define DIGCERR_NUMPAGESTOOLARGE	0x80097008
#define DIGCERR_INVALIDDWSIZE		0x80097009
#define DIGCERR_ERROREND			0x80097100

// This structure is used to report all the characterstics of the plug in server to the
// client socket when requested through the IServerCharacteristics::GetReport method
#pragma pack (8)

typedef struct {
	DWORD			 dwSize;
	LPCWSTR	   		 lpwszPageTitle;
	DLGPROC	   		 fpPageProc;
	BOOL			 fProcFlag;
	DLGPROC	  		 fpPrePostProc;
	BOOL			 fIconFlag;
	LPCWSTR			 lpwszPageIcon;
    LPCWSTR        	 lpwszTemplate; 
	LPARAM			 lParam;
	HINSTANCE		 hInstance;
} DIGCPAGEINFO, *LPDIGCPAGEINFO;		// was tServerPageRep, *tServerPageRepPtr;

typedef struct {
	DWORD		dwSize;
	USHORT		nNumPages;
	LPCWSTR		lpwszSheetCaption;
	BOOL		fSheetIconFlag;
	LPCWSTR		lpwszSheetIcon;
} DIGCSHEETINFO, *LPDIGCSHEETINFO;	// was tServerSheetRep, *tServerSheetRepPtr;

// This structure is used to report all the characterstics of the plug in server to the
// client socket when requested through the IServerDiagnostics::GetPortInfo method

#endif   // _SERVERSTRUCT_H
//-----------------------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\inc\verinfo.h ===
/*
 *  verinfo.h - header file to define the build version
 *
 */

//
// Force all builds to default to private
//

//#ifdef OFFICIAL_BUILD
#define OFFICIAL		1
//#endif

#ifndef DIRECTX_REDIST
// On official whistler build machines, the DX bits should not be timebombed, so
// we say that all whislter builds are "final release":
#define DX_FINAL_RELEASE           1
#else
// On DX build machines and private developer builds, we use non-final release builds
// unless this var. is set in the environment or uncommented here:

// Uncomment the following line for a non time bombed build
#define DX_FINAL_RELEASE           1

#endif


#ifndef DX_FINAL_RELEASE
#define DX_EXPIRE_YEAR          2001
#define DX_EXPIRE_MONTH            9 /* Jan=1, Feb=2, etc .. */
#define DX_EXPIRE_DAY              1
#define DX_EXPIRE_TEXT   TEXT("This pre-release version of DirectX has expired, please upgrade to the latest version from http://www.microsoft.com/directx")
#endif

#define MANVERSION              4
#define MANREVISION             8
#define MANMINORREV             1
#define BUILD_NUMBER            612
#define RC_NUMBER               0

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME      "Microsoft\256 DirectX for Windows\256  95 and 98\0"
#define VERSIONCOPYRIGHT        "Copyright \251 Microsoft Corp. 1994-2000\0"
#endif


/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME      "Microsoft Corporation\0"

/*
 *  Version flags
 */
//
// these two #define's are for RTM release
//
#define FINAL

#undef VER_PRIVATEBUILD
#ifndef OFFICIAL
#define VER_PRIVATEBUILD        VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD        0
#endif

#undef VER_PRERELEASE
#ifndef FINAL
#define VER_PRERELEASE          VS_FF_PRERELEASE
#else
#define VER_PRERELEASE          0
#endif

#undef VER_DEBUG
#ifdef DEBUG
#define VER_DEBUG               VS_FF_DEBUG
#elif RDEBUG
#define VER_DEBUG               VS_FF_DEBUG
#else
#define VER_DEBUG               0
#endif

#define VERSIONFLAGS            (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK    0x0030003FL
#endif

#ifdef ADJ_MANREVISION
#undef MANREVISION
// extra spaces intended to correct a problem
#define     MANREVISION ADJ_MANREVISION
#endif

#if 	(MANMINORREV < 10)
#define MMR_BPAD "0"
#else
#define MMR_BPAD
#endif

#if 	(MANREVISION < 10)
#define MR_BPAD "0"
#else
#define MR_BPAD
#endif

#if 	(BUILD_NUMBER < 10)
#define BN_BPAD "000"
#elif	(BUILD_NUMBER < 100)
#define BN_BPAD "00"
#elif	(BUILD_NUMBER < 1000)
#define BN_BPAD "0"
#else
#define BN_BPAD ""
#endif

#define BUILD_NUMBER_STR2(x) 	BN_BPAD #x
#define BUILD_NUMBER_STR1(x) 	BUILD_NUMBER_STR2(x)
#define BUILD_NUMBER_STR       	BUILD_NUMBER_STR1(BUILD_NUMBER)


#define VERSION_STR2(w,x,y,z) 	#w "." MR_BPAD #x "." MMR_BPAD #y "." BN_BPAD #z
#define VERSION_STR1(w,x,y,z) 	VERSION_STR2(w, x, y, z)
#define VERSIONSTR       	VERSION_STR1(MANVERSION, MANREVISION, MANMINORREV, BUILD_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed DXdprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\inc\dciddi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995  Microsoft Corporation\Intel.  All Rights Reserved.
 * 
 **************************************************************************/
/*******************************************************************
 *
 *	FILE:		dciddi.h
 *	
 *	DESCRIPTION:	definitions for MS/Intel-defined DCI interface
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */                                                               
#define DCICOMMAND			3075
#define DCI_VERSION			0x0100

#define DCICREATEPRIMARYSURFACE		1 
#define DCICREATEOFFSCREENSURFACE       2 
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4 
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                              	0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4    

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN			    -17
#define DCI_ERR_YALIGN			    -18
#define DCI_ERR_XYALIGN			    -19
#define DCI_ERR_WIDTHALIGN		    -20
#define DCI_ERR_HEIGHTALIGN		    -21
											 
/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16				
#define DCI_STATUS_WASSTILLDRAWING         32


/* DCI Capability Flags */
#define DCI_SURFACE_TYPE			0x0000000F
#define DCI_PRIMARY                 		0x00000000
#define DCI_OFFSCREEN               		0x00000001
#define DCI_OVERLAY                 		0x00000002

#define DCI_VISIBLE                 		0x00000010
#define DCI_CHROMAKEY               		0x00000020
#define DCI_1632_ACCESS             		0x00000040
#define DCI_DWORDSIZE               		0x00000080
#define DCI_DWORDALIGN              		0x00000100
#define DCI_WRITEONLY               		0x00000200
#define DCI_ASYNC                   		0x00000400

#define DCI_CAN_STRETCHX            		0x00001000
#define DCI_CAN_STRETCHY            		0x00002000
#define DCI_CAN_STRETCHXY           		(DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN           		0x00004000
#define DCI_CAN_STRETCHYN           		0x00008000
#define DCI_CAN_STRETCHXYN          		(DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  1

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *	input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the 
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
	DWORD	dwCommand;
	DWORD	dwParam1;
	DWORD 	dwParam2;
	DWORD	dwVersion;
	DWORD	dwReserved;
} DCICMD;
typedef  DCICMD FAR *LPDCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for 
 * the DCICREATE... calls.  The fields that are actually relevant differ for 
 * each of the three calls.  Details are in the DCI Spec chapter providing 
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
	DCICMD	cmd;							/* common header structure */
	DWORD   dwCompression;          		/* format of surface to be created                      */
	DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
	DWORD   dwWidth;                        /* height of the surface to be created          */
	DWORD   dwHeight;                       /* width of input surfaces                                      */
	DWORD	dwDCICaps;						/* capabilities of surface wanted */
	DWORD	dwBitCount;					/* bit depth of format to be created */
	LPVOID  lpSurface;                      /* pointer to an associated surface             */      
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;
		
/**************************************************************************
 *	surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary 
 * surface, and as a member of the larger structures returned by the 
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
	DWORD   dwSize;                 	/* size of structure                                            */
	DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
	DWORD   dwCompression;          	/* format of surface to be created                      */
	DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

	DWORD   dwWidth;                    /* width of surface                                             */
	DWORD   dwHeight;                   /* height of surface                                            */
	LONG    lStride;                    /* distance in bytes betw. one pixel            */
										/* and the pixel directly below it                      */
	DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
    ULONG_PTR dwOffSurface;               /* offset of surface pointer                            */
	WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;
	DWORD   dwReserved1;                /* reserved for provider */
	DWORD   dwReserved2;                /* reserved for DCIMAN */     
	DWORD   dwReserved3;                /* reserved for future */     
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
	void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */      
	void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;

/*
 * This structure is used by a DCI client to provide input parameters for the 
 * DCIEnumSurface call.
 */
typedef struct _DCIENUMINPUT {
	DCICMD	cmd;							/* common header structure */
	RECT    rSrc;                           /* source rect. for stretch  */
	RECT    rDst;                           /* dest. rect. for stretch       */
	void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
	LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;

/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;
								   
/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

	DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

	DCISURFACEINFO  dciInfo;                                                /* surface info                  */
	DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
	DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */                    

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')                                             
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
	    #define DEBUG
        #endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPFINIT()   DPFInit()
        #define DPF         dprintf
        #define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
	    #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT
    #else
        #pragma warning(disable:4002)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\inc\dciman.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995  Microsoft Corporation.	All Rights Reserved.
 * 
 **************************************************************************/
/****************************************************************************

 DCIMAN.H

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight, 
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf, 
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

/****************************************************************************
 ***************************************************************************/

extern void    WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void    WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);
extern int     WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

extern int     WINAPI DCICreatePrimary32(HDC hdc, LPDCISURFACEINFO pdci);

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\inc\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
TYPE_DIBENG     equ     'RP'            ;deType
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
#define TYPE_DIBENG     0x5250
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
deCursorExclude		equ deBeginAccess
deCursorUnexclude	equ deEndAccess
comment ~
*/
#define deCursorExclude	deBeginAccess
#define deCursorUnexclude deEndAccess
/*
end comment ~

DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType            dw  ?               ; contains TYPE_DIBENG or 0           ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deBeginAccess     dd	?		; Begin surface access call back      ;*/ void         (FAR *deBeginAccess)();    /*
  deEndAccess       dd	?		; End surface access call back	      ;*/ void         (FAR *deEndAccess)();      /*
  deDriverReserved  dd  ?		; Reserved for Minidriver use.        ;*/ DWORD        deDriverReserved;          /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER      equ     0000000000000001b       ;display driver
PALETTIZED      equ     0000000000000010b       ;paletized device
SELECTEDDIB     equ     0000000000000100b       ;DIB Section
OFFSCREEN       equ     0000000000001000b       ;offscreen surface (use with VRAM)
DISABLED        equ     0000000000010000b	;going away -- please use BUSY instead [raypat]
BUSY            equ     0000000000010000b	;
NOT_FRAMEBUFFER	equ	0000000000100000b	;example: 8514/a
FIVE6FIVE	equ	0000000001000000b	;16 bpp, 565 color format.
NON64KBANK      equ     0000000010000000b       ;bank size is not 64K
VRAM            equ     1000000000000000b       ;physical surface (video memory)
BANKEDVRAM      equ     0100000000000000b       ;VFlatD simulated
BANKEDSCAN      equ     0010000000000000b       ;VFlatD simulated (broken rasters)
PALETTE_XLAT    equ     0001000000000000b       ;background palette xlat
VGADITHER       equ     0000100000000000b       ;dither to VGA colors (first 8, and last 8)
CTCHANGE        equ     0000010000000000b       ;color table has been changed
DITHER256       equ     0000001000000000b       ;dither to 256 fixed colors
FREE2           equ     0000000100000000b       ;free

BUSY_BIT        equ     4                       ;bit number to test for BUSY


comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define OFFSCREEN       0x0008
#define DISABLED        0x0010
#define BUSY            0x0010		
#define NOT_FRAMEBUFFER 0x0020
#define FIVE6FIVE       0x0040
#define NON64KBANK      0x0080
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
#define PALETTE_XLAT    0x1000
#define VGADITHER       0x0800
#define CTCHANGE        0x0400
#define DITHER256       0x0200

#define BUSY_BIT        0x0004
/*
end comment ~

;----------------------------------------------------------------------------
; Definitions for DIBEngine.deBeginAccess flags
;----------------------------------------------------------------------------
FB_ACCESS   	equ     0000000000000001b
CURSOREXCLUDE  	equ     0000000000001000b

comment ~
*/
#define FB_ACCESS	0x0001
#define CURSOREXCLUDE	0x0008
/*
end comment ~


;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Physical fg color                ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Physical bg color                ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
PRIVATEDATA    equ      00100000b ;Vendor specific bit for Pens, Brushes
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
#define  PRIVATEDATA    0x20
/*
end comment ~
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return (LPVOID)lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
SIZE_T __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern SIZE_T __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\verinfo.h ===
/*
 *  verinfo.h - header file to define the build version
 *
 */

//
// Force all builds to default to private
//

#ifdef OFFICIAL_BUILD
#define OFFICIAL		1
#endif

// Uncomment the following line for a non time bombed build
//#define DX_FINAL_RELEASE           1

#ifndef DX_FINAL_RELEASE
#define DX_EXPIRE_YEAR          2000
#define DX_EXPIRE_MONTH            7 /* Jan=1, Feb=2, etc .. */
#define DX_EXPIRE_DAY              4
#define DX_EXPIRE_TEXT   TEXT("This pre-release version of DirectX has expired, please upgrade to the latest version.")
#endif

#define MANVERSION              4
#define MANREVISION             8
#define MANMINORREV             1
#define BUILD_NUMBER            0022

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME      "Microsoft\256 DirectX for Windows\256  95 and 98\0"
#define VERSIONCOPYRIGHT        "Copyright \251 Microsoft Corp. 1994-2000\0"
#endif


/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME      "Microsoft Corporation\0"

/*
 *  Version flags
 */
//
// these two #define's are for RTM release
//
//#define FINAL

#undef VER_PRIVATEBUILD
#ifndef OFFICIAL
#define VER_PRIVATEBUILD        VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD        0
#endif

#undef VER_PRERELEASE
#ifndef FINAL
#define VER_PRERELEASE          VS_FF_PRERELEASE
#else
#define VER_PRERELEASE          0
#endif

#undef VER_DEBUG
#ifdef DEBUG
#define VER_DEBUG               VS_FF_DEBUG
#elif RDEBUG
#define VER_DEBUG               VS_FF_DEBUG
#else
#define VER_DEBUG               0
#endif

#define VERSIONFLAGS            (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK    0x0030003FL
#endif

//
// Make versioning more automatic  
// bugbug clean up for 7.0
//

#ifdef ADJ_MANREVISION
#undef MANREVISION
// extra spaces intended to correct a problem
#define     MANREVISION ADJ_MANREVISION
#endif

#if 	(MANMINORREV < 10)
#define MMR_BPAD "0"
#else
#define MMR_BPAD
#endif

#if 	(MANREVISION < 10)
#define MR_BPAD "0"
#else
#define MR_BPAD
#endif

#if 	(BUILD_NUMBER < 10)
#define BN_BPAD "000"
#elif	(BUILD_NUMBER < 100)
#define BN_BPAD "00"
#elif	(BUILD_NUMBER < 1000)
#define BN_BPAD "0"
#else
#define BN_BPAD ""
#endif

#define BUILD_NUMBER_STR2(x) 	BN_BPAD #x
#define BUILD_NUMBER_STR1(x) 	BUILD_NUMBER_STR2(x)
#define BUILD_NUMBER_STR       	BUILD_NUMBER_STR1(BUILD_NUMBER)


#define VERSION_STR2(w,x,y,z) 	#w "." MR_BPAD #x "." MMR_BPAD #y "." BN_BPAD #z
#define VERSION_STR1(w,x,y,z) 	VERSION_STR2(w, x, y, z)
#define VERSIONSTR       	VERSION_STR1(MANVERSION, MANREVISION, MANMINORREV, BUILD_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\common.inc ===
# This file contains everything that's common between all AMovie directories.

SOURCES_USED=$(ROOT)\common.inc

SDK_ROOT=$(BASEDIR)\public\sdk\amovie

PASS0_HEADERDIR = $(O)
PASS0_SOURCEDIR = $(O)
MIDL_TLBDIR=$(O)

UMTYPE=windows

# Use NT4/Win95 base API's with IE4 addon support.

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

!ifndef USE_MFC
WIN32_IE_VERSION=0x0400
!endif

NOT_LEAN_AND_MEAN=1

# Runs on NT4/Win95 or better

SUBSYSTEM_VERSION=4.00

!if "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DSTRICT -DWINVER=0x0400 -DNT_BUILD -DDIRECTDRAW_VERSION=0x0300 -DDIRECTSOUND_VERSION=0x0800 -DFINAL=1 -DOFFICIAL=1
!else
C_DEFINES=$(C_DEFINES) -DSTRICT -DWINVER=0x0501 -DNT_BUILD -DDIRECTDRAW_VERSION=0x0300 -DDIRECTSOUND_VERSION=0x0800 -DFINAL=1 -DOFFICIAL=1
!endif

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w
!endif

INCLUDES= \
    $(SDK_ROOT)\inc; \
    $(ROOT)\h;


!if exist( "$(ROOT)\qbuild.ver" )
C_DEFINES=$(C_DEFINES) -DQBUILD_VER
INCLUDES = $(INCLUDES)$(ROOT);
!endif

!if defined(DIRECTX_REDIST) && exist( "$(ROOT)\..\directx\inc\verinfo.h" )
C_DEFINES=$(C_DEFINES) -DDXBUILD_VER
INCLUDES=$(INCLUDES);$(ROOT)\..\directx\inc;
!endif

MSC_WARNING_LEVEL=/W3

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
# Turn pch off so it doesn't get contributed to public libs
NTNOPCH=1
!endif

!ifdef NTNOPCH
DISABLE_PCH=1
!endif

# unfortunately sources files define PRECOMPILED_INCLUDE after this
# file is preprocessed, and there doesn't appear to be a way to delay
# its evaluation
!ifndef PRECOMPILED_INCLUDE
!ifndef DISABLE_PCH
USER_C_FLAGS=/Yustreams.h /Fp$(PROJECT_ROOT)\published\dxmdev\dshowdev\base\$(O)\streams.pch
!endif
!endif

USE_MSVCRT=1

!ifndef PROJECT_OBJ_ROOT
PROJECT_OBJ_ROOT=$(PROJECT_ROOT)
!endif

!ifdef PERF
C_DEFINES=$(C_DEFINES) -DPERF
QUARTZ_PERF_LIB=$(QUARTZ_LIB_DIR)\measure.lib
!endif

# allow mixing debug/retail strmbase.lib in our builds only. the NT
# tree pulls it from nt\public\sdk\lib
STRMBASE_LIB=$(PROJECT_ROOT)\published\dxmdev\dshowdev\base\$(O)\strmbase.lib

!if "$(BUILD_PRODUCT)" != "NT"
!if !$(FREEBUILD)
#DEBUG_CRTS=1
!endif
!else
!ifndef NEVER_UNICODE
C_DEFINES=-DUNICODE -D_UNICODE $(C_DEFINES)
WIN32_WINNT_VERSION=0x0500
!endif
!endif

# Add lib flags for old platforms when shipping DX
!ifdef DIRECTX_REDIST
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) /link50compat
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL	0x80004005L

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HINSTANCE hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( (HANDLE) 0xffffffff, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, 100000 );  // fail if this doesn't work within 100 seconds
    CloseHandle( hevent );
    if( rc == WAIT_TIMEOUT )
    {
        return FALSE;
    }
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = (DWORD)hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */


/*
 * StopWatchProcess
 *
 * Signal DDHELP to stop watching a process.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP to stop watching a process" );
    hd.req = DDHELPREQ_STOPWATCHPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

#ifndef WINNT
/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open DOS box event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

#endif //!winnt

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
		return (DWORD)hd.dwReturn;
	else
		return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */

    /*
     * Get DDHELP to load the DirectDraw VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDDVxd( void )
    {
	DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDDVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDDVxd */

#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD_PTR)pfn;
    sendRequest( &hd );
    return;
}

HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_LOADLIBRARY;
    hd.dwData1 = (DWORD_PTR)pszLibraryName;
    sendRequest(&hd);
    return (HINSTANCE)hd.dwReturn;
}

BOOL HelperFreeLibrary(HINSTANCE hInst)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_FREELIBRARY;
    hd.dwData1 = (DWORD_PTR)hInst;
    sendRequest(&hd);
    return (BOOL)hd.dwReturn;
}

void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_ADDDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}

void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_DELDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\dmocom\dllentry.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// classes used to support dll entrypoints for COM objects.
//
int g_cActiveObjects = 0;

#include "dmocom.h"
#include "dmoreg.h"
#include "dmoutils.h"
#include <shlwapi.h>

#ifdef DEBUG
bool g_fDbgInDllEntryPoint = false;
#endif

extern CComClassTemplate g_ComClassTemplates[];
extern int g_cComClassTemplates;

HINSTANCE g_hInst;

//
// an instance of this is created by the DLLGetClassObject entrypoint
// it uses the CComClassTemplate object it is given to support the
// IClassFactory interface

class CClassFactory : public IClassFactory,
                      CBaseObject
{

private:
    const CComClassTemplate *const m_pTemplate;

    ULONG m_cRef;

    static int m_cLocked;
public:
    CClassFactory(const CComClassTemplate *);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();

    // IClassFactory
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **pv);
    STDMETHODIMP LockServer(BOOL fLock);

    // allow DLLGetClassObject to know about global server lock status
    static BOOL IsLocked() {
        return (m_cLocked > 0);
    };
};

// process-wide dll locked state
int CClassFactory::m_cLocked = 0;

CClassFactory::CClassFactory(const CComClassTemplate *pTemplate)
: m_cRef(0)
, m_pTemplate(pTemplate)
{
}


STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER)
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    // any interface on this object is the object pointer.
    if ((riid == IID_IUnknown) || (riid == IID_IClassFactory)) {
        *ppv = (LPVOID) this;
	// AddRef returned interface pointer
        ((LPUNKNOWN) *ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CClassFactory::Release()
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    } else {
        return m_cRef;
    }
}

STDMETHODIMP
CClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    void **pv)
{
    CheckPointer(pv,E_POINTER)
    ValidateReadWritePtr(pv,sizeof(void *));

    /* Enforce the normal OLE rules regarding interfaces and delegation */

    if (pUnkOuter != NULL) {
        if (IsEqualIID(riid,IID_IUnknown) == FALSE) {
            return ResultFromScode(E_NOINTERFACE);
        }
    }

    /* Create the new object through the derived class's create function */

    HRESULT hr = NOERROR;
    CComBase *pObj = m_pTemplate->m_lpfnNew(pUnkOuter, &hr);

    if (pObj == NULL) {
	if (SUCCEEDED(hr)) {
	    hr = E_OUTOFMEMORY;
	}
	return hr;
    }

    /* Delete the object if we got a construction error */

    if (FAILED(hr)) {
        delete pObj;
        return hr;
    }

    /* Get a reference counted interface on the object */

    /* We wrap the non-delegating QI with NDAddRef & NDRelease. */
    /* This protects any outer object from being prematurely    */
    /* released by an inner object that may have to be created  */
    /* in order to supply the requested interface.              */
    pObj->NDAddRef();
    hr = pObj->NDQueryInterface(riid, pv);
    pObj->NDRelease();
    /* Note that if NDQueryInterface fails, it will  */
    /* not increment the ref count, so the NDRelease */
    /* will drop the ref back to zero and the object will "self-*/
    /* destruct".  Hence we don't need additional tidy-up code  */
    /* to cope with NDQueryInterface failing.        */

    if (SUCCEEDED(hr)) {
        ASSERT(*pv);
    }

    return hr;
}

STDMETHODIMP
CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        m_cLocked++;
    } else {
        m_cLocked--;
    }
    return NOERROR;
}


// --- COM entrypoints -----------------------------------------

//called by COM to get the class factory object for a given class
STDAPI
DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **pv)
{
    if (!(riid == IID_IUnknown) && !(riid == IID_IClassFactory)) {
            return E_NOINTERFACE;
    }

    // traverse the array of templates looking for one with this
    // class id
    for (int i = 0; i < g_cComClassTemplates; i++) {
        const CComClassTemplate * pT = &g_ComClassTemplates[i];
        if (*(pT->m_ClsID) == rClsID) {

            // found a template - make a class factory based on this
            // template

            *pv = (LPVOID) (LPUNKNOWN) new CClassFactory(pT);
            if (*pv == NULL) {
                return E_OUTOFMEMORY;
            }
            ((LPUNKNOWN)*pv)->AddRef();
            return NOERROR;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}


// called by COM to determine if this dll can be unloaded
// return ok unless there are outstanding objects or a lock requested
// by IClassFactory::LockServer
//
// CClassFactory has a static function that can tell us about the locks,
// and CCOMObject has a static function that can tell us about the active
// object count
STDAPI
DllCanUnloadNow()
{
    if (CClassFactory::IsLocked() || g_cActiveObjects) {
	return S_FALSE;
    } else {
        return S_OK;
    }
}


// --- standard WIN32 entrypoints --------------------------------------


extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
#ifdef DEBUG
    extern bool g_fDbgInDllEntryPoint;
    g_fDbgInDllEntryPoint = true;
#endif

    switch (ulReason)
    {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        g_hInst = hInstance;
        //DllInitClasses(TRUE);
        break;

    case DLL_PROCESS_DETACH:
        //DllInitClasses(FALSE);
        break;
    }

#ifdef DEBUG
    g_fDbgInDllEntryPoint = false;
#endif
    return TRUE;
}

// Automatically calls RegCloseKey when leaving scope
class CAutoHKey {
public:
   CAutoHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey) {
      if (RegCreateKey(hKey, szSubKey, phKey) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};

//
// Creates the COM registration key with subkeys under HKCR\CLSID
//
STDAPI CreateCLSIDRegKey(REFCLSID clsid, const char *szName) {
   // Get dll name
   char szFileName[MAX_PATH];
   GetModuleFileNameA(g_hInst, szFileName, MAX_PATH);
   char szRegPath[80] = "CLSID\\{";
   HKEY hKey;
   DMOGuidToStrA(szRegPath + 7, clsid);
   strcat(szRegPath, "}");
   CAutoHKey k1(HKEY_CLASSES_ROOT,szRegPath,&hKey);
   if (!hKey)
      return E_FAIL;
   if (RegSetValueA(hKey, NULL, REG_SZ, szName, strlen(szName)) != ERROR_SUCCESS)
      return E_FAIL;

   HKEY hInprocServerKey;
   CAutoHKey k2(hKey,"InprocServer32",&hInprocServerKey);
   if (!hInprocServerKey)
      return E_FAIL;

   if (RegSetValueA(hInprocServerKey, NULL, REG_SZ, szFileName, strlen(szFileName)) != ERROR_SUCCESS)
      return E_FAIL;
   if (RegSetValueExA(hInprocServerKey, "ThreadingModel", 0, REG_SZ, (BYTE*)"Both", 4) != ERROR_SUCCESS)
      return E_FAIL;
   return NOERROR;
}


STDAPI RemoveCLSIDRegKey(REFCLSID clsid)
{
   char szRegPath[80] = "CLSID\\{";
   DMOGuidToStrA(szRegPath + 7, clsid);
   strcat(szRegPath, "}");

   //  Delete this key
   if (ERROR_SUCCESS == SHDeleteKey(HKEY_CLASSES_ROOT, szRegPath)) {
       return S_OK;
   } else {
       return E_FAIL;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\dxguid\dxguid.cpp ===
//@@BEGIN_MSINTERNAL
//-----------------------------------------------------------------------------
// File: DXGuid.cpp
//
// Desc: Simple file used to build the dxguid.lib library.
//
//       Note 1: only release versions of the lib should be built.
//
//       Note 2: this source is not released to the public
//
//
// Hist: 02.07.98 - mwetzel - Created
//
//  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved
//-----------------------------------------------------------------------------

#define INITGUID

#include <windows.h>        // This needs to be windows.h and NOT wtypes.h so that
                            // the Borland CBuilder3 compiler won't complain.

// DDraw Headers with GUIDs
#pragma message( "**** About to include ddrawp.h" )
#include "DDrawP.H"

// GUIDs from DDrawI.h:
// (#including DDrawI.h indirectly includes some other D3D headers that cause
// problems down the road, so it's easier to just redefine the needed GUIDs here.)
DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_VideoPortCallbacks,       0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,    0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_VideoPortCaps,            0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks2,        0x0ba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,       0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,      0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,           0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_D3DExtendedCaps,      0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( GUID_ZPixelFormats,        0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,        0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_DDStereoMode,          0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_OptSurfaceKmodeInfo,      0xe05c8472, 0x51d4, 0x11d1, 0x8c, 0xce, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_OptSurfaceUmodeInfo,      0x9d792804, 0x5fa8, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_UserModeDriverInfo,       0xf0b0e8e2, 0x5f97, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_UserModeDriverPassword,   0x97f861b6, 0x60a1, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_MotionCompCallbacks,      0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_NTCallbacks,                  0x6fe9ecde, 0xdf89, 0x11d1, 0x9d, 0xb0, 0x00, 0x60, 0x08, 0x27, 0x71, 0xba);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,  0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
DEFINE_GUID( GUID_DDMoreCaps,               0x880baf30, 0xb030, 0x11d0, 0x8e, 0xa7, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b);


#pragma message( "**** About to include dvp.h" )
#include "DVP.H"

// D3D Immediate Mode Headers with GUIDs
#pragma message( "**** About to include d3d.h" )

#include "D3D.H"

// d3d8.h
DEFINE_GUID(IID_IDirect3D8, 0x1dd9e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);
DEFINE_GUID(IID_IDirect3DDevice8, 0x7385e5df, 0x8fe8, 0x41d5, 0x86, 0xb6, 0xd7, 0xb4, 0x85, 0x47, 0xb6, 0xcf);
DEFINE_GUID(IID_IDirect3DResource8, 0x1b36bb7b, 0x9b7, 0x410a, 0xb4, 0x45, 0x7d, 0x14, 0x30, 0xd7, 0xb3, 0x3f);
DEFINE_GUID(IID_IDirect3DBaseTexture8, 0xb4211cfa, 0x51b9, 0x4a9f, 0xab, 0x78, 0xdb, 0x99, 0xb2, 0xbb, 0x67, 0x8e);
DEFINE_GUID(IID_IDirect3DTexture8, 0xe4cdd575, 0x2866, 0x4f01, 0xb1, 0x2e, 0x7e, 0xec, 0xe1, 0xec, 0x93, 0x58);
DEFINE_GUID(IID_IDirect3DCubeTexture8, 0x3ee5b968, 0x2aca, 0x4c34, 0x8b, 0xb5, 0x7e, 0x0c, 0x3d, 0x19, 0xb7, 0x50);
DEFINE_GUID(IID_IDirect3DVolumeTexture8, 0x4b8aaafa, 0x140f, 0x42ba, 0x91, 0x31, 0x59, 0x7e, 0xaf, 0xaa, 0x2e, 0xad);
DEFINE_GUID(IID_IDirect3DVertexBuffer8, 0x8aeeeac7, 0x05f9, 0x44d4, 0xb5, 0x91, 0x00, 0x0b, 0x0d, 0xf1, 0xcb, 0x95);
DEFINE_GUID(IID_IDirect3DIndexBuffer8, 0x0e689c9a, 0x053d, 0x44a0, 0x9d, 0x92, 0xdb, 0x0e, 0x3d, 0x75, 0x0f, 0x86);
DEFINE_GUID(IID_IDirect3DSurface8, 0xb96eebca, 0xb326, 0x4ea5, 0x88, 0x2f, 0x2f, 0xf5, 0xba, 0xe0, 0x21, 0xdd);
DEFINE_GUID(IID_IDirect3DVolume8, 0xbd7349f5, 0x14f1, 0x42e4, 0x9c, 0x79, 0x97, 0x23, 0x80, 0xdb, 0x40, 0xc0);
DEFINE_GUID(IID_IDirect3DSwapChain8, 0x928c088b, 0x76b9, 0x4c6b, 0xa5, 0x36, 0xa5, 0x90, 0x85, 0x38, 0x76, 0xcd);

// d3dx8*.h
DEFINE_GUID(IID_ID3DXBaseMesh,0xa69ba991, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);
DEFINE_GUID(IID_ID3DXMesh, 0x9d84ac46, 0x6b90, 0x49a9, 0xa7, 0x21, 0x8, 0x5c, 0x7a, 0x3e, 0x3d, 0xae);
DEFINE_GUID(IID_ID3DXPMesh, 0x15981aa8, 0x1a05, 0x48e3, 0xbb, 0xe7, 0xff, 0x5d, 0x49, 0x65, 0x4e, 0x3f);
DEFINE_GUID(IID_ID3DXSPMesh, 0xbc3bbde2, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);
DEFINE_GUID(IID_ID3DXSkinMesh, 0x82a53844, 0xf322, 0x409e, 0xa2, 0xe9, 0x99, 0x2e, 0x11, 0x4, 0x6, 0x9d);
DEFINE_GUID(IID_ID3DXMatrixStack, 0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID(IID_ID3DXTechnique, 0xa00f378d, 0xaf79, 0x4917, 0x90, 0x7e, 0x4d, 0x63, 0x5e, 0xe6, 0x38, 0x44);
DEFINE_GUID(IID_ID3DXEffect, 0x281bbdd4, 0xaedf, 0x4907, 0x86, 0x50, 0xe7, 0x9c, 0xdf, 0xd4, 0x51, 0x65);
DEFINE_GUID(IID_ID3DXBuffer, 0x932e6a7e, 0xc68e, 0x45dd, 0xa7, 0xbf, 0x53, 0xd1, 0x9c, 0x86, 0xdb, 0x1f);

DEFINE_GUID(IID_ID3DXInterpolator, 0xade2c06d, 0x3747, 0x4b9f, 0xa5, 0x14, 0x34, 0x40, 0xb8, 0x28, 0x49, 0x80);
DEFINE_GUID(IID_ID3DXKeyFrameInterpolator, 0x6caa71f8, 0x972, 0x4cdb, 0xa5, 0x5b, 0x43, 0xb9, 0x68, 0x99, 0x75, 0x15);
DEFINE_GUID(IID_ID3DXAnimationSet, 0x54b569ac, 0xaef, 0x473e, 0x97, 0x4, 0x3f, 0xef, 0x31, 0x7f, 0x64, 0xab);
DEFINE_GUID(IID_ID3DXAnimationMixer, 0x5eec992b, 0x1046, 0x44f6, 0x92, 0x4b, 0xd1, 0x75, 0x96, 0xb0, 0x48, 0x3e);
DEFINE_GUID(IID_ID3DXAnimationController, 0x3a714d34, 0xff61, 0x421e, 0x90, 0x9f, 0x63, 0x9f, 0x38, 0x35, 0x67, 0x8);

// D3D Retained Mode Headers with GUIDs
#pragma message( "**** About to include d3drm header files" )
#include "D3DRM.H"
#include "D3DRMObj.H"
#include "D3DRMWin.H"
#include "D3DRMDef.H"
#include "RMXFGUID.H"
#include "DXFile.H"

// DInput Headers with GUIDs
#include "DInput.H"
#include "DInputD.H"        // Needed for IDirectInputJoyConfig

// DPlay Headers with GUIDs
#include "DPlay.H"
#include "DPLobby.H"
#include "DPlay8.H"
#include "DVoice.H"
#include "DPLobby8.H"
#include "DPAddr.H"

// DSound Headers with GUIDs
#include <mmreg.h>          // for DSound
#include "DSound.H"

// DMusic Headers with GUIDs
#include "DMusicC.H"
#include "DMusicI.H"
#include "DMKSCtrl.H"

//#include "DSetup.h"       // No GUID for DSetup yet


//@@END_MSINTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\dxerr8\dxerr8.h ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.h
 *  Content:    DirectX Error Library Include File
 *
 ****************************************************************************/

#ifndef _DXERR8_H_
#define _DXERR8_H_

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

//
//  DXGetErrorString8
//  
//  Desc:  Converts a DirectX HRESULT to a string 
//
//  Args:  HRESULT hr   Can be any error code from
//                      D3D8 D3DX8 DDRAW DPLAY8 DMUSIC DSOUND DINPUT DSHOW
//
//  Return: Converted string 
//
const char*  WINAPI DXGetErrorString8A(HRESULT hr);
const WCHAR* WINAPI DXGetErrorString8W(HRESULT hr);

#ifdef UNICODE
#define DXGetErrorString8 DXGetErrorString8W
#else
#define DXGetErrorString8 DXGetErrorString8A
#endif 


//
//  DXGetErrorDescription8
//  
//  Desc:  Returns a string description of a DirectX HRESULT
//
//  Args:  HRESULT hr   Can be any error code from
//                      D3D8 D3DX8 DDRAW DPLAY8 DMUSIC DSOUND DINPUT DSHOW
//
//  Return: String description
//
const char*  WINAPI DXGetErrorDescription8A(HRESULT hr);
const WCHAR* WINAPI DXGetErrorDescription8W(HRESULT hr);

#ifdef UNICODE
    #define DXGetErrorDescription8 DXGetErrorDescription8W
#else
    #define DXGetErrorDescription8 DXGetErrorDescription8A
#endif 


//
//  DXTrace
//
//  Desc:  Outputs a formatted error message to the debug stream
//
//  Args:  CHAR* strFile   The current file, typically passed in using the 
//                         __FILE__ macro.
//         DWORD dwLine    The current line number, typically passed in using the 
//                         __LINE__ macro.
//         HRESULT hr      An HRESULT that will be traced to the debug stream.
//         CHAR* strMsg    A string that will be traced to the debug stream (may be NULL)
//         BOOL bPopMsgBox If TRUE, then a message box will popup also containing the passed info.
//
//  Return: The hr that was passed in.  
//
HRESULT WINAPI DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, char* strMsg, BOOL bPopMsgBox );
HRESULT WINAPI DXTraceW( char* strFile, DWORD dwLine, HRESULT hr, WCHAR* strMsg, BOOL bPopMsgBox );

#ifdef UNICODE
#define DXTrace DXTraceW
#else
#define DXTrace DXTraceA
#endif 


//
// Helper macros
//
#if defined(DEBUG) | defined(_DEBUG)
#define DXTRACE_MSG(str)              DXTrace( __FILE__, (DWORD)__LINE__, 0, str, FALSE )
#define DXTRACE_ERR(str,hr)           DXTrace( __FILE__, (DWORD)__LINE__, hr, str, TRUE )
#define DXTRACE_ERR_NOMSGBOX(str,hr)  DXTrace( __FILE__, (DWORD)__LINE__, hr, str, FALSE )
#else
#define DXTRACE_MSG(str)              (0L)
#define DXTRACE_ERR(str,hr)           (hr)
#define DXTRACE_ERR_NOMSGBOX(str,hr)  (hr)
#endif


#ifdef __cplusplus
}
#endif //__cplusplus

#endif // _DXERR8_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\dmocom\dmocom.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

#include "dmocom.h"


#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions



/* Constructor */

// We know we use "this" in the initialization list, we also know we don't modify *phr.
#pragma warning( disable : 4355 4100 )
CComBase::CComBase(IUnknown* pUnk)
: 
/* Start the object with a reference count of zero - when the      */
/* object is queried for it's first interface this may be          */
/* incremented depending on whether or not this object is          */
/* currently being aggregated upon                                 */
  m_cRef(0)
/* Set our pointer to our IUnknown interface.                      */
/* If we have an outer, use its, otherwise use ours.               */
/* This pointer effectivly points to the owner of                  */
/* this object and can be accessed by the GetOwner() method.       */
, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
 /* Why the double cast?  Well, the inner cast is a type-safe cast */
 /* to pointer to a type from which we inherit.  The second is     */
 /* type-unsafe but works because INDUnknown "behaves   */
 /* like" IUnknown. (Only the names on the methods change.)        */
{
    // Everything we need to do has been done in the initializer list
}

// This does the same as above except it has a useless HRESULT argument
// use the previous constructor, this is just left for compatibility...
CComBase::CComBase(IUnknown* pUnk,HRESULT *phr) :
    m_cRef(0),
    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
{
}

#pragma warning( default : 4355 4100 )

/* QueryInterface */

STDMETHODIMP CComBase::NDQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown) {
        GetInterface((IUnknown*) (INDUnknown*) this, ppv);
        return NOERROR;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

/* We have to ensure that we DON'T use a max macro, since these will typically   */
/* lead to one of the parameters being evaluated twice.  Since we are worried    */
/* about concurrency, we can't afford to access the m_cRef twice since we can't  */
/* afford to run the risk that its value having changed between accesses.        */
#ifdef max
    #undef max
#endif

template<class T> inline static T max( const T & a, const T & b )
{
    return a > b ? a : b;
}

/* AddRef */

STDMETHODIMP_(ULONG) CComBase::NDAddRef()
{
    LONG lRef = InterlockedIncrement( &m_cRef );
    ASSERT(lRef > 0);
/*
    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"),
           m_dwCookie, m_cRef));
*/
    return max(ULONG(m_cRef), 1ul);
}


/* Release */

STDMETHODIMP_(ULONG) CComBase::NDRelease()
{
    /* If the reference count drops to zero delete ourselves */

    LONG lRef = InterlockedDecrement( &m_cRef );
    ASSERT(lRef >= 0);

/*
    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"),
	    m_dwCookie, m_cRef));
*/
    if (lRef == 0) {

        // COM rules say we must protect against re-entrancy.
        // If we are an aggregator and we hold our own interfaces
        // on the aggregatee, the QI for these interfaces will
        // addref ourselves. So after doing the QI we must release
        // a ref count on ourselves. Then, before releasing the
        // private interface, we must addref ourselves. When we do
        // this from the destructor here it will result in the ref
        // count going to 1 and then back to 0 causing us to
        // re-enter the destructor. Hence we add an extra refcount here
        // once we know we will delete the object.
        // for an example aggregator see filgraph\distrib.cpp.

        m_cRef++;

        delete this;
        return ULONG(0);
    } else {
        return max(ULONG(m_cRef), 1ul);
    }
}


/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv)
{
    CheckPointer(ppv, E_POINTER);
    *ppv = pUnk;
    pUnk->AddRef();
    return NOERROR;
}


/* Compares two interfaces and returns TRUE if they are on the same object */

BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    IUnknown* pUnknown1;     // Retrieve the IUnknown interface
    IUnknown* pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\misc\dxerr8\dxerr8.cpp ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.cpp
 *  Content:    DirectX Error Library 
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <MMsystem.h>
#include "dxerr8.h"


#include"d3d8.h"
#include"ddraw.h"
#include"d3dx8.h"
#include"d3dxerr.h"
#include"dsound.h"
#include"dmusici.h"
#include"dplay8.h"
#include"dvoice.h"
#include"dinput.h"
#include"dinputd.h"
#include"vfwmsgs.h"

//#include"appman.h"

#define BUFFER_SIZE 3000
#define  CHK_ERR(hrchk, strOut) \
        case hrchk: \
             return strOut;     


/****************************************************/
/* DXGetErrorString8A                                */
/*                                                  */
/****************************************************/
const char * WINAPI DXGetErrorString8A(HRESULT hr)
{
   switch(hr)
   {     
// -------------------------------------------------------------        
// Common Win32 error codes
// -------------------------------------------------------------        
        CHK_ERR(S_OK, "S_OK")        
        CHK_ERR(S_FALSE, "S_FALSE")
        
        CHK_ERR(ERROR_FILE_NOT_FOUND, "ERROR_FILE_NOT_FOUND")
        CHK_ERR(ERROR_PATH_NOT_FOUND, "ERROR_PATH_NOT_FOUND")
        CHK_ERR(ERROR_TOO_MANY_OPEN_FILES, "ERROR_TOO_MANY_OPEN_FILES")
        CHK_ERR(ERROR_ACCESS_DENIED, "ERROR_ACCESS_DENIED")
        CHK_ERR(ERROR_INVALID_HANDLE, "ERROR_INVALID_HANDLE")
        CHK_ERR(ERROR_NOT_ENOUGH_MEMORY, "ERROR_NOT_ENOUGH_MEMORY")
        CHK_ERR(ERROR_INVALID_BLOCK, "ERROR_INVALID_BLOCK")
        CHK_ERR(ERROR_BAD_ENVIRONMENT, "ERROR_BAD_ENVIRONMENT")
        CHK_ERR(ERROR_BAD_FORMAT, "ERROR_BAD_FORMAT")
        CHK_ERR(ERROR_OUTOFMEMORY, "ERROR_OUTOFMEMORY")
                
        CHK_ERR(E_UNEXPECTED, "E_UNEXPECTED")
        CHK_ERR(E_NOTIMPL, "E_NOTIMPL")
        CHK_ERR(E_OUTOFMEMORY, "E_OUTOFMEMORY")
        CHK_ERR(E_INVALIDARG, "E_INVALIDARG")
        CHK_ERR(E_NOINTERFACE, "E_NOINTERFACE")
        CHK_ERR(E_POINTER, "E_POINTER")
        CHK_ERR(E_HANDLE, "E_HANDLE")
        CHK_ERR(E_ABORT, "E_ABORT")
        CHK_ERR(E_FAIL, "E_FAIL")
        CHK_ERR(E_ACCESSDENIED, "E_ACCESSDENIED")
        CHK_ERR(E_PENDING, "E_PENDING")
        CHK_ERR(REGDB_E_CLASSNOTREG, "REGDB_E_CLASSNOTREG")
        CHK_ERR(CO_E_NOTINITIALIZED, "CO_E_NOTINITIALIZED")
        CHK_ERR(CO_E_ALREADYINITIALIZED, "CO_E_ALREADYINITIALIZED")
        CHK_ERR(CLASS_E_NOAGGREGATION, "CLASS_E_NOAGGREGATION")


// -------------------------------------------------------------        
// ddraw.h error codes as of 12/14/00
// -------------------------------------------------------------                
        CHK_ERR(DDERR_ALREADYINITIALIZED, "DDERR_ALREADYINITIALIZED")
        CHK_ERR(DDERR_CANNOTATTACHSURFACE, "DDERR_CANNOTATTACHSURFACE")
        CHK_ERR(DDERR_CANNOTDETACHSURFACE, "DDERR_CANNOTDETACHSURFACE")
        CHK_ERR(DDERR_CURRENTLYNOTAVAIL, "DDERR_CURRENTLYNOTAVAIL")
        CHK_ERR(DDERR_EXCEPTION, "DDERR_EXCEPTION")
//      CHK_ERR(DDERR_GENERIC, "DDERR_GENERIC")
        CHK_ERR(DDERR_HEIGHTALIGN, "DDERR_HEIGHTALIGN")
        CHK_ERR(DDERR_INCOMPATIBLEPRIMARY, "DDERR_INCOMPATIBLEPRIMARY")
        CHK_ERR(DDERR_INVALIDCAPS, "DDERR_INVALIDCAPS")
        CHK_ERR(DDERR_INVALIDCLIPLIST, "DDERR_INVALIDCLIPLIST")
        CHK_ERR(DDERR_INVALIDMODE, "DDERR_INVALIDMODE")
        CHK_ERR(DDERR_INVALIDOBJECT, "DDERR_INVALIDOBJECT")
//        CHK_ERR(DDERR_INVALIDPARAMS, "DDERR_INVALIDPARAMS")
        CHK_ERR(DDERR_INVALIDPIXELFORMAT, "DDERR_INVALIDPIXELFORMAT")
        CHK_ERR(DDERR_INVALIDRECT, "DDERR_INVALIDRECT")
        CHK_ERR(DDERR_LOCKEDSURFACES, "DDERR_LOCKEDSURFACES")
        CHK_ERR(DDERR_NO3D, "DDERR_NO3D")
        CHK_ERR(DDERR_NOALPHAHW, "DDERR_NOALPHAHW")
        CHK_ERR(DDERR_NOSTEREOHARDWARE, "DDERR_NOSTEREOHARDWARE")
        CHK_ERR(DDERR_NOSURFACELEFT, "DDERR_NOSURFACELEFT")
        CHK_ERR(DDERR_NOCLIPLIST, "DDERR_NOCLIPLIST")
        CHK_ERR(DDERR_NOCOLORCONVHW, "DDERR_NOCOLORCONVHW")
        CHK_ERR(DDERR_NOCOOPERATIVELEVELSET, "DDERR_NOCOOPERATIVELEVELSET")
        CHK_ERR(DDERR_NOCOLORKEY, "DDERR_NOCOLORKEY")
        CHK_ERR(DDERR_NOCOLORKEYHW, "DDERR_NOCOLORKEYHW")
        CHK_ERR(DDERR_NODIRECTDRAWSUPPORT, "DDERR_NODIRECTDRAWSUPPORT")
        CHK_ERR(DDERR_NOEXCLUSIVEMODE, "DDERR_NOEXCLUSIVEMODE")
        CHK_ERR(DDERR_NOFLIPHW, "DDERR_NOFLIPHW")
        CHK_ERR(DDERR_NOGDI, "DDERR_NOGDI")
        CHK_ERR(DDERR_NOMIRRORHW, "DDERR_NOMIRRORHW")
        CHK_ERR(DDERR_NOTFOUND, "DDERR_NOTFOUND")
        CHK_ERR(DDERR_NOOVERLAYHW, "DDERR_NOOVERLAYHW")
        CHK_ERR(DDERR_OVERLAPPINGRECTS, "DDERR_OVERLAPPINGRECTS")
        CHK_ERR(DDERR_NORASTEROPHW, "DDERR_NORASTEROPHW")
        CHK_ERR(DDERR_NOROTATIONHW, "DDERR_NOROTATIONHW")
        CHK_ERR(DDERR_NOSTRETCHHW, "DDERR_NOSTRETCHHW")
        CHK_ERR(DDERR_NOT4BITCOLOR, "DDERR_NOT4BITCOLOR")
        CHK_ERR(DDERR_NOT4BITCOLORINDEX, "DDERR_NOT4BITCOLORINDEX")
        CHK_ERR(DDERR_NOT8BITCOLOR, "DDERR_NOT8BITCOLOR")
        CHK_ERR(DDERR_NOTEXTUREHW, "DDERR_NOTEXTUREHW")
        CHK_ERR(DDERR_NOVSYNCHW, "DDERR_NOVSYNCHW")
        CHK_ERR(DDERR_NOZBUFFERHW, "DDERR_NOZBUFFERHW")
        CHK_ERR(DDERR_NOZOVERLAYHW, "DDERR_NOZOVERLAYHW")
        CHK_ERR(DDERR_OUTOFCAPS, "DDERR_OUTOFCAPS")
//        CHK_ERR(DDERR_OUTOFMEMORY, "DDERR_OUTOFMEMORY")
//        CHK_ERR(DDERR_OUTOFVIDEOMEMORY, "DDERR_OUTOFVIDEOMEMORY")
        CHK_ERR(DDERR_OVERLAYCANTCLIP, "DDERR_OVERLAYCANTCLIP")
        CHK_ERR(DDERR_OVERLAYCOLORKEYONLYONEACTIVE, "DDERR_OVERLAYCOLORKEYONLYONEACTIVE")
        CHK_ERR(DDERR_PALETTEBUSY, "DDERR_PALETTEBUSY")
        CHK_ERR(DDERR_COLORKEYNOTSET, "DDERR_COLORKEYNOTSET")
        CHK_ERR(DDERR_SURFACEALREADYATTACHED, "DDERR_SURFACEALREADYATTACHED")
        CHK_ERR(DDERR_SURFACEALREADYDEPENDENT, "DDERR_SURFACEALREADYDEPENDENT")
        CHK_ERR(DDERR_SURFACEBUSY, "DDERR_SURFACEBUSY")
        CHK_ERR(DDERR_CANTLOCKSURFACE, "DDERR_CANTLOCKSURFACE")
        CHK_ERR(DDERR_SURFACEISOBSCURED, "DDERR_SURFACEISOBSCURED")
        CHK_ERR(DDERR_SURFACELOST, "DDERR_SURFACELOST")
        CHK_ERR(DDERR_SURFACENOTATTACHED, "DDERR_SURFACENOTATTACHED")
        CHK_ERR(DDERR_TOOBIGHEIGHT, "DDERR_TOOBIGHEIGHT")
        CHK_ERR(DDERR_TOOBIGSIZE, "DDERR_TOOBIGSIZE")
        CHK_ERR(DDERR_TOOBIGWIDTH, "DDERR_TOOBIGWIDTH")
//        CHK_ERR(DDERR_UNSUPPORTED, "DDERR_UNSUPPORTED")
        CHK_ERR(DDERR_UNSUPPORTEDFORMAT, "DDERR_UNSUPPORTEDFORMAT")
        CHK_ERR(DDERR_UNSUPPORTEDMASK, "DDERR_UNSUPPORTEDMASK")
        CHK_ERR(DDERR_INVALIDSTREAM, "DDERR_INVALIDSTREAM")
        CHK_ERR(DDERR_VERTICALBLANKINPROGRESS, "DDERR_VERTICALBLANKINPROGRESS")
        CHK_ERR(DDERR_WASSTILLDRAWING, "DDERR_WASSTILLDRAWING")
        CHK_ERR(DDERR_DDSCAPSCOMPLEXREQUIRED, "DDERR_DDSCAPSCOMPLEXREQUIRED")
        CHK_ERR(DDERR_XALIGN, "DDERR_XALIGN")
        CHK_ERR(DDERR_INVALIDDIRECTDRAWGUID, "DDERR_INVALIDDIRECTDRAWGUID")
        CHK_ERR(DDERR_DIRECTDRAWALREADYCREATED, "DDERR_DIRECTDRAWALREADYCREATED")
        CHK_ERR(DDERR_NODIRECTDRAWHW, "DDERR_NODIRECTDRAWHW")
        CHK_ERR(DDERR_PRIMARYSURFACEALREADYEXISTS, "DDERR_PRIMARYSURFACEALREADYEXISTS")
        CHK_ERR(DDERR_NOEMULATION, "DDERR_NOEMULATION")
        CHK_ERR(DDERR_REGIONTOOSMALL, "DDERR_REGIONTOOSMALL")
        CHK_ERR(DDERR_CLIPPERISUSINGHWND, "DDERR_CLIPPERISUSINGHWND")
        CHK_ERR(DDERR_NOCLIPPERATTACHED, "DDERR_NOCLIPPERATTACHED")
        CHK_ERR(DDERR_NOHWND, "DDERR_NOHWND")
        CHK_ERR(DDERR_HWNDSUBCLASSED, "DDERR_HWNDSUBCLASSED")
        CHK_ERR(DDERR_HWNDALREADYSET, "DDERR_HWNDALREADYSET")
        CHK_ERR(DDERR_NOPALETTEATTACHED, "DDERR_NOPALETTEATTACHED")
        CHK_ERR(DDERR_NOPALETTEHW, "DDERR_NOPALETTEHW")
        CHK_ERR(DDERR_BLTFASTCANTCLIP, "DDERR_BLTFASTCANTCLIP")
        CHK_ERR(DDERR_NOBLTHW, "DDERR_NOBLTHW")
        CHK_ERR(DDERR_NODDROPSHW, "DDERR_NODDROPSHW")
        CHK_ERR(DDERR_OVERLAYNOTVISIBLE, "DDERR_OVERLAYNOTVISIBLE")
        CHK_ERR(DDERR_NOOVERLAYDEST, "DDERR_NOOVERLAYDEST")
        CHK_ERR(DDERR_INVALIDPOSITION, "DDERR_INVALIDPOSITION")
        CHK_ERR(DDERR_NOTAOVERLAYSURFACE, "DDERR_NOTAOVERLAYSURFACE")
        CHK_ERR(DDERR_EXCLUSIVEMODEALREADYSET, "DDERR_EXCLUSIVEMODEALREADYSET")
        CHK_ERR(DDERR_NOTFLIPPABLE, "DDERR_NOTFLIPPABLE")
        CHK_ERR(DDERR_CANTDUPLICATE, "DDERR_CANTDUPLICATE")
        CHK_ERR(DDERR_NOTLOCKED, "DDERR_NOTLOCKED")
        CHK_ERR(DDERR_CANTCREATEDC, "DDERR_CANTCREATEDC")
        CHK_ERR(DDERR_NODC, "DDERR_NODC")
        CHK_ERR(DDERR_WRONGMODE, "DDERR_WRONGMODE")
        CHK_ERR(DDERR_IMPLICITLYCREATED, "DDERR_IMPLICITLYCREATED")
        CHK_ERR(DDERR_NOTPALETTIZED, "DDERR_NOTPALETTIZED")
        CHK_ERR(DDERR_UNSUPPORTEDMODE, "DDERR_UNSUPPORTEDMODE")
        CHK_ERR(DDERR_NOMIPMAPHW, "DDERR_NOMIPMAPHW")
        CHK_ERR(DDERR_INVALIDSURFACETYPE, "DDERR_INVALIDSURFACETYPE")
        CHK_ERR(DDERR_NOOPTIMIZEHW, "DDERR_NOOPTIMIZEHW")
        CHK_ERR(DDERR_NOTLOADED, "DDERR_NOTLOADED")
        CHK_ERR(DDERR_NOFOCUSWINDOW, "DDERR_NOFOCUSWINDOW")
        CHK_ERR(DDERR_NOTONMIPMAPSUBLEVEL, "DDERR_NOTONMIPMAPSUBLEVEL")
        CHK_ERR(DDERR_DCALREADYCREATED, "DDERR_DCALREADYCREATED")
        CHK_ERR(DDERR_NONONLOCALVIDMEM, "DDERR_NONONLOCALVIDMEM")
        CHK_ERR(DDERR_CANTPAGELOCK, "DDERR_CANTPAGELOCK")
        CHK_ERR(DDERR_CANTPAGEUNLOCK, "DDERR_CANTPAGEUNLOCK")
        CHK_ERR(DDERR_NOTPAGELOCKED, "DDERR_NOTPAGELOCKED")
        CHK_ERR(DDERR_MOREDATA, "DDERR_MOREDATA")
        CHK_ERR(DDERR_EXPIRED, "DDERR_EXPIRED")
        CHK_ERR(DDERR_TESTFINISHED, "DDERR_TESTFINISHED")
        CHK_ERR(DDERR_NEWMODE, "DDERR_NEWMODE")
        CHK_ERR(DDERR_D3DNOTINITIALIZED, "DDERR_D3DNOTINITIALIZED")
        CHK_ERR(DDERR_VIDEONOTACTIVE, "DDERR_VIDEONOTACTIVE")
        CHK_ERR(DDERR_NOMONITORINFORMATION, "DDERR_NOMONITORINFORMATION")
        CHK_ERR(DDERR_NODRIVERSUPPORT, "DDERR_NODRIVERSUPPORT")
        CHK_ERR(DDERR_DEVICEDOESNTOWNSURFACE, "DDERR_DEVICEDOESNTOWNSURFACE")


// -------------------------------------------------------------        
// dinput.h error codes as of 10/4/00
// -------------------------------------------------------------        
//      CHK_ERR(DI_OK, "DI_OK")
//      CHK_ERR(DI_NOTATTACHED, "DI_NOTATTACHED")
//      CHK_ERR(DI_BUFFEROVERFLOW, "DI_BUFFEROVERFLOW")
//      CHK_ERR(DI_PROPNOEFFECT, "DI_PROPNOEFFECT")
//      CHK_ERR(DI_NOEFFECT, "DI_NOEFFECT")
//      CHK_ERR(DI_POLLEDDEVICE, "DI_POLLEDDEVICE")
//      CHK_ERR(DI_DOWNLOADSKIPPED, "DI_DOWNLOADSKIPPED")
//      CHK_ERR(DI_EFFECTRESTARTED, "DI_EFFECTRESTARTED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_ACCESSDENIED, "DI_SETTINGSNOTSAVED_ACCESSDENIED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_DISKFULL, "DI_SETTINGSNOTSAVED_DISKFULL")
//      CHK_ERR(DI_TRUNCATED, "DI_TRUNCATED")
//      CHK_ERR(DI_TRUNCATEDANDRESTARTED, "DI_TRUNCATEDANDRESTARTED")
//      CHK_ERR(DI_WRITEPROTECT, "DI_WRITEPROTECT")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, "DIERR_OLDDIRECTINPUTVERSION")
//      CHK_ERR(DIERR_GENERIC, "DIERR_GENERIC")
//      CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, "DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, "DIERR_BETADIRECTINPUTVERSION")
        CHK_ERR(DIERR_BADDRIVERVER, "DIERR_BADDRIVERVER")
//      CHK_ERR(DIERR_DEVICENOTREG, "DIERR_DEVICENOTREG")   
        CHK_ERR(DIERR_NOTFOUND, "DIERR_NOTFOUND")                
//      CHK_ERR(DIERR_OBJECTNOTFOUND, "DIERR_OBJECTNOTFOUND")
//      CHK_ERR(DIERR_INVALIDPARAM, "DIERR_INVALIDPARAM")         
//      CHK_ERR(DIERR_NOINTERFACE, "DIERR_NOINTERFACE")         
//      CHK_ERR(DIERR_GENERIC, "DIERR_GENERIC")         
//      CHK_ERR(DIERR_OUTOFMEMORY, "DIERR_OUTOFMEMORY")         
//      CHK_ERR(DIERR_UNSUPPORTED, "DIERR_UNSUPPORTED")         
        CHK_ERR(DIERR_NOTINITIALIZED, "DIERR_NOTINITIALIZED")
        CHK_ERR(DIERR_ALREADYINITIALIZED, "DIERR_ALREADYINITIALIZED")
//      CHK_ERR(DIERR_NOAGGREGATION, "DIERR_NOAGGREGATION")
//      CHK_ERR(DIERR_OTHERAPPHASPRIO, "DIERR_OTHERAPPHASPRIO")         
        CHK_ERR(DIERR_INPUTLOST, "DIERR_INPUTLOST")
        CHK_ERR(DIERR_ACQUIRED, "DIERR_ACQUIRED")
        CHK_ERR(DIERR_NOTACQUIRED, "DIERR_NOTACQUIRED")
//      CHK_ERR(DIERR_READONLY, "DIERR_READONLY")
//      CHK_ERR(DIERR_HANDLEEXISTS, "DIERR_HANDLEEXISTS")         
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, "DIERR_INSUFFICIENTPRIVS & VFW_E_INVALIDMEDIATYPE")        
        CHK_ERR(DIERR_DEVICEFULL, "DIERR_DEVICEFULL & VFW_E_INVALIDSUBTYPE & DMO_E_INVALIDSTREAMINDEX")
        CHK_ERR(DIERR_MOREDATA, "DIERR_MOREDATA & VFW_E_NEED_OWNER & DMO_E_INVALIDTYPE")
        CHK_ERR(DIERR_NOTDOWNLOADED, "DIERR_NOTDOWNLOADED & VFW_E_ENUM_OUT_OF_SYNC & DMO_E_TYPE_NOT_SET")
        CHK_ERR(DIERR_HASEFFECTS, "DIERR_HASEFFECTS & VFW_E_ALREADY_CONNECTED & DMO_E_NOTACCEPTING")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, "DIERR_NOTEXCLUSIVEACQUIRED & VFW_E_FILTER_ACTIVE & DMO_E_TYPE_NOT_ACCEPTED")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, "DIERR_INCOMPLETEEFFECT & VFW_E_NO_TYPES & DMO_E_NO_MORE_ITEMS")
        CHK_ERR(DIERR_NOTBUFFERED, "DIERR_NOTBUFFERED & VFW_E_NO_ACCEPTABLE_TYPES")
        CHK_ERR(DIERR_EFFECTPLAYING, "DIERR_EFFECTPLAYING & VFW_E_INVALID_DIRECTION")
        CHK_ERR(DIERR_UNPLUGGED, "DIERR_UNPLUGGED & VFW_E_NOT_CONNECTED")
        CHK_ERR(DIERR_REPORTFULL, "DIERR_REPORTFULL & VFW_E_NO_ALLOCATOR")
        CHK_ERR(DIERR_MAPFILEFAIL, "DIERR_MAPFILEFAIL & VFW_E_RUNTIME_ERROR")
 

// -------------------------------------------------------------        
// dinputd.h error codes as of 9/8/00
// -------------------------------------------------------------                
        CHK_ERR(DIERR_NOMOREITEMS, "DIERR_NOMOREITEMS")        
        CHK_ERR(DIERR_DRIVERFIRST, "DIERR_DRIVERFIRST")
        CHK_ERR(DIERR_DRIVERFIRST+1, "DIERR_DRIVERFIRST+1")
        CHK_ERR(DIERR_DRIVERFIRST+2, "DIERR_DRIVERFIRST+2")
        CHK_ERR(DIERR_DRIVERFIRST+3, "DIERR_DRIVERFIRST+3")
        CHK_ERR(DIERR_DRIVERFIRST+4, "DIERR_DRIVERFIRST+4")
        CHK_ERR(DIERR_DRIVERFIRST+5, "DIERR_DRIVERFIRST+5")
        CHK_ERR(DIERR_DRIVERLAST, "DIERR_DRIVERLAST")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, "DIERR_INVALIDCLASSINSTALLER")
        CHK_ERR(DIERR_CANCELLED, "DIERR_CANCELLED")
        CHK_ERR(DIERR_BADINF, "DIERR_BADINF")
        
        
// -------------------------------------------------------------        
// dvoice.h error codes as of 9/8/00
// -------------------------------------------------------------                        
//      CHK_ERR(DV_OK, "DV_OK")
        CHK_ERR(DV_FULLDUPLEX, "DV_FULLDUPLEX")
        CHK_ERR(DV_HALFDUPLEX, "DV_HALFDUPLEX")
        CHK_ERR(DV_PENDING, "DV_PENDING")
        CHK_ERR(DVERR_BUFFERTOOSMALL, "DVERR_BUFFERTOOSMALL")
        CHK_ERR(DVERR_EXCEPTION, "DVERR_EXCEPTION")
//      CHK_ERR(DVERR_GENERIC, "DVERR_GENERIC")
        CHK_ERR(DVERR_INVALIDFLAGS, "DVERR_INVALIDFLAGS")
        CHK_ERR(DVERR_INVALIDOBJECT, "DVERR_INVALIDOBJECT")
        CHK_ERR(DVERR_INVALIDPLAYER, "DVERR_INVALIDPLAYER")
        CHK_ERR(DVERR_INVALIDGROUP, "DVERR_INVALIDGROUP")
        CHK_ERR(DVERR_INVALIDHANDLE, "DVERR_INVALIDHANDLE")
//      CHK_ERR(DVERR_OUTOFMEMORY, "DVERR_OUTOFMEMORY")
//      CHK_ERR(DVERR_PENDING, "DVERR_PENDING")
//      CHK_ERR(DVERR_NOTSUPPORTED, "DVERR_NOTSUPPORTED")
//      CHK_ERR(DVERR_NOINTERFACE, "DVERR_NOINTERFACE")
        CHK_ERR(DVERR_SESSIONLOST, "DVERR_SESSIONLOST")
        CHK_ERR(DVERR_NOVOICESESSION, "DVERR_NOVOICESESSION")
        CHK_ERR(DVERR_CONNECTIONLOST, "DVERR_CONNECTIONLOST")
        CHK_ERR(DVERR_NOTINITIALIZED, "DVERR_NOTINITIALIZED")
        CHK_ERR(DVERR_CONNECTED, "DVERR_CONNECTED")
        CHK_ERR(DVERR_NOTCONNECTED, "DVERR_NOTCONNECTED")
        CHK_ERR(DVERR_CONNECTABORTING, "DVERR_CONNECTABORTING")
        CHK_ERR(DVERR_NOTALLOWED, "DVERR_NOTALLOWED")
        CHK_ERR(DVERR_INVALIDTARGET, "DVERR_INVALIDTARGET")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, "DVERR_TRANSPORTNOTHOST")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, "DVERR_COMPRESSIONNOTSUPPORTED")
        CHK_ERR(DVERR_ALREADYPENDING, "DVERR_ALREADYPENDING")
        CHK_ERR(DVERR_SOUNDINITFAILURE, "DVERR_SOUNDINITFAILURE")
        CHK_ERR(DVERR_TIMEOUT, "DVERR_TIMEOUT")
        CHK_ERR(DVERR_CONNECTABORTED, "DVERR_CONNECTABORTED")
        CHK_ERR(DVERR_NO3DSOUND, "DVERR_NO3DSOUND")
        CHK_ERR(DVERR_ALREADYBUFFERED, "DVERR_ALREADYBUFFERED")
        CHK_ERR(DVERR_NOTBUFFERED, "DVERR_NOTBUFFERED")
        CHK_ERR(DVERR_HOSTING, "DVERR_HOSTING")
        CHK_ERR(DVERR_NOTHOSTING, "DVERR_NOTHOSTING")
        CHK_ERR(DVERR_INVALIDDEVICE, "DVERR_INVALIDDEVICE")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, "DVERR_RECORDSYSTEMERROR")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, "DVERR_PLAYBACKSYSTEMERROR")
        CHK_ERR(DVERR_SENDERROR, "DVERR_SENDERROR")
        CHK_ERR(DVERR_USERCANCEL, "DVERR_USERCANCEL")
        CHK_ERR(DVERR_RUNSETUP, "DVERR_RUNSETUP")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, "DVERR_INCOMPATIBLEVERSION")
        CHK_ERR(DVERR_INITIALIZED, "DVERR_INITIALIZED")
//      CHK_ERR(DVERR_INVALIDPOINTER, "DVERR_INVALIDPOINTER")
        CHK_ERR(DVERR_NOTRANSPORT, "DVERR_NOTRANSPORT")
        CHK_ERR(DVERR_NOCALLBACK, "DVERR_NOCALLBACK")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, "DVERR_TRANSPORTNOTINIT")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, "DVERR_TRANSPORTNOSESSION")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, "DVERR_TRANSPORTNOPLAYER")
        CHK_ERR(DVERR_USERBACK, "DVERR_USERBACK")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, "DVERR_NORECVOLAVAILABLE")
        CHK_ERR(DVERR_INVALIDBUFFER, "DVERR_INVALIDBUFFER")
        CHK_ERR(DVERR_LOCKEDBUFFER, "DVERR_LOCKEDBUFFER")
        
              
// -------------------------------------------------------------        
// dplay8.h error codes as of 10/4/00
// -------------------------------------------------------------                        
        CHK_ERR(DPNERR_ABORTED, "DPNERR_ABORTED")
        CHK_ERR(DPNERR_ADDRESSING, "DPNERR_ADDRESSING")
        CHK_ERR(DPNERR_ALREADYCLOSING, "DPNERR_ALREADYCLOSING")        
        CHK_ERR(DPNERR_ALREADYCONNECTED, "DPNERR_ALREADYCONNECTED")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, "DPNERR_ALREADYDISCONNECTING")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, "DPNERR_ALREADYINITIALIZED")
        CHK_ERR(DPNERR_ALREADYREGISTERED, "DPNERR_ALREADYREGISTERED")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, "DPNERR_BUFFERTOOSMALL")
        CHK_ERR(DPNERR_CANNOTCANCEL, "DPNERR_CANNOTCANCEL")
        CHK_ERR(DPNERR_CANTCREATEGROUP, "DPNERR_CANTCREATEGROUP")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, "DPNERR_CANTCREATEPLAYER")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, "DPNERR_CANTLAUNCHAPPLICATION")
        CHK_ERR(DPNERR_CONNECTING, "DPNERR_CONNECTING")
        CHK_ERR(DPNERR_CONNECTIONLOST, "DPNERR_CONNECTIONLOST")
        CHK_ERR(DPNERR_CONVERSION, "DPNERR_CONVERSION")
        CHK_ERR(DPNERR_DATATOOLARGE, "DPNERR_DATATOOLARGE")
        CHK_ERR(DPNERR_DOESNOTEXIST, "DPNERR_DOESNOTEXIST")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, "DPNERR_DUPLICATECOMMAND")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, "DPNERR_ENDPOINTNOTRECEIVING")
        CHK_ERR(DPNERR_ENUMQUERYTOOLARGE, "DPNERR_ENUMQUERYTOOLARGE")
        CHK_ERR(DPNERR_ENUMRESPONSETOOLARGE, "DPNERR_ENUMRESPONSETOOLARGE")
        CHK_ERR(DPNERR_EXCEPTION, "DPNERR_EXCEPTION")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, "DPNERR_GROUPNOTEMPTY")
        CHK_ERR(DPNERR_HOSTING, "DPNERR_HOSTING")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, "DPNERR_HOSTREJECTEDCONNECTION")
        CHK_ERR(DPNERR_HOSTTERMINATEDSESSION, "DPNERR_HOSTTERMINATEDSESSION")        
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, "DPNERR_INCOMPLETEADDRESS")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, "DPNERR_INVALIDADDRESSFORMAT")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, "DPNERR_INVALIDAPPLICATION")
        CHK_ERR(DPNERR_INVALIDCOMMAND, "DPNERR_INVALIDCOMMAND")
        CHK_ERR(DPNERR_INVALIDENDPOINT, "DPNERR_INVALIDENDPOINT")
        CHK_ERR(DPNERR_INVALIDFLAGS, "DPNERR_INVALIDFLAGS")
        CHK_ERR(DPNERR_INVALIDGROUP, "DPNERR_INVALIDGROUP")
        CHK_ERR(DPNERR_INVALIDHANDLE, "DPNERR_INVALIDHANDLE")
        CHK_ERR(DPNERR_INVALIDINSTANCE, "DPNERR_INVALIDINSTANCE")
        CHK_ERR(DPNERR_INVALIDINTERFACE, "DPNERR_INVALIDINTERFACE")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, "DPNERR_INVALIDDEVICEADDRESS")
        CHK_ERR(DPNERR_INVALIDOBJECT, "DPNERR_INVALIDOBJECT")
//      CHK_ERR(DPNERR_INVALIDPARAM, "DPNERR_INVALIDPARAM")        
        CHK_ERR(DPNERR_INVALIDPASSWORD, "DPNERR_INVALIDPASSWORD")
        CHK_ERR(DPNERR_INVALIDPLAYER, "DPNERR_INVALIDPLAYER")
//      CHK_ERR(DPNERR_INVALIDPOINTER, "DPNERR_INVALIDPOINTER")        
        CHK_ERR(DPNERR_INVALIDPRIORITY, "DPNERR_INVALIDPRIORITY")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, "DPNERR_INVALIDHOSTADDRESS")
        CHK_ERR(DPNERR_INVALIDSTRING, "DPNERR_INVALIDSTRING")
        CHK_ERR(DPNERR_INVALIDURL, "DPNERR_INVALIDURL")
        CHK_ERR(DPNERR_INVALIDVERSION, "DPNERR_INVALIDVERSION")
        CHK_ERR(DPNERR_NOCAPS, "DPNERR_NOCAPS")
        CHK_ERR(DPNERR_NOCONNECTION, "DPNERR_NOCONNECTION")
        CHK_ERR(DPNERR_NOHOSTPLAYER, "DPNERR_NOHOSTPLAYER")
//      CHK_ERR(DPNERR_NOINTERFACE, "DPNERR_NOINTERFACE")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, "DPNERR_NOMOREADDRESSCOMPONENTS")
        CHK_ERR(DPNERR_NORESPONSE, "DPNERR_NORESPONSE")
        CHK_ERR(DPNERR_NOTALLOWED, "DPNERR_NOTALLOWED")
        CHK_ERR(DPNERR_NOTHOST, "DPNERR_NOTHOST")
        CHK_ERR(DPNERR_NOTREADY, "DPNERR_NOTREADY")
        CHK_ERR(DPNERR_NOTREGISTERED, "DPNERR_NOTREGISTERED")
//      CHK_ERR(DPNERR_OUTOFMEMORY, "DPNERR_OUTOFMEMORY")
//      CHK_ERR(DPNERR_PENDING, "DPNERR_PENDING")
        CHK_ERR(DPNERR_PLAYERLOST, "DPNERR_PLAYERLOST")
        CHK_ERR(DPNERR_PLAYERNOTREACHABLE, "DPNERR_PLAYERNOTREACHABLE")
        CHK_ERR(DPNERR_SENDTOOLARGE, "DPNERR_SENDTOOLARGE")
        CHK_ERR(DPNERR_SESSIONFULL, "DPNERR_SESSIONFULL")
        CHK_ERR(DPNERR_TABLEFULL, "DPNERR_TABLEFULL")
        CHK_ERR(DPNERR_TIMEDOUT, "DPNERR_TIMEDOUT")
        CHK_ERR(DPNERR_UNINITIALIZED, "DPNERR_UNINITIALIZED")
//      CHK_ERR(DPNERR_UNSUPPORTED, "DPNERR_UNSUPPORTED")
        CHK_ERR(DPNERR_USERCANCEL, "DPNERR_USERCANCEL")
        
              
// -------------------------------------------------------------        
// dxfile.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(DXFILE_OK, "DXFILE_OK")
        CHK_ERR(DXFILEERR_BADOBJECT, "DXFILEERR_BADOBJECT")
        CHK_ERR(DXFILEERR_BADVALUE, "DXFILEERR_BADVALUE")
        CHK_ERR(DXFILEERR_BADTYPE, "DXFILEERR_BADTYPE")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, "DXFILEERR_BADSTREAMHANDLE")
        CHK_ERR(DXFILEERR_BADALLOC, "DXFILEERR_BADALLOC")
        CHK_ERR(DXFILEERR_NOTFOUND, "DXFILEERR_NOTFOUND")
        CHK_ERR(DXFILEERR_NOTDONEYET, "DXFILEERR_NOTDONEYET")
        CHK_ERR(DXFILEERR_FILENOTFOUND, "DXFILEERR_FILENOTFOUND")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, "DXFILEERR_RESOURCENOTFOUND")
        CHK_ERR(DXFILEERR_URLNOTFOUND, "DXFILEERR_URLNOTFOUND")
        CHK_ERR(DXFILEERR_BADRESOURCE, "DXFILEERR_BADRESOURCE")
        CHK_ERR(DXFILEERR_BADFILETYPE, "DXFILEERR_BADFILETYPE")
        CHK_ERR(DXFILEERR_BADFILEVERSION, "DXFILEERR_BADFILEVERSION")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, "DXFILEERR_BADFILEFLOATSIZE")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, "DXFILEERR_BADFILECOMPRESSIONTYPE")
        CHK_ERR(DXFILEERR_BADFILE, "DXFILEERR_BADFILE")
        CHK_ERR(DXFILEERR_PARSEERROR, "DXFILEERR_PARSEERROR")
        CHK_ERR(DXFILEERR_NOTEMPLATE, "DXFILEERR_NOTEMPLATE")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, "DXFILEERR_BADARRAYSIZE")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, "DXFILEERR_BADDATAREFERENCE")
        CHK_ERR(DXFILEERR_INTERNALERROR, "DXFILEERR_INTERNALERROR")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, "DXFILEERR_NOMOREOBJECTS")
        CHK_ERR(DXFILEERR_BADINTRINSICS, "DXFILEERR_BADINTRINSICS")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, "DXFILEERR_NOMORESTREAMHANDLES")
        CHK_ERR(DXFILEERR_NOMOREDATA, "DXFILEERR_NOMOREDATA")
        CHK_ERR(DXFILEERR_BADCACHEFILE, "DXFILEERR_BADCACHEFILE")
        CHK_ERR(DXFILEERR_NOINTERNET, "DXFILEERR_NOINTERNET")
        
        
// -------------------------------------------------------------        
// d3d8.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(D3D_OK, "D3D_OK")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, "D3DERR_WRONGTEXTUREFORMAT")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, "D3DERR_UNSUPPORTEDCOLOROPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, "D3DERR_UNSUPPORTEDCOLORARG")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, "D3DERR_UNSUPPORTEDALPHAOPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, "D3DERR_UNSUPPORTEDALPHAARG")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, "D3DERR_TOOMANYOPERATIONS")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, "D3DERR_CONFLICTINGTEXTUREFILTER")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, "D3DERR_UNSUPPORTEDFACTORVALUE")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, "D3DERR_CONFLICTINGRENDERSTATE")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, "D3DERR_UNSUPPORTEDTEXTUREFILTER")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, "D3DERR_CONFLICTINGTEXTUREPALETTE")                
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, "D3DERR_DRIVERINTERNALERROR")
        CHK_ERR(D3DERR_NOTFOUND, "D3DERR_NOTFOUND")
        CHK_ERR(D3DERR_MOREDATA, "D3DERR_MOREDATA")
        CHK_ERR(D3DERR_DEVICELOST, "D3DERR_DEVICELOST")
        CHK_ERR(D3DERR_DEVICENOTRESET, "D3DERR_DEVICENOTRESET")
        CHK_ERR(D3DERR_NOTAVAILABLE, "D3DERR_NOTAVAILABLE")
        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, "D3DERR_OUTOFVIDEOMEMORY")
        CHK_ERR(D3DERR_INVALIDDEVICE, "D3DERR_INVALIDDEVICE")
        CHK_ERR(D3DERR_INVALIDCALL, "D3DERR_INVALIDCALL")
        CHK_ERR(D3DERR_DRIVERINVALIDCALL, "D3DERR_DRIVERINVALIDCALL")                        
        
        
// -------------------------------------------------------------        
// d3dx8mesh.h error codes as of 12/5/00
// -------------------------------------------------------------                                
        CHK_ERR(D3DXERR_CANNOTMODIFYINDEXBUFFER, "D3DXERR_CANNOTMODIFYINDEXBUFFER")                        
        CHK_ERR(D3DXERR_INVALIDMESH, "D3DXERR_INVALIDMESH")                        
        CHK_ERR(D3DXERR_CANNOTATTRSORT, "D3DXERR_CANNOTATTRSORT")                        
        CHK_ERR(D3DXERR_SKINNINGNOTSUPPORTED, "D3DXERR_SKINNINGNOTSUPPORTED")                        
        CHK_ERR(D3DXERR_TOOMANYINFLUENCES, "D3DXERR_TOOMANYINFLUENCES")                        
        CHK_ERR(D3DXERR_INVALIDDATA, "D3DXERR_INVALIDDATA")                        

   
// -------------------------------------------------------------        
// dsound.h error codes as of 9/8/00
// -------------------------------------------------------------        
//      CHK_ERR(DS_OK, "DS_OK")        
        CHK_ERR(DS_NO_VIRTUALIZATION, "DS_NO_VIRTUALIZATION")           
        CHK_ERR(DS_INCOMPLETE, "DS_INCOMPLETE")             
        CHK_ERR(DSERR_ALLOCATED, "DSERR_ALLOCATED")
        CHK_ERR(DSERR_CONTROLUNAVAIL, "DSERR_CONTROLUNAVAIL")
//      CHK_ERR(DSERR_INVALIDPARAM, "DSERR_INVALIDPARAM")                
        CHK_ERR(DSERR_INVALIDCALL, "DSERR_INVALIDCALL")
//      CHK_ERR(DSERR_GENERIC, "DSERR_GENERIC")                
        CHK_ERR(DSERR_PRIOLEVELNEEDED, "DSERR_PRIOLEVELNEEDED")
//      CHK_ERR(DSERR_OUTOFMEMORY, "DSERR_OUTOFMEMORY")                
        CHK_ERR(DSERR_BADFORMAT, "DSERR_BADFORMAT")
//      CHK_ERR(DSERR_UNSUPPORTED, "DSERR_UNSUPPORTED")                
        CHK_ERR(DSERR_NODRIVER, "DSERR_NODRIVER")
        CHK_ERR(DSERR_ALREADYINITIALIZED, "DSERR_ALREADYINITIALIZED")
//      CHK_ERR(DSERR_NOAGGREGATION, "DSERR_NOAGGREGATION")                
        CHK_ERR(DSERR_BUFFERLOST, "DSERR_BUFFERLOST")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, "DSERR_OTHERAPPHASPRIO")
        CHK_ERR(DSERR_UNINITIALIZED, "DSERR_UNINITIALIZED")
//      CHK_ERR(DSERR_NOINTERFACE, "DSERR_NOINTERFACE")                
//      CHK_ERR(DSERR_ACCESSDENIED, "DSERR_ACCESSDENIED")        
        CHK_ERR(DSERR_BUFFERTOOSMALL, "DSERR_BUFFERTOOSMALL")        
        CHK_ERR(DSERR_DS8_REQUIRED, "DSERR_DS8_REQUIRED")        
        CHK_ERR(DSERR_SENDLOOP, "DSERR_SENDLOOP")        
        CHK_ERR(DSERR_BADSENDBUFFERGUID, "DSERR_BADSENDBUFFERGUID")        
        CHK_ERR(DSERR_OBJECTNOTFOUND, "DSERR_OBJECTNOTFOUND")        
   
// -------------------------------------------------------------        
// dmerror.h error codes as of 9/8/00
// -------------------------------------------------------------        
        CHK_ERR(DMUS_S_PARTIALLOAD, "DMUS_S_PARTIALLOAD")  
        CHK_ERR(DMUS_S_PARTIALDOWNLOAD, "DMUS_S_PARTIALDOWNLOAD")    
        CHK_ERR(DMUS_S_REQUEUE, "DMUS_S_REQUEUE")            
        CHK_ERR(DMUS_S_FREE, "DMUS_S_FREE")  
        CHK_ERR(DMUS_S_END, "DMUS_S_END")                
        CHK_ERR(DMUS_S_STRING_TRUNCATED, "DMUS_S_STRING_TRUNCATED")   
        CHK_ERR(DMUS_S_LAST_TOOL, "DMUS_S_LAST_TOOL")          
        CHK_ERR(DMUS_S_OVER_CHORD, "DMUS_S_OVER_CHORD")         
        CHK_ERR(DMUS_S_UP_OCTAVE, "DMUS_S_UP_OCTAVE")          
        CHK_ERR(DMUS_S_DOWN_OCTAVE, "DMUS_S_DOWN_OCTAVE")        
        CHK_ERR(DMUS_S_NOBUFFERCONTROL, "DMUS_S_NOBUFFERCONTROL")    
        CHK_ERR(DMUS_S_GARBAGE_COLLECTED, "DMUS_S_GARBAGE_COLLECTED")  
        CHK_ERR(DMUS_E_DRIVER_FAILED, "DMUS_E_DRIVER_FAILED")
        CHK_ERR(DMUS_E_PORTS_OPEN, "DMUS_E_PORTS_OPEN")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, "DMUS_E_DEVICE_IN_USE")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, "DMUS_E_INSUFFICIENTBUFFER")
        CHK_ERR(DMUS_E_BUFFERNOTSET, "DMUS_E_BUFFERNOTSET")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, "DMUS_E_BUFFERNOTAVAILABLE")
        CHK_ERR(DMUS_E_NOTADLSCOL, "DMUS_E_NOTADLSCOL")
        CHK_ERR(DMUS_E_INVALIDOFFSET, "DMUS_E_INVALIDOFFSET")
        CHK_ERR(DMUS_E_ALREADY_LOADED, "DMUS_E_ALREADY_LOADED")
        CHK_ERR(DMUS_E_INVALIDPOS, "DMUS_E_INVALIDPOS")
        CHK_ERR(DMUS_E_INVALIDPATCH, "DMUS_E_INVALIDPATCH")
        CHK_ERR(DMUS_E_CANNOTSEEK, "DMUS_E_CANNOTSEEK")
        CHK_ERR(DMUS_E_CANNOTWRITE, "DMUS_E_CANNOTWRITE")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, "DMUS_E_CHUNKNOTFOUND")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, "DMUS_E_INVALID_DOWNLOADID")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, "DMUS_E_NOT_DOWNLOADED_TO_PORT")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, "DMUS_E_ALREADY_DOWNLOADED")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, "DMUS_E_UNKNOWN_PROPERTY")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, "DMUS_E_SET_UNSUPPORTED")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, "DMUS_E_GET_UNSUPPORTED")
        CHK_ERR(DMUS_E_NOTMONO, "DMUS_E_NOTMONO")
        CHK_ERR(DMUS_E_BADARTICULATION, "DMUS_E_BADARTICULATION")
        CHK_ERR(DMUS_E_BADINSTRUMENT, "DMUS_E_BADINSTRUMENT")
        CHK_ERR(DMUS_E_BADWAVELINK, "DMUS_E_BADWAVELINK")
        CHK_ERR(DMUS_E_NOARTICULATION, "DMUS_E_NOARTICULATION")
        CHK_ERR(DMUS_E_NOTPCM, "DMUS_E_NOTPCM")
        CHK_ERR(DMUS_E_BADWAVE, "DMUS_E_BADWAVE")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, "DMUS_E_BADOFFSETTABLE")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, "DMUS_E_UNKNOWNDOWNLOAD")
        CHK_ERR(DMUS_E_NOSYNTHSINK, "DMUS_E_NOSYNTHSINK")
        CHK_ERR(DMUS_E_ALREADYOPEN, "DMUS_E_ALREADYOPEN")
        CHK_ERR(DMUS_E_ALREADYCLOSED, "DMUS_E_ALREADYCLOSED")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, "DMUS_E_SYNTHNOTCONFIGURED")
        CHK_ERR(DMUS_E_SYNTHACTIVE, "DMUS_E_SYNTHACTIVE")
        CHK_ERR(DMUS_E_CANNOTREAD, "DMUS_E_CANNOTREAD")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, "DMUS_E_DMUSIC_RELEASED")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, "DMUS_E_BUFFER_EMPTY")
        CHK_ERR(DMUS_E_BUFFER_FULL, "DMUS_E_BUFFER_FULL")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, "DMUS_E_PORT_NOT_CAPTURE")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, "DMUS_E_PORT_NOT_RENDER")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, "DMUS_E_DSOUND_NOT_SET")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, "DMUS_E_ALREADY_ACTIVATED")
        CHK_ERR(DMUS_E_INVALIDBUFFER, "DMUS_E_INVALIDBUFFER")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, "DMUS_E_WAVEFORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, "DMUS_E_SYNTHINACTIVE")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, "DMUS_E_DSOUND_ALREADY_SET")
        CHK_ERR(DMUS_E_INVALID_EVENT, "DMUS_E_INVALID_EVENT")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, "DMUS_E_UNSUPPORTED_STREAM")
        CHK_ERR(DMUS_E_ALREADY_INITED, "DMUS_E_ALREADY_INITED")
        CHK_ERR(DMUS_E_INVALID_BAND, "DMUS_E_INVALID_BAND")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, "DMUS_E_TRACK_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, "DMUS_E_TOOL_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, "DMUS_E_INVALID_TRACK_HDR")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, "DMUS_E_INVALID_TOOL_HDR")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, "DMUS_E_ALL_TOOLS_FAILED")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, "DMUS_E_ALL_TRACKS_FAILED")
//      CHK_ERR(DMUS_E_NOT_FOUND, "DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, "DMUS_E_NOT_INIT")
        CHK_ERR(DMUS_E_TYPE_DISABLED, "DMUS_E_TYPE_DISABLED")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, "DMUS_E_TYPE_UNSUPPORTED")
        CHK_ERR(DMUS_E_TIME_PAST, "DMUS_E_TIME_PAST")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, "DMUS_E_TRACK_NOT_FOUND")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, "DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, "DMUS_E_NO_MASTER_CLOCK")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, "DMUS_E_LOADER_NOCLASSID")
        CHK_ERR(DMUS_E_LOADER_BADPATH, "DMUS_E_LOADER_BADPATH")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, "DMUS_E_LOADER_FAILEDOPEN")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, "DMUS_E_LOADER_FORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, "DMUS_E_LOADER_FAILEDCREATE")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, "DMUS_E_LOADER_OBJECTNOTFOUND")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, "DMUS_E_LOADER_NOFILENAME")
        CHK_ERR(DMUS_E_INVALIDFILE, "DMUS_E_INVALIDFILE")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, "DMUS_E_ALREADY_EXISTS")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, "DMUS_E_OUT_OF_RANGE")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, "DMUS_E_SEGMENT_INIT_FAILED")
        CHK_ERR(DMUS_E_ALREADY_SENT, "DMUS_E_ALREADY_SENT")
        CHK_ERR(DMUS_E_CANNOT_FREE, "DMUS_E_CANNOT_FREE")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, "DMUS_E_CANNOT_OPEN_PORT")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, "DMUS_E_CANNOT_CONVERT")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, "DMUS_E_DESCEND_CHUNK_FAIL")
        CHK_ERR(DMUS_E_NOT_LOADED, "DMUS_E_NOT_LOADED")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, "DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, "DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, "DMUS_E_SCRIPT_ERROR_IN_SCRIPT")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, "DMUS_E_SCRIPT_CANTLOAD_OLEAUT32")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, "DMUS_E_SCRIPT_LOADSCRIPT_ERROR")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, "DMUS_E_SCRIPT_INVALID_FILE")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, "DMUS_E_INVALID_SCRIPTTRACK")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, "DMUS_E_SCRIPT_VARIABLE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, "DMUS_E_SCRIPT_ROUTINE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_CONTENT_READONLY, "DMUS_E_SCRIPT_CONTENT_READONLY")
        CHK_ERR(DMUS_E_SCRIPT_NOT_A_REFERENCE, "DMUS_E_SCRIPT_NOT_A_REFERENCE")
        CHK_ERR(DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED, "DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, "DMUS_E_INVALID_SEGMENTTRIGGERTRACK")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, "DMUS_E_INVALID_LYRICSTRACK")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, "DMUS_E_INVALID_PARAMCONTROLTRACK")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, "DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, "DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, "DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, "DMUS_E_AUDIOPATHS_NOT_VALID")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, "DMUS_E_AUDIOPATHS_IN_USE")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, "DMUS_E_NO_AUDIOPATH_CONFIG")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, "DMUS_E_AUDIOPATH_INACTIVE")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, "DMUS_E_AUDIOPATH_NOBUFFER")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, "DMUS_E_AUDIOPATH_NOPORT")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, "DMUS_E_NO_AUDIOPATH")
        CHK_ERR(DMUS_E_INVALIDCHUNK, "DMUS_E_INVALIDCHUNK")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, "DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, "DMUS_E_INVALID_CONTAINER_OBJECT")    
   
// -------------------------------------------------------------        
// vfwmsgs.h error codes as of 9/8/00
// -------------------------------------------------------------        
//      CHK_ERR(VFW_E_INVALIDMEDIATYPE, "VFW_E_INVALIDMEDIATYPE")
//      CHK_ERR(VFW_E_INVALIDSUBTYPE, "VFW_E_INVALIDSUBTYPE")
//      CHK_ERR(VFW_E_NEED_OWNER, "VFW_E_NEED_OWNER")
//      CHK_ERR(VFW_E_ENUM_OUT_OF_SYNC, "VFW_E_ENUM_OUT_OF_SYNC")
//      CHK_ERR(VFW_E_ALREADY_CONNECTED, "VFW_E_ALREADY_CONNECTED")
//      CHK_ERR(VFW_E_FILTER_ACTIVE, "VFW_E_FILTER_ACTIVE")
//      CHK_ERR(VFW_E_NO_TYPES, "VFW_E_NO_TYPES")
//      CHK_ERR(VFW_E_NO_ACCEPTABLE_TYPES, "VFW_E_NO_ACCEPTABLE_TYPES")
//      CHK_ERR(VFW_E_INVALID_DIRECTION, "VFW_E_INVALID_DIRECTION")
//      CHK_ERR(VFW_E_NOT_CONNECTED, "VFW_E_NOT_CONNECTED")
//      CHK_ERR(VFW_E_NO_ALLOCATOR, "VFW_E_NO_ALLOCATOR")
//      CHK_ERR(VFW_E_RUNTIME_ERROR, "VFW_E_RUNTIME_ERROR")
        CHK_ERR(VFW_E_BUFFER_NOTSET, "VFW_E_BUFFER_NOTSET")
        CHK_ERR(VFW_E_BUFFER_OVERFLOW, "VFW_E_BUFFER_OVERFLOW")
        CHK_ERR(VFW_E_BADALIGN, "VFW_E_BADALIGN")
        CHK_ERR(VFW_E_ALREADY_COMMITTED, "VFW_E_ALREADY_COMMITTED")
        CHK_ERR(VFW_E_BUFFERS_OUTSTANDING, "VFW_E_BUFFERS_OUTSTANDING")
        CHK_ERR(VFW_E_NOT_COMMITTED, "VFW_E_NOT_COMMITTED")
        CHK_ERR(VFW_E_SIZENOTSET, "VFW_E_SIZENOTSET")
        CHK_ERR(VFW_E_NO_CLOCK, "VFW_E_NO_CLOCK")
        CHK_ERR(VFW_E_NO_SINK, "VFW_E_NO_SINK")
        CHK_ERR(VFW_E_NO_INTERFACE, "VFW_E_NO_INTERFACE")
        CHK_ERR(VFW_E_NOT_FOUND, "VFW_E_NOT_FOUND")
        CHK_ERR(VFW_E_CANNOT_CONNECT, "VFW_E_CANNOT_CONNECT")
        CHK_ERR(VFW_E_CANNOT_RENDER, "VFW_E_CANNOT_RENDER")
        CHK_ERR(VFW_E_CHANGING_FORMAT, "VFW_E_CHANGING_FORMAT")
        CHK_ERR(VFW_E_NO_COLOR_KEY_SET, "VFW_E_NO_COLOR_KEY_SET")
        CHK_ERR(VFW_E_NOT_OVERLAY_CONNECTION, "VFW_E_NOT_OVERLAY_CONNECTION")
        CHK_ERR(VFW_E_NOT_SAMPLE_CONNECTION, "VFW_E_NOT_SAMPLE_CONNECTION")
        CHK_ERR(VFW_E_PALETTE_SET, "VFW_E_PALETTE_SET")
        CHK_ERR(VFW_E_COLOR_KEY_SET, "VFW_E_COLOR_KEY_SET")
        CHK_ERR(VFW_E_NO_COLOR_KEY_FOUND, "VFW_E_NO_COLOR_KEY_FOUND")
        CHK_ERR(VFW_E_NO_PALETTE_AVAILABLE, "VFW_E_NO_PALETTE_AVAILABLE")
        CHK_ERR(VFW_E_NO_DISPLAY_PALETTE, "VFW_E_NO_DISPLAY_PALETTE")
        CHK_ERR(VFW_E_TOO_MANY_COLORS, "VFW_E_TOO_MANY_COLORS")
        CHK_ERR(VFW_E_STATE_CHANGED, "VFW_E_STATE_CHANGED")
        CHK_ERR(VFW_E_NOT_STOPPED, "VFW_E_NOT_STOPPED")
        CHK_ERR(VFW_E_NOT_PAUSED, "VFW_E_NOT_PAUSED")
        CHK_ERR(VFW_E_NOT_RUNNING, "VFW_E_NOT_RUNNING")
        CHK_ERR(VFW_E_WRONG_STATE, "VFW_E_WRONG_STATE")
        CHK_ERR(VFW_E_START_TIME_AFTER_END, "VFW_E_START_TIME_AFTER_END")
        CHK_ERR(VFW_E_INVALID_RECT, "VFW_E_INVALID_RECT")
        CHK_ERR(VFW_E_TYPE_NOT_ACCEPTED, "VFW_E_TYPE_NOT_ACCEPTED")
        CHK_ERR(VFW_E_SAMPLE_REJECTED, "VFW_E_SAMPLE_REJECTED")
        CHK_ERR(VFW_E_SAMPLE_REJECTED_EOS, "VFW_E_SAMPLE_REJECTED_EOS")
        CHK_ERR(VFW_E_DUPLICATE_NAME, "VFW_E_DUPLICATE_NAME")
        CHK_ERR(VFW_S_DUPLICATE_NAME, "VFW_S_DUPLICATE_NAME")
        CHK_ERR(VFW_E_TIMEOUT, "VFW_E_TIMEOUT")
        CHK_ERR(VFW_E_INVALID_FILE_FORMAT, "VFW_E_INVALID_FILE_FORMAT")
        CHK_ERR(VFW_E_ENUM_OUT_OF_RANGE, "VFW_E_ENUM_OUT_OF_RANGE")
        CHK_ERR(VFW_E_CIRCULAR_GRAPH, "VFW_E_CIRCULAR_GRAPH")
        CHK_ERR(VFW_E_NOT_ALLOWED_TO_SAVE, "VFW_E_NOT_ALLOWED_TO_SAVE")
        CHK_ERR(VFW_E_TIME_ALREADY_PASSED, "VFW_E_TIME_ALREADY_PASSED")
        CHK_ERR(VFW_E_ALREADY_CANCELLED, "VFW_E_ALREADY_CANCELLED")
        CHK_ERR(VFW_E_CORRUPT_GRAPH_FILE, "VFW_E_CORRUPT_GRAPH_FILE")
        CHK_ERR(VFW_E_ADVISE_ALREADY_SET, "VFW_E_ADVISE_ALREADY_SET")
        CHK_ERR(VFW_S_STATE_INTERMEDIATE, "VFW_S_STATE_INTERMEDIATE")
        CHK_ERR(VFW_E_NO_MODEX_AVAILABLE, "VFW_E_NO_MODEX_AVAILABLE")
        CHK_ERR(VFW_E_NO_ADVISE_SET, "VFW_E_NO_ADVISE_SET")
        CHK_ERR(VFW_E_NO_FULLSCREEN, "VFW_E_NO_FULLSCREEN")
        CHK_ERR(VFW_E_IN_FULLSCREEN_MODE, "VFW_E_IN_FULLSCREEN_MODE")
        CHK_ERR(VFW_E_UNKNOWN_FILE_TYPE, "VFW_E_UNKNOWN_FILE_TYPE")
        CHK_ERR(VFW_E_CANNOT_LOAD_SOURCE_FILTER, "VFW_E_CANNOT_LOAD_SOURCE_FILTER")
        CHK_ERR(VFW_S_PARTIAL_RENDER, "VFW_S_PARTIAL_RENDER")
        CHK_ERR(VFW_E_FILE_TOO_SHORT, "VFW_E_FILE_TOO_SHORT")
        CHK_ERR(VFW_E_INVALID_FILE_VERSION, "VFW_E_INVALID_FILE_VERSION")
        CHK_ERR(VFW_S_SOME_DATA_IGNORED, "VFW_S_SOME_DATA_IGNORED")
        CHK_ERR(VFW_S_CONNECTIONS_DEFERRED, "VFW_S_CONNECTIONS_DEFERRED")
        CHK_ERR(VFW_E_INVALID_CLSID, "VFW_E_INVALID_CLSID")
        CHK_ERR(VFW_E_INVALID_MEDIA_TYPE, "VFW_E_INVALID_MEDIA_TYPE")
        CHK_ERR(VFW_E_BAD_KEY, "VFW_E_BAD_KEY")
        CHK_ERR(VFW_S_NO_MORE_ITEMS, "VFW_S_NO_MORE_ITEMS")
        CHK_ERR(VFW_E_SAMPLE_TIME_NOT_SET, "VFW_E_SAMPLE_TIME_NOT_SET")
        CHK_ERR(VFW_S_RESOURCE_NOT_NEEDED, "VFW_S_RESOURCE_NOT_NEEDED")
        CHK_ERR(VFW_E_MEDIA_TIME_NOT_SET, "VFW_E_MEDIA_TIME_NOT_SET")
        CHK_ERR(VFW_E_NO_TIME_FORMAT_SET, "VFW_E_NO_TIME_FORMAT_SET")
        CHK_ERR(VFW_E_MONO_AUDIO_HW, "VFW_E_MONO_AUDIO_HW")
        CHK_ERR(VFW_S_MEDIA_TYPE_IGNORED, "VFW_S_MEDIA_TYPE_IGNORED")
        CHK_ERR(VFW_E_NO_DECOMPRESSOR, "VFW_E_NO_DECOMPRESSOR")
        CHK_ERR(VFW_E_NO_AUDIO_HARDWARE, "VFW_E_NO_AUDIO_HARDWARE")
        CHK_ERR(VFW_S_VIDEO_NOT_RENDERED, "VFW_S_VIDEO_NOT_RENDERED")
        CHK_ERR(VFW_S_AUDIO_NOT_RENDERED, "VFW_S_AUDIO_NOT_RENDERED")
        CHK_ERR(VFW_E_RPZA, "VFW_E_RPZA")
        CHK_ERR(VFW_S_RPZA, "VFW_S_RPZA")
        CHK_ERR(VFW_E_PROCESSOR_NOT_SUITABLE, "VFW_E_PROCESSOR_NOT_SUITABLE")
        CHK_ERR(VFW_E_UNSUPPORTED_AUDIO, "VFW_E_UNSUPPORTED_AUDIO")
        CHK_ERR(VFW_E_UNSUPPORTED_VIDEO, "VFW_E_UNSUPPORTED_VIDEO")
        CHK_ERR(VFW_E_MPEG_NOT_CONSTRAINED, "VFW_E_MPEG_NOT_CONSTRAINED")
        CHK_ERR(VFW_E_NOT_IN_GRAPH, "VFW_E_NOT_IN_GRAPH")
        CHK_ERR(VFW_S_ESTIMATED, "VFW_S_ESTIMATED")
        CHK_ERR(VFW_E_NO_TIME_FORMAT, "VFW_E_NO_TIME_FORMAT")
        CHK_ERR(VFW_E_READ_ONLY, "VFW_E_READ_ONLY")
        CHK_ERR(VFW_S_RESERVED, "VFW_S_RESERVED")
        CHK_ERR(VFW_E_BUFFER_UNDERFLOW, "VFW_E_BUFFER_UNDERFLOW")
        CHK_ERR(VFW_E_UNSUPPORTED_STREAM, "VFW_E_UNSUPPORTED_STREAM")
        CHK_ERR(VFW_E_NO_TRANSPORT, "VFW_E_NO_TRANSPORT")
        CHK_ERR(VFW_S_STREAM_OFF, "VFW_S_STREAM_OFF")
        CHK_ERR(VFW_S_CANT_CUE, "VFW_S_CANT_CUE")
        CHK_ERR(VFW_E_BAD_VIDEOCD, "VFW_E_BAD_VIDEOCD")
        CHK_ERR(VFW_S_NO_STOP_TIME, "VFW_S_NO_STOP_TIME")
        CHK_ERR(VFW_E_OUT_OF_VIDEO_MEMORY, "VFW_E_OUT_OF_VIDEO_MEMORY")
        CHK_ERR(VFW_E_VP_NEGOTIATION_FAILED, "VFW_E_VP_NEGOTIATION_FAILED")
        CHK_ERR(VFW_E_DDRAW_CAPS_NOT_SUITABLE, "VFW_E_DDRAW_CAPS_NOT_SUITABLE")
        CHK_ERR(VFW_E_NO_VP_HARDWARE, "VFW_E_NO_VP_HARDWARE")
        CHK_ERR(VFW_E_NO_CAPTURE_HARDWARE, "VFW_E_NO_CAPTURE_HARDWARE")
        CHK_ERR(VFW_E_DVD_OPERATION_INHIBITED, "VFW_E_DVD_OPERATION_INHIBITED")
        CHK_ERR(VFW_E_DVD_INVALIDDOMAIN, "VFW_E_DVD_INVALIDDOMAIN")
        CHK_ERR(VFW_E_DVD_NO_BUTTON, "VFW_E_DVD_NO_BUTTON")
        CHK_ERR(VFW_E_DVD_GRAPHNOTREADY, "VFW_E_DVD_GRAPHNOTREADY")
        CHK_ERR(VFW_E_DVD_RENDERFAIL, "VFW_E_DVD_RENDERFAIL")
        CHK_ERR(VFW_E_DVD_DECNOTENOUGH, "VFW_E_DVD_DECNOTENOUGH")
        CHK_ERR(VFW_E_DDRAW_VERSION_NOT_SUITABLE, "VFW_E_DDRAW_VERSION_NOT_SUITABLE")
        CHK_ERR(VFW_E_COPYPROT_FAILED, "VFW_E_COPYPROT_FAILED")
        CHK_ERR(VFW_S_NOPREVIEWPIN, "VFW_S_NOPREVIEWPIN")
        CHK_ERR(VFW_E_TIME_EXPIRED, "VFW_E_TIME_EXPIRED")
        CHK_ERR(VFW_S_DVD_NON_ONE_SEQUENTIAL, "VFW_S_DVD_NON_ONE_SEQUENTIAL")
        CHK_ERR(VFW_E_DVD_WRONG_SPEED, "VFW_E_DVD_WRONG_SPEED")
        CHK_ERR(VFW_E_DVD_MENU_DOES_NOT_EXIST, "VFW_E_DVD_MENU_DOES_NOT_EXIST")
        CHK_ERR(VFW_E_DVD_CMD_CANCELLED, "VFW_E_DVD_CMD_CANCELLED")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_VERSION, "VFW_E_DVD_STATE_WRONG_VERSION")
        CHK_ERR(VFW_E_DVD_STATE_CORRUPT, "VFW_E_DVD_STATE_CORRUPT")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_DISC, "VFW_E_DVD_STATE_WRONG_DISC")
        CHK_ERR(VFW_E_DVD_INCOMPATIBLE_REGION, "VFW_E_DVD_INCOMPATIBLE_REGION")
        CHK_ERR(VFW_E_DVD_NO_ATTRIBUTES, "VFW_E_DVD_NO_ATTRIBUTES")
        CHK_ERR(VFW_E_DVD_NO_GOUP_PGC, "VFW_E_DVD_NO_GOUP_PGC")
        CHK_ERR(VFW_E_DVD_LOW_PARENTAL_LEVEL, "VFW_E_DVD_LOW_PARENTAL_LEVEL")
        CHK_ERR(VFW_E_DVD_NOT_IN_KARAOKE_MODE, "VFW_E_DVD_NOT_IN_KARAOKE_MODE")
        CHK_ERR(VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE, "VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE")
        CHK_ERR(VFW_S_DVD_NOT_ACCURATE, "VFW_S_DVD_NOT_ACCURATE")
        CHK_ERR(VFW_E_FRAME_STEP_UNSUPPORTED, "VFW_E_FRAME_STEP_UNSUPPORTED")
        CHK_ERR(VFW_E_DVD_STREAM_DISABLED, "VFW_E_DVD_STREAM_DISABLED")
        CHK_ERR(VFW_E_DVD_TITLE_UNKNOWN, "VFW_E_DVD_TITLE_UNKNOWN")
        CHK_ERR(VFW_E_DVD_INVALID_DISC, "VFW_E_DVD_INVALID_DISC")
        CHK_ERR(VFW_E_DVD_NO_RESUME_INFORMATION, "VFW_E_DVD_NO_RESUME_INFORMATION")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD, "VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED, "VFW_E_PIN_ALREADY_BLOCKED")
        CHK_ERR(VFW_E_CERTIFICATION_FAILURE, "VFW_E_CERTIFICATION_FAILURE")
        CHK_ERR(E_PROP_SET_UNSUPPORTED, "E_PROP_SET_UNSUPPORTED")
        CHK_ERR(E_PROP_ID_UNSUPPORTED, "E_PROP_ID_UNSUPPORTED")
   }
   
   return "Unknown";
}

















/****************************************************/
/* DXGetErrorString8W                               */
/*                                                  */
/****************************************************/
const WCHAR * WINAPI DXGetErrorString8W(HRESULT hr)
{
   switch(hr)
   {             
// -------------------------------------------------------------        
// Common Win32 error codes
// -------------------------------------------------------------        
        CHK_ERR(S_OK, L"S_OK")        
        CHK_ERR(S_FALSE, L"S_FALSE")
        
        CHK_ERR(ERROR_FILE_NOT_FOUND, L"ERROR_FILE_NOT_FOUND")
        CHK_ERR(ERROR_PATH_NOT_FOUND, L"ERROR_PATH_NOT_FOUND")
        CHK_ERR(ERROR_TOO_MANY_OPEN_FILES, L"ERROR_TOO_MANY_OPEN_FILES")
        CHK_ERR(ERROR_ACCESS_DENIED, L"ERROR_ACCESS_DENIED")
        CHK_ERR(ERROR_INVALID_HANDLE, L"ERROR_INVALID_HANDLE")
        CHK_ERR(ERROR_NOT_ENOUGH_MEMORY, L"ERROR_NOT_ENOUGH_MEMORY")
        CHK_ERR(ERROR_INVALID_BLOCK, L"ERROR_INVALID_BLOCK")
        CHK_ERR(ERROR_BAD_ENVIRONMENT, L"ERROR_BAD_ENVIRONMENT")
        CHK_ERR(ERROR_BAD_FORMAT, L"ERROR_BAD_FORMAT")
        CHK_ERR(ERROR_OUTOFMEMORY, L"ERROR_OUTOFMEMORY")
                
        CHK_ERR(E_UNEXPECTED, L"E_UNEXPECTED")
        CHK_ERR(E_NOTIMPL, L"E_NOTIMPL")
        CHK_ERR(E_OUTOFMEMORY, L"E_OUTOFMEMORY")
        CHK_ERR(E_INVALIDARG, L"E_INVALIDARG")
        CHK_ERR(E_NOINTERFACE, L"E_NOINTERFACE")
        CHK_ERR(E_POINTER, L"E_POINTER")
        CHK_ERR(E_HANDLE, L"E_HANDLE")
        CHK_ERR(E_ABORT, L"E_ABORT")
        CHK_ERR(E_FAIL, L"E_FAIL")
        CHK_ERR(E_ACCESSDENIED, L"E_ACCESSDENIED")
        CHK_ERR(E_PENDING, L"E_PENDING")
        CHK_ERR(REGDB_E_CLASSNOTREG, L"REGDB_E_CLASSNOTREG")
        CHK_ERR(CO_E_NOTINITIALIZED, L"CO_E_NOTINITIALIZED")
        CHK_ERR(CO_E_ALREADYINITIALIZED, L"CO_E_ALREADYINITIALIZED")
        CHK_ERR(CLASS_E_NOAGGREGATION, L"CLASS_E_NOAGGREGATION")


// -------------------------------------------------------------        
// ddraw.h error codes as of 12/14/00
// -------------------------------------------------------------                
        CHK_ERR(DDERR_ALREADYINITIALIZED, L"DDERR_ALREADYINITIALIZED")
        CHK_ERR(DDERR_CANNOTATTACHSURFACE, L"DDERR_CANNOTATTACHSURFACE")
        CHK_ERR(DDERR_CANNOTDETACHSURFACE, L"DDERR_CANNOTDETACHSURFACE")
        CHK_ERR(DDERR_CURRENTLYNOTAVAIL, L"DDERR_CURRENTLYNOTAVAIL")
        CHK_ERR(DDERR_EXCEPTION, L"DDERR_EXCEPTION")
//      CHK_ERR(DDERR_GENERIC, L"DDERR_GENERIC")
        CHK_ERR(DDERR_HEIGHTALIGN, L"DDERR_HEIGHTALIGN")
        CHK_ERR(DDERR_INCOMPATIBLEPRIMARY, L"DDERR_INCOMPATIBLEPRIMARY")
        CHK_ERR(DDERR_INVALIDCAPS, L"DDERR_INVALIDCAPS")
        CHK_ERR(DDERR_INVALIDCLIPLIST, L"DDERR_INVALIDCLIPLIST")
        CHK_ERR(DDERR_INVALIDMODE, L"DDERR_INVALIDMODE")
        CHK_ERR(DDERR_INVALIDOBJECT, L"DDERR_INVALIDOBJECT")
//        CHK_ERR(DDERR_INVALIDPARAMS, L"DDERR_INVALIDPARAMS")
        CHK_ERR(DDERR_INVALIDPIXELFORMAT, L"DDERR_INVALIDPIXELFORMAT")
        CHK_ERR(DDERR_INVALIDRECT, L"DDERR_INVALIDRECT")
        CHK_ERR(DDERR_LOCKEDSURFACES, L"DDERR_LOCKEDSURFACES")
        CHK_ERR(DDERR_NO3D, L"DDERR_NO3D")
        CHK_ERR(DDERR_NOALPHAHW, L"DDERR_NOALPHAHW")
        CHK_ERR(DDERR_NOSTEREOHARDWARE, L"DDERR_NOSTEREOHARDWARE")
        CHK_ERR(DDERR_NOSURFACELEFT, L"DDERR_NOSURFACELEFT")
        CHK_ERR(DDERR_NOCLIPLIST, L"DDERR_NOCLIPLIST")
        CHK_ERR(DDERR_NOCOLORCONVHW, L"DDERR_NOCOLORCONVHW")
        CHK_ERR(DDERR_NOCOOPERATIVELEVELSET, L"DDERR_NOCOOPERATIVELEVELSET")
        CHK_ERR(DDERR_NOCOLORKEY, L"DDERR_NOCOLORKEY")
        CHK_ERR(DDERR_NOCOLORKEYHW, L"DDERR_NOCOLORKEYHW")
        CHK_ERR(DDERR_NODIRECTDRAWSUPPORT, L"DDERR_NODIRECTDRAWSUPPORT")
        CHK_ERR(DDERR_NOEXCLUSIVEMODE, L"DDERR_NOEXCLUSIVEMODE")
        CHK_ERR(DDERR_NOFLIPHW, L"DDERR_NOFLIPHW")
        CHK_ERR(DDERR_NOGDI, L"DDERR_NOGDI")
        CHK_ERR(DDERR_NOMIRRORHW, L"DDERR_NOMIRRORHW")
        CHK_ERR(DDERR_NOTFOUND, L"DDERR_NOTFOUND")
        CHK_ERR(DDERR_NOOVERLAYHW, L"DDERR_NOOVERLAYHW")
        CHK_ERR(DDERR_OVERLAPPINGRECTS, L"DDERR_OVERLAPPINGRECTS")
        CHK_ERR(DDERR_NORASTEROPHW, L"DDERR_NORASTEROPHW")
        CHK_ERR(DDERR_NOROTATIONHW, L"DDERR_NOROTATIONHW")
        CHK_ERR(DDERR_NOSTRETCHHW, L"DDERR_NOSTRETCHHW")
        CHK_ERR(DDERR_NOT4BITCOLOR, L"DDERR_NOT4BITCOLOR")
        CHK_ERR(DDERR_NOT4BITCOLORINDEX, L"DDERR_NOT4BITCOLORINDEX")
        CHK_ERR(DDERR_NOT8BITCOLOR, L"DDERR_NOT8BITCOLOR")
        CHK_ERR(DDERR_NOTEXTUREHW, L"DDERR_NOTEXTUREHW")
        CHK_ERR(DDERR_NOVSYNCHW, L"DDERR_NOVSYNCHW")
        CHK_ERR(DDERR_NOZBUFFERHW, L"DDERR_NOZBUFFERHW")
        CHK_ERR(DDERR_NOZOVERLAYHW, L"DDERR_NOZOVERLAYHW")
        CHK_ERR(DDERR_OUTOFCAPS, L"DDERR_OUTOFCAPS")
//        CHK_ERR(DDERR_OUTOFMEMORY, L"DDERR_OUTOFMEMORY")
//        CHK_ERR(DDERR_OUTOFVIDEOMEMORY, L"DDERR_OUTOFVIDEOMEMORY")
        CHK_ERR(DDERR_OVERLAYCANTCLIP, L"DDERR_OVERLAYCANTCLIP")
        CHK_ERR(DDERR_OVERLAYCOLORKEYONLYONEACTIVE, L"DDERR_OVERLAYCOLORKEYONLYONEACTIVE")
        CHK_ERR(DDERR_PALETTEBUSY, L"DDERR_PALETTEBUSY")
        CHK_ERR(DDERR_COLORKEYNOTSET, L"DDERR_COLORKEYNOTSET")
        CHK_ERR(DDERR_SURFACEALREADYATTACHED, L"DDERR_SURFACEALREADYATTACHED")
        CHK_ERR(DDERR_SURFACEALREADYDEPENDENT, L"DDERR_SURFACEALREADYDEPENDENT")
        CHK_ERR(DDERR_SURFACEBUSY, L"DDERR_SURFACEBUSY")
        CHK_ERR(DDERR_CANTLOCKSURFACE, L"DDERR_CANTLOCKSURFACE")
        CHK_ERR(DDERR_SURFACEISOBSCURED, L"DDERR_SURFACEISOBSCURED")
        CHK_ERR(DDERR_SURFACELOST, L"DDERR_SURFACELOST")
        CHK_ERR(DDERR_SURFACENOTATTACHED, L"DDERR_SURFACENOTATTACHED")
        CHK_ERR(DDERR_TOOBIGHEIGHT, L"DDERR_TOOBIGHEIGHT")
        CHK_ERR(DDERR_TOOBIGSIZE, L"DDERR_TOOBIGSIZE")
        CHK_ERR(DDERR_TOOBIGWIDTH, L"DDERR_TOOBIGWIDTH")
//        CHK_ERR(DDERR_UNSUPPORTED, L"DDERR_UNSUPPORTED")
        CHK_ERR(DDERR_UNSUPPORTEDFORMAT, L"DDERR_UNSUPPORTEDFORMAT")
        CHK_ERR(DDERR_UNSUPPORTEDMASK, L"DDERR_UNSUPPORTEDMASK")
        CHK_ERR(DDERR_INVALIDSTREAM, L"DDERR_INVALIDSTREAM")
        CHK_ERR(DDERR_VERTICALBLANKINPROGRESS, L"DDERR_VERTICALBLANKINPROGRESS")
        CHK_ERR(DDERR_WASSTILLDRAWING, L"DDERR_WASSTILLDRAWING")
        CHK_ERR(DDERR_DDSCAPSCOMPLEXREQUIRED, L"DDERR_DDSCAPSCOMPLEXREQUIRED")
        CHK_ERR(DDERR_XALIGN, L"DDERR_XALIGN")
        CHK_ERR(DDERR_INVALIDDIRECTDRAWGUID, L"DDERR_INVALIDDIRECTDRAWGUID")
        CHK_ERR(DDERR_DIRECTDRAWALREADYCREATED, L"DDERR_DIRECTDRAWALREADYCREATED")
        CHK_ERR(DDERR_NODIRECTDRAWHW, L"DDERR_NODIRECTDRAWHW")
        CHK_ERR(DDERR_PRIMARYSURFACEALREADYEXISTS, L"DDERR_PRIMARYSURFACEALREADYEXISTS")
        CHK_ERR(DDERR_NOEMULATION, L"DDERR_NOEMULATION")
        CHK_ERR(DDERR_REGIONTOOSMALL, L"DDERR_REGIONTOOSMALL")
        CHK_ERR(DDERR_CLIPPERISUSINGHWND, L"DDERR_CLIPPERISUSINGHWND")
        CHK_ERR(DDERR_NOCLIPPERATTACHED, L"DDERR_NOCLIPPERATTACHED")
        CHK_ERR(DDERR_NOHWND, L"DDERR_NOHWND")
        CHK_ERR(DDERR_HWNDSUBCLASSED, L"DDERR_HWNDSUBCLASSED")
        CHK_ERR(DDERR_HWNDALREADYSET, L"DDERR_HWNDALREADYSET")
        CHK_ERR(DDERR_NOPALETTEATTACHED, L"DDERR_NOPALETTEATTACHED")
        CHK_ERR(DDERR_NOPALETTEHW, L"DDERR_NOPALETTEHW")
        CHK_ERR(DDERR_BLTFASTCANTCLIP, L"DDERR_BLTFASTCANTCLIP")
        CHK_ERR(DDERR_NOBLTHW, L"DDERR_NOBLTHW")
        CHK_ERR(DDERR_NODDROPSHW, L"DDERR_NODDROPSHW")
        CHK_ERR(DDERR_OVERLAYNOTVISIBLE, L"DDERR_OVERLAYNOTVISIBLE")
        CHK_ERR(DDERR_NOOVERLAYDEST, L"DDERR_NOOVERLAYDEST")
        CHK_ERR(DDERR_INVALIDPOSITION, L"DDERR_INVALIDPOSITION")
        CHK_ERR(DDERR_NOTAOVERLAYSURFACE, L"DDERR_NOTAOVERLAYSURFACE")
        CHK_ERR(DDERR_EXCLUSIVEMODEALREADYSET, L"DDERR_EXCLUSIVEMODEALREADYSET")
        CHK_ERR(DDERR_NOTFLIPPABLE, L"DDERR_NOTFLIPPABLE")
        CHK_ERR(DDERR_CANTDUPLICATE, L"DDERR_CANTDUPLICATE")
        CHK_ERR(DDERR_NOTLOCKED, L"DDERR_NOTLOCKED")
        CHK_ERR(DDERR_CANTCREATEDC, L"DDERR_CANTCREATEDC")
        CHK_ERR(DDERR_NODC, L"DDERR_NODC")
        CHK_ERR(DDERR_WRONGMODE, L"DDERR_WRONGMODE")
        CHK_ERR(DDERR_IMPLICITLYCREATED, L"DDERR_IMPLICITLYCREATED")
        CHK_ERR(DDERR_NOTPALETTIZED, L"DDERR_NOTPALETTIZED")
        CHK_ERR(DDERR_UNSUPPORTEDMODE, L"DDERR_UNSUPPORTEDMODE")
        CHK_ERR(DDERR_NOMIPMAPHW, L"DDERR_NOMIPMAPHW")
        CHK_ERR(DDERR_INVALIDSURFACETYPE, L"DDERR_INVALIDSURFACETYPE")
        CHK_ERR(DDERR_NOOPTIMIZEHW, L"DDERR_NOOPTIMIZEHW")
        CHK_ERR(DDERR_NOTLOADED, L"DDERR_NOTLOADED")
        CHK_ERR(DDERR_NOFOCUSWINDOW, L"DDERR_NOFOCUSWINDOW")
        CHK_ERR(DDERR_NOTONMIPMAPSUBLEVEL, L"DDERR_NOTONMIPMAPSUBLEVEL")
        CHK_ERR(DDERR_DCALREADYCREATED, L"DDERR_DCALREADYCREATED")
        CHK_ERR(DDERR_NONONLOCALVIDMEM, L"DDERR_NONONLOCALVIDMEM")
        CHK_ERR(DDERR_CANTPAGELOCK, L"DDERR_CANTPAGELOCK")
        CHK_ERR(DDERR_CANTPAGEUNLOCK, L"DDERR_CANTPAGEUNLOCK")
        CHK_ERR(DDERR_NOTPAGELOCKED, L"DDERR_NOTPAGELOCKED")
        CHK_ERR(DDERR_MOREDATA, L"DDERR_MOREDATA")
        CHK_ERR(DDERR_EXPIRED, L"DDERR_EXPIRED")
        CHK_ERR(DDERR_TESTFINISHED, L"DDERR_TESTFINISHED")
        CHK_ERR(DDERR_NEWMODE, L"DDERR_NEWMODE")
        CHK_ERR(DDERR_D3DNOTINITIALIZED, L"DDERR_D3DNOTINITIALIZED")
        CHK_ERR(DDERR_VIDEONOTACTIVE, L"DDERR_VIDEONOTACTIVE")
        CHK_ERR(DDERR_NOMONITORINFORMATION, L"DDERR_NOMONITORINFORMATION")
        CHK_ERR(DDERR_NODRIVERSUPPORT, L"DDERR_NODRIVERSUPPORT")
        CHK_ERR(DDERR_DEVICEDOESNTOWNSURFACE, L"DDERR_DEVICEDOESNTOWNSURFACE")

// -------------------------------------------------------------        
// dinput.h error codes as of 10/4/00
// -------------------------------------------------------------        
//      CHK_ERR(DI_OK, L"DI_OK")
//      CHK_ERR(DI_NOTATTACHED, L"DI_NOTATTACHED")
//      CHK_ERR(DI_BUFFEROVERFLOW, L"DI_BUFFEROVERFLOW")
//      CHK_ERR(DI_PROPNOEFFECT, L"DI_PROPNOEFFECT")
//      CHK_ERR(DI_NOEFFECT, L"DI_NOEFFECT")
//      CHK_ERR(DI_POLLEDDEVICE, L"DI_POLLEDDEVICE")
//      CHK_ERR(DI_DOWNLOADSKIPPED, L"DI_DOWNLOADSKIPPED")
//      CHK_ERR(DI_EFFECTRESTARTED, L"DI_EFFECTRESTARTED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_ACCESSDENIED, L"DI_SETTINGSNOTSAVED_ACCESSDENIED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_DISKFULL, L"DI_SETTINGSNOTSAVED_DISKFULL")
//      CHK_ERR(DI_TRUNCATED, L"DI_TRUNCATED")
//      CHK_ERR(DI_TRUNCATEDANDRESTARTED, L"DI_TRUNCATEDANDRESTARTED")
//      CHK_ERR(DI_WRITEPROTECT, L"DI_WRITEPROTECT")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, L"DIERR_OLDDIRECTINPUTVERSION")
//      CHK_ERR(DIERR_GENERIC, L"DIERR_GENERIC")
//      CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, L"DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, L"DIERR_BETADIRECTINPUTVERSION")
        CHK_ERR(DIERR_BADDRIVERVER, L"DIERR_BADDRIVERVER")
//      CHK_ERR(DIERR_DEVICENOTREG, L"DIERR_DEVICENOTREG")   
        CHK_ERR(DIERR_NOTFOUND, L"DIERR_NOTFOUND")                
//      CHK_ERR(DIERR_OBJECTNOTFOUND, L"DIERR_OBJECTNOTFOUND")
//      CHK_ERR(DIERR_INVALIDPARAM, L"DIERR_INVALIDPARAM")         
//      CHK_ERR(DIERR_NOINTERFACE, L"DIERR_NOINTERFACE")         
//      CHK_ERR(DIERR_GENERIC, L"DIERR_GENERIC")         
//      CHK_ERR(DIERR_OUTOFMEMORY, L"DIERR_OUTOFMEMORY")         
//      CHK_ERR(DIERR_UNSUPPORTED, L"DIERR_UNSUPPORTED")         
        CHK_ERR(DIERR_NOTINITIALIZED, L"DIERR_NOTINITIALIZED")
        CHK_ERR(DIERR_ALREADYINITIALIZED, L"DIERR_ALREADYINITIALIZED")
//      CHK_ERR(DIERR_NOAGGREGATION, L"DIERR_NOAGGREGATION")
//      CHK_ERR(DIERR_OTHERAPPHASPRIO, L"DIERR_OTHERAPPHASPRIO")         
        CHK_ERR(DIERR_INPUTLOST, L"DIERR_INPUTLOST")
        CHK_ERR(DIERR_ACQUIRED, L"DIERR_ACQUIRED")
        CHK_ERR(DIERR_NOTACQUIRED, L"DIERR_NOTACQUIRED")
//      CHK_ERR(DIERR_READONLY, L"DIERR_READONLY")
//      CHK_ERR(DIERR_HANDLEEXISTS, L"DIERR_HANDLEEXISTS")         
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, L"DIERR_INSUFFICIENTPRIVS & VFW_E_INVALIDMEDIATYPE")        
        CHK_ERR(DIERR_DEVICEFULL, L"DIERR_DEVICEFULL & VFW_E_INVALIDSUBTYPE & DMO_E_INVALIDSTREAMINDEX")
        CHK_ERR(DIERR_MOREDATA, L"DIERR_MOREDATA & VFW_E_NEED_OWNER & DMO_E_INVALIDTYPE")
        CHK_ERR(DIERR_NOTDOWNLOADED, L"DIERR_NOTDOWNLOADED & VFW_E_ENUM_OUT_OF_SYNC & DMO_E_TYPE_NOT_SET")
        CHK_ERR(DIERR_HASEFFECTS, L"DIERR_HASEFFECTS & VFW_E_ALREADY_CONNECTED & DMO_E_NOTACCEPTING")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, L"DIERR_NOTEXCLUSIVEACQUIRED & VFW_E_FILTER_ACTIVE & DMO_E_TYPE_NOT_ACCEPTED")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, L"DIERR_INCOMPLETEEFFECT & VFW_E_NO_TYPES & DMO_E_NO_MORE_ITEMS")
        CHK_ERR(DIERR_NOTBUFFERED, L"DIERR_NOTBUFFERED & VFW_E_NO_ACCEPTABLE_TYPES")
        CHK_ERR(DIERR_EFFECTPLAYING, L"DIERR_EFFECTPLAYING & VFW_E_INVALID_DIRECTION")
        CHK_ERR(DIERR_UNPLUGGED, L"DIERR_UNPLUGGED & VFW_E_NOT_CONNECTED")
        CHK_ERR(DIERR_REPORTFULL, L"DIERR_REPORTFULL & VFW_E_NO_ALLOCATOR")
        CHK_ERR(DIERR_MAPFILEFAIL, L"DIERR_MAPFILEFAIL & VFW_E_RUNTIME_ERROR")


// -------------------------------------------------------------        
// dinputd.h error codes as of 9/8/00
// -------------------------------------------------------------                
        CHK_ERR(DIERR_NOMOREITEMS, L"DIERR_NOMOREITEMS")        
        CHK_ERR(DIERR_DRIVERFIRST, L"DIERR_DRIVERFIRST")
        CHK_ERR(DIERR_DRIVERFIRST+1, L"DIERR_DRIVERFIRST+1")
        CHK_ERR(DIERR_DRIVERFIRST+2, L"DIERR_DRIVERFIRST+2")
        CHK_ERR(DIERR_DRIVERFIRST+3, L"DIERR_DRIVERFIRST+3")
        CHK_ERR(DIERR_DRIVERFIRST+4, L"DIERR_DRIVERFIRST+4")
        CHK_ERR(DIERR_DRIVERFIRST+5, L"DIERR_DRIVERFIRST+5")
        CHK_ERR(DIERR_DRIVERLAST, L"DIERR_DRIVERLAST")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, L"DIERR_INVALIDCLASSINSTALLER")
        CHK_ERR(DIERR_CANCELLED, L"DIERR_CANCELLED")
        CHK_ERR(DIERR_BADINF, L"DIERR_BADINF")
        
        
// -------------------------------------------------------------        
// dvoice.h error codes as of 9/8/00
// -------------------------------------------------------------                        
//      CHK_ERR(DV_OK, L"DV_OK")
        CHK_ERR(DV_FULLDUPLEX, L"DV_FULLDUPLEX")
        CHK_ERR(DV_HALFDUPLEX, L"DV_HALFDUPLEX")
        CHK_ERR(DV_PENDING, L"DV_PENDING")
        CHK_ERR(DVERR_BUFFERTOOSMALL, L"DVERR_BUFFERTOOSMALL")
        CHK_ERR(DVERR_EXCEPTION, L"DVERR_EXCEPTION")
//      CHK_ERR(DVERR_GENERIC, L"DVERR_GENERIC")
        CHK_ERR(DVERR_INVALIDFLAGS, L"DVERR_INVALIDFLAGS")
        CHK_ERR(DVERR_INVALIDOBJECT, L"DVERR_INVALIDOBJECT")
        CHK_ERR(DVERR_INVALIDPLAYER, L"DVERR_INVALIDPLAYER")
        CHK_ERR(DVERR_INVALIDGROUP, L"DVERR_INVALIDGROUP")
        CHK_ERR(DVERR_INVALIDHANDLE, L"DVERR_INVALIDHANDLE")
//      CHK_ERR(DVERR_OUTOFMEMORY, L"DVERR_OUTOFMEMORY")
//      CHK_ERR(DVERR_PENDING, L"DVERR_PENDING")
//      CHK_ERR(DVERR_NOTSUPPORTED, L"DVERR_NOTSUPPORTED")
//      CHK_ERR(DVERR_NOINTERFACE, L"DVERR_NOINTERFACE")
        CHK_ERR(DVERR_SESSIONLOST, L"DVERR_SESSIONLOST")
        CHK_ERR(DVERR_NOVOICESESSION, L"DVERR_NOVOICESESSION")
        CHK_ERR(DVERR_CONNECTIONLOST, L"DVERR_CONNECTIONLOST")
        CHK_ERR(DVERR_NOTINITIALIZED, L"DVERR_NOTINITIALIZED")
        CHK_ERR(DVERR_CONNECTED, L"DVERR_CONNECTED")
        CHK_ERR(DVERR_NOTCONNECTED, L"DVERR_NOTCONNECTED")
        CHK_ERR(DVERR_CONNECTABORTING, L"DVERR_CONNECTABORTING")
        CHK_ERR(DVERR_NOTALLOWED, L"DVERR_NOTALLOWED")
        CHK_ERR(DVERR_INVALIDTARGET, L"DVERR_INVALIDTARGET")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, L"DVERR_TRANSPORTNOTHOST")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, L"DVERR_COMPRESSIONNOTSUPPORTED")
        CHK_ERR(DVERR_ALREADYPENDING, L"DVERR_ALREADYPENDING")
        CHK_ERR(DVERR_SOUNDINITFAILURE, L"DVERR_SOUNDINITFAILURE")
        CHK_ERR(DVERR_TIMEOUT, L"DVERR_TIMEOUT")
        CHK_ERR(DVERR_CONNECTABORTED, L"DVERR_CONNECTABORTED")
        CHK_ERR(DVERR_NO3DSOUND, L"DVERR_NO3DSOUND")
        CHK_ERR(DVERR_ALREADYBUFFERED, L"DVERR_ALREADYBUFFERED")
        CHK_ERR(DVERR_NOTBUFFERED, L"DVERR_NOTBUFFERED")
        CHK_ERR(DVERR_HOSTING, L"DVERR_HOSTING")
        CHK_ERR(DVERR_NOTHOSTING, L"DVERR_NOTHOSTING")
        CHK_ERR(DVERR_INVALIDDEVICE, L"DVERR_INVALIDDEVICE")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, L"DVERR_RECORDSYSTEMERROR")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, L"DVERR_PLAYBACKSYSTEMERROR")
        CHK_ERR(DVERR_SENDERROR, L"DVERR_SENDERROR")
        CHK_ERR(DVERR_USERCANCEL, L"DVERR_USERCANCEL")
        CHK_ERR(DVERR_RUNSETUP, L"DVERR_RUNSETUP")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, L"DVERR_INCOMPATIBLEVERSION")
        CHK_ERR(DVERR_INITIALIZED, L"DVERR_INITIALIZED")
//      CHK_ERR(DVERR_INVALIDPOINTER, L"DVERR_INVALIDPOINTER")
        CHK_ERR(DVERR_NOTRANSPORT, L"DVERR_NOTRANSPORT")
        CHK_ERR(DVERR_NOCALLBACK, L"DVERR_NOCALLBACK")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, L"DVERR_TRANSPORTNOTINIT")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, L"DVERR_TRANSPORTNOSESSION")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, L"DVERR_TRANSPORTNOPLAYER")
        CHK_ERR(DVERR_USERBACK, L"DVERR_USERBACK")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, L"DVERR_NORECVOLAVAILABLE")
        CHK_ERR(DVERR_INVALIDBUFFER, L"DVERR_INVALIDBUFFER")
        CHK_ERR(DVERR_LOCKEDBUFFER, L"DVERR_LOCKEDBUFFER")
        
              
// -------------------------------------------------------------        
// dplay8.h error codes as of 10/4/00
// -------------------------------------------------------------                        
        CHK_ERR(DPNERR_ABORTED, L"DPNERR_ABORTED")
        CHK_ERR(DPNERR_ADDRESSING, L"DPNERR_ADDRESSING")
        CHK_ERR(DPNERR_ALREADYCLOSING, L"DPNERR_ALREADYCLOSING")        
        CHK_ERR(DPNERR_ALREADYCONNECTED, L"DPNERR_ALREADYCONNECTED")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, L"DPNERR_ALREADYDISCONNECTING")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, L"DPNERR_ALREADYINITIALIZED")
        CHK_ERR(DPNERR_ALREADYREGISTERED, L"DPNERR_ALREADYREGISTERED")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, L"DPNERR_BUFFERTOOSMALL")
        CHK_ERR(DPNERR_CANNOTCANCEL, L"DPNERR_CANNOTCANCEL")
        CHK_ERR(DPNERR_CANTCREATEGROUP, L"DPNERR_CANTCREATEGROUP")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, L"DPNERR_CANTCREATEPLAYER")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, L"DPNERR_CANTLAUNCHAPPLICATION")
        CHK_ERR(DPNERR_CONNECTING, L"DPNERR_CONNECTING")
        CHK_ERR(DPNERR_CONNECTIONLOST, L"DPNERR_CONNECTIONLOST")
        CHK_ERR(DPNERR_CONVERSION, L"DPNERR_CONVERSION")
        CHK_ERR(DPNERR_DATATOOLARGE, L"DPNERR_DATATOOLARGE")
        CHK_ERR(DPNERR_DOESNOTEXIST, L"DPNERR_DOESNOTEXIST")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, L"DPNERR_DUPLICATECOMMAND")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, L"DPNERR_ENDPOINTNOTRECEIVING")
        CHK_ERR(DPNERR_ENUMQUERYTOOLARGE, L"DPNERR_ENUMQUERYTOOLARGE")
        CHK_ERR(DPNERR_ENUMRESPONSETOOLARGE, L"DPNERR_ENUMRESPONSETOOLARGE")
        CHK_ERR(DPNERR_EXCEPTION, L"DPNERR_EXCEPTION")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, L"DPNERR_GROUPNOTEMPTY")
        CHK_ERR(DPNERR_HOSTING, L"DPNERR_HOSTING")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, L"DPNERR_HOSTREJECTEDCONNECTION")
        CHK_ERR(DPNERR_HOSTTERMINATEDSESSION, L"DPNERR_HOSTTERMINATEDSESSION")        
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, L"DPNERR_INCOMPLETEADDRESS")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, L"DPNERR_INVALIDADDRESSFORMAT")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, L"DPNERR_INVALIDAPPLICATION")
        CHK_ERR(DPNERR_INVALIDCOMMAND, L"DPNERR_INVALIDCOMMAND")
        CHK_ERR(DPNERR_INVALIDENDPOINT, L"DPNERR_INVALIDENDPOINT")
        CHK_ERR(DPNERR_INVALIDFLAGS, L"DPNERR_INVALIDFLAGS")
        CHK_ERR(DPNERR_INVALIDGROUP, L"DPNERR_INVALIDGROUP")
        CHK_ERR(DPNERR_INVALIDHANDLE, L"DPNERR_INVALIDHANDLE")
        CHK_ERR(DPNERR_INVALIDINSTANCE, L"DPNERR_INVALIDINSTANCE")
        CHK_ERR(DPNERR_INVALIDINTERFACE, L"DPNERR_INVALIDINTERFACE")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, L"DPNERR_INVALIDDEVICEADDRESS")
        CHK_ERR(DPNERR_INVALIDOBJECT, L"DPNERR_INVALIDOBJECT")
//      CHK_ERR(DPNERR_INVALIDPARAM, L"DPNERR_INVALIDPARAM")        
        CHK_ERR(DPNERR_INVALIDPASSWORD, L"DPNERR_INVALIDPASSWORD")
        CHK_ERR(DPNERR_INVALIDPLAYER, L"DPNERR_INVALIDPLAYER")
//      CHK_ERR(DPNERR_INVALIDPOINTER, L"DPNERR_INVALIDPOINTER")        
        CHK_ERR(DPNERR_INVALIDPRIORITY, L"DPNERR_INVALIDPRIORITY")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, L"DPNERR_INVALIDHOSTADDRESS")
        CHK_ERR(DPNERR_INVALIDSTRING, L"DPNERR_INVALIDSTRING")
        CHK_ERR(DPNERR_INVALIDURL, L"DPNERR_INVALIDURL")
        CHK_ERR(DPNERR_INVALIDVERSION, L"DPNERR_INVALIDVERSION")
        CHK_ERR(DPNERR_NOCAPS, L"DPNERR_NOCAPS")
        CHK_ERR(DPNERR_NOCONNECTION, L"DPNERR_NOCONNECTION")
        CHK_ERR(DPNERR_NOHOSTPLAYER, L"DPNERR_NOHOSTPLAYER")
//      CHK_ERR(DPNERR_NOINTERFACE, L"DPNERR_NOINTERFACE")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, L"DPNERR_NOMOREADDRESSCOMPONENTS")
        CHK_ERR(DPNERR_NORESPONSE, L"DPNERR_NORESPONSE")
        CHK_ERR(DPNERR_NOTALLOWED, L"DPNERR_NOTALLOWED")
        CHK_ERR(DPNERR_NOTHOST, L"DPNERR_NOTHOST")
        CHK_ERR(DPNERR_NOTREADY, L"DPNERR_NOTREADY")
        CHK_ERR(DPNERR_NOTREGISTERED, L"DPNERR_NOTREGISTERED")
//      CHK_ERR(DPNERR_OUTOFMEMORY, L"DPNERR_OUTOFMEMORY")
//      CHK_ERR(DPNERR_PENDING, L"DPNERR_PENDING")
        CHK_ERR(DPNERR_PLAYERLOST, L"DPNERR_PLAYERLOST")
        CHK_ERR(DPNERR_PLAYERNOTREACHABLE, L"DPNERR_PLAYERNOTREACHABLE")
        CHK_ERR(DPNERR_SENDTOOLARGE, L"DPNERR_SENDTOOLARGE")
        CHK_ERR(DPNERR_SESSIONFULL, L"DPNERR_SESSIONFULL")
        CHK_ERR(DPNERR_TABLEFULL, L"DPNERR_TABLEFULL")
        CHK_ERR(DPNERR_TIMEDOUT, L"DPNERR_TIMEDOUT")
        CHK_ERR(DPNERR_UNINITIALIZED, L"DPNERR_UNINITIALIZED")
//      CHK_ERR(DPNERR_UNSUPPORTED, L"DPNERR_UNSUPPORTED")
        CHK_ERR(DPNERR_USERCANCEL, L"DPNERR_USERCANCEL")
        
              
// -------------------------------------------------------------        
// dxfile.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(DXFILE_OK, L"DXFILE_OK")
        CHK_ERR(DXFILEERR_BADOBJECT, L"DXFILEERR_BADOBJECT")
        CHK_ERR(DXFILEERR_BADVALUE, L"DXFILEERR_BADVALUE")
        CHK_ERR(DXFILEERR_BADTYPE, L"DXFILEERR_BADTYPE")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, L"DXFILEERR_BADSTREAMHANDLE")
        CHK_ERR(DXFILEERR_BADALLOC, L"DXFILEERR_BADALLOC")
        CHK_ERR(DXFILEERR_NOTFOUND, L"DXFILEERR_NOTFOUND")
        CHK_ERR(DXFILEERR_NOTDONEYET, L"DXFILEERR_NOTDONEYET")
        CHK_ERR(DXFILEERR_FILENOTFOUND, L"DXFILEERR_FILENOTFOUND")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, L"DXFILEERR_RESOURCENOTFOUND")
        CHK_ERR(DXFILEERR_URLNOTFOUND, L"DXFILEERR_URLNOTFOUND")
        CHK_ERR(DXFILEERR_BADRESOURCE, L"DXFILEERR_BADRESOURCE")
        CHK_ERR(DXFILEERR_BADFILETYPE, L"DXFILEERR_BADFILETYPE")
        CHK_ERR(DXFILEERR_BADFILEVERSION, L"DXFILEERR_BADFILEVERSION")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, L"DXFILEERR_BADFILEFLOATSIZE")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, L"DXFILEERR_BADFILECOMPRESSIONTYPE")
        CHK_ERR(DXFILEERR_BADFILE, L"DXFILEERR_BADFILE")
        CHK_ERR(DXFILEERR_PARSEERROR, L"DXFILEERR_PARSEERROR")
        CHK_ERR(DXFILEERR_NOTEMPLATE, L"DXFILEERR_NOTEMPLATE")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, L"DXFILEERR_BADARRAYSIZE")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, L"DXFILEERR_BADDATAREFERENCE")
        CHK_ERR(DXFILEERR_INTERNALERROR, L"DXFILEERR_INTERNALERROR")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, L"DXFILEERR_NOMOREOBJECTS")
        CHK_ERR(DXFILEERR_BADINTRINSICS, L"DXFILEERR_BADINTRINSICS")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, L"DXFILEERR_NOMORESTREAMHANDLES")
        CHK_ERR(DXFILEERR_NOMOREDATA, L"DXFILEERR_NOMOREDATA")
        CHK_ERR(DXFILEERR_BADCACHEFILE, L"DXFILEERR_BADCACHEFILE")
        CHK_ERR(DXFILEERR_NOINTERNET, L"DXFILEERR_NOINTERNET")
        
        
// -------------------------------------------------------------        
// d3d8.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(D3D_OK, L"D3D_OK")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, L"D3DERR_WRONGTEXTUREFORMAT")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, L"D3DERR_UNSUPPORTEDCOLOROPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, L"D3DERR_UNSUPPORTEDCOLORARG")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, L"D3DERR_UNSUPPORTEDALPHAOPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, L"D3DERR_UNSUPPORTEDALPHAARG")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, L"D3DERR_TOOMANYOPERATIONS")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, L"D3DERR_CONFLICTINGTEXTUREFILTER")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, L"D3DERR_UNSUPPORTEDFACTORVALUE")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, L"D3DERR_CONFLICTINGRENDERSTATE")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, L"D3DERR_UNSUPPORTEDTEXTUREFILTER")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, L"D3DERR_CONFLICTINGTEXTUREPALETTE")                
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, L"D3DERR_DRIVERINTERNALERROR")
        CHK_ERR(D3DERR_NOTFOUND, L"D3DERR_NOTFOUND")
        CHK_ERR(D3DERR_MOREDATA, L"D3DERR_MOREDATA")
        CHK_ERR(D3DERR_DEVICELOST, L"D3DERR_DEVICELOST")
        CHK_ERR(D3DERR_DEVICENOTRESET, L"D3DERR_DEVICENOTRESET")
        CHK_ERR(D3DERR_NOTAVAILABLE, L"D3DERR_NOTAVAILABLE")
        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, L"D3DERR_OUTOFVIDEOMEMORY")
        CHK_ERR(D3DERR_INVALIDDEVICE, L"D3DERR_INVALIDDEVICE")
        CHK_ERR(D3DERR_INVALIDCALL, L"D3DERR_INVALIDCALL")
        CHK_ERR(D3DERR_DRIVERINVALIDCALL, L"D3DERR_DRIVERINVALIDCALL")                        
        
        
// -------------------------------------------------------------        
// d3dx8mesh.h error codes as of 12/5/00
// -------------------------------------------------------------                                
        CHK_ERR(D3DXERR_CANNOTMODIFYINDEXBUFFER, L"D3DXERR_CANNOTMODIFYINDEXBUFFER")                        
        CHK_ERR(D3DXERR_INVALIDMESH, L"D3DXERR_INVALIDMESH")                        
        CHK_ERR(D3DXERR_CANNOTATTRSORT, L"D3DXERR_CANNOTATTRSORT")                        
        CHK_ERR(D3DXERR_SKINNINGNOTSUPPORTED, L"D3DXERR_SKINNINGNOTSUPPORTED")                        
        CHK_ERR(D3DXERR_TOOMANYINFLUENCES, L"D3DXERR_TOOMANYINFLUENCES")                        
        CHK_ERR(D3DXERR_INVALIDDATA, L"D3DXERR_INVALIDDATA")                        

   
// -------------------------------------------------------------        
// dsound.h error codes as of 9/8/00
// -------------------------------------------------------------        
//      CHK_ERR(DS_OK, L"DS_OK")        
        CHK_ERR(DS_NO_VIRTUALIZATION, L"DS_NO_VIRTUALIZATION")           
        CHK_ERR(DS_INCOMPLETE, L"DS_INCOMPLETE")             
        CHK_ERR(DSERR_ALLOCATED, L"DSERR_ALLOCATED")
        CHK_ERR(DSERR_CONTROLUNAVAIL, L"DSERR_CONTROLUNAVAIL")
//      CHK_ERR(DSERR_INVALIDPARAM, L"DSERR_INVALIDPARAM")                
        CHK_ERR(DSERR_INVALIDCALL, L"DSERR_INVALIDCALL")
//      CHK_ERR(DSERR_GENERIC, L"DSERR_GENERIC")                
        CHK_ERR(DSERR_PRIOLEVELNEEDED, L"DSERR_PRIOLEVELNEEDED")
//      CHK_ERR(DSERR_OUTOFMEMORY, L"DSERR_OUTOFMEMORY")                
        CHK_ERR(DSERR_BADFORMAT, L"DSERR_BADFORMAT")
//      CHK_ERR(DSERR_UNSUPPORTED, L"DSERR_UNSUPPORTED")                
        CHK_ERR(DSERR_NODRIVER, L"DSERR_NODRIVER")
        CHK_ERR(DSERR_ALREADYINITIALIZED, L"DSERR_ALREADYINITIALIZED")
//      CHK_ERR(DSERR_NOAGGREGATION, L"DSERR_NOAGGREGATION")                
        CHK_ERR(DSERR_BUFFERLOST, L"DSERR_BUFFERLOST")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, L"DSERR_OTHERAPPHASPRIO")
        CHK_ERR(DSERR_UNINITIALIZED, L"DSERR_UNINITIALIZED")
//      CHK_ERR(DSERR_NOINTERFACE, L"DSERR_NOINTERFACE")                
//      CHK_ERR(DSERR_ACCESSDENIED, L"DSERR_ACCESSDENIED")        
        CHK_ERR(DSERR_BUFFERTOOSMALL, L"DSERR_BUFFERTOOSMALL")        
        CHK_ERR(DSERR_DS8_REQUIRED, L"DSERR_DS8_REQUIRED")        
        CHK_ERR(DSERR_SENDLOOP, L"DSERR_SENDLOOP")        
        CHK_ERR(DSERR_BADSENDBUFFERGUID, L"DSERR_BADSENDBUFFERGUID")        
        CHK_ERR(DSERR_OBJECTNOTFOUND, L"DSERR_OBJECTNOTFOUND")        
   
// -------------------------------------------------------------        
// dmerror.h error codes as of 9/8/00
// -------------------------------------------------------------        
        CHK_ERR(DMUS_S_PARTIALLOAD, L"DMUS_S_PARTIALLOAD")  
        CHK_ERR(DMUS_S_PARTIALDOWNLOAD, L"DMUS_S_PARTIALDOWNLOAD")    
        CHK_ERR(DMUS_S_REQUEUE, L"DMUS_S_REQUEUE")            
        CHK_ERR(DMUS_S_FREE, L"DMUS_S_FREE")  
        CHK_ERR(DMUS_S_END, L"DMUS_S_END")                
        CHK_ERR(DMUS_S_STRING_TRUNCATED, L"DMUS_S_STRING_TRUNCATED")   
        CHK_ERR(DMUS_S_LAST_TOOL, L"DMUS_S_LAST_TOOL")          
        CHK_ERR(DMUS_S_OVER_CHORD, L"DMUS_S_OVER_CHORD")         
        CHK_ERR(DMUS_S_UP_OCTAVE, L"DMUS_S_UP_OCTAVE")          
        CHK_ERR(DMUS_S_DOWN_OCTAVE, L"DMUS_S_DOWN_OCTAVE")        
        CHK_ERR(DMUS_S_NOBUFFERCONTROL, L"DMUS_S_NOBUFFERCONTROL")    
        CHK_ERR(DMUS_S_GARBAGE_COLLECTED, L"DMUS_S_GARBAGE_COLLECTED")  
        CHK_ERR(DMUS_E_DRIVER_FAILED, L"DMUS_E_DRIVER_FAILED")
        CHK_ERR(DMUS_E_PORTS_OPEN, L"DMUS_E_PORTS_OPEN")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, L"DMUS_E_DEVICE_IN_USE")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, L"DMUS_E_INSUFFICIENTBUFFER")
        CHK_ERR(DMUS_E_BUFFERNOTSET, L"DMUS_E_BUFFERNOTSET")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, L"DMUS_E_BUFFERNOTAVAILABLE")
        CHK_ERR(DMUS_E_NOTADLSCOL, L"DMUS_E_NOTADLSCOL")
        CHK_ERR(DMUS_E_INVALIDOFFSET, L"DMUS_E_INVALIDOFFSET")
        CHK_ERR(DMUS_E_ALREADY_LOADED, L"DMUS_E_ALREADY_LOADED")
        CHK_ERR(DMUS_E_INVALIDPOS, L"DMUS_E_INVALIDPOS")
        CHK_ERR(DMUS_E_INVALIDPATCH, L"DMUS_E_INVALIDPATCH")
        CHK_ERR(DMUS_E_CANNOTSEEK, L"DMUS_E_CANNOTSEEK")
        CHK_ERR(DMUS_E_CANNOTWRITE, L"DMUS_E_CANNOTWRITE")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, L"DMUS_E_CHUNKNOTFOUND")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, L"DMUS_E_INVALID_DOWNLOADID")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, L"DMUS_E_NOT_DOWNLOADED_TO_PORT")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, L"DMUS_E_ALREADY_DOWNLOADED")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, L"DMUS_E_UNKNOWN_PROPERTY")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, L"DMUS_E_SET_UNSUPPORTED")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, L"DMUS_E_GET_UNSUPPORTED")
        CHK_ERR(DMUS_E_NOTMONO, L"DMUS_E_NOTMONO")
        CHK_ERR(DMUS_E_BADARTICULATION, L"DMUS_E_BADARTICULATION")
        CHK_ERR(DMUS_E_BADINSTRUMENT, L"DMUS_E_BADINSTRUMENT")
        CHK_ERR(DMUS_E_BADWAVELINK, L"DMUS_E_BADWAVELINK")
        CHK_ERR(DMUS_E_NOARTICULATION, L"DMUS_E_NOARTICULATION")
        CHK_ERR(DMUS_E_NOTPCM, L"DMUS_E_NOTPCM")
        CHK_ERR(DMUS_E_BADWAVE, L"DMUS_E_BADWAVE")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, L"DMUS_E_BADOFFSETTABLE")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, L"DMUS_E_UNKNOWNDOWNLOAD")
        CHK_ERR(DMUS_E_NOSYNTHSINK, L"DMUS_E_NOSYNTHSINK")
        CHK_ERR(DMUS_E_ALREADYOPEN, L"DMUS_E_ALREADYOPEN")
        CHK_ERR(DMUS_E_ALREADYCLOSED, L"DMUS_E_ALREADYCLOSED")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, L"DMUS_E_SYNTHNOTCONFIGURED")
        CHK_ERR(DMUS_E_SYNTHACTIVE, L"DMUS_E_SYNTHACTIVE")
        CHK_ERR(DMUS_E_CANNOTREAD, L"DMUS_E_CANNOTREAD")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, L"DMUS_E_DMUSIC_RELEASED")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, L"DMUS_E_BUFFER_EMPTY")
        CHK_ERR(DMUS_E_BUFFER_FULL, L"DMUS_E_BUFFER_FULL")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, L"DMUS_E_PORT_NOT_CAPTURE")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, L"DMUS_E_PORT_NOT_RENDER")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, L"DMUS_E_DSOUND_NOT_SET")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, L"DMUS_E_ALREADY_ACTIVATED")
        CHK_ERR(DMUS_E_INVALIDBUFFER, L"DMUS_E_INVALIDBUFFER")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, L"DMUS_E_WAVEFORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, L"DMUS_E_SYNTHINACTIVE")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, L"DMUS_E_DSOUND_ALREADY_SET")
        CHK_ERR(DMUS_E_INVALID_EVENT, L"DMUS_E_INVALID_EVENT")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, L"DMUS_E_UNSUPPORTED_STREAM")
        CHK_ERR(DMUS_E_ALREADY_INITED, L"DMUS_E_ALREADY_INITED")
        CHK_ERR(DMUS_E_INVALID_BAND, L"DMUS_E_INVALID_BAND")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, L"DMUS_E_TRACK_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, L"DMUS_E_TOOL_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, L"DMUS_E_INVALID_TRACK_HDR")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, L"DMUS_E_INVALID_TOOL_HDR")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, L"DMUS_E_ALL_TOOLS_FAILED")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, L"DMUS_E_ALL_TRACKS_FAILED")
//      CHK_ERR(DMUS_E_NOT_FOUND, L"DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, L"DMUS_E_NOT_INIT")
        CHK_ERR(DMUS_E_TYPE_DISABLED, L"DMUS_E_TYPE_DISABLED")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, L"DMUS_E_TYPE_UNSUPPORTED")
        CHK_ERR(DMUS_E_TIME_PAST, L"DMUS_E_TIME_PAST")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, L"DMUS_E_TRACK_NOT_FOUND")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, L"DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, L"DMUS_E_NO_MASTER_CLOCK")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, L"DMUS_E_LOADER_NOCLASSID")
        CHK_ERR(DMUS_E_LOADER_BADPATH, L"DMUS_E_LOADER_BADPATH")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, L"DMUS_E_LOADER_FAILEDOPEN")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, L"DMUS_E_LOADER_FORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, L"DMUS_E_LOADER_FAILEDCREATE")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, L"DMUS_E_LOADER_OBJECTNOTFOUND")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, L"DMUS_E_LOADER_NOFILENAME")
        CHK_ERR(DMUS_E_INVALIDFILE, L"DMUS_E_INVALIDFILE")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, L"DMUS_E_ALREADY_EXISTS")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, L"DMUS_E_OUT_OF_RANGE")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, L"DMUS_E_SEGMENT_INIT_FAILED")
        CHK_ERR(DMUS_E_ALREADY_SENT, L"DMUS_E_ALREADY_SENT")
        CHK_ERR(DMUS_E_CANNOT_FREE, L"DMUS_E_CANNOT_FREE")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, L"DMUS_E_CANNOT_OPEN_PORT")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, L"DMUS_E_CANNOT_CONVERT")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, L"DMUS_E_DESCEND_CHUNK_FAIL")
        CHK_ERR(DMUS_E_NOT_LOADED, L"DMUS_E_NOT_LOADED")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, L"DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, L"DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, L"DMUS_E_SCRIPT_ERROR_IN_SCRIPT")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, L"DMUS_E_SCRIPT_CANTLOAD_OLEAUT32")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, L"DMUS_E_SCRIPT_LOADSCRIPT_ERROR")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, L"DMUS_E_SCRIPT_INVALID_FILE")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, L"DMUS_E_INVALID_SCRIPTTRACK")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, L"DMUS_E_SCRIPT_VARIABLE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, L"DMUS_E_SCRIPT_ROUTINE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_CONTENT_READONLY, L"DMUS_E_SCRIPT_CONTENT_READONLY")
        CHK_ERR(DMUS_E_SCRIPT_NOT_A_REFERENCE, L"DMUS_E_SCRIPT_NOT_A_REFERENCE")
        CHK_ERR(DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED, L"DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, L"DMUS_E_INVALID_SEGMENTTRIGGERTRACK")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, L"DMUS_E_INVALID_LYRICSTRACK")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, L"DMUS_E_INVALID_PARAMCONTROLTRACK")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, L"DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, L"DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, L"DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, L"DMUS_E_AUDIOPATHS_NOT_VALID")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, L"DMUS_E_AUDIOPATHS_IN_USE")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, L"DMUS_E_NO_AUDIOPATH_CONFIG")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, L"DMUS_E_AUDIOPATH_INACTIVE")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, L"DMUS_E_AUDIOPATH_NOBUFFER")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, L"DMUS_E_AUDIOPATH_NOPORT")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, L"DMUS_E_NO_AUDIOPATH")
        CHK_ERR(DMUS_E_INVALIDCHUNK, L"DMUS_E_INVALIDCHUNK")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, L"DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, L"DMUS_E_INVALID_CONTAINER_OBJECT")    
   
// -------------------------------------------------------------        
// vfwmsgs.h error codes as of 9/8/00
// -------------------------------------------------------------        
//      CHK_ERR(VFW_E_INVALIDMEDIATYPE, L"VFW_E_INVALIDMEDIATYPE")
//      CHK_ERR(VFW_E_INVALIDSUBTYPE, L"VFW_E_INVALIDSUBTYPE")
//      CHK_ERR(VFW_E_NEED_OWNER, L"VFW_E_NEED_OWNER")
//      CHK_ERR(VFW_E_ENUM_OUT_OF_SYNC, L"VFW_E_ENUM_OUT_OF_SYNC")
//      CHK_ERR(VFW_E_ALREADY_CONNECTED, L"VFW_E_ALREADY_CONNECTED")
//      CHK_ERR(VFW_E_FILTER_ACTIVE, L"VFW_E_FILTER_ACTIVE")
//      CHK_ERR(VFW_E_NO_TYPES, L"VFW_E_NO_TYPES")
//      CHK_ERR(VFW_E_NO_ACCEPTABLE_TYPES, L"VFW_E_NO_ACCEPTABLE_TYPES")
//      CHK_ERR(VFW_E_INVALID_DIRECTION, L"VFW_E_INVALID_DIRECTION")
//      CHK_ERR(VFW_E_NOT_CONNECTED, L"VFW_E_NOT_CONNECTED")
//      CHK_ERR(VFW_E_NO_ALLOCATOR, L"VFW_E_NO_ALLOCATOR")
//      CHK_ERR(VFW_E_RUNTIME_ERROR, L"VFW_E_RUNTIME_ERROR")
        CHK_ERR(VFW_E_BUFFER_NOTSET, L"VFW_E_BUFFER_NOTSET")
        CHK_ERR(VFW_E_BUFFER_OVERFLOW, L"VFW_E_BUFFER_OVERFLOW")
        CHK_ERR(VFW_E_BADALIGN, L"VFW_E_BADALIGN")
        CHK_ERR(VFW_E_ALREADY_COMMITTED, L"VFW_E_ALREADY_COMMITTED")
        CHK_ERR(VFW_E_BUFFERS_OUTSTANDING, L"VFW_E_BUFFERS_OUTSTANDING")
        CHK_ERR(VFW_E_NOT_COMMITTED, L"VFW_E_NOT_COMMITTED")
        CHK_ERR(VFW_E_SIZENOTSET, L"VFW_E_SIZENOTSET")
        CHK_ERR(VFW_E_NO_CLOCK, L"VFW_E_NO_CLOCK")
        CHK_ERR(VFW_E_NO_SINK, L"VFW_E_NO_SINK")
        CHK_ERR(VFW_E_NO_INTERFACE, L"VFW_E_NO_INTERFACE")
        CHK_ERR(VFW_E_NOT_FOUND, L"VFW_E_NOT_FOUND")
        CHK_ERR(VFW_E_CANNOT_CONNECT, L"VFW_E_CANNOT_CONNECT")
        CHK_ERR(VFW_E_CANNOT_RENDER, L"VFW_E_CANNOT_RENDER")
        CHK_ERR(VFW_E_CHANGING_FORMAT, L"VFW_E_CHANGING_FORMAT")
        CHK_ERR(VFW_E_NO_COLOR_KEY_SET, L"VFW_E_NO_COLOR_KEY_SET")
        CHK_ERR(VFW_E_NOT_OVERLAY_CONNECTION, L"VFW_E_NOT_OVERLAY_CONNECTION")
        CHK_ERR(VFW_E_NOT_SAMPLE_CONNECTION, L"VFW_E_NOT_SAMPLE_CONNECTION")
        CHK_ERR(VFW_E_PALETTE_SET, L"VFW_E_PALETTE_SET")
        CHK_ERR(VFW_E_COLOR_KEY_SET, L"VFW_E_COLOR_KEY_SET")
        CHK_ERR(VFW_E_NO_COLOR_KEY_FOUND, L"VFW_E_NO_COLOR_KEY_FOUND")
        CHK_ERR(VFW_E_NO_PALETTE_AVAILABLE, L"VFW_E_NO_PALETTE_AVAILABLE")
        CHK_ERR(VFW_E_NO_DISPLAY_PALETTE, L"VFW_E_NO_DISPLAY_PALETTE")
        CHK_ERR(VFW_E_TOO_MANY_COLORS, L"VFW_E_TOO_MANY_COLORS")
        CHK_ERR(VFW_E_STATE_CHANGED, L"VFW_E_STATE_CHANGED")
        CHK_ERR(VFW_E_NOT_STOPPED, L"VFW_E_NOT_STOPPED")
        CHK_ERR(VFW_E_NOT_PAUSED, L"VFW_E_NOT_PAUSED")
        CHK_ERR(VFW_E_NOT_RUNNING, L"VFW_E_NOT_RUNNING")
        CHK_ERR(VFW_E_WRONG_STATE, L"VFW_E_WRONG_STATE")
        CHK_ERR(VFW_E_START_TIME_AFTER_END, L"VFW_E_START_TIME_AFTER_END")
        CHK_ERR(VFW_E_INVALID_RECT, L"VFW_E_INVALID_RECT")
        CHK_ERR(VFW_E_TYPE_NOT_ACCEPTED, L"VFW_E_TYPE_NOT_ACCEPTED")
        CHK_ERR(VFW_E_SAMPLE_REJECTED, L"VFW_E_SAMPLE_REJECTED")
        CHK_ERR(VFW_E_SAMPLE_REJECTED_EOS, L"VFW_E_SAMPLE_REJECTED_EOS")
        CHK_ERR(VFW_E_DUPLICATE_NAME, L"VFW_E_DUPLICATE_NAME")
        CHK_ERR(VFW_S_DUPLICATE_NAME, L"VFW_S_DUPLICATE_NAME")
        CHK_ERR(VFW_E_TIMEOUT, L"VFW_E_TIMEOUT")
        CHK_ERR(VFW_E_INVALID_FILE_FORMAT, L"VFW_E_INVALID_FILE_FORMAT")
        CHK_ERR(VFW_E_ENUM_OUT_OF_RANGE, L"VFW_E_ENUM_OUT_OF_RANGE")
        CHK_ERR(VFW_E_CIRCULAR_GRAPH, L"VFW_E_CIRCULAR_GRAPH")
        CHK_ERR(VFW_E_NOT_ALLOWED_TO_SAVE, L"VFW_E_NOT_ALLOWED_TO_SAVE")
        CHK_ERR(VFW_E_TIME_ALREADY_PASSED, L"VFW_E_TIME_ALREADY_PASSED")
        CHK_ERR(VFW_E_ALREADY_CANCELLED, L"VFW_E_ALREADY_CANCELLED")
        CHK_ERR(VFW_E_CORRUPT_GRAPH_FILE, L"VFW_E_CORRUPT_GRAPH_FILE")
        CHK_ERR(VFW_E_ADVISE_ALREADY_SET, L"VFW_E_ADVISE_ALREADY_SET")
        CHK_ERR(VFW_S_STATE_INTERMEDIATE, L"VFW_S_STATE_INTERMEDIATE")
        CHK_ERR(VFW_E_NO_MODEX_AVAILABLE, L"VFW_E_NO_MODEX_AVAILABLE")
        CHK_ERR(VFW_E_NO_ADVISE_SET, L"VFW_E_NO_ADVISE_SET")
        CHK_ERR(VFW_E_NO_FULLSCREEN, L"VFW_E_NO_FULLSCREEN")
        CHK_ERR(VFW_E_IN_FULLSCREEN_MODE, L"VFW_E_IN_FULLSCREEN_MODE")
        CHK_ERR(VFW_E_UNKNOWN_FILE_TYPE, L"VFW_E_UNKNOWN_FILE_TYPE")
        CHK_ERR(VFW_E_CANNOT_LOAD_SOURCE_FILTER, L"VFW_E_CANNOT_LOAD_SOURCE_FILTER")
        CHK_ERR(VFW_S_PARTIAL_RENDER, L"VFW_S_PARTIAL_RENDER")
        CHK_ERR(VFW_E_FILE_TOO_SHORT, L"VFW_E_FILE_TOO_SHORT")
        CHK_ERR(VFW_E_INVALID_FILE_VERSION, L"VFW_E_INVALID_FILE_VERSION")
        CHK_ERR(VFW_S_SOME_DATA_IGNORED, L"VFW_S_SOME_DATA_IGNORED")
        CHK_ERR(VFW_S_CONNECTIONS_DEFERRED, L"VFW_S_CONNECTIONS_DEFERRED")
        CHK_ERR(VFW_E_INVALID_CLSID, L"VFW_E_INVALID_CLSID")
        CHK_ERR(VFW_E_INVALID_MEDIA_TYPE, L"VFW_E_INVALID_MEDIA_TYPE")
        CHK_ERR(VFW_E_BAD_KEY, L"VFW_E_BAD_KEY")
        CHK_ERR(VFW_S_NO_MORE_ITEMS, L"VFW_S_NO_MORE_ITEMS")
        CHK_ERR(VFW_E_SAMPLE_TIME_NOT_SET, L"VFW_E_SAMPLE_TIME_NOT_SET")
        CHK_ERR(VFW_S_RESOURCE_NOT_NEEDED, L"VFW_S_RESOURCE_NOT_NEEDED")
        CHK_ERR(VFW_E_MEDIA_TIME_NOT_SET, L"VFW_E_MEDIA_TIME_NOT_SET")
        CHK_ERR(VFW_E_NO_TIME_FORMAT_SET, L"VFW_E_NO_TIME_FORMAT_SET")
        CHK_ERR(VFW_E_MONO_AUDIO_HW, L"VFW_E_MONO_AUDIO_HW")
        CHK_ERR(VFW_S_MEDIA_TYPE_IGNORED, L"VFW_S_MEDIA_TYPE_IGNORED")
        CHK_ERR(VFW_E_NO_DECOMPRESSOR, L"VFW_E_NO_DECOMPRESSOR")
        CHK_ERR(VFW_E_NO_AUDIO_HARDWARE, L"VFW_E_NO_AUDIO_HARDWARE")
        CHK_ERR(VFW_S_VIDEO_NOT_RENDERED, L"VFW_S_VIDEO_NOT_RENDERED")
        CHK_ERR(VFW_S_AUDIO_NOT_RENDERED, L"VFW_S_AUDIO_NOT_RENDERED")
        CHK_ERR(VFW_E_RPZA, L"VFW_E_RPZA")
        CHK_ERR(VFW_S_RPZA, L"VFW_S_RPZA")
        CHK_ERR(VFW_E_PROCESSOR_NOT_SUITABLE, L"VFW_E_PROCESSOR_NOT_SUITABLE")
        CHK_ERR(VFW_E_UNSUPPORTED_AUDIO, L"VFW_E_UNSUPPORTED_AUDIO")
        CHK_ERR(VFW_E_UNSUPPORTED_VIDEO, L"VFW_E_UNSUPPORTED_VIDEO")
        CHK_ERR(VFW_E_MPEG_NOT_CONSTRAINED, L"VFW_E_MPEG_NOT_CONSTRAINED")
        CHK_ERR(VFW_E_NOT_IN_GRAPH, L"VFW_E_NOT_IN_GRAPH")
        CHK_ERR(VFW_S_ESTIMATED, L"VFW_S_ESTIMATED")
        CHK_ERR(VFW_E_NO_TIME_FORMAT, L"VFW_E_NO_TIME_FORMAT")
        CHK_ERR(VFW_E_READ_ONLY, L"VFW_E_READ_ONLY")
        CHK_ERR(VFW_S_RESERVED, L"VFW_S_RESERVED")
        CHK_ERR(VFW_E_BUFFER_UNDERFLOW, L"VFW_E_BUFFER_UNDERFLOW")
        CHK_ERR(VFW_E_UNSUPPORTED_STREAM, L"VFW_E_UNSUPPORTED_STREAM")
        CHK_ERR(VFW_E_NO_TRANSPORT, L"VFW_E_NO_TRANSPORT")
        CHK_ERR(VFW_S_STREAM_OFF, L"VFW_S_STREAM_OFF")
        CHK_ERR(VFW_S_CANT_CUE, L"VFW_S_CANT_CUE")
        CHK_ERR(VFW_E_BAD_VIDEOCD, L"VFW_E_BAD_VIDEOCD")
        CHK_ERR(VFW_S_NO_STOP_TIME, L"VFW_S_NO_STOP_TIME")
        CHK_ERR(VFW_E_OUT_OF_VIDEO_MEMORY, L"VFW_E_OUT_OF_VIDEO_MEMORY")
        CHK_ERR(VFW_E_VP_NEGOTIATION_FAILED, L"VFW_E_VP_NEGOTIATION_FAILED")
        CHK_ERR(VFW_E_DDRAW_CAPS_NOT_SUITABLE, L"VFW_E_DDRAW_CAPS_NOT_SUITABLE")
        CHK_ERR(VFW_E_NO_VP_HARDWARE, L"VFW_E_NO_VP_HARDWARE")
        CHK_ERR(VFW_E_NO_CAPTURE_HARDWARE, L"VFW_E_NO_CAPTURE_HARDWARE")
        CHK_ERR(VFW_E_DVD_OPERATION_INHIBITED, L"VFW_E_DVD_OPERATION_INHIBITED")
        CHK_ERR(VFW_E_DVD_INVALIDDOMAIN, L"VFW_E_DVD_INVALIDDOMAIN")
        CHK_ERR(VFW_E_DVD_NO_BUTTON, L"VFW_E_DVD_NO_BUTTON")
        CHK_ERR(VFW_E_DVD_GRAPHNOTREADY, L"VFW_E_DVD_GRAPHNOTREADY")
        CHK_ERR(VFW_E_DVD_RENDERFAIL, L"VFW_E_DVD_RENDERFAIL")
        CHK_ERR(VFW_E_DVD_DECNOTENOUGH, L"VFW_E_DVD_DECNOTENOUGH")
        CHK_ERR(VFW_E_DDRAW_VERSION_NOT_SUITABLE, L"VFW_E_DDRAW_VERSION_NOT_SUITABLE")
        CHK_ERR(VFW_E_COPYPROT_FAILED, L"VFW_E_COPYPROT_FAILED")
        CHK_ERR(VFW_S_NOPREVIEWPIN, L"VFW_S_NOPREVIEWPIN")
        CHK_ERR(VFW_E_TIME_EXPIRED, L"VFW_E_TIME_EXPIRED")
        CHK_ERR(VFW_S_DVD_NON_ONE_SEQUENTIAL, L"VFW_S_DVD_NON_ONE_SEQUENTIAL")
        CHK_ERR(VFW_E_DVD_WRONG_SPEED, L"VFW_E_DVD_WRONG_SPEED")
        CHK_ERR(VFW_E_DVD_MENU_DOES_NOT_EXIST, L"VFW_E_DVD_MENU_DOES_NOT_EXIST")
        CHK_ERR(VFW_E_DVD_CMD_CANCELLED, L"VFW_E_DVD_CMD_CANCELLED")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_VERSION, L"VFW_E_DVD_STATE_WRONG_VERSION")
        CHK_ERR(VFW_E_DVD_STATE_CORRUPT, L"VFW_E_DVD_STATE_CORRUPT")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_DISC, L"VFW_E_DVD_STATE_WRONG_DISC")
        CHK_ERR(VFW_E_DVD_INCOMPATIBLE_REGION, L"VFW_E_DVD_INCOMPATIBLE_REGION")
        CHK_ERR(VFW_E_DVD_NO_ATTRIBUTES, L"VFW_E_DVD_NO_ATTRIBUTES")
        CHK_ERR(VFW_E_DVD_NO_GOUP_PGC, L"VFW_E_DVD_NO_GOUP_PGC")
        CHK_ERR(VFW_E_DVD_LOW_PARENTAL_LEVEL, L"VFW_E_DVD_LOW_PARENTAL_LEVEL")
        CHK_ERR(VFW_E_DVD_NOT_IN_KARAOKE_MODE, L"VFW_E_DVD_NOT_IN_KARAOKE_MODE")
        CHK_ERR(VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE, L"VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE")
        CHK_ERR(VFW_S_DVD_NOT_ACCURATE, L"VFW_S_DVD_NOT_ACCURATE")
        CHK_ERR(VFW_E_FRAME_STEP_UNSUPPORTED, L"VFW_E_FRAME_STEP_UNSUPPORTED")
        CHK_ERR(VFW_E_DVD_STREAM_DISABLED, L"VFW_E_DVD_STREAM_DISABLED")
        CHK_ERR(VFW_E_DVD_TITLE_UNKNOWN, L"VFW_E_DVD_TITLE_UNKNOWN")
        CHK_ERR(VFW_E_DVD_INVALID_DISC, L"VFW_E_DVD_INVALID_DISC")
        CHK_ERR(VFW_E_DVD_NO_RESUME_INFORMATION, L"VFW_E_DVD_NO_RESUME_INFORMATION")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD, L"VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED, L"VFW_E_PIN_ALREADY_BLOCKED")
        CHK_ERR(VFW_E_CERTIFICATION_FAILURE, L"VFW_E_CERTIFICATION_FAILURE")
        CHK_ERR(E_PROP_SET_UNSUPPORTED, L"E_PROP_SET_UNSUPPORTED")
        CHK_ERR(E_PROP_ID_UNSUPPORTED, L"E_PROP_ID_UNSUPPORTED")
   }
   
   return L"Unknown";
}




//-----------------------------------------------------------------------------
// Name: DXGetErrorDescription8A()
// Desc: Returns a description of the HRESULT 
//-----------------------------------------------------------------------------
const char * WINAPI DXGetErrorDescription8A(HRESULT hr)
{
   switch(hr)
   {     
// -------------------------------------------------------------        
// Common Win32 error codes
// -------------------------------------------------------------        
        CHK_ERR(S_OK, "The function completed successfully")        
        CHK_ERR(S_FALSE, "Call successful, but returned FALSE")
        
        CHK_ERR(ERROR_FILE_NOT_FOUND, "The system cannot find the file specified.")
        CHK_ERR(ERROR_PATH_NOT_FOUND, "The system cannot find the path specified.")
        CHK_ERR(ERROR_TOO_MANY_OPEN_FILES, "The system cannot open the file.")
        CHK_ERR(ERROR_ACCESS_DENIED, "Access is denied.")
        CHK_ERR(ERROR_INVALID_HANDLE, "The handle is invalid.")
        CHK_ERR(ERROR_NOT_ENOUGH_MEMORY, "Not enough storage is available to process this command.")
        CHK_ERR(ERROR_INVALID_BLOCK, "The storage control block address is invalid.")
        CHK_ERR(ERROR_BAD_ENVIRONMENT, "The environment is incorrect.")
        CHK_ERR(ERROR_BAD_FORMAT, "An attempt was made to load a program with an incorrect format.")
        CHK_ERR(ERROR_OUTOFMEMORY, "The system cannot find the drive specified.")
                
        CHK_ERR(E_UNEXPECTED, "Catastrophic failure")
        CHK_ERR(E_NOTIMPL, "The function called is not supported at this time")
        CHK_ERR(E_OUTOFMEMORY, "Ran out of memory")
        CHK_ERR(E_INVALIDARG, "An invalid parameter was passed to the returning function")
        CHK_ERR(E_NOINTERFACE, "The requested COM interface is not available")
        CHK_ERR(E_POINTER, "Invalid pointer")
        CHK_ERR(E_HANDLE, "Invalid handle")
        CHK_ERR(E_ABORT, "Operation aborted")
        CHK_ERR(E_FAIL, "An undetermined error occurred")
        CHK_ERR(E_ACCESSDENIED, "Access is denied")
        CHK_ERR(E_PENDING, "The data necessary to complete this operation is not yet available.")
        CHK_ERR(REGDB_E_CLASSNOTREG, "Class not registered")
        CHK_ERR(CO_E_NOTINITIALIZED, "CoInitialize has not been called.")
        CHK_ERR(CO_E_ALREADYINITIALIZED, "CoInitialize has already been called.")
        CHK_ERR(CLASS_E_NOAGGREGATION, "This object does not support aggregation")

// -------------------------------------------------------------        
// ddraw.h error codes as of 1/22/01
// -------------------------------------------------------------                
        CHK_ERR(DDERR_ALREADYINITIALIZED, "This object is already initialized")
        CHK_ERR(DDERR_CANNOTATTACHSURFACE, "This surface can not be attached to the requested surface.")
        CHK_ERR(DDERR_CANNOTDETACHSURFACE, "This surface can not be detached from the requested surface.")
        CHK_ERR(DDERR_CURRENTLYNOTAVAIL, "Support is currently not available.")
        CHK_ERR(DDERR_EXCEPTION, "An exception was encountered while performing the requested operation")
//      CHK_ERR(DDERR_GENERIC, "DDERR_GENERIC")
        CHK_ERR(DDERR_HEIGHTALIGN, "Height of rectangle provided is not a multiple of reqd alignment")
        CHK_ERR(DDERR_INCOMPATIBLEPRIMARY, "Unable to match primary surface creation request with existing primary surface.")
        CHK_ERR(DDERR_INVALIDCAPS, "One or more of the caps bits passed to the callback are incorrect.")
        CHK_ERR(DDERR_INVALIDCLIPLIST, "DirectDraw does not support provided Cliplist.")
        CHK_ERR(DDERR_INVALIDMODE, "DirectDraw does not support the requested mode")
        CHK_ERR(DDERR_INVALIDOBJECT, "DirectDraw received a pointer that was an invalid DIRECTDRAW object.")
//        CHK_ERR(DDERR_INVALIDPARAMS, "DDERR_INVALIDPARAMS")
        CHK_ERR(DDERR_INVALIDPIXELFORMAT, "pixel format was invalid as specified")
        CHK_ERR(DDERR_INVALIDRECT, "Rectangle provided was invalid.")
        CHK_ERR(DDERR_LOCKEDSURFACES, "Operation could not be carried out because one or more surfaces are locked")
        CHK_ERR(DDERR_NO3D, "There is no 3D present.")
        CHK_ERR(DDERR_NOALPHAHW, "Operation could not be carried out because there is no alpha accleration hardware present or available.")
        CHK_ERR(DDERR_NOSTEREOHARDWARE, "Operation could not be carried out because there is no stereo hardware present or available.")
        CHK_ERR(DDERR_NOSURFACELEFT, "Operation could not be carried out because there is no hardware present which supports stereo surfaces")
        CHK_ERR(DDERR_NOCLIPLIST, "no clip list available")
        CHK_ERR(DDERR_NOCOLORCONVHW, "Operation could not be carried out because there is no color conversion hardware present or available.")
        CHK_ERR(DDERR_NOCOOPERATIVELEVELSET, "Create function called without DirectDraw object method SetCooperativeLevel being called.")
        CHK_ERR(DDERR_NOCOLORKEY, "Surface doesn't currently have a color key")
        CHK_ERR(DDERR_NOCOLORKEYHW, "Operation could not be carried out because there is no hardware support of the dest color key.")
        CHK_ERR(DDERR_NODIRECTDRAWSUPPORT, "No DirectDraw support possible with current display driver")
        CHK_ERR(DDERR_NOEXCLUSIVEMODE, "Operation requires the application to have exclusive mode but the application does not have exclusive mode.")
        CHK_ERR(DDERR_NOFLIPHW, "Flipping visible surfaces is not supported.")
        CHK_ERR(DDERR_NOGDI, "There is no GDI present.")
        CHK_ERR(DDERR_NOMIRRORHW, "Operation could not be carried out because there is no hardware present or available.")
        CHK_ERR(DDERR_NOTFOUND, "Requested item was not found")
        CHK_ERR(DDERR_NOOVERLAYHW, "Operation could not be carried out because there is no overlay hardware present or available.")
        CHK_ERR(DDERR_OVERLAPPINGRECTS, "Operation could not be carried out because the source and destination rectangles are on the same surface and overlap each other.")
        CHK_ERR(DDERR_NORASTEROPHW, "Operation could not be carried out because there is no appropriate raster op hardware present or available.")
        CHK_ERR(DDERR_NOROTATIONHW, "Operation could not be carried out because there is no rotation hardware present or available.")
        CHK_ERR(DDERR_NOSTRETCHHW, "Operation could not be carried out because there is no hardware support for stretching")
        CHK_ERR(DDERR_NOT4BITCOLOR, "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.")
        CHK_ERR(DDERR_NOT4BITCOLORINDEX, "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.")
        CHK_ERR(DDERR_NOT8BITCOLOR, "DirectDraw Surface is not in 8 bit color mode and the requested operation requires 8 bit color.")
        CHK_ERR(DDERR_NOTEXTUREHW, "Operation could not be carried out because there is no texture mapping hardware present or available.")
        CHK_ERR(DDERR_NOVSYNCHW, "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.")
        CHK_ERR(DDERR_NOZBUFFERHW, "Operation could not be carried out because there is no hardware support for zbuffer blting.")
        CHK_ERR(DDERR_NOZOVERLAYHW, "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.")
        CHK_ERR(DDERR_OUTOFCAPS, "The hardware needed for the requested operation has already been allocated.")
//        CHK_ERR(DDERR_OUTOFMEMORY, "DDERR_OUTOFMEMORY")
//        CHK_ERR(DDERR_OUTOFVIDEOMEMORY, "DDERR_OUTOFVIDEOMEMORY")
        CHK_ERR(DDERR_OVERLAYCANTCLIP, "hardware does not support clipped overlays")
        CHK_ERR(DDERR_OVERLAYCOLORKEYONLYONEACTIVE, "Can only have ony color key active at one time for overlays")
        CHK_ERR(DDERR_PALETTEBUSY, "Access to this palette is being refused because the palette is already locked by another thread.")
        CHK_ERR(DDERR_COLORKEYNOTSET, "No src color key specified for this operation.")
        CHK_ERR(DDERR_SURFACEALREADYATTACHED, "This surface is already attached to the surface it is being attached to.")
        CHK_ERR(DDERR_SURFACEALREADYDEPENDENT, "This surface is already a dependency of the surface it is being made a dependency of.")
        CHK_ERR(DDERR_SURFACEBUSY, "Access to this surface is being refused because the surface is already locked by another thread.")
        CHK_ERR(DDERR_CANTLOCKSURFACE, "Access to this surface is being refused because no driver exists which can supply a pointer to the surface. This is most likely to happen when attempting to lock the primary surface when no DCI provider is present. Will also happen on attempts to lock an optimized surface.")
        CHK_ERR(DDERR_SURFACEISOBSCURED, "Access to Surface refused because Surface is obscured.")
        CHK_ERR(DDERR_SURFACELOST, "Access to this surface is being refused because the surface is gone. The DIRECTDRAWSURFACE object representing this surface should have Restore called on it.")
        CHK_ERR(DDERR_SURFACENOTATTACHED, "The requested surface is not attached.")
        CHK_ERR(DDERR_TOOBIGHEIGHT, "Height requested by DirectDraw is too large.")
        CHK_ERR(DDERR_TOOBIGSIZE, "Size requested by DirectDraw is too large --  The individual height and width are OK.")
        CHK_ERR(DDERR_TOOBIGWIDTH, "Width requested by DirectDraw is too large.")
//        CHK_ERR(DDERR_UNSUPPORTED, "DDERR_UNSUPPORTED")
        CHK_ERR(DDERR_UNSUPPORTEDFORMAT, "Pixel format requested is unsupported by DirectDraw")
        CHK_ERR(DDERR_UNSUPPORTEDMASK, "Bitmask in the pixel format requested is unsupported by DirectDraw")
        CHK_ERR(DDERR_INVALIDSTREAM, "The specified stream contains invalid data")
        CHK_ERR(DDERR_VERTICALBLANKINPROGRESS, "vertical blank is in progress")
        CHK_ERR(DDERR_WASSTILLDRAWING, "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.")
        CHK_ERR(DDERR_DDSCAPSCOMPLEXREQUIRED, "The specified surface type requires specification of the COMPLEX flag")
        CHK_ERR(DDERR_XALIGN, "Rectangle provided was not horizontally aligned on reqd. boundary")
        CHK_ERR(DDERR_INVALIDDIRECTDRAWGUID, "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.")
        CHK_ERR(DDERR_DIRECTDRAWALREADYCREATED, "A DirectDraw object representing this driver has already been created for this process.")
        CHK_ERR(DDERR_NODIRECTDRAWHW, "A hardware only DirectDraw object creation was attempted but the driver did not support any hardware.")
        CHK_ERR(DDERR_PRIMARYSURFACEALREADYEXISTS, "this process already has created a primary surface")
        CHK_ERR(DDERR_NOEMULATION, "software emulation not available.")
        CHK_ERR(DDERR_REGIONTOOSMALL, "region passed to Clipper::GetClipList is too small.")
        CHK_ERR(DDERR_CLIPPERISUSINGHWND, "an attempt was made to set a clip list for a clipper objec that is already monitoring an hwnd.")
        CHK_ERR(DDERR_NOCLIPPERATTACHED, "No clipper object attached to surface object")
        CHK_ERR(DDERR_NOHWND, "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.")
        CHK_ERR(DDERR_HWNDSUBCLASSED, "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.")
        CHK_ERR(DDERR_HWNDALREADYSET, "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.")
        CHK_ERR(DDERR_NOPALETTEATTACHED, "No palette object attached to this surface.")
        CHK_ERR(DDERR_NOPALETTEHW, "No hardware support for 16 or 256 color palettes.")
        CHK_ERR(DDERR_BLTFASTCANTCLIP, "If a clipper object is attached to the source surface passed into a BltFast call.")
        CHK_ERR(DDERR_NOBLTHW, "No blter.")
        CHK_ERR(DDERR_NODDROPSHW, "No DirectDraw ROP hardware.")
        CHK_ERR(DDERR_OVERLAYNOTVISIBLE, "returned when GetOverlayPosition is called on a hidden overlay")
        CHK_ERR(DDERR_NOOVERLAYDEST, "returned when GetOverlayPosition is called on a overlay that UpdateOverlay has never been called on to establish a destionation.")
        CHK_ERR(DDERR_INVALIDPOSITION, "returned when the position of the overlay on the destionation is no longer legal for that destionation.")
        CHK_ERR(DDERR_NOTAOVERLAYSURFACE, "returned when an overlay member is called for a non-overlay surface")
        CHK_ERR(DDERR_EXCLUSIVEMODEALREADYSET, "An attempt was made to set the cooperative level when it was already set to exclusive.")
        CHK_ERR(DDERR_NOTFLIPPABLE, "An attempt has been made to flip a surface that is not flippable.")
        CHK_ERR(DDERR_CANTDUPLICATE, "Can't duplicate primary & 3D surfaces, or surfaces that are implicitly created.")
        CHK_ERR(DDERR_NOTLOCKED, "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.")
        CHK_ERR(DDERR_CANTCREATEDC, "Windows can not create any more DCs, or a DC was requested for a paltte-indexed surface when the surface had no palette AND the display mode was not palette-indexed (in this case DirectDraw cannot select a proper palette into the DC)")
        CHK_ERR(DDERR_NODC, "No DC was ever created for this surface.")
        CHK_ERR(DDERR_WRONGMODE, "This surface can not be restored because it was created in a different mode.")
        CHK_ERR(DDERR_IMPLICITLYCREATED, "This surface can not be restored because it is an implicitly created surface.")
        CHK_ERR(DDERR_NOTPALETTIZED, "The surface being used is not a palette-based surface")
        CHK_ERR(DDERR_UNSUPPORTEDMODE, "The display is currently in an unsupported mode")
        CHK_ERR(DDERR_NOMIPMAPHW, "Operation could not be carried out because there is no mip-map texture mapping hardware present or available.")
        CHK_ERR(DDERR_INVALIDSURFACETYPE, "The requested action could not be performed because the surface was of the wrong type.")
        CHK_ERR(DDERR_NOOPTIMIZEHW, "Device does not support optimized surfaces, therefore no video memory optimized surfaces")
        CHK_ERR(DDERR_NOTLOADED, "Surface is an optimized surface, but has not yet been allocated any memory")
        CHK_ERR(DDERR_NOFOCUSWINDOW, "Attempt was made to create or set a device window without first setting the focus window")
        CHK_ERR(DDERR_NOTONMIPMAPSUBLEVEL, "Attempt was made to set a palette on a mipmap sublevel")
        CHK_ERR(DDERR_DCALREADYCREATED, "A DC has already been returned for this surface. Only one DC can be retrieved per surface.")
        CHK_ERR(DDERR_NONONLOCALVIDMEM, "An attempt was made to allocate non-local video memory from a device that does not support non-local video memory.")
        CHK_ERR(DDERR_CANTPAGELOCK, "The attempt to page lock a surface failed.")
        CHK_ERR(DDERR_CANTPAGEUNLOCK, "The attempt to page unlock a surface failed.")
        CHK_ERR(DDERR_NOTPAGELOCKED, "An attempt was made to page unlock a surface with no outstanding page locks.")
        CHK_ERR(DDERR_MOREDATA, "There is more data available than the specified buffer size could hold")
        CHK_ERR(DDERR_EXPIRED, "The data has expired and is therefore no longer valid.")
        CHK_ERR(DDERR_TESTFINISHED, "The mode test has finished executing.")
        CHK_ERR(DDERR_NEWMODE, "The mode test has switched to a new mode.")
        CHK_ERR(DDERR_D3DNOTINITIALIZED, "D3D has not yet been initialized.")
        CHK_ERR(DDERR_VIDEONOTACTIVE, "The video port is not active")
        CHK_ERR(DDERR_NOMONITORINFORMATION, "The monitor does not have EDID data.")
        CHK_ERR(DDERR_NODRIVERSUPPORT, "The driver does not enumerate display mode refresh rates.")
        CHK_ERR(DDERR_DEVICEDOESNTOWNSURFACE, "Surfaces created by one direct draw device cannot be used directly by another direct draw device.")

// -------------------------------------------------------------        
// dinput.h error codes as of 10/4/00
// -------------------------------------------------------------        
//      CHK_ERR(DI_OK, "DI_OK")
//      CHK_ERR(DI_NOTATTACHED, "DI_NOTATTACHED")
//      CHK_ERR(DI_BUFFEROVERFLOW, "DI_BUFFEROVERFLOW")
//      CHK_ERR(DI_PROPNOEFFECT, "DI_PROPNOEFFECT")
//      CHK_ERR(DI_NOEFFECT, "DI_NOEFFECT")
//      CHK_ERR(DI_POLLEDDEVICE, "DI_POLLEDDEVICE")
//      CHK_ERR(DI_DOWNLOADSKIPPED, "DI_DOWNLOADSKIPPED")
//      CHK_ERR(DI_EFFECTRESTARTED, "DI_EFFECTRESTARTED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_ACCESSDENIED, "DI_SETTINGSNOTSAVED_ACCESSDENIED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_DISKFULL, "DI_SETTINGSNOTSAVED_DISKFULL")
//      CHK_ERR(DI_TRUNCATED, "DI_TRUNCATED")
//      CHK_ERR(DI_TRUNCATEDANDRESTARTED, "DI_TRUNCATEDANDRESTARTED")
//      CHK_ERR(DI_WRITEPROTECT, "DI_WRITEPROTECT")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, "The application requires a newer version of DirectInput.")
//      CHK_ERR(DIERR_GENERIC, "DIERR_GENERIC")
//      CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, "DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, "The application was written for an unsupported prerelease version of DirectInput.")
        CHK_ERR(DIERR_BADDRIVERVER, "The object could not be created due to an incompatible driver version or mismatched or incomplete driver components.")
//      CHK_ERR(DIERR_DEVICENOTREG, "DIERR_DEVICENOTREG")   
        CHK_ERR(DIERR_NOTFOUND, "The requested object does not exist.")                
//      CHK_ERR(DIERR_OBJECTNOTFOUND, "DIERR_OBJECTNOTFOUND")
//      CHK_ERR(DIERR_INVALIDPARAM, "DIERR_INVALIDPARAM")         
//      CHK_ERR(DIERR_NOINTERFACE, "DIERR_NOINTERFACE")         
//      CHK_ERR(DIERR_GENERIC, "DIERR_GENERIC")         
//      CHK_ERR(DIERR_OUTOFMEMORY, "DIERR_OUTOFMEMORY")         
//      CHK_ERR(DIERR_UNSUPPORTED, "DIERR_UNSUPPORTED")         
        CHK_ERR(DIERR_NOTINITIALIZED, "This object has not been initialized")
        CHK_ERR(DIERR_ALREADYINITIALIZED, "This object is already initialized")
//      CHK_ERR(DIERR_NOAGGREGATION, "DIERR_NOAGGREGATION")
//      CHK_ERR(DIERR_OTHERAPPHASPRIO, "DIERR_OTHERAPPHASPRIO")         
        CHK_ERR(DIERR_INPUTLOST, "Access to the device has been lost.  It must be re-acquired.")
        CHK_ERR(DIERR_ACQUIRED, "The operation cannot be performed while the device is acquired.")
        CHK_ERR(DIERR_NOTACQUIRED, "The operation cannot be performed unless the device is acquired.")
//      CHK_ERR(DIERR_READONLY, "DIERR_READONLY")
//      CHK_ERR(DIERR_HANDLEEXISTS, "DIERR_HANDLEEXISTS")         
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, "Unable to IDirectInputJoyConfig_Acquire because the user does not have sufficient privileges to change the joystick configuration. & An invalid media type was specified")        
        CHK_ERR(DIERR_DEVICEFULL, "The device is full. & An invalid media subtype was specified.")
        CHK_ERR(DIERR_MOREDATA, "Not all the requested information fit into the buffer. & This object can only be created as an aggregated object.")
        CHK_ERR(DIERR_NOTDOWNLOADED, "The effect is not downloaded. & The enumerator has become invalid.")
        CHK_ERR(DIERR_HASEFFECTS, "The device cannot be reinitialized because there are still effects attached to it. & At least one of the pins involved in the operation is already connected.")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, "The operation cannot be performed unless the device is acquired in DISCL_EXCLUSIVE mode. & This operation cannot be performed because the filter is active.")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, "The effect could not be downloaded because essential information is missing.  For example, no axes have been associated with the effect, or no type-specific information has been created. & One of the specified pins supports no media types.")
        CHK_ERR(DIERR_NOTBUFFERED, "Attempted to read buffered device data from a device that is not buffered. & There is no common media type between these pins.")
        CHK_ERR(DIERR_EFFECTPLAYING, "An attempt was made to modify parameters of an effect while it is playing.  Not all hardware devices support altering the parameters of an effect while it is playing. & Two pins of the same direction cannot be connected together.")
        CHK_ERR(DIERR_UNPLUGGED, "The operation could not be completed because the device is not plugged in. & The operation cannot be performed because the pins are not connected.")
        CHK_ERR(DIERR_REPORTFULL, "SendDeviceData failed because more information was requested to be sent than can be sent to the device.  Some devices have restrictions on how much data can be sent to them.  (For example, there might be a limit on the number of buttons that can be pressed at once.) & No sample buffer allocator is available.")
        CHK_ERR(DIERR_MAPFILEFAIL, "A mapper file function failed because reading or writing the user or IHV settings file failed. & A run-time error occurred.")
 

// -------------------------------------------------------------        
// dinputd.h error codes as of 9/8/00
// -------------------------------------------------------------                
        CHK_ERR(DIERR_NOMOREITEMS, "No more items.")        
        CHK_ERR(DIERR_DRIVERFIRST, "Device driver-specific codes. Unless the specific driver has been precisely identified, no meaning should be attributed to these values other than that the driver originated the error.")
        CHK_ERR(DIERR_DRIVERFIRST+1, "DIERR_DRIVERFIRST+1")
        CHK_ERR(DIERR_DRIVERFIRST+2, "DIERR_DRIVERFIRST+2")
        CHK_ERR(DIERR_DRIVERFIRST+3, "DIERR_DRIVERFIRST+3")
        CHK_ERR(DIERR_DRIVERFIRST+4, "DIERR_DRIVERFIRST+4")
        CHK_ERR(DIERR_DRIVERFIRST+5, "DIERR_DRIVERFIRST+5")
        CHK_ERR(DIERR_DRIVERLAST, "Device installer errors.")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, "Registry entry or DLL for class installer invalid or class installer not found.")
        CHK_ERR(DIERR_CANCELLED, "The user cancelled the install operation.")
        CHK_ERR(DIERR_BADINF, "The INF file for the selected device could not be found or is invalid or is damaged.")
        

// -------------------------------------------------------------        
// dvoice.h error codes as of 9/8/00
// -------------------------------------------------------------                        
//      CHK_ERR(DV_OK, "OK")
        CHK_ERR(DV_FULLDUPLEX, "Full duplex")
        CHK_ERR(DV_HALFDUPLEX, "Half duplex")
        CHK_ERR(DV_PENDING, "Pending")
        CHK_ERR(DVERR_BUFFERTOOSMALL, "Buffer too small")
        CHK_ERR(DVERR_EXCEPTION, "Exception")
//      CHK_ERR(DVERR_GENERIC, "Generic")
        CHK_ERR(DVERR_INVALIDFLAGS, "Invalid flags")
        CHK_ERR(DVERR_INVALIDOBJECT, "Invalid object")
        CHK_ERR(DVERR_INVALIDPLAYER, "Invalid player")
        CHK_ERR(DVERR_INVALIDGROUP, "Invalid group")
        CHK_ERR(DVERR_INVALIDHANDLE, "Invalid handle")
//      CHK_ERR(DVERR_OUTOFMEMORY, "Out of memory")
//      CHK_ERR(DVERR_PENDING, "Pending")
//      CHK_ERR(DVERR_NOTSUPPORTED, "Not supported")
//      CHK_ERR(DVERR_NOINTERFACE, "No interface")
        CHK_ERR(DVERR_SESSIONLOST, "Session lost")
        CHK_ERR(DVERR_NOVOICESESSION, "No voice session")
        CHK_ERR(DVERR_CONNECTIONLOST, "Connection lost")
        CHK_ERR(DVERR_NOTINITIALIZED, "Not initialized")
        CHK_ERR(DVERR_CONNECTED, "Connected")
        CHK_ERR(DVERR_NOTCONNECTED, "Not connected")
        CHK_ERR(DVERR_CONNECTABORTING, "Connect aborting")
        CHK_ERR(DVERR_NOTALLOWED, "Not allowed")
        CHK_ERR(DVERR_INVALIDTARGET, "Invalid target")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, "Transport not host")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, "Compression not supported")
        CHK_ERR(DVERR_ALREADYPENDING, "Already pending")
        CHK_ERR(DVERR_SOUNDINITFAILURE, "Sound init failure")
        CHK_ERR(DVERR_TIMEOUT, "Time out")
        CHK_ERR(DVERR_CONNECTABORTED, "Connect aborted")
        CHK_ERR(DVERR_NO3DSOUND, "No 3d sound")
        CHK_ERR(DVERR_ALREADYBUFFERED, "Already buffered")
        CHK_ERR(DVERR_NOTBUFFERED, "Not buffered")
        CHK_ERR(DVERR_HOSTING, "Hosting")
        CHK_ERR(DVERR_NOTHOSTING, "Not hosting")
        CHK_ERR(DVERR_INVALIDDEVICE, "Invalid device")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, "Record system error")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, "Playback system error")
        CHK_ERR(DVERR_SENDERROR, "Send error")
        CHK_ERR(DVERR_USERCANCEL, "User cancel")
        CHK_ERR(DVERR_RUNSETUP, "Run setup")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, "Incompatible version")
        CHK_ERR(DVERR_INITIALIZED, "Initialized")
//      CHK_ERR(DVERR_INVALIDPOINTER, "Invalid pointer")
        CHK_ERR(DVERR_NOTRANSPORT, "No transport")
        CHK_ERR(DVERR_NOCALLBACK, "No callback")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, "Transport not init")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, "Transport no session")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, "Transport no player")
        CHK_ERR(DVERR_USERBACK, "User back")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, "No rec vol available")
        CHK_ERR(DVERR_INVALIDBUFFER, "Invalid buffer")
        CHK_ERR(DVERR_LOCKEDBUFFER, "Locked buffer")
        
              
// -------------------------------------------------------------        
// dplay8.h error codes as of 10/4/00
// -------------------------------------------------------------                        
        CHK_ERR(DPNERR_ABORTED, "Aborted")
        CHK_ERR(DPNERR_ADDRESSING, "Addressing")
        CHK_ERR(DPNERR_ALREADYCLOSING, "Already closing")        
        CHK_ERR(DPNERR_ALREADYCONNECTED, "Already connected")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, "Already disconnecting")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, "Already initialized")
        CHK_ERR(DPNERR_ALREADYREGISTERED, "Already registered")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, "Buffer too small")
        CHK_ERR(DPNERR_CANNOTCANCEL, "Can not cancel")
        CHK_ERR(DPNERR_CANTCREATEGROUP, "Cant create group")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, "Cant create player")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, "Cant launch application")
        CHK_ERR(DPNERR_CONNECTING, "Connecting")
        CHK_ERR(DPNERR_CONNECTIONLOST, "Connection lost")
        CHK_ERR(DPNERR_CONVERSION, "Conversion")
        CHK_ERR(DPNERR_DATATOOLARGE, "Data too large")
        CHK_ERR(DPNERR_DOESNOTEXIST, "Does not exist")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, "Duplicate command")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, "End point not receiving")
        CHK_ERR(DPNERR_ENUMQUERYTOOLARGE, "Enum query too large")
        CHK_ERR(DPNERR_ENUMRESPONSETOOLARGE, "Enum response too large")
        CHK_ERR(DPNERR_EXCEPTION, "Exception")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, "Group not empty")
        CHK_ERR(DPNERR_HOSTING, "Hosting")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, "Host rejected connection")
        CHK_ERR(DPNERR_HOSTTERMINATEDSESSION, "Host terminated session")        
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, "Incomplete address")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, "Invalid address format")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, "Invalid application")
        CHK_ERR(DPNERR_INVALIDCOMMAND, "Invalid command")
        CHK_ERR(DPNERR_INVALIDENDPOINT, "Invalid end point")
        CHK_ERR(DPNERR_INVALIDFLAGS, "Invalid flags")
        CHK_ERR(DPNERR_INVALIDGROUP, "Invalid group")
        CHK_ERR(DPNERR_INVALIDHANDLE, "Invalid handle")
        CHK_ERR(DPNERR_INVALIDINSTANCE, "Invalid instance")
        CHK_ERR(DPNERR_INVALIDINTERFACE, "Invalid interface")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, "Invalid device address")
        CHK_ERR(DPNERR_INVALIDOBJECT, "Invalid object")
//      CHK_ERR(DPNERR_INVALIDPARAM, "Invalid param")        
        CHK_ERR(DPNERR_INVALIDPASSWORD, "Invalid password")
        CHK_ERR(DPNERR_INVALIDPLAYER, "Invalid player")
//      CHK_ERR(DPNERR_INVALIDPOINTER, "Invalid pointer")        
        CHK_ERR(DPNERR_INVALIDPRIORITY, "Invalid priority")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, "Invalid host address")
        CHK_ERR(DPNERR_INVALIDSTRING, "Invalid string")
        CHK_ERR(DPNERR_INVALIDURL, "Invalid url")
        CHK_ERR(DPNERR_INVALIDVERSION, "Invalid version")
        CHK_ERR(DPNERR_NOCAPS, "No caps")
        CHK_ERR(DPNERR_NOCONNECTION, "No connection")
        CHK_ERR(DPNERR_NOHOSTPLAYER, "No host player")
//      CHK_ERR(DPNERR_NOINTERFACE, "No interface")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, "No more address components")
        CHK_ERR(DPNERR_NORESPONSE, "No response")
        CHK_ERR(DPNERR_NOTALLOWED, "Not allowed")
        CHK_ERR(DPNERR_NOTHOST, "Not host")
        CHK_ERR(DPNERR_NOTREADY, "Not ready")
        CHK_ERR(DPNERR_NOTREGISTERED, "Not registered")
//      CHK_ERR(DPNERR_OUTOFMEMORY, "Out of memory")
//      CHK_ERR(DPNERR_PENDING, "Pending")
        CHK_ERR(DPNERR_PLAYERLOST, "Player lost")
        CHK_ERR(DPNERR_PLAYERNOTREACHABLE, "Player not reachable")
        CHK_ERR(DPNERR_SENDTOOLARGE, "Send too large")
        CHK_ERR(DPNERR_SESSIONFULL, "Session full")
        CHK_ERR(DPNERR_TABLEFULL, "Table full")
        CHK_ERR(DPNERR_TIMEDOUT, "Timed out")
        CHK_ERR(DPNERR_UNINITIALIZED, "Uninitialized")
//      CHK_ERR(DPNERR_UNSUPPORTED, "Unsupported")
        CHK_ERR(DPNERR_USERCANCEL, "User cancel")
        
              
// -------------------------------------------------------------        
// dxfile.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(DXFILE_OK, "Ok")
        CHK_ERR(DXFILEERR_BADOBJECT, "Bad object")
        CHK_ERR(DXFILEERR_BADVALUE, "Bad value")
        CHK_ERR(DXFILEERR_BADTYPE, "Bad type")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, "Bad stream handle")
        CHK_ERR(DXFILEERR_BADALLOC, "Bad alloc")
        CHK_ERR(DXFILEERR_NOTFOUND, "Not found")
        CHK_ERR(DXFILEERR_NOTDONEYET, "Not done yet")
        CHK_ERR(DXFILEERR_FILENOTFOUND, "File not found")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, "Resource not found")
        CHK_ERR(DXFILEERR_URLNOTFOUND, "Url not found")
        CHK_ERR(DXFILEERR_BADRESOURCE, "Bad resource")
        CHK_ERR(DXFILEERR_BADFILETYPE, "Bad file type")
        CHK_ERR(DXFILEERR_BADFILEVERSION, "Bad file version")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, "Bad file float size")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, "Bad file compression type")
        CHK_ERR(DXFILEERR_BADFILE, "Bad file")
        CHK_ERR(DXFILEERR_PARSEERROR, "Parse error")
        CHK_ERR(DXFILEERR_NOTEMPLATE, "No template")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, "Bad array size")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, "Bad data reference")
        CHK_ERR(DXFILEERR_INTERNALERROR, "Internal error")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, "No more objects")
        CHK_ERR(DXFILEERR_BADINTRINSICS, "Bad intrinsics")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, "No more stream handles")
        CHK_ERR(DXFILEERR_NOMOREDATA, "No more data")
        CHK_ERR(DXFILEERR_BADCACHEFILE, "Bad cache file")
        CHK_ERR(DXFILEERR_NOINTERNET, "No internet")
        
        
// -------------------------------------------------------------        
// d3d8.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(D3D_OK, "Ok")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, "Wrong texture format")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, "Unsupported color operation")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, "Unsupported color arg")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, "Unsupported alpha operation")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, "Unsupported alpha arg")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, "Too many operations")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, "Conflicting texture filter")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, "Unsupported factor value")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, "Conflicting render state")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, "Unsupported texture filter")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, "Conflicting texture palette")                
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, "Driver internal error")
        CHK_ERR(D3DERR_NOTFOUND, "Not found")
        CHK_ERR(D3DERR_MOREDATA, "More data")
        CHK_ERR(D3DERR_DEVICELOST, "Device lost")
        CHK_ERR(D3DERR_DEVICENOTRESET, "Device not reset")
        CHK_ERR(D3DERR_NOTAVAILABLE, "Not available")
        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, "Out of video memory")
        CHK_ERR(D3DERR_INVALIDDEVICE, "Invalid device")
        CHK_ERR(D3DERR_INVALIDCALL, "Invalid call")
        CHK_ERR(D3DERR_DRIVERINVALIDCALL, "Driver invalid call")                        
        
        
// -------------------------------------------------------------        
// d3dx8mesh.h error codes as of 12/5/00
// -------------------------------------------------------------                                
        CHK_ERR(D3DXERR_CANNOTMODIFYINDEXBUFFER, "Can not modify index buffer")                        
        CHK_ERR(D3DXERR_INVALIDMESH, "Invalid mesh")                        
        CHK_ERR(D3DXERR_CANNOTATTRSORT, "Cannot attr sort")                        
        CHK_ERR(D3DXERR_SKINNINGNOTSUPPORTED, "Skinning not supported")                        
        CHK_ERR(D3DXERR_TOOMANYINFLUENCES, "Too many influences")                        
        CHK_ERR(D3DXERR_INVALIDDATA, "Invalid data")                        


// -------------------------------------------------------------        
// dsound.h error codes as of 1/22/01
// -------------------------------------------------------------        
//      CHK_ERR(DS_OK, "")        
        CHK_ERR(DS_NO_VIRTUALIZATION, "The call succeeded, but we had to substitute the 3D algorithm")           
        CHK_ERR(DS_INCOMPLETE, "The call succeeded, but not all of the optional effects were obtained.")             
        CHK_ERR(DSERR_ALLOCATED, "The call failed because resources (such as a priority level) were already being used by another caller")
        CHK_ERR(DSERR_CONTROLUNAVAIL, "The control (vol, pan, etc.) requested by the caller is not available")
//      CHK_ERR(DSERR_INVALIDPARAM, "DSERR_INVALIDPARAM")                
        CHK_ERR(DSERR_INVALIDCALL, "This call is not valid for the current state of this object")
//      CHK_ERR(DSERR_GENERIC, "DSERR_GENERIC")                
        CHK_ERR(DSERR_PRIOLEVELNEEDED, "The caller does not have the priority level required for the function to succeed")
//      CHK_ERR(DSERR_OUTOFMEMORY, "Not enough free memory is available to complete the operation")                
        CHK_ERR(DSERR_BADFORMAT, "The specified WAVE format is not supported")
//      CHK_ERR(DSERR_UNSUPPORTED, "DSERR_UNSUPPORTED")                
        CHK_ERR(DSERR_NODRIVER, "No sound driver is available for use")
        CHK_ERR(DSERR_ALREADYINITIALIZED, "This object is already initialized")
//      CHK_ERR(DSERR_NOAGGREGATION, "DSERR_NOAGGREGATION")                
        CHK_ERR(DSERR_BUFFERLOST, "The buffer memory has been lost, and must be restored")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, "Another app has a higher priority level, preventing this call from succeeding")
        CHK_ERR(DSERR_UNINITIALIZED, "This object has not been initialized")
//      CHK_ERR(DSERR_NOINTERFACE, "DSERR_NOINTERFACE")                
//      CHK_ERR(DSERR_ACCESSDENIED, "DSERR_ACCESSDENIED")        
        CHK_ERR(DSERR_BUFFERTOOSMALL, "Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")        
        CHK_ERR(DSERR_DS8_REQUIRED, "Attempt to use DirectSound 8 functionality on an older DirectSound object")        
        CHK_ERR(DSERR_SENDLOOP, "A circular loop of send effects was detected")        
        CHK_ERR(DSERR_BADSENDBUFFERGUID, "The GUID specified in an audiopath file does not match a valid MIXIN buffer")        
        CHK_ERR(DSERR_OBJECTNOTFOUND, "The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)")                

// -------------------------------------------------------------        
// dmerror.h error codes as of 9/8/00
// -------------------------------------------------------------        
        CHK_ERR(DMUS_S_PARTIALLOAD, "The object could only load partially. This can happen if some components are not registered properly, such as embedded tracks and tools. This can also happen if some content is missing. For example, if a segment uses a DLS collection that is not in the loader's current search directory.")  
        CHK_ERR(DMUS_S_PARTIALDOWNLOAD, "Return value from IDirectMusicBand::Download() which indicates that some of the instruments safely downloaded, but others failed. This usually occurs when some instruments are on PChannels not supported by the performance or port.")    
        CHK_ERR(DMUS_S_REQUEUE, "Return value from IDirectMusicTool::ProcessPMsg() which indicates to the performance that it should cue the PMsg again automatically.")            
        CHK_ERR(DMUS_S_FREE, "Return value from IDirectMusicTool::ProcessPMsg() which indicates to the performance that it should free the PMsg automatically.")  
        CHK_ERR(DMUS_S_END, "Return value from IDirectMusicTrack::Play() which indicates to the segment that the track has no more data after mtEnd.")                
        CHK_ERR(DMUS_S_STRING_TRUNCATED, "Returned string has been truncated to fit the buffer size.")   
        CHK_ERR(DMUS_S_LAST_TOOL, "Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg is already stamped with the last tool in the graph. The returned PMsg's tool pointer is now NULL.")          
        CHK_ERR(DMUS_S_OVER_CHORD, "Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates  that no note has been calculated because the music value has the note  at a position higher than the top note of the chord. This applies only to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates that the caller should not do anything with the note. It is not meant to be played against this chord.")         
        CHK_ERR(DMUS_S_UP_OCTAVE, "Returned from IDirectMusicPerformance::MIDIToMusic(),  and IDirectMusicPerformance::MusicToMIDI(), this indicates  that the note conversion generated a note value that is below 0,  so it has been bumped up one or more octaves to be in the proper MIDI range of 0 through 127.  Note that this is valid for MIDIToMusic() when using play modes DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of which store MIDI values in wMusicValue. With MusicToMIDI(), it is valid for all play modes. Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.")          
        CHK_ERR(DMUS_S_DOWN_OCTAVE, "Returned from IDirectMusicPerformance::MIDIToMusic(),  and IDirectMusicPerformance::MusicToMIDI(), this indicates  that the note conversion generated a note value that is above 127, so it has been bumped down one or more octaves to be in the proper MIDI range of 0 through 127.  Note that this is valid for MIDIToMusic() when using play modes DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of which store MIDI values in wMusicValue. With MusicToMIDI(), it is valid for all play modes. Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.")        
        CHK_ERR(DMUS_S_NOBUFFERCONTROL, "Although the audio output from the port will be routed to the same device as the given DirectSound buffer, buffer controls such as pan and volume will not affect the output.")    
        CHK_ERR(DMUS_S_GARBAGE_COLLECTED, "The requested operation was not performed because during CollectGarbage the loader determined that the object had been released.")  
        CHK_ERR(DMUS_E_DRIVER_FAILED, "An unexpected error was returned from a device driver, indicating possible failure of the driver or hardware.")
        CHK_ERR(DMUS_E_PORTS_OPEN, "The requested operation cannot be performed while there are  instantiated ports in any process in the system.")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, "The requested device is already in use (possibly by a non-DirectMusic client) and cannot be opened again.")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, "Buffer is not large enough for requested operation.")
        CHK_ERR(DMUS_E_BUFFERNOTSET, "No buffer was prepared for the download data.")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, "Download failed due to inability to access or create download buffer.")
        CHK_ERR(DMUS_E_NOTADLSCOL, "Error parsing DLS collection. File is corrupt.")
        CHK_ERR(DMUS_E_INVALIDOFFSET, "Wave chunks in DLS collection file are at incorrect offsets.")
        CHK_ERR(DMUS_E_ALREADY_LOADED, "Second attempt to load a DLS collection that is currently open. ")
        CHK_ERR(DMUS_E_INVALIDPOS, "Error reading wave data from DLS collection. Indicates bad file.")
        CHK_ERR(DMUS_E_INVALIDPATCH, "There is no instrument in the collection that matches patch number.")
        CHK_ERR(DMUS_E_CANNOTSEEK, "The IStream* doesn't support Seek().")
        CHK_ERR(DMUS_E_CANNOTWRITE, "The IStream* doesn't support Write().")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, "The RIFF parser doesn't contain a required chunk while parsing file.")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, "Invalid download id was used in the process of creating a download buffer.")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, "Tried to unload an object that was not downloaded or previously unloaded.")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, "Buffer was already downloaded to synth.")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, "The specified property item was not recognized by the target object.")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, "The specified property item may not be set on the target object.")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, "* The specified property item may not be retrieved from the target object.")
        CHK_ERR(DMUS_E_NOTMONO, "Wave chunk has more than one interleaved channel. DLS format requires MONO.")
        CHK_ERR(DMUS_E_BADARTICULATION, "Invalid articulation chunk in DLS collection.")
        CHK_ERR(DMUS_E_BADINSTRUMENT, "Invalid instrument chunk in DLS collection.")
        CHK_ERR(DMUS_E_BADWAVELINK, "Wavelink chunk in DLS collection points to invalid wave.")
        CHK_ERR(DMUS_E_NOARTICULATION, "Articulation missing from instrument in DLS collection.")
        CHK_ERR(DMUS_E_NOTPCM, "Downoaded DLS wave is not in PCM format. ")
        CHK_ERR(DMUS_E_BADWAVE, "Bad wave chunk in DLS collection")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, "Offset Table for download buffer has errors. ")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, "Attempted to download unknown data type.")
        CHK_ERR(DMUS_E_NOSYNTHSINK, "The operation could not be completed because no sink was connected to the synthesizer.")
        CHK_ERR(DMUS_E_ALREADYOPEN, "An attempt was made to open the software synthesizer while it was already  open.")
        CHK_ERR(DMUS_E_ALREADYCLOSED, "An attempt was made to close the software synthesizer while it was already  open.")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, "The operation could not be completed because the software synth has not  yet been fully configured.")
        CHK_ERR(DMUS_E_SYNTHACTIVE, "The operation cannot be carried out while the synthesizer is active.")
        CHK_ERR(DMUS_E_CANNOTREAD, "An error occurred while attempting to read from the IStream* object.")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, "The operation cannot be performed because the final instance of the DirectMusic object was released. Ports cannot be used after final  release of the DirectMusic object.")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, "There was no data in the referenced buffer.")
        CHK_ERR(DMUS_E_BUFFER_FULL, "There is insufficient space to insert the given event into the buffer.")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, "The given operation could not be carried out because the port is a capture port.")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, "The given operation could not be carried out because the port is a render port.")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, "The port could not be created because no DirectSound has been specified. Specify a DirectSound interface via the IDirectMusic::SetDirectSound method; pass NULL to have DirectMusic manage usage of DirectSound.")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, "The operation cannot be carried out while the port is active.")
        CHK_ERR(DMUS_E_INVALIDBUFFER, "Invalid DirectSound buffer was handed to port. ")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, "Invalid buffer format was handed to the synth sink.")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, "The operation cannot be carried out while the synthesizer is inactive.")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, "IDirectMusic::SetDirectSound has already been called. It may not be changed while in use.")
        CHK_ERR(DMUS_E_INVALID_EVENT, "The given event is invalid (either it is not a valid MIDI message or it makes use of running status). The event cannot be packed into the buffer.")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, "The IStream* object does not contain data supported by the loading object.")
        CHK_ERR(DMUS_E_ALREADY_INITED, "The object has already been initialized.")
        CHK_ERR(DMUS_E_INVALID_BAND, "The file does not contain a valid band.")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, "The IStream* object's data does not have a track header as the first chunk, and therefore can not be read by the segment object.")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, "The IStream* object's data does not have a tool header as the first chunk, and therefore can not be read by the graph object.")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, "The IStream* object's data contains an invalid track header (ckid is 0 and fccType is NULL,) and therefore can not be read by the segment object.")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, "The IStream* object's data contains an invalid tool header (ckid is 0 and fccType is NULL,) and therefore can not be read by the graph object.")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, "The graph object was unable to load all tools from the IStream* object data. This may be due to errors in the stream, or the tools being incorrectly registered on the client.")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, "The segment object was unable to load all tracks from the IStream* object data. This may be due to errors in the stream, or the tracks being incorrectly registered on the client.")
//      CHK_ERR(DMUS_E_NOT_FOUND, "DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, "A required object is not initialized or failed to initialize.")
        CHK_ERR(DMUS_E_TYPE_DISABLED, "The requested parameter type is currently disabled. Parameter types may be enabled and disabled by certain calls to SetParam().")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, "The requested parameter type is not supported on the object.")
        CHK_ERR(DMUS_E_TIME_PAST, "The time is in the past, and the operation can not succeed.")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, "The requested track is not contained by the segment.")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, "The track does not support clock time playback or getparam.")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, "There is no master clock in the performance. Be sure to call IDirectMusicPerformance::Init().")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, "The class id field is required and missing in the DMUS_OBJECTDESC.")
        CHK_ERR(DMUS_E_LOADER_BADPATH, "The requested file path is invalid.")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, "File open failed - either file doesn't exist or is locked.")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, "Search data type is not supported.")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, "Unable to find or create object.")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, "Object was not found.")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, "The file name is missing from the DMUS_OBJECTDESC.")
        CHK_ERR(DMUS_E_INVALIDFILE, "The file requested is not a valid file.")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, "The tool is already contained in the graph. Create a new instance.")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, "Value is out of range, for instance the requested length is longer than the segment.")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, "Segment initialization failed, most likely due to a critical memory situation.")
        CHK_ERR(DMUS_E_ALREADY_SENT, "The DMUS_PMSG has already been sent to the performance object via IDirectMusicPerformance::SendPMsg().")
        CHK_ERR(DMUS_E_CANNOT_FREE, "The DMUS_PMSG was either not allocated by the performance via IDirectMusicPerformance::AllocPMsg(), or it was already freed via IDirectMusicPerformance::FreePMsg().")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, "The default system port could not be opened.")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, "A call to MIDIToMusic() or MusicToMIDI() resulted in an error because the requested conversion could not happen. This usually occurs when the provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, "DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file  was reached before the desired chunk was found.")
        CHK_ERR(DMUS_E_NOT_LOADED, "An attempt to use this object failed because it first needs to be loaded.")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, "The activeX scripting engine for the script's language is not compatible with DirectMusic.")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, "A varient was used that had a type that is not supported by DirectMusic.")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, "An error was encountered while parsing or executing the script. The pErrorInfo parameter (if supplied) was filled with information about the error.")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, "Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only the DirectMusicScript language, which doesn't require oleaut32.dll can be used.")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, "An error occured while parsing a script loaded using LoadScript.  The script that was loaded contains an error.")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, "The script file is invalid.")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, "The file contains an invalid script track.")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, "The script does not contain a variable with the specified name.")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, "The script does not contain a routine with the specified name.")
        CHK_ERR(DMUS_E_SCRIPT_CONTENT_READONLY, "Scripts variables for content referenced or embedded in a script cannot be set.")
        CHK_ERR(DMUS_E_SCRIPT_NOT_A_REFERENCE, "Attempt was made to set a script's variable by reference to a value that was not an object type.")
        CHK_ERR(DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED, "Attempt was made to set a script's variable by value to an object that does not support a default value property.")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, "The file contains an invalid segment trigger track.")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, "The file contains an invalid lyrics track.")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, "The file contains an invalid parameter control track.")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, "A script written in AudioVBScript could not be read because it contained a statement that is not allowed by the AudioVBScript language.")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, "A script routine written in AudioVBScript failed because an invalid operation occurred.  For example, adding the number 3 to a segment object would produce this error.  So would attempting to call a routine that doesn't exist.")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, "A script routine written in AudioVBScript failed because a function outside of a script failed to complete. For example, a call to PlaySegment that fails to play because of low memory would return this error.")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, "The Performance has set up some PChannels using the AssignPChannel command, which makes it not capable of supporting audio paths.")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, "This is the inverse of the previous error. The Performance has set up some audio paths, which makes is incompatible with the calls to allocate pchannels, etc. ")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, "A segment or song was asked for its embedded audio path configuration, but there isn't any. ")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, "An audiopath is inactive, perhaps because closedown was called.")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, "An audiopath failed to create because a requested buffer could not be created.")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, "An audiopath could not be used for playback because it lacked port assignments.")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, "Attempt was made to play segment in audiopath mode and there was no audiopath.")
        CHK_ERR(DMUS_E_INVALIDCHUNK, "Invalid data was found in a RIFF file chunk.")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, "Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, "The file does not contain a valid container object.")    
   
// -------------------------------------------------------------        
// vfwmsgs.h error codes as of 9/8/00
// -------------------------------------------------------------        
//      CHK_ERR(VFW_E_INVALIDMEDIATYPE, "VFW_E_INVALIDMEDIATYPE")
//      CHK_ERR(VFW_E_INVALIDSUBTYPE, "VFW_E_INVALIDSUBTYPE")
//      CHK_ERR(VFW_E_NEED_OWNER, "VFW_E_NEED_OWNER")
//      CHK_ERR(VFW_E_ENUM_OUT_OF_SYNC, "VFW_E_ENUM_OUT_OF_SYNC")
//      CHK_ERR(VFW_E_ALREADY_CONNECTED, "VFW_E_ALREADY_CONNECTED")
//      CHK_ERR(VFW_E_FILTER_ACTIVE, "VFW_E_FILTER_ACTIVE")
//      CHK_ERR(VFW_E_NO_TYPES, "VFW_E_NO_TYPES")
//      CHK_ERR(VFW_E_NO_ACCEPTABLE_TYPES, "VFW_E_NO_ACCEPTABLE_TYPES")
//      CHK_ERR(VFW_E_INVALID_DIRECTION, "VFW_E_INVALID_DIRECTION")
//      CHK_ERR(VFW_E_NOT_CONNECTED, "VFW_E_NOT_CONNECTED")
//      CHK_ERR(VFW_E_NO_ALLOCATOR, "VFW_E_NO_ALLOCATOR")
//      CHK_ERR(VFW_E_RUNTIME_ERROR, "VFW_E_RUNTIME_ERROR")
        CHK_ERR(VFW_E_BUFFER_NOTSET, "No buffer space has been set")
        CHK_ERR(VFW_E_BUFFER_OVERFLOW, "The buffer is not big enough.")
        CHK_ERR(VFW_E_BADALIGN, "An invalid alignment was specified.")
        CHK_ERR(VFW_E_ALREADY_COMMITTED, "Cannot change allocated memory while the filter is active.")
        CHK_ERR(VFW_E_BUFFERS_OUTSTANDING, "One or more buffers are still active.")
        CHK_ERR(VFW_E_NOT_COMMITTED, "Cannot allocate a sample when the allocator is not active.")
        CHK_ERR(VFW_E_SIZENOTSET, "Cannot allocate memory because no size has been set.")
        CHK_ERR(VFW_E_NO_CLOCK, "Cannot lock for synchronization because no clock has been defined.")
        CHK_ERR(VFW_E_NO_SINK, "Quality messages could not be sent because no quality sink has been defined.")
        CHK_ERR(VFW_E_NO_INTERFACE, "A required interface has not been implemented.")
        CHK_ERR(VFW_E_NOT_FOUND, "An object or name was not found.")
        CHK_ERR(VFW_E_CANNOT_CONNECT, "No combination of intermediate filters could be found to make the connection.")
        CHK_ERR(VFW_E_CANNOT_RENDER, "No combination of filters could be found to render the stream.")
        CHK_ERR(VFW_E_CHANGING_FORMAT, "Could not change formats dynamically.")
        CHK_ERR(VFW_E_NO_COLOR_KEY_SET, "No color key has been set.")
        CHK_ERR(VFW_E_NOT_OVERLAY_CONNECTION, "Current pin connection is not using the IOverlay transport.")
        CHK_ERR(VFW_E_NOT_SAMPLE_CONNECTION, "Current pin connection is not using the IMemInputPin transport.")
        CHK_ERR(VFW_E_PALETTE_SET, "Setting a color key would conflict with the palette already set.")
        CHK_ERR(VFW_E_COLOR_KEY_SET, "Setting a palette would conflict with the color key already set.")
        CHK_ERR(VFW_E_NO_COLOR_KEY_FOUND, "No matching color key is available.")
        CHK_ERR(VFW_E_NO_PALETTE_AVAILABLE, "No palette is available.")
        CHK_ERR(VFW_E_NO_DISPLAY_PALETTE, "Display does not use a palette.")
        CHK_ERR(VFW_E_TOO_MANY_COLORS, "Too many colors for the current display settings.")
        CHK_ERR(VFW_E_STATE_CHANGED, "The state changed while waiting to process the sample.")
        CHK_ERR(VFW_E_NOT_STOPPED, "The operation could not be performed because the filter is not stopped.")
        CHK_ERR(VFW_E_NOT_PAUSED, "The operation could not be performed because the filter is not paused.")
        CHK_ERR(VFW_E_NOT_RUNNING, "The operation could not be performed because the filter is not running.")
        CHK_ERR(VFW_E_WRONG_STATE, "The operation could not be performed because the filter is in the wrong state.")
        CHK_ERR(VFW_E_START_TIME_AFTER_END, "The sample start time is after the sample end time.")
        CHK_ERR(VFW_E_INVALID_RECT, "The supplied rectangle is invalid.")
        CHK_ERR(VFW_E_TYPE_NOT_ACCEPTED, "This pin cannot use the supplied media type.")
        CHK_ERR(VFW_E_SAMPLE_REJECTED, "This sample cannot be rendered.")
        CHK_ERR(VFW_E_SAMPLE_REJECTED_EOS, "This sample cannot be rendered because the end of the stream has been reached.")
        CHK_ERR(VFW_E_DUPLICATE_NAME, "An attempt to add a filter with a duplicate name failed.")
        CHK_ERR(VFW_S_DUPLICATE_NAME, "An attempt to add a filter with a duplicate name succeeded with a modified name.")
        CHK_ERR(VFW_E_TIMEOUT, "A time-out has expired.")
        CHK_ERR(VFW_E_INVALID_FILE_FORMAT, "The file format is invalid.")
        CHK_ERR(VFW_E_ENUM_OUT_OF_RANGE, "The list has already been exhausted.")
        CHK_ERR(VFW_E_CIRCULAR_GRAPH, "The filter graph is circular.")
        CHK_ERR(VFW_E_NOT_ALLOWED_TO_SAVE, "Updates are not allowed in this state.")
        CHK_ERR(VFW_E_TIME_ALREADY_PASSED, "An attempt was made to queue a command for a time in the past.")
        CHK_ERR(VFW_E_ALREADY_CANCELLED, "The queued command has already been canceled.")
        CHK_ERR(VFW_E_CORRUPT_GRAPH_FILE, "Cannot render the file because it is corrupt.")
        CHK_ERR(VFW_E_ADVISE_ALREADY_SET, "An overlay advise link already exists.")
        CHK_ERR(VFW_S_STATE_INTERMEDIATE, "The state transition has not completed.")
        CHK_ERR(VFW_E_NO_MODEX_AVAILABLE, "No full-screen modes are available.")
        CHK_ERR(VFW_E_NO_ADVISE_SET, "This Advise cannot be canceled because it was not successfully set.")
        CHK_ERR(VFW_E_NO_FULLSCREEN, "A full-screen mode is not available.")
        CHK_ERR(VFW_E_IN_FULLSCREEN_MODE, "Cannot call IVideoWindow methods while in full-screen mode.")
        CHK_ERR(VFW_E_UNKNOWN_FILE_TYPE, "The media type of this file is not recognized.")
        CHK_ERR(VFW_E_CANNOT_LOAD_SOURCE_FILTER, "The source filter for this file could not be loaded.")
        CHK_ERR(VFW_S_PARTIAL_RENDER, "Some of the streams in this movie are in an unsupported format.")
        CHK_ERR(VFW_E_FILE_TOO_SHORT, "A file appeared to be incomplete.")
        CHK_ERR(VFW_E_INVALID_FILE_VERSION, "The version number of the file is invalid.")
        CHK_ERR(VFW_S_SOME_DATA_IGNORED, "The file contained some property settings that were not used.")
        CHK_ERR(VFW_S_CONNECTIONS_DEFERRED, "Some connections have failed and have been deferred.")
        CHK_ERR(VFW_E_INVALID_CLSID, "This file is corrupt: it contains an invalid class identifier.")
        CHK_ERR(VFW_E_INVALID_MEDIA_TYPE, "This file is corrupt: it contains an invalid media type.")
        CHK_ERR(VFW_E_BAD_KEY, "A registry entry is corrupt.")
        CHK_ERR(VFW_S_NO_MORE_ITEMS, "The end of the list has been reached.")
        CHK_ERR(VFW_E_SAMPLE_TIME_NOT_SET, "No time stamp has been set for this sample.")
        CHK_ERR(VFW_S_RESOURCE_NOT_NEEDED, "The resource specified is no longer needed.")
        CHK_ERR(VFW_E_MEDIA_TIME_NOT_SET, "No media time stamp has been set for this sample.")
        CHK_ERR(VFW_E_NO_TIME_FORMAT_SET, "No media time format has been selected.")
        CHK_ERR(VFW_E_MONO_AUDIO_HW, "Cannot change balance because audio device is mono only.")
        CHK_ERR(VFW_S_MEDIA_TYPE_IGNORED, "A connection could not be made with the media type in the persistent graph, but has been made with a negotiated media type.")
        CHK_ERR(VFW_E_NO_DECOMPRESSOR, "Cannot play back the video stream: no suitable decompressor could be found.")
        CHK_ERR(VFW_E_NO_AUDIO_HARDWARE, "Cannot play back the audio stream: no audio hardware is available, or the hardware is not responding.")
        CHK_ERR(VFW_S_VIDEO_NOT_RENDERED, "Cannot play back the video stream: no suitable decompressor could be found.")
        CHK_ERR(VFW_S_AUDIO_NOT_RENDERED, "Cannot play back the audio stream: no audio hardware is available.")
        CHK_ERR(VFW_E_RPZA, "Cannot play back the video stream: format 'RPZA' is not supported.")
        CHK_ERR(VFW_S_RPZA, "Cannot play back the video stream: format 'RPZA' is not supported.")
        CHK_ERR(VFW_E_PROCESSOR_NOT_SUITABLE, "ActiveMovie cannot play MPEG movies on this processor.")
        CHK_ERR(VFW_E_UNSUPPORTED_AUDIO, "Cannot play back the audio stream: the audio format is not supported.")
        CHK_ERR(VFW_E_UNSUPPORTED_VIDEO, "Cannot play back the video stream: the video format is not supported.")
        CHK_ERR(VFW_E_MPEG_NOT_CONSTRAINED, "ActiveMovie cannot play this video stream because it falls outside the constrained standard.")
        CHK_ERR(VFW_E_NOT_IN_GRAPH, "Cannot perform the requested function on an object that is not in the filter graph.")
        CHK_ERR(VFW_S_ESTIMATED, "The value returned had to be estimated.  It's accuracy can not be guaranteed.")
        CHK_ERR(VFW_E_NO_TIME_FORMAT, "Cannot get or set time related information on an object that is using a time format of TIME_FORMAT_NONE.")
        CHK_ERR(VFW_E_READ_ONLY, "The connection cannot be made because the stream is read only and the filter alters the data.")
        CHK_ERR(VFW_S_RESERVED, "This success code is reserved for internal purposes within ActiveMovie.")
        CHK_ERR(VFW_E_BUFFER_UNDERFLOW, "The buffer is not full enough.")
        CHK_ERR(VFW_E_UNSUPPORTED_STREAM, "Cannot play back the file.  The format is not supported.")
        CHK_ERR(VFW_E_NO_TRANSPORT, "Pins cannot connect due to not supporting the same transport.")
        CHK_ERR(VFW_S_STREAM_OFF, "The stream has been turned off.")
        CHK_ERR(VFW_S_CANT_CUE, "The graph can't be cued because of lack of or corrupt data.")
        CHK_ERR(VFW_E_BAD_VIDEOCD, "The Video CD can't be read correctly by the device or is the data is corrupt.")
        CHK_ERR(VFW_S_NO_STOP_TIME, "The stop time for the sample was not set.")
        CHK_ERR(VFW_E_OUT_OF_VIDEO_MEMORY, "There is not enough Video Memory at this display resolution and number of colors. Reducing resolution might help.")
        CHK_ERR(VFW_E_VP_NEGOTIATION_FAILED, "The VideoPort connection negotiation process has failed.")
        CHK_ERR(VFW_E_DDRAW_CAPS_NOT_SUITABLE, "Either DirectDraw has not been installed or the Video Card capabilities are not suitable. Make sure the display is not in 16 color mode.")
        CHK_ERR(VFW_E_NO_VP_HARDWARE, "No VideoPort hardware is available, or the hardware is not responding.")
        CHK_ERR(VFW_E_NO_CAPTURE_HARDWARE, "No Capture hardware is available, or the hardware is not responding.")
        CHK_ERR(VFW_E_DVD_OPERATION_INHIBITED, "This User Operation is inhibited by DVD Content at this time.")
        CHK_ERR(VFW_E_DVD_INVALIDDOMAIN, "This Operation is not permitted in the current domain.")
        CHK_ERR(VFW_E_DVD_NO_BUTTON, "The specified button is invalid or is not present at the current time, or there is no button present at the specified location.")
        CHK_ERR(VFW_E_DVD_GRAPHNOTREADY, "DVD-Video playback graph has not been built yet.")
        CHK_ERR(VFW_E_DVD_RENDERFAIL, "DVD-Video playback graph building failed.")
        CHK_ERR(VFW_E_DVD_DECNOTENOUGH, "DVD-Video playback graph could not be built due to insufficient decoders.")
        CHK_ERR(VFW_E_DDRAW_VERSION_NOT_SUITABLE, "Version number of DirectDraw not suitable. Make sure to install dx5 or higher version.")
        CHK_ERR(VFW_E_COPYPROT_FAILED, "Copy protection cannot be enabled. Please make sure any other copy protected content is not being shown now.")
        CHK_ERR(VFW_S_NOPREVIEWPIN, "There was no preview pin available, so the capture pin output is being split to provide both capture and preview.")
        CHK_ERR(VFW_E_TIME_EXPIRED, "This object cannot be used anymore as its time has expired.")
        CHK_ERR(VFW_S_DVD_NON_ONE_SEQUENTIAL, "The current title was not a sequential set of chapters (PGC), and the returned timing information might not be continuous.")
        CHK_ERR(VFW_E_DVD_WRONG_SPEED, "The operation cannot be performed at the current playback speed.")
        CHK_ERR(VFW_E_DVD_MENU_DOES_NOT_EXIST, "The specified menu doesn't exist.")
        CHK_ERR(VFW_E_DVD_CMD_CANCELLED, "The specified command was either cancelled or no longer exists.")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_VERSION, "The data did not contain a recognized version.")
        CHK_ERR(VFW_E_DVD_STATE_CORRUPT, "The state data was corrupt.")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_DISC, "The state data is from a different disc.")
        CHK_ERR(VFW_E_DVD_INCOMPATIBLE_REGION, "The region was not compatible with the current drive.")
        CHK_ERR(VFW_E_DVD_NO_ATTRIBUTES, "The requested DVD stream attribute does not exist.")
        CHK_ERR(VFW_E_DVD_NO_GOUP_PGC, "Currently there is no GoUp (Annex J user function) program chain (PGC).")
        CHK_ERR(VFW_E_DVD_LOW_PARENTAL_LEVEL, "The current parental level was too low.")
        CHK_ERR(VFW_E_DVD_NOT_IN_KARAOKE_MODE, "The current audio is not karaoke content.")
        CHK_ERR(VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE, "The audio stream did not contain sufficient information to determine the contents of each channel.")
        CHK_ERR(VFW_S_DVD_NOT_ACCURATE, "The seek into the movie was not frame accurate.")
        CHK_ERR(VFW_E_FRAME_STEP_UNSUPPORTED, "Frame step is not supported on this configuration.")
        CHK_ERR(VFW_E_DVD_STREAM_DISABLED, "The specified stream is disabled and cannot be selected.")
        CHK_ERR(VFW_E_DVD_TITLE_UNKNOWN, "The operation depends on the current title number, however the navigator has not yet entered the VTSM or the title domains, so the 'current' title index is unknown.")
        CHK_ERR(VFW_E_DVD_INVALID_DISC, "The specified path does not point to a valid DVD disc.")
        CHK_ERR(VFW_E_DVD_NO_RESUME_INFORMATION, "There is currently no resume information.")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD, "This thread has already blocked this output pin.  There is no need to call IPinFlowControl::Block() again.")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED, "IPinFlowControl::Block() has been called on another thread.  The current thread cannot make any assumptions about this pin's block state.")
        CHK_ERR(VFW_E_CERTIFICATION_FAILURE, "An operation failed due to a certification failure.")
        CHK_ERR(E_PROP_SET_UNSUPPORTED, "The Specified property set is not supported.")
        CHK_ERR(E_PROP_ID_UNSUPPORTED, "The specified property ID is not supported for the specified property set.")
   }
   
   return "n/a";
}




//-----------------------------------------------------------------------------
// Name: DXGetErrorDescription8W()
// Desc: Returns a description of the HRESULT 
//-----------------------------------------------------------------------------
const WCHAR * WINAPI DXGetErrorDescription8W(HRESULT hr)
{
   switch(hr)
   {     
// -------------------------------------------------------------        
// Common Win32 error codes
// -------------------------------------------------------------        
        CHK_ERR(S_OK, L"The function completed successfully")        
        CHK_ERR(S_FALSE, L"Call successful, but returned FALSE")
        
        CHK_ERR(ERROR_FILE_NOT_FOUND, L"The system cannot find the file specified.")
        CHK_ERR(ERROR_PATH_NOT_FOUND, L"The system cannot find the path specified.")
        CHK_ERR(ERROR_TOO_MANY_OPEN_FILES, L"The system cannot open the file.")
        CHK_ERR(ERROR_ACCESS_DENIED, L"Access is denied.")
        CHK_ERR(ERROR_INVALID_HANDLE, L"The handle is invalid.")
        CHK_ERR(ERROR_NOT_ENOUGH_MEMORY, L"Not enough storage is available to process this command.")
        CHK_ERR(ERROR_INVALID_BLOCK, L"The storage control block address is invalid.")
        CHK_ERR(ERROR_BAD_ENVIRONMENT, L"The environment is incorrect.")
        CHK_ERR(ERROR_BAD_FORMAT, L"An attempt was made to load a program with an incorrect format.")
        CHK_ERR(ERROR_OUTOFMEMORY, L"The system cannot find the drive specified.")
                
        CHK_ERR(E_UNEXPECTED, L"Catastrophic failure")
        CHK_ERR(E_NOTIMPL, L"The function called is not supported at this time")
        CHK_ERR(E_OUTOFMEMORY, L"Ran out of memory")
        CHK_ERR(E_INVALIDARG, L"An invalid parameter was passed to the returning function")
        CHK_ERR(E_NOINTERFACE, L"The requested COM interface is not available")
        CHK_ERR(E_POINTER, L"Invalid pointer")
        CHK_ERR(E_HANDLE, L"Invalid handle")
        CHK_ERR(E_ABORT, L"Operation aborted")
        CHK_ERR(E_FAIL, L"An undetermined error occurred")
        CHK_ERR(E_ACCESSDENIED, L"Access is denied")
        CHK_ERR(E_PENDING, L"The data necessary to complete this operation is not yet available.")
        CHK_ERR(REGDB_E_CLASSNOTREG, L"Class not registered")
        CHK_ERR(CO_E_NOTINITIALIZED, L"CoInitialize has not been called.")
        CHK_ERR(CO_E_ALREADYINITIALIZED, L"CoInitialize has already been called.")
        CHK_ERR(CLASS_E_NOAGGREGATION, L"This object does not support aggregation")

// -------------------------------------------------------------        
// ddraw.h error codes as of 1/22/01
// -------------------------------------------------------------                
        CHK_ERR(DDERR_ALREADYINITIALIZED, L"This object is already initialized")
        CHK_ERR(DDERR_CANNOTATTACHSURFACE, L"This surface can not be attached to the requested surface.")
        CHK_ERR(DDERR_CANNOTDETACHSURFACE, L"This surface can not be detached from the requested surface.")
        CHK_ERR(DDERR_CURRENTLYNOTAVAIL, L"Support is currently not available.")
        CHK_ERR(DDERR_EXCEPTION, L"An exception was encountered while performing the requested operation")
//      CHK_ERR(DDERR_GENERIC, L"DDERR_GENERIC")
        CHK_ERR(DDERR_HEIGHTALIGN, L"Height of rectangle provided is not a multiple of reqd alignment")
        CHK_ERR(DDERR_INCOMPATIBLEPRIMARY, L"Unable to match primary surface creation request with existing primary surface.")
        CHK_ERR(DDERR_INVALIDCAPS, L"One or more of the caps bits passed to the callback are incorrect.")
        CHK_ERR(DDERR_INVALIDCLIPLIST, L"DirectDraw does not support provided Cliplist.")
        CHK_ERR(DDERR_INVALIDMODE, L"DirectDraw does not support the requested mode")
        CHK_ERR(DDERR_INVALIDOBJECT, L"DirectDraw received a pointer that was an invalid DIRECTDRAW object.")
//        CHK_ERR(DDERR_INVALIDPARAMS, L"DDERR_INVALIDPARAMS")
        CHK_ERR(DDERR_INVALIDPIXELFORMAT, L"pixel format was invalid as specified")
        CHK_ERR(DDERR_INVALIDRECT, L"Rectangle provided was invalid.")
        CHK_ERR(DDERR_LOCKEDSURFACES, L"Operation could not be carried out because one or more surfaces are locked")
        CHK_ERR(DDERR_NO3D, L"There is no 3D present.")
        CHK_ERR(DDERR_NOALPHAHW, L"Operation could not be carried out because there is no alpha accleration hardware present or available.")
        CHK_ERR(DDERR_NOSTEREOHARDWARE, L"Operation could not be carried out because there is no stereo hardware present or available.")
        CHK_ERR(DDERR_NOSURFACELEFT, L"Operation could not be carried out because there is no hardware present which supports stereo surfaces")
        CHK_ERR(DDERR_NOCLIPLIST, L"no clip list available")
        CHK_ERR(DDERR_NOCOLORCONVHW, L"Operation could not be carried out because there is no color conversion hardware present or available.")
        CHK_ERR(DDERR_NOCOOPERATIVELEVELSET, L"Create function called without DirectDraw object method SetCooperativeLevel being called.")
        CHK_ERR(DDERR_NOCOLORKEY, L"Surface doesn't currently have a color key")
        CHK_ERR(DDERR_NOCOLORKEYHW, L"Operation could not be carried out because there is no hardware support of the dest color key.")
        CHK_ERR(DDERR_NODIRECTDRAWSUPPORT, L"No DirectDraw support possible with current display driver")
        CHK_ERR(DDERR_NOEXCLUSIVEMODE, L"Operation requires the application to have exclusive mode but the application does not have exclusive mode.")
        CHK_ERR(DDERR_NOFLIPHW, L"Flipping visible surfaces is not supported.")
        CHK_ERR(DDERR_NOGDI, L"There is no GDI present.")
        CHK_ERR(DDERR_NOMIRRORHW, L"Operation could not be carried out because there is no hardware present or available.")
        CHK_ERR(DDERR_NOTFOUND, L"Requested item was not found")
        CHK_ERR(DDERR_NOOVERLAYHW, L"Operation could not be carried out because there is no overlay hardware present or available.")
        CHK_ERR(DDERR_OVERLAPPINGRECTS, L"Operation could not be carried out because the source and destination rectangles are on the same surface and overlap each other.")
        CHK_ERR(DDERR_NORASTEROPHW, L"Operation could not be carried out because there is no appropriate raster op hardware present or available.")
        CHK_ERR(DDERR_NOROTATIONHW, L"Operation could not be carried out because there is no rotation hardware present or available.")
        CHK_ERR(DDERR_NOSTRETCHHW, L"Operation could not be carried out because there is no hardware support for stretching")
        CHK_ERR(DDERR_NOT4BITCOLOR, L"DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.")
        CHK_ERR(DDERR_NOT4BITCOLORINDEX, L"DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.")
        CHK_ERR(DDERR_NOT8BITCOLOR, L"DirectDraw Surface is not in 8 bit color mode and the requested operation requires 8 bit color.")
        CHK_ERR(DDERR_NOTEXTUREHW, L"Operation could not be carried out because there is no texture mapping hardware present or available.")
        CHK_ERR(DDERR_NOVSYNCHW, L"Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.")
        CHK_ERR(DDERR_NOZBUFFERHW, L"Operation could not be carried out because there is no hardware support for zbuffer blting.")
        CHK_ERR(DDERR_NOZOVERLAYHW, L"Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.")
        CHK_ERR(DDERR_OUTOFCAPS, L"The hardware needed for the requested operation has already been allocated.")
//        CHK_ERR(DDERR_OUTOFMEMORY, L"DDERR_OUTOFMEMORY")
//        CHK_ERR(DDERR_OUTOFVIDEOMEMORY, L"DDERR_OUTOFVIDEOMEMORY")
        CHK_ERR(DDERR_OVERLAYCANTCLIP, L"hardware does not support clipped overlays")
        CHK_ERR(DDERR_OVERLAYCOLORKEYONLYONEACTIVE, L"Can only have ony color key active at one time for overlays")
        CHK_ERR(DDERR_PALETTEBUSY, L"Access to this palette is being refused because the palette is already locked by another thread.")
        CHK_ERR(DDERR_COLORKEYNOTSET, L"No src color key specified for this operation.")
        CHK_ERR(DDERR_SURFACEALREADYATTACHED, L"This surface is already attached to the surface it is being attached to.")
        CHK_ERR(DDERR_SURFACEALREADYDEPENDENT, L"This surface is already a dependency of the surface it is being made a dependency of.")
        CHK_ERR(DDERR_SURFACEBUSY, L"Access to this surface is being refused because the surface is already locked by another thread.")
        CHK_ERR(DDERR_CANTLOCKSURFACE, L"Access to this surface is being refused because no driver exists which can supply a pointer to the surface. This is most likely to happen when attempting to lock the primary surface when no DCI provider is present. Will also happen on attempts to lock an optimized surface.")
        CHK_ERR(DDERR_SURFACEISOBSCURED, L"Access to Surface refused because Surface is obscured.")
        CHK_ERR(DDERR_SURFACELOST, L"Access to this surface is being refused because the surface is gone. The DIRECTDRAWSURFACE object representing this surface should have Restore called on it.")
        CHK_ERR(DDERR_SURFACENOTATTACHED, L"The requested surface is not attached.")
        CHK_ERR(DDERR_TOOBIGHEIGHT, L"Height requested by DirectDraw is too large.")
        CHK_ERR(DDERR_TOOBIGSIZE, L"Size requested by DirectDraw is too large --  The individual height and width are OK.")
        CHK_ERR(DDERR_TOOBIGWIDTH, L"Width requested by DirectDraw is too large.")
//        CHK_ERR(DDERR_UNSUPPORTED, L"DDERR_UNSUPPORTED")
        CHK_ERR(DDERR_UNSUPPORTEDFORMAT, L"Pixel format requested is unsupported by DirectDraw")
        CHK_ERR(DDERR_UNSUPPORTEDMASK, L"Bitmask in the pixel format requested is unsupported by DirectDraw")
        CHK_ERR(DDERR_INVALIDSTREAM, L"The specified stream contains invalid data")
        CHK_ERR(DDERR_VERTICALBLANKINPROGRESS, L"vertical blank is in progress")
        CHK_ERR(DDERR_WASSTILLDRAWING, L"Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.")
        CHK_ERR(DDERR_DDSCAPSCOMPLEXREQUIRED, L"The specified surface type requires specification of the COMPLEX flag")
        CHK_ERR(DDERR_XALIGN, L"Rectangle provided was not horizontally aligned on reqd. boundary")
        CHK_ERR(DDERR_INVALIDDIRECTDRAWGUID, L"The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.")
        CHK_ERR(DDERR_DIRECTDRAWALREADYCREATED, L"A DirectDraw object representing this driver has already been created for this process.")
        CHK_ERR(DDERR_NODIRECTDRAWHW, L"A hardware only DirectDraw object creation was attempted but the driver did not support any hardware.")
        CHK_ERR(DDERR_PRIMARYSURFACEALREADYEXISTS, L"this process already has created a primary surface")
        CHK_ERR(DDERR_NOEMULATION, L"software emulation not available.")
        CHK_ERR(DDERR_REGIONTOOSMALL, L"region passed to Clipper::GetClipList is too small.")
        CHK_ERR(DDERR_CLIPPERISUSINGHWND, L"an attempt was made to set a clip list for a clipper objec that is already monitoring an hwnd.")
        CHK_ERR(DDERR_NOCLIPPERATTACHED, L"No clipper object attached to surface object")
        CHK_ERR(DDERR_NOHWND, L"Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.")
        CHK_ERR(DDERR_HWNDSUBCLASSED, L"HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.")
        CHK_ERR(DDERR_HWNDALREADYSET, L"The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.")
        CHK_ERR(DDERR_NOPALETTEATTACHED, L"No palette object attached to this surface.")
        CHK_ERR(DDERR_NOPALETTEHW, L"No hardware support for 16 or 256 color palettes.")
        CHK_ERR(DDERR_BLTFASTCANTCLIP, L"If a clipper object is attached to the source surface passed into a BltFast call.")
        CHK_ERR(DDERR_NOBLTHW, L"No blter.")
        CHK_ERR(DDERR_NODDROPSHW, L"No DirectDraw ROP hardware.")
        CHK_ERR(DDERR_OVERLAYNOTVISIBLE, L"returned when GetOverlayPosition is called on a hidden overlay")
        CHK_ERR(DDERR_NOOVERLAYDEST, L"returned when GetOverlayPosition is called on a overlay that UpdateOverlay has never been called on to establish a destionation.")
        CHK_ERR(DDERR_INVALIDPOSITION, L"returned when the position of the overlay on the destionation is no longer legal for that destionation.")
        CHK_ERR(DDERR_NOTAOVERLAYSURFACE, L"returned when an overlay member is called for a non-overlay surface")
        CHK_ERR(DDERR_EXCLUSIVEMODEALREADYSET, L"An attempt was made to set the cooperative level when it was already set to exclusive.")
        CHK_ERR(DDERR_NOTFLIPPABLE, L"An attempt has been made to flip a surface that is not flippable.")
        CHK_ERR(DDERR_CANTDUPLICATE, L"Can't duplicate primary & 3D surfaces, or surfaces that are implicitly created.")
        CHK_ERR(DDERR_NOTLOCKED, L"Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.")
        CHK_ERR(DDERR_CANTCREATEDC, L"Windows can not create any more DCs, or a DC was requested for a paltte-indexed surface when the surface had no palette AND the display mode was not palette-indexed (in this case DirectDraw cannot select a proper palette into the DC)")
        CHK_ERR(DDERR_NODC, L"No DC was ever created for this surface.")
        CHK_ERR(DDERR_WRONGMODE, L"This surface can not be restored because it was created in a different mode.")
        CHK_ERR(DDERR_IMPLICITLYCREATED, L"This surface can not be restored because it is an implicitly created surface.")
        CHK_ERR(DDERR_NOTPALETTIZED, L"The surface being used is not a palette-based surface")
        CHK_ERR(DDERR_UNSUPPORTEDMODE, L"The display is currently in an unsupported mode")
        CHK_ERR(DDERR_NOMIPMAPHW, L"Operation could not be carried out because there is no mip-map texture mapping hardware present or available.")
        CHK_ERR(DDERR_INVALIDSURFACETYPE, L"The requested action could not be performed because the surface was of the wrong type.")
        CHK_ERR(DDERR_NOOPTIMIZEHW, L"Device does not support optimized surfaces, therefore no video memory optimized surfaces")
        CHK_ERR(DDERR_NOTLOADED, L"Surface is an optimized surface, but has not yet been allocated any memory")
        CHK_ERR(DDERR_NOFOCUSWINDOW, L"Attempt was made to create or set a device window without first setting the focus window")
        CHK_ERR(DDERR_NOTONMIPMAPSUBLEVEL, L"Attempt was made to set a palette on a mipmap sublevel")
        CHK_ERR(DDERR_DCALREADYCREATED, L"A DC has already been returned for this surface. Only one DC can be retrieved per surface.")
        CHK_ERR(DDERR_NONONLOCALVIDMEM, L"An attempt was made to allocate non-local video memory from a device that does not support non-local video memory.")
        CHK_ERR(DDERR_CANTPAGELOCK, L"The attempt to page lock a surface failed.")
        CHK_ERR(DDERR_CANTPAGEUNLOCK, L"The attempt to page unlock a surface failed.")
        CHK_ERR(DDERR_NOTPAGELOCKED, L"An attempt was made to page unlock a surface with no outstanding page locks.")
        CHK_ERR(DDERR_MOREDATA, L"There is more data available than the specified buffer size could hold")
        CHK_ERR(DDERR_EXPIRED, L"The data has expired and is therefore no longer valid.")
        CHK_ERR(DDERR_TESTFINISHED, L"The mode test has finished executing.")
        CHK_ERR(DDERR_NEWMODE, L"The mode test has switched to a new mode.")
        CHK_ERR(DDERR_D3DNOTINITIALIZED, L"D3D has not yet been initialized.")
        CHK_ERR(DDERR_VIDEONOTACTIVE, L"The video port is not active")
        CHK_ERR(DDERR_NOMONITORINFORMATION, L"The monitor does not have EDID data.")
        CHK_ERR(DDERR_NODRIVERSUPPORT, L"The driver does not enumerate display mode refresh rates.")
        CHK_ERR(DDERR_DEVICEDOESNTOWNSURFACE, L"Surfaces created by one direct draw device cannot be used directly by another direct draw device.")

// -------------------------------------------------------------        
// dinput.h error codes as of 10/4/00
// -------------------------------------------------------------        
//      CHK_ERR(DI_OK, L"DI_OK")
//      CHK_ERR(DI_NOTATTACHED, L"DI_NOTATTACHED")
//      CHK_ERR(DI_BUFFEROVERFLOW, L"DI_BUFFEROVERFLOW")
//      CHK_ERR(DI_PROPNOEFFECT, L"DI_PROPNOEFFECT")
//      CHK_ERR(DI_NOEFFECT, L"DI_NOEFFECT")
//      CHK_ERR(DI_POLLEDDEVICE, L"DI_POLLEDDEVICE")
//      CHK_ERR(DI_DOWNLOADSKIPPED, L"DI_DOWNLOADSKIPPED")
//      CHK_ERR(DI_EFFECTRESTARTED, L"DI_EFFECTRESTARTED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_ACCESSDENIED, L"DI_SETTINGSNOTSAVED_ACCESSDENIED")
//      CHK_ERR(DI_SETTINGSNOTSAVED_DISKFULL, L"DI_SETTINGSNOTSAVED_DISKFULL")
//      CHK_ERR(DI_TRUNCATED, L"DI_TRUNCATED")
//      CHK_ERR(DI_TRUNCATEDANDRESTARTED, L"DI_TRUNCATEDANDRESTARTED")
//      CHK_ERR(DI_WRITEPROTECT, L"DI_WRITEPROTECT")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, L"The application requires a newer version of DirectInput.")
//      CHK_ERR(DIERR_GENERIC, L"DIERR_GENERIC")
//      CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, L"DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, L"The application was written for an unsupported prerelease version of DirectInput.")
        CHK_ERR(DIERR_BADDRIVERVER, L"The object could not be created due to an incompatible driver version or mismatched or incomplete driver components.")
//      CHK_ERR(DIERR_DEVICENOTREG, L"DIERR_DEVICENOTREG")   
        CHK_ERR(DIERR_NOTFOUND, L"The requested object does not exist.")                
//      CHK_ERR(DIERR_OBJECTNOTFOUND, L"DIERR_OBJECTNOTFOUND")
//      CHK_ERR(DIERR_INVALIDPARAM, L"DIERR_INVALIDPARAM")         
//      CHK_ERR(DIERR_NOINTERFACE, L"DIERR_NOINTERFACE")         
//      CHK_ERR(DIERR_GENERIC, L"DIERR_GENERIC")         
//      CHK_ERR(DIERR_OUTOFMEMORY, L"DIERR_OUTOFMEMORY")         
//      CHK_ERR(DIERR_UNSUPPORTED, L"DIERR_UNSUPPORTED")         
        CHK_ERR(DIERR_NOTINITIALIZED, L"This object has not been initialized")
        CHK_ERR(DIERR_ALREADYINITIALIZED, L"This object is already initialized")
//      CHK_ERR(DIERR_NOAGGREGATION, L"DIERR_NOAGGREGATION")
//      CHK_ERR(DIERR_OTHERAPPHASPRIO, L"DIERR_OTHERAPPHASPRIO")         
        CHK_ERR(DIERR_INPUTLOST, L"Access to the device has been lost.  It must be re-acquired.")
        CHK_ERR(DIERR_ACQUIRED, L"The operation cannot be performed while the device is acquired.")
        CHK_ERR(DIERR_NOTACQUIRED, L"The operation cannot be performed unless the device is acquired.")
//      CHK_ERR(DIERR_READONLY, L"DIERR_READONLY")
//      CHK_ERR(DIERR_HANDLEEXISTS, L"DIERR_HANDLEEXISTS")         
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, L"Unable to IDirectInputJoyConfig_Acquire because the user does not have sufficient privileges to change the joystick configuration. & An invalid media type was specified")        
        CHK_ERR(DIERR_DEVICEFULL, L"The device is full. & An invalid media subtype was specified.")
        CHK_ERR(DIERR_MOREDATA, L"Not all the requested information fit into the buffer. & This object can only be created as an aggregated object.")
        CHK_ERR(DIERR_NOTDOWNLOADED, L"The effect is not downloaded. & The enumerator has become invalid.")
        CHK_ERR(DIERR_HASEFFECTS, L"The device cannot be reinitialized because there are still effects attached to it. & At least one of the pins involved in the operation is already connected.")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, L"The operation cannot be performed unless the device is acquired in DISCL_EXCLUSIVE mode. & This operation cannot be performed because the filter is active.")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, L"The effect could not be downloaded because essential information is missing.  For example, no axes have been associated with the effect, or no type-specific information has been created. & One of the specified pins supports no media types.")
        CHK_ERR(DIERR_NOTBUFFERED, L"Attempted to read buffered device data from a device that is not buffered. & There is no common media type between these pins.")
        CHK_ERR(DIERR_EFFECTPLAYING, L"An attempt was made to modify parameters of an effect while it is playing.  Not all hardware devices support altering the parameters of an effect while it is playing. & Two pins of the same direction cannot be connected together.")
        CHK_ERR(DIERR_UNPLUGGED, L"The operation could not be completed because the device is not plugged in. & The operation cannot be performed because the pins are not connected.")
        CHK_ERR(DIERR_REPORTFULL, L"SendDeviceData failed because more information was requested to be sent than can be sent to the device.  Some devices have restrictions on how much data can be sent to them.  (For example, there might be a limit on the number of buttons that can be pressed at once.) & No sample buffer allocator is available.")
        CHK_ERR(DIERR_MAPFILEFAIL, L"A mapper file function failed because reading or writing the user or IHV settings file failed. & A run-time error occurred.")
 

// -------------------------------------------------------------        
// dinputd.h error codes as of 9/8/00
// -------------------------------------------------------------                
        CHK_ERR(DIERR_NOMOREITEMS, L"No more items.")        
        CHK_ERR(DIERR_DRIVERFIRST, L"Device driver-specific codes. Unless the specific driver has been precisely identified, no meaning should be attributed to these values other than that the driver originated the error.")
        CHK_ERR(DIERR_DRIVERFIRST+1, L"DIERR_DRIVERFIRST+1")
        CHK_ERR(DIERR_DRIVERFIRST+2, L"DIERR_DRIVERFIRST+2")
        CHK_ERR(DIERR_DRIVERFIRST+3, L"DIERR_DRIVERFIRST+3")
        CHK_ERR(DIERR_DRIVERFIRST+4, L"DIERR_DRIVERFIRST+4")
        CHK_ERR(DIERR_DRIVERFIRST+5, L"DIERR_DRIVERFIRST+5")
        CHK_ERR(DIERR_DRIVERLAST, L"Device installer errors.")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, L"Registry entry or DLL for class installer invalid or class installer not found.")
        CHK_ERR(DIERR_CANCELLED, L"The user cancelled the install operation.")
        CHK_ERR(DIERR_BADINF, L"The INF file for the selected device could not be found or is invalid or is damaged.")
        
            
// -------------------------------------------------------------        
// dvoice.h error codes as of 9/8/00
// -------------------------------------------------------------                        
//      CHK_ERR(DV_OK, L"OK")
        CHK_ERR(DV_FULLDUPLEX, L"Full duplex")
        CHK_ERR(DV_HALFDUPLEX, L"Half duplex")
        CHK_ERR(DV_PENDING, L"Pending")
        CHK_ERR(DVERR_BUFFERTOOSMALL, L"Buffer too small")
        CHK_ERR(DVERR_EXCEPTION, L"Exception")
//      CHK_ERR(DVERR_GENERIC, L"Generic")
        CHK_ERR(DVERR_INVALIDFLAGS, L"Invalid flags")
        CHK_ERR(DVERR_INVALIDOBJECT, L"Invalid object")
        CHK_ERR(DVERR_INVALIDPLAYER, L"Invalid player")
        CHK_ERR(DVERR_INVALIDGROUP, L"Invalid group")
        CHK_ERR(DVERR_INVALIDHANDLE, L"Invalid handle")
//      CHK_ERR(DVERR_OUTOFMEMORY, L"Out of memory")
//      CHK_ERR(DVERR_PENDING, L"Pending")
//      CHK_ERR(DVERR_NOTSUPPORTED, L"Not supported")
//      CHK_ERR(DVERR_NOINTERFACE, L"No interface")
        CHK_ERR(DVERR_SESSIONLOST, L"Session lost")
        CHK_ERR(DVERR_NOVOICESESSION, L"No voice session")
        CHK_ERR(DVERR_CONNECTIONLOST, L"Connection lost")
        CHK_ERR(DVERR_NOTINITIALIZED, L"Not initialized")
        CHK_ERR(DVERR_CONNECTED, L"Connected")
        CHK_ERR(DVERR_NOTCONNECTED, L"Not connected")
        CHK_ERR(DVERR_CONNECTABORTING, L"Connect aborting")
        CHK_ERR(DVERR_NOTALLOWED, L"Not allowed")
        CHK_ERR(DVERR_INVALIDTARGET, L"Invalid target")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, L"Transport not host")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, L"Compression not supported")
        CHK_ERR(DVERR_ALREADYPENDING, L"Already pending")
        CHK_ERR(DVERR_SOUNDINITFAILURE, L"Sound init failure")
        CHK_ERR(DVERR_TIMEOUT, L"Time out")
        CHK_ERR(DVERR_CONNECTABORTED, L"Connect aborted")
        CHK_ERR(DVERR_NO3DSOUND, L"No 3d sound")
        CHK_ERR(DVERR_ALREADYBUFFERED, L"Already buffered")
        CHK_ERR(DVERR_NOTBUFFERED, L"Not buffered")
        CHK_ERR(DVERR_HOSTING, L"Hosting")
        CHK_ERR(DVERR_NOTHOSTING, L"Not hosting")
        CHK_ERR(DVERR_INVALIDDEVICE, L"Invalid device")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, L"Record system error")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, L"Playback system error")
        CHK_ERR(DVERR_SENDERROR, L"Send error")
        CHK_ERR(DVERR_USERCANCEL, L"User cancel")
        CHK_ERR(DVERR_RUNSETUP, L"Run setup")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, L"Incompatible version")
        CHK_ERR(DVERR_INITIALIZED, L"Initialized")
//      CHK_ERR(DVERR_INVALIDPOINTER, L"Invalid pointer")
        CHK_ERR(DVERR_NOTRANSPORT, L"No transport")
        CHK_ERR(DVERR_NOCALLBACK, L"No callback")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, L"Transport not init")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, L"Transport no session")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, L"Transport no player")
        CHK_ERR(DVERR_USERBACK, L"User back")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, L"No rec vol available")
        CHK_ERR(DVERR_INVALIDBUFFER, L"Invalid buffer")
        CHK_ERR(DVERR_LOCKEDBUFFER, L"Locked buffer")
        
              
// -------------------------------------------------------------        
// dplay8.h error codes as of 10/4/00
// -------------------------------------------------------------                        
        CHK_ERR(DPNERR_ABORTED, L"Aborted")
        CHK_ERR(DPNERR_ADDRESSING, L"Addressing")
        CHK_ERR(DPNERR_ALREADYCLOSING, L"Already closing")        
        CHK_ERR(DPNERR_ALREADYCONNECTED, L"Already connected")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, L"Already disconnecting")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, L"Already initialized")
        CHK_ERR(DPNERR_ALREADYREGISTERED, L"Already registered")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, L"Buffer too small")
        CHK_ERR(DPNERR_CANNOTCANCEL, L"Can not cancel")
        CHK_ERR(DPNERR_CANTCREATEGROUP, L"Cant create group")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, L"Cant create player")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, L"Cant launch application")
        CHK_ERR(DPNERR_CONNECTING, L"Connecting")
        CHK_ERR(DPNERR_CONNECTIONLOST, L"Connection lost")
        CHK_ERR(DPNERR_CONVERSION, L"Conversion")
        CHK_ERR(DPNERR_DATATOOLARGE, L"Data too large")
        CHK_ERR(DPNERR_DOESNOTEXIST, L"Does not exist")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, L"Duplicate command")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, L"End point not receiving")
        CHK_ERR(DPNERR_ENUMQUERYTOOLARGE, L"Enum query too large")
        CHK_ERR(DPNERR_ENUMRESPONSETOOLARGE, L"Enum response too large")
        CHK_ERR(DPNERR_EXCEPTION, L"Exception")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, L"Group not empty")
        CHK_ERR(DPNERR_HOSTING, L"Hosting")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, L"Host rejected connection")
        CHK_ERR(DPNERR_HOSTTERMINATEDSESSION, L"Host terminated session")        
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, L"Incomplete address")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, L"Invalid address format")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, L"Invalid application")
        CHK_ERR(DPNERR_INVALIDCOMMAND, L"Invalid command")
        CHK_ERR(DPNERR_INVALIDENDPOINT, L"Invalid end point")
        CHK_ERR(DPNERR_INVALIDFLAGS, L"Invalid flags")
        CHK_ERR(DPNERR_INVALIDGROUP, L"Invalid group")
        CHK_ERR(DPNERR_INVALIDHANDLE, L"Invalid handle")
        CHK_ERR(DPNERR_INVALIDINSTANCE, L"Invalid instance")
        CHK_ERR(DPNERR_INVALIDINTERFACE, L"Invalid interface")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, L"Invalid device address")
        CHK_ERR(DPNERR_INVALIDOBJECT, L"Invalid object")
//      CHK_ERR(DPNERR_INVALIDPARAM, L"Invalid param")        
        CHK_ERR(DPNERR_INVALIDPASSWORD, L"Invalid password")
        CHK_ERR(DPNERR_INVALIDPLAYER, L"Invalid player")
//      CHK_ERR(DPNERR_INVALIDPOINTER, L"Invalid pointer")        
        CHK_ERR(DPNERR_INVALIDPRIORITY, L"Invalid priority")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, L"Invalid host address")
        CHK_ERR(DPNERR_INVALIDSTRING, L"Invalid string")
        CHK_ERR(DPNERR_INVALIDURL, L"Invalid url")
        CHK_ERR(DPNERR_INVALIDVERSION, L"Invalid version")
        CHK_ERR(DPNERR_NOCAPS, L"No caps")
        CHK_ERR(DPNERR_NOCONNECTION, L"No connection")
        CHK_ERR(DPNERR_NOHOSTPLAYER, L"No host player")
//      CHK_ERR(DPNERR_NOINTERFACE, L"No interface")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, L"No more address components")
        CHK_ERR(DPNERR_NORESPONSE, L"No response")
        CHK_ERR(DPNERR_NOTALLOWED, L"Not allowed")
        CHK_ERR(DPNERR_NOTHOST, L"Not host")
        CHK_ERR(DPNERR_NOTREADY, L"Not ready")
        CHK_ERR(DPNERR_NOTREGISTERED, L"Not registered")
//      CHK_ERR(DPNERR_OUTOFMEMORY, L"Out of memory")
//      CHK_ERR(DPNERR_PENDING, L"Pending")
        CHK_ERR(DPNERR_PLAYERLOST, L"Player lost")
        CHK_ERR(DPNERR_PLAYERNOTREACHABLE, L"Player not reachable")
        CHK_ERR(DPNERR_SENDTOOLARGE, L"Send too large")
        CHK_ERR(DPNERR_SESSIONFULL, L"Session full")
        CHK_ERR(DPNERR_TABLEFULL, L"Table full")
        CHK_ERR(DPNERR_TIMEDOUT, L"Timed out")
        CHK_ERR(DPNERR_UNINITIALIZED, L"Uninitialized")
//      CHK_ERR(DPNERR_UNSUPPORTED, L"Unsupported")
        CHK_ERR(DPNERR_USERCANCEL, L"User cancel")
        
              
// -------------------------------------------------------------        
// dxfile.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(DXFILE_OK, L"Ok")
        CHK_ERR(DXFILEERR_BADOBJECT, L"Bad object")
        CHK_ERR(DXFILEERR_BADVALUE, L"Bad value")
        CHK_ERR(DXFILEERR_BADTYPE, L"Bad type")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, L"Bad stream handle")
        CHK_ERR(DXFILEERR_BADALLOC, L"Bad alloc")
        CHK_ERR(DXFILEERR_NOTFOUND, L"Not found")
        CHK_ERR(DXFILEERR_NOTDONEYET, L"Not done yet")
        CHK_ERR(DXFILEERR_FILENOTFOUND, L"File not found")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, L"Resource not found")
        CHK_ERR(DXFILEERR_URLNOTFOUND, L"Url not found")
        CHK_ERR(DXFILEERR_BADRESOURCE, L"Bad resource")
        CHK_ERR(DXFILEERR_BADFILETYPE, L"Bad file type")
        CHK_ERR(DXFILEERR_BADFILEVERSION, L"Bad file version")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, L"Bad file float size")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, L"Bad file compression type")
        CHK_ERR(DXFILEERR_BADFILE, L"Bad file")
        CHK_ERR(DXFILEERR_PARSEERROR, L"Parse error")
        CHK_ERR(DXFILEERR_NOTEMPLATE, L"No template")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, L"Bad array size")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, L"Bad data reference")
        CHK_ERR(DXFILEERR_INTERNALERROR, L"Internal error")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, L"No more objects")
        CHK_ERR(DXFILEERR_BADINTRINSICS, L"Bad intrinsics")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, L"No more stream handles")
        CHK_ERR(DXFILEERR_NOMOREDATA, L"No more data")
        CHK_ERR(DXFILEERR_BADCACHEFILE, L"Bad cache file")
        CHK_ERR(DXFILEERR_NOINTERNET, L"No internet")
        
        
// -------------------------------------------------------------        
// d3d8.h error codes as of 9/8/00
// -------------------------------------------------------------                                
//      CHK_ERR(D3D_OK, L"Ok")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, L"Wrong texture format")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, L"Unsupported color operation")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, L"Unsupported color arg")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, L"Unsupported alpha operation")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, L"Unsupported alpha arg")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, L"Too many operations")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, L"Conflicting texture filter")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, L"Unsupported factor value")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, L"Conflicting render state")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, L"Unsupported texture filter")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, L"Conflicting texture palette")                
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, L"Driver internal error")
        CHK_ERR(D3DERR_NOTFOUND, L"Not found")
        CHK_ERR(D3DERR_MOREDATA, L"More data")
        CHK_ERR(D3DERR_DEVICELOST, L"Device lost")
        CHK_ERR(D3DERR_DEVICENOTRESET, L"Device not reset")
        CHK_ERR(D3DERR_NOTAVAILABLE, L"Not available")
        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, L"Out of video memory")
        CHK_ERR(D3DERR_INVALIDDEVICE, L"Invalid device")
        CHK_ERR(D3DERR_INVALIDCALL, L"Invalid call")
        CHK_ERR(D3DERR_DRIVERINVALIDCALL, L"Driver invalid call")                        
        
        
// -------------------------------------------------------------        
// d3dx8mesh.h error codes as of 12/5/00
// -------------------------------------------------------------                                
        CHK_ERR(D3DXERR_CANNOTMODIFYINDEXBUFFER, L"Can not modify index buffer")                        
        CHK_ERR(D3DXERR_INVALIDMESH, L"Invalid mesh")                        
        CHK_ERR(D3DXERR_CANNOTATTRSORT, L"Cannot attr sort")                        
        CHK_ERR(D3DXERR_SKINNINGNOTSUPPORTED, L"Skinning not supported")                        
        CHK_ERR(D3DXERR_TOOMANYINFLUENCES, L"Too many influences")                        
        CHK_ERR(D3DXERR_INVALIDDATA, L"Invalid data")                        

// -------------------------------------------------------------        
// dsound.h error codes as of 1/22/01
// -------------------------------------------------------------        
//      CHK_ERR(DS_OK, L"")        
        CHK_ERR(DS_NO_VIRTUALIZATION, L"The call succeeded, but we had to substitute the 3D algorithm")           
        CHK_ERR(DS_INCOMPLETE, L"The call succeeded, but not all of the optional effects were obtained.")             
        CHK_ERR(DSERR_ALLOCATED, L"The call failed because resources (such as a priority level) were already being used by another caller")
        CHK_ERR(DSERR_CONTROLUNAVAIL, L"The control (vol, pan, etc.) requested by the caller is not available")
//      CHK_ERR(DSERR_INVALIDPARAM, L"DSERR_INVALIDPARAM")                
        CHK_ERR(DSERR_INVALIDCALL, L"This call is not valid for the current state of this object")
//      CHK_ERR(DSERR_GENERIC, L"DSERR_GENERIC")                
        CHK_ERR(DSERR_PRIOLEVELNEEDED, L"The caller does not have the priority level required for the function to succeed")
//      CHK_ERR(DSERR_OUTOFMEMORY, L"Not enough free memory is available to complete the operation")                
        CHK_ERR(DSERR_BADFORMAT, L"The specified WAVE format is not supported")
//      CHK_ERR(DSERR_UNSUPPORTED, L"DSERR_UNSUPPORTED")                
        CHK_ERR(DSERR_NODRIVER, L"No sound driver is available for use")
        CHK_ERR(DSERR_ALREADYINITIALIZED, L"This object is already initialized")
//      CHK_ERR(DSERR_NOAGGREGATION, L"DSERR_NOAGGREGATION")                
        CHK_ERR(DSERR_BUFFERLOST, L"The buffer memory has been lost, and must be restored")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, L"Another app has a higher priority level, preventing this call from succeeding")
        CHK_ERR(DSERR_UNINITIALIZED, L"This object has not been initialized")
//      CHK_ERR(DSERR_NOINTERFACE, L"DSERR_NOINTERFACE")                
//      CHK_ERR(DSERR_ACCESSDENIED, L"DSERR_ACCESSDENIED")        
        CHK_ERR(DSERR_BUFFERTOOSMALL, L"Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")        
        CHK_ERR(DSERR_DS8_REQUIRED, L"Attempt to use DirectSound 8 functionality on an older DirectSound object")        
        CHK_ERR(DSERR_SENDLOOP, L"A circular loop of send effects was detected")        
        CHK_ERR(DSERR_BADSENDBUFFERGUID, L"The GUID specified in an audiopath file does not match a valid MIXIN buffer")        
        CHK_ERR(DSERR_OBJECTNOTFOUND, L"The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)")                

// -------------------------------------------------------------        
// dmerror.h error codes as of 9/8/00
// -------------------------------------------------------------        
        CHK_ERR(DMUS_S_PARTIALLOAD, L"The object could only load partially. This can happen if some components are not registered properly, such as embedded tracks and tools. This can also happen if some content is missing. For example, if a segment uses a DLS collection that is not in the loader's current search directory.")  
        CHK_ERR(DMUS_S_PARTIALDOWNLOAD, L"Return value from IDirectMusicBand::Download() which indicates that some of the instruments safely downloaded, but others failed. This usually occurs when some instruments are on PChannels not supported by the performance or port.")    
        CHK_ERR(DMUS_S_REQUEUE, L"Return value from IDirectMusicTool::ProcessPMsg() which indicates to the performance that it should cue the PMsg again automatically.")            
        CHK_ERR(DMUS_S_FREE, L"Return value from IDirectMusicTool::ProcessPMsg() which indicates to the performance that it should free the PMsg automatically.")  
        CHK_ERR(DMUS_S_END, L"Return value from IDirectMusicTrack::Play() which indicates to the segment that the track has no more data after mtEnd.")                
        CHK_ERR(DMUS_S_STRING_TRUNCATED, L"Returned string has been truncated to fit the buffer size.")   
        CHK_ERR(DMUS_S_LAST_TOOL, L"Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg is already stamped with the last tool in the graph. The returned PMsg's tool pointer is now NULL.")          
        CHK_ERR(DMUS_S_OVER_CHORD, L"Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates  that no note has been calculated because the music value has the note  at a position higher than the top note of the chord. This applies only to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates that the caller should not do anything with the note. It is not meant to be played against this chord.")         
        CHK_ERR(DMUS_S_UP_OCTAVE, L"Returned from IDirectMusicPerformance::MIDIToMusic(),  and IDirectMusicPerformance::MusicToMIDI(), this indicates  that the note conversion generated a note value that is below 0,  so it has been bumped up one or more octaves to be in the proper MIDI range of 0 through 127.  Note that this is valid for MIDIToMusic() when using play modes DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of which store MIDI values in wMusicValue. With MusicToMIDI(), it is valid for all play modes. Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.")          
        CHK_ERR(DMUS_S_DOWN_OCTAVE, L"Returned from IDirectMusicPerformance::MIDIToMusic(),  and IDirectMusicPerformance::MusicToMIDI(), this indicates  that the note conversion generated a note value that is above 127, so it has been bumped down one or more octaves to be in the proper MIDI range of 0 through 127.  Note that this is valid for MIDIToMusic() when using play modes DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of which store MIDI values in wMusicValue. With MusicToMIDI(), it is valid for all play modes. Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.")        
        CHK_ERR(DMUS_S_NOBUFFERCONTROL, L"Although the audio output from the port will be routed to the same device as the given DirectSound buffer, buffer controls such as pan and volume will not affect the output.")    
        CHK_ERR(DMUS_S_GARBAGE_COLLECTED, L"The requested operation was not performed because during CollectGarbage the loader determined that the object had been released.")  
        CHK_ERR(DMUS_E_DRIVER_FAILED, L"An unexpected error was returned from a device driver, indicating possible failure of the driver or hardware.")
        CHK_ERR(DMUS_E_PORTS_OPEN, L"The requested operation cannot be performed while there are  instantiated ports in any process in the system.")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, L"The requested device is already in use (possibly by a non-DirectMusic client) and cannot be opened again.")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, L"Buffer is not large enough for requested operation.")
        CHK_ERR(DMUS_E_BUFFERNOTSET, L"No buffer was prepared for the download data.")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, L"Download failed due to inability to access or create download buffer.")
        CHK_ERR(DMUS_E_NOTADLSCOL, L"Error parsing DLS collection. File is corrupt.")
        CHK_ERR(DMUS_E_INVALIDOFFSET, L"Wave chunks in DLS collection file are at incorrect offsets.")
        CHK_ERR(DMUS_E_ALREADY_LOADED, L"Second attempt to load a DLS collection that is currently open. ")
        CHK_ERR(DMUS_E_INVALIDPOS, L"Error reading wave data from DLS collection. Indicates bad file.")
        CHK_ERR(DMUS_E_INVALIDPATCH, L"There is no instrument in the collection that matches patch number.")
        CHK_ERR(DMUS_E_CANNOTSEEK, L"The IStream* doesn't support Seek().")
        CHK_ERR(DMUS_E_CANNOTWRITE, L"The IStream* doesn't support Write().")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, L"The RIFF parser doesn't contain a required chunk while parsing file.")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, L"Invalid download id was used in the process of creating a download buffer.")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, L"Tried to unload an object that was not downloaded or previously unloaded.")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, L"Buffer was already downloaded to synth.")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, L"The specified property item was not recognized by the target object.")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, L"The specified property item may not be set on the target object.")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, L"* The specified property item may not be retrieved from the target object.")
        CHK_ERR(DMUS_E_NOTMONO, L"Wave chunk has more than one interleaved channel. DLS format requires MONO.")
        CHK_ERR(DMUS_E_BADARTICULATION, L"Invalid articulation chunk in DLS collection.")
        CHK_ERR(DMUS_E_BADINSTRUMENT, L"Invalid instrument chunk in DLS collection.")
        CHK_ERR(DMUS_E_BADWAVELINK, L"Wavelink chunk in DLS collection points to invalid wave.")
        CHK_ERR(DMUS_E_NOARTICULATION, L"Articulation missing from instrument in DLS collection.")
        CHK_ERR(DMUS_E_NOTPCM, L"Downoaded DLS wave is not in PCM format. ")
        CHK_ERR(DMUS_E_BADWAVE, L"Bad wave chunk in DLS collection")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, L"Offset Table for download buffer has errors. ")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, L"Attempted to download unknown data type.")
        CHK_ERR(DMUS_E_NOSYNTHSINK, L"The operation could not be completed because no sink was connected to the synthesizer.")
        CHK_ERR(DMUS_E_ALREADYOPEN, L"An attempt was made to open the software synthesizer while it was already  open.")
        CHK_ERR(DMUS_E_ALREADYCLOSED, L"An attempt was made to close the software synthesizer while it was already  open.")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, L"The operation could not be completed because the software synth has not  yet been fully configured.")
        CHK_ERR(DMUS_E_SYNTHACTIVE, L"The operation cannot be carried out while the synthesizer is active.")
        CHK_ERR(DMUS_E_CANNOTREAD, L"An error occurred while attempting to read from the IStream* object.")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, L"The operation cannot be performed because the final instance of the DirectMusic object was released. Ports cannot be used after final  release of the DirectMusic object.")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, L"There was no data in the referenced buffer.")
        CHK_ERR(DMUS_E_BUFFER_FULL, L"There is insufficient space to insert the given event into the buffer.")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, L"The given operation could not be carried out because the port is a capture port.")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, L"The given operation could not be carried out because the port is a render port.")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, L"The port could not be created because no DirectSound has been specified. Specify a DirectSound interface via the IDirectMusic::SetDirectSound method; pass NULL to have DirectMusic manage usage of DirectSound.")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, L"The operation cannot be carried out while the port is active.")
        CHK_ERR(DMUS_E_INVALIDBUFFER, L"Invalid DirectSound buffer was handed to port. ")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, L"Invalid buffer format was handed to the synth sink.")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, L"The operation cannot be carried out while the synthesizer is inactive.")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, L"IDirectMusic::SetDirectSound has already been called. It may not be changed while in use.")
        CHK_ERR(DMUS_E_INVALID_EVENT, L"The given event is invalid (either it is not a valid MIDI message or it makes use of running status). The event cannot be packed into the buffer.")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, L"The IStream* object does not contain data supported by the loading object.")
        CHK_ERR(DMUS_E_ALREADY_INITED, L"The object has already been initialized.")
        CHK_ERR(DMUS_E_INVALID_BAND, L"The file does not contain a valid band.")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, L"The IStream* object's data does not have a track header as the first chunk, and therefore can not be read by the segment object.")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, L"The IStream* object's data does not have a tool header as the first chunk, and therefore can not be read by the graph object.")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, L"The IStream* object's data contains an invalid track header (ckid is 0 and fccType is NULL,) and therefore can not be read by the segment object.")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, L"The IStream* object's data contains an invalid tool header (ckid is 0 and fccType is NULL,) and therefore can not be read by the graph object.")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, L"The graph object was unable to load all tools from the IStream* object data. This may be due to errors in the stream, or the tools being incorrectly registered on the client.")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, L"The segment object was unable to load all tracks from the IStream* object data. This may be due to errors in the stream, or the tracks being incorrectly registered on the client.")
//      CHK_ERR(DMUS_E_NOT_FOUND, L"DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, L"A required object is not initialized or failed to initialize.")
        CHK_ERR(DMUS_E_TYPE_DISABLED, L"The requested parameter type is currently disabled. Parameter types may be enabled and disabled by certain calls to SetParam().")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, L"The requested parameter type is not supported on the object.")
        CHK_ERR(DMUS_E_TIME_PAST, L"The time is in the past, and the operation can not succeed.")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, L"The requested track is not contained by the segment.")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, L"The track does not support clock time playback or getparam.")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, L"There is no master clock in the performance. Be sure to call IDirectMusicPerformance::Init().")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, L"The class id field is required and missing in the DMUS_OBJECTDESC.")
        CHK_ERR(DMUS_E_LOADER_BADPATH, L"The requested file path is invalid.")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, L"File open failed - either file doesn't exist or is locked.")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, L"Search data type is not supported.")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, L"Unable to find or create object.")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, L"Object was not found.")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, L"The file name is missing from the DMUS_OBJECTDESC.")
        CHK_ERR(DMUS_E_INVALIDFILE, L"The file requested is not a valid file.")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, L"The tool is already contained in the graph. Create a new instance.")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, L"Value is out of range, for instance the requested length is longer than the segment.")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, L"Segment initialization failed, most likely due to a critical memory situation.")
        CHK_ERR(DMUS_E_ALREADY_SENT, L"The DMUS_PMSG has already been sent to the performance object via IDirectMusicPerformance::SendPMsg().")
        CHK_ERR(DMUS_E_CANNOT_FREE, L"The DMUS_PMSG was either not allocated by the performance via IDirectMusicPerformance::AllocPMsg(), or it was already freed via IDirectMusicPerformance::FreePMsg().")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, L"The default system port could not be opened.")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, L"A call to MIDIToMusic() or MusicToMIDI() resulted in an error because the requested conversion could not happen. This usually occurs when the provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, L"DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file  was reached before the desired chunk was found.")
        CHK_ERR(DMUS_E_NOT_LOADED, L"An attempt to use this object failed because it first needs to be loaded.")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, L"The activeX scripting engine for the script's language is not compatible with DirectMusic.")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, L"A varient was used that had a type that is not supported by DirectMusic.")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, L"An error was encountered while parsing or executing the script. The pErrorInfo parameter (if supplied) was filled with information about the error.")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, L"Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only the DirectMusicScript language, which doesn't require oleaut32.dll can be used.")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, L"An error occured while parsing a script loaded using LoadScript.  The script that was loaded contains an error.")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, L"The script file is invalid.")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, L"The file contains an invalid script track.")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, L"The script does not contain a variable with the specified name.")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, L"The script does not contain a routine with the specified name.")
        CHK_ERR(DMUS_E_SCRIPT_CONTENT_READONLY, L"Scripts variables for content referenced or embedded in a script cannot be set.")
        CHK_ERR(DMUS_E_SCRIPT_NOT_A_REFERENCE, L"Attempt was made to set a script's variable by reference to a value that was not an object type.")
        CHK_ERR(DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED, L"Attempt was made to set a script's variable by value to an object that does not support a default value property.")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, L"The file contains an invalid segment trigger track.")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, L"The file contains an invalid lyrics track.")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, L"The file contains an invalid parameter control track.")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, L"A script written in AudioVBScript could not be read because it contained a statement that is not allowed by the AudioVBScript language.")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, L"A script routine written in AudioVBScript failed because an invalid operation occurred.  For example, adding the number 3 to a segment object would produce this error.  So would attempting to call a routine that doesn't exist.")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, L"A script routine written in AudioVBScript failed because a function outside of a script failed to complete. For example, a call to PlaySegment that fails to play because of low memory would return this error.")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, L"The Performance has set up some PChannels using the AssignPChannel command, which makes it not capable of supporting audio paths.")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, L"This is the inverse of the previous error. The Performance has set up some audio paths, which makes is incompatible with the calls to allocate pchannels, etc. ")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, L"A segment or song was asked for its embedded audio path configuration, but there isn't any. ")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, L"An audiopath is inactive, perhaps because closedown was called.")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, L"An audiopath failed to create because a requested buffer could not be created.")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, L"An audiopath could not be used for playback because it lacked port assignments.")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, L"Attempt was made to play segment in audiopath mode and there was no audiopath.")
        CHK_ERR(DMUS_E_INVALIDCHUNK, L"Invalid data was found in a RIFF file chunk.")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, L"Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, L"The file does not contain a valid container object.")    
   
// -------------------------------------------------------------        
// vfwmsgs.h error codes as of 9/8/00
// -------------------------------------------------------------        
//      CHK_ERR(VFW_E_INVALIDMEDIATYPE, L"VFW_E_INVALIDMEDIATYPE")
//      CHK_ERR(VFW_E_INVALIDSUBTYPE, L"VFW_E_INVALIDSUBTYPE")
//      CHK_ERR(VFW_E_NEED_OWNER, L"VFW_E_NEED_OWNER")
//      CHK_ERR(VFW_E_ENUM_OUT_OF_SYNC, L"VFW_E_ENUM_OUT_OF_SYNC")
//      CHK_ERR(VFW_E_ALREADY_CONNECTED, L"VFW_E_ALREADY_CONNECTED")
//      CHK_ERR(VFW_E_FILTER_ACTIVE, L"VFW_E_FILTER_ACTIVE")
//      CHK_ERR(VFW_E_NO_TYPES, L"VFW_E_NO_TYPES")
//      CHK_ERR(VFW_E_NO_ACCEPTABLE_TYPES, L"VFW_E_NO_ACCEPTABLE_TYPES")
//      CHK_ERR(VFW_E_INVALID_DIRECTION, L"VFW_E_INVALID_DIRECTION")
//      CHK_ERR(VFW_E_NOT_CONNECTED, L"VFW_E_NOT_CONNECTED")
//      CHK_ERR(VFW_E_NO_ALLOCATOR, L"VFW_E_NO_ALLOCATOR")
//      CHK_ERR(VFW_E_RUNTIME_ERROR, L"VFW_E_RUNTIME_ERROR")
        CHK_ERR(VFW_E_BUFFER_NOTSET, L"No buffer space has been set")
        CHK_ERR(VFW_E_BUFFER_OVERFLOW, L"The buffer is not big enough.")
        CHK_ERR(VFW_E_BADALIGN, L"An invalid alignment was specified.")
        CHK_ERR(VFW_E_ALREADY_COMMITTED, L"Cannot change allocated memory while the filter is active.")
        CHK_ERR(VFW_E_BUFFERS_OUTSTANDING, L"One or more buffers are still active.")
        CHK_ERR(VFW_E_NOT_COMMITTED, L"Cannot allocate a sample when the allocator is not active.")
        CHK_ERR(VFW_E_SIZENOTSET, L"Cannot allocate memory because no size has been set.")
        CHK_ERR(VFW_E_NO_CLOCK, L"Cannot lock for synchronization because no clock has been defined.")
        CHK_ERR(VFW_E_NO_SINK, L"Quality messages could not be sent because no quality sink has been defined.")
        CHK_ERR(VFW_E_NO_INTERFACE, L"A required interface has not been implemented.")
        CHK_ERR(VFW_E_NOT_FOUND, L"An object or name was not found.")
        CHK_ERR(VFW_E_CANNOT_CONNECT, L"No combination of intermediate filters could be found to make the connection.")
        CHK_ERR(VFW_E_CANNOT_RENDER, L"No combination of filters could be found to render the stream.")
        CHK_ERR(VFW_E_CHANGING_FORMAT, L"Could not change formats dynamically.")
        CHK_ERR(VFW_E_NO_COLOR_KEY_SET, L"No color key has been set.")
        CHK_ERR(VFW_E_NOT_OVERLAY_CONNECTION, L"Current pin connection is not using the IOverlay transport.")
        CHK_ERR(VFW_E_NOT_SAMPLE_CONNECTION, L"Current pin connection is not using the IMemInputPin transport.")
        CHK_ERR(VFW_E_PALETTE_SET, L"Setting a color key would conflict with the palette already set.")
        CHK_ERR(VFW_E_COLOR_KEY_SET, L"Setting a palette would conflict with the color key already set.")
        CHK_ERR(VFW_E_NO_COLOR_KEY_FOUND, L"No matching color key is available.")
        CHK_ERR(VFW_E_NO_PALETTE_AVAILABLE, L"No palette is available.")
        CHK_ERR(VFW_E_NO_DISPLAY_PALETTE, L"Display does not use a palette.")
        CHK_ERR(VFW_E_TOO_MANY_COLORS, L"Too many colors for the current display settings.")
        CHK_ERR(VFW_E_STATE_CHANGED, L"The state changed while waiting to process the sample.")
        CHK_ERR(VFW_E_NOT_STOPPED, L"The operation could not be performed because the filter is not stopped.")
        CHK_ERR(VFW_E_NOT_PAUSED, L"The operation could not be performed because the filter is not paused.")
        CHK_ERR(VFW_E_NOT_RUNNING, L"The operation could not be performed because the filter is not running.")
        CHK_ERR(VFW_E_WRONG_STATE, L"The operation could not be performed because the filter is in the wrong state.")
        CHK_ERR(VFW_E_START_TIME_AFTER_END, L"The sample start time is after the sample end time.")
        CHK_ERR(VFW_E_INVALID_RECT, L"The supplied rectangle is invalid.")
        CHK_ERR(VFW_E_TYPE_NOT_ACCEPTED, L"This pin cannot use the supplied media type.")
        CHK_ERR(VFW_E_SAMPLE_REJECTED, L"This sample cannot be rendered.")
        CHK_ERR(VFW_E_SAMPLE_REJECTED_EOS, L"This sample cannot be rendered because the end of the stream has been reached.")
        CHK_ERR(VFW_E_DUPLICATE_NAME, L"An attempt to add a filter with a duplicate name failed.")
        CHK_ERR(VFW_S_DUPLICATE_NAME, L"An attempt to add a filter with a duplicate name succeeded with a modified name.")
        CHK_ERR(VFW_E_TIMEOUT, L"A time-out has expired.")
        CHK_ERR(VFW_E_INVALID_FILE_FORMAT, L"The file format is invalid.")
        CHK_ERR(VFW_E_ENUM_OUT_OF_RANGE, L"The list has already been exhausted.")
        CHK_ERR(VFW_E_CIRCULAR_GRAPH, L"The filter graph is circular.")
        CHK_ERR(VFW_E_NOT_ALLOWED_TO_SAVE, L"Updates are not allowed in this state.")
        CHK_ERR(VFW_E_TIME_ALREADY_PASSED, L"An attempt was made to queue a command for a time in the past.")
        CHK_ERR(VFW_E_ALREADY_CANCELLED, L"The queued command has already been canceled.")
        CHK_ERR(VFW_E_CORRUPT_GRAPH_FILE, L"Cannot render the file because it is corrupt.")
        CHK_ERR(VFW_E_ADVISE_ALREADY_SET, L"An overlay advise link already exists.")
        CHK_ERR(VFW_S_STATE_INTERMEDIATE, L"The state transition has not completed.")
        CHK_ERR(VFW_E_NO_MODEX_AVAILABLE, L"No full-screen modes are available.")
        CHK_ERR(VFW_E_NO_ADVISE_SET, L"This Advise cannot be canceled because it was not successfully set.")
        CHK_ERR(VFW_E_NO_FULLSCREEN, L"A full-screen mode is not available.")
        CHK_ERR(VFW_E_IN_FULLSCREEN_MODE, L"Cannot call IVideoWindow methods while in full-screen mode.")
        CHK_ERR(VFW_E_UNKNOWN_FILE_TYPE, L"The media type of this file is not recognized.")
        CHK_ERR(VFW_E_CANNOT_LOAD_SOURCE_FILTER, L"The source filter for this file could not be loaded.")
        CHK_ERR(VFW_S_PARTIAL_RENDER, L"Some of the streams in this movie are in an unsupported format.")
        CHK_ERR(VFW_E_FILE_TOO_SHORT, L"A file appeared to be incomplete.")
        CHK_ERR(VFW_E_INVALID_FILE_VERSION, L"The version number of the file is invalid.")
        CHK_ERR(VFW_S_SOME_DATA_IGNORED, L"The file contained some property settings that were not used.")
        CHK_ERR(VFW_S_CONNECTIONS_DEFERRED, L"Some connections have failed and have been deferred.")
        CHK_ERR(VFW_E_INVALID_CLSID, L"This file is corrupt: it contains an invalid class identifier.")
        CHK_ERR(VFW_E_INVALID_MEDIA_TYPE, L"This file is corrupt: it contains an invalid media type.")
        CHK_ERR(VFW_E_BAD_KEY, L"A registry entry is corrupt.")
        CHK_ERR(VFW_S_NO_MORE_ITEMS, L"The end of the list has been reached.")
        CHK_ERR(VFW_E_SAMPLE_TIME_NOT_SET, L"No time stamp has been set for this sample.")
        CHK_ERR(VFW_S_RESOURCE_NOT_NEEDED, L"The resource specified is no longer needed.")
        CHK_ERR(VFW_E_MEDIA_TIME_NOT_SET, L"No media time stamp has been set for this sample.")
        CHK_ERR(VFW_E_NO_TIME_FORMAT_SET, L"No media time format has been selected.")
        CHK_ERR(VFW_E_MONO_AUDIO_HW, L"Cannot change balance because audio device is mono only.")
        CHK_ERR(VFW_S_MEDIA_TYPE_IGNORED, L"A connection could not be made with the media type in the persistent graph, but has been made with a negotiated media type.")
        CHK_ERR(VFW_E_NO_DECOMPRESSOR, L"Cannot play back the video stream: no suitable decompressor could be found.")
        CHK_ERR(VFW_E_NO_AUDIO_HARDWARE, L"Cannot play back the audio stream: no audio hardware is available, or the hardware is not responding.")
        CHK_ERR(VFW_S_VIDEO_NOT_RENDERED, L"Cannot play back the video stream: no suitable decompressor could be found.")
        CHK_ERR(VFW_S_AUDIO_NOT_RENDERED, L"Cannot play back the audio stream: no audio hardware is available.")
        CHK_ERR(VFW_E_RPZA, L"Cannot play back the video stream: format 'RPZA' is not supported.")
        CHK_ERR(VFW_S_RPZA, L"Cannot play back the video stream: format 'RPZA' is not supported.")
        CHK_ERR(VFW_E_PROCESSOR_NOT_SUITABLE, L"ActiveMovie cannot play MPEG movies on this processor.")
        CHK_ERR(VFW_E_UNSUPPORTED_AUDIO, L"Cannot play back the audio stream: the audio format is not supported.")
        CHK_ERR(VFW_E_UNSUPPORTED_VIDEO, L"Cannot play back the video stream: the video format is not supported.")
        CHK_ERR(VFW_E_MPEG_NOT_CONSTRAINED, L"ActiveMovie cannot play this video stream because it falls outside the constrained standard.")
        CHK_ERR(VFW_E_NOT_IN_GRAPH, L"Cannot perform the requested function on an object that is not in the filter graph.")
        CHK_ERR(VFW_S_ESTIMATED, L"The value returned had to be estimated.  It's accuracy can not be guaranteed.")
        CHK_ERR(VFW_E_NO_TIME_FORMAT, L"Cannot get or set time related information on an object that is using a time format of TIME_FORMAT_NONE.")
        CHK_ERR(VFW_E_READ_ONLY, L"The connection cannot be made because the stream is read only and the filter alters the data.")
        CHK_ERR(VFW_S_RESERVED, L"This success code is reserved for internal purposes within ActiveMovie.")
        CHK_ERR(VFW_E_BUFFER_UNDERFLOW, L"The buffer is not full enough.")
        CHK_ERR(VFW_E_UNSUPPORTED_STREAM, L"Cannot play back the file.  The format is not supported.")
        CHK_ERR(VFW_E_NO_TRANSPORT, L"Pins cannot connect due to not supporting the same transport.")
        CHK_ERR(VFW_S_STREAM_OFF, L"The stream has been turned off.")
        CHK_ERR(VFW_S_CANT_CUE, L"The graph can't be cued because of lack of or corrupt data.")
        CHK_ERR(VFW_E_BAD_VIDEOCD, L"The Video CD can't be read correctly by the device or is the data is corrupt.")
        CHK_ERR(VFW_S_NO_STOP_TIME, L"The stop time for the sample was not set.")
        CHK_ERR(VFW_E_OUT_OF_VIDEO_MEMORY, L"There is not enough Video Memory at this display resolution and number of colors. Reducing resolution might help.")
        CHK_ERR(VFW_E_VP_NEGOTIATION_FAILED, L"The VideoPort connection negotiation process has failed.")
        CHK_ERR(VFW_E_DDRAW_CAPS_NOT_SUITABLE, L"Either DirectDraw has not been installed or the Video Card capabilities are not suitable. Make sure the display is not in 16 color mode.")
        CHK_ERR(VFW_E_NO_VP_HARDWARE, L"No VideoPort hardware is available, or the hardware is not responding.")
        CHK_ERR(VFW_E_NO_CAPTURE_HARDWARE, L"No Capture hardware is available, or the hardware is not responding.")
        CHK_ERR(VFW_E_DVD_OPERATION_INHIBITED, L"This User Operation is inhibited by DVD Content at this time.")
        CHK_ERR(VFW_E_DVD_INVALIDDOMAIN, L"This Operation is not permitted in the current domain.")
        CHK_ERR(VFW_E_DVD_NO_BUTTON, L"The specified button is invalid or is not present at the current time, or there is no button present at the specified location.")
        CHK_ERR(VFW_E_DVD_GRAPHNOTREADY, L"DVD-Video playback graph has not been built yet.")
        CHK_ERR(VFW_E_DVD_RENDERFAIL, L"DVD-Video playback graph building failed.")
        CHK_ERR(VFW_E_DVD_DECNOTENOUGH, L"DVD-Video playback graph could not be built due to insufficient decoders.")
        CHK_ERR(VFW_E_DDRAW_VERSION_NOT_SUITABLE, L"Version number of DirectDraw not suitable. Make sure to install dx5 or higher version.")
        CHK_ERR(VFW_E_COPYPROT_FAILED, L"Copy protection cannot be enabled. Please make sure any other copy protected content is not being shown now.")
        CHK_ERR(VFW_S_NOPREVIEWPIN, L"There was no preview pin available, so the capture pin output is being split to provide both capture and preview.")
        CHK_ERR(VFW_E_TIME_EXPIRED, L"This object cannot be used anymore as its time has expired.")
        CHK_ERR(VFW_S_DVD_NON_ONE_SEQUENTIAL, L"The current title was not a sequential set of chapters (PGC), and the returned timing information might not be continuous.")
        CHK_ERR(VFW_E_DVD_WRONG_SPEED, L"The operation cannot be performed at the current playback speed.")
        CHK_ERR(VFW_E_DVD_MENU_DOES_NOT_EXIST, L"The specified menu doesn't exist.")
        CHK_ERR(VFW_E_DVD_CMD_CANCELLED, L"The specified command was either cancelled or no longer exists.")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_VERSION, L"The data did not contain a recognized version.")
        CHK_ERR(VFW_E_DVD_STATE_CORRUPT, L"The state data was corrupt.")
        CHK_ERR(VFW_E_DVD_STATE_WRONG_DISC, L"The state data is from a different disc.")
        CHK_ERR(VFW_E_DVD_INCOMPATIBLE_REGION, L"The region was not compatible with the current drive.")
        CHK_ERR(VFW_E_DVD_NO_ATTRIBUTES, L"The requested DVD stream attribute does not exist.")
        CHK_ERR(VFW_E_DVD_NO_GOUP_PGC, L"Currently there is no GoUp (Annex J user function) program chain (PGC).")
        CHK_ERR(VFW_E_DVD_LOW_PARENTAL_LEVEL, L"The current parental level was too low.")
        CHK_ERR(VFW_E_DVD_NOT_IN_KARAOKE_MODE, L"The current audio is not karaoke content.")
        CHK_ERR(VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE, L"The audio stream did not contain sufficient information to determine the contents of each channel.")
        CHK_ERR(VFW_S_DVD_NOT_ACCURATE, L"The seek into the movie was not frame accurate.")
        CHK_ERR(VFW_E_FRAME_STEP_UNSUPPORTED, L"Frame step is not supported on this configuration.")
        CHK_ERR(VFW_E_DVD_STREAM_DISABLED, L"The specified stream is disabled and cannot be selected.")
        CHK_ERR(VFW_E_DVD_TITLE_UNKNOWN, L"The operation depends on the current title number, however the navigator has not yet entered the VTSM or the title domains, so the 'current' title index is unknown.")
        CHK_ERR(VFW_E_DVD_INVALID_DISC, L"The specified path does not point to a valid DVD disc.")
        CHK_ERR(VFW_E_DVD_NO_RESUME_INFORMATION, L"There is currently no resume information.")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD, L"This thread has already blocked this output pin.  There is no need to call IPinFlowControl::Block() again.")
        CHK_ERR(VFW_E_PIN_ALREADY_BLOCKED, L"IPinFlowControl::Block() has been called on another thread.  The current thread cannot make any assumptions about this pin's block state.")
        CHK_ERR(VFW_E_CERTIFICATION_FAILURE, L"An operation failed due to a certification failure.")
        CHK_ERR(E_PROP_SET_UNSUPPORTED, L"The Specified property set is not supported.")
        CHK_ERR(E_PROP_ID_UNSUPPORTED, L"The specified property ID is not supported for the specified property set.")
   }
   
   return L"n/a";
}




//-----------------------------------------------------------------------------
// Name: DXTraceW()
// Desc: Outputs a formatted error message to the debug stream
//-----------------------------------------------------------------------------
HRESULT WINAPI DXTraceW( CHAR* strFile, DWORD dwLine, HRESULT hr, 
                         WCHAR* strMsg, BOOL bPopMsgBox )
{
    WCHAR strLine[50];
    WCHAR strError[200];
    WCHAR strBuffer[BUFFER_SIZE];
        
    swprintf( strLine, L"%ld", dwLine );
            
    if( strFile != NULL )
    {
        if( strlen(strFile) + 200 < BUFFER_SIZE )
        {        
           swprintf( strBuffer, L"%S(%s): ", strFile, strLine );
           OutputDebugStringW( strBuffer );
        }
    }

    if( strMsg != NULL )
        OutputDebugStringW( strMsg );

    swprintf( strError, L"%s (0x%0.8x)", DXGetErrorString8W(hr), hr );
    swprintf( strBuffer, L" (hr=%s)", strError );
    OutputDebugStringW( strBuffer );

    OutputDebugStringW( L"\n" );
    
    if( bPopMsgBox )
    {
        if( wcslen(strMsg) + strlen(strFile) + 
            wcslen(strLine) + wcslen(strError) + 200 < BUFFER_SIZE )
        {
            swprintf( strBuffer, L"File: %S\nLine: %s\nError Code: %s\nCalling: %s", 
                      strFile, strLine, strError, strMsg );
            MessageBoxW( NULL, strBuffer, L"Unexpected error encountered", MB_OK|MB_ICONERROR );
        }                              
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: DXTraceA()
// Desc: Outputs a formatted error message to the debug stream
//-----------------------------------------------------------------------------
HRESULT WINAPI DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, 
                         char* strMsg, BOOL bPopMsgBox )                 
{
    CHAR strLine[50];
    CHAR strError[200];
    CHAR strBuffer[BUFFER_SIZE];
        
    sprintf( strLine, "%ld", dwLine );
            
    if( strFile != NULL )
    {
        if( strlen(strFile) + 200 < BUFFER_SIZE )
        {
           sprintf( strBuffer, "%s(%s): ", strFile, strLine );
           OutputDebugStringA( strBuffer );
        }
    }

    if( strMsg != NULL )
        OutputDebugStringA( strMsg );

    sprintf( strError, "%s (0x%0.8x)", DXGetErrorString8A(hr), hr );
    sprintf( strBuffer, " (hr=%s)", strError );
    OutputDebugStringA( strBuffer );
    
    OutputDebugStringA( "\n" );
    
    if( bPopMsgBox )
    {
        if( strlen(strMsg) + strlen(strFile) + 
            strlen(strLine) + strlen(strError) + 200 < BUFFER_SIZE )
        {
            sprintf( strBuffer, "File: %s\nLine: %s\nError Code: %s\nCalling: %s", 
                     strFile, strLine, strError, strMsg );
            MessageBoxA( NULL, strBuffer, "Unexpected error encountered", MB_OK|MB_ICONERROR );
        }                              
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\msdmo\dmort.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// dmort.cpp - DMO runtime misc.
//
#include <windows.h>
#include "mediaobj.h"
#include "dmort.h"

//
// Mediatype stuff
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, ULONG cbFormat) {
   if (!pmt)
      return E_POINTER;
   pmt->pUnk = NULL;
   if (cbFormat) {
      pmt->pbFormat = (PBYTE)CoTaskMemAlloc(cbFormat);
      if (!pmt->pbFormat)
         return E_OUTOFMEMORY;
   }
   else
      pmt->pbFormat = NULL;
   pmt->cbFormat = cbFormat;
   return NOERROR;
}

STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt) {
   if (!pmt)
      return E_POINTER;
   if (pmt->pUnk) {
      pmt->pUnk->Release();
      pmt->pUnk = NULL;
   }
   if (pmt->pbFormat) {
      CoTaskMemFree(pmt->pbFormat);
      pmt->pbFormat = NULL;
   }
   return NOERROR;
}

// everything has been allocated - just copy
void CopyMediaTypeInternal(DMO_MEDIA_TYPE *pmtDest, DMO_MEDIA_TYPE const *pmtSrc) {
   if (pmtDest->cbFormat)
      memcpy(pmtDest->pbFormat, pmtSrc->pbFormat, pmtDest->cbFormat);

   if (pmtSrc->pUnk) {
      pmtSrc->pUnk->AddRef();
      pmtDest->pUnk = pmtSrc->pUnk;
   }
   
   pmtDest->majortype = pmtSrc->majortype;
   pmtDest->subtype = pmtSrc->subtype;
   pmtDest->bFixedSizeSamples = pmtSrc->bFixedSizeSamples;
   pmtDest->bTemporalCompression = pmtSrc->bTemporalCompression;
   pmtDest->lSampleSize = pmtSrc->lSampleSize;
   pmtDest->formattype = pmtSrc->formattype;
}

STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, DMO_MEDIA_TYPE const *pmtSrc) {
   if ((!pmtDest) || (!pmtSrc))
      return E_POINTER;

   ULONG cbFormat = pmtSrc->pbFormat ? pmtSrc->cbFormat : 0;

   HRESULT hr = MoInitMediaType(pmtDest, cbFormat);
   if (FAILED(hr))
      return hr;
   
   CopyMediaTypeInternal(pmtDest, pmtSrc);

   return NOERROR;
}

STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, ULONG cbFormat) {
   if (!ppmt)
      return E_POINTER;
   *ppmt = (DMO_MEDIA_TYPE*) CoTaskMemAlloc(sizeof(DMO_MEDIA_TYPE));
   if (!*ppmt)
      return E_OUTOFMEMORY;
   HRESULT hr = MoInitMediaType(*ppmt, cbFormat);
   if (FAILED(hr)) {
      CoTaskMemFree(*ppmt);
      *ppmt = NULL;
   }
   return hr;
}

STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt) {
   if (!pmt)
      return E_POINTER;
   HRESULT hr = MoFreeMediaType(pmt);
   CoTaskMemFree(pmt);
   return hr;
}

STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, DMO_MEDIA_TYPE const *pmtSrc) {
   if (!ppmtDest || !pmtSrc)
      return E_POINTER;

   ULONG cbFormat = pmtSrc->pbFormat ? pmtSrc->cbFormat : 0;

   HRESULT hr = MoCreateMediaType(ppmtDest, cbFormat);
   if (FAILED(hr))
      return hr;

   CopyMediaTypeInternal(*ppmtDest, pmtSrc);

   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\msdmo\dmoutils.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DMOUTILS_H__
#define __DMOUTILS_H__

#include <wchar.h>

// convert guid to string
STDAPI_(void) DMOGuidToStrA(char *szStr, REFGUID guid);
STDAPI_(void) DMOGuidToStrW(WCHAR *szStr, REFGUID guid);

// convert string to guid
STDAPI_(BOOL) DMOStrToGuidA(char *szStr, GUID *pguid);
STDAPI_(BOOL) DMOStrToGuidW(WCHAR *szStr, GUID *pguid);

#ifdef UNICODE
#define DMOStrToGuid DMOStrToGuidW
#define DMOGuidToStr DMOGuidToStrW
#else
#define DMOStrToGuid DMOStrToGuidA
#define DMOGuidToStr DMOGuidToStrA
#endif

#endif __DMOUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\msdmo\guidenum.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __GUIDENUM_H__
#define __GUIDENUM_H__

#include "mediaobj.h"

template<typename T> class CArrayContainer {
public:
   CArrayContainer(ULONG ulSize = 0) {
      if (ulSize) {
         m_ulMax = ulSize;
         m_ulUsed = 0;
         m_ar = (T*)malloc(ulSize * sizeof(T));
      }
      else
         m_ar = NULL;
   }

   ~CArrayContainer() {if (m_ar) free(m_ar);}

   HRESULT Add(const T& el) {
      if (!m_ar) {
         m_ulMax = 20;
         m_ulUsed = 0;
         m_ar = (T*)malloc(m_ulMax * sizeof(T));
         if (!m_ar)
            return E_OUTOFMEMORY;
      }
      else if (m_ulUsed == m_ulMax) {
         ULONG ulNew = m_ulMax + 20;
         T* pNew = (T*)realloc(m_ar, ulNew * sizeof(T));
         if (!pNew)
            return E_OUTOFMEMORY;
         m_ulMax = ulNew;
         m_ar = pNew;
      }
      m_ar[m_ulUsed++] = el;
      return NOERROR;
   }

   T* GetNth(ULONG ulPos) {
      if (ulPos >= m_ulUsed)
         return NULL;
      return &m_ar[ulPos];
   }

   ULONG GetSize(void) {
      return m_ulUsed;
   }

private:
   T* m_ar;
   ULONG m_ulMax;
   ULONG m_ulUsed;
};

// implements IEnumDMO, which is returned by DMO enumeration API
class CEnumDMOCLSID : public IEnumDMO {
public:
   CEnumDMOCLSID();
   ~CEnumDMOCLSID();

   // IUnknown
   STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();

   // enum
   STDMETHODIMP Next(ULONG celt, CLSID *pclsidItems, WCHAR **pszNames, ULONG *pceltFetched);
   STDMETHODIMP Skip(ULONG celt);
   STDMETHODIMP Reset(void);
   STDMETHODIMP Clone(IEnumDMO **ppenum);

   // private
   void Add(REFCLSID clsidDMO, WCHAR *szName);
private:
   typedef struct {
       CLSID clsid;
       WCHAR *szName;
   } Entry;
   volatile long m_cRef;
   CArrayContainer<Entry> m_store;
   ULONG m_ulPos;
};

#endif //__GUIDENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\msdmo\guidenum.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include "guidenum.h"

//
// implementation of the enumerator returned by DMO enumeration API
//

CEnumDMOCLSID::CEnumDMOCLSID() {
   m_cRef = 1;
   m_ulPos = 0;
}

CEnumDMOCLSID::~CEnumDMOCLSID() {
   Entry* pEntry;
   DWORD ulPos = 0;
   while (pEntry = m_store.GetNth(ulPos)) {
      delete [] pEntry->szName;
      ulPos++;
   }
}

HRESULT CEnumDMOCLSID::QueryInterface(REFIID riid, void **ppv) {

   if (NULL == ppv) {
      return E_POINTER;
   }

   if (riid == IID_IUnknown) {
      AddRef();
      *ppv = (IUnknown*)this;
      return NOERROR;
   }
   else if (riid == IID_IEnumDMO) {
      AddRef();
      *ppv = (IEnumDMO*)this;
      return NOERROR;
   }
   else
      return E_NOINTERFACE;
}

ULONG CEnumDMOCLSID::AddRef() {
   return InterlockedIncrement((long*)&m_cRef);
}

ULONG CEnumDMOCLSID::Release() {
   long l = InterlockedDecrement((long*)&m_cRef);
   if (l == 0) {
      delete this;
   }
   return l;
}

HRESULT CEnumDMOCLSID::Next(ULONG celt, CLSID *pCLSIDs, WCHAR **pszNames, ULONG *pceltFetched) {

   if( NULL == pCLSIDs ) {
      return E_POINTER;
   }

   if( (1 != celt) && (NULL == pceltFetched) ) {
      return E_INVALIDARG;
   }

   for (ULONG c = 0; c < celt; c++) {
      Entry* p = m_store.GetNth(m_ulPos + c);
      if (!p)
         break;
      pCLSIDs[c] = p->clsid;
      WCHAR* szSrc = p->szName;
      if (!szSrc)
         szSrc = L"";
      if (pszNames) {
          pszNames[c] = (WCHAR*) CoTaskMemAlloc(sizeof(WCHAR) * (wcslen(szSrc) + 1));
          if (pszNames[c]) {
             wcscpy(pszNames[c], szSrc);
          } else {
              for (ULONG c1 = 0; c1 < c; c1++) {
                  CoTaskMemFree(pszNames[c1]);
                  pszNames[c1] = NULL;
              }
              return E_OUTOFMEMORY;
          }
      }
   }
    
   if( NULL != pceltFetched ) {
      *pceltFetched = c;
   }

   m_ulPos += c;
   return (c == celt) ? S_OK : S_FALSE;
}

HRESULT CEnumDMOCLSID::Skip(ULONG celt) {
   m_ulPos += celt;

   // The documentation for IEnumXXXX::Skip() states that 
   // it returns "S_OK if the number of elements skipped 
   // is celt; otherwise S_FALSE." (MSDN Library April 2000).
   if( m_ulPos <= m_store.GetSize() ) {
      return S_OK;
   } else {
      return S_FALSE;
   }
}

HRESULT CEnumDMOCLSID::Reset(void) {
   m_ulPos = 0;
   return NOERROR;
}

HRESULT CEnumDMOCLSID::Clone(IEnumDMO ** ppenum) {
   return E_NOTIMPL;
}

void CEnumDMOCLSID::Add(REFCLSID clsidDMO, WCHAR* szName) {
   WCHAR *szNm = NULL;
   if (szName) {
      szNm = new WCHAR[wcslen(szName) + 1];
      if (szNm) {
         wcscpy(szNm, szName);
      } else {
          return;
      }
   }
   Entry e;
   e.clsid = clsidDMO;
   e.szName = szNm;
   m_store.Add(e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\inc\dmocom.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CComBase

b. Make a static CreateInstance function that takes an IUnknown* and an
   HRESULT*. The IUnknown* defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

c. Have a constructor for your object that passes the IUnknown* and HRESULT*
   to the CComBase constructor. You can set the HRESULT if you have an error,
   or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a CComClassTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CComBase
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use \() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CComBase constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NDQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NDQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

#include <windows.h>
#include <basetyps.h>
#include <unknwn.h>

extern int g_cActiveObjects;

STDAPI CreateCLSIDRegKey(REFCLSID clsid, const char *szName);

STDAPI RemoveCLSIDRegKey(REFCLSID clsid);

#ifdef DEBUG
    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif
    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}
#else
    #ifndef ASSERT
       #define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
#endif

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INDUNKNOWN_DEFINED
DECLARE_INTERFACE(INDUnknown)
{
    STDMETHOD(NDQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NDAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NDRelease)(THIS) PURE;
};
#define INDUNKNOWN_DEFINED
#endif

class CBaseObject {
public:
   CBaseObject() {g_cActiveObjects++;}
   ~CBaseObject() {g_cActiveObjects--;}
};

/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class CComBase : public INDUnknown,
                 CBaseObject
{
private:
    IUnknown* m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NDRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CComBase(IUnknown* pUnk);
    virtual ~CComBase() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CComBase(IUnknown* pUnk,HRESULT *phr);

    /* Return the owner of this object */

    IUnknown* GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CComBase *CreateInstance(IUnknown*, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NDQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NDAddRef();
    STDMETHODIMP_(ULONG) NDRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CComBase *(CALLBACK *LPFNNewCOMObject)(IUnknown* pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

struct CComClassTemplate {
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
};


/* You must override the (pure virtual) NDQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\msdmo\dmoutils.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <stdio.h>
#include "dmoutils.h"

// convert guid to string
void DMOGuidToStrA(char *szStr, REFGUID guid) {
   sprintf(szStr, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
           guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
           guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],
           guid.Data4[6], guid.Data4[7]);
}
void DMOGuidToStrW(WCHAR *szStr, REFGUID guid) {
   swprintf(szStr, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
           guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
           guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],
           guid.Data4[6], guid.Data4[7]);
}

// convert string to guid
BOOL DMOStrToGuidA(char *szStr, GUID *pguid) {
   DWORD temp[8];
   if (sscanf(szStr, "%08x-%04hx-%04hx-%02x%02x-%02x%02x%02x%02x%02x%02x",
           &pguid->Data1, &pguid->Data2, &pguid->Data3,
           &temp[0], &temp[1], &temp[2], &temp[3],
           &temp[4], &temp[5], &temp[6], &temp[7]) == 11) {
      for (DWORD c = 0; c < 8; c++)
         pguid->Data4[c] = (unsigned char)temp[c];
      return TRUE;
   }
   else
      return FALSE;
}
BOOL DMOStrToGuidW(WCHAR *szStr, GUID *pguid) {
   char szSrc[80];
   WideCharToMultiByte(0,0,szStr,-1,szSrc,80,NULL,NULL);
   return DMOStrToGuidA(szSrc, pguid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\msdmo\regenum.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// regenum.cpp - registration/enumeration part of DMO runtime
//
#include <windows.h>
#include <tchar.h>
#include "dmoreg.h"
#include "guidenum.h"
#include "shlwapi.h"
#include "dmoutils.h"

#define DMO_REGISTRY_HIVE HKEY_CLASSES_ROOT
#define DMO_REGISTRY_PATH TEXT("DirectShow\\MediaObjects")

#define INPUT_TYPES_STR   "InputTypes"
#define OUTPUT_TYPES_STR  "OutputTypes"
#define SUBTYPES_STR      "Subtypes"
#define KEYED_STR         "Keyed"
#define CATEGORIES_STR    "Categories"

#ifndef CHARS_IN_GUID
#define CHARS_IN_GUID 39
#endif


//  Helper copied from shwapi

/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns:
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey,
    IN LPCTSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKey(hkey, pszSubKey, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        TCHAR   szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = sizeof(szSubKeyName) / sizeof(szSubKeyName[0]);
        TCHAR   szClass[MAX_PATH];
        DWORD   cbClass = sizeof(szClass) / sizeof(szClass[0]);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (NO_ERROR == dwRet && dwIndex > 0)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}

// Automatically calls RegCloseKey when leaving scope
class CAutoHKey {
public:
   CAutoHKey() : m_hKey(NULL) {}
   ~CAutoHKey() {
       if (m_hKey)
           RegCloseKey(m_hKey);
   }
   LRESULT Create(HKEY hKey, LPCTSTR szSubKey)
   {
       return RegCreateKey(hKey, szSubKey, &m_hKey);
   }
   LRESULT Open(HKEY hKey, LPCTSTR szSubKey)
   {
       return RegOpenKey(hKey, szSubKey, &m_hKey);
   }
   void Close()
   {
       if (m_hKey) {
           RegCloseKey(m_hKey);
       }
       m_hKey = NULL;
   }
   HKEY m_hKey;
   HKEY Key() const { return m_hKey; }
};

// Automatically calls RegCloseKey when leaving scope
class CAutoCreateHKey {
public:
   CAutoCreateHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey) {
      if (RegCreateKeyEx(hKey,
                         szSubKey,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         MAXIMUM_ALLOWED,
                         NULL,
                         phKey,
                         NULL) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoCreateHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};

class CAutoOpenHKey {
public:
   CAutoOpenHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey, REGSAM samDesired = KEY_READ) {
      if (RegOpenKeyEx(hKey,
                       szSubKey,
                       0,
                       samDesired,
                       phKey) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoOpenHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};


HRESULT ReadTypesFromKeys(HKEY hkDMO, LPCTSTR pszTypes, DWORD *pcbData, PVOID *ppvData)
{
    //  Collect all the types into 1 value - need to enumerate
    //  keys and subkeys
    LPVOID pMem = CoTaskMemAlloc(0);
    unsigned int nEntries = 0;
    DWORD dwTypeIndex;
    BOOL bSuccess = TRUE;
    DMO_PARTIAL_MEDIATYPE Type;
    CAutoHKey hkSrc;
    if (NOERROR != hkSrc.Open(hkDMO, pszTypes)) {
        bSuccess = FALSE;
    }
    for (dwTypeIndex = 0; bSuccess; dwTypeIndex++) {
        TCHAR szType[MAX_PATH];
        LONG lResult = RegEnumKey(hkSrc.Key(), dwTypeIndex, szType, MAX_PATH);
        if (NOERROR != lResult) {
            if (ERROR_NO_MORE_ITEMS != lResult) {
                bSuccess = FALSE;
            }
            break;
        }
        if (DMOStrToGuid(szType, &Type.type)) {
            CAutoHKey kType;
            kType.Open(hkSrc.Key(), szType);
            if (NULL == kType.Key()) {
                bSuccess = FALSE;
            } else {
                DWORD dwSubtypeIndex;
                for (dwSubtypeIndex = 0; bSuccess; dwSubtypeIndex++) {
                    TCHAR szSubtype[MAX_PATH];
                    lResult = RegEnumKey(kType.Key(), dwSubtypeIndex, szSubtype, MAX_PATH);
                    if (NOERROR != lResult) {
                        if (ERROR_NO_MORE_ITEMS != lResult) {
                            bSuccess = FALSE;
                        }
                        break;
                    }
                    if (DMOStrToGuid(szSubtype, &Type.subtype)) {
                        //  Add to our list
                        LPVOID pMemNew = CoTaskMemRealloc(pMem,
                                            (nEntries + 1) * sizeof(DMO_PARTIAL_MEDIATYPE));
                        if (NULL == pMemNew) {
                            bSuccess = FALSE;
                        } else {
                            pMem = pMemNew;
                            CopyMemory((LPBYTE)pMem +
                                        nEntries * sizeof(DMO_PARTIAL_MEDIATYPE),
                                        &Type,
                                        sizeof(DMO_PARTIAL_MEDIATYPE));
                            nEntries++;
                        }
                    }
                }
            }
        }
    }
    if (bSuccess && nEntries != 0) {
        *ppvData = pMem;
        *pcbData = nEntries * sizeof(DMO_PARTIAL_MEDIATYPE);
        return S_OK;
    } else {
        CoTaskMemFree(pMem);
        return S_FALSE;
    }
}

HRESULT ReadTypes(HKEY hkDMO, LPCTSTR pszTypes, DWORD *pcbData, PVOID *ppvData)
{
    *pcbData = 0;

    //  Try reading the value first
    DWORD cbData;
    if (NOERROR != RegQueryValueEx(hkDMO, pszTypes, NULL, NULL, NULL, &cbData)) {
        return ReadTypesFromKeys(hkDMO, pszTypes, pcbData, ppvData);
    }
    if (cbData == 0) {
        return S_OK;
    }
    PVOID pvData = (PBYTE)CoTaskMemAlloc(cbData);
    if (NULL == pvData) {
        return E_OUTOFMEMORY;
    }
    if (NOERROR == RegQueryValueEx(hkDMO, pszTypes, NULL, NULL, (PBYTE)pvData, &cbData)) {
        *ppvData = pvData;
        *pcbData = cbData;
        return S_OK;
    } else {
        CoTaskMemFree(pvData);
        return E_OUTOFMEMORY;
    }
}



/////////////////////////////////////////////////////////////////////////////
//
// DMO Registration code
//

// Registration helper
void CreateObjectGuidKey(HKEY hKey, REFCLSID clsidDMO) {
   TCHAR szSubkeyName[80];

   HKEY hObjectGuidKey;
   DMOGuidToStr(szSubkeyName, clsidDMO);
   CAutoCreateHKey kGuid(hKey, szSubkeyName, &hObjectGuidKey);
}

// Registration helper
// Registers types\subtypes underneath the object's key
void RegisterTypes(HKEY hObjectKey,
                   TCHAR* szInputOrOutput,
                   ULONG ulTypes,
                   const DMO_PARTIAL_MEDIATYPE* pTypes) {
    RegSetValueEx(hObjectKey, szInputOrOutput, 0, REG_BINARY,
                  (const BYTE *)pTypes,
                  ulTypes * sizeof(DMO_PARTIAL_MEDIATYPE));
}

//
// Public entry point
//
STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   unsigned long ulInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   unsigned long ulOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
) {
   TCHAR szSubkeyName[80];
   if ((clsidDMO == GUID_NULL) || (guidCategory == GUID_NULL))
      return E_INVALIDARG;

   // Create/open the main DMO key
   HKEY hMainKey;
   CAutoCreateHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   HKEY hCategoriesKey;
   CAutoCreateHKey kCats(hMainKey, TEXT(CATEGORIES_STR), &hCategoriesKey);
   if (hCategoriesKey == NULL)
      return E_FAIL;

   // Create/open the category specific subkey underneath the main key
   DMOGuidToStr(szSubkeyName, guidCategory);
   HKEY hCategoryKey;
   CAutoCreateHKey kCat(hCategoriesKey, szSubkeyName, &hCategoryKey);
   if (hCategoryKey == NULL)
      return E_FAIL;

   //  Deletet the redundant old types keys
   DeleteKeyRecursively(hCategoryKey, TEXT(INPUT_TYPES_STR));
   DeleteKeyRecursively(hCategoryKey, TEXT(OUTPUT_TYPES_STR));

   // If the category key does not have a name yet, add one
   DWORD cbName;
   DWORD dwType;

   if ((RegQueryValueEx(hCategoryKey, NULL, NULL, &dwType, NULL, &cbName) != ERROR_SUCCESS) ||
       (cbName <= sizeof(TCHAR)) || (REG_SZ != dwType)) {
      TCHAR* szName;
      if (guidCategory == DMOCATEGORY_AUDIO_DECODER)
         szName = TEXT("Audio decoders");
      else if (guidCategory == DMOCATEGORY_AUDIO_ENCODER)
         szName = TEXT("Audio encoders");
      else if (guidCategory == DMOCATEGORY_VIDEO_DECODER)
         szName = TEXT("Video decoders");
      else if (guidCategory == DMOCATEGORY_VIDEO_ENCODER)
         szName = TEXT("Video encoders");
      else if (guidCategory == DMOCATEGORY_AUDIO_EFFECT)
         szName = TEXT("Audio effects");
      else if (guidCategory == DMOCATEGORY_VIDEO_EFFECT)
         szName = TEXT("Video effects");
      else if (guidCategory == DMOCATEGORY_AUDIO_CAPTURE_EFFECT)
         szName = TEXT("Audio capture effects");
     else if (guidCategory == DMOCATEGORY_ACOUSTIC_ECHO_CANCEL)
         szName = TEXT("Acoustic Echo Canceller");
      else if (guidCategory == DMOCATEGORY_AUDIO_NOISE_SUPPRESS)
         szName = TEXT("Audio Noise Suppressor");
      else if (guidCategory == DMOCATEGORY_AGC)
         szName = TEXT("Automatic Gain Control");
      else
         szName = TEXT("Unknown DMO category");
      RegSetValue(hCategoryKey, NULL, REG_SZ, szName, lstrlen(szName) * sizeof(TCHAR));
   }

   // Create/open the object specific key underneath the category key
   DMOGuidToStr(szSubkeyName, clsidDMO);

   //  Remove the old one
   DeleteKeyRecursively(hMainKey, szSubkeyName);

   HKEY hObjKey;
   CAutoCreateHKey kObj(hCategoryKey, szSubkeyName, &hObjKey);
   if (hObjKey == NULL)
      return E_FAIL;

   // Create/open the object specific key underneath the main key
   DMOGuidToStr(szSubkeyName, clsidDMO); // BUGBUG: redundant
   HKEY hObjectKey;
   CAutoCreateHKey kObject(hMainKey, szSubkeyName, &hObjectKey);
   if (hObjectKey == NULL)
      return E_FAIL;

   // set the default value of the object key to the name of the DMO
#ifdef UNICODE
   LPCWSTR sz = szName;
#else
   char sz[80];
   WideCharToMultiByte(0,0,szName,-1,sz,80,NULL,NULL);
#endif
   if (RegSetValue(hObjectKey, NULL, REG_SZ, sz, lstrlen(sz) * sizeof(TCHAR))
        != ERROR_SUCCESS)
      return E_FAIL;

   // If the object is keyed, add a registry value indicating so
   if (dwFlags & DMO_REGISTERF_IS_KEYED) {
      if (RegSetValue(hObjectKey, TEXT(KEYED_STR), REG_SZ, TEXT(""), 0)
            != ERROR_SUCCESS)
         return E_FAIL;
   }

   // Register types
   if (ulInTypes) {
      RegisterTypes(hObjectKey,   TEXT(INPUT_TYPES_STR), ulInTypes, pInTypes);
   }

   if (ulOutTypes) {
      RegisterTypes(hObjectKey,   TEXT(OUTPUT_TYPES_STR),ulOutTypes,pOutTypes);
   }

   // Nuke the DShow filter cache
   DeleteKeyRecursively(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie\\Filter Cache"));

   return NOERROR;
}

// helper
void MakeSubkeyName (TCHAR* szSubkeyName,
                     REFGUID guidCategory,
                     REFCLSID clsidDMO) {
   DMOGuidToStr(szSubkeyName, guidCategory);
   _tcscat(szSubkeyName, TEXT("\\"));
   DMOGuidToStr(szSubkeyName + lstrlen(szSubkeyName), clsidDMO);
}


//
// Public entry point
//
STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory
) {
   HRESULT hr;

   // open the root DMO key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey, MAXIMUM_ALLOWED);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the "Categories" key underneath the root key
   HKEY hCategoriesKey;
   CAutoOpenHKey kCats(hMainKey, TEXT(CATEGORIES_STR), &hCategoriesKey, MAXIMUM_ALLOWED);
   if (hCategoriesKey == NULL)
      return E_FAIL;

   // Iterate through all categories attempting to delete from each one
   TCHAR szCategory[80];
   DWORD dwIndex = 0;
   BOOL bDeletedAnything = FALSE;
   BOOL bDeletedAll = TRUE;
   DMOGuidToStr(szCategory, guidCategory);

   while (RegEnumKey(hCategoriesKey, dwIndex, szCategory, 80) == ERROR_SUCCESS) {

      // process the subkey only if it resembles a category GUID
      GUID guid;
      if (DMOStrToGuid(szCategory, &guid)) {

         // Try to delete from this category
         TCHAR szSubkeyName[256];
         MakeSubkeyName(szSubkeyName, guid, clsidDMO);
         if (guidCategory == GUID_NULL || guid == guidCategory) {
         if (DeleteKeyRecursively(hCategoriesKey, szSubkeyName) == ERROR_SUCCESS)
            bDeletedAnything = TRUE;
         } else {
             CAutoHKey hk;
             if (ERROR_FILE_NOT_FOUND != hk.Open(hCategoriesKey, szSubkeyName)) {
                 bDeletedAll = FALSE;
             }
         }
      }
      dwIndex++;
   }

   if (bDeletedAnything) {
      hr = S_OK;
      if (bDeletedAll) {
         // Now delete this object's key from underneath the root DMO key
         TCHAR szGuid[CHARS_IN_GUID];
         DMOGuidToStr(szGuid, clsidDMO);
         if (DeleteKeyRecursively(hMainKey, szGuid) != ERROR_SUCCESS) {
             hr = S_FALSE;
         }
      }
   }
   else
      hr = S_FALSE;

   return hr;

}
//
// End DMO Registration code
//
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//
// DMO Enumeration code
// Some of it leaves room for future improvements in terms of speed
//

// helper
HRESULT ReadName(HKEY hDMOKey, WCHAR szName[80]) {
   LONG cbSize = 80;
#ifdef UNICODE
   if (RegQueryValue(hDMOKey, NULL, szName, &cbSize) == ERROR_SUCCESS)
      return S_OK;
#else
   char szTmp[80];
   if (RegQueryValue(hDMOKey, NULL, szTmp, &cbSize) == ERROR_SUCCESS) {
      MultiByteToWideChar(0,0,szTmp,-1,szName,80);
      return S_OK;
   }
#endif
   else {
      szName[0] = L'\0'; // no name - corrupt registry ?
      return S_FALSE;
   }
}

// Enumeration helper, does what the name says
void LookupNameAndAddToEnum(HKEY hObjectKey,
                            TCHAR* szGuid,
                            DWORD dwFlags,
                            REFCLSID clsidDMO,
                            CEnumDMOCLSID* pEnum) {
   // Skip keyed DMOs unless explicitly asked to include them
   if (!(dwFlags & DMO_ENUMF_INCLUDE_KEYED)) {
      // open the DMO's registry key
      LONG cbValue;
      if (RegQueryValue(hObjectKey, TEXT(KEYED_STR), NULL, &cbValue)
           == ERROR_SUCCESS)
         return; // DMO is keyed - skip
   }

   WCHAR szName[80];
   if (FAILED(ReadName(hObjectKey, szName)))
      szName[0] = L'\0';

   pEnum->Add(clsidDMO, szName);
}


//  Check if any of the requested types match
//  If no requested types are specified then this is treated
//  as a match
BOOL CompareTypes(HKEY hkDMO,
                  unsigned long ulTypes,
                  const DMO_PARTIAL_MEDIATYPE *pTypes,
                  LPCTSTR pszTypesValue)
{
    if (ulTypes == 0) {
        return TRUE;
    }
    DWORD cbData;
    PVOID pvDMOTypes = NULL;
    if (S_OK == ReadTypes(hkDMO, pszTypesValue, &cbData, &pvDMOTypes)) {
        for (unsigned long ulType = 0; ulType < ulTypes; ulType++) {
            DMO_PARTIAL_MEDIATYPE *pDMOTypes = (DMO_PARTIAL_MEDIATYPE *)pvDMOTypes;
            while ((PBYTE)(pDMOTypes + 1) <= (PBYTE)pvDMOTypes + cbData) {
                if (pDMOTypes->type == pTypes[ulType].type ||
                    pDMOTypes->type == GUID_NULL ||
                    pTypes[ulType].type == GUID_NULL) {
                    if (pTypes[ulType].subtype == GUID_NULL ||
                        pDMOTypes->subtype == GUID_NULL ||
                        pTypes[ulType].subtype == pDMOTypes->subtype) {
                        CoTaskMemFree(pvDMOTypes);
                        return TRUE;
                    }
                }
                pDMOTypes++;
            }
        }
    }
    CoTaskMemFree(pvDMOTypes);
    return FALSE;
}

// Enumeration helper
HRESULT EnumerateDMOs(HKEY hMainKey,
                      HKEY hCatKey,
                      DWORD dwFlags,
                      unsigned long ulInputTypes,
                      const DMO_PARTIAL_MEDIATYPE *pInputTypes,
                      unsigned long ulOutputTypes,
                      const DMO_PARTIAL_MEDIATYPE *pOutputTypes,
                      CEnumDMOCLSID *pEnum) {
    DWORD dwIndex = 0;
    TCHAR szSubkey[80];
    while (RegEnumKey(hCatKey, dwIndex, szSubkey, 80) == ERROR_SUCCESS) {
        // Does this look like an object CLSID ?
        CLSID clsidDMO;
        if (DMOStrToGuid(szSubkey, &clsidDMO)) {
            // Do the type match?
            CAutoHKey hkDMO;
            if (NOERROR == hkDMO.Open(hMainKey, szSubkey)) {
                if (CompareTypes(hkDMO.Key(), ulInputTypes, pInputTypes, TEXT(INPUT_TYPES_STR)) &&
                    CompareTypes(hkDMO.Key(), ulOutputTypes, pOutputTypes, TEXT(OUTPUT_TYPES_STR))) {
                    LookupNameAndAddToEnum(hkDMO.Key(), szSubkey, dwFlags, clsidDMO, pEnum);
                }
            }
        }
        dwIndex++;
    }
    return S_OK;
}
//
// Public entry point
//
STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   unsigned long ulInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   unsigned long ulOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes,// can be NULL only of ulOutTypes = 0
   IEnumDMO **ppEnum
) {
    if (ppEnum == NULL) {
        return E_POINTER;
    }
    if (ulInTypes > 0 && pInTypes == NULL ||
        ulOutTypes > 0 && pOutTypes == NULL) {
        return E_INVALIDARG;
    }

    *ppEnum = NULL;

    // open the root key
    CAutoHKey kMain;
    kMain.Open(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH);
    if (kMain.Key() == NULL)
        return E_FAIL;

    CEnumDMOCLSID *pEnum = new CEnumDMOCLSID();
    if (!pEnum)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (guidCategory == GUID_NULL) {

        hr = EnumerateDMOs(kMain.Key(),
                           kMain.Key(),
                           dwFlags,
                           ulInTypes,
                           pInTypes,
                           ulOutTypes,
                           pOutTypes,
                           pEnum);
    } else {

        // open the subkey for the specified category and enumerate its subkeys
        TCHAR szCategory[CHARS_IN_GUID];
        TCHAR szCategoryPath[MAX_PATH];
        DMOGuidToStr(szCategory, guidCategory);
        wsprintf(szCategoryPath, TEXT(CATEGORIES_STR) TEXT("\\%s"), szCategory);
        CAutoHKey key2;
        key2.Open(kMain.Key(), szCategoryPath);
        if (key2.Key()) {
            hr = EnumerateDMOs(kMain.Key(),
                               key2.Key(),
                               dwFlags,
                               ulInTypes,
                               pInTypes,
                               ulOutTypes,
                               pOutTypes,
                               pEnum);
        }
    }

    if (SUCCEEDED(hr)) {
        *ppEnum = (IEnumDMO*) pEnum;
        hr = S_OK;
    } else {
        delete pEnum;
    }
    return hr;
}
//  Copy the type information
HRESULT FetchTypeInfo(HKEY hObjKey, LPCTSTR pszTypesValue,
                      unsigned long ulTypesRequested,
                      unsigned long *pulTypesSupplied,
                      DMO_PARTIAL_MEDIATYPE *pTypes)
{
    DWORD cbData;
    unsigned long ulTypesCopied = 0;
    PVOID pvData;
    if (S_OK == ReadTypes(hObjKey, pszTypesValue, &cbData, &pvData)) {
        ulTypesCopied =
                min(ulTypesRequested, cbData / sizeof(DMO_PARTIAL_MEDIATYPE));
        CopyMemory(pTypes, pvData,
                   ulTypesCopied * sizeof(DMO_PARTIAL_MEDIATYPE));
        CoTaskMemFree(pvData);
    }
    *pulTypesSupplied = ulTypesCopied;
    return ulTypesCopied != 0 ? S_OK : S_FALSE;
}

// Mediatype helper
HRESULT FetchMediatypeInfo(HKEY hObjKey,
                           unsigned long ulInputTypesRequested,
                           unsigned long *pulInputTypesSupplied,
                           DMO_PARTIAL_MEDIATYPE *pInputTypes,
                           unsigned long ulOutputTypesRequested,
                           unsigned long *pulOutputTypesSupplied,
                           DMO_PARTIAL_MEDIATYPE *pOutputTypes) {

   HRESULT hr1 = S_OK;
   if (ulInputTypesRequested) {
      hr1 = FetchTypeInfo(hObjKey,
                          TEXT(INPUT_TYPES_STR),
                          ulInputTypesRequested,
                          pulInputTypesSupplied,
                          pInputTypes);
   } else {
       *pulInputTypesSupplied = 0;
   }
   HRESULT hr2 = S_OK;
   if (ulOutputTypesRequested) {
      hr2 = FetchTypeInfo(hObjKey,
                          TEXT(OUTPUT_TYPES_STR),
                          ulOutputTypesRequested,
                          pulOutputTypesSupplied,
                          pOutputTypes);
   } else {
       *pulOutputTypesSupplied = 0;
   }
   if ((hr1 == S_OK) && (hr2 == S_OK))
      return S_OK;
   else
      return S_FALSE;
}

//
// Public entry point
//
STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
) {
   // open the DMO root registry key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the object specific guid key
   TCHAR szGuid[80];
   DMOGuidToStr(szGuid, clsidDMO);
   HKEY hObjKey;
   CAutoOpenHKey kObj(hMainKey, szGuid, &hObjKey);
   if (!hObjKey)
      return E_FAIL;

   return FetchMediatypeInfo(hObjKey,
                             ulInputTypesRequested,
                             pulInputTypesSupplied,
                             pInputTypes,
                             ulOutputTypesRequested,
                             pulOutputTypesSupplied,
                             pOutputTypes);
}


STDAPI DMOGetName(REFCLSID clsidDMO, WCHAR szName[80]) {
   // open the DMO root registry key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the object specific guid key
   TCHAR szGuid[80];
   DMOGuidToStr(szGuid, clsidDMO);
   HKEY hObjKey;
   CAutoOpenHKey kObj(hMainKey, szGuid, &hObjKey);
   if (!hObjKey)
      return E_FAIL;

   return ReadName(hObjKey, szName);
}

//
// End DMO Enumeration code
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\filter.cpp ===
#include <streams.h>
#include <amstream.h>
#include <atlbase.h>
#include <initguid.h>
#include <dmoreg.h>
#include <mediaerr.h>
#include <wmsecure.h>
#include <wmsdk.h>      // needed for IWMReader
#include "filter.h"
#include "inpin.h"
#include "outpin.h"


//
//  Helper - locks or unlocks a sample if it represents a
//  DirectDraw surface
//
bool LockUnlockSurface(IMediaSample *pSample, bool bLock)
{
    CComPtr<IDirectDrawMediaSample> pDDSample;
    if (SUCCEEDED(pSample->QueryInterface(IID_IDirectDrawMediaSample, (void **)&pDDSample))) {
        if (!bLock) {
            return S_OK == pDDSample->GetSurfaceAndReleaseLock(NULL, NULL);
        } else {
            return S_OK == pDDSample->LockMediaSamplePointer();
        }
    }

    CComPtr<IDirectDrawSurface> pSurface;
    if (SUCCEEDED(pSample->QueryInterface(IID_IDirectDrawSurface, (void **)&pSurface))) {
        if (!bLock) {
            if (SUCCEEDED(pSurface->Unlock(NULL))) {
                return true;
            } else {
                return false;
            }
        } else {
            DDSURFACEDESC ddsd;
            ddsd.dwSize = sizeof(ddsd);
            HRESULT hr = pSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);
            if (FAILED(hr)) {
                DbgLog((LOG_STREAM, 1, TEXT("Failed to relock surface code(%x)"), hr));
            }
            return S_OK == hr;
        }
    }
    return false;
}

//
// Used for input IMediaBuffers.  Has extra code to deal with IMediaSample.
//
class CMediaBufferOnIMediaSample : public CBaseMediaBuffer {
public:
      CMediaBufferOnIMediaSample(IMediaSample *pSample, HRESULT *phr) {
      *phr = pSample->GetPointer(&m_pData);
      if (FAILED(*phr)) {
         return;
      }
      if (!m_pData) {
         *phr = E_POINTER;
         return;
      }
      m_ulSize = pSample->GetSize();
      DbgLog((LOG_STREAM,4,"in %d", m_ulSize));
      m_ulData = pSample->GetActualDataLength();
      pSample->AddRef();
      m_pSample = pSample;
      m_cRef = 1;
      *phr = NOERROR;
   }
   STDMETHODIMP_(ULONG) Release() { // override to release the sample
      long l = InterlockedDecrement((long*)&m_cRef);
      if (l == 0) {
         m_pSample->Release();
         delete this;
      }
      return l;
   }
private:
   IMediaSample *m_pSample;
};

CMediaWrapperFilter::CMediaWrapperFilter(
    LPUNKNOWN pUnkOwner,
    HRESULT *phr
) : CBaseFilter(NAME("CMediaWrapperFilter"),
                NULL,
                &m_csFilter,
                CLSID_DMOWrapperFilter),
    m_pMediaObject(NULL),
    m_pDMOQualityControl(NULL),
    m_pDMOOutputOptimizations(NULL),
    m_pUpstreamQualityControl(NULL),
    m_pDMOUnknown(NULL),
    m_pWrapperSecureChannel(NULL),
    m_pCertUnknown(NULL),
    m_clsidDMO(GUID_NULL),
    m_guidCat(GUID_NULL),
    m_fErrorSignaled( FALSE )
{

    LogPrivateEntry(LOG_INIT, "filter ctor");
    m_pInputPins = NULL;
    m_pOutputPins = NULL;
    m_OutputBufferStructs = NULL;

    *phr = RefreshPinList();
}


CMediaWrapperFilter::~CMediaWrapperFilter()
{
   LogPrivateEntry(LOG_INIT, "filter dtor");
   FreePerStreamStuff();

    if (m_pDMOOutputOptimizations) {
        GetOwner()->AddRef(); // the AddRef is required by COM aggregation rules
        m_pDMOOutputOptimizations->Release();
    }
    if (m_pDMOQualityControl) {
        GetOwner()->AddRef(); // the AddRef is required by COM aggregation rules
        m_pDMOQualityControl->Release();
    }

    if (m_pMediaObject) {
        GetOwner()->AddRef(); // the AddRef is required by COM aggregation rules
        m_pMediaObject->Release();
    }

    // let the inner object know that the whole thing is going away
    if (m_pDMOUnknown) {
        m_pDMOUnknown->Release();
    }

    // release the app certificate if we got one, note that we expect this to have
    // been done when the filter was removed from the graph
    if (m_pCertUnknown) {
        m_pCertUnknown->Release();
    }

    // release secure channel object if we created one
    if( m_pWrapperSecureChannel ) {
        m_pWrapperSecureChannel->WMSC_Disconnect();
        m_pWrapperSecureChannel->Release();
    }

}

template <class T> void ArrayNew(T* &p, ULONG n, bool &fSuccess) {
   ASSERT(!p);
   delete[] p;
   p = NULL;

   if (!fSuccess) {
      return;
   }

   p = new T[n];

   if (!p) {
      fSuccess = false;
   }
}

HRESULT CMediaWrapperFilter::AllocatePerStreamStuff(ULONG cInputs, DWORD cOutputs) {
   LogPrivateEntry(LOG_INIT, "AllocatePerStreamStuff");
   bool fSuccess = true;
   ArrayNew(m_pInputPins, cInputs, fSuccess);
   ArrayNew(m_pOutputPins, cOutputs, fSuccess);
   ArrayNew(m_OutputBufferStructs, cOutputs, fSuccess);

   if (!fSuccess) {
      return E_OUTOFMEMORY;
   }
   // Initialize these so DeletePins() can be called right away
   DWORD c;
   for (c = 0; c < cInputs; c++)
      m_pInputPins[c] = NULL;
   for (c = 0; c < cOutputs; c++)
      m_pOutputPins[c] = NULL;
   return NOERROR;
}

void CMediaWrapperFilter::FreePerStreamStuff() {
   LogPrivateEntry(LOG_INIT, "FreePerStreamStuff");
   DeletePins();

   delete[] m_pInputPins;
   m_pInputPins = NULL;

   delete[] m_pOutputPins;
   m_pOutputPins = NULL;

   delete[] m_OutputBufferStructs;
   m_OutputBufferStructs = NULL;

   m_cInputPins = m_cOutputPins = 0;
}

void CMediaWrapperFilter::DeletePins()
{
   LogPrivateEntry(LOG_INIT, "DeletePins");
    if (m_pInputPins) {
        for (DWORD c = 0; c < m_cInputPins; c++) {
            if (m_pInputPins[c]) {
                delete m_pInputPins[c];
                m_pInputPins[c] = NULL;
            }
        }
    }
    if (m_pOutputPins) {
        for (DWORD c = 0; c < m_cOutputPins; c++) {
            if (m_pOutputPins[c]) {
                delete m_pOutputPins[c];
                m_pOutputPins[c] = NULL;
            }
        }
    }
}

STDMETHODIMP CMediaWrapperFilter::Run(REFERENCE_TIME rtStart) {
   HRESULT hrRun = CBaseFilter::Run(rtStart);
   LogHResult(hrRun, LOG_STATE, "Run", "CBaseFilter::Run()");
   if (FAILED(hrRun)) {
      return hrRun;
   }

   if (m_pDMOQualityControl) {
      HRESULT hr;
      hr = m_pDMOQualityControl->SetStatus(DMO_QUALITY_STATUS_ENABLED);
      LogHResult(hr, LOG_STATE, "Run", "m_pDMO->QualityEnable");
   }

   return hrRun;
}

STDMETHODIMP  CMediaWrapperFilter::Pause() {
   LogPublicEntry(LOG_STATE, "Pause");
   CAutoLock l(&m_csFilter);

   if(!m_pMediaObject) {
       return E_FAIL;
   }

   if (m_pDMOQualityControl) {
      HRESULT hr;
      hr = m_pDMOQualityControl->SetStatus(0);
      LogHResult(hr, LOG_STATE, "Pause", "m_pDMO->QualityDisable");
   }

   if (m_State == State_Stopped) {
      DbgLog((LOG_STATE,4,"Stopped => Paused"));

      m_fErrorSignaled = FALSE;

      //CAutoLock l2(&m_csStreaming);
      //  First allocate streaming resources
      HRESULT hr = TranslateDMOError(m_pMediaObject->AllocateStreamingResources());
      if (FAILED(hr)) {
          return hr;
      }
      for (DWORD c = 0; c < m_cInputPins; c++)
         m_pInputPins[c]->m_fEOS = false;
      for (c = 0; c < m_cOutputPins; c++) {
         m_pOutputPins[c]->m_fEOS = false;

         m_pOutputPins[c]->m_fNeedsPreviousSample = false;
         if (m_pOutputPins[c]->m_fAllocatorHasOneBuffer && m_pDMOOutputOptimizations) {
            // Offer to always supply the same buffer
            DWORD dwFlags;
            HRESULT hr = m_pDMOOutputOptimizations->QueryOperationModePreferences(c, &dwFlags);
            if (dwFlags & DMO_VOSF_NEEDS_PREVIOUS_SAMPLE) {
               hr = m_pDMOOutputOptimizations->SetOperationMode(c, DMO_VOSF_NEEDS_PREVIOUS_SAMPLE);
               if (SUCCEEDED(hr)) {
                  m_pOutputPins[c]->m_fNeedsPreviousSample = true;
               }
            }
         }
      }
      m_fNoUpstreamQualityControl = false;
      m_pUpstreamQualityControl = NULL;

   }
   HRESULT hr = CBaseFilter::Pause();
   LogHResult(hr, LOG_STATE, "Pause", "CBaseFilter::Pause");
   return hr;
}

STDMETHODIMP  CMediaWrapperFilter::Stop()
{
    LogPublicEntry(LOG_STATE, "Stop");
    CAutoLock l(&m_csFilter);

    if(!m_pMediaObject) {
        return E_FAIL;
    }

    //  BUGBUG do any graph rearrangement stuff

    //  Flush our object - but only after we've synced our input
    //  pins

    //  First stop the filter, free allocators or whatever
    HRESULT hr = CBaseFilter::Stop();
    LogHResult(hr, LOG_STATE, "Stop", "CBaseFilter::Stop");
    //  Sync to the input pins
    for (ULONG ulIndex = 0; ulIndex < m_cInputPins; ulIndex++) {
            m_pInputPins[ulIndex]->SyncLock();
    }

    //  NOW, grab our streaming lock and flush the object
    CAutoLock l2(&m_csStreaming);
    hr = TranslateDMOError(m_pMediaObject->Flush());
    LogHResult(hr, LOG_STATE, "Stop", "IMediaObject::Flush");

    hr = TranslateDMOError(m_pMediaObject->FreeStreamingResources());
    LogHResult(hr, LOG_STATE, "Stop", "IMediaObject::FreeStreamingResources");

    if (m_pUpstreamQualityControl) {
       m_pUpstreamQualityControl->Release();
       m_pUpstreamQualityControl = NULL;
    }
    m_fNoUpstreamQualityControl = false;

    return S_OK;
}

//  Override to handle multiple output streams case
STDMETHODIMP CMediaWrapperFilter::GetState(DWORD dwMilliseconds, FILTER_STATE *pfs)
{
    HRESULT hr = CBaseFilter::GetState(dwMilliseconds, pfs);

    //  If we have > 1 output pin connected then say we can't cue
    //  or we'll block pause forever
    //  We might want to use output queues in future
    if (SUCCEEDED(hr) && m_State == State_Paused) {
        DWORD cOutputPinsConnected = 0;
        for (DWORD c = 0; c < m_cOutputPins; c++) {
            if (m_pOutputPins[c]->IsConnected()) {
                cOutputPinsConnected++;
            }
        }
        if (cOutputPinsConnected > 1) {
            hr  = VFW_S_CANT_CUE;
        }
    }
    return hr;
}

int CMediaWrapperFilter::GetPinCount()
{
    CAutoLock l(&m_csFilter);
    return (int)(m_cInputPins + m_cOutputPins);
}

HRESULT CMediaWrapperFilter::Init(REFCLSID clsidDMO, REFCLSID guidCat)
{
    LogPublicEntry(LOG_INIT, "Init");
    CAutoLock l(&m_csFilter);

    ASSERT( !m_pDMOUnknown );
    
    HRESULT hr;
    m_cRef++;
    hr = CoCreateInstance(clsidDMO,
                          GetOwner(),
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void**)&m_pDMOUnknown);
    m_cRef--;
    LogHResult(hr, LOG_INIT, "Init", "CoCreateInstance");
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pDMOUnknown->QueryInterface(IID_IMediaObject, (void**)&m_pMediaObject);
    LogHResult(hr, LOG_INIT, "Init", "QI(IMediaObject)");
    if (FAILED(hr)) {
        m_pDMOUnknown->Release();

        //  If we don't set this to NULL we crash in the destructor
        m_pDMOUnknown = NULL;
        m_pMediaObject = NULL;
        return hr;
    }
    GetOwner()->Release(); // this is the official COM hack for this situation

    //
    // check and see if we're already in the graph
    // (which will happen when we're loaded from a grf),
    // if so, we should know by now whether the app we're in is secure or not
    //
    if( m_pGraph )
    {
        HRESULT hrCert = SetupSecureChannel();
        LogHResult(hr, LOG_SECURECHANNEL, "Init", "SetupSecureChannel");
        if( FAILED( hrCert ) )
        {
            //
            // !!note that if we fail when loaded from a grf our best fallout is to
            // return the failure here, before we've created our pins
            //
            return hrCert;
        }
    }

    hr = m_pDMOUnknown->QueryInterface(IID_IDMOQualityControl, (void**)&m_pDMOQualityControl);
    if (SUCCEEDED(hr)) { // eliminate the cirtular ref count
        DbgLog((LOG_STREAM, 2, "DMO supports quality control"));
        GetOwner()->Release();
    }
    else { // No problem, just make sure m_pDMOQualityControl stays NULL
        DbgLog((LOG_STREAM, 2, "DMO does not support quality control"));
        m_pDMOQualityControl = NULL;
    }

    hr = m_pDMOUnknown->QueryInterface(IID_IDMOVideoOutputOptimizations, (void**)&m_pDMOOutputOptimizations);
    if (SUCCEEDED(hr)) { // eliminate the cirtular ref count
        DbgLog((LOG_STREAM, 4, "DMO supports output optimizations"));
        GetOwner()->Release();
    }
    else {
        DbgLog((LOG_STREAM, 4, "DMO does not support output optimizations"));
        m_pDMOOutputOptimizations = NULL;
    }

    m_clsidDMO = clsidDMO;
    m_guidCat = guidCat;
    RefreshPinList();

    return S_OK;
}

// This just returns the first input pin (if there is one).  Looks
// like we will never fully support multiple input streams anyway.
CWrapperInputPin* CMediaWrapperFilter::GetInputPinForPassThru() {
   LogPrivateEntry(LOG_INIT, "GetInputPinForPosPassThru");
   CAutoLock l(&m_csFilter);
   if (m_cInputPins) {
      return m_pInputPins[0];
   } else {
      return NULL;
   }
}

// ------------------------------------------------------------------------
//
// JoinFilterGraph - need to be in graph to initialize keying mechanism
//
// ------------------------------------------------------------------------
STDMETHODIMP CMediaWrapperFilter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    LogPrivateEntry(LOG_INIT, "JoinFilterGraph");

    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if(FAILED( hr ) )
        return hr;

    if( !pGraph )
    {
        //
        // if filter is removed from the graph, release the certification object.
        // we don't allow secure DMOs to be run outside of a graph
        //
        if( m_pCertUnknown )
        {
            m_pCertUnknown->Release();
            m_pCertUnknown = NULL;
        }
    }
    else
    {
        ASSERT( !m_pCertUnknown );
        //
        // see whether the dshow app is an IServiceProvider (in case this is a secure dmo)
        //
        IObjectWithSite *pSite;
        HRESULT hrCert = m_pGraph->QueryInterface( IID_IObjectWithSite, (VOID **)&pSite );
        if( SUCCEEDED( hrCert ) )
        {
            IServiceProvider *pSP;
            hrCert = pSite->GetSite( IID_IServiceProvider, (VOID **)&pSP );
            pSite->Release();
            LogHResult(hrCert, LOG_SECURECHANNEL, "JoinFilterGraph", "IObjectWithSite->GetSite");
            if( SUCCEEDED( hrCert ) )
            {
                hrCert = pSP->QueryService( IID_IWMReader, IID_IUnknown, (void **) &m_pCertUnknown );
                pSP->Release();
                LogHResult(hrCert, LOG_SECURECHANNEL, "JoinFilterGraph", "IServiceProvider->QI(IWMReader)");
#ifdef DEBUG
                if( SUCCEEDED( hrCert ) )
                {
                    DbgLog( ( LOG_TRACE, 5, TEXT("CMediaWrapperFilter::JoinFilterGraph got app cert (pUnkCert = 0x%08lx)"), m_pCertUnknown ) );
                }
#endif
            }
        }
        // if we were loaded from a grf then our m_pMediaObject wouldn't have been
        // created yet so we can't check dmo security
        if( m_pMediaObject )
        {
            hr = SetupSecureChannel();
            LogHResult(hrCert, LOG_SECURECHANNEL, "JoinFilterGraph", "SetupSecureChannel");
            if( FAILED( hr ) )
            {
                // up-oh, we failed to join, but the base class thinks we did,
                // so we need to unjoin the base class
                CBaseFilter::JoinFilterGraph(NULL, NULL);
            }
        }
    }
    return hr;
}

// ------------------------------------------------------------------------
//
// SetupSecureChannel
//
// ------------------------------------------------------------------------
HRESULT CMediaWrapperFilter::SetupSecureChannel()
{
    ASSERT( m_pGraph );
    ASSERT( m_pMediaObject );
    if( !m_pGraph )
        return E_UNEXPECTED;

    if( !m_pMediaObject )
        return E_UNEXPECTED;

    if( m_pWrapperSecureChannel )
    {
        // must already have a secure channel set up, right?
        return S_OK;
    }

#ifdef _X86_
    //
    // next check whether this is a secure dmo
    //
    IWMGetSecureChannel * pGetSecureChannel;

    HRESULT hr = m_pMediaObject->QueryInterface( IID_IWMGetSecureChannel, ( void ** )&pGetSecureChannel );
    LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "m_pMediaObject->QI(IWMGetSecureChannel)");
    if( SUCCEEDED( hr ) )
    {
        // it is, do we have a certificate from the app?
        if( m_pCertUnknown )
        {
            //
            // pass app certification to dmo through secure channel
            //
            IWMSecureChannel * pCodecSecureChannel;
            hr = pGetSecureChannel->GetPeerSecureChannelInterface( &pCodecSecureChannel );
            LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "pGetSecureChannel->GetPeerSecureChannelInterface");
            if ( SUCCEEDED( hr ) )
            {
                // setup a secure channel on our side (the dmo wrapper side)
                hr = WMCreateSecureChannel( &m_pWrapperSecureChannel );
                LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "WMCreateSecureChannel failed");
                if( SUCCEEDED( hr ) )
                {
                    IWMAuthorizer * pWMAuthorizer;
                    // QI the pCertUnknown for IWMAuthorizer before passing it down to the dmo!
                    hr = m_pCertUnknown->QueryInterface( IID_IWMAuthorizer, (void ** ) &pWMAuthorizer );
                    if( SUCCEEDED( hr ) )
                    {
                        // pass the channel a pointer to the app certificate's IWMAuthorizer
                        hr = m_pWrapperSecureChannel->WMSC_AddCertificate( pWMAuthorizer );
                        LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "m_pWrapperSecureChannel->WMSC_AddCertificate");
                        if( SUCCEEDED( hr ) )
                        {
                            // connect the dmo wrapper's secure channel to the codec's
                            hr = m_pWrapperSecureChannel->WMSC_Connect( pCodecSecureChannel );
                            LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "m_pWrapperSecureChannel->WMSC_Connect");
                        }
                        pWMAuthorizer->Release();
                    }
                    if( FAILED( hr ) )
                    {
                        // release the m_pWrapperSecureChannel if anything failed within this scope
                        m_pWrapperSecureChannel->Release();
                        m_pWrapperSecureChannel = NULL;
                    }

                }
                pCodecSecureChannel->Release();
            }
        }
        else
        {
            // if not a secure app then refuse to join the graph
            hr = VFW_E_CERTIFICATION_FAILURE;
        }

        pGetSecureChannel->Release();
    }
    else
    {
        //
        // this dmo's not secure so just return success and continue on
        //
        hr = S_OK;
    }
    return hr;
#else
    // wmsdk not supported on non-x86 and WIN64 platforms, for those just return success
    return S_OK;
#endif
}


HRESULT CMediaWrapperFilter::QualityNotify(ULONG ulOutputIndex, Quality q) {
   HRESULT hr;
   DbgLog((LOG_STREAM, 4, "QualityNotify(%08X%08X = %08X%08X + %08X%08X)",
           (DWORD)((q.TimeStamp + q.Late) >> 32), (DWORD)(q.TimeStamp + q.Late),
           (DWORD)(q.TimeStamp >> 32), (DWORD)q.TimeStamp,
           (DWORD)(q.Late >> 32), (DWORD)q.Late));

   // Try our DMO
   if (m_pDMOQualityControl) {
      hr = m_pDMOQualityControl->SetNow(q.TimeStamp + q.Late);

      LogHResult(hr, LOG_STREAM, "QualityNotify", "DMO->SetNow");

      return hr;
   }

   { // lock scope
      CAutoLock l(&m_csQualityPassThru);
      // Try the upstream filter
      if (!m_fNoUpstreamQualityControl) {
         return E_FAIL; // Don't check for this more than once
      }

      if (!m_pUpstreamQualityControl) { // Try to get the interface
         // Assume falilure
         m_fNoUpstreamQualityControl = true;

         CWrapperInputPin* pInPin = GetInputPinForPassThru();
         if (!pInPin) {
            return E_FAIL;
            DbgLog((LOG_STREAM, 4, "QualityNotify: no input pin"));
         }
         IPin* pUpstreamPin = pInPin->GetConnected();
         if (!pUpstreamPin) {
            DbgLog((LOG_STREAM, 4, "QualityNotify: no upstream pin (???)"));
            return E_FAIL;
         }
         HRESULT hr;
         hr = pUpstreamPin->QueryInterface(IID_IQualityControl, (void**)&m_pUpstreamQualityControl);
         LogHResult(hr, LOG_STREAM, "QualityNotify", "UpstreamPin->QI(IQualityControl)");
         if (FAILED(hr)) {
            m_pUpstreamQualityControl = NULL;
            return hr;
         }

         // Succeeded if we got here
         m_fNoUpstreamQualityControl = false;
      }
   } // lock scope

   hr = m_pUpstreamQualityControl->Notify(this, q);
   LogHResult(hr, LOG_STREAM, "QualityNotify", "UpstreamPin->Notify");
   return hr;
}

CBasePin * CMediaWrapperFilter::GetPin(int iPin)
{
    CAutoLock l(&m_csFilter);
    DWORD ulPin = (DWORD) iPin;
    if (ulPin < m_cInputPins) {
        return m_pInputPins[ulPin];
    }
    else if (ulPin < m_cInputPins + m_cOutputPins) {
        return m_pOutputPins[ulPin - m_cInputPins];
    } else {
        return NULL;
    }
}

HRESULT CMediaWrapperFilter::RefreshPinList()
{
    CAutoLock l(&m_csFilter);
    LogPrivateEntry(LOG_INIT, "RefreshPinList");

    //  Free old ones
    FreePerStreamStuff();

    DWORD cInputStreams, cOutputStreams;
    HRESULT hr;

    if (m_pMediaObject) {
       hr = TranslateDMOError(m_pMediaObject->GetStreamCount(
           &cInputStreams,
           &cOutputStreams));

       if (FAILED(hr)) {
           return hr;
       }
    }
    else {
       cInputStreams = 0;
       cOutputStreams = 0;
    }

    m_cInputPins = cInputStreams;
    m_cOutputPins = cOutputStreams;
    if (FAILED(hr = AllocatePerStreamStuff(m_cInputPins, m_cOutputPins))) {
       return E_OUTOFMEMORY;
    }

    //  Check input and output pins
    //  Note that this loop is designed to recover if anything
    //  fails
    DWORD c;
    for (c = 0; c < m_cInputPins; c++) m_pInputPins[c] = NULL;
    for (c = 0; c < m_cOutputPins; c++) m_pOutputPins[c] = NULL;

    for (c = 0; c < m_cInputPins; c++) {
       m_pInputPins[c] = new CWrapperInputPin(this, c, &hr);
       if (NULL == m_pInputPins[c]) {
          hr = E_OUTOFMEMORY;
       }
    }
    for (c = 0; c < m_cOutputPins; c++) {
       //  See if this pin is optional
       DWORD dwFlags;
       hr = TranslateDMOError(m_pMediaObject->GetOutputStreamInfo(c, &dwFlags));
       if (SUCCEEDED(hr)) {
           m_pOutputPins[c] =
               new CWrapperOutputPin(this, c, 0 != (dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL), &hr);
           if (NULL == m_pOutputPins[c]) {
              hr = E_OUTOFMEMORY;
           }
       }
    }

    if (FAILED(hr)) {
        FreePerStreamStuff();
    }

    return hr;
}

// Check a media type
HRESULT CMediaWrapperFilter::InputCheckMediaType(ULONG ulInputIndex, const AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "InputCheckMediaType");
   return TranslateDMOError(m_pMediaObject->SetInputType(ulInputIndex,
                                                         pmt,
                                                         DMO_SET_TYPEF_TEST_ONLY));
}
HRESULT CMediaWrapperFilter::OutputCheckMediaType(ULONG ulOutputIndex, const AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "OutputCheckMediaType");
   return TranslateDMOError(m_pMediaObject->SetOutputType(ulOutputIndex, pmt, DMO_SET_TYPEF_TEST_ONLY));
}

// Set a media type
HRESULT CMediaWrapperFilter::InputSetMediaType(ULONG ulInputIndex, const CMediaType *pmt)
{
   LogPublicEntry(LOG_CONNECT, "InputSetMediaType");
    HRESULT hr = TranslateDMOError(m_pMediaObject->SetInputType(ulInputIndex, pmt, 0));
    if (FAILED(hr)) {
       return hr;
    }
    return m_pInputPins[ulInputIndex]->CBaseInputPin::SetMediaType(pmt);
}
HRESULT CMediaWrapperFilter::OutputSetMediaType(ULONG ulOutputIndex, const AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "OutputSetMediaType");
    return TranslateDMOError(m_pMediaObject->SetOutputType(ulOutputIndex, pmt, 0));
}

// get a media type
HRESULT CMediaWrapperFilter::InputGetMediaType(ULONG ulInputIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "InputGetMediaType");
    CAutoLock lck(&m_csFilter);
    return TranslateDMOError(m_pMediaObject->GetInputType(ulInputIndex, ulTypeIndex, pmt));
}
HRESULT CMediaWrapperFilter::OutputGetMediaType(ULONG ulOutputIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "OutputGetMediaType");
    CAutoLock lck(&m_csFilter);
    return TranslateDMOError(m_pMediaObject->GetOutputType(ulOutputIndex, ulTypeIndex, pmt));
}

HRESULT CMediaWrapperFilter::InputGetAllocatorRequirements(ULONG ulInputIndex, ALLOCATOR_PROPERTIES *pProps) {
   DWORD dwLookahead;
   LogPublicEntry(LOG_CONNECT, "InputGetAllocatorRequirements");
   HRESULT hr = TranslateDMOError(m_pMediaObject->GetInputSizeInfo(
                              ulInputIndex,
                              (ULONG*)&pProps->cbBuffer,
                              &dwLookahead,
                              (ULONG*)&pProps->cbAlign));
   LogHResult(hr, LOG_CONNECT, "InputGetAllocatorRequirements", "IMediaObject::GetInputSizeInfo");
   if (FAILED(hr)) {
      return hr;
   }

   pProps->cBuffers = 1;

   return NOERROR;
}

HRESULT CMediaWrapperFilter::OutputDecideBufferSize(
    ULONG ulOutputIndex,
    IMemAllocator *pAlloc,
    ALLOCATOR_PROPERTIES *ppropRequest
)
{
   LogPublicEntry(LOG_CONNECT,"OutputDecideBufferSize");
    DWORD cbBuffer, cbAlign, cbPrefix;
    HRESULT hr = TranslateDMOError(m_pMediaObject->GetOutputSizeInfo(
                                     ulOutputIndex,
                                     &cbBuffer,
                                     &cbAlign));
    LogHResult(hr, LOG_CONNECT,"OutputDecideBufferSize", "GetOutputSizeInfo");

    DbgLog((LOG_CONNECT,3,"output stream %lu wants %d-byte buffers", ulOutputIndex, cbBuffer));

    //  Why?
    if (cbBuffer < 16384) {
       cbBuffer = 16384;
    }
    cbPrefix = 0;

    if (SUCCEEDED(hr)) {
        ppropRequest->cBuffers = 1;
        ppropRequest->cbBuffer = max((long)cbBuffer, ppropRequest->cbBuffer);
        ppropRequest->cbAlign = max((long)cbAlign, ppropRequest->cbAlign);
        ppropRequest->cbPrefix = max((long)cbPrefix, ppropRequest->cbPrefix);
        ALLOCATOR_PROPERTIES propActual;
        hr = pAlloc->SetProperties(ppropRequest, &propActual);
        LogHResult(hr, LOG_CONNECT,"OutputDecideBufferSize", "Allocator::SetProperties");

        DbgLog((LOG_CONNECT,3,"output stream %lu will use %d %d-byte buffers", ulOutputIndex, propActual.cBuffers, propActual.cbBuffer));

        if (propActual.cBuffers == 1) {
           m_pOutputPins[ulOutputIndex]->m_fAllocatorHasOneBuffer = true;
        } else {
           m_pOutputPins[ulOutputIndex]->m_fAllocatorHasOneBuffer = false;
        }
    }
    return hr;
}

HRESULT CMediaWrapperFilter::DeliverInputSample(ULONG ulInputIndex, IMediaSample *pSample) {
    HRESULT hr;
    BYTE* pData = NULL;
    bool bTimeStamp = false, bTimeLength = false;
    REFERENCE_TIME rtStart = 0, rtStop = 0;
    bool bSyncPoint = false;

    LogPrivateEntry(LOG_STREAM, "DeliverInputSample");

    // Get misc. flags and fields from the IMediaSample
    if (SUCCEEDED(hr = pSample->GetTime(&rtStart, &rtStop))) {
        bTimeStamp = true;
        // assume rtStop is invalid if it either precedes
        // start or trailis it by more than 1 hour.
        if ((rtStop >= rtStart) && (rtStop <= rtStart + 10000000 * (REFERENCE_TIME)3600)) {
            bTimeLength = true;
        }
    }
    if (pSample->IsSyncPoint() == S_OK) {
        bSyncPoint = true;
    }

    // If there is a discontinuity, send it before the data
    // BUGBUG: this requires additional code to work correctly with multiple input streams.
    // We should probably at least deliver anything stuck in the input queues before
    // executing the discontuinuity.  In any case, we haven't thought through the multiple
    // input stream case, so this is probably not the first place that would break...
    if (pSample->IsDiscontinuity() == S_OK) {
        DbgLog((LOG_STREAM, 4, "discontinuity on input stream %lu", ulInputIndex));
        hr = TranslateDMOError(m_pMediaObject->Discontinuity(ulInputIndex));
        LogHResult(hr,LOG_STREAM,"DeliverInputSample","IMediaObject::Discontinuity");
        if (FAILED(hr)) {
            return hr;
        }

        hr = SuckOutOutput();
        LogHResult(hr, LOG_STATE,"Discontinuity", "SuckOutOutput");
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create a media buffer from the sample
    CMediaBufferOnIMediaSample *pBuffer = new CMediaBufferOnIMediaSample(pSample, &hr);
    if (!pBuffer) {
        DbgLog((LOG_STREAM,0,"could not create a CMediaBufferOnIMediaSample"));
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        LogHResult(hr, LOG_STREAM, "DeliverInputSample", "CMediaBufferOnIMediaSample ctor");
        delete pBuffer;
        return hr;
    }

    if( m_pWrapperSecureChannel )
    {
        // encrypt the buffer pointer if this is a secure dmo
        CMediaBufferOnIMediaSample * pEncryptedBuffer = pBuffer;

        HRESULT hrSecure = m_pWrapperSecureChannel->WMSC_Encrypt(
                                   (BYTE *)&pEncryptedBuffer,
                                   sizeof(BYTE *) );
        LogHResult(hrSecure, LOG_SECURECHANNEL, "DeliverInputSample", "m_pWrapperSecureChannel->WMSC_Encrypt");
        if( SUCCEEDED( hrSecure ) )
        {
            // Deliver the buffer
            hr = TranslateDMOError(m_pMediaObject->ProcessInput(
                        ulInputIndex,
                        pEncryptedBuffer,
                        (bSyncPoint ? DMO_INPUT_DATA_BUFFERF_SYNCPOINT : 0) |
                        (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIME : 0) |
                        (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIMELENGTH : 0),
                        rtStart,
                        rtStop - rtStart));
        }
        else
        {
            // hmm, what should we do?
            hr = hrSecure; // ?
        }
    }
    else
    {
        // Deliver the buffer
        hr = TranslateDMOError(m_pMediaObject->ProcessInput(
                    ulInputIndex,
                    pBuffer,
                    (bSyncPoint ? DMO_INPUT_DATA_BUFFERF_SYNCPOINT : 0) |
                    (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIME : 0) |
                    (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIMELENGTH : 0),
                    rtStart,
                    rtStop - rtStart));
    }
    LogHResult(LOG_STREAM, 4, "DeliverInputSample", "IMediaObject::ProcessInput");
    pBuffer->Release();

    //  Handle flushing.  We test here so that if BeginFlush is
    //  called after we enter Receive() we still wind up flushing
    //  this buffer:
    //  Cases:
    //    1.  BeginFlush sets m_bFlushing before this line
    //        -- this is OK - we Flush()
    //    2.  BeginFlush sets m_bFlushing after this line
    //        -- this is OK - BeginFlush will call Flush()
    if (m_pInputPins[ulInputIndex]->m_bFlushing) {
        m_pMediaObject->Flush();
        hr = E_FAIL;
    }
    return hr;
}

// helper
void CMediaWrapperFilter::FreeOutputSamples() {
   LogPrivateEntry(LOG_STREAM,"FreeOutputSamples");
   for (DWORD c = 0; c < m_cOutputPins; c++) {
      if (m_pOutputPins[c]->m_pMediaSample) {
         if (m_pOutputPins[c]->m_fNeedToRelockSurface) {
             m_pOutputPins[c]->m_fNeedToRelockSurface = false;
             LockUnlockSurface(m_pOutputPins[c]->m_pMediaSample, true);
         }
         m_pOutputPins[c]->m_pMediaSample->Release();
         m_pOutputPins[c]->m_pMediaSample = NULL;
      }
   }
}
HRESULT CMediaWrapperFilter::SuckOutOutput(DiscardType bDiscard) {
    bool bOutputIncomplete;
    HRESULT hr;
    DWORD c;
    DWORD dwStatus;
    LogPrivateEntry(LOG_STREAM,"SuckOutOutput");
    for (c = 0; c < m_cOutputPins; c++) {
        // Initialize these so FreeOutputSamples() can work
        m_pOutputPins[c]->m_pMediaSample = NULL;
        // Initially all outputs need buffers because we just delivered new data
        if (m_pOutputPins[c]->IsConnected() && !(c == 0 && bDiscard == NullBuffer)) {
            m_pOutputPins[c]->m_fStreamNeedsBuffer = true;
        } else {
            m_pOutputPins[c]->m_fStreamNeedsBuffer = false;
        }
    }
    do { // do while incomplete

        bool bPrelock = false;

        // Prepare the output buffers
        for (c = 0; c < m_cOutputPins; c++) {
            // Does this output need a buffer ?
            if (m_pOutputPins[c]->m_fStreamNeedsBuffer) {
                DbgLog((LOG_STREAM,4,"output stream %lu needs a buffer", c));
                // Yes, make one
                // First check if the DMO insists on seeing the previous sample
                bool bUsePreviousSample = m_pOutputPins[c]->m_fNeedsPreviousSample;
                if (bUsePreviousSample) {
                    // ask if we could please use a different buffer this time
                    DWORD dwFlags;
                    hr = m_pDMOOutputOptimizations->GetCurrentSampleRequirements(c, &dwFlags);
                    if (SUCCEEDED(hr) && !(dwFlags & DMO_VOSF_NEEDS_PREVIOUS_SAMPLE)) {
                        bUsePreviousSample = false;
                    }
                }
                DWORD dwGBFlags = 0;
                if (bUsePreviousSample) {
                    dwGBFlags = AM_GBF_NOTASYNCPOINT; // this secretly means we want the same buffer
                    DbgLog((LOG_STREAM, 3, "Asking for the previous buffer again"));
                }
                hr = m_pOutputPins[c]->GetDeliveryBuffer(&(m_pOutputPins[c]->m_pMediaSample), NULL, NULL, dwGBFlags);
                LogHResult(hr, LOG_STREAM, "SuckOutOutput", "GetDeliveryBuffer");
                if (FAILED(hr)) {
                    FreeOutputSamples();
                    return hr;
                }

                BYTE *pData;
                hr = m_pOutputPins[c]->m_pMediaSample->GetPointer(&pData);
                LogHResult(hr, LOG_STREAM, "SuckOutOutput", "GetPointer");
                if (FAILED(hr)) {
                    FreeOutputSamples();
                    return hr;
                }

                //  Unlock prior to locking DMO
                if (m_pOutputPins[c]->m_fVideo) {
                    bool bNeedToRelock =
                        LockUnlockSurface(m_pOutputPins[c]->m_pMediaSample, false);
                    m_pOutputPins[c]->m_fNeedToRelockSurface = bNeedToRelock;
                    if (bNeedToRelock) {
                        bPrelock = true;
                    }
                } else {
                    m_pOutputPins[c]->m_fNeedToRelockSurface = false;
                }


                // check for dynamic output type change
                DMO_MEDIA_TYPE* pmt;
                hr = m_pOutputPins[c]->m_pMediaSample->GetMediaType(&pmt);
                if (hr == S_OK) {
                    DbgLog((LOG_CONNECT,2,"on-the-fly type change on output stream %lu", c));
                    hr = TranslateDMOError(m_pMediaObject->SetOutputType(c, pmt, 0));
                    LogHResult(hr, LOG_CONNECT, "SuckOutOutput", "IMediaObject::SetOutputType");
                    if (FAILED(hr)) {
                        FreeOutputSamples();
                        return hr;
                    }
                }

                m_pOutputPins[c]->m_MediaBuffer.Init(pData, m_pOutputPins[c]->m_pMediaSample->GetSize());
                m_OutputBufferStructs[c].pBuffer = &(m_pOutputPins[c]->m_MediaBuffer);

            }
            else { // No, this output does not need a buffer
                m_OutputBufferStructs[c].pBuffer = NULL;
            }
        }

        //  Do prelocking - this is all to get round ddraw surface
        //  locking issues - we want the surface locked after
        //  the DMO lock in case the DMO calls ddraw or something

        if (bPrelock) {
            m_pMediaObject->Lock(TRUE);

            //  Relock all the samples
            for (DWORD c = 0; c < m_cOutputPins; c++) {
                if (m_pOutputPins[c]->m_fNeedToRelockSurface) {
                    m_pOutputPins[c]->m_fNeedToRelockSurface = false;
                    if (!LockUnlockSurface(m_pOutputPins[c]->m_pMediaSample, true)) {
                        DbgLog((LOG_STREAM, 1, TEXT("Failed to relock surface")));
                        m_pMediaObject->Lock(FALSE);
                        FreeOutputSamples();
                        return E_FAIL;
                    }
                }
            }
        }

        if( m_pWrapperSecureChannel )
        {
            // encrypt the buffer pointer if this is a secure dmo
            DMO_OUTPUT_DATA_BUFFER * pEncryptedOutputBufferStructs = m_OutputBufferStructs;

            HRESULT hrSecure = m_pWrapperSecureChannel->WMSC_Encrypt(
                                        (BYTE *)&pEncryptedOutputBufferStructs,
                                        sizeof(BYTE *) );
            LogHResult(hrSecure, LOG_SECURECHANNEL, "SuckOutOutput", "m_pWrapperSecureChannel->WMSC_Encrypt");
            if( SUCCEEDED( hrSecure ) )
            {
                // call process using encrypted buffer ptr
                hr = TranslateDMOError(m_pMediaObject->ProcessOutput(
                                             DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER,
                                             m_cOutputPins,
                                             pEncryptedOutputBufferStructs,
                                             &dwStatus));
            }
            else
            {
                m_fErrorSignaled = TRUE;
                NotifyEvent( EC_ERRORABORT, hrSecure, 0 );
                return hrSecure;
            }
        }
        else
        {
            // call process
            hr = TranslateDMOError(m_pMediaObject->ProcessOutput(
                                         DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER,
                                         m_cOutputPins,
                                         m_OutputBufferStructs,
                                         &dwStatus));
        }

        if (bPrelock) {
            m_pMediaObject->Lock(FALSE);
        }
        LogHResult(hr, LOG_STREAM, "SuckOutOutput", "IMediaObject::ProcessOutput");
        if (FAILED(hr))
        {
            FreeOutputSamples();
            if( E_OUTOFMEMORY == hr )
            {
                //
                // abort on critical dmo failures only (it's still unclear what these are)
                //
                m_fErrorSignaled = TRUE;
                NotifyEvent( EC_ERRORABORT, hr, 0 );
                return hr;
            }
            else
            {
                //
                // in most cases the dmo can continue to receive samples (for instance on E_FAIL),
                // so just eat the error and return
                //
                return S_OK;
            }
        }

        // See what the object produced
        bOutputIncomplete = false;
        for (c = 0; c < m_cOutputPins; c++) {
            // Did we supply a buffer ?
            if (m_OutputBufferStructs[c].pBuffer) {

                // Migrate IMediaSample members to the IMediaBuffer
                if (m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT) {
                    m_pOutputPins[c]->m_pMediaSample->SetSyncPoint(TRUE);
                }
                if (m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_TIME) {
                    if (m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH) {
                        m_OutputBufferStructs[c].rtTimelength += m_OutputBufferStructs[c].rtTimestamp;
                        m_pOutputPins[c]->m_pMediaSample->SetTime(&m_OutputBufferStructs[c].rtTimestamp, &m_OutputBufferStructs[c].rtTimelength);
                    }
                    else {
                        m_pOutputPins[c]->m_pMediaSample->SetTime(&m_OutputBufferStructs[c].rtTimestamp, NULL);
                    }
                }

                ULONG ulProduced;
                m_OutputBufferStructs[c].pBuffer->GetBufferAndLength(NULL, &ulProduced);
                DbgLog((LOG_STREAM, 4, "output stream %lu produced %lu bytes", c, ulProduced));
                if (ulProduced && (bDiscard == KeepOutput || c != 0)) {
                    m_pOutputPins[c]->m_pMediaSample->SetActualDataLength(ulProduced);
                    // Deliver
                    hr = m_pOutputPins[c]->Deliver(m_pOutputPins[c]->m_pMediaSample);
                    LogHResult(hr, LOG_STREAM, "SuckOutOutput", "Deliver");
                    if( S_OK != hr )
                    {
                        FreeOutputSamples();
                        return hr;
                    }
                }
                m_pOutputPins[c]->m_pMediaSample->Release();
                m_pOutputPins[c]->m_pMediaSample = NULL;
            }
            // check INCOMPLETE, even if it was previously set
            if ((m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) &&
                m_pOutputPins[c]->IsConnected() && !(c == 0 && bDiscard == NullBuffer)) {
                DbgLog((LOG_STREAM, 4, "Output stream %lu is incomplete", c));
                m_pOutputPins[c]->m_fStreamNeedsBuffer = true;
                bOutputIncomplete = true;
            }
            else
                m_pOutputPins[c]->m_fStreamNeedsBuffer = false;
        }

    } while (bOutputIncomplete);
    return NOERROR;
}

//
// BUGBUG: implement these queue methods for real
//
HRESULT CMediaWrapperFilter::EnqueueInputSample(ULONG ulInputIndex,
                                             IMediaSample *pSample) {
   LogPrivateEntry(LOG_STREAM, "EnqueueInputSample");
   return E_NOTIMPL;
   // pSample->AddRef();
}
IMediaSample* CMediaWrapperFilter::DequeueInputSample(ULONG ulInputIndex) {
   LogPrivateEntry(LOG_STREAM, "DequeueInputSample");
   return NULL;
   // pSample->Release();
}
bool CMediaWrapperFilter::InputQueueEmpty(ULONG ulInputIndex) {
   LogPrivateEntry(LOG_STREAM, "InputQueueEmpty");
   return true;
}

HRESULT CMediaWrapperFilter::InputNewSegment
(
    ULONG ulInputIndex,
    REFERENCE_TIME tStart,
    REFERENCE_TIME tStop,
    double dRate
)
{
    LogPrivateEntry(LOG_STREAM, "InputNewSegment");
    CAutoLock lck(&m_csStreaming);

    HRESULT hr = S_OK;
    for (DWORD cOut = 0; cOut < m_cOutputPins; cOut++)
    {
        if (InputMapsToOutput(ulInputIndex, cOut))
        {
            hr = m_pOutputPins[cOut]->DeliverNewSegment(tStart, tStop, dRate);

            // just log any error and continue
            LogHResult(hr, LOG_STREAM, "InputNewSegment", "DeliverNewSegment");
        }
    }
    hr = m_pInputPins[ulInputIndex]->CBaseInputPin::NewSegment(tStart, tStop, dRate);
    LogHResult(hr, LOG_STREAM, "InputNewSegment", "CBaseInputPin::NewSegment");
    return hr;
}

void CMediaWrapperFilter::PropagateAnyEOS() {
   LogPrivateEntry(LOG_STREAM, "PropagateAnyEOS");
   // check every output pin
   for (DWORD cOut = 0; cOut < m_cOutputPins; cOut++) {
      // Have we already delivered an EOS on this output pin ?
      if (m_pOutputPins[cOut]->m_fEOS) {
         continue; // Yes, don't bother with this pin anymore.
         DbgLog((LOG_STATE,4,"EndOfStream already delivered on output stream %lu", cOut));
      }

      // check if all inputs connected to this output are done
      bool bEOSOnEveryConnectedInput = true;
      for (DWORD cIn = 0; cIn < m_cInputPins; cIn++) {
         if (InputMapsToOutput(cIn, cOut) &&
             !(m_pInputPins[cIn]->m_fEOS && InputQueueEmpty(cIn))
            ) { // some input not complete yet
            bEOSOnEveryConnectedInput = false;
            break;
         }
      }
      if (!bEOSOnEveryConnectedInput) {
         DbgLog((LOG_STATE, 5, "some input connected to output stream %lu has yet to receive an EOS", cOut));
         continue; // not yet, better luck next time
      }

      // deliver output EOS
      HRESULT hr;
      hr = m_pOutputPins[cOut]->DeliverEndOfStream(); // bugbug - retval ?
      LogHResult(hr, LOG_STATE, "PropagateAnyEOS", "DeliverEndOfStream");
      m_pOutputPins[cOut]->m_fEOS = true;
   }
}

HRESULT CMediaWrapperFilter::NewSample(ULONG ulInputIndex, IMediaSample *pSample)
{
   HRESULT hr;
   LogPublicEntry(LOG_STREAM, "NewSample");
   if( m_fErrorSignaled )
   {
      return S_FALSE;
   }

   ASSERT(ulInputIndex < m_cInputPins);

   { // stream lock scope
      CAutoLock lck(&(m_pInputPins[ulInputIndex]->m_csStream));

      hr = m_pInputPins[ulInputIndex]->CBaseInputPin::Receive(pSample);
      LogHResult(hr, LOG_STREAM, "NewSample", "CBaseInputPin::Receive");
      if (S_OK != hr) {
         return hr;
      }

      if (m_pInputPins[ulInputIndex]->m_fEOS) { // we have already received EOS on this input
         DbgLog((LOG_STREAM | LOG_STATE, 2, "Receive() after EOS on input stream %lu - rejecting !", ulInputIndex));
         return S_FALSE; // should this be a hard errror ?
      }
   }

   DbgLog((LOG_STREAM, 4, "Receive() on input stream %lu", ulInputIndex));

    CAutoLock lck(&m_csStreaming);

    // Is the stream ready to accept input ?
    DWORD dwStatus;
    DWORD c;
    hr = TranslateDMOError(m_pMediaObject->GetInputStatus(ulInputIndex, &dwStatus));
    LogHResult(hr, LOG_STREAM, "NewSample", "IMediaObject::GetInputStatus");
    if (FAILED(hr)) {
       return hr;
    }
    if (dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA) {

       // If the input stream became ready for data at some point and we
       // already had data waitingin q queue, we should have delivered that
       // data right then (see code below).  The assumption is that an input
       // stream can only become ready for input due to a ProcessInput() or
       // ProcessOutput() call.
       ASSERT(InputQueueEmpty(ulInputIndex));

       // Yes - deliver the sample
       hr = DeliverInputSample(ulInputIndex, pSample);
       LogHResult(hr, LOG_STREAM, "NewSample", "DeliverInputSample");
       if (FAILED(hr)) {
          return hr;
       }

       if (hr == S_FALSE) // S_FALSE means no new output is available, thus
          return NOERROR; // no need to do the SuckOutOutput loop below.

       //  Suck the output
       DiscardType bDiscard = KeepOutput;

       //  We discard the output for output stream 0 for preroll data for
       //  video decoders
       if (0 != (m_pInputPins[ulInputIndex]->SampleProps()->dwSampleFlags & AM_SAMPLE_PREROLL) &&
           m_guidCat == DMOCATEGORY_VIDEO_DECODER) {
           bDiscard = DiscardOutput; // Discard it ourselves
           //  Can't discard non-discardable streams
           DWORD dwFlags;
           if (SUCCEEDED(TranslateDMOError(m_pMediaObject->GetOutputStreamInfo(0, &dwFlags)))) {
               if (dwFlags & (DMO_OUTPUT_STREAMF_OPTIONAL |
                              DMO_OUTPUT_STREAMF_DISCARDABLE)) {
                   bDiscard = NullBuffer; // Pass a NULL buffer to the decoder
               }
           }
       }

#ifdef DEBUG
        if (bDiscard) {
            DbgLog((LOG_TRACE, 2, TEXT("Discarding")));
        }
#endif

       //
       // Now Repeatedly call ProcessOutput() until no output is incomplete.
       // Even after we've sucked out all output produced from the current
       // input, we may still have additional data waiting in some other
       // stream's input queue.  In that case we deliver that data and repeat
       // the process of sucking out output.
       //
       bool bNewInput;
       do { // while new input
          hr = SuckOutOutput(bDiscard);
          LogHResult(hr, LOG_STREAM, "NewSample", "SuckOutOutput");
          if (FAILED(hr))
             return hr;
          bNewInput = false; // we just called ProcessOutput

          // Check if we can now deliver something waiting in an input queue
          for (c = 0; c < m_cInputPins; c++) {
             // Data waiting on this stream ?
             if (!InputQueueEmpty(c)) {
                DbgLog((LOG_STREAM,4,"Input stream %lu has data waiting in the input queue", c));
                // Yes there is data, but is the object ready for it ?
                hr = TranslateDMOError(m_pMediaObject->GetInputStatus(c, &dwStatus));
                LogHResult(hr, LOG_STREAM | LOG_STATE, "NewSample", "GetInputStatus2");
                if (FAILED(hr)) {
                   return hr;
                }
                if (dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA) {
                   DbgLog((LOG_STREAM,4,"inputstream %lu is accepting", c));
                   // Object is now ready - deliver !
                   hr = DeliverInputSample(c, DequeueInputSample(c));
                   LogHResult(hr, LOG_STREAM, "NewSample", "DeliverInputSample2");
                   if (FAILED(hr)) {
                      return hr;
                   }
                   bNewInput = true;
                } // if stream ready
                else {
                   DbgLog((LOG_STREAM,4,"data in the queue but the DMO is not accepting on input stream %lu", c));
                }
             } // if data in queue
          } // for all input streams
       } while (bNewInput);

       // Two things are true when we are here: (1) no output is incomplete,
       // and (2) we just processed all input queues as far as possible w/o
       // additional input.  That makes this a good place to check EOS.
       PropagateAnyEOS();

       return NOERROR;
    } // if current input ready for data
    else {
       DbgLog((LOG_STREAM | LOG_STATE, 2, "Input stream %u is not accepting - the sample will be put in the queue", ulInputIndex));
       return EnqueueInputSample(ulInputIndex, pSample);
    }
}


bool CMediaWrapperFilter::InputMapsToOutput(
    ULONG ulInputIndex,
    ULONG ulOutputIndex
)
{
    //  BUGBUG fix!
    return true;
}

HRESULT CMediaWrapperFilter::EndOfStream(ULONG ulInputIndex)
{
    HRESULT hr;

    LogPublicEntry(LOG_STATE, "EndOfStream");
    //
    // Stream specific part
    //
    { // stream lock scope
       CAutoLock l(&(m_pInputPins[ulInputIndex]->m_csStream));

       // Are we stopped or something?
       HRESULT hr = m_pInputPins[ulInputIndex]->CBaseInputPin::CheckStreaming();
       if (S_OK != hr) {
           return hr;
       }

       // Ignore any EOS calls on the same stream after the first one
       if (m_pInputPins[ulInputIndex]->m_fEOS) {
          DbgLog((LOG_STATE,2,"Ignoring redundant EndOfStream() on stream %lu", ulInputIndex));
          return NOERROR; // we've already see one of those, thank you
       }
       m_pInputPins[ulInputIndex]->m_fEOS = true;
    }
    DbgLog((LOG_STATE,3,"EndOfStream() on input stream %lu", ulInputIndex));

    // BUGBUG: the rest of what this function does should happen only
    // *after* delivering any samples still stuck in the input queues.

    // Put code here to deliver the contents of each input stream's queue !
    // Remember to call SuckOutOutput() after delivering every input sample.

    // Note that nothing can ever end up in the queue if there is only one
    // input stream.


    //
    // Object global part
    //
    CAutoLock l2(&m_csStreaming);

    // Process the EOS
    hr = TranslateDMOError(m_pMediaObject->Discontinuity(ulInputIndex));
    LogHResult(hr, LOG_STATE,"EndOfStream", "IMediaObject::Discontinuity");
    if (FAILED(hr)) {
       return hr;
    }

    hr = SuckOutOutput();
    LogHResult(hr, LOG_STATE,"EndOfStream", "SuckOutOutput");
    if (FAILED(hr)) {
       return hr;
    }

    // Flush the object if this was the last input EOS
    bool bSomeInputStillIncomplete = false;
    for (DWORD c = 0; c < m_cInputPins; c++) {
       if (!m_pInputPins[c]->m_fEOS) {
          bSomeInputStillIncomplete = true;
          break;
       }
    }
    if (!bSomeInputStillIncomplete) {
       hr = TranslateDMOError(m_pMediaObject->Flush());
       LogHResult(hr,LOG_STREAM,"EndOfStream","IMediaObject::Flush");
    }
    else {
       DbgLog((LOG_STATE,4,"EndOfStream(): some input still incomplete - not flushing yet"));
    }

    PropagateAnyEOS();

    return NOERROR;
}

HRESULT CMediaWrapperFilter::BeginFlush(ULONG ulInputIndex)
{
    //
    // BUGBUG: synchronize with input queues !  (multiple input stream case only)
    //

    LogPublicEntry(LOG_STATE, "BeginFlush");
    ASSERT(ulInputIndex < m_cInputPins);
    DbgLog((LOG_STATE,3,"BeginFlush() on input stream %lu", ulInputIndex));
    HRESULT hr = m_pInputPins[ulInputIndex]->CBaseInputPin::BeginFlush();
    LogHResult(hr, LOG_STATE, "BeginFlush", "CBaseInputPin::BeginFlush");

    //  Need to also flush the object as not doing so could cause
    //  upstream filters to block
    //  Note also that bacause of the loose synchronization this also
    //  needs to be done after ProcessInput if we're flushing (see
    //  coments in side DeliverInputSample).
    m_pMediaObject->Flush();

    m_fErrorSignaled = FALSE;

    //  Propagate it to all output pins
    for (ULONG ulOutputIndex = 0; ulOutputIndex < m_cOutputPins; ulOutputIndex++) {
        if (InputMapsToOutput(ulInputIndex, ulOutputIndex)) {
            //  Decommit it's allocator
            hr = m_pOutputPins[ulOutputIndex]->DeliverBeginFlush();
            LogHResult(hr, LOG_STATE, "BeginFlush", "DeliverBeginFlush");
        }
    }
    return S_OK;
}

HRESULT CMediaWrapperFilter::EndFlush(ULONG ulInputIndex)
{
    LogPublicEntry(LOG_STATE, "EndFlush");
    ASSERT(ulInputIndex < m_cInputPins);
    DbgLog((LOG_STATE,3,"EndFlush() on input stream %lu", ulInputIndex));
    HRESULT hr;
    {
       CAutoLock l(&m_csStreaming);
       m_pMediaObject->Flush();

       //  Propagate it to all output pins
       for (ULONG ulOutputIndex = 0; ulOutputIndex < m_cOutputPins; ulOutputIndex++) {
           if (InputMapsToOutput(ulInputIndex, ulOutputIndex)) {
               //  Clear end of stream condition on this output pin
               //  and propagate flush
               m_pOutputPins[ulOutputIndex]->m_fEOS = false;
               hr = m_pOutputPins[ulOutputIndex]->DeliverEndFlush();
               LogHResult(hr, LOG_STATE, "EndFlush", "DeliverEndFlush");
           }
       }
    }

    // BUGBUG - lock the stream !
    m_pInputPins[ulInputIndex]->m_fEOS = false;
    hr = m_pInputPins[ulInputIndex]->CBaseInputPin::EndFlush();
    LogHResult(hr, LOG_STATE, "EndFlush", "CBaseInputPin::EndFlush");

    return S_OK;
}

HRESULT CMediaWrapperFilter::NonDelegatingQueryInterface(REFGUID riid, void **ppv) {
   LogPublicEntry(LOG_INIT, "NonDelegatingQueryInterface");
   if (riid == IID_IDMOWrapperFilter) {
      return GetInterface((IDMOWrapperFilter*)this, ppv);
   }
   if (riid == IID_IPersistStream) {
      return GetInterface((IPersistStream*)this, ppv);
   }

   if (SUCCEEDED(CBaseFilter::NonDelegatingQueryInterface(riid, ppv))) {
      return NOERROR;
   }

   if (m_pMediaObject) { // bugbug: conditional QI behavior is bad COM
      if (SUCCEEDED(m_pDMOUnknown->QueryInterface(riid, ppv)))
         return NOERROR;
   }

   return E_NOINTERFACE;
}

// IPersistStream
HRESULT CMediaWrapperFilter::IsDirty() {
   return S_OK; // bugbug
}
HRESULT CMediaWrapperFilter::Load(IStream *pStm) {

   CLSID clsidDMOFromStream;
   HRESULT hr = pStm->Read(&clsidDMOFromStream, sizeof(CLSID), NULL);
   if (FAILED(hr)) {
      return hr;
   }
   CLSID guidCatFromStream;
   hr = pStm->Read(&guidCatFromStream, sizeof(CLSID), NULL);
   if (FAILED(hr)) {
      return hr;
   }

   if( !m_pDMOUnknown )
   {
       // only necessary if object hasn't been created yet!
       hr = Init(clsidDMOFromStream, guidCatFromStream);
   }
   else if( ( m_clsidDMO != clsidDMOFromStream ) || 
            ( m_guidCat != guidCatFromStream ) )
   {
       ASSERT( ( m_clsidDMO == clsidDMOFromStream ) && ( m_guidCat == guidCatFromStream ) );
       DbgLog((LOG_TRACE,1,"ERROR: Invalid IStream ptr passed to Load method!"));
       hr = E_UNEXPECTED;
   }   
   
   if (SUCCEEDED(hr)) {
       //  Let the DMO return its data
       CComQIPtr<IPersistStream> pPersist(m_pDMOUnknown);
       if (pPersist != NULL && pPersist != static_cast<IPersistStream *>(this)) {
           hr = pPersist->Load(pStm);
           if (E_NOTIMPL == hr) {
               hr = S_OK;
           }
       }
   }
   return hr;
}
HRESULT CMediaWrapperFilter::Save(IStream *pStm, BOOL fClearDirty) {
   HRESULT hr = pStm->Write(&m_clsidDMO, sizeof(CLSID), NULL);
   if (SUCCEEDED(hr)) {
       HRESULT hr = pStm->Write(&m_guidCat, sizeof(CLSID), NULL);
   }
   //  Let the DMO return its data
   CComQIPtr<IPersistStream> pPersist(m_pDMOUnknown);
   if (pPersist != NULL && pPersist != static_cast<IPersistStream *>(this)) {
       hr = pPersist->Save(pStm, fClearDirty);
       if (E_NOTIMPL == hr) {
           hr = S_OK;
       }
   }
   return hr;
}
HRESULT CMediaWrapperFilter::GetSizeMax(ULARGE_INTEGER *pcbSize) {
   return sizeof(CLSID);
}
HRESULT CMediaWrapperFilter::GetClassID(CLSID *clsid) {
   CheckPointer(clsid, E_POINTER);
   *clsid = CLSID_DMOWrapperFilter;
   return S_OK;
}


//
// CreateInstance
//
// Provide the way for COM to create a CNullNull object
CUnknown * WINAPI CMediaWrapperFilter::CreateInstance(
    LPUNKNOWN punk,
    HRESULT *phr)
{
    return new CMediaWrapperFilter(punk, phr);
}


HRESULT TranslateDMOError(HRESULT hr)
{
    switch (hr) {
    case DMO_E_INVALIDSTREAMINDEX:
        hr = E_UNEXPECTED;
        break;

    case DMO_E_INVALIDTYPE:
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        break;

    case DMO_E_TYPE_NOT_SET:
        hr = E_UNEXPECTED;
        break;

    case DMO_E_NOTACCEPTING:
        hr = VFW_E_WRONG_STATE;
        break;

    case DMO_E_TYPE_NOT_ACCEPTED:
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        break;

    case DMO_E_NO_MORE_ITEMS:
        hr = E_INVALIDARG;
        break;

    }
    return hr;
}

#ifdef FILTER_DLL
//  Stuff to make this a dshow dll
// Needed for the CreateInstance mechanism
CFactoryTemplate g_Templates[]= {
    { L"DirectShow Media Object Wrapper Filter"
        , &CLSID_DMOWrapperFilter
        , CMediaWrapperFilter::CreateInstance
        , NULL
        , NULL
    },
};

int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif // FILTER_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\inpin.h ===
#ifndef __INPIN_H__
#define __INPIN_H__

class CWrapperInputPin : public CBaseInputPin
{
   friend class CMediaWrapperFilter; // stuff at the bottom is owned by the filter

public:
    CWrapperInputPin(CMediaWrapperFilter *pFilter,
                          ULONG Id,
                          HRESULT *phr);
    ~CWrapperInputPin();
    STDMETHODIMP EndOfStream();
    STDMETHODIMP Receive(IMediaSample *pSample);

    //  Override GetAllocator and Notify Allocator to allow
    //  for media object streams that hold on to buffer
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);


    //  Override to unset media type
    HRESULT BreakConnect();

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    //  Synclock for stop
    void SyncLock();

    BOOL HoldsOnToBuffers();

protected:
    HRESULT MP3AndWMABufferSizeWorkAround(IMemAllocator* pProposedAllocator);
    HRESULT SetBufferSize(IMemAllocator* pAllocator, DWORD dwMinBufferSize);

    CMediaWrapperFilter *Filter() const
    {
        return static_cast<CMediaWrapperFilter *>(m_pFilter);
    }

    ULONG      m_Id;
    _PinName_  *m_pNameObject;
    CCritSec m_csStream;

    // This stuff is owned by the filter and is declared here for allocation convenience
    bool m_fEOS; // have received EOS during this streaming session
};

//  Special allocator class.  This class allocators extra internal
//  buffers to satisfy the lookahead scheme that are not reported
//  in GetProperties.  Thus the upstream pin's requirements are satisfied
//  in addition to our own.
class CSpecialAllocator : public CMemAllocator
{
    DWORD m_dwLookahead;
public:
    CSpecialAllocator(DWORD dwLookahead, HRESULT *phr) :
        CMemAllocator(NAME("CSpecialAllocator"), NULL, phr),
        m_dwLookahead(dwLookahead)
    {
    }

    //  Helper
    LONG BuffersRequired(LONG cbBuffer) const
    {
        if (cbBuffer <= 0 || m_dwLookahead == 0) {
            return 1;
        } else {
            return (m_dwLookahead + 2 * (cbBuffer - 1)) / cbBuffer;
        }
    }

    //  Override Set/GetProperties to create extra buffers not
    //  reported
    STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES *pProps)
    {
        CAutoLock lck(this);
        HRESULT hr = CMemAllocator::GetProperties(pProps);
        LONG cBuffersRequired = BuffersRequired(m_lSize);
        if (SUCCEEDED(hr)) {
            ASSERT(pProps->cBuffers >= cBuffersRequired);
            pProps->cBuffers -= cBuffersRequired - 1;
        }
        return hr;
    }
    STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES *pRequest,
                               ALLOCATOR_PROPERTIES *pActual)
    {
        CAutoLock lck(this);

        //  Compute the buffers required for this buffer size
        LONG cBuffersRequired = BuffersRequired(pRequest->cbBuffer);
        ALLOCATOR_PROPERTIES Request = *pRequest;
        Request.cBuffers += cBuffersRequired - 1;
        HRESULT hr = CMemAllocator::SetProperties(&Request, pActual);
        if (SUCCEEDED(hr)) {
            ASSERT(pActual->cBuffers >= pRequest->cBuffers);
            pActual->cBuffers -= cBuffersRequired - 1;
        }
        return hr;
    }
};

#endif //__INPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\outpin.cpp ===
#include <wchar.h>
#include <streams.h>
#include <atlbase.h>
#include <wmsecure.h>
#include <dmoreg.h>
#include <mediaerr.h>
#include "mediaobj.h"
#include "dmodshow.h"
#include "filter.h"
#include "inpin.h"
#include "outpin.h"
#include "wmcodecstrs.h" // from wm encoder group, not public currently

CWrapperOutputPin::CWrapperOutputPin(
    CMediaWrapperFilter *pFilter,
    ULONG Id,
    BOOL bOptional,
    HRESULT *phr) :
    CBaseOutputPin(NAME("CWrapperOutputPin"),
                   pFilter,
                   pFilter->FilterLock(),
                   phr,
                   _PinName_(bOptional ? L"~out" : L"out", Id).Name()
                  ),
    m_Id(Id),
    m_fNoPosPassThru(FALSE),
    m_pPosPassThru(NULL),
    m_pMediaSample(NULL),
    // compression setting default values, move to struct eventually
    m_lQuality( -1 ),
    m_lKeyFrameRate( -1 ),
    m_bUseIAMStreamConfigOnDMO( false ),
    m_bUseIAMVideoCompressionOnDMO( false ),
    m_pmtFromSetFormat( NULL )
{
}

CWrapperOutputPin::~CWrapperOutputPin() {
    delete m_pPosPassThru;

    if( m_pmtFromSetFormat )
    {
        // clean up any media type we might have cached from a SetFormat call
        DeleteMediaType( m_pmtFromSetFormat );
    }
}

HRESULT CWrapperOutputPin::NonDelegatingQueryInterface(REFGUID riid, void **ppv) {
    if (SUCCEEDED(CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
        return NOERROR;

    if ((riid == IID_IMediaPosition) || (riid == IID_IMediaSeeking)) {
        CAutoLock l(&m_csPassThru);

        // The first time we get here, we attempt to create a CPosPassThru
        // object.  If we succeed, we use the object in all subsequent QI
        // calls.  If we fail, we set m_fNoPassThru to TRUE so that we never
        // try again.  Trying again and succeeding would violate COM rules.
        if (m_fNoPosPassThru)
            return E_NOINTERFACE;

        // Create a CPosPassThru if we don't have one already
        if (!m_pPosPassThru) {
            CWrapperInputPin* pInPin = Filter()->GetInputPinForPassThru();
            if (pInPin) {
                HRESULT hr = S_OK;
                m_pPosPassThru = new CPosPassThru(TEXT("DMO wrapper PosPassThru"),
                                                (IPin*)this,
                                                &hr,
                                                pInPin);
                if (m_pPosPassThru && (FAILED(hr))) {
                    delete m_pPosPassThru;
                    m_pPosPassThru = NULL;
                }
            }
        }

        if (m_pPosPassThru) {
            return m_pPosPassThru->NonDelegatingQueryInterface(riid, ppv);
        }
        else {
            m_fNoPosPassThru = TRUE;
            return E_NOINTERFACE;
        }
    }
    else if (riid == IID_IAMStreamConfig )
    {
        // we support this interface for audio and video encoders
        if (IsAudioEncoder() || IsVideoEncoder() )
        {   
            if( 0 == m_Id && !m_bUseIAMStreamConfigOnDMO )
            {         
                // first check whether the dmo supports this natively and cache the interface pointer if so
                // BUGBUG needs to be per output stream!!
                // for now fail only ask if 1st output stream
                CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
                if( pStreamConfigOnDMO )
                {
                    // so it is supported natively, but we must release it since it winds up addref'ing the filter
                    m_bUseIAMStreamConfigOnDMO = true;
                    DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin::NonDelegatingQI - DMO supports IAMStreamConfig natively")));
                }
            }
            // either way it'll go through us
            return GetInterface( static_cast<IAMStreamConfig *> (this), ppv );
        }            
    }
    else if (riid == IID_IAMVideoCompression )
    {
        // we support this interface for video encoders
        if ( IsVideoEncoder() )
        {      
            if( 0 == m_Id && !m_bUseIAMVideoCompressionOnDMO )
            {         
                // first check whether the dmo supports this natively and cache the interface pointer if so
                // BUGBUG needs to be per output stream!!
                // for now fail only ask if 1st output stream
                CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
                if( pVideoCompressionOnDMO )
                {
                    // so it is supported natively, but we must release it since it winds up addref'ing the filter
                    m_bUseIAMVideoCompressionOnDMO = true;
                    DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin::NonDelegatingQI - DMO supports IAMVideoCompression natively")));
                }
            }
            // either way it'll go through us
            return GetInterface( static_cast<IAMVideoCompression *> (this), ppv);
        }            
    }
             
    return E_NOINTERFACE;
}

HRESULT CWrapperOutputPin::CheckMediaType(const CMediaType *pmt)
{
    return Filter()->OutputCheckMediaType(m_Id, pmt);
}
HRESULT CWrapperOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock l(&m_csStream);
    HRESULT hr = Filter()->OutputSetMediaType(m_Id, pmt);
    if (SUCCEEDED(hr)) {
        hr = CBaseOutputPin::SetMediaType(pmt);
        if (SUCCEEDED(hr)) {
            m_fVideo = pmt->majortype == MEDIATYPE_Video ? true : false;
        }
    }
    return hr;
}

HRESULT CWrapperOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if( m_pmtFromSetFormat )
    {
        // our SetFormat has been called so only offer that type from now on
        if( iPosition != 0 )
            return E_INVALIDARG;

        *pMediaType = *m_pmtFromSetFormat;
        return S_OK;
    }
    else
    {
        return Filter()->OutputGetMediaType(m_Id, (ULONG)iPosition, pMediaType);
    }
}

//
// override primarily for the case where we're a wm dmo video encoder connecting directly 
// to the ASF writer, in a desparate attempt to get an output type which a wm video encoder
// will accept in the default connection case
//
STDMETHODIMP CWrapperOutputPin::Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin::Connect")));
    CAutoLock lck(&(Filter()->m_csFilter));
    //
    // if connecting to the asf writer try getting a default type from the writer
    //
    // note that, although we'd like to do this only if SetFormat hasn't been called,
    // we have no guarantee that the writer format hasn't changed, so we need to 
    // continually call SetFormat with the type we get from the downstream pin's GetFormat
    bool bSetFormatOnConnect = false;

    if( !pmt && !m_pmtFromSetFormat && IsVideoEncoder() )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfig( pReceivePin );
        if( pStreamConfig )
        {
            AM_MEDIA_TYPE *pmt2;
            HRESULT hrInt = pStreamConfig->GetFormat( &pmt2 );
            if( SUCCEEDED( hrInt ) )
            {
                // now we'll only offer this type!
                hrInt = SetFormat( pmt2 );
                if( SUCCEEDED( hrInt ) )
                {
                    bSetFormatOnConnect = true; 
                }
            }
        }
    }
    // call the base class connect
    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt);
    if( bSetFormatOnConnect )
    {
        // whether we failed or not, unset the format if we set one here in connect
        if( m_pmtFromSetFormat )
        {
            // clean up any media type we might have cached from a SetFormat call
            DeleteMediaType( m_pmtFromSetFormat );
            m_pmtFromSetFormat = NULL;
        }
    }
    return hr; 
}

//  Remove any media type when breaking a connection
HRESULT CWrapperOutputPin::BreakConnect()
{
    HRESULT hr = CBaseOutputPin::BreakConnect();
    Filter()->m_pMediaObject->SetOutputType(m_Id, &CMediaType(), DMO_SET_TYPEF_CLEAR);
    return hr;
}

HRESULT CWrapperOutputPin::DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES * ppropInputRequest
)
{
    return Filter()->OutputDecideBufferSize(m_Id, pAlloc, ppropInputRequest);
}

HRESULT CWrapperOutputPin::Notify(IBaseFilter * pSender, Quality q)
{
   LogPublicEntry(LOG_STREAM,"Quality Notify");
   HRESULT hr;

   // If quality sink set, forward the quality request to it
   if (m_pQSink) {
      hr = m_pQSink->Notify(Filter(), q);
      LogHResult(hr, LOG_STREAM, "Quality Notify", "m_pQSink->Notify");
      return hr;
   }

   // This will try the DMO, then the upstream pin
   return Filter()->QualityNotify(m_Id, q);
}

//
// IAMStreamConfig
//
HRESULT CWrapperOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMStreamConfig::SetFormat")));
    CAutoLock lck(&(Filter()->m_csFilter));
    HRESULT hr = S_OK;
    if (NULL == pmt)
    {
        // I'd rather use this to "unset" the type, but that's not how other encoders work
        // previously they returned E_POINTER for this
        // can we break tradition?
        DeleteMediaType( m_pmtFromSetFormat );
        m_pmtFromSetFormat = NULL;
        return S_OK;
    }

    if (Filter()->m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    // ensure inputs connected to this output are connected
    // since our possible output formats depend on the input format
    if( !IsInputConnected() )
    {
        return VFW_E_NOT_CONNECTED;
    }

    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->SetFormat( pmt );
    }
    
#ifdef DEBUG
    if(pmt->pbFormat && pmt->cbFormat > 0 )
    {    
        if( IsVideoEncoder() )
        {
            DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin - IAMStreamConfig::SetFormat %x %dbit %dx%d"),
                HEADER(pmt->pbFormat)->biCompression,
                HEADER(pmt->pbFormat)->biBitCount,
                HEADER(pmt->pbFormat)->biWidth,
                HEADER(pmt->pbFormat)->biHeight));
        }
        else
        {
            DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin - IAMStreamConfig::SetFormat to tag:%d %dbit %dchannel %dHz"),
                ((LPWAVEFORMATEX)(pmt->pbFormat))->wFormatTag,
                ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
                ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
                ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));
        }
    }        
#endif

    // If this is the same format as we already are using, don't bother
    CMediaType cmt;
    hr = GetMediaType(0,&cmt);
    if (S_OK != hr)
        return hr;
    
    if (cmt == *pmt) 
    {
        return NOERROR;
    }

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) 
    {
        DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat rejected")));
        return hr;
    }

    // if we're connected, ask downstream
    if (IsConnected()) 
    {
        hr = GetConnected()->QueryAccept(pmt);
        if (hr != NOERROR)
        {
            return VFW_E_INVALIDMEDIATYPE;
        }
    }

    // this is now the preferred type (type 0)
    hr = SetMediaType((CMediaType *)pmt);
    if( S_OK == hr )
    {
        // only offer this type from now on!
        if( m_pmtFromSetFormat )
            DeleteMediaType( m_pmtFromSetFormat );

        m_pmtFromSetFormat = CreateMediaType( ( AM_MEDIA_TYPE * ) pmt );
        if( !m_pmtFromSetFormat )
            return E_OUTOFMEMORY;
    }
    ASSERT(hr == S_OK);

    // Changing the format means reconnecting if necessary
    if (IsConnected())
        Filter()->m_pGraph->Reconnect(this);

    return NOERROR;
}


HRESULT CWrapperOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("CWrapperOutputPin - IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
        return E_POINTER;

    CAutoLock lck(&(Filter()->m_csFilter));
    
    // ensure inputs connected to this output are connected
    // since our possible output formats depend on the input format
    if( !IsInputConnected() )
    {
        return VFW_E_NOT_CONNECTED;
    }
    
    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->GetFormat( ppmt );
    }

    // type 0 is always the preferred type 
    // actually this isn't the case for at least wm encoders, but we'll fake it
    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) 
    {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
        return hr;
    }
    return NOERROR;
}


HRESULT CWrapperOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMStreamConfig::GetNumberOfCapabilities")));
    if (piCount == NULL || piSize == NULL)
        return E_POINTER;

    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->GetNumberOfCapabilities( piCount, piSize );
    }

    // find out how many output types the dmo enumerates
    // note that it's ok to show possible output types before connecting input
    int iType = 0;
    HRESULT hr = S_OK;
    while( S_OK == hr )
    {
        // just enumerating, no need to get mt
        hr = GetMediaType( iType, NULL ); 
        if( S_OK == hr )
            iType++;
    }
    *piCount = iType;

    if( IsVideoEncoder() )
    {
        *piSize = sizeof(VIDEO_STREAM_CONFIG_CAPS);
    }
    else
    {
        ASSERT( IsAudioEncoder() );
        *piSize = sizeof(AUDIO_STREAM_CONFIG_CAPS);
    }
    return NOERROR;
}

HRESULT CWrapperOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMStreamConfig::GetStreamCaps")));

    if (i < 0)
        return E_INVALIDARG;

    if (NULL == pSCC || NULL == ppmt)
        return E_POINTER;

    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->GetStreamCaps( i, ppmt, pSCC );
    }

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (NULL == *ppmt)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(i, (CMediaType *)*ppmt);
    if (hr != NOERROR) 
    {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;

        if( DMO_E_NO_MORE_ITEMS == hr || E_INVALIDARG == hr )
        {
            // is this spec'd to return S_FALSE if too high a type? Seems so from other encoders.
            return S_FALSE;
        }
        else
        {
            return hr;
        }
    }

    if( IsVideoEncoder() )
    {
        VIDEO_STREAM_CONFIG_CAPS *pVSCC = (VIDEO_STREAM_CONFIG_CAPS *)pSCC;

        ZeroMemory(pVSCC, sizeof(VIDEO_STREAM_CONFIG_CAPS));
        pVSCC->guid = MEDIATYPE_Video;

        if( (*ppmt)->pbFormat && (*ppmt)->cbFormat > 0 )
        {        
            BITMAPINFOHEADER *pbmih = HEADER((*ppmt)->pbFormat);
            pVSCC->InputSize.cx = pbmih->biWidth;
            pVSCC->InputSize.cy = pbmih->biHeight;
            pVSCC->MinCroppingSize.cx = pbmih->biWidth;
            pVSCC->MinCroppingSize.cy = pbmih->biHeight;
            pVSCC->MaxCroppingSize.cx = pbmih->biWidth;
            pVSCC->MaxCroppingSize.cy = pbmih->biHeight;
        }            
    }
    else
    {
        AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

        ZeroMemory(pASCC, sizeof(AUDIO_STREAM_CONFIG_CAPS));
        pASCC->guid = MEDIATYPE_Audio;

        if( (*ppmt)->pbFormat && (*ppmt)->cbFormat > 0 )
        {        
            LPWAVEFORMATEX pwfx = (LPWAVEFORMATEX)(*ppmt)->pbFormat;
            // rather let's just offer exactly what the dmo offers (if filled in?)        
        
            pASCC->MinimumChannels = pwfx->nChannels;
            pASCC->MaximumChannels = pwfx->nChannels;
            pASCC->ChannelsGranularity = 1;
            pASCC->MinimumBitsPerSample = pwfx->wBitsPerSample;
            pASCC->MaximumBitsPerSample = pwfx->wBitsPerSample;
            pASCC->BitsPerSampleGranularity = 8;
            pASCC->MinimumSampleFrequency = pwfx->nSamplesPerSec;
            pASCC->MaximumSampleFrequency = pwfx->nSamplesPerSec;
            pASCC->SampleFrequencyGranularity = 1; //?
        }
    }
    return hr;    
}


//
// IAMVideoCompression
//

#define DMO_COMPRESSION_QUALITY_MAX 10000  // is this set in stone? Check this.

// make key frames this often
//
HRESULT CWrapperOutputPin::put_KeyFrameRate(long KeyFrameRate)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::put_KeyFrameRate")));
    CAutoLock lck(&(Filter()->m_csFilter));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->put_KeyFrameRate( KeyFrameRate );
    }
    
    HRESULT hr = S_OK;
    if( KeyFrameRate < 0 )
    {
        // used to set default key frame rate, which we don't know
        // do nothing
    }
    else 
    {
        // check whether units match!
        hr = SetCompressionParamUsingIPropBag( g_wszWMVCKeyframeDistance, KeyFrameRate );
        if( SUCCEEDED( hr ) )
        {
            // update our internal copy 
            m_lKeyFrameRate = KeyFrameRate;
        }
    }        
    return hr;
}

// make key frames this often
//
HRESULT CWrapperOutputPin::get_KeyFrameRate(long FAR* pKeyFrameRate)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::get_KeyFrameRate")));
    if( NULL == pKeyFrameRate )
        return E_POINTER;
        
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->get_KeyFrameRate( pKeyFrameRate );
    }
    
    // wm codecs don't support a get, so just return the current internal value
    *pKeyFrameRate = m_lKeyFrameRate;

    return NOERROR;
}

// compress with this quality
//
HRESULT CWrapperOutputPin::put_Quality(double Quality)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::put_Quality")));

    CAutoLock lck(&(Filter()->m_csFilter));
    
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->put_Quality( Quality );
    }
    
    HRESULT hr = S_OK;
    if (Quality < 0)
    {
        // used to set default quality, except we don't know how to find out what this is!
        // so do nothing, for now
    }        
    else if (Quality >= 0. && Quality <= 1.)
    {    
        // check whether units match!
        long lQuality = (long)( Quality * DMO_COMPRESSION_QUALITY_MAX );
        hr = SetCompressionParamUsingIPropBag( g_wszWMVCCrisp, lQuality );
        if( SUCCEEDED( hr ) )
        {
            // update our internal copy 
            m_lQuality = lQuality;
        }
    }        
    else
    {    
        hr = E_INVALIDARG;
    }        
    return hr;
}

// compress with this quality
//
HRESULT CWrapperOutputPin::get_Quality(double FAR* pQuality)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::get_Quality")));
    if( NULL == pQuality )
        return E_POINTER;
        
    CAutoLock lck(&(Filter()->m_csFilter));
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->get_Quality( pQuality );
    }
        
    // scale the dmo encoder's bounds to 0-1, hmm...?
    if( m_lQuality < 0 )
    {
        // assume default
        *pQuality = -1.;
    }
    else
    {
        // wm codecs don't support a get, so just return the current internal value
        *pQuality = m_lQuality / (double)DMO_COMPRESSION_QUALITY_MAX; // ?
    }
    return NOERROR;
}


// every frame must fit in the data rate...
//
HRESULT CWrapperOutputPin::put_WindowSize(DWORDLONG WindowSize)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::put_WindowSize")));

    CAutoLock lck(&(Filter()->m_csFilter));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->put_WindowSize( WindowSize );
    }
    
    return E_NOTIMPL;
}


// every frame must fit in the data rate... we don't do the WindowSize thing
//
HRESULT CWrapperOutputPin::get_WindowSize(DWORDLONG FAR* pWindowSize)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::get_WindowSize")));

    if (pWindowSize == NULL)
        return E_POINTER;

    CAutoLock lck(&(Filter()->m_csFilter));
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->get_WindowSize( pWindowSize );
    }
    
    *pWindowSize = 1;   // we don't do windows
    return NOERROR;
}


// make this frame a key frame, whenever it comes by
//
HRESULT CWrapperOutputPin::OverrideKeyFrame(long FrameNumber)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::OverrideKeyFrame")));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->OverrideKeyFrame( FrameNumber );
    }
    
    // not needed currently
    return E_NOTIMPL;
}

// make this frame this size, whenever it comes by
//
HRESULT CWrapperOutputPin::OverrideFrameSize(long FrameNumber, long Size)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::OverrideFrameSize")));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->OverrideFrameSize( FrameNumber, Size );
    }
    
    // not needed currently
    return E_NOTIMPL;
}


// Get some information about the codec
//
HRESULT CWrapperOutputPin::GetInfo
(   
    LPWSTR pstrVersion, 
    int *pcbVersion, 
    LPWSTR pstrDescription, 
    int *pcbDescription, 
    long FAR* pDefaultKeyFrameRate, 
    long FAR* pDefaultPFramesPerKey, 
    double FAR* pDefaultQuality, 
    long FAR* pCapabilities
)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::GetInfo")));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->GetInfo(
                                                pstrVersion, 
                                                pcbVersion, 
                                                pstrDescription, 
                                                pcbDescription, 
                                                pDefaultKeyFrameRate, 
                                                pDefaultPFramesPerKey, 
                                                pDefaultQuality, 
                                                pCapabilities );
    }
    
    // there's no way to query default settings for wm codecs currently?
    return E_NOTIMPL;
    
#if 0    
    CAutoLock lck(&(Filter()->m_csFilter));

    // for ICM we did this...
    if (pDefaultKeyFrameRate)
        *pDefaultKeyFrameRate = ICGetDefaultKeyFrameRate(hic);
    if (pDefaultPFramesPerKey)
        *pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
        // scale this 0-1
        *pDefaultQuality = ICGetDefaultQuality(hic) / (double)ICQUALITY_HIGH;
    if (pCapabilities) 
    {
        *pCapabilities = 0;
            if (dw > 0) 
        {
            *pCapabilities |= ((icinfo.dwFlags & VIDCF_QUALITY) ?
                CompressionCaps_CanQuality : 0);
            *pCapabilities |= ((icinfo.dwFlags & VIDCF_CRUNCH) ?
                CompressionCaps_CanCrunch : 0);
            *pCapabilities |= ((icinfo.dwFlags & VIDCF_TEMPORAL) ?
                CompressionCaps_CanKeyFrame : 0);
            // we don't do b frames
        }
    }

    // We have no version string, but we have a description
    if (pstrVersion)
        *pstrVersion = 0;
    if (pcbVersion)
        *pcbVersion = 0;
    if (dw > 0) 
    {
        if (pstrDescription && pcbDescription)
            lstrcpynW(pstrDescription, (LPCWSTR)&icinfo.szDescription,
            min(*pcbDescription / 2,
            lstrlenW((LPCWSTR)&icinfo.szDescription) + 1));
        if (pcbDescription)
            // string length in bytes, incl. NULL
            *pcbDescription = lstrlenW((LPCWSTR)&icinfo.szDescription) * 2 + 2;
    } 
    else 
    {
        if (pstrDescription) 
        {
            *pstrDescription = 0;
            if (pcbDescription)
                *pcbDescription = 0;
        }
    }

    return NOERROR;
#endif    
}

HRESULT CWrapperOutputPin::SetCompressionParamUsingIPropBag
( 
    const WCHAR * wszParam,
    const LONG    lValue
)
{
    HRESULT hr = E_NOTIMPL;
    
    //
    // wm codecs support setting of compression properties through IPropertyBag, try this first
    //
    CComQIPtr< IPropertyBag, &IID_IPropertyBag > pPropBag( Filter()->m_pMediaObject );
    if( !pPropBag )
    {
        DbgLog((LOG_TRACE,2,TEXT("CWrapperOutputPin::SetCompressionParamUsingIPropBag - DMO doesn't support IPropertyBag for compression setting") ) );
    }
    else
    {
        // attempt to set the property
        VARIANT var;
        
        V_VT( &var ) = VT_I4;
        V_I4( &var ) = lValue; 
    
        hr = pPropBag->Write( wszParam, &var );
#ifdef DEBUG
        if( FAILED( hr ) )
        {
            DbgLog((LOG_TRACE,
                3,
                TEXT("CWrapperOutputPin::SetCompressionParamUsingIPropBag - DMO supports IPropertyBag but not %ls setting"),
                wszParam ) );
        }
#endif        
    }
    return hr;
}

bool CWrapperOutputPin::IsAudioEncoder()
{
    if(Filter()->m_guidCat == DMOCATEGORY_AUDIO_ENCODER)
        return true;
    else 
        return false;
}
bool CWrapperOutputPin::IsVideoEncoder()
{
    if(Filter()->m_guidCat == DMOCATEGORY_VIDEO_ENCODER)
        return true;
    else 
        return false;
}

bool CWrapperOutputPin::IsInputConnected()
{
    for (DWORD cIn = 0; cIn < Filter()->m_cInputPins; cIn++) 
    {
        if (Filter()->InputMapsToOutput(cIn, m_Id) &&
            !(Filter()->m_pInputPins[cIn]->IsConnected())) 
        { 
            // some input not connected
            return false;
        }
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\outpin.h ===
#ifndef __OUTPIN_H__
#define __OUTPIN_H__

#include "filter.h"

//   Almost nothing to override
class CWrapperOutputPin : public CBaseOutputPin, 
                          public IAMStreamConfig,
                          public IAMVideoCompression
{
    friend class CMediaWrapperFilter; // stuff at the bottom is owned by the filter

public:
    DECLARE_IUNKNOWN

    CWrapperOutputPin(CMediaWrapperFilter *pFilter,
                           ULONG Id,
                           BOOL bOptional,
                           HRESULT *phr);
    ~CWrapperOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFGUID riid, void **ppv);

    HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
    );

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    //  Override to unset media type
    HRESULT BreakConnect();

    // override to work around broken wm encoders which need a bitrate to connect, for
    // use when connecting directly to the ASF writer filter
    STDMETHODIMP Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
    
    
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // IAMStreamConfig methods
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC);

    // IAMVideoCompression methods 
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate);
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate);
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality);
    STDMETHODIMP get_Quality(double FAR* pQuality);
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize);
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize);
    STDMETHODIMP OverrideKeyFrame(long FrameNumber);
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size);
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);


protected:
    CMediaWrapperFilter *Filter() const
    {
        return static_cast<CMediaWrapperFilter *>(m_pFilter);
    }
    ULONG m_Id;
    CCritSec m_csStream;

    BOOL m_fNoPosPassThru;
    CPosPassThru* m_pPosPassThru;
    CCritSec m_csPassThru;

    // This stuff is owned by the filter and is declared here for allocation convenience
    IMediaSample*      m_pMediaSample;
    CStaticMediaBuffer m_MediaBuffer;
    bool m_fStreamNeedsBuffer;  // per-output-stream flag local to SuckOutOutput()
    bool m_fEOS;                // indicates we have already delivered an EOS on this stream
    bool m_fNeedsPreviousSample;
    bool m_fAllocatorHasOneBuffer;

    //  Only valid between GetDeliveryBuffer and Deliver for video
    bool m_fNeedToRelockSurface;

    //  Set when OutputSetType is called
    bool m_fVideo;

    // IAMStreamConfig helpers
    bool IsAudioEncoder();
    bool IsVideoEncoder();
    bool IsInputConnected();
    // used for dmo encoders that natively support these interfaces
    bool m_bUseIAMStreamConfigOnDMO;
    bool m_bUseIAMVideoCompressionOnDMO;

    HRESULT SetCompressionParamUsingIPropBag(const WCHAR * wszParam, const LONG lValue);
    
    // compression params for IAMVideoCompression, move to struct eventually
    long m_lKeyFrameRate;
    long m_lQuality;
    
    AM_MEDIA_TYPE       *m_pmtFromSetFormat;

};

#endif //__OUTPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\wmcodecstrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmcodecids.h
//
//--------------------------------------------------------------------------

#ifndef __WMCODECSTRS_H_
#define __WMCODECSTRS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// Configuration options for Windows Media Video Codecs
//

static const WCHAR *g_wszWMVCDatarate = L"_DATARATE";
static const WCHAR *g_wszWMVCKeyframeDistance = L"_KEYDIST";
static const WCHAR *g_wszWMVCCrisp = L"_CRISP";
static const WCHAR *g_wszWMVCTotalWindow = L"_TOTALWINDOW";
static const WCHAR *g_wszWMVCVideoWIndow = L"_VIDEOWINDOW";
static const WCHAR *g_wszWMVCFrameCount = L"_FRAMECOUNT";
static const WCHAR *g_wszWMVCLiveEncode = L"_LIVEENCODE";
static const WCHAR *g_wszWMVCComplexityMode = L"_COMPLEXITY";
static const WCHAR *g_wszWMVCPacketOverhead = L"_ASFOVERHEADPERFRAME";

#endif  // !defined(__WMCODECSTRS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\inpin.cpp ===
#include <wchar.h>
#include <streams.h>
#include <atlbase.h>
#include <wmsecure.h>
#include <limits.h>
#include "mediaobj.h"
#include "dmodshow.h"
#include "filter.h"
#include "inpin.h"
#include "outpin.h"

// BUGBUG - set proper name

CWrapperInputPin::CWrapperInputPin(
                      CMediaWrapperFilter *pFilter,
                      ULONG Id,
                      HRESULT *phr) :
    CBaseInputPin(NAME("CWrapperInputPin"),
                  pFilter,
                  pFilter->FilterLock(),
                  phr,
                  (m_pNameObject = new _PinName_(L"in", Id))->Name()
                 ),
    m_Id(Id),
    m_fEOS(false)
{
}

CWrapperInputPin::~CWrapperInputPin() {
   delete m_pNameObject;
}

STDMETHODIMP CWrapperInputPin::Receive(IMediaSample *pSample)
{
   HRESULT hr = Filter()->NewSample(m_Id, pSample);

   //  If something bad happens flush - this avoids some more deadlocks
   //  where we're holding on to the sample
   if (S_OK != hr) {
       Filter()->m_pMediaObject->Flush();
   }
   return hr;
}

HRESULT CWrapperInputPin::CheckMediaType(const CMediaType *pmt)
{
    return Filter()->InputCheckMediaType(m_Id, pmt);
}
HRESULT CWrapperInputPin::SetMediaType(const CMediaType *pmt)
{
    return Filter()->InputSetMediaType(m_Id, pmt);
}

HRESULT CWrapperInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    return Filter()->InputGetMediaType(m_Id, (ULONG)iPosition, pMediaType);
}


//  Remove any media type when breaking a connection
HRESULT CWrapperInputPin::BreakConnect()
{
    HRESULT hr = CBaseInputPin::BreakConnect();
    Filter()->m_pMediaObject->SetInputType(m_Id, &CMediaType(), DMO_SET_TYPEF_CLEAR);
    return hr;
}

//  Override GetAllocator and Notify Allocator to allow
//  for media object streams that hold on to buffer
STDMETHODIMP CWrapperInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator, E_POINTER);
    *ppAllocator = NULL;

    //  Already got an allocator or not using special behavior?
    if (m_pAllocator != NULL || !HoldsOnToBuffers()) {
        return CBaseInputPin::GetAllocator(ppAllocator);
    }

    DWORD dwLookahead;
    DWORD cbBuffer;
    DWORD cbAlign;
    HRESULT hr = TranslateDMOError(Filter()->m_pMediaObject->GetInputSizeInfo(
                               m_Id,
                               &cbBuffer,
                               &dwLookahead,
                               &cbAlign));
    if (FAILED(hr)) {
       return hr;
    }
    //  Create our own special allocator
    hr = S_OK;
    CSpecialAllocator *pAllocator = new CSpecialAllocator(dwLookahead, &hr);
    if (NULL == pAllocator) {
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        delete pAllocator;
        return hr;
    }

    m_pAllocator = pAllocator;
    m_pAllocator->AddRef();
    pAllocator->AddRef();
    *ppAllocator = pAllocator;
    return S_OK;
}
STDMETHODIMP CWrapperInputPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly
)
{
    //  If we hold on to buffers only allow our own allocator to be
    //  used
    if (HoldsOnToBuffers()) {
        if (pAllocator != m_pAllocator) {
            return E_FAIL;
        }
    }

    CAutoLock cObjectLock(m_pLock);

    // It does not make sense to propose an allocator if the pin
    // is not connected.
    ASSERT(IsConnected());

    HRESULT hr = MP3AndWMABufferSizeWorkAround(pAllocator);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 5, TEXT("WARNING in CWrapperInputPin::NotifyAllocator(): MP3AndWMABufferSizeWorkAround() failed and returned %#08x"), hr ));
    }

    return CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
}

STDMETHODIMP CWrapperInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    return Filter()->InputGetAllocatorRequirements(m_Id, pProps);
}

//  Just grab our critical section so we know we're quiesced
void CWrapperInputPin::SyncLock()
{
    CAutoLock lck(&m_csStream);
}


STDMETHODIMP CWrapperInputPin::NewSegment(
                REFERENCE_TIME tStart,
                REFERENCE_TIME tStop,
                double dRate)
{
    return Filter()->InputNewSegment(m_Id, tStart, tStop, dRate);
}


STDMETHODIMP CWrapperInputPin::BeginFlush()
{
    CAutoLock lck(m_pLock);

    //  Avoid deadlocks because the object is holding on to a sample
    //  Note we flush the object in EndFlush
    if (m_pAllocator) {
        m_pAllocator->Decommit();
    }
    return Filter()->BeginFlush(m_Id);
}
STDMETHODIMP CWrapperInputPin::EndFlush()
{
    CAutoLock lck(m_pLock);

    //  Recommit the allocator - we know no samples are flowing
    //  when EndFlush is called so this is safe to do in any order
    if (m_pAllocator) {
        m_pAllocator->Commit();
    }
    return Filter()->EndFlush(m_Id);
}
STDMETHODIMP CWrapperInputPin::EndOfStream()
{
    HRESULT hr = Filter()->EndOfStream(m_Id);
    //  where we're holding on to the sample
    if (S_OK != hr) {
        Filter()->m_pMediaObject->Flush();
    }
    return hr;
}

STDMETHODIMP CWrapperInputPin::Notify(IBaseFilter * pSender, Quality q)
{
    return E_NOTIMPL;
}

BOOL CWrapperInputPin::HoldsOnToBuffers()
{
    DWORD dwFlags = 0;
    Filter()->m_pMediaObject->GetInputStreamInfo(m_Id, &dwFlags);

    return 0 != (dwFlags & DMO_INPUT_STREAMF_HOLDS_BUFFERS);
}

HRESULT CWrapperInputPin::MP3AndWMABufferSizeWorkAround(IMemAllocator* pProposedAllocator)
{
    if (!IsConnected()) {
        return E_FAIL;
    }

    PIN_INFO pi;
    IPin* pConnected = GetConnected();

    HRESULT hr = pConnected->QueryPinInfo(&pi);
    if (FAILED(hr)) {
        return hr;
    }

    if (NULL == pi.pFilter) {
        return E_UNEXPECTED;
    }

    // {38be3000-dbf4-11d0-860e-00a024cfef6d}
    const CLSID MPEG_LAYER_3_DECODER_FILTER = { 0x38be3000, 0xdbf4, 0x11d0, { 0x86, 0x0e, 0x00, 0xa0, 0x24, 0xcf, 0xef, 0x6d } };

    // {22E24591-49D0-11D2-BB50-006008320064}
    const CLSID WINDOWS_MEDIA_AUDIO_DECODER_FILTER = { 0x22E24591, 0x49D0, 0x11D2, { 0xBB, 0x50, 0x00, 0x60, 0x08, 0x32, 0x00, 0x64 } };

    CLSID clsidFilter;

    hr = pi.pFilter->GetClassID(&clsidFilter);

    QueryPinInfoReleaseFilter(pi);

    // The Windows Media Audio Decoder (WMAD) filter and the MPEG Layer 3
    // (MP3) Decoder filter incorrectly calculate the output allocator's
    // media sample size.  The output allocator is the allocator used by
    // filter's the output pin.  Both filters tell the output allocator to
    // create samples which are too small.  Both filters then refuse to deliver
    // any samples when the filter graph is running because the output
    // allocator's samples cannot hold enough data.  The DMO Wrapper filter
    // works around these bugs because the authors of both filters
    // refuse to fix any bugs. The work around is to increase the allocator's
    // sample size if the allocator's sample size is too small and the DMO
    // Wrapper filter is connected to the WMA Decoder or the MP3 decoder.
    // The bug stops reproing once we increase the sample size.
    if (IsEqualCLSID(WINDOWS_MEDIA_AUDIO_DECODER_FILTER, clsidFilter)) {

        const DWORD MIN_WMA_FILTER_BUFFER_SIZE = 0x80000;

        hr = SetBufferSize(pProposedAllocator, MIN_WMA_FILTER_BUFFER_SIZE);
        if (FAILED(hr)) {
            return hr;
        }

    } else if (IsEqualCLSID(MPEG_LAYER_3_DECODER_FILTER, clsidFilter)) {

        // The MP3 decoder's audio sample buffers never hold
        // more then one tenth of second.  One tenth of second
        // of 44.1 KHZ 16 bit stereo PCM audio can be stored in
        // 17640 bytes.  17640 = (44100*2*2)/10 = 44E8.
        const DWORD MIN_MP3_BUFFER_SIZE = 0x44E8;

        hr = SetBufferSize(pProposedAllocator, MIN_MP3_BUFFER_SIZE);
        if (FAILED(hr)) {
            return hr;
        }

    } else {
        // Do nothing because we have not found a known broken filter.
    }

    return S_OK;
}

HRESULT CWrapperInputPin::SetBufferSize(IMemAllocator* pAllocator, DWORD dwMinBufferSize)
{
    ALLOCATOR_PROPERTIES apRequested;

    // Make sure dwMinBufferSize can be converted to a long.
    ASSERT(dwMinBufferSize <= LONG_MAX);

    HRESULT hr = pAllocator->GetProperties(&apRequested);
    if (FAILED(hr)) {
        return hr;
    }

    apRequested.cbBuffer = max((long)dwMinBufferSize, apRequested.cbBuffer);

    ALLOCATOR_PROPERTIES apActual;

    hr = pAllocator->SetProperties(&apRequested, &apActual);
    if (FAILED(hr)) {
        return hr;
    }

    if ((apActual.cbAlign != apRequested.cbAlign) ||
        (apActual.cBuffers < apRequested.cBuffers) ||
        (apActual.cbBuffer < apRequested.cbBuffer) ||
        (apActual.cbPrefix != apRequested.cbPrefix)) {

        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\dmo\wrapper\filter.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

#include <wchar.h>
#include "mediaobj.h"
#include "dmodshow.h"
#include "mediabuf.h"
//  Filter to wrap filter Media objects
//
//  Need to have topology defined by Media objects

//  TODO:
//     Add persistence stuff for clsid of object wrapped
//        and persist its own stuff too.
//

//
// This code uses DbgLog as follows:
//   LOG_CUSTOM1 logs streaming state changes
//   LOG_CUSTOM2 logs recurring streaming/processing events
//   LOG_CUSTOM3 logs connection events
//   LOG_CUSTOM4 logs initialization events
//   LOG_CUSTOM5 logs function entries (level 3: public, level 4: private)
//
// Log levels are used as follows:
//   0 - critical errors
//   1 - non-critical errors
//   2 - unusual non-erratic events
//   3 - function entries
//   4 - detailed step-by-step logging
//   5 - extremely detailed logging
//
#define LOG_STATE           LOG_CUSTOM1
#define LOG_STREAM          LOG_CUSTOM2
#define LOG_CONNECT         LOG_CUSTOM3
#define LOG_INIT            LOG_CUSTOM4
#define LOG_ENTRY           LOG_CUSTOM5
#define LOG_SECURECHANNEL   LOG_CUSTOM2

//
// Define a DbgLog wrapper macro to automatically do the following on error:
//  - add LOG_ERROR to the log category mask
//  - lower the level to 1
// If hr does not indicate an error, the supplied category/level is used as is.
//
#define LogHResult(hr,LOG_CATEGORY,caller,callee) \
   DbgLog((LOG_CATEGORY | (FAILED(hr) ? LOG_ERROR : 0), \
           FAILED(hr) ? 1 : 4, \
           "%s%s(): %s() returned 0x%08X", \
           FAILED(hr) ? "!!! ERROR: " : "", \
           caller, \
           callee, \
           hr))

// Define a DbgLog wrapper macro to aotomatically add LOG_CUSTOM5 to all function entry logs
#define LogPublicEntry(LOG_CATEGORY,name) \
   DbgLog((LOG_CATEGORY | LOG_ENTRY, \
           3, \
           "Entering %s()", name))
#define LogPrivateEntry(LOG_CATEGORY,name) \
   DbgLog((LOG_CATEGORY | LOG_ENTRY, \
           4, \
           "Entering %s()", name))


//
// Used for output IMediaBuffers.  Reusable - final Release does not delete.
// AddRef()/Release() calls are ignored because DMOs are not supposed to use
// those on an output buffer.
//
class CStaticMediaBuffer : public CBaseMediaBuffer {
public:
//   CStaticMediaBuffer() {m_pData = NULL;}
   STDMETHODIMP_(ULONG) AddRef() {return 2;}
   STDMETHODIMP_(ULONG) Release() {return 1;}
   void Init(BYTE *pData, ULONG ulSize) {
      m_pData = pData;
      m_ulSize = ulSize;
      m_ulData = 0;
   }
};

extern const AMOVIESETUP_FILTER sudMediaWrap;

class CWrapperInputPin;
class CWrapperOutputPin;
class CStaticMediaBuffer;

class CMediaWrapperFilter : public CBaseFilter,
                            public IDMOWrapperFilter,
                            public IPersistStream

{
    friend class CWrapperInputPin;
    friend class CWrapperOutputPin;
public:
    DECLARE_IUNKNOWN

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnkOuter, HRESULT *phr);

    CMediaWrapperFilter(LPUNKNOWN pUnkOwner,
                        HRESULT *phr);


    ~CMediaWrapperFilter();

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME rtStart);
    STDMETHODIMP GetState(DWORD dwMilliseconds, FILTER_STATE *pfs);

    STDMETHODIMP Init(REFCLSID clsidDMO, REFCLSID guidCat);

    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    STDMETHODIMP NonDelegatingQueryInterface(REFGUID riid, void **ppv);

    CCritSec *FilterLock()
    {
        return &m_csFilter;
    }

    CBasePin *GetPin(int iPin);
    int GetPinCount();

    //  Refresh what pins we have
    HRESULT RefreshPinList();

    //  Remove pins
    void DeletePins();

    //  New input sample from a pin - called with pin streaming lock held.
    HRESULT NewSample(ULONG ulIndex, IMediaSample *pSample);

    //  EndOfStream - called with pin streaming lock held.
    HRESULT EndOfStream(ULONG ulIndex);

    //  Check Media Type
    HRESULT InputCheckMediaType(ULONG ulIndex, const AM_MEDIA_TYPE *pmt);
    HRESULT OutputCheckMediaType(ULONG ulIndex, const AM_MEDIA_TYPE *pmt);

    //  Get Media Type
    HRESULT InputGetMediaType(ULONG ulIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt);
    HRESULT OutputGetMediaType(ULONG ulIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt);

    //  Set the media type - our pin classes pointlessly duplicate
    //  the media type stored by the object here
    HRESULT InputSetMediaType(ULONG ulIndex, const CMediaType *pmt);
    HRESULT OutputSetMediaType(ULONG ulIndex, const AM_MEDIA_TYPE *pmt);

    //  Allocator stuff
    HRESULT InputGetAllocatorRequirements(ULONG ulInputIndex,
                                          ALLOCATOR_PROPERTIES *pProps);
    HRESULT OutputDecideBufferSize(ULONG ulIndex, IMemAllocator *pAlloc,
                                   ALLOCATOR_PROPERTIES *ppropRequest);

    //  QueryInternalConnections stuff
    bool InputMapsToOutput(ULONG ulInputIndex, ULONG ulOutputIndex);

    HRESULT BeginFlush(ULONG ulInputIndex);
    HRESULT EndFlush(ULONG ulInputIndex);

    // NewSegment
    HRESULT InputNewSegment(ULONG ulInputIndex, REFERENCE_TIME tStart,
                            REFERENCE_TIME tStop, double dRate);

    // IPersistStream
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP GetClassID(CLSID *clsid);

protected:
    //
    // Per stream stuff
    //
    CWrapperInputPin**                m_pInputPins;
    CWrapperOutputPin**               m_pOutputPins;

    DMO_OUTPUT_DATA_BUFFER*           m_OutputBufferStructs;

    HRESULT AllocatePerStreamStuff (ULONG cInputs, ULONG cOutputs);
    void FreePerStreamStuff ();
    CWrapperInputPin* GetInputPinForPassThru();
    HRESULT QualityNotify(ULONG ulOutputIndex, Quality q);

    //  The Media object
    IMediaObject*  m_pMediaObject;
    IUnknown*      m_pDMOUnknown;
    IDMOQualityControl* m_pDMOQualityControl;
    IDMOVideoOutputOptimizations* m_pDMOOutputOptimizations;
    ULONG m_cInputPins;
    ULONG m_cOutputPins;

    // app certificate for secure dmo unlocking
    IUnknown*     m_pCertUnknown;
    IWMSecureChannel* m_pWrapperSecureChannel;

    //  Filter lock
    CCritSec                   m_csFilter;

    //  Streaming lock
    CCritSec                   m_csStreaming;

    //  Stop event
    CAMEvent                   m_evStop;

    BOOL                       m_fErrorSignaled;

    HRESULT DeliverInputSample(ULONG ulInputIndex, IMediaSample *pSample);

    typedef enum { KeepOutput, NullBuffer, DiscardOutput } DiscardType;
    HRESULT SuckOutOutput(DiscardType bDiscard = KeepOutput);

    HRESULT EnqueueInputSample(ULONG ulInputStreamIndex, IMediaSample *pSample);
    IMediaSample* DequeueInputSample(ULONG ulInputStreamIndex);
    bool CMediaWrapperFilter::InputQueueEmpty(ULONG ulInputStreamIndex);

    void FreeOutputSamples();

    void PropagateAnyEOS();

    HRESULT SetupSecureChannel();

    BOOL m_fNoUpstreamQualityControl;
    IQualityControl* m_pUpstreamQualityControl;
    CCritSec m_csLastOutputSampleTimes;
    CCritSec m_csQualityPassThru;

    CLSID m_clsidDMO;
    CLSID m_guidCat;
};

//  Hack to make a string
class _PinName_
{
public:
    _PinName_(WCHAR *szPrefix, int iName)
    {
        swprintf(sz, L"%s%d", szPrefix, iName);
    }
    WCHAR sz[20];
    LPCWSTR Name()
    {
        return sz;
    }
};


typedef CBasePin *PBASEPIN;

//  Translate error codes to dshow codes
HRESULT TranslateDMOError(HRESULT hr);

#endif //__FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfread\asfread.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.


/* This goes in the factory template table to create new instances */
CUnknown *CreateASFReaderInstance(LPUNKNOWN, HRESULT *);

extern const AMOVIESETUP_FILTER sudWMAsfRead;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfread\asfread.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// more things to do:
//
// Use IAMStreamSelect to allow turning on multiple video streams from an MBR file
// turn on user-provided clock, proxy DShow clock to WMSDK somehow
//      something to look at: if graph is paused, does SDK just run far ahead and eat memory?
//
// Get SetReceiveStreamSamples(TRUE) to work..... ok, it works, should we use it?
//                                      yes, currently on always.  allow turning it off somehow?
//
// implement additional interfaces for statistics, stream switch notifications?
// also support for markers--fire EC_MARKER_HIT?
// script commands? or will they just work?
//
// how to handle DRM properly?  -- fix when there are real certificates?
//
// test for non-local file playback--a few examples tried, live ones seem to work
//
// handle fast-forward/fast-rewind
//
// what about playlists?  additional support needed?  EC_EOS_SOON?
//
// need to pass client info down for logging...
//
// !!! check that timestamps are good for live stream
//
// probably need to pause the graph when we're buffering?
//
// also may need to return VFW_S_CANT_CUE from GetState....
//
// MBR currently completely broken.
//
// is it correct that we never let the WMSDK handle decompression?
//
// HTTP authentication won't work because we don't support the
// Credential interface
//
// report buffering progress
//
// ICustomSaveAs?  probably not necessary
//
// need new code to not do "user clock" for network sources, or,
// equivalently, to fall back to non-user-clock on failure
//

#include <streams.h>
#include <wmsdk.h>
#include <evcodei.h>
#include <wmsdkdrm.h>
#include <atlbase.h>

#include <initguid.h>
#include <qnetwork.h>



#include "asfreadi.h"

#pragma warning(disable:4355)

// if we have only one pin connected, we only need 1 or 2 buffers. any more,
// and we waste time every seek in paused state sending a bunch of frames that
// will never be used.
// But to avoid hanging, if >1 outpin is connected, we seem to need lots of
// buffering
//
#define LOW_BUFFERS 2
#define HIGH_BUFFERS 50

const int TIMEDELTA = 1000; // 1 sec clock tick if no clock
const int TIMEOFFSET = 1000; // 1 sec delta between DShow and ASF clock

#define PREROLL_SEEK_WINDOW 660000

// The WM ASF Reader does not alter the media samples time stamps.
// Another words, it does not speed up or slow down the audio or 
// video.
extern const double NORMAL_PLAYBACK_SPEED = 1.0;

WM_GET_LICENSE_DATA * CloneGetLicenseData( WM_GET_LICENSE_DATA * pGetLicenseData );
WM_INDIVIDUALIZE_STATUS * CloneIndividualizeStatusData( WM_INDIVIDUALIZE_STATUS * pIndStatus );

/*  Internal classes */

void CASFReader::_IntSetStart( REFERENCE_TIME Start )
{
    m_rtStart = Start;
}

CASFReader::CASFReader(LPUNKNOWN pUnk, HRESULT   *phr) :
           CBaseFilter(NAME("CASFReader"), pUnk, &m_csFilter, CLSID_WMAsfReader),
           m_OutputPins(NAME("CASFReader output pin list")),
           m_bAtEnd(FALSE),
           m_fSentEOS( FALSE ),
           m_hrOpen( S_OK ),
           m_fGotStopEvent( FALSE ),
           m_pFileName(NULL),
           m_Rate(NORMAL_PLAYBACK_SPEED),
           m_pReader(NULL),
           m_pReaderAdv(NULL),
           m_pReaderAdv2(NULL),
           m_pWMHI(NULL),
           m_pCallback(NULL),
           m_qwDuration(0),
           m_pStreamNums(NULL),
           m_lStopsPending( -1 ),
           m_bUncompressedMode( FALSE )
{
    m_pCallback = new CASFReaderCallback(this);

    if (!m_pCallback)
        *phr = E_OUTOFMEMORY;
    else
        m_pCallback->AddRef();
}

CASFReader::~CASFReader()
{
    delete [] m_pFileName;
    delete [] m_pStreamNums;
    RemoveOutputPins();
}

/* CBaseFilter */
int CASFReader::GetPinCount()
{
    CAutoLock lck(m_pLock);
    int n = 0;
    
    if( m_bUncompressedMode )
    {
        // we don't disable any outputs in uncompressed mode
        n = m_OutputPins.GetCount();
    }
    else
    {    
        POSITION pos = m_OutputPins.GetHeadPosition();
        while (pos) {
            CASFOutput *pPin = m_OutputPins.GetNext(pos);

            WMT_STREAM_SELECTION sel = WMT_OFF;
            m_pReaderAdv->GetStreamSelected((WORD) pPin->m_idStream, &sel);
    
            if (sel != WMT_OFF)
                ++n;
        }                
    }

    return n;
}

CBasePin *CASFReader::GetPin(int n) {
    CAutoLock lck(m_pLock);

    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        CASFOutput *pPin = m_OutputPins.GetNext(pos);
        
        WMT_STREAM_SELECTION sel = WMT_ON;
        if( !m_bUncompressedMode )
        {        
            // just count streams that are on
            m_pReaderAdv->GetStreamSelected((WORD) pPin->m_idStream, &sel);
        }
        if (sel != WMT_OFF) 
        {
            if (n-- == 0) 
            {
                return pPin;
            }
        }
    }
    return NULL;
}

// override Stop to sync with inputpin correctly
STDMETHODIMP
CASFReader::Stop()
{
    DbgLog((LOG_TRACE, 1, TEXT("*** CASFReader STOP ***")));

    if( !m_pReader )
        return E_FAIL;

    if (m_State != State_Stopped) 
    {
        HRESULT hr = CallStop(); // StopPushing();
        ASSERT(SUCCEEDED(hr));
    }
    return CBaseFilter::Stop();
}


// override Pause?
STDMETHODIMP
CASFReader::Pause()
{
    if( !m_pReader )
        return E_FAIL;

    HRESULT hr = S_OK;
    if (m_State == State_Stopped) {
        
        DbgLog((LOG_TRACE, 1, TEXT("*** CASFReader PAUSE ***")));
    
        // and do the normal active processing
        POSITION pos = m_OutputPins.GetHeadPosition();
        while (pos) {
            CASFOutput *pPin = m_OutputPins.GetNext(pos);
            if (pPin->IsConnected()) {
                pPin->Active();
            }
        }

        hr = StartPushing();

        if (SUCCEEDED(hr)) {
            m_State = State_Paused;
        }
        
    } else if (m_State == State_Running) {
        // !!! don't pause the reader!
	// !!! or should we???
        m_State = State_Paused;
    } else {



    }

    return hr;
}


// override Run to only start timers when we're really running
STDMETHODIMP
CASFReader::Run(REFERENCE_TIME tStart)
{
    if( !m_pReader )
        return E_FAIL;

    // !!! Resume the reader if we were paused?
    
    // should we need to care here?
    return CBaseFilter::Run(tStart);
}


// Override GetState to signal Pause failures
STDMETHODIMP
CASFReader::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    return CBaseFilter::GetState(dwMSecs, State);
}


/* Overriden to say what interfaces we support and where */
STDMETHODIMP
CASFReader::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we have this interface? */

    if (riid == IID_IFileSourceFilter) {
        return GetInterface(static_cast<IFileSourceFilter *>(this), ppv);
    }

    if (riid == IID_IAMExtendedSeeking) {
        return GetInterface(static_cast<IAMExtendedSeeking *>(this), ppv);
    }

    if (riid == IID_IWMHeaderInfo) {
        return GetInterface(static_cast<IWMHeaderInfo *>(this), ppv);
    }

    if (riid == IID_IWMReaderAdvanced) {
        return GetInterface(static_cast<IWMReaderAdvanced *>(this), ppv);
    }
    
    if (riid == IID_IWMReaderAdvanced2) {
        return GetInterface(static_cast<IWMReaderAdvanced2 *>(this), ppv);
    }

    if (riid == IID_IServiceProvider) {
        return GetInterface(static_cast<IServiceProvider *>(this), ppv);
    }
    
    return CBaseFilter::NonDelegatingQueryInterface(riid,ppv);
}


/*  Remove our output pins */
void CASFReader::RemoveOutputPins(BOOL fReleaseStreamer)
{
    for (;;) {
        CASFOutput *pPin = m_OutputPins.RemoveHead();
        if (pPin == NULL) {
            break;
        }
        IPin *pPeer = pPin->GetConnected();
        if (pPeer != NULL) {
            pPeer->Disconnect();
            pPin->Disconnect();
        }
        pPin->Release();
    }
    IncrementPinVersion();

    if (fReleaseStreamer) {
        if (m_pWMHI) {
            m_pWMHI->Release();
            m_pWMHI = NULL;
        }
        if (m_pReaderAdv) {
            m_pReaderAdv->Release();
            m_pReaderAdv = NULL;
        }
        if (m_pReaderAdv2) {
            m_pReaderAdv2->Release();
            m_pReaderAdv2 = NULL;
        }
        
        if (m_pReader) {
            DbgLog((LOG_TRACE, 1, TEXT("Closing reader, waiting for callback")));
            HRESULT hrClose = m_pReader->Close();

            if (hrClose == S_OK) 
            {
                m_evOpen.Wait();
            }
            m_pReader->Release();
            m_pReader = NULL;
        }
        if (m_pCallback) {
            m_pCallback->Release();
            m_pCallback = NULL;
        }
    }
}


HRESULT DumpAttributes(IWMHeaderInfo *pHeader)
{
    HRESULT hr = S_OK;
#ifdef DEBUG
    WORD i, wAttrCnt;

    hr = pHeader->GetAttributeCount( 0, &wAttrCnt );
    if ( FAILED( hr ) )
    {
        DbgLog((LOG_TRACE, 2, TEXT(" GetAttributeCount Failed %x\n"), hr ));
        return( hr );
    }

    for ( i = 0; i < wAttrCnt ; i++ )
    {
        WORD wStream = 0xffff;
        WCHAR  wName[512];
        WORD cbNamelen = sizeof(wName) / sizeof(wName[0]);
        WMT_ATTR_DATATYPE type;
        BYTE pValue[512];
        WORD cbLength = sizeof(pValue);

        hr = pHeader->GetAttributeByIndex( i, &wStream, wName, &cbNamelen, &type, pValue, &cbLength );
        if ( FAILED( hr ) && (hr != ASF_E_BUFFERTOOSMALL) ) 
        {
            DbgLog((LOG_TRACE, 2,  TEXT("GetAttributeByIndex (%d/%d) Failed %x"), i, wAttrCnt, hr ));
            return( hr );
        }

        switch ( type )
        {
        case WMT_TYPE_DWORD:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:  %d"), wName, *((DWORD *) pValue) ));
            break;
        case WMT_TYPE_STRING:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:   %ls"), wName, (WCHAR *) pValue ));
            break;
        case WMT_TYPE_BINARY:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:   Type = Binary of Length %d"), wName, cbLength));
        {
            char achHex[65];
            for (int j = 0; j < cbLength; j+= 32) {
                for (int k = 0; k < 32 && j + k < cbLength; k++) {
                    wsprintfA(achHex+k*2, "%02x", pValue[j+k]);
                }

                DbgLog((LOG_TRACE, 2, TEXT("     %hs"), achHex));
            }
        }
            break;
        case WMT_TYPE_BOOL:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:   %hs"), wName, ( * ( ( BOOL * ) pValue) ? "true" : "false" ) ));
            break;
        default:
            break;
        }
    }
#endif

    return hr;
}


// Override JoinFilterGraph so that we can delay loading a file until we're in a graph
STDMETHODIMP
CASFReader::JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);

    if (SUCCEEDED(hr) && m_pGraph && m_pFileName && !m_pReader) {
        hr = LoadInternal();
        if( FAILED( hr ) )
        {
            // uh-oh, we'll fail to join, but the base class thinks we did, so we 
            // need to unjoin the base class
            CBaseFilter::JoinFilterGraph(NULL, NULL);
        }            
    }
    
    return hr;
}


STDMETHODIMP
CASFReader::Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(pszFileName, E_POINTER);

    // is there a file loaded at the moment ?
    if (m_pFileName)
        return E_FAIL;

    //
    // Record the file name for GetCurFile
    //
    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)];
    if (m_pFileName==NULL) {
        return E_OUTOFMEMORY;
    }
    
    lstrcpyW(m_pFileName, pszFileName);

    if (!m_pGraph)
        return S_OK;

    return LoadInternal();
}

HRESULT CASFReader::LoadInternal()
{
    ASSERT(m_pGraph);

    HRESULT hr = S_OK;
    if( !m_pReader )
    {
        IObjectWithSite *pSite;
        
        hr = m_pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
        if (SUCCEEDED(hr)) {
            IServiceProvider *pSP;
            hr = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
            pSite->Release();
            
            if (SUCCEEDED(hr)) {
                IUnknown *pUnkCert;
                hr = pSP->QueryService(IID_IWMReader, IID_IUnknown, (void **) &pUnkCert);
                pSP->Release();
                if (SUCCEEDED(hr)) {
                    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
                    __try 
                    {
                        hr = WMCreateReader(pUnkCert, WMT_RIGHT_PLAYBACK, &m_pReader);
                        if( FAILED( hr ) )
                        {
                            DbgLog((LOG_TRACE, 1, TEXT("ERROR: CASFReader::LoadInternal WMCreateReader returned %x"), hr));
                        }                    
                    }
                    __except (  EXCEPTION_EXECUTE_HANDLER ) 
                    {
                        DbgLog(( LOG_TRACE, 1,
                            TEXT("CASFReader - Exception calling WMCreateReader, probably due to wmvcore.dll not present. Aborting. ")));
                        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
                    }
                
                    pUnkCert->Release();
                    if( SUCCEEDED( hr ) )
                    {                    
                        DbgLog((LOG_TRACE, 3, TEXT("WMCreateReader succeeded")));
                    }
                }
                else
                {
                    DbgLog((LOG_TRACE, 1, TEXT("ERROR: CASFReader::LoadInternal QueryService for certification returned %x"), hr));

                    // return dshow cert error
                    hr = VFW_E_CERTIFICATION_FAILURE;
                }
            }
            else
            {
                // return dshow cert error
                hr = VFW_E_CERTIFICATION_FAILURE;
            }        
        }
        else
        {
            hr = VFW_E_CERTIFICATION_FAILURE;
        }    
    }
    if ( !m_pReaderAdv && SUCCEEDED(hr)) {
        hr = m_pReader->QueryInterface(IID_IWMReaderAdvanced, (void **) &m_pReaderAdv);
    }
    
    HRESULT hrTmp;    
    if ( !m_pReaderAdv2 && SUCCEEDED(hr)) {
        hrTmp = m_pReader->QueryInterface(IID_IWMReaderAdvanced2, (void **) &m_pReaderAdv2);
    }
    
    if ( !m_pWMHI && SUCCEEDED(hr)) {
        // get header info, but it's okay if it's not there
        HRESULT hrWMHI = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &m_pWMHI);
    }
    
    if (SUCCEEDED(hr)) {
        hr = m_pReader->Open(m_pFileName, m_pCallback, NULL);

        DbgLog((LOG_TRACE, 2, TEXT("IWMReader::Open(%ls) returned %x"), m_pFileName, hr));
    } else if (m_pReader) {
        m_pReader->Release();
        m_pReader = NULL; // !!! work around bug #1365
    }

    if (SUCCEEDED(hr)) {
        m_evOpen.Wait();
        hr = m_hrOpen;
        DbgLog((LOG_TRACE, 2, TEXT("Finished waiting, callback returned %x"), hr));
    }
    
    m_bUncompressedMode = FALSE; // reset on new file
    
    if (SUCCEEDED(hr)) {        
        // get duration of file
        IWMHeaderInfo *pHeaderInfo;

        HRESULT hr2 = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
        if (SUCCEEDED(hr2)) {

            // random debug spew
            DumpAttributes(pHeaderInfo);
            
            WORD wStreamNum = 0xffff;
            WMT_ATTR_DATATYPE Type;
            WORD cbLength = sizeof(m_qwDuration);

            hr2 = pHeaderInfo->GetAttributeByName(&wStreamNum,
                                                    g_wszWMDuration,
                                                    &Type,
                                                    (BYTE *) &m_qwDuration,
                                                    &cbLength);

            if (SUCCEEDED(hr2)) {
                ASSERT(Type == WMT_TYPE_QWORD);

                DbgLog((LOG_TRACE, 2, TEXT("file duration = %dms"), (DWORD) (m_qwDuration / 10000)));

                m_rtStop = m_qwDuration;
                
                m_rtStart = 0;
            } else {
                DbgLog((LOG_TRACE, 2, TEXT("couldn't get duration of file, hr=%x"), hr2));
            }

            BOOL bIsDRM = FALSE;
            wStreamNum = 0xffff;
            cbLength = sizeof( BOOL );

            hr2 = pHeaderInfo->GetAttributeByName(&wStreamNum, // any DRM streams?
                                                    g_wszWMProtected,
                                                    &Type,
                                                    (BYTE *) &bIsDRM,
                                                    &cbLength);

            if (SUCCEEDED(hr2)) {
                ASSERT(Type == WMT_TYPE_BOOL);

                DbgLog((LOG_TRACE, 2, TEXT("Is this DRM'd content? %hs"), bIsDRM ? "true" : "false" ));
                if( bIsDRM )
                {
                    m_bUncompressedMode = TRUE;
                }
                
            } else {
                DbgLog((LOG_TRACE, 2, TEXT("couldn't get DRM attribute, hr=%x"), hr2));
            }

            pHeaderInfo->Release();
        }


        // error check?
        hr2 = m_pReaderAdv->SetReceiveSelectionCallbacks(TRUE);

    }
    
    if (SUCCEEDED(hr)) {
        IWMProfile *pProfile;
        hr = m_pReader->QueryInterface(IID_IWMProfile, (void **) &pProfile);
        if (SUCCEEDED(hr)) {
            DWORD cStreams;

            hr = pProfile->GetStreamCount(&cStreams);

            if (SUCCEEDED(hr)) {

                if( m_pStreamNums ) delete [] m_pStreamNums;
                m_pStreamNums = new WORD[cStreams];

                if( !m_pStreamNums ) 
                    hr = E_OUTOFMEMORY;
                else
                for (DWORD dw = 0; dw < cStreams; dw++) {
                    IWMStreamConfig *pConfig;

                    hr = pProfile->GetStream(dw, &pConfig);

                    if (FAILED(hr))
                        break;

                    WORD wStreamNum;
                    hr = pConfig->GetStreamNumber(&wStreamNum);
                    DbgLog((LOG_TRACE, 2, TEXT("Stream(%d) #%d"), dw, wStreamNum));
                    m_pStreamNums[dw] = wStreamNum;

                    WM_MEDIA_TYPE *pStreamType = NULL;
                    IWMMediaProps *pProps;
                    hr = pConfig->QueryInterface(IID_IWMMediaProps, (void **) &pProps);
                    if (SUCCEEDED(hr)) {
                        DWORD cbMediaType = 0;
                        hr = pProps->GetMediaType( NULL, &cbMediaType );
                        pStreamType = (WM_MEDIA_TYPE*)new BYTE[cbMediaType];
                        if (pStreamType) {
                            hr = pProps->GetMediaType( pStreamType, &cbMediaType );

                            if (SUCCEEDED(hr)) {
                                DisplayType(TEXT("Media Type"), (AM_MEDIA_TYPE *) pStreamType);
                            }
                        }
                        
                        pProps->Release();
                    }
                    
                    if( !m_bUncompressedMode )
                    {                    
                        if (SUCCEEDED(hr)) {
                            hr  = m_pReaderAdv->SetReceiveStreamSamples(wStreamNum, TRUE);

                            DbgLog((LOG_TRACE, 2, TEXT("SetReceiveStreamSamples(%d) returned %x"), wStreamNum, hr));


                            WCHAR wszName[20];
                            if (pStreamType->majortype == MEDIATYPE_Video) {
                                wsprintfW(wszName, L"Raw Video %d", dw);
                            } else if (pStreamType->majortype == MEDIATYPE_Audio) {
                                wsprintfW(wszName, L"Raw Audio %d", dw);
                            } else {
                                wsprintfW(wszName, L"Raw Stream %d", dw);
                            }

                            // create new output pin, append to list
                            CASFOutput *pPin = new CASFOutput( this, wStreamNum, pStreamType, &hr, wszName );

                            if (pPin == NULL) {
                                hr = E_OUTOFMEMORY;
                            }

                            if (SUCCEEDED(hr)) {
                                pPin->m_cToAlloc = LOW_BUFFERS; // !!!                        
                                hr = m_pReaderAdv->GetMaxStreamSampleSize(wStreamNum, &pPin->m_cbToAlloc);
                                DbgLog((LOG_TRACE, 2, TEXT("Stream %d: \"%ls\"  max size = %d"),
                                        wStreamNum, wszName, pPin->m_cbToAlloc));

                                if (pPin->m_cbToAlloc <= 32) {
                                    DbgLog((LOG_TRACE, 2, TEXT("Got back really small number, using 64K instead")));
                                    pPin->m_cbToAlloc = 65536; // !!!
                                }
                            }

                            if (FAILED(hr)) {
                                delete[] pStreamType;
                                pConfig->Release();
                                delete pPin;
                                break;
                            }

                            /* Release() is called when the pin is removed from the list */
                            pPin->AddRef();
                            POSITION pos = m_OutputPins.AddTail(pPin);
                            if (pos == NULL) {
                                delete pPin;
                                hr = E_OUTOFMEMORY;
                            }
                        }

                        if (SUCCEEDED(hr)) {
                            hr = m_pReaderAdv->SetAllocateForStream(wStreamNum, TRUE);

                            DbgLog((LOG_TRACE, 2, TEXT("SetAllocateForStream(%d) returned %x"), wStreamNum, hr));
                        }
                    }                        

                    delete[] pStreamType;
                    pConfig->Release();
                }
            }

            pProfile->Release();
        }

        DWORD cOutputs;
        hr = m_pReader->GetOutputCount(&cOutputs);

        if (SUCCEEDED(hr)) 
        {
            for (DWORD dw = 0; dw < cOutputs; dw++) 
            {
                if( !m_bUncompressedMode )
                {                
                    // call SetOutputProps(NULL) to ask the WMSDK not to
                    // load any codecs for us, since we expose compressed
                    // data
                    hr = m_pReader->SetOutputProps(dw, NULL);
                    DbgLog((LOG_TRACE, 2, TEXT("SetOutputProps(%d, NULL) returned %x"), dw, hr));
                }
                else
                {
                    IWMOutputMediaProps *pOutProps;

                    hr = m_pReader->GetOutputProps(dw, &pOutProps);

                    if (FAILED(hr))
                        break;

#ifdef DEBUG
                    WCHAR wszStreamGroupName[256];
                    WCHAR wszConnectionName[256];

                    WORD wSize = 256;
                    HRESULT hrDebug = pOutProps->GetStreamGroupName(wszStreamGroupName, &wSize);
                    if (FAILED(hrDebug)) 
                    {
                        DbgLog((LOG_ERROR, 1, "Error calling GetStreamGroupName(%d)", dw));
                    } 
                    else 
                    {
                        wSize = 256;
                        hrDebug = pOutProps->GetConnectionName(wszConnectionName, &wSize);
                        DbgLog((LOG_TRACE, 2, "Stream %d: StreamGroup '%ls', Connection '%ls'",
                                dw, wszStreamGroupName, wszConnectionName));
                    }
#endif

                    DWORD cbMediaType = 0;
                    hr = pOutProps->GetMediaType( NULL, &cbMediaType );
                    if (FAILED(hr)) {
                        pOutProps->Release();
                        break;
                    }
                
                    WM_MEDIA_TYPE *pStreamType = (WM_MEDIA_TYPE*)new BYTE[cbMediaType];
                    if( NULL == pStreamType )
                    {
                        pOutProps->Release();
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    hr = pOutProps->GetMediaType( pStreamType, &cbMediaType );
                    if( FAILED( hr ) )
                    {
                        pOutProps->Release();
                        break;
                    }

                    WCHAR wszName[20];
                    if (pStreamType->majortype == MEDIATYPE_Video) 
                    {
                        wsprintfW(wszName, L"Video %d", dw);
                    } 
                    else if (pStreamType->majortype == MEDIATYPE_Audio) 
                    {
                        wsprintfW(wszName, L"Audio %d", dw);
                    } 
                    else 
                    {
                        wsprintfW(wszName, L"Stream %d", dw);
                    }

                    // create new output pin, append to list
                    CASFOutput *pPin = new CASFOutput( this, dw, pStreamType, &hr, wszName );

                    delete[] pStreamType;
                
                    if (pPin == NULL) {
                        hr = E_OUTOFMEMORY;
                    }

                    pOutProps->Release();
                    
                    if (SUCCEEDED(hr)) 
                    {
                        pPin->m_cToAlloc = LOW_BUFFERS; // !!!                        
                        hr = m_pReaderAdv->GetMaxOutputSampleSize(dw, &pPin->m_cbToAlloc);
                        DbgLog((LOG_TRACE, 2, "Stream %d: \"%ls\"  max size = %d",
                                dw, wszName, pPin->m_cbToAlloc));
                        
                        if (pPin->m_cbToAlloc <= 32) 
                        {
                            DbgLog((LOG_TRACE, 2, TEXT("Got back really small number, using 64K instead")));
                            pPin->m_cbToAlloc = 65536; // !!!
                        }
                    }

                    if (FAILED(hr)) 
                    {
                        delete pPin;
                        break;
                    }

                    /* Release() is called when the pin is removed from the list */
                    pPin->AddRef();
                    POSITION pos = m_OutputPins.AddTail(pPin);
                    if (pos == NULL) 
                    {
                        delete pPin;
                        hr = E_OUTOFMEMORY;
                    }
                    
                    if (SUCCEEDED(hr)) 
                    {
                        hr = m_pReaderAdv->SetAllocateForOutput((WORD)dw, TRUE);

                        DbgLog((LOG_TRACE, 2, TEXT("SetAllocateForOutput(%d) returned %x"), dw, hr));
                    }
                    
                }                    
            }
        }
    }

    if (SUCCEEDED(hr)) {
        HRESULT hrClock = m_pReaderAdv->SetUserProvidedClock(TRUE);

        DbgLog((LOG_TRACE, 2, TEXT("Setting user-provided clock (TRUE) returned %x"), hrClock));

        if (FAILED(hr)) {
            // !!! this is documented to not work with some sources, presumably network ones?
        }
    }
    
    // if it didn't work, clean up
    if ( NS_E_LICENSE_REQUIRED == hr) 
    {
        //
        // if we failed because a license is required don't release reader interfaces
        // to give app a chance to do license acquisition using this same reader instance
        //
        // but clear filename so that the app can recall Load after acquiring license
        //
        delete [] m_pFileName;
        m_pFileName = NULL;
    }
    else if (FAILED(hr) ) {
        RemoveOutputPins();
    }
    
    return hr;
}


STDMETHODIMP
CASFReader::GetCurFile(
		    LPOLESTR * ppszFileName,
		    AM_MEDIA_TYPE *pmt)
{
    // return the current file name

    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
        *ppszFileName = (LPOLESTR) QzTaskMemAlloc( sizeof(WCHAR)
                                                 * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName!=NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        }
    }

    if (pmt) {
	pmt->majortype = GUID_NULL;   // Later!
	pmt->subtype = GUID_NULL;     // Later!
	pmt->pUnk = NULL;             // Later!
	pmt->lSampleSize = 0;         // Later!
	pmt->cbFormat = 0;            // Later!
    }

    return NOERROR;

}


/*  Send BeginFlush() downstream */
HRESULT CASFReader::BeginFlush()
{
    DbgLog((LOG_TRACE, 2, TEXT("Sending BeginFlush to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);

        HRESULT hr = pPin->DeliverBeginFlush();

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 2, TEXT("Got %x from DeliverBeginFlush"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

    return NOERROR;
}


    /*  Send EndFlush() downstream */
HRESULT CASFReader::EndFlush()
{
    DbgLog((LOG_TRACE, 2, TEXT("Sending EndFlush to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);

        HRESULT hr = pPin->DeliverEndFlush();

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 2, TEXT("Got %x from DeliverEndFlush"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

    return NOERROR;
}


HRESULT CASFReader::SendEOS()
{
    HRESULT hr;

    if (m_fSentEOS)
        return S_OK;

    m_fSentEOS = TRUE;
    
    DbgLog((LOG_TRACE, 1, TEXT("Sending EOS to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);

        hr = pPin->DeliverEndOfStream();

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 1, TEXT("Got %x from DeliverEndOfStream"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

#if 0
    //
    // See if we can already send the EC_EOS_SOON event so that the control can pre-load the next 
    // playlist element, if any. We don't want to send it too early, or else the next stream will
    // have to wait in its nssplit filter until this stream actually ends rendering
    // In other words, we try to return the codec to a position of zero credit, or otherwise 
    // we'll keep on accumulating early data at the client.
    // 
    m_fPendingEOSNotify = TRUE;
    ConsiderSendingEOSNotify();
#endif

    return NOERROR;
}

    
HRESULT CASFReader::CallStop()
{
    HRESULT hr = StopReader();    
    if (hr == S_OK) {
        m_evStartStop.Wait();
        hr = m_hrStartStop;
        DbgLog((LOG_TRACE, 5, TEXT("IWMReader::Stop() wait for StartStop event completed (m_pReader = 0x%08lx, hr = 0x%08lx)"), m_pReader, hr));
        if( SUCCEEDED( hr ) )
        {        
            // 
            // restore default streams selection state on successful stop, so unconnected pins don't 
            // disappear, in case we want to reconnect them next time
            //
            if( !m_bUncompressedMode )
            {    
                HRESULT hrTmp = SetupActiveStreams( TRUE ); 
#ifdef DEBUG        
                if( FAILED( hrTmp ) )
                {
                    DbgLog((LOG_TRACE, 1, TEXT("!!ERROR IWMReader::CallStop() SetupActiveStreams() failed (m_pReader = 0x%08lx, hr = 0x%08lx)"), m_pReader, hrTmp));
                }
#endif
            }
        }        
    }
    else
    {    
        DbgLog((LOG_TRACE, 1, TEXT("!!ERROR IWMReader::CallStop() failed with (m_pReader = 0x%08lx, hr = 0x%08lx)"), m_pReader, hr));
    }        
    return hr;
}

HRESULT CASFReader::StopReader()
{
    HRESULT hr = S_OK;
    if( 0 == InterlockedIncrement( &m_lStopsPending ) )
    {    
        hr = m_pReader->Stop();
        if( FAILED( hr ) )
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR - IWMReader::Stop() returned %x (m_pReader = 0x%08lx)"), hr, m_pReader));
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("IWMReader::Stop() returned %x (m_pReader = 0x%08lx)"), hr, m_pReader));
        }        
    }
    else
    {    
        DbgLog((LOG_TRACE, 5, TEXT("IWMReader::Stop() already pending (m_pReader = 0x%08lx)"), m_pReader));
    }
    return hr;
}

HRESULT CASFReader::SetupActiveStreams( BOOL bReset = FALSE )
{
    HRESULT hr = 0;

    ASSERT( !m_bUncompressedMode );

    CComPtr<IWMProfile> pProfile;
    hr = m_pReader->QueryInterface(IID_IWMProfile, (void **) &pProfile);
    if( FAILED( hr ) )
    {
        return hr;
    }

    DWORD cStreams;
    hr = pProfile->GetStreamCount(&cStreams);
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( cStreams == 0 )
    {
        return E_FAIL;
    }

    WORD * pAry = new WORD[cStreams];
    if( !pAry )
    {
        return E_OUTOFMEMORY;
    }

    WMT_STREAM_SELECTION * pSel = new WMT_STREAM_SELECTION[cStreams];
    if( !pSel )
    {
        delete [] pAry;
        return E_OUTOFMEMORY;
    }

    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();

    for( DWORD dw = 0 ; dw < cStreams && pos ; dw++ )
    {
        pPin = (CASFOutput *) m_OutputPins.Get(pos);
        if( bReset )
        {
            pSel[dw] = pPin->m_selDefaultState;
        }
        else
        {        
            if( pPin->IsConnected( ) )
            {
                pSel[dw] = WMT_ON;
            }
            else
            {
                pSel[dw] = WMT_OFF;
            }
        }            
        pAry[dw] = m_pStreamNums[dw];
        pos = m_OutputPins.Next(pos);
    }
    if( !m_bUncompressedMode )
    {    
        hr = m_pReaderAdv->SetManualStreamSelection( TRUE );
        hr = m_pReaderAdv->SetStreamsSelected( (WORD) cStreams, pAry, pSel );
    }
            
    delete [] pSel;
    delete [] pAry;

    return hr;
}

HRESULT CASFReader::StopPushing()
{
    BeginFlush();

    CallStop();

    EndFlush();
    
    return S_OK;
}

HRESULT CASFReader::StartPushing()
{
    ASSERT( m_pReader );
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, TEXT("Sending NewSegment to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);
        pPin->m_bFirstSample = TRUE;
        pPin->m_nReceived = 0;
        pPin->m_bNonPrerollSampleSent = FALSE;

        hr = pPin->DeliverNewSegment(m_rtStart, m_rtStop, GetRate());

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 1, TEXT("Got %x from DeliverNewSegment"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

    m_fSentEOS = FALSE;
    if( !m_bUncompressedMode )
    {    
        hr = SetupActiveStreams( );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }        
    m_lStopsPending = -1; // ensure only 1 stop gets called
    
    hr = m_pReader->Start(m_rtStart, 0, (float) GetRate(), NULL);

    DbgLog((LOG_TRACE, 1, TEXT("IWMReader::Start(%s, %d) returns %x"), (LPCTSTR) CDisp(m_rtStart), 0, hr));

    if (SUCCEEDED(hr)) {
        m_evStartStop.Wait();

        // !!! delayed HRESULT?
        hr = m_hrStartStop;
    }
    return hr;
}

//
// IServiceProvider
//
STDMETHODIMP CASFReader::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (NULL == ppv) 
    {
        return E_POINTER;
    }
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;
    
    if (IID_IWMDRMReader == guidService) 
    {
        // !! return IWMDRMReader to allow license acquisition to work on same reader instance
        if( m_pReader )
        {
            //
            // For this interface we pass out the reader's interface directly. 
            //
            hr = m_pReader->QueryInterface( riid, (void **) ppv );
        }
        else
        {
            hr = E_FAIL;
        }            
    }
    return hr;
}


CASFOutput::CASFOutput(CASFReader *pFilter, DWORD dwID, WM_MEDIA_TYPE *pStreamType, HRESULT *phr, WCHAR *pwszName) :
       CBaseOutputPin(NAME("CASFOutput"),   // Object name
                      pFilter,
                      &pFilter->m_csFilter,               // CCritsec *
                      phr,
                      pwszName),
       m_Seeking(pFilter, this, GetOwner(), phr),
       m_pFilter(pFilter),
       m_idStream(dwID),
       m_pOutputQueue(NULL),
       m_bNonPrerollSampleSent( FALSE )
{

    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::CASFOutput - stream id %d"), m_idStream));

    m_mt.majortype = pStreamType->majortype;
    m_mt.subtype = pStreamType->subtype;
    if (m_mt.majortype == MEDIATYPE_Video) {
        ASSERT(m_mt.subtype == GetBitmapSubtype(HEADER(pStreamType->pbFormat)));
        m_mt.subtype = GetBitmapSubtype(HEADER(pStreamType->pbFormat));
	if ((HEADER(pStreamType->pbFormat))->biSizeImage == 0) {
	    HRESULT hr = m_pFilter->m_pReaderAdv->GetMaxStreamSampleSize((WORD) dwID, &(HEADER(pStreamType->pbFormat))->biSizeImage);
	    DbgLog((LOG_TRACE, 2, TEXT("Adjusting biSizeImage from 0 to %d"), (HEADER(pStreamType->pbFormat))->biSizeImage));
	}
    }

    if (m_mt.majortype == MEDIATYPE_Audio) {
        WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pStreamType->pbFormat;
        // ASSERT(m_mt.subtype.Data1 == wfx->wFormatTag);
        m_mt.subtype.Data1 = pwfx->wFormatTag;
        m_mt.lSampleSize = pwfx->nBlockAlign;
    }

    m_mt.bFixedSizeSamples = pStreamType->bFixedSizeSamples;
    m_mt.bTemporalCompression = pStreamType->bTemporalCompression;
    m_mt.lSampleSize = pStreamType->lSampleSize;
    m_mt.formattype = pStreamType->formattype;
    m_mt.SetFormat(pStreamType->pbFormat, pStreamType->cbFormat);

    //
    // cache stream's original select state (picked by wmsdk reader), 
    // since we deselect unconnected pin streams on pause/run 
    // and use this to restore the original stream select state on stop
    //
    m_selDefaultState = WMT_OFF;
    m_pFilter->m_pReaderAdv->GetStreamSelected( (WORD)m_idStream, &m_selDefaultState);

    // !!! *phr = hr;
}


/*  Destructor */

CASFOutput::~CASFOutput()
{
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::~CASFOutput - stream id %d"), m_idStream));
}

// override say what interfaces we support where
STDMETHODIMP CASFOutput::NonDelegatingQueryInterface(
                                            REFIID riid,
                                            void** ppv )
{
    if( riid == IID_IMediaSeeking )
    {
        return( GetInterface( (IMediaSeeking *)&m_Seeking, ppv ) );
    }
    else
    {
        return( CBaseOutputPin::NonDelegatingQueryInterface( riid, ppv ) );
    }
}

/* Override revert to normal ref counting
   These pins cannot be finally Release()'d while the input pin is
   connected */

STDMETHODIMP_(ULONG)
CASFOutput::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CASFOutput::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}


// currently each output pin only supports one media type....
HRESULT CASFOutput::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    CAutoLock lck(m_pLock);

    if (iPosition < 0)  {
        return E_INVALIDARG;
    }

    if( m_pFilter->m_bUncompressedMode )
    {
        DWORD dwFormats;
        HRESULT hr = m_pFilter->m_pReader->GetOutputFormatCount(m_idStream, &dwFormats);
        if (iPosition >= (int) dwFormats) {
            return VFW_S_NO_MORE_ITEMS;
        }
    
        IWMOutputMediaProps *pOutProps;
        hr = m_pFilter->m_pReader->GetOutputFormat(m_idStream, iPosition, &pOutProps);

        DbgLog((LOG_TRACE, 2, "GetOutputFormat(%d  %d/%d)) returns %x", m_idStream, iPosition, dwFormats, hr));
        
        if (SUCCEEDED(hr)) {
            DWORD cbMediaType = 0;
            hr = pOutProps->GetMediaType( NULL, &cbMediaType );
            WM_MEDIA_TYPE *pStreamType = (WM_MEDIA_TYPE*)new BYTE[cbMediaType];
            if (pStreamType) {
                hr = pOutProps->GetMediaType( pStreamType, &cbMediaType );

                ASSERT(pStreamType->pUnk == NULL);
            
                if (SUCCEEDED(hr)) {
                    DisplayType(TEXT("Possible output mediatype"), (AM_MEDIA_TYPE *) pStreamType);
                    *pMediaType = *(AM_MEDIA_TYPE *) pStreamType;
                }
                delete[] pStreamType;
            }
            pOutProps->Release();
        
        }
        return hr; // no!
    }
    else
    {    
        if (iPosition > 0) {
            return VFW_S_NO_MORE_ITEMS;
        }

        *pMediaType = m_mt;
    }
    return S_OK;
}

HRESULT CASFOutput::CheckMediaType(const CMediaType *pmt)
{
    if( !m_pFilter->m_bUncompressedMode )
    {    
        if (*pmt == m_mt)
	    return S_OK;
    }
    else
    {
        int i = 0;

        while (1) {
            CMediaType mt;

            HRESULT hr = GetMediaType(i++, &mt);

            if (hr != S_OK)
                break;
                
            if (*pmt == mt)
            {                
                return S_OK;
            }                    
        }
    }    
    return S_FALSE;
}

HRESULT CASFOutput::SetMediaType(const CMediaType *mt)
{
    HRESULT hr = S_OK;
    if( m_pFilter->m_bUncompressedMode )
    {    
        IWMOutputMediaProps *pOutProps;
        HRESULT hr = m_pFilter->m_pReader->GetOutputProps(m_idStream, &pOutProps);
        if (SUCCEEDED(hr)) 
        {
            hr = pOutProps->SetMediaType((WM_MEDIA_TYPE *) mt);
            if (SUCCEEDED(hr)) 
            {
                hr = m_pFilter->m_pReader->SetOutputProps(m_idStream, pOutProps);
                if (SUCCEEDED(hr)) 
                {
                    CBaseOutputPin::SetMediaType(mt);
                }
            }
            pOutProps->Release();
        }            
    }
    
    // !!! override, don't let value change??? (in compressed case at least)
    return hr;
}

HRESULT CASFOutput::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    return CBaseOutputPin::DecideAllocator(pPin, ppAlloc);
}

HRESULT CASFOutput::DecideBufferSize(IMemAllocator * pAlloc,
				     ALLOCATOR_PROPERTIES * pProp)
{
    HRESULT hr = NOERROR;

    if (m_cToAlloc != HIGH_BUFFERS) {
        POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();
        while (pos) 
        {
            CASFOutput *pPin = m_pFilter->m_OutputPins.GetNext(pos);
            if (pPin && pPin != this && pPin->IsConnected())
            {
                // we only send 2 buffers when one pin's connected but because
                // of WMSDK limitations, we need to send 50 (or more) per pin when
                // we have 2 pins connected. (the reason is because audio or video could
                // have gaps in it, which without having 50 buffers per pin would cause a WMSDK
                // reader deadlock).

                ASSERT( pPin->m_pAllocator );

                if( pPin->m_pAllocator )
                {
                    ALLOCATOR_PROPERTIES Props;
                    ZeroMemory( &Props, sizeof( Props ) );
                    hr = pPin->m_pAllocator->GetProperties( &Props );
                    if( !FAILED( hr ) )
                    {
                        Props.cBuffers = max( Props.cBuffers, HIGH_BUFFERS );
                        ALLOCATOR_PROPERTIES Actual;
                        hr = pPin->m_pAllocator->SetProperties( &Props, &Actual );
                    }
                }

                m_cToAlloc = HIGH_BUFFERS;
            }
        }
    }

    if( FAILED( hr ) )
    {
        return hr;
    }

    if (pProp->cBuffers < (LONG) m_cToAlloc)
        pProp->cBuffers = m_cToAlloc;

    if (pProp->cbBuffer < (LONG) m_cbToAlloc)
        pProp->cbBuffer = m_cbToAlloc;

    if (pProp->cbAlign < 1)
        pProp->cbAlign = 1;

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProp, &Actual);

    if( SUCCEEDED( hr ) )
    {
        if (pProp->cBuffers > Actual.cBuffers || pProp->cbBuffer > Actual.cbBuffer)
        {
            hr = E_FAIL;
        }
    }

    return hr;    
};

//  Return TRUE if we're the pin being used for seeking
//  !!!! do we need something intelligent here?
BOOL CASFOutput::IsSeekingPin()
{
    //  See if we're the first connected pin

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();
    for (;;) {
        CASFOutput *pPin;
        pPin = m_pFilter->m_OutputPins.GetNext(pos);
        if (pPin == NULL) {
            break;
        }

        if (pPin->IsConnected()) {
	    return this == pPin;
        }
    }

    // we seem to get here sometimes while the graph is being rebuilt....
    DbgLog((LOG_ERROR, 1, TEXT("All pins disconnected in IsSeekingPin??")));
    return TRUE;
}


//
// Active
//
// This is called when we start running or go paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CASFOutput::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
        m_pOutputQueue = new COutputQueue(m_Connected, &hr, TRUE, FALSE);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }
    }

    // Pass the call on to the base class
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Active, about to commit allocator")));
    CBaseOutputPin::Active();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Active, back from committing allocator")));
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CASFOutput::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // Delete the output queus associated with the pin.
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Inactive, about to decommit allocator")));
    CBaseOutputPin::Inactive();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Inactive, back from decommitting allocator")));
    return NOERROR;

} // Inactive


//
// Deliver
//
HRESULT CASFOutput::Deliver(IMediaSample *pMediaSample)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    pMediaSample->AddRef();
    return m_pOutputQueue->Receive(pMediaSample);

} // Deliver


//
// DeliverEndOfStream
//
HRESULT CASFOutput::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CASFOutput::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();

    // decommit the allocator so the WMSDK push thread will stop
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverBeginFlush, about to decommit allocator")));
    m_pAllocator->Decommit();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverBeginFlush, back from decommitting allocator")));
    
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CASFOutput::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    // re-commit the allocator now that it's safe
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverEndFlush, about to re-commit allocator")));
    m_pAllocator->Commit();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverEndFlush, back from re-committing allocator")));
    
    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CASFOutput::DeliverNewSegment(REFERENCE_TIME tStart, 
                                         REFERENCE_TIME tStop,  
                                         double dRate)          
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


STDMETHODIMP CASFReader::get_ExSeekCapabilities(long FAR* pExCapabilities)
{
    if (!pExCapabilities)
	return E_INVALIDARG;

    long c = 0;

    c |= AM_EXSEEK_BUFFERING;

    // !!! is this right?
    c |= AM_EXSEEK_NOSTANDARDREPAINT;


    // !!! fix these?
    if (0)
	c |= AM_EXSEEK_SENDS_VIDEOFRAMEREADY;
    
    if (0)
        c |= AM_EXSEEK_CANSCAN | AM_EXSEEK_SCANWITHOUTCLOCK;

    if (1)
        c |= AM_EXSEEK_CANSEEK;

    if (0) 
        c |= AM_EXSEEK_MARKERSEEK;

    *pExCapabilities = c;

    return S_OK;
}

STDMETHODIMP CASFReader::get_MarkerCount(long FAR* pMarkerCount)
{
    if( !m_pReader )
        return E_FAIL;
        
    IWMHeaderInfo *pHeaderInfo;

    HRESULT hr = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
    if (SUCCEEDED(hr)) {
        WORD wMarkers;

        hr = pHeaderInfo->GetMarkerCount(&wMarkers);

        if (SUCCEEDED(hr))
            *pMarkerCount = (long) wMarkers;

        pHeaderInfo->Release();
    }

    return hr;
}

STDMETHODIMP CASFReader::get_CurrentMarker(long FAR* pCurrentMarker)
{
    if( !m_pReader )
        return E_FAIL;
        
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetMarkerTime(long MarkerNum, double FAR* pMarkerTime)
{
    if( !m_pReader )
        return E_FAIL;
        
    IWMHeaderInfo *pHeaderInfo;

    HRESULT hr = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
    if (SUCCEEDED(hr)) {
        QWORD qwTime;
        WORD cchMarkerName;

        hr = pHeaderInfo->GetMarker((WORD) MarkerNum, NULL, &cchMarkerName, &qwTime);

        if (SUCCEEDED(hr))
            *pMarkerTime = ((double) (LONGLONG) qwTime / 10000000.0);

        pHeaderInfo->Release();
    }

    return hr;
}

STDMETHODIMP CASFReader::GetMarkerName(long MarkerNum, BSTR FAR* pbstrMarkerName)
{
    if( !m_pReader )
        return E_FAIL;
        
    IWMHeaderInfo *pHeaderInfo;

    HRESULT hr = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
    if (SUCCEEDED(hr)) {
        QWORD qwTime;
        WORD cchMarkerName;

        hr = pHeaderInfo->GetMarker((WORD) MarkerNum, NULL, &cchMarkerName, &qwTime);

        if (SUCCEEDED(hr)) {
            *pbstrMarkerName = SysAllocStringLen(NULL, cchMarkerName);

            if (!*pbstrMarkerName)
                hr = E_OUTOFMEMORY;
            else {
                hr = pHeaderInfo->GetMarker((WORD) MarkerNum, *pbstrMarkerName, &cchMarkerName, &qwTime);
            }
        }

        pHeaderInfo->Release();
    }

    return hr;
}

STDMETHODIMP CASFReader::put_PlaybackSpeed(double Speed)
{
    if (!IsValidPlaybackRate(Speed)) {
        return E_INVALIDARG;
    }

    ASSERT(0);
    SetRate(Speed);

    return S_OK;
}

STDMETHODIMP CASFReader::get_PlaybackSpeed(double *pSpeed)
{
    *pSpeed = GetRate();

    return S_OK;
}

/* Overriden to say what interfaces we support and where */
STDMETHODIMP
CASFReaderCallback::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we have this interface? */

    if (riid == IID_IWMReaderCallback) {
	return GetInterface(static_cast<IWMReaderCallback *>(this), ppv);
    }

    if (riid == IID_IWMReaderCallbackAdvanced) {
	return GetInterface(static_cast<IWMReaderCallbackAdvanced *>(this), ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid,ppv);
}




// IWMReaderCallback
//
// qwSampleDuration will be 0 for most media types.
//
STDMETHODIMP CASFReaderCallback::OnSample(DWORD dwOutputNum,
                 QWORD qwSampleTime,
                 QWORD qwSampleDuration,
                 DWORD dwFlags,
                 INSSBuffer *pSample,
                 void *pvContext)
{
    DbgLog((LOG_TRACE, 2, TEXT("Callback::OnSample  %d   %d  %d  %d"),
            dwOutputNum, (DWORD) (qwSampleTime / 10000), (DWORD) (qwSampleDuration / 10000), dwFlags));

    if (m_pFilter->m_fSentEOS) {
	DbgLog((LOG_TRACE, 1, TEXT("Received sample after EOS....")));
	return S_OK; // !!! error?
    }
    
    CASFOutput * pPin = NULL;

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();
        
    while( pos )
    {
        pPin = (CASFOutput *) m_pFilter->m_OutputPins.Get( pos );

        if( pPin->m_idStream == dwOutputNum )
        {
            break;
        }

        pos = m_pFilter->m_OutputPins.Next( pos );
    }

    ASSERT(pPin);

    if (!pPin || !pPin->IsConnected()) {
        return S_OK;
    }

    CWMReadSample *pWMS = (CWMReadSample *) pSample;
    IMediaSample *pMS = pWMS->m_pSample;

    pMS->AddRef();
    if (pMS) {
        // qwSampleTime is from the start of the file, our time units are from the middle
        REFERENCE_TIME rtStart = qwSampleTime - m_pFilter->m_rtStart;
        REFERENCE_TIME rtStop = rtStart + qwSampleDuration;

        //
        // no delivering past where we were told.
        //
        
        // m_pFilter->m_rtStop is where we've been told to seek to, relative to the start of the file
        if( (REFERENCE_TIME) qwSampleTime >= m_pFilter->m_rtStop &&
            !( MEDIATYPE_Video == pPin->m_mt.majortype && !pPin->m_bNonPrerollSampleSent ) )
        {
            // but make sure we've delivered at least one non-prerolled video frame on a seek
            DbgLog((LOG_TRACE, 8, TEXT("OnSample: Finished delivering, since past where we were told( qwSampleTime = %ld, m_pFilter->m_rtStop = %ld"),
                    (long)( qwSampleTime/10000 ), (long) ( m_pFilter->m_rtStop/10000 ) ));
            pMS->Release();
            return S_OK;
        }
        
        pPin->m_nReceived++;

        DbgLog((LOG_TRACE, 2, TEXT("AsfRead:Setting sample #%ld's times to %ld %ld"), pPin->m_nReceived, long( rtStart / 10000 ), long( rtStop / 10000 ) ));

        pMS->SetTime(&rtStart, &rtStop);

        BOOL SyncPoint = dwFlags & WM_SF_CLEANPOINT;
        BOOL Discont = dwFlags & WM_SF_DISCONTINUITY;
        BOOL ShouldPreroll = ( rtStop <= 0 );
        if( MEDIATYPE_Video == pPin->m_mt.majortype )
        {        
            //
            // the following is a workaround, not an ideal solution...
            //
            // for video stop marking preroll if we get close enough to the seek window
            //
            if( 10000 == qwSampleDuration )
            {            
                // up to now durations of 10000 for video are used by the wmsdk reader erroneously
                ShouldPreroll = ( ( rtStart + PREROLL_SEEK_WINDOW ) <= 0 );
            }
#ifdef DEBUG            
            else
            {
                DbgLog((LOG_TRACE, 3, "!! HEADS UP - we're getting video samples with durations != 1, something's either fixed or more broken than before!!" ));
            }            
#endif            
        }

        // if we're to deliver the first sample downstream after a seek, we
        // HAVE to deliver a keyframe or guess what? We'll blow out a decompressor!
        //
        if( pPin->m_bFirstSample )
        {
            if( !SyncPoint )
            {
                DbgLog((LOG_TRACE, 1, TEXT("      Was seeked, but not key, exiting..." )));
                DbgLog((LOG_ERROR, 1, TEXT("      Was seeked, but not key, exiting..." )));
                pMS->Release();
                return S_OK;
            }
            pPin->m_bFirstSample = FALSE;

            // always set a discont after a seek
            //
            Discont = TRUE;
        }
        else
        {
            if( Discont )
            {
                DbgLog((LOG_TRACE, 0, TEXT("AsfRead:DISCONT DISCONT DISCONT DISCONT" )));
                if (pPin->m_mt.majortype == MEDIATYPE_Audio) 
                {
//                    ASSERT( !Discont );
                }
                Discont = FALSE;
            }
        }

#ifdef DEBUG
        if( Discont && !SyncPoint )
        {
            DbgLog((LOG_ERROR, 1, TEXT("      Got discont without sync..." )));
            DbgLog((LOG_TRACE, 1, TEXT("      Got discont without sync..." )));
        }
        if( SyncPoint )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Sample was a sync point" )));
        }
        if( Discont )
        {
            DbgLog((LOG_TRACE, 1, TEXT("Sample is a discontinuity" )));
        }
        if( ShouldPreroll )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Sample is prerolled" )));
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("sample is normal, no reroll" )));
        }
#endif
        if( !ShouldPreroll )
        {
            pPin->m_bNonPrerollSampleSent = TRUE;
        }        

        // don't allow a discont unless there's a key
        //
        Discont = Discont && SyncPoint;

        pMS->SetSyncPoint(SyncPoint);
        pMS->SetDiscontinuity(Discont);
        pMS->SetPreroll(ShouldPreroll); // !!! different if striding?

        HRESULT hr = pPin->Deliver(pMS);

        pMS->Release();
        
        DbgLog((LOG_TRACE, 5, TEXT("      Receive returns %x"), hr));

        if (hr != S_OK) {

            // was told to stop pushing
            //
            DbgLog((LOG_TRACE, 15, TEXT("      Calling stop in callback (m_pReader = 0x%08lx)"), m_pFilter->m_pReader));
            hr = m_pFilter->StopReader();
        }
    }

    
    return S_OK;
}


//
// The contents pParam depends on the Status.
//
STDMETHODIMP CASFReaderCallback::OnStatus(WMT_STATUS Status, 
                 HRESULT hrStatus,
                 WMT_ATTR_DATATYPE dwType,
                 BYTE *pValue,
                 void *pvContext)
{
    HRESULT hr = S_OK;
    AM_WMT_EVENT_DATA * pWMTEventInfo = NULL;
    ULONG ulCount = 0;
    BOOL bSent = FALSE;

    // !!! ignore if context doesn't match?
    
    switch (Status) {
        case WMT_ERROR:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_ERROR): %x"), hrStatus));
            m_pFilter->NotifyEvent( EC_ERRORABORT, hrStatus, 0 );
            break;
            
        case WMT_OPENED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_OPENED): %x"), hrStatus));
            m_pFilter->m_hrOpen = hrStatus;
            m_pFilter->m_evOpen.Set();
            break;
            
        case WMT_BUFFERING_START:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_BUFFERING_START): %x"), hrStatus));
            //
            // Tell the upper layer to show the BUFFERING msg in the UI,
            //
            m_pFilter->NotifyEvent( EC_BUFFERING_DATA, TRUE, 0 );
            break;
            
        case WMT_BUFFERING_STOP:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_BUFFERING_STOP): %x"), hrStatus));
            //
            // Tell the upper layer to show the BUFFERING msg in the UI,
            //
            m_pFilter->NotifyEvent( EC_BUFFERING_DATA, FALSE, 0 );
            break;
            
        case WMT_EOF:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_EOF): %x"), hrStatus));

            m_pFilter->SendEOS();
            
            break;
            
        case WMT_END_OF_SEGMENT:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_END_OF_SEGMENT): %x"), hrStatus));

            // !!! what is this for?
            ASSERT(0);
            
            break;
            
        case WMT_END_OF_STREAMING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_END_OF_STREAMING): %x"), hrStatus));

            // !!! send EC_EOS_SOON?
            break;
            
        case WMT_LOCATING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_LOCATING): %x"), hrStatus));

            m_pFilter->NotifyEvent(EC_LOADSTATUS, AM_LOADSTATUS_LOCATING, 0L); 
            break;
            
        case WMT_CONNECTING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_CONNECTING): %x"), hrStatus));

            m_pFilter->NotifyEvent(EC_LOADSTATUS, AM_LOADSTATUS_CONNECTING, 0L); 
            break;
            
        case WMT_NO_RIGHTS:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NO_RIGHTS): %x"), hrStatus));

            if( pValue )
            {            
                ulCount = 2 * (wcslen( (WCHAR *)pValue ) + 1 );

                pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
                if( pWMTEventInfo )
                {            
                    pWMTEventInfo->hrStatus = hrStatus;
                    pWMTEventInfo->pData = (void *) CoTaskMemAlloc( ulCount );
                    
                    if( pWMTEventInfo->pData )
                    {                
                        CopyMemory( pWMTEventInfo->pData, pValue, ulCount );
                        m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS, (LONG_PTR) pWMTEventInfo );
                        bSent = TRUE;
                    }
                    else
                    {
                        CoTaskMemFree( pWMTEventInfo );
                    }                
                }
            }
            if( !bSent )
            {            
                // use a null param struct to indicate out of mem error
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS, NULL ); 
            }
            
            break;

        case WMT_ACQUIRE_LICENSE:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_ACQUIRE_LICENSE): %x"), hrStatus));

    	    //
            // means we've acquired the license, tell app
            //
            pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
            if( pWMTEventInfo )
            {   
                pWMTEventInfo->hrStatus = hrStatus;
                if( SUCCEEDED( hrStatus ) )
                {                
                    pWMTEventInfo->pData = CloneGetLicenseData( (WM_GET_LICENSE_DATA *) pValue );
                    if( pWMTEventInfo->pData )
                    {                
                        m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_ACQUIRE_LICENSE, (LONG_PTR) pWMTEventInfo );
                        bSent = TRUE;
                    }
                    else
                    {
                        CoTaskMemFree( pWMTEventInfo );
                    }                
                }
                else
                {
                    bSent = TRUE;
                    pWMTEventInfo->pData = NULL;
                    m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_ACQUIRE_LICENSE, (LONG_PTR) pWMTEventInfo );
                }
            }            
            if( !bSent )
            {            
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_ACQUIRE_LICENSE, NULL ); // use a null param struct to indicate out of mem error
            }
            break;
            
        case WMT_MISSING_CODEC:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_MISSING_CODEC): %x"), hrStatus));
            // !!! call the unabletorender callback???
            // !!! if we're doing compressed pins, we should actually be okay, since we'll
            // expose the right pin, and the graph can make the right thing happen.
            break;
            
        case WMT_STARTED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_STARTED): %x"), hrStatus));
            m_pFilter->m_hrStartStop = hrStatus;
            {
                // !!! hack hack hack, in my opinion.
                // start the clock going
                REFERENCE_TIME tInitial = m_pFilter->m_rtStart + TIMEOFFSET * 10000;
                hr = m_pFilter->m_pReaderAdv->DeliverTime( tInitial );
                DbgLog((LOG_TIMING, 1, TEXT("   calling DeliverTime(%s) returns %x"), (LPCTSTR) CDisp(CRefTime(tInitial)), hr));
            }
            m_pFilter->m_evStartStop.Set();
            break;
            
        case WMT_STOPPED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_STOPPED): %x"), hrStatus));
            m_pFilter->m_hrStartStop = hrStatus;
            m_pFilter->m_evStartStop.Set();
            break;
            
        case WMT_CLOSED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_CLOSED): %x"), hrStatus));
            m_pFilter->m_hrOpen = hrStatus;
            m_pFilter->m_evOpen.Set();
            break;
            
        case WMT_STRIDING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_STRIDING): %x"), hrStatus));
            break;
            
        case WMT_TIMER:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_TIMER): %x"), hrStatus));
            ASSERT(!"got WMT_TIMER, why?");
            break;

        case WMT_INDIVIDUALIZE:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_INDIVIDUALIZE): %x"), hrStatus));
            
            pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
            if( pWMTEventInfo )
            {            
                pWMTEventInfo->hrStatus = hrStatus;
                pWMTEventInfo->pData = CloneIndividualizeStatusData( (WM_INDIVIDUALIZE_STATUS *) pValue );
                if( pWMTEventInfo->pData )
                {                
                    m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_INDIVIDUALIZE, (LONG_PTR) pWMTEventInfo );
                    bSent = TRUE;
                }
                else
                {
                    CoTaskMemFree( pWMTEventInfo );
                }
            }            
            if( !bSent )
            {            
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_INDIVIDUALIZE, NULL ); // use a null param struct to indicate out of mem error
            }
            break;

        case WMT_NEEDS_INDIVIDUALIZATION:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NEEDS_INDIVIDUALIZATION): %x"), hrStatus));
            m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NEEDS_INDIVIDUALIZATION, NULL ); // use a null param struct to indicate out of mem error
            break;

        case WMT_NO_RIGHTS_EX:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NO_RIGHTS_EX): %x"), hrStatus));
            
            pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
            if( pWMTEventInfo )
            {            
                pWMTEventInfo->hrStatus = hrStatus;
                pWMTEventInfo->pData = CloneGetLicenseData( (WM_GET_LICENSE_DATA *) pValue );
                if( pWMTEventInfo->pData )
                {                
                    m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS_EX, (LONG_PTR) pWMTEventInfo );
                    bSent = TRUE;
                }
                else
                {
                    CoTaskMemFree( pWMTEventInfo );
                }
            }            
            if( !bSent )
            {            
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS_EX, NULL ); // use a null param struct to indicate out of mem error
            }
            
            break;

#ifdef WMT_NEW_FORMAT
        case WMT_NEW_FORMAT:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NEW_FORMAT): %x"), hrStatus));
            ASSERT(!"got WMT_NEW_FORMAT, why?");
            break;
#endif
            
        default:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(UNKNOWN %d): %x"), Status, hrStatus));
            ASSERT(!"got unknown WMT_ status code");
            break;
    }

    return hr;
}

WM_GET_LICENSE_DATA * CloneGetLicenseData( WM_GET_LICENSE_DATA * pGetLicenseData )
{
    if( NULL == pGetLicenseData )
        return NULL;

    WM_GET_LICENSE_DATA * pClonedGetLicenseData = ( WM_GET_LICENSE_DATA *) CoTaskMemAlloc( sizeof( WM_GET_LICENSE_DATA ) );
    if( pClonedGetLicenseData )
    {            
        CopyMemory( pClonedGetLicenseData, pGetLicenseData, sizeof( WM_GET_LICENSE_DATA ) );

        ULONG ulCount1 = 0;
        ULONG ulCount2 = 0;
        ULONG ulCount3 = 0;
        if( pGetLicenseData->wszURL )
        {        
            ulCount1 = 2 * ( wcslen( (WCHAR *)pGetLicenseData->wszURL ) + 1 );
            pClonedGetLicenseData->wszURL = ( WCHAR *) CoTaskMemAlloc( ulCount1 );
        }
        if( pGetLicenseData->wszLocalFilename )
        {        
            ulCount2 = 2 * ( wcslen( (WCHAR *)pGetLicenseData->wszLocalFilename ) + 1 );
            pClonedGetLicenseData->wszLocalFilename = ( WCHAR *) CoTaskMemAlloc( ulCount2 );
        }
        if( pGetLicenseData->dwPostDataSize > 0 )
        {        
            ulCount3 = pGetLicenseData->dwPostDataSize;
            pClonedGetLicenseData->pbPostData = ( BYTE *) CoTaskMemAlloc( ulCount3 );
        }
        else
        {
            pClonedGetLicenseData->pbPostData = NULL;
        }        
        
        if( ( ulCount1 > 0 && !pClonedGetLicenseData->wszURL ) ||
            ( ulCount2 > 0 && !pClonedGetLicenseData->wszLocalFilename ) ||
            ( ulCount3 > 0 && !pClonedGetLicenseData->pbPostData ) )
        {
            // if we failed due to out of memory release all allocations
            CoTaskMemFree( pClonedGetLicenseData->wszURL );
            CoTaskMemFree( pClonedGetLicenseData->wszLocalFilename );
            CoTaskMemFree( pClonedGetLicenseData->pbPostData );
            CoTaskMemFree( pClonedGetLicenseData );
            pClonedGetLicenseData = NULL;
        }
        else 
        {
            CopyMemory( pClonedGetLicenseData->wszURL, pGetLicenseData->wszURL, ulCount1 );
            CopyMemory( pClonedGetLicenseData->wszLocalFilename, pGetLicenseData->wszLocalFilename, ulCount2 );
            CopyMemory( pClonedGetLicenseData->pbPostData, pGetLicenseData->pbPostData, ulCount3 );
        }                
    }            
    return pClonedGetLicenseData;
}

WM_INDIVIDUALIZE_STATUS * CloneIndividualizeStatusData( WM_INDIVIDUALIZE_STATUS * pIndStatus )
{
    if( NULL == pIndStatus )
        return NULL;

    WM_INDIVIDUALIZE_STATUS * pClonedIndStatus = ( WM_INDIVIDUALIZE_STATUS *) CoTaskMemAlloc( sizeof( WM_INDIVIDUALIZE_STATUS ) );
    if( pClonedIndStatus )
    {            
        CopyMemory( pClonedIndStatus, pIndStatus, sizeof( WM_INDIVIDUALIZE_STATUS ) );

        ULONG ulCount1 = 0;
        if( pIndStatus->pszIndiRespUrl )
        {
            ulCount1 = strlen( (LPSTR)pIndStatus->pszIndiRespUrl ) + 1;
            pIndStatus->pszIndiRespUrl = ( LPSTR ) CoTaskMemAlloc( ulCount1 );

            if( ulCount1 > 0 && !pIndStatus->pszIndiRespUrl )
            {
                CoTaskMemFree( pClonedIndStatus );
                pClonedIndStatus = NULL;
            }
            else if( ulCount1 > 0 )
            {
                CopyMemory( pClonedIndStatus->pszIndiRespUrl, pIndStatus->pszIndiRespUrl, ulCount1 );
            }                
        }            
    }            
    return pIndStatus;
}

// IWMReaderCallbackAdvanced

//
// Receive a sample directly from the ASF. To get this call, the user
// must register himself to receive samples for a particular stream.
//
STDMETHODIMP CASFReaderCallback::OnStreamSample(WORD wStreamNum,
                       QWORD qwSampleTime,
                       QWORD qwSampleDuration,
                       DWORD dwFlags,
                       INSSBuffer *pSample,
                       void *pvContext )
{
    DbgLog((LOG_TRACE, 5, TEXT("Callback::OnStreamSample(%d, %d, %d, %d)"),
           wStreamNum, (DWORD) (qwSampleTime / 10000), (DWORD) (qwSampleDuration / 10000), dwFlags));

    HRESULT hr = S_OK;

    ASSERT( !m_pFilter->m_bUncompressedMode );
    
    hr = OnSample((DWORD) wStreamNum, qwSampleTime, qwSampleDuration, dwFlags, pSample, pvContext);
    
    // find output pin, make IMediaSample, deliver

    // !!! why not just call OnSample?
    // !!! need to map wStreamNum back to an output #?


    return hr;
}


//
// In some cases, the user may want to get callbacks telling what the
// reader thinks the current time is. This is interesting in 2 cases:
// - If the ASF has gaps in it; say no audio for 10 seconds. This call
//   will continue to be called, while OnSample won't be called.
// - If the user is driving the clock, the reader needs to communicate
//   back to the user its time, to avoid the user overrunning the reader.
//
STDMETHODIMP CASFReaderCallback::OnTime(QWORD qwCurrentTime, void *pvContext )
{
    DbgLog((LOG_TRACE, 2, TEXT("Callback::OnTime(%d)"),
           (DWORD) (qwCurrentTime / 10000)));

    HRESULT hr = S_OK;

    if (qwCurrentTime >= (QWORD) m_pFilter->m_rtStop) {
	DbgLog((LOG_TRACE, 1, TEXT("OnTime value past the duration, we must be done")));
	
	m_pFilter->SendEOS();

	return S_OK;
    }
    
    QWORD qwNewTime = qwCurrentTime + TIMEDELTA * 10000;
    // if no clock, free-run the time forward

    hr = m_pFilter->m_pReaderAdv->DeliverTime(qwNewTime);
    DbgLog((LOG_TIMING, 2, TEXT("   calling DeliverTime(%d) returns %x"), (DWORD) (qwNewTime / 10000), hr));
    
    return hr;
}

//
// The user can also get callbacks when stream selection occurs.
//
STDMETHODIMP CASFReaderCallback::OnStreamSelection(WORD wStreamCount,
                          WORD *pStreamNumbers,
                          WMT_STREAM_SELECTION *pSelections,
                          void *pvContext)
{
    DbgLog((LOG_TRACE, 2, TEXT("Callback::OnStreamSelect(%d)"),
           wStreamCount));


    for (WORD w = 0; w < wStreamCount; w++) {
        DbgLog((LOG_TRACE, 2, TEXT("   StreamSelect(%d): %d"),
           pStreamNumbers[w], pSelections[w]));

        // send media type change downstream?

        // if we're using compressed pins, we need to switch which pin is in use.... 


    }

    return S_OK;
}

//
// If the user has registered to allocate buffers, this is where he must
// do it.
//
STDMETHODIMP CASFReaderCallback::AllocateForOutput(DWORD dwOutputNum,
                           DWORD cbBuffer,
                           INSSBuffer **ppBuffer,
                           void *pvContext )
{
    ASSERT( m_pFilter->m_bUncompressedMode );
    if( !m_pFilter->m_bUncompressedMode )
    {
        return E_NOTIMPL;
    }            
    
    CASFOutput * pPin = NULL;

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();

    while( pos )
    {
        pPin = (CASFOutput *) m_pFilter->m_OutputPins.Get( pos );

        if( pPin->m_idStream == dwOutputNum )
        {
            break;
        }
        pos = m_pFilter->m_OutputPins.Next( pos );
    }

    ASSERT(pPin);

    if (!pPin || !pPin->IsConnected()) 
    {
        return E_FAIL;  // !!! better return code?
    }

    IMediaSample *pMS;

    DbgLog((LOG_TRACE, 25, TEXT("CASFReaderCallback::AllocateForOutput(%d), getting %d byte buffer"), dwOutputNum, cbBuffer));
    HRESULT hr = pPin->m_pAllocator->GetBuffer(&pMS, NULL, NULL, 0);
    DbgLog((LOG_TRACE, 25, TEXT("CASFReaderCallback::AllocateForOutput(%d), GetBuffer returned %x"), dwOutputNum, hr));
    if (SUCCEEDED(hr)) 
    {
        // make INSSBuffer, put it into *ppBuffer

        // SDK shouldn't have asked for a buffer bigger than the max size
        ASSERT(cbBuffer <= (DWORD) pMS->GetSize());

        *ppBuffer = new CWMReadSample(pMS);

        if (!*ppBuffer)
        {        
            hr = E_OUTOFMEMORY;
        }            
        else 
        {
            (*ppBuffer)->AddRef();
            // WMSDK will assume buffer length has been set
            pMS->SetActualDataLength(cbBuffer);
        }            
	    pMS->Release();  // WMReadSample holds buffer now
    } 
    else 
    {
        DbgLog((LOG_ERROR, 4, TEXT("GetBuffer failed in AllocateForOutput, hr = %x"), hr));
    }

    return hr;
}

STDMETHODIMP CASFReaderCallback::OnOutputPropsChanged(DWORD dwOutputNum,
                            WM_MEDIA_TYPE *pMediaType,
                            void *pvContext)
{
    ASSERT(0);
    return E_NOTIMPL;
}

STDMETHODIMP CASFReaderCallback::AllocateForStream(WORD wStreamNum,
                            DWORD cbBuffer,
                            INSSBuffer **ppBuffer,
                            void *pvContext)
{
    if( m_pFilter->m_bUncompressedMode )
    {
        ASSERT( FALSE );
        return E_NOTIMPL;
    }
    
    CASFOutput * pPin = NULL;

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();

    while( pos )
    {
	pPin = (CASFOutput *) m_pFilter->m_OutputPins.Get( pos );

	if( pPin->m_idStream == wStreamNum )
	{
	    break;
	}

	pos = m_pFilter->m_OutputPins.Next( pos );
    }

    ASSERT(pPin);

    if (!pPin || !pPin->IsConnected()) {
	return E_FAIL;  // !!! better return code?
    }

    IMediaSample *pMS;

    DbgLog((LOG_TRACE, 4, TEXT("CASFReaderCallback::AllocateForStream(%d), getting %d byte buffer"), wStreamNum, cbBuffer));
    HRESULT hr = pPin->m_pAllocator->GetBuffer(&pMS, NULL, NULL, 0);
    DbgLog((LOG_TRACE, 4, TEXT("CASFReaderCallback::AllocateForStream(%d), GetBuffer returned %x"), wStreamNum, hr));

    if (SUCCEEDED(hr)) {
	// make INSSBuffer, put it into *ppBuffer

	// SDK shouldn't have asked for a buffer bigger than the max size
        ASSERT(cbBuffer <= (DWORD) pMS->GetSize());

        *ppBuffer = new CWMReadSample(pMS);

        if (!*ppBuffer)
            hr = E_OUTOFMEMORY;
        else {
            (*ppBuffer)->AddRef();
	    // WMSDK will assume buffer length has been set
	    pMS->SetActualDataLength(cbBuffer);
	}

	pMS->Release();  // WMReadSample holds buffer now
    } else {
	DbgLog((LOG_ERROR, 4, TEXT("GetBuffer failed in AllocateForStream, hr = %x"), hr));
    }

    return hr;
}


// IWMHeaderInfo forwarded to WMSDK
STDMETHODIMP CASFReader::GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeCount(wStreamNum, pcAttributes);
}


STDMETHODIMP CASFReader::GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByIndex(wIndex, pwStreamNum, pwszName,
                                        pcchNameLen, pType, pValue, pcbLength);
}


STDMETHODIMP CASFReader::GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByName(pwStreamNum, pszName, pType,
                                       pValue, pcbLength);
}


STDMETHODIMP CASFReader::SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->SetAttribute(wStreamNum, pszName, Type, pValue, cbLength);
}


STDMETHODIMP CASFReader::GetMarkerCount( WORD *pcMarkers )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarkerCount(pcMarkers);
}


STDMETHODIMP CASFReader::GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarker(wIndex, pwszMarkerName, pcchMarkerNameLen, pcnsMarkerTime);
}


STDMETHODIMP CASFReader::AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddMarker(pwszMarkerName, cnsMarkerTime);
}

STDMETHODIMP CASFReader::RemoveMarker( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveMarker(wIndex);
}

STDMETHODIMP CASFReader::GetScriptCount( WORD *pcScripts )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScriptCount(pcScripts);
}

STDMETHODIMP CASFReader::GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScript(wIndex, pwszType, pcchTypeLen, pwszCommand,
                              pcchCommandLen, pcnsScriptTime);
}

STDMETHODIMP CASFReader::AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddScript(pwszType, pwszCommand, cnsScriptTime);
}

STDMETHODIMP CASFReader::RemoveScript( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveScript(wIndex);
}


//
// IWMReaderAdvanced2 
// 
// Note that we only allow outside access to some of these methods,
// particularly the informational ones to provide download progress, etc...
// We don't allow an app access to any streaming or control methods.
//
STDMETHODIMP CASFReader::SetPlayMode( WMT_PLAY_MODE Mode )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->SetPlayMode( Mode );
}

STDMETHODIMP CASFReader::GetPlayMode( WMT_PLAY_MODE *pMode )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetPlayMode( pMode );
}

STDMETHODIMP CASFReader::GetBufferProgress( DWORD *pdwPercent, QWORD *pcnsBuffering )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetBufferProgress( pdwPercent, pcnsBuffering );
}

STDMETHODIMP CASFReader::GetDownloadProgress( DWORD *pdwPercent,
                                              QWORD *pqwBytesDownloaded,
                                              QWORD *pcnsDownload )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetDownloadProgress( pdwPercent, pqwBytesDownloaded, pcnsDownload );
}                             
                             
STDMETHODIMP CASFReader::GetSaveAsProgress( DWORD *pdwPercent )
{
    //
    // probably useful to apps, but then we'd need to forward 
    // WMT_SAVEAS_START and WMT_SAVEAS_STOP status as well...
    // so for later
    //
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SaveFileAs( const WCHAR *pwszFilename )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetProtocolName( WCHAR *pwszProtocol, DWORD *pcchProtocol )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetProtocolName( pwszProtocol, pcchProtocol );
}
STDMETHODIMP CASFReader::StartAtMarker( WORD wMarkerIndex, 
                       QWORD cnsDuration, 
                       float fRate, 
                       void *pvContext )
{
    return E_NOTIMPL;
}
                       
STDMETHODIMP CASFReader::GetOutputSetting( 
                DWORD dwOutputNum,
                LPCWSTR pszName,
                WMT_ATTR_DATATYPE *pType,
                BYTE *pValue,
                WORD *pcbLength )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetOutputSetting(
                DWORD dwOutputNum,
                LPCWSTR pszName,
                WMT_ATTR_DATATYPE Type,
                const BYTE *pValue,
                WORD cbLength )
{
    return E_NOTIMPL;
}
                
STDMETHODIMP CASFReader::Preroll( QWORD cnsStart, QWORD cnsDuration, float fRate )
{
    return E_NOTIMPL;
}
            
STDMETHODIMP CASFReader::SetLogClientID( BOOL fLogClientID )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->SetLogClientID( fLogClientID );
}

STDMETHODIMP CASFReader::GetLogClientID( BOOL *pfLogClientID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::StopBuffering( )
{
    return E_NOTIMPL;
}


// IWMReaderAdvanced forwarded to WMSDK
STDMETHODIMP CASFReader::SetUserProvidedClock( BOOL fUserClock )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetUserProvidedClock( BOOL *pfUserClock )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::DeliverTime( QWORD cnsTime )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetManualStreamSelection( BOOL fSelection )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetManualStreamSelection( BOOL *pfSelection )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetStreamsSelected( WORD cStreamCount, 
                            WORD *pwStreamNumbers,
                            WMT_STREAM_SELECTION *pSelections )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetStreamSelected( WORD wStreamNum, WMT_STREAM_SELECTION *pSelection )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetReceiveSelectionCallbacks( BOOL fGetCallbacks )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetReceiveSelectionCallbacks( BOOL *pfGetCallbacks )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetReceiveStreamSamples( WORD wStreamNum, BOOL fReceiveStreamSamples )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetReceiveStreamSamples( WORD wStreamNum, BOOL *pfReceiveStreamSamples )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetAllocateForOutput( DWORD dwOutputNum, BOOL fAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetAllocateForOutput( DWORD dwOutputNum, BOOL *pfAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetAllocateForStream( WORD dwStreamNum, BOOL fAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetAllocateForStream( WORD dwStreamNum, BOOL *pfAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetStatistics( WM_READER_STATISTICS *pStatistics )
{
    if (!m_pReaderAdv)
        return E_FAIL;

    return m_pReaderAdv->GetStatistics( pStatistics );
}

STDMETHODIMP CASFReader::SetClientInfo( WM_READER_CLIENTINFO *pClientInfo )
{
    if (!m_pReaderAdv)
        return E_FAIL;

    return m_pReaderAdv->SetClientInfo( pClientInfo );
}

STDMETHODIMP CASFReader::GetMaxOutputSampleSize( DWORD dwOutput, DWORD *pcbMax )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetMaxStreamSampleSize( WORD wStream, DWORD *pcbMax )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::NotifyLateDelivery( QWORD cnsLateness )
{
    return E_NOTIMPL;
}


// ------------------------------------------------------------------------
//
// CWMReadSample methods
//
CWMReadSample::CWMReadSample(IMediaSample  * pSample) :
        CUnknown(NAME("CWMReadSample"), NULL ),
        m_pSample( pSample )
{
    // !!!! addref sample here?
    m_pSample->AddRef();
}

CWMReadSample::~CWMReadSample()
{
    m_pSample->Release();
}


// override say what interfaces we support where
STDMETHODIMP CWMReadSample::NonDelegatingQueryInterface(
                                            REFIID riid,
                                            void** ppv )
{
    if (riid == IID_INSSBuffer) {
        return GetInterface( (INSSBuffer *)this, ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

// ------------------------------------------------------------------------
//
// methods to make our wrapped IMediaSample look like an INSSBuffer sample
//
STDMETHODIMP CWMReadSample::GetLength( DWORD *pdwLength )
{
    if (NULL == pdwLength) {
        return( E_INVALIDARG );
    }
    
    *pdwLength = m_pSample->GetActualDataLength();

    return( S_OK );
}

STDMETHODIMP CWMReadSample::SetLength( DWORD dwLength )
{
    return m_pSample->SetActualDataLength( dwLength );
} 

STDMETHODIMP CWMReadSample::GetMaxLength( DWORD * pdwLength )
{
    if( NULL == pdwLength )
    {
        return( E_INVALIDARG );
    }

    *pdwLength = m_pSample->GetSize();
    return( S_OK );
} 

STDMETHODIMP CWMReadSample::GetBufferAndLength(
    BYTE  ** ppdwBuffer,
    DWORD *  pdwLength )
{
    HRESULT hr = m_pSample->GetPointer(ppdwBuffer);

    if( SUCCEEDED( hr ) )
        *pdwLength = m_pSample->GetActualDataLength();
    
    return hr;        
} 

STDMETHODIMP CWMReadSample::GetBuffer( BYTE ** ppdwBuffer )
{
    return m_pSample->GetPointer( ppdwBuffer );
} 





// filter creation junk
CUnknown * CreateASFReaderInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CreateASFReaderInstance")));
    return new CASFReader(pUnk, phr);
}


// setup data
const AMOVIESETUP_FILTER sudWMAsfRead =
{ &CLSID_WMAsfReader        // clsID
, L"WM ASF Reader"      // strName
, MERIT_UNLIKELY        // dwMerit
, 0                     // nPins
, NULL   };             // lpPin


#ifdef FILTER_DLL

/*****************************************************************************/
// COM Global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    { L"WM ASF Reader"
    , &CLSID_WMAsfReader
    , CreateASFReaderInstance
    , NULL
    , &sudWMAsfRead }
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfread\seeking.cpp ===
// Copyright (c) Microsoft Corporation 1996-2000. All Rights Reserved

/*

    seeking.cpp

    Implementation of IMediaSeeking for the ASF reader source filter

*/

#include <streams.h>
#include <wmsdk.h>
#include <qnetwork.h>
#include "asfreadi.h"

//
//  IMediaSeeking stuff
//
/*  Constructor and Destructor */
CImplSeeking::CImplSeeking(CASFReader *pFilter,
                                               CASFOutput *pPin,
                                               LPUNKNOWN pUnk,
                                               HRESULT *phr) :
    CUnknown(NAME("CImplSeeking"),pUnk),
    m_pFilter(pFilter),
    m_pPin(pPin)
{
}

STDMETHODIMP
CImplSeeking::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    if (riid == IID_IMediaSeeking) {
	return GetInterface(static_cast<IMediaSeeking *>(this), ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

// returns S_OK if mode is supported, S_FALSE otherwise
STDMETHODIMP CImplSeeking::IsFormatSupported(const GUID * pFormat)
{
#if 0 // !!! bad things happen if we don't say we support at least TIME_FORMAT_MEDIA_TIME
    //  Only support seeking on one pin
    if (!m_pPin->IsSeekingPin()) {
        return S_FALSE;
    }
#endif

    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP CImplSeeking::QueryPreferredFormat(GUID *pFormat)
{
    /*  Don't care - they're all just as bad as one another */
    *pFormat = m_pPin->IsSeekingPin()
               ? TIME_FORMAT_MEDIA_TIME
               : TIME_FORMAT_NONE;
    return S_OK;
}

// can only change the mode when stopped
// (returns VFE_E_WRONG_STATE otherwise)
STDMETHODIMP CImplSeeking::SetTimeFormat(const GUID * pFormat)
{
    CAutoLock lck(&m_pFilter->m_csFilter);
    if (!m_pFilter->IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    if (S_OK != IsFormatSupported(pFormat)) {
        return E_INVALIDARG;
    }

    return S_OK;
}

//
//  Returns the current time format
//
STDMETHODIMP CImplSeeking::GetTimeFormat(GUID *pFormat)
{
    CAutoLock lck(&m_pFilter->m_csPosition);
    if (m_pPin->IsSeekingPin()) {
        *pFormat = TIME_FORMAT_MEDIA_TIME;
    } else {
        *pFormat = TIME_FORMAT_NONE;
    }

    return S_OK;
}

//
//  Returns the current time format
//
STDMETHODIMP CImplSeeking::IsUsingTimeFormat(const GUID * pFormat)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

    return ( m_pPin->IsSeekingPin() ? *pFormat == TIME_FORMAT_MEDIA_TIME :
				     *pFormat == TIME_FORMAT_NONE )
           ? S_OK
           : S_FALSE;
}

// return current properties
STDMETHODIMP CImplSeeking::GetDuration(LONGLONG *pDuration)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

    // !!! is this the proper error code to return?  Is this check a good idea at all?
    if (m_pFilter->m_qwDuration == 0) {
	DbgLog((LOG_TRACE, 1, TEXT("AsfReadSeek:GetDuration returning E_FAIL for a live stream")));
	return E_FAIL;
    }

#if 0
    if (m_pFilter->m_pMsProps && (SPF_BROADCAST & m_pFilter->m_pMsProps->dwFlags)) {
	DbgLog((LOG_TRACE, 4, TEXT("AsfReadSeek:GetDuration returning E_FAIL for a broadcast stream")));
	return E_FAIL;
    }
#endif

    DbgLog((LOG_TRACE, 8, TEXT("AsfReadSeek:GetDuration returning %ld"), (long) m_pFilter->m_qwDuration / 10000 ));

    *pDuration = m_pFilter->m_qwDuration;
    
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetStopPosition(LONGLONG *pStop)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

    if (m_pFilter->m_qwDuration == 0 && m_pFilter->m_rtStop == 0) {
	DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetStopPosition returning E_FAIL for a live stream with no duration set")));
	return E_FAIL;
    }
    
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetStopPosition returning %ld"), (long) m_pFilter->m_rtStop / 10000 ));

    *pStop = m_pFilter->m_rtStop;
    
    return S_OK;
}

//  Return the start position if we get asked for the current position on
//  the basis that we'll only be asked if we haven't sent any position data
//  yet in any samples.  The time needs to be relative to the segment we are
//  playing, therefore 0.
STDMETHODIMP CImplSeeking::GetCurrentPosition(LONGLONG *pCurrent)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

#if 0 // !!!!
    // We only want to report the current position when they ask through the
    // seeking interface of the video pin.
    if (m_pPin != m_pFilter->m_pVideoPin)
	return E_FAIL;
#endif
    
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetCurrentPosition returning %ld"), (long) 0 ));

    // BUGBUG Bogus

    *pCurrent = 0;
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetCapabilities( DWORD * pCapabilities )
{
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetCapabilities IS NOT IMPLEMENTED") ));

    // BUGBUG do this

    HRESULT hr = E_NOTIMPL;
    return hr;
}

STDMETHODIMP CImplSeeking::CheckCapabilities( DWORD * pCapabilities )
{
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:CheckCapabilities IS NOT IMPLEMENTED") ));

    // BUGBUG do this

    HRESULT hr = E_NOTIMPL;
    return hr;
}

STDMETHODIMP CImplSeeking::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                                             LONGLONG    Source, const GUID * pSourceFormat )
{
    // !!! we only support one time format....
    // perhaps we should still check what we're being asked to do

    // BUGBUG do this

    *pTarget = Source;
    return S_OK;
}

STDMETHODIMP CImplSeeking::SetPositions
( LONGLONG * pCurrent, DWORD CurrentFlags
, LONGLONG * pStop, DWORD StopFlags )
{
    CAutoLock Lock( &m_pFilter->m_csFilter );

    LONGLONG Current, CurrentMarker, Stop ;
    DWORD CurrentMarkerPacket = 0xffffffff;

    HRESULT hr;

    const DWORD PosCurrentBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;
    const DWORD PosStopBits    = StopFlags & AM_SEEKING_PositioningBitsMask;

    if (PosCurrentBits == AM_SEEKING_AbsolutePositioning) {
        Current = *pCurrent;
    } else if (PosCurrentBits || (PosStopBits == AM_SEEKING_IncrementalPositioning)) {
        hr = GetCurrentPosition( &Current );
        if (FAILED(hr)) {
            return hr;
        }
        if (PosCurrentBits == AM_SEEKING_RelativePositioning) Current += *pCurrent;
    }

    if (PosStopBits == AM_SEEKING_AbsolutePositioning) {
        Stop = *pStop;
    } else if (PosStopBits == AM_SEEKING_IncrementalPositioning) {
        Stop = Current + *pStop;
    } else {
	Stop = 0;
        hr = GetStopPosition( &Stop );
        if (FAILED(hr)) {
	    // fails for live streams, but ignore that for now...
	    // !!! return hr;
        }
        if (PosStopBits == AM_SEEKING_RelativePositioning) Stop += *pStop;
    }

    //  if this is the preferred pin, actually do the seek
    if (m_pPin->IsSeekingPin()) {
	{
	    CAutoLock lck(&m_pFilter->m_csPosition);
	    LONGLONG llDuration = 0;

	    //  Check limits
	    HRESULT hrDuration = GetDuration(&llDuration);
	    
	    if (PosCurrentBits) {
		if (Current < 0 || PosStopBits && Current > Stop) {
		    return E_INVALIDARG;
		}

#if 0
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
		VARIANT_BOOL	fCan;

		m_pFilter->get_CanSeek(&fCan);

		if (Current > 0 &&			// Not seeking to the beginning
		    Current != m_pFilter->m_rtStop &&	// Not seeking to the end
		    fCan == OAFALSE)			// Can't seek to just any old position
		{
		    m_pFilter->get_CanSeekToMarkers(&fCan);

		    if (fCan == OAFALSE) {
			// can't seek at all, sorry

			if (!m_pFilter->IsStopped()) {

			    // give it a good swift kick in the head
			    m_pFilter->BeginFlush();

			    m_pFilter->m_msDispatchTime = 0;
			    m_pFilter->m_dwFirstSCR = 0xffffffff;

			    m_pFilter->EndFlush();

			    return S_OK;
			}
			
			return E_FAIL;
		    }

		    // ok, they're planning to seek to a marker, which one?

		    // find the marker, set CurrentMarker, CurrentMarkerPacket

		    hr = m_pFilter->GetMarkerOffsets(Current, &CurrentMarker, &CurrentMarkerPacket);
		    if (FAILED(hr))
			return hr;
		} else {
		    // !!! if we're near enough to a marker, we could try
		    // to do marker-specific things....
		    CurrentMarker = Current;
		}
#endif
                
	    }

	    if (PosStopBits)
	    {
		if (SUCCEEDED(hrDuration) && (Stop > llDuration)) {
		    Stop = llDuration;
		}
		m_pFilter->m_rtStop = Stop;
	    }
	}

	if (PosCurrentBits)
	{
	    if (!m_pFilter->IsStopped())
		m_pFilter->StopPushing();

            m_pFilter->_IntSetStart( Current );

	    if (!m_pFilter->IsStopped())
		m_pFilter->StartPushing();
	}        
    }
    
    if (CurrentFlags & AM_SEEKING_ReturnTime)
    {
	*pCurrent = m_pFilter->m_rtStart;
    }
    if (StopFlags & AM_SEEKING_ReturnTime)
    {
	*pStop = m_pFilter->m_rtStop;
    }

    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:SetPositions to %ld %ld, this = %lx"), long( m_pFilter->m_rtStart / 10000 ), long( m_pFilter->m_rtStop / 10000 ), this ));
    
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hrResult = S_OK;

    if (pCurrent)
    {
        hrResult = GetCurrentPosition( pCurrent );
        if (FAILED(hrResult)) {
            return hrResult;
        }
    }

    if (pStop)
    {
        hrResult = GetStopPosition( pStop );
    }

    return hrResult;
}

STDMETHODIMP CImplSeeking::SetRate(double dRate)
{
    CAutoLock lck2(&m_pFilter->m_csPosition);
    if (!m_pFilter->IsValidPlaybackRate(dRate)) {  
        DbgLog((LOG_TRACE, 2, TEXT("WARNING in CImplSeeking::SetRate(): The user attempted to set an unsupported playback rate.") ));
        return E_INVALIDARG;
    }

    if (dRate != m_pFilter->GetRate()) {
	// !!! is this sufficient, do we need to remember the current position?
	if (!m_pFilter->IsStopped())
	    m_pFilter->StopPushing();

	m_pFilter->SetRate(dRate);

	if (!m_pFilter->IsStopped())
	    m_pFilter->StartPushing();
    }

    return S_OK;
}

STDMETHODIMP CImplSeeking::GetRate(double * pdRate)
{
    CAutoLock lck(&m_pFilter->m_csPosition);
    *pdRate = m_pFilter->GetRate();
    
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    HRESULT hr = S_OK;

    if (pEarliest != NULL) {
        *pEarliest = 0;
    }

    if (pLatest != NULL) {
        hr = GetDuration(pLatest);
    }
    return hr;
}


#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfread\asfreadi.h ===
#include "asfread.h"

//
// Our sample class which takes an input IMediaSample and makes it look like
// an INSSBuffer buffer for the wmsdk
//
class CWMReadSample : public INSSBuffer, public CUnknown
{

public:

    CWMReadSample(IMediaSample * pSample);
    ~CWMReadSample();

    DECLARE_IUNKNOWN
            
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // INSSBuffer
    STDMETHODIMP GetLength( DWORD *pdwLength );
    STDMETHODIMP SetLength( DWORD dwLength );
    STDMETHODIMP GetMaxLength( DWORD * pdwLength );
    STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength );
    STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer );

public: // !!!!
    IMediaSample *m_pSample;
};


class CASFReader;
class CASFOutput;

// ------------------------------------------------------------------------

//  Implementation of IMediaSeeking
class CImplSeeking : public CUnknown, public IMediaSeeking
{
private:
    CASFReader * const m_pFilter;
    CASFOutput * const m_pPin;

public:
    CImplSeeking(CASFReader *, CASFOutput *, LPUNKNOWN, HRESULT *);
    DECLARE_IUNKNOWN

    //  IMediaSeeking methods
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // returns S_OK if mode is supported, S_FALSE otherwise
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);

    // can only change the mode when stopped
    // (returns VFE_E_WRONG_STATE otherwise)
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);

    // return current properties
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);

    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP SetRate(double dRate);
    STDMETHODIMP GetRate(double * pdRate);
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll) { return E_NOTIMPL; }
};


// ------------------------------------------------------------------------
// output pin
//
//  CASFOutput defines the output pin
//
class CASFOutput : public CBaseOutputPin, /* ISplitterTiming, */ public CCritSec
{
    friend class CASFReaderCallback;
    friend class CASFReader;

public:
    // we use this to prohibit the WMSDK delivering us a VIDEO non-keyframe as the 1st sample
    BOOL m_bFirstSample;

    DECLARE_IUNKNOWN

    // Constructor and Destructor

    CASFOutput( CASFReader   * pFilter,
                DWORD           dwID,
                WM_MEDIA_TYPE  *pStreamType,
                HRESULT        * phr,
                WCHAR *pwszName);

    ~CASFOutput();

    // CUnknown methods

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();

    // CBasePin methods

    // returns the preferred formats for a pin
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // check if the pin can support this specific proposed type and format
    HRESULT CheckMediaType(const CMediaType *);

    // set the connection to use this format (previously agreed)
    HRESULT SetMediaType(const CMediaType *);

#if 0 // !!! not important for the moment....
    // override to call Commit and Decommit
    HRESULT BreakConnect();
#endif

    // CBaseOutputPin methods

    // Force our allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    HRESULT DecideBufferSize(IMemAllocator * pAlloc,
                         ALLOCATOR_PROPERTIES * ppropInputRequest);

        
    // Override to handle quality messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {    return E_NOTIMPL;   // We do NOT handle this
    }

    // Are we the pin being used for seeking
    BOOL IsSeekingPin();

#if 0
    //
    // ISplitterTiming methods
    //
    STDMETHODIMP GetLastPacketTime( LONGLONG *pTime );
    STDMETHODIMP_(BOOL) IsBroadcast();
#endif

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);
    
    //
    // Get an interface via QI on connected filter, if any
    //
    STDMETHODIMP QIConnectedFilter( REFIID riid, void **ppv );

    CASFReader * const m_pFilter;

    DWORD                m_idStream;
    WMT_STREAM_SELECTION m_selDefaultState; // reader's default stream selection state

    DWORD       m_cbToAlloc; // output buffer size
    long        m_nReceived;
    DWORD       m_cToAlloc;
    BOOL        m_bNonPrerollSampleSent; // we went to be sure to send at least one non-preroll video frame on a seek

    /*  Position stuff */
    CImplSeeking       m_Seeking;

    COutputQueue *m_pOutputQueue;  // Streams data to the peer pin
};


class CASFReaderCallback : public CUnknown, public IWMReaderCallback,
            public IWMReaderCallbackAdvanced
{
public:
    DECLARE_IUNKNOWN

    /* Overriden to say what interfaces we support and where */
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    CASFReader * const m_pFilter;
    
    CASFReaderCallback(CASFReader * pReader) : CUnknown(NAME("ASF reader callback"), NULL),
                                                m_pFilter(pReader)
            {}
                        
public:

    // IWMReaderCallback
    //
    // dwSampleDuration will be 0 for most media types.
    //
    STDMETHODIMP OnSample(DWORD dwOutputNum,
                     QWORD qwSampleTime,
                     QWORD qwSampleDuration,
                     DWORD dwFlags,
                     INSSBuffer *pSample,
                     void *pvContext);

    //
    // The contents pParam depends on the Status.
    //
    STDMETHODIMP OnStatus(WMT_STATUS Status, 
                     HRESULT hr,
                     WMT_ATTR_DATATYPE dwType,
                     BYTE *pValue,
                     void *pvContext);

    // IWMReaderCallbackAdvanced

    //
    // Receive a sample directly from the ASF. To get this call, the user
    // must register himself to receive samples for a particular stream.
    //
    STDMETHODIMP OnStreamSample(WORD wStreamNum,
                           QWORD qwSampleTime,
                           QWORD qwSampleDuration,
                           DWORD dwFlags,
                           INSSBuffer *pSample,
                           void *pvContext);

    //
    // In some cases, the user may want to get callbacks telling what the
    // reader thinks the current time is. This is interesting in 2 cases:
    // - If the ASF has gaps in it; say no audio for 10 seconds. This call
    //   will continue to be called, while OnSample won't be called.
    // - If the user is driving the clock, the reader needs to communicate
    //   back to the user its time, to avoid the user overrunning the reader.
    //
    STDMETHODIMP OnTime(QWORD qwCurrentTime, void *pvContext );

    //
    // The user can also get callbacks when stream selection occurs.
    //
    STDMETHODIMP OnStreamSelection(WORD wStreamCount,
                              WORD *pStreamNumbers,
                              WMT_STREAM_SELECTION *pSelections,
                              void *pvContext );

    //
    // If the user has registered to allocate buffers, this is where he must
    // do it.
    //
    STDMETHODIMP AllocateForOutput(DWORD dwOutputNum,
                               DWORD cbBuffer,
                               INSSBuffer **ppBuffer,
                               void *pvContext );

    STDMETHODIMP OnOutputPropsChanged(DWORD dwOutputNum, WM_MEDIA_TYPE *pMediaType,
                           void *pvContext);

    STDMETHODIMP AllocateForStream(WORD wStreamNum,
                               DWORD cbBuffer,
                               INSSBuffer **ppBuffer,
                               void *pvContext );

};


class CASFReader : public CBaseFilter, public IFileSourceFilter,
                public IAMExtendedSeeking, public IWMHeaderInfo,
                public IWMReaderAdvanced2, public IServiceProvider
#if 0
   ,IAMMediaContent, IMediaPositionBengalHack,
                        IAMNetworkStatus, IAMNetShowExProps,
                        IAMChannelInfo, IAMNetShowConfig,
                        ISpecifyPropertyPages, IAMNetShowThinning, IMediaStreamSelector,
                        IAMOpenProgress, IAMNetShowPreroll, ISplitterTiming, IAMRebuild,
                        IBufferingTime
#endif
{
    
public:
    DECLARE_IUNKNOWN

public:
    // global critical section
    CCritSec    m_csFilter;

    // Lock on setting and getting position values
    //
    CCritSec    m_csPosition;  // Integrity of values set

    /*  Internal classes */

    CASFReader(LPUNKNOWN  pUnk,
              HRESULT   *phr);
    ~CASFReader();

    /* CBaseFilter */
    int GetPinCount();
    CBasePin *GetPin(int n);

    /* IBaseFilter */

    // override Stop to sync with inputpin correctly
    STDMETHODIMP Stop();

    // override Pause to stop ourselves starting too soon
    STDMETHODIMP Pause();

    // override Run to only start timers when we're really running
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // Override GetState to signal Pause failures
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    void _IntSetStart( REFERENCE_TIME Start );

    // Helper
    BOOL IsStopped()
    {
        return m_State == State_Stopped;
    };

public:

    /* Overriden to say what interfaces we support and where */
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /*  Remove our output pins */
    void RemoveOutputPins(BOOL fReleaseStreamer = TRUE);

    // Override JoinFilterGraph so that we can delay loading a file until we're in a graph
    STDMETHODIMP JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName);

    HRESULT LoadInternal();

    double GetRate();
    void SetRate(double dNewRate);
    bool IsValidPlaybackRate(double dRate);

public: // IFileSourceFilter methods
    STDMETHODIMP Load(
                    LPCOLESTR pszFileName,
                    const AM_MEDIA_TYPE *pmt);

    STDMETHODIMP GetCurFile(
                    LPOLESTR * ppszFileName,
                    AM_MEDIA_TYPE *pmt);

    LPOLESTR      m_pFileName;  // set by Load, used by GetCurFile

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    /*  Send BeginFlush() downstream */
    HRESULT BeginFlush();

    /*  Send EndFlush() downstream */
    HRESULT EndFlush();

    HRESULT SendEOS();
    
    double m_Rate;
    
    CRefTime m_rtStart;
//    CRefTime m_rtMarkerStart;  // equal to m_rtStart, unless starting from a marker....
public:							// Making the Stop time accessible
    CRefTime m_rtStop;

private:
    DWORD    m_dwPacketIDStart;

    HRESULT CallStop();
    HRESULT StopReader();
    HRESULT StopPushing();
    HRESULT StartPushing();
    HRESULT SetupActiveStreams( BOOL bReset ); // if bReset is TRUE, restore default,
                                               // otherwise disable unconnected streams

private:
    //  Allow our internal classes to see our private data 
    friend class CASFOutput;
    friend class CImplSeeking;
    friend class CASFReaderCallback;
    
    CGenericList<CASFOutput> m_OutputPins;

    /*  At end of data so EndOfStream sent for all pins */
    BOOL                     m_bAtEnd;

    // NetShow - specific stuff
private:
    IWMReader          *m_pReader;
    IWMReaderAdvanced  *m_pReaderAdv;
    IWMReaderAdvanced2 *m_pReaderAdv2;
    IWMHeaderInfo      *m_pWMHI;
    IWMReaderCallback  *m_pCallback;
    QWORD               m_qwDuration;  // duration in ms
    BOOL                m_fSeekable;
    WORD                * m_pStreamNums;

    CAMEvent            m_evOpen;
    HRESULT             m_hrOpen;
    CAMEvent            m_evStartStop;  // !!! eliminate or combine with above?
    HRESULT             m_hrStartStop;
    LONG                m_lStopsPending;     // to ensure the reader's only stopped once
    BOOL                m_bUncompressedMode; // used for DRM content

    // !!! needed?
    BOOL                m_fGotStopEvent;
    BOOL                m_fSentEOS;


    // !!! bogus IDispatch impl
    STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetTypeInfo(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) { return E_NOTIMPL; }

    STDMETHODIMP Invoke(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) { return E_NOTIMPL; }
    // !!! end bogosity

    /* IAMExtendedSeeking methods */
    STDMETHODIMP get_ExSeekCapabilities(long FAR* pExCapabilities);
    STDMETHODIMP get_MarkerCount(long FAR* pMarkerCount);
    STDMETHODIMP get_CurrentMarker(long FAR* pCurrentMarker);
    STDMETHODIMP GetMarkerTime(long MarkerNum, double FAR* pMarkerTime);
    STDMETHODIMP GetMarkerName(long MarkerNum, BSTR FAR* pbstrMarkerName);
    STDMETHODIMP put_PlaybackSpeed(double Speed);
    STDMETHODIMP get_PlaybackSpeed(double *pSpeed);

    // IWMHeaderInfo
    STDMETHODIMP GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes );
    STDMETHODIMP GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength );
    STDMETHODIMP GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength );
    STDMETHODIMP SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength );
    STDMETHODIMP GetMarkerCount( WORD *pcMarkers );
    STDMETHODIMP GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime );
    STDMETHODIMP AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime );
    STDMETHODIMP RemoveMarker( WORD wIndex );
    STDMETHODIMP GetScriptCount( WORD *pcScripts );
    STDMETHODIMP GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime );
    STDMETHODIMP AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime );
    STDMETHODIMP RemoveScript( WORD wIndex );

    //
    // IWMReaderAdvanced2
    //
    STDMETHODIMP SetPlayMode( WMT_PLAY_MODE Mode );
    STDMETHODIMP GetPlayMode( WMT_PLAY_MODE *pMode );
    STDMETHODIMP GetBufferProgress( DWORD *pdwPercent, QWORD *pcnsBuffering );
    STDMETHODIMP GetDownloadProgress( DWORD *pdwPercent, QWORD *pqwBytesDownloaded, QWORD *pcnsDownload );
    STDMETHODIMP GetSaveAsProgress( DWORD *pdwPercent );
    STDMETHODIMP SaveFileAs( const WCHAR *pwszFilename );
    STDMETHODIMP GetProtocolName( WCHAR *pwszProtocol, DWORD *pcchProtocol );
    STDMETHODIMP StartAtMarker( WORD wMarkerIndex, 
                                QWORD cnsDuration, 
                                float fRate, 
                                void *pvContext );
    STDMETHODIMP GetOutputSetting( 
                    DWORD dwOutputNum,
                    LPCWSTR pszName,
                    WMT_ATTR_DATATYPE *pType,
                    BYTE *pValue,
                    WORD *pcbLength );
    STDMETHODIMP SetOutputSetting(
                    DWORD dwOutputNum,
                    LPCWSTR pszName,
                    WMT_ATTR_DATATYPE Type,
                    const BYTE *pValue,
                    WORD cbLength );
    STDMETHODIMP Preroll( 
                QWORD cnsStart,
                QWORD cnsDuration,
                float fRate );
    STDMETHODIMP SetLogClientID( BOOL fLogClientID );
    STDMETHODIMP GetLogClientID( BOOL *pfLogClientID );
    STDMETHODIMP StopBuffering( );

    //
    // IWMReaderAdvanced 
    //
    STDMETHODIMP SetUserProvidedClock( BOOL fUserClock );
    STDMETHODIMP GetUserProvidedClock( BOOL *pfUserClock );
    STDMETHODIMP DeliverTime( QWORD cnsTime );
    STDMETHODIMP SetManualStreamSelection( BOOL fSelection );
    STDMETHODIMP GetManualStreamSelection( BOOL *pfSelection );
    STDMETHODIMP SetStreamsSelected( WORD cStreamCount,
                                WORD *pwStreamNumbers,
                                WMT_STREAM_SELECTION *pSelections );
    STDMETHODIMP GetStreamSelected( WORD wStreamNum,
                                    WMT_STREAM_SELECTION *pSelection );
    STDMETHODIMP SetReceiveSelectionCallbacks( BOOL fGetCallbacks );
    STDMETHODIMP GetReceiveSelectionCallbacks( BOOL *pfGetCallbacks );
    STDMETHODIMP SetReceiveStreamSamples( WORD wStreamNum, BOOL fReceiveStreamSamples );
    STDMETHODIMP GetReceiveStreamSamples( WORD wStreamNum, BOOL *pfReceiveStreamSamples );
    STDMETHODIMP SetAllocateForOutput( DWORD dwOutputNum, BOOL fAllocate );
    STDMETHODIMP GetAllocateForOutput( DWORD dwOutputNum, BOOL *pfAllocate );
    STDMETHODIMP SetAllocateForStream( WORD dwStreamNum, BOOL fAllocate );
    STDMETHODIMP GetAllocateForStream( WORD dwSreamNum, BOOL *pfAllocate );
    STDMETHODIMP GetStatistics( WM_READER_STATISTICS *pStatistics );
    STDMETHODIMP SetClientInfo( WM_READER_CLIENTINFO *pClientInfo );
    STDMETHODIMP GetMaxOutputSampleSize( DWORD dwOutput, DWORD *pcbMax );
    STDMETHODIMP GetMaxStreamSampleSize( WORD wStream, DWORD *pcbMax );
    STDMETHODIMP NotifyLateDelivery( QWORD cnsLateness );
    // end of IWMReaderAdvanced methods

#if 0

    // IMediaPositionBengalHack

    STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetTypeInfo(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) { return E_NOTIMPL; }

    STDMETHODIMP Invoke(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) { return E_NOTIMPL; }

    /* IAMMediaContent methods */
    STDMETHODIMP get_AuthorName(THIS_ BSTR FAR* strAuthorName);
    STDMETHODIMP get_Title(THIS_ BSTR FAR* strTitle);
    STDMETHODIMP get_Copyright(THIS_ BSTR FAR* strCopyright);
    STDMETHODIMP get_Description(THIS_ BSTR FAR* strDescription);
    STDMETHODIMP get_Rating(THIS_ BSTR FAR* strRating);
    STDMETHODIMP get_BaseURL(THIS_ BSTR FAR* strBaseURL);
    STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL);
    STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL);
    STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL);
    STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL);
    STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }

    /* IMediaPositionBengalHack methods */
    STDMETHODIMP get_CanSetPositionForward(THIS_ long FAR* plCanSetPositionForward);
    STDMETHODIMP get_CanSetPositionBackward(THIS_ long FAR* plCanSetPositionBackward);
    STDMETHODIMP get_CanGoToMarker(THIS_ long lMarkerIndex, long FAR* plCanGoToMarker);
    // !!! why not just use marker times?
    STDMETHODIMP GoToMarker(THIS_ long lMarkerIndex);
//    STDMETHODIMP get_CurrentMarker(THIS_ long FAR* plMarkerIndex);


    // additional methods to define:
    // get current play statistics
    
    /* IAMNetworkStatus methods */
    STDMETHODIMP get_ReceivedPackets(long FAR* pReceivedPackets);
    STDMETHODIMP get_RecoveredPackets(long FAR* pRecoveredPackets);
    STDMETHODIMP get_LostPackets(long FAR* pLostPackets);
    STDMETHODIMP get_ReceptionQuality(long FAR* pReceptionQuality);
    STDMETHODIMP get_BufferingCount(long FAR* pBufferingCount);
    STDMETHODIMP get_IsBroadcast(VARIANT_BOOL FAR* pIsBroadcast);
    STDMETHODIMP get_BufferingProgress(long FAR* pBufferingProgress);

    /* IAMNetShowExProps methods */
    STDMETHODIMP get_SourceProtocol(long FAR* pSourceProtocol);
    STDMETHODIMP get_Bandwidth(long FAR* pBandwidth);
    STDMETHODIMP get_ErrorCorrection(BSTR FAR* pbstrErrorCorrection);
    STDMETHODIMP get_CodecCount(long FAR* pCodecCount);
    STDMETHODIMP GetCodecInstalled(long CodecNum, VARIANT_BOOL FAR* pCodecInstalled);
    STDMETHODIMP GetCodecDescription(long CodecNum, BSTR FAR* pbstrCodecDescription);
    STDMETHODIMP GetCodecURL(long CodecNum, BSTR FAR* pbstrCodecURL);
    STDMETHODIMP get_CreationDate(DATE FAR* pCreationDate);
    STDMETHODIMP get_SourceLink(BSTR FAR* pbstrSourceLink);


    // !!! former IAMExtendedSeeking methods
    STDMETHODIMP put_CurrentMarker(long CurrentMarker);
    STDMETHODIMP get_CanScan(VARIANT_BOOL FAR* pCanScan);
    STDMETHODIMP get_CanSeek(VARIANT_BOOL FAR* pCanSeek);
    STDMETHODIMP get_CanSeekToMarkers(VARIANT_BOOL FAR* pCanSeekToMarkers);

    /* IAMChannelInfo methods */
    STDMETHODIMP get_ChannelName(BSTR FAR* pbstrChannelName);
    STDMETHODIMP get_ChannelDescription(BSTR FAR* pbstrChannelDescription);
    STDMETHODIMP get_ChannelURL(BSTR FAR* pbstrChannelURL);
    STDMETHODIMP get_ContactAddress(BSTR FAR* pbstrContactAddress);
    STDMETHODIMP get_ContactPhone(BSTR FAR* pbstrContactPhone);
    STDMETHODIMP get_ContactEmail(BSTR FAR* pbstrContactEmail);

    /* IAMNetShowConfig methods */
    STDMETHODIMP get_BufferingTime(double FAR* pBufferingTime);
    STDMETHODIMP put_BufferingTime(double BufferingTime);
    STDMETHODIMP get_UseFixedUDPPort(VARIANT_BOOL FAR* pUseFixedUDPPort);
    STDMETHODIMP put_UseFixedUDPPort(VARIANT_BOOL UseFixedUDPPort);
    STDMETHODIMP get_FixedUDPPort(LONG FAR* pFixedUDPPort);
    STDMETHODIMP put_FixedUDPPort(LONG FixedUDPPort);
    STDMETHODIMP get_UseHTTPProxy(VARIANT_BOOL FAR* pUseHTTPProxy);
    STDMETHODIMP put_UseHTTPProxy(VARIANT_BOOL UseHTTPProxy);
    STDMETHODIMP get_EnableAutoProxy( VARIANT_BOOL FAR* pEnableAutoProxy );
    STDMETHODIMP put_EnableAutoProxy( VARIANT_BOOL EnableAutoProxy );
    STDMETHODIMP get_HTTPProxyHost(BSTR FAR* pbstrHTTPProxyHost);
    STDMETHODIMP put_HTTPProxyHost(BSTR bstrHTTPProxyHost);
    STDMETHODIMP get_HTTPProxyPort(LONG FAR* pHTTPProxyPort);
    STDMETHODIMP put_HTTPProxyPort(LONG HTTPProxyPort);
    STDMETHODIMP get_EnableMulticast(VARIANT_BOOL FAR* pEnableMulticast);
    STDMETHODIMP put_EnableMulticast(VARIANT_BOOL EnableMulticast);
    STDMETHODIMP get_EnableUDP(VARIANT_BOOL FAR* pEnableUDP);
    STDMETHODIMP put_EnableUDP(VARIANT_BOOL EnableUDP);
    STDMETHODIMP get_EnableTCP(VARIANT_BOOL FAR* pEnableTCP);
    STDMETHODIMP put_EnableTCP(VARIANT_BOOL EnableTCP);
    STDMETHODIMP get_EnableHTTP(VARIANT_BOOL FAR* pEnableHTTP);
    STDMETHODIMP put_EnableHTTP(VARIANT_BOOL EnableHTTP);

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IAMRebuild
    STDMETHODIMP RebuildNow();

    // --- IAMOpenProgress methods ---
    STDMETHODIMP QueryProgress(LONGLONG* pllTotal, LONGLONG* pllCurrent);
    STDMETHODIMP AbortOperation();

    //
    // IAMNetShowThinning
    //
    STDMETHODIMP GetLevelCount( long *pcLevels );
    STDMETHODIMP GetCurrentLevel( long *pCurrentLevel );
    STDMETHODIMP SetNewLevel( long NewLevel );
    STDMETHODIMP GetAutoUpdate( long *pfAutoUpdate );
    STDMETHODIMP SetAutoUpdate( long fAutoUpdate );

    //
    // IMediaStreamSelector
    //
    STDMETHODIMP ReduceBandwidth( IMediaStream *pStream, long RecvRate );
    STDMETHODIMP IncreaseBandwidth( IMediaStream *pStream, long RecvRate );

    //
    // IAMNetShowPreroll
    //
    STDMETHODIMP put_Preroll( VARIANT_BOOL fPreroll );
    STDMETHODIMP get_Preroll( VARIANT_BOOL *pfPreroll );

    //
    // ISplitterTiming Methods
    //
    STDMETHODIMP GetLastPacketTime(LONGLONG *pTime);
    STDMETHODIMP_(BOOL) IsBroadcast();

    //
    // IBufferingTime Methods
    //
    STDMETHODIMP GetBufferingTime( DWORD *pdwMilliseconds );
    STDMETHODIMP SetBufferingTime( DWORD dwMilliseconds );
#endif
};

extern const double NORMAL_PLAYBACK_SPEED;

inline double CASFReader::GetRate()
{
    ASSERT( IsValidPlaybackRate(m_Rate) );

    return m_Rate;
}

inline void CASFReader::SetRate(double dNewRate)
{
    // IWMReader::Start() only accepts rates between 1 and 10 and between -1 and -10.
    // See the documentation for IWMReader::Start() for more information.
    ASSERT(((-10.0 <= dNewRate) && (dNewRate <= -1.0)) || ((1.0 <= dNewRate) && (dNewRate <= 10.0)));

    ASSERT( IsValidPlaybackRate(dNewRate) );
    
    m_Rate = dNewRate;
}

inline bool CASFReader::IsValidPlaybackRate(double dRate)
{
    // The WM ASF Reader only supports normal playback speeds.  It does 
    // not support fast forward or rewind.
    return (NORMAL_PLAYBACK_SPEED == dRate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfwrite\asfwrite.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __WMWrite__
#define __WMWrite__

#include "dshowasf.h"

////////////////////////////////////////////////////////////////////////////////

extern const AMOVIESETUP_FILTER sudWMAsfWriter;

#define PROFILE_ID_NOT_SET 0xFFFFFFFF

enum WMWRITE_PINTYPE {
    PINTYPE_NONE  = 0,
    PINTYPE_AUDIO, 
    PINTYPE_VIDEO
};

class CWMWriterIndexerCallback;
class CWMWriter;
class CWMWriterInputPin;

typedef CGenericList<IPin> PinList;

//
// Our sample class which takes an input IMediaSample and makes it look like
// an INSSBuffer buffer for the wmsdk
//
class CWMSample : public INSSBuffer, public CBaseObject
{

public:
    CWMSample(
        TCHAR *pName,
        IMediaSample * pSample );

    // IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHOD( QueryInterface )( REFIID riid, void **ppvObject );
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP_(ULONG) AddRef();

    // INSSBuffer
    STDMETHODIMP GetLength( DWORD *pdwLength );
    STDMETHODIMP SetLength( DWORD dwLength );
    STDMETHODIMP GetMaxLength( DWORD * pdwLength );
    STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength );
    STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer );

private:
    IMediaSample *m_pSample;
    LONG         m_cOurRef;
};

//
// Indexing class
//
class CWMWriterIndexerCallback : 
    public CUnknown, public IWMStatusCallback 
{
public:
    DECLARE_IUNKNOWN

    // we support some interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    CWMWriterIndexerCallback(CWMWriter * pWriter) : 
        CUnknown(NAME("CWMWriterIndexerCallback"), NULL), m_pFilter(pWriter) {}

    // IWMStatusCallback
    STDMETHODIMP OnStatus(WMT_STATUS Status, 
                     HRESULT hr,
                     WMT_ATTR_DATATYPE dwType,
                     BYTE *pValue,
                     void *pvContext );
    
    CWMWriter * m_pFilter;
    
};


// 
// Writer input pin class
// 
class CWMWriterInputPin : 
    public CBaseInputPin,
    public IAMStreamConfig
{
    friend class CWMWriter;

protected:

    // interleave stuff
    //
    HANDLE m_hWakeEvent;
    void SleepUntilReady( );
    void WakeMeUp();
    BOOL m_bNeverSleep;

    HRESULT HandleFormatChange( const CMediaType *pmt );

    // owning filter
    CWMWriter *m_pFilter;

public:

    // input pin supports an interface
    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFGUID riid, void **ppv);
    
    CWMWriterInputPin(
      CWMWriter *pWMWriter,     // used to enumerate pins
      HRESULT *pHr,             // OLE failure return code
      LPCWSTR szName,           // pin identification
      int numPin,               // number of this pin
      DWORD dwPinType,
      IWMStreamConfig * pWMStreamConfig );


    ~CWMWriterInputPin();

    // update pin info, used to make a recycled pin current
    HRESULT Update( LPCWSTR pName, int numPin, DWORD dwPinType, IWMStreamConfig * pWMStreamConfig );

    // build a list of input media acceptable to the wmsdk for the current profile
    HRESULT BuildInputTypeList();

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* pmt);
    
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType); 

    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();
    STDMETHODIMP Disconnect();

    // set the connection media type, as well as the input type for wmsdk
    HRESULT SetMediaType(const CMediaType *pmt);

    STDMETHODIMP NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    // for dynamic format changes
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
    );


    // --- IMemInputPin -----

    // here's the next block of data from the stream.
    STDMETHODIMP Receive(IMediaSample * pSample);

    // provide EndOfStream
    STDMETHODIMP EndOfStream(void);
    
    // Called when the stream goes active/inactive
    HRESULT Active(void);
    HRESULT Inactive(void);

    // IAMStreamConfig methods
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt) {return E_NOTIMPL;} ;
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt); // used to return default compressed format
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize){return E_NOTIMPL;} ;
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC){return E_NOTIMPL;} ;


   // Attributes
protected:
    CCritSec m_csReceive;      	// input wide receive lock
    
public:

    BOOL m_bConnected;          // CompleteConnect/BreakConnect pairs
    int m_numPin;               // pin number
    int m_numStream;            // stream #, valid while running
    
    IWMInputMediaProps * m_pWMInputMediaProps;

protected:

    DWORD   m_fdwPinType;       // audio, video,...
    BOOL    m_fEOSReceived;     // Received an EOS yet?
    DWORD   m_cInputMediaTypes; // count of input types offered by our input pin
    IWMMediaProps ** m_lpInputMediaPropsArray; // list of types we offer, based on current profile
    IWMStreamConfig * m_pWMStreamConfig;
    BOOL    m_bCompressedMode;	// this pin's getting compressed data and using advanced writer intf

    DWORD    m_cSample;         // sample counter
    REFERENCE_TIME m_rtFirstSampleOffset;   // first sample time offset if timestamp < 0

    REFERENCE_TIME m_rtLastTimeStamp;
    REFERENCE_TIME m_rtLastDeliveredStartTime;
    REFERENCE_TIME m_rtLastDeliveredEndTime;
};

//
// Define our WMWriter
//
class CWMWriter : 
    public CBaseFilter, 
    public IMediaSeeking,
    public IAMFilterMiscFlags,
    public IFileSinkFilter2,
    public ISpecifyPropertyPages,
    public IConfigAsfWriter,
    public CPersistStream,
    public IWMHeaderInfo,
    public IServiceProvider
{
    friend class CWMWriterInputPin;

public:
    //
    // --- COM Stuff ---
    //
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
  
    // map getpin/getpincount for base enum of pins to owner
    // override this to return more specialised pin objects
    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);

    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    // override state changes to allow derived filters
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP EndOfStream();

    // tell filter this pin's done
    HRESULT EndOfStreamFromPin(int pinNum);
	
    // helper to ensure we're ready for Pause->Run
    HRESULT      CanPause();

    // IMediaSeeking. currently used for a progress bar (how much have
    // we written?)
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

    STDMETHODIMP ConvertTimeFormat(
        LONGLONG * pTarget, const GUID * pTargetFormat,
        LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions(
        LONGLONG * pCurrent,  DWORD CurrentFlags,
        LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

    //  IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IConfigAsfWriter interface
    //
    STDMETHODIMP ConfigureFilterUsingProfileId( DWORD dwProfileId );
    STDMETHODIMP GetCurrentProfileId( DWORD *pdwProfileId )
    {
        if( NULL == pdwProfileId )
            return E_POINTER;

        *pdwProfileId = 0;
        if( m_dwProfileId != PROFILE_ID_NOT_SET )
        {
            *pdwProfileId = m_dwProfileId;
             return S_OK;
        }
        else
            return E_FAIL;
    }
    STDMETHODIMP ConfigureFilterUsingProfileGuid( REFGUID guidProfile );
    STDMETHODIMP GetCurrentProfileGuid( GUID *pProfileGuid );

    STDMETHODIMP SetIndexMode( BOOL bIndexFile )
    {
        m_bIndexFile = bIndexFile;
        return S_OK;
    }

    STDMETHODIMP GetIndexMode( BOOL *pbIndexFile )
    {
        ASSERT( pbIndexFile );
        if( !pbIndexFile )
            return E_POINTER;

        *pbIndexFile = m_bIndexFile;
        return S_OK; 
    }

    //
    // Use these methods when a custom profile setup is preferred
    //
    STDMETHODIMP ConfigureFilterUsingProfile(IWMProfile * pWMProfile);
    STDMETHODIMP GetCurrentProfile( IWMProfile **ppProfile )
    {
        if( !ppProfile )
            return E_POINTER;

        *ppProfile = m_pWMProfile;
        if( m_pWMProfile )
        {
            // caller must release
            m_pWMProfile->AddRef();    
       	} else {
            // indicative of some unexpected error
            return E_FAIL;
       	}
   
        return S_OK;
    }

    //
    // CPersistStream
    //
    STDMETHODIMP GetClassID(CLSID *pClsid);
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    //
    // --- IFileSinkFilter interface ---
    //
    STDMETHODIMP SetFileName( LPCOLESTR pszFileName, const AM_MEDIA_TYPE *pmt );
    STDMETHODIMP SetMode( DWORD dwFlags );
    STDMETHODIMP GetCurFile( LPOLESTR * ppszFileName, AM_MEDIA_TYPE *pmt );
    STDMETHODIMP GetMode( DWORD *pdwFlags );

    //
    // --- ISpecifyPropertyPages ---
    //
    STDMETHODIMP GetPages(CAUUID *pPages);


    // IWMHeaderInfo
    STDMETHODIMP GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes );
    STDMETHODIMP GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength );
    STDMETHODIMP GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength );
    STDMETHODIMP SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength );
    STDMETHODIMP GetMarkerCount( WORD *pcMarkers );
    STDMETHODIMP GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime );
    STDMETHODIMP AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime );
    STDMETHODIMP RemoveMarker( WORD wIndex );
    STDMETHODIMP GetScriptCount( WORD *pcScripts );
    STDMETHODIMP GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime );
    STDMETHODIMP AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime );
    STDMETHODIMP RemoveScript( WORD wIndex );


    //
    // wmsdk helpers
    //

    // release current profile on deletion or reset
    void    DeleteProfile();
    void    DeletePins( BOOL bRecycle = FALSE ); // delete input pins (or recycle if TRUE)
    void    ReleaseWMWriter();
    HRESULT CreateWMWriter();   // create the wmsdk objects
    HRESULT LoadInternal();     // given a certification, open the wmsdk and configure the filter

    // tell wmsdk where to write
    HRESULT Open(); 
    void    Close();

    HRESULT      m_hrIndex;             // indexer object status
    BOOL         m_bIndexFile;          // indicates whether to index file
    BOOL         m_bResetFilename;      // does wmsdk need to be told the output filename?

public:
    // Construction / destruction
    CWMWriter(TCHAR *, LPUNKNOWN, CLSID clsid, HRESULT * );
    ~CWMWriter();

// Definitions
protected:
    CCritSec m_csFilter;                // filter wide lock
    
    // control streaming ?
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // chance to customize the Muxing process
    HRESULT Receive(
                CWMWriterInputPin * pPin, 
                IMediaSample * pSample, 
                REFERENCE_TIME *prtStart,
                REFERENCE_TIME *prtEnd );

    HRESULT CopyOurSampleToNSBuffer( INSSBuffer *pNSDest, IMediaSample *pSource );
    HRESULT IndexFile();

private:
    enum TimeFormat
    {
        FORMAT_TIME
    } m_TimeFormat;

    // cache file name
    OLECHAR*    m_wszFileName;

    BOOL        m_MediaTypeChanged;
    BOOL        m_fErrorSignaled;

    DWORD       m_dwOpenFlags;      // file open mode

    // wmsdk writer members
    IWMWriter*          m_pWMWriter;
    IWMWriterAdvanced*  m_pWMWriterAdvanced;
    IWMHeaderInfo*      m_pWMHI;
    IWMProfile*         m_pWMProfile;
    DWORD               m_dwProfileId; 
    GUID                m_guidProfile; 
    DWORD               m_fdwConfigMode; 
    IUnknown*           m_pUnkCert;

    // pin lists
    CGenericList<CWMWriterInputPin> m_lstInputPins;
    CGenericList<CWMWriterInputPin> m_lstRecycledPins;
  
    // number of inputs filter has currently
    int m_cInputs;           // count of total input pins
    int m_cAudioInputs;      // count of audio input pins
    int m_cVideoInputs;      // count of video input pins
    int m_cConnections;      // connected pins
    int m_cConnectedAudioPins;  // connected audio pins (need at least 1 to run, for now)
    int m_cActiveAudioStreams;  // # of audio streams which haven't receive EOS

    // create a pin 
    HRESULT AddNextPin(unsigned callingPin, DWORD dwPinType, IWMStreamConfig * pWMStreamConfig);

    CWMWriterInputPin * GetPinById( int numPin );

    HRESULT CompleteConnect( int numPin );
    HRESULT BreakConnect( int numPin );
    HRESULT PrepareForReconnect( PinList & lstReconnectPins ); // cache connected pins
    HRESULT ReconnectPins( PinList & lstReconnectPins );       // attempt to reconnect previously connected pins

    // we're a renderer
    STDMETHODIMP_(ULONG) GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_RENDERER; }

    // persistent data
    struct FilterPersistData
    {
        DWORD	dwcb;
        DWORD	dwProfileId;
        DWORD   fdwConfigMode;
        GUID    guidProfile;
    };

    // interleave stuff
    //
    BOOL HaveIDeliveredTooMuch( CWMWriterInputPin * pPin, REFERENCE_TIME Start );
};

#endif /* __WMWrite__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfwrite\proppage.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  proppage.cpp - property page for ASF writer filter
//
//--------------------------------------------------------------------------;


#include <streams.h>
#include <wmsdk.h>
#include <atlbase.h>

#include "asfwrite.h"
#include "resource.h"
#include "proppage.h"
#include <atlimpl.cpp>


//
// CreateInstance
//
CUnknown * WINAPI CWMWriterProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CWMWriterProperties(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


//
// CWMWriterProperties::Constructor
//
CWMWriterProperties::CWMWriterProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("CWMWriter Property Page"),pUnk,
        IDD_ASFWRITERPROPS, IDS_TITLE),
        m_pIConfigAsfWriter( NULL ),
        m_hwndProfileCB( 0 ),
        m_hwndIndexFileChkBox( 0 )
{
} 

CWMWriterProperties::~CWMWriterProperties()
{   
    ASSERT( NULL == m_pIConfigAsfWriter );
    if( m_pIConfigAsfWriter )
    {
        m_pIConfigAsfWriter->Release();
        m_pIConfigAsfWriter = NULL;
    }            

}

//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CWMWriterProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }

} // SetDirty


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR CWMWriterProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // get the hWnd of the list box
            m_hwndProfileCB       = GetDlgItem (hwnd, IDC_PROFILE_LIST) ;
            m_hwndIndexFileChkBox = GetDlgItem (hwnd, IDC_INDEX_FILE) ;
            
            FillProfileList();
            
            // init Index File check box
            BOOL bIndex = TRUE; 
            
            HRESULT hr = m_pIConfigAsfWriter->GetIndexMode( &bIndex );
            ASSERT( SUCCEEDED( hr ) );
           
            Button_SetCheck(m_hwndIndexFileChkBox, bIndex);

            return (LRESULT) 1;
        }

        case WM_COMMAND:
        {
            if( HIWORD(wParam) == CBN_SELCHANGE ||
                LOWORD(wParam) == IDC_INDEX_FILE )
            {
                SetDirty();
            }
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
HRESULT CWMWriterProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIConfigAsfWriter == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IConfigAsfWriter, (void **) &m_pIConfigAsfWriter);
    ASSERT( SUCCEEDED( hr ) );
    if (FAILED(hr))
    {
        return hr;
    }

    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release the private interface, release the upstream pin.
//
HRESULT CWMWriterProperties::OnDisconnect()
{
    if( m_pIConfigAsfWriter )
    {
        m_pIConfigAsfWriter->Release();
        m_pIConfigAsfWriter = NULL;
    }            
    return NOERROR;

} // OnDisconnect


//
// Activate
//
// We are being activated
//
HRESULT CWMWriterProperties::OnActivate()
{
    DWORD dwProfileId;
    
    GUID guidProfile;
    
    // get the current profile guid and try to find the index that matches it
    HRESULT hr = m_pIConfigAsfWriter->GetCurrentProfileGuid( &guidProfile );
    if( SUCCEEDED( hr ) )
    {
        // now try to find which system profile index is associated with this profile guid
        hr = GetProfileIndexFromGuid( &dwProfileId, guidProfile );
    }        
    
    if( SUCCEEDED( hr ) )
        SendMessage (m_hwndProfileCB, CB_SETCURSEL, dwProfileId, 0) ;
            
    return NOERROR;
    
} // Activate

//
// GetProfileIndexFromGuid
//
// given a profile guid attempt to the matching system profile and return its index
//
HRESULT CWMWriterProperties::GetProfileIndexFromGuid( DWORD *pdwProfileIndex, GUID guidProfile )
{
    ASSERT( pdwProfileIndex );
    
    USES_CONVERSION;
    
    if( !pdwProfileIndex ) 
        return E_POINTER;
            
    CComPtr <IWMProfileManager> pIWMProfileManager;
    WCHAR *wszProfileCurrent = NULL; 
    DWORD cProfiles = 0;
    *pdwProfileIndex = 0; // default in case we don't find it
    
    HRESULT hr = WMCreateProfileManager( &pIWMProfileManager );
    if( SUCCEEDED( hr ) )
    {   
        // only need to check new profiles since that's all we enumerate
        IWMProfileManager2*	pIPM2 = NULL;
        HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                    ( void ** )&pIPM2 );
        if( SUCCEEDED( hrInt ) )
        {
            pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
            pIPM2->Release();
        }
#ifdef DEBUG        
        else
        {
            // else if IWMProfileManager2 isn't supported I guess we assume that we're 
            // running on Apollo bits and the hack isn't needed?  
            DbgLog(( LOG_TRACE, 2, TEXT("CWMWriter::GetProfileIndexFromGuid QI for IWMProfileManager2 failed [0x%08lx]"), hrInt ));
        }        
#endif                
                     
        hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    }

    if( SUCCEEDED( hr ) )
    {        
        //    
        // load each system profile and compare guid's until we find a match
        //    
        BOOL bDone = FALSE;
        for (int i = 0; !bDone && i < (int)cProfiles; ++i)
        {
            CComPtr <IWMProfile> pIWMProfileTemp;
    
            hr = pIWMProfileManager->LoadSystemProfile( i, &pIWMProfileTemp );
            if( SUCCEEDED( hr ) )
            {   
                CComPtr <IWMProfile2> pWMProfile2;
                hr = pIWMProfileTemp->QueryInterface( IID_IWMProfile2, (void **) &pWMProfile2 );
                ASSERT( SUCCEEDED( hr ) );
                if( SUCCEEDED( hr ) )
                {              
                    GUID guidProfileTemp;
                    hr = pWMProfile2->GetProfileID( &guidProfileTemp );
                    if( SUCCEEDED( hr ) )
                    {
                        if( guidProfileTemp == guidProfile )
                        {
                            // we've found the profile we wanted, exit
                            *pdwProfileIndex = i;
                            bDone = TRUE;
                        }
                    }
                }
            }                                    
        }
    }
        
    return hr;
}

//
// OnApplyChanges
//
// Changes made should be kept.
//
HRESULT CWMWriterProperties::OnApplyChanges()
{
    ASSERT( m_pIConfigAsfWriter );
    HRESULT hr = S_OK;

    //
    // get the current selection of the profile? maybe...
    //
    int iIndex = (int) SendMessage(m_hwndProfileCB, CB_GETCURSEL, 0, 0) ;
    if( iIndex <= 0 )
        iIndex = 0 ;

    m_bDirty = FALSE;            // the page is now clean
    
    CComPtr <IWMProfileManager> pIWMProfileManager;

    hr = WMCreateProfileManager( &pIWMProfileManager );

    //
    // we only use 7_0 profiles
    //        
    IWMProfileManager2*	pIPM2 = NULL;
    HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                ( void ** )&pIPM2 );
    if( SUCCEEDED( hrInt ) )
    {
        pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
        pIPM2->Release();
    }
#ifdef DEBUG        
    else
    {
        // else if IWMProfileManager2 isn't supported I guess we assume that we're 
        // running on Apollo bits and the hack isn't needed?  
        DbgLog(( LOG_TRACE, 2, TEXT("CWMWriterProperties::OnApplyChanges QI for IWMProfileManager2 failed [0x%08lx]"), hrInt ));
    }        
#endif                
      
    // to validate the id passed in we could re-query for this or cache it the first time
    // re-querying for now
    DWORD cProfiles;
    hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    if( SUCCEEDED( hr ) )
    {
        ASSERT( (DWORD)iIndex < cProfiles );
        if( (DWORD)iIndex >= cProfiles )
        {
            DbgLog( ( LOG_TRACE
                  , 3
                  , TEXT("CWMWriter::ConfigureFilterUsingProfileId: ERROR - invalid profile id (%d)")
                  , iIndex ) );
                  
            hr = E_FAIL;   
        }
    }
    if( SUCCEEDED( hr ) )
    {   
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( iIndex, &pIWMProfile );
        if( SUCCEEDED( hr ) )
        {
            // now reconfigure filter
            hr = m_pIConfigAsfWriter->ConfigureFilterUsingProfile( pIWMProfile );
            ASSERT( SUCCEEDED( hr ) );
        }            
    }    
    
    // update the indexing mode
    int iState = (int) SendMessage( m_hwndIndexFileChkBox, BM_GETCHECK, 0, 0 ) ;
    m_pIConfigAsfWriter->SetIndexMode( iState == BST_CHECKED ? TRUE : FALSE );
    
    return hr;

} // OnApplyChanges


//
// FillProfileList
//
// Fill the list box with an enumeration of the media type that our
//
void CWMWriterProperties::FillProfileList()
{
    USES_CONVERSION;
    
    int wextent = 0 ;
    int Loop = 0 ;
    SIZE extent ;
    DWORD cProfiles = 0 ;
    
    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = WMCreateProfileManager( &pIWMProfileManager );
    if( FAILED( hr ) )
    {   
        return; // return error!
    }        
        
    // only show 7_0 profiles
    IWMProfileManager2*	pIPM2 = NULL;
    HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                ( void ** )&pIPM2 );
    if( SUCCEEDED( hrInt ) )
    {
        pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
        pIPM2->Release();
    }
#ifdef DEBUG        
    else
    {
        // else if IWMProfileManager2 isn't supported I guess we assume that we're 
        // running on Apollo bits and the hack isn't needed?  
        DbgLog(( LOG_TRACE, 2, TEXT("CWMWriterProperties::FillProfileList QI for IWMProfileManager2 failed [0x%08lx]"), hrInt ));
    }        
#endif                
        
    hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    if( FAILED( hr ) )
    {
        return;
    }
        
    //
    // get a dc for the control
    //
    HDC hdc = GetDC( m_hwndProfileCB );
    if( NULL == hdc )
        return;
        
    //    
    // now load the profile strings
    //    
    LRESULT ix;
    DWORD cchName, cchDescription;
    for (int i = 0; i < (int)cProfiles && SUCCEEDED( hr ) ; ++i)
	{
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( i, &pIWMProfile );
        if( FAILED( hr ) )
            break;
            
        hr = pIWMProfile->GetName( NULL, &cchName );
        if( FAILED( hr ) )
            break;
            
        WCHAR *wszProfile = new WCHAR[ cchName + 1 ]; 
        if( NULL == wszProfile )
            break;
            
        hr = pIWMProfile->GetName( wszProfile, &cchName );
        if( FAILED( hr ) )
            break;
        
        hr = pIWMProfile->GetDescription( NULL, &cchDescription );
        if( FAILED( hr ) )
            break;
            
        WCHAR *wszDescription = new WCHAR[ cchDescription + 1 ]; // + 1? assume so, check
        if( NULL == wszDescription )
            break;
            
        
        hr = pIWMProfile->GetDescription( wszDescription, &cchDescription );
        if( FAILED( hr ) )
            break;
        
        const WCHAR *cwszDivider = L" - ";
        
        WCHAR *wszDisplayString = new WCHAR[ cchDescription +
                                             cchName +
                                             wcslen(cwszDivider) + 1 ];
        if( NULL == wszDisplayString )
            break;
            
        wcscpy( wszDisplayString, wszProfile );
        wcscat( wszDisplayString, cwszDivider );
        wcscat( wszDisplayString, wszDescription );
                
        TCHAR *szDisplayString = W2T( wszDisplayString );

                
        //
        // get the extent of the string and save the max extent
        //
        GetTextExtentPoint( hdc, szDisplayString, _tcslen(szDisplayString), &extent ) ;
        if (extent.cx > wextent)
            wextent = extent.cx ;

        //
        // add the string to the list box.
        //
        ix = SendMessage (m_hwndProfileCB, CB_INSERTSTRING, i, (LPARAM)(LPCTSTR)szDisplayString) ;

        ASSERT (CB_ERR != ix);
        
        delete[] wszProfile;
        delete[] wszDescription;
        delete[] wszDisplayString;
    }
    SendMessage (m_hwndProfileCB, CB_SETHORIZONTALEXTENT, wextent, 0) ;
    SendMessage (m_hwndProfileCB, CB_SETCURSEL, 0, 0) ;

    ReleaseDC( m_hwndProfileCB, hdc );
    
} // FillProfileListBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfwrite\asfwrite.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


#include <streams.h>
#include <atlbase.h>
#include <wmsdk.h>
#include <wmsysprf.h>
#include "asfwrite.h"
#include "proppage.h"
#include <initguid.h>

// put a pin to sleep if it gets this far ahead of another
#define BLOCKINGSIZE (1*UNITS/2) 

//
// wake blocking pins up when the slower pin is within this range
// use a value that's something less than BLOCKINGSIZE to avoid oscillating back and
// forth too much
//
// NOTE!!! - the wmsdk requires that we don't let the video time get too close to
//           a blocking audio thread. Currently they'll start blocking video when it 
//           gets within at least 66ms of the audio, so make sure this is at least 
//           greater than that.
//
#define WAKEUP_RANGE ( BLOCKINGSIZE - 200 * (UNITS/MILLISECONDS) )


// setup data
const AMOVIESETUP_FILTER sudWMAsfWriter =
{ &CLSID_WMAsfWriter       // clsID
, L"WM ASF Writer"      // strName
, MERIT_UNLIKELY        // dwMerit
, 0                     // nPins
, NULL   };             // lpPin

// need a way to keep track of whether the filter asf profile was configured 
// using a profile id or guid (or neither, since an app can give us just us a profile too)
enum CONFIG_FLAGS {
    CONFIG_F_BY_GUID = 1,
    CONFIG_F_BY_ID 
};

#ifdef FILTER_DLL

/*****************************************************************************/
// COM Global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    { L"WM ASF Writer"
    , &CLSID_WMAsfWriter
    , CWMWriter::CreateInstance
    , NULL
    , &sudWMAsfWriter },
    
    { L"WM ASF Writer Properties"
    , &CLSID_WMAsfWriterProperties
    , CWMWriterProperties::CreateInstance }
    
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif


/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown * CWMWriter::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CWMWriter::CreateInstance")));
    return new CWMWriter(TEXT("WMWriter filter"), pUnk, CLSID_WMAsfWriter, phr);
}

// ------------------------------------------------------------------------
//
// NonDelegatingQueryInterface
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if(riid == IID_IMediaSeeking) {
        return GetInterface((IMediaSeeking *)this, ppv);
    } else if(riid == IID_IAMFilterMiscFlags) {
        return GetInterface((IAMFilterMiscFlags *)this, ppv);
    } else if(riid == IID_IFileSinkFilter2) {     
        return GetInterface((IFileSinkFilter2 *) this, ppv);
    } else if(riid == IID_IFileSinkFilter) {
        return GetInterface((IFileSinkFilter *) this, ppv);
    } else if (IID_ISpecifyPropertyPages == riid) {
        return GetInterface ((ISpecifyPropertyPages *) this, ppv);
    } else if (IID_IConfigAsfWriter == riid) {
        return GetInterface ((IConfigAsfWriter *) this, ppv);
    } else if (IID_IPersistStream == riid) {
        return GetInterface ((IPersistStream *) this, ppv);
    } else if (IID_IWMHeaderInfo == riid) {
        return GetInterface ((IWMHeaderInfo *) this, ppv);
    } else if (IID_IServiceProvider == riid) {
        return GetInterface ((IServiceProvider *) this, ppv);
    } else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

// ------------------------------------------------------------------------
//
// CWMWriter::CWMWriter
//
// ------------------------------------------------------------------------
CWMWriter::CWMWriter( 
    TCHAR     *pName,
    LPUNKNOWN pUnk,
    CLSID     clsid,
    HRESULT   *phr )
    : CBaseFilter(pName, pUnk, &m_csFilter, clsid)
    , m_TimeFormat(FORMAT_TIME)
    , m_fErrorSignaled(0)
    , m_cInputs( 0 )
    , m_cAudioInputs( 0 )
    , m_cVideoInputs( 0 )
    , m_cConnections( 0 )
    , m_cConnectedAudioPins( 0 )
    , m_cActiveAudioStreams( 0 )
    , m_wszFileName( 0 )
    , m_pWMWriter( NULL )
    , m_pWMWriterAdvanced( NULL )
    , m_pWMHI( NULL )
    , m_pWMProfile( NULL )
    , m_fdwConfigMode( CONFIG_F_BY_GUID ) // initialize using a hand-picked guid
    , m_guidProfile( WMProfile_V70_256Video ) // default 7.0 profile
    , m_lstRecycledPins(NAME("List of recycled input pins"))
    , m_lstInputPins(NAME("List of input pins"))
    , m_dwProfileId( PROFILE_ID_NOT_SET )
    , m_hrIndex( S_OK )
    , m_bIndexFile( TRUE )
    , CPersistStream(pUnk, phr)
    , m_pUnkCert( NULL )
    , m_dwOpenFlags( AM_FILE_OVERWRITE ) // only mode we support currently
    , m_bResetFilename( TRUE )
{
    ASSERT(phr != NULL);
    
    if( FAILED( *phr ) )
        return ;

    DbgLog((LOG_TRACE, 5, TEXT("CWMWriter: constructed")));
}

// ------------------------------------------------------------------------
//
// destructor
//
// ------------------------------------------------------------------------
CWMWriter::~CWMWriter()
{
    // delete the profile
    DeleteProfile();
        
    // close file (doesn't really do anything, but just in case it needs to later)
    Close();

    // free the writer
    ReleaseWMWriter();
    
    // free the certification object
    if( m_pUnkCert )
        m_pUnkCert->Release();
            
    // delete the pins
    DeletePins();

    // delete recycled pins
    CWMWriterInputPin * pwp;
    while ( pwp = m_lstRecycledPins.RemoveHead() )
    {
        delete pwp;
    }

    // sanity check that we've really cleaned up everything
    ASSERT( 0 == m_lstRecycledPins.GetCount() );
    ASSERT( 0 == m_lstInputPins.GetCount() );
    ASSERT( 0 == m_cAudioInputs );
    ASSERT( 0 == m_cVideoInputs );
    ASSERT( 0 == m_cInputs );
    
    delete[] m_wszFileName;
    m_wszFileName = 0;
}

void CWMWriter::DeletePins( BOOL bRecycle )
{
    CWMWriterInputPin * pwp;
    while ( pwp = m_lstInputPins.RemoveHead() )
    {
        m_cInputs--;
        ASSERT( !pwp->IsConnected() );
        if( PINTYPE_AUDIO == pwp->m_fdwPinType )
            m_cAudioInputs--;
        else if( PINTYPE_VIDEO == pwp->m_fdwPinType )
            m_cVideoInputs--;
        
        if( bRecycle )    
            m_lstRecycledPins.AddTail( pwp );
        else
            delete pwp;            
    }
}


void CWMWriter::ReleaseWMWriter()
{
    if( m_pWMHI )
    {
        m_pWMHI->Release();
        m_pWMHI = NULL;
    }    

    if( m_pWMWriterAdvanced )
    {
        m_pWMWriterAdvanced->Release();
        m_pWMWriterAdvanced = NULL;
    }    

    if( m_pWMWriter )
    {
        m_pWMWriter->Release();
        m_pWMWriter = NULL;
    }
}    

// ------------------------------------------------------------------------
//
// CreateWMWriter - create the WMWriter and advanced writer, release old
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::CreateWMWriter()
{
    ReleaseWMWriter(); // in case we already have one
        
    ASSERT( m_pUnkCert );
    if( !m_pUnkCert )
        return E_FAIL;
   

    HRESULT hr = S_OK;

    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateWriter( m_pUnkCert, &m_pWMWriter );
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 1,
                TEXT("CWMWriter::CreateWMWriter - WMCreateWriter failed ( hr = 0x%08lx)."), 
                hr));
            return hr;
        }
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::CreateWMWriter - Exception calling WMCreateWriter probably due to wmvcore.dll not present. Aborting. ")));
        return HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }

    //
    // also grab the advanced writer interface here as well in case we need
    // to send data directly to writer
    //
    hr = m_pWMWriter->QueryInterface( IID_IWMWriterAdvanced, (void **) &m_pWMWriterAdvanced );
    if( FAILED( hr ) )
    {
        DbgLog(( LOG_TRACE, 2,
            TEXT("CWMWriter::CreateWMWriter - Unable to create IWMWriterAdvanced(0x%08lx)."), 
            hr));
        return hr;
    }
     
    hr = m_pWMWriter->QueryInterface( IID_IWMHeaderInfo, (void **) &m_pWMHI );
    if( FAILED( hr ) )
    {
        DbgLog(( LOG_TRACE, 2,
            TEXT("CWMWriter::CreateWMWriter - Unable to create IWMHeaderInfo(0x%08lx)."), 
            hr));
        return hr;
    }
    
    hr = Open();
    if( FAILED( hr ) )
    {
        return hr;
    }
                
    ASSERT( m_pWMWriter );
    ASSERT( m_pWMWriterAdvanced );
    ASSERT( m_pWMHI );
    
    return hr;
}

// ------------------------------------------------------------------------
//
// Open - give the WMWriter the filename
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::Open()
{
    ASSERT( m_pWMWriter );
    
    HRESULT hr = S_OK;

    if( !m_pWMWriter )
    {    
        return E_FAIL;
    }
    
    if( !m_wszFileName )
    {    
        return S_OK;
    }
    
    // !!! support filenames like http://8080.asf to mean "use HTTP
    // with port 8080"

    // !!! will also need code to look for msbd:// once that's added to
    // Artemis
    if (
      ((m_wszFileName[0] == _T('H')) || (m_wszFileName[0] == _T('h'))) &&
      ((m_wszFileName[1] == _T('T')) || (m_wszFileName[1] == _T('t'))) &&
      ((m_wszFileName[2] == _T('T')) || (m_wszFileName[2] == _T('t'))) &&
      ((m_wszFileName[3] == _T('P')) || (m_wszFileName[3] == _T('p'))) &&
      (m_wszFileName[4] == _T(':')) &&
      (m_wszFileName[5] == _T('/')) &&
      (m_wszFileName[6] == _T('/'))
       )
    {
        DWORD dwPortNumber = atoiW(m_wszFileName + 7);

	
        if (dwPortNumber == 0)
            dwPortNumber = 80;
	
        IWMWriterNetworkSink*   pNetSink = NULL;
        
        // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
        __try 
        {
            hr = WMCreateWriterNetworkSink( &pNetSink );
            if( FAILED( hr ) )
            {
                DbgLog(( LOG_TRACE, 1,
                    TEXT("CWMWriter::Open - WMCreateWriterNetworkSink failed ( hr = 0x%08lx)."), 
                    hr));
                return hr;
            }
        }
        __except (  EXCEPTION_EXECUTE_HANDLER ) 
        {
            DbgLog(( LOG_TRACE, 1,
                TEXT("CWMWriter::Open - Exception calling WMCreateWriterNetworkSink probably due to wmvcore.dll not present. Aborting. ")));
            return HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
        }
            
        
        // !!! call SetNetworkProtocol?
	
        hr = pNetSink->Open( &dwPortNumber );
        if( SUCCEEDED( hr ) )
        {
            hr = m_pWMWriterAdvanced->AddSink( pNetSink );
            if( FAILED( hr ) )
            {
                DbgLog((LOG_TRACE, 1, TEXT("AddSink failed, hr = %x"), hr));
            }
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("Couldn't open the net sink, hr = %x"), hr ));
        }
        pNetSink->Release();
    } 
    else
    {
        // for files, we configure the wmsdk writer on Pause
        m_bResetFilename = TRUE;
    }    
    return hr;
}

// ------------------------------------------------------------------------
//
// Close - close file 
//
// ------------------------------------------------------------------------
void CWMWriter::Close( void )
{
    // note that Close doesn't delete m_wszFileName, SetFilename and destructor do
}

// ------------------------------------------------------------------------
//
// DeleteProfile 
//
// Delete profile and anything dependent on one, like the input 
// media type list for each pin.
//
// ------------------------------------------------------------------------
void CWMWriter::DeleteProfile()
{
    for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        if( pwp->m_pWMInputMediaProps )
        {
            pwp->m_pWMInputMediaProps->Release();
            pwp->m_pWMInputMediaProps = NULL;
        }
    }

    if( m_pWMProfile )
    {
        m_pWMProfile->Release();
        m_pWMProfile = NULL;
    }
}

// ------------------------------------------------------------------------
//
// AddNextPin - Create or recycle a pin
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::AddNextPin
(
    unsigned callingPin, 
    DWORD dwPinType, 
    IWMStreamConfig * pWMStreamConfig
)
{
    CAutoLock lock(&m_csFilter);
    HRESULT hr;
    WCHAR wsz[20];
    
    switch( dwPinType )
    {
        case PINTYPE_AUDIO:
            lstrcpyW(wsz, L"Audio Input 00");
            wsz[12] = (WCHAR)(L'0' + (m_cAudioInputs + 1) / 10);
            wsz[13] = (WCHAR)(L'0' + (m_cAudioInputs + 1) % 10);
            break;

        case PINTYPE_VIDEO:
            lstrcpyW(wsz, L"Video Input 00");
            wsz[12] = (WCHAR)(L'0' + (m_cVideoInputs + 1) / 10);
            wsz[13] = (WCHAR)(L'0' + (m_cVideoInputs + 1) % 10);
            break;
            
        default:
            ASSERT( FALSE ); 
            return E_FAIL;
    }            
        
    hr = S_OK;
    
    // see if there's a pin on the recycle or whether we need to create a new one
    CWMWriterInputPin * pwp = m_lstRecycledPins.RemoveHead();
    if( !pwp )
    {
        // oh well, we tried
        pwp = new CWMWriterInputPin(this, &hr, wsz, m_cInputs, dwPinType, pWMStreamConfig);
        if( NULL == pwp )
            return E_OUTOFMEMORY;
    }
    else
    {
        // for recycled pins update their internals (could just always require this, even for new pins?)
        pwp->Update( wsz, m_cInputs, dwPinType, pWMStreamConfig );
        DbgLog(( LOG_TRACE, 3,
                 TEXT("CWMWriter::AddNextPin recycling a pin")));
    }
    
    if(FAILED(hr))
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::AddNextPin create pin failed")));
    }
    else
    { 
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::added 1 pin")));
    
        m_lstInputPins.AddTail( pwp );
    
        m_cInputs++;
        if( PINTYPE_AUDIO == dwPinType )
            m_cAudioInputs++;
        else if( PINTYPE_VIDEO == dwPinType )
            m_cVideoInputs++;
    }

    ASSERT( m_cConnections <= m_cInputs );
    ASSERT( m_cConnections <= m_lstInputPins.GetCount() );

    return hr;
}

// ------------------------------------------------------------------------
//
// LoadInternal
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::LoadInternal()
{
    ASSERT( m_pUnkCert );
        
    HRESULT hr = S_OK;
    
    //
    // Do we already have a writer object? If so, use it and don't re-create one.
    //
    // This perf fix was made for MovieMaker to allow them to more quickly transition
    // from a preview graph to a record graph, by not releasing and recreating the writer 
    // on a graph rebuild.
    //
    if( !m_pWMWriter )
    {    
        // create the wmsdk writer objects
        hr = CreateWMWriter();
        if( SUCCEEDED( hr ) )
        {                    
            DbgLog((LOG_TRACE, 8, TEXT("CWMWriter::LoadInternal - created wmsdk writer object")));
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::LoadInternal failed to create wmsdk writer object(0x%08lx)"),hr));
        }                    
                
        //
        // now configure the filter...
        //
        // initialize to a default profile guid
        // user can override at any time by calling ConfigureFilterUsingProfile (or ProfileId)
        //
        if( SUCCEEDED( hr ) )
        {        
            ASSERT( m_pWMWriter );
            // first try our default or persisted profile
            hr = ConfigureFilterUsingProfileGuid( m_guidProfile );
            if( FAILED( hr ) )
            {
                // if that didn't work try a 4.0 (apollo) in case this is a legacy wmsdk platform
                hr = ConfigureFilterUsingProfileGuid( WMProfile_V40_250Video );
            }
        }
    }        
    return hr;
}

// ------------------------------------------------------------------------
// CBaseFilter methods
// ------------------------------------------------------------------------


// ------------------------------------------------------------------------
//
// JoinFilterGraph - need to be in graph to initialize keying mechanism
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if(FAILED( hr ) )
        return hr;
    
    if( !pGraph )
    {
        // if filter is removed from the graph, release the certification object.
        // we don't want to be run outside of a graph
        if( m_pUnkCert )
        {        
            m_pUnkCert->Release();
            m_pUnkCert = NULL;
        }            
    }    
    else
    {
        ASSERT( !m_pUnkCert );
        
        // unlock writer
        IObjectWithSite *pSite;
        hr = pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
        if (SUCCEEDED(hr)) 
        {
            IServiceProvider *pSP;
            hr = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
            pSite->Release();
            
            if (SUCCEEDED(hr)) 
            {
                // !!! should I pass IID_IWMWriter?  any purpose to letting app see the difference?
                hr = pSP->QueryService(IID_IWMReader, IID_IUnknown, (void **) &m_pUnkCert);
                pSP->Release();
                if (SUCCEEDED(hr)) 
                {
                    DbgLog((LOG_TRACE, 8, TEXT("CWMWriter::JoinFilterGraph got wmsdk certification (m_pUnkCert = 0x%08lx)"), m_pUnkCert));
                    hr = LoadInternal();
                    if( FAILED( hr ) )
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::JoinFilterGraph LoadInternal failed (0x%08lx)"), hr));
                    }                    
                }
                else
                {
                    DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::JoinFilterGraph QueryService for certification failed (0x%08lx)"), hr));
                    
                    // change error to certification error
                    hr = VFW_E_CERTIFICATION_FAILURE;
                }                
            }
            else
            {
                hr = VFW_E_CERTIFICATION_FAILURE;
            }                            
            if( FAILED( hr ) )
            {
                // up-oh, we failed to join, but the base class thinks we did, 
                // so we need to unjoin the base class
                CBaseFilter::JoinFilterGraph(NULL, NULL);
            }            
        }
        else
        {
            hr = VFW_E_CERTIFICATION_FAILURE;
        }            
    }
    return hr;
}


// ------------------------------------------------------------------------
//
// GetPin
//
// ------------------------------------------------------------------------
CBasePin* CWMWriter::GetPin(int n)
{
    if(n < (int)m_cInputs && n >= 0)
        return GetPinById( n );
    else
        return 0;
}

// ------------------------------------------------------------------------
//
// GetPinCount
//
// ------------------------------------------------------------------------
int CWMWriter::GetPinCount()
{
  return m_cInputs;
}

// ------------------------------------------------------------------------
//
// CompleteConnect
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::CompleteConnect( int numPin )
{
    CAutoLock lock(&m_csFilter);
    HRESULT hr = S_OK;
    
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriterInputPin::CompleteConnect") ));

    CWMWriterInputPin * pwp = GetPinById( numPin );
    if( NULL == pwp )
        return E_INVALIDARG;
       
    m_cConnections++;
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriter::CompleteConnect %i"), m_cConnections ));
    
    if( PINTYPE_AUDIO == pwp->m_fdwPinType )
        m_cConnectedAudioPins++;
        
    ASSERT(m_cConnections <= m_cInputs);
    ASSERT( m_cConnectedAudioPins < 2 );
    
    return hr;
}

// ------------------------------------------------------------------------
//
// GetPinById
//
// ------------------------------------------------------------------------
CWMWriterInputPin * CWMWriter::GetPinById( int numPin )
{
    POSITION Pos = m_lstInputPins.GetHeadPosition();
    CWMWriterInputPin * pwp;
    while( Pos != NULL ) 
    {
        pwp = m_lstInputPins.GetNext(Pos); 
        if( numPin == pwp->m_numPin )
            return pwp;
    }
    return NULL;
}

// ------------------------------------------------------------------------
//
// BreakConnect
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::BreakConnect( int numPin )
{
    CAutoLock lock(&m_csFilter);

    CWMWriterInputPin * pwp = GetPinById( numPin );
    if( NULL == pwp )
        return E_INVALIDARG;

    ASSERT(m_cConnections > 0);
    m_cConnections--;

    if( PINTYPE_AUDIO == pwp->m_fdwPinType )
        m_cConnectedAudioPins--;
    
    ASSERT( m_cConnectedAudioPins >= 0 );
        
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriter::BreakConnect %i"), m_cConnections ));
             
    return S_OK;
}

// ------------------------------------------------------------------------
//
// StartStreaming
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::StartStreaming()
{
    DbgLog((LOG_TRACE, 2, TEXT("CWMWriter::StartStreaming()")));
   
    // first check if we're writing live data
    BOOL bLive = FALSE;
        
    ASSERT( m_pGraph );
    IAMGraphStreams *pgs;
    HRESULT hr = m_pGraph->QueryInterface( IID_IAMGraphStreams, (void **) &pgs );
    if( SUCCEEDED( hr ) )
    {   
        // go through each of our input pins and see if any is being sourced by live data
        // stop when we find any live source
        for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos && !bLive ; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

            IAMPushSource *pPushSource = NULL;
            HRESULT hrInt = pgs->FindUpstreamInterface( pwp
                                                      , IID_IAMPushSource
                                                      , (void **) &pPushSource
                                                      , AM_INTF_SEARCH_OUTPUT_PIN ); 
            if( SUCCEEDED( hrInt ) )
            {
                ULONG ulPushSourceFlags = 0;
                hrInt = pPushSource->GetPushSourceFlags(&ulPushSourceFlags);
                ASSERT( SUCCEEDED( hrInt ) );
                if( SUCCEEDED( hrInt ) )
                {
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found push source (ulPushSourceFlags = 0x%08lx)")
                          , ulPushSourceFlags ) );
                    if( 0 == ( AM_PUSHSOURCECAPS_NOT_LIVE & ulPushSourceFlags ) )
                    {
                        // yes, this is live data
                        bLive = TRUE;
                    }                    
                }
                pPushSource->Release();         
            }
            else
            {
                // workaround for live graphs where the audio capture pin doesn't yet
                // support IAMPushSource
                IKsPropertySet * pKs;
                hrInt = pgs->FindUpstreamInterface( pwp
                                                  , IID_IKsPropertySet
                                                  , (void **) &pKs
                                                  , AM_INTF_SEARCH_OUTPUT_PIN ); // search output pins
                // this will only find the first one so beware!!
                if( SUCCEEDED( hrInt ) )             
                {   
                    GUID guidCategory;
                    DWORD dw;
                    hrInt = pKs->Get( AMPROPSETID_Pin
                                    , AMPROPERTY_PIN_CATEGORY
                                    , NULL
                                    , 0
                                    , &guidCategory
                                    , sizeof(GUID)
                                    , &dw );
                    if( SUCCEEDED( hrInt ) )
                    {
                        DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found IKsPropertySet pin. Checking pin category...") ) );
                        if( guidCategory == PIN_CATEGORY_CAPTURE )
                        {
                        
                            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found capture pin even though no IAMPushSource support") ) );
                            bLive = TRUE;
                        } 
                    }                    
                    pKs->Release();
                }                
            }
        }            
        pgs->Release();
    }            
    
    HRESULT hrInt2 = m_pWMWriterAdvanced->SetLiveSource( bLive );
    DbgLog( ( LOG_TRACE, 3, TEXT("CWMWriter:StartStreaming SetLiveSource( bLive = %2d )"), bLive ) );
    ASSERT( SUCCEEDED( hrInt2 ) );
   
    // 
    // set WMSDK sync tolerance to 0 to avoid sample blocking problems
    //
    hr = m_pWMWriterAdvanced->SetSyncTolerance( 0 );
    ASSERT( SUCCEEDED( hr ) );
#ifdef DEBUG    
    if( SUCCEEDED( hr ) )
    {    
        DWORD dwSyncTolInMS;
        hr = m_pWMWriterAdvanced->GetSyncTolerance( &dwSyncTolInMS );
        if( SUCCEEDED( hr ) )
        {
            DbgLog((LOG_TRACE, 5, TEXT("CWMWriter::Pause WMSDK writer's sync tolerance = %ldms"), dwSyncTolInMS));
        }
    }        
#endif        

    // finally, take a count of active audio streams before running
    m_cActiveAudioStreams = 0;
    for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos ; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        if( PINTYPE_AUDIO == pwp->m_fdwPinType )
        {
            m_cActiveAudioStreams++;
        }        
    }            
    
    // then the wmsdk writer should be ready to roll...
    hr = m_pWMWriter->BeginWriting();
    if( FAILED( hr ) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("CWMWriter::Pause WMWriter::BeginWriting failed [hr=0x%08lx]"), hr));
        return( hr );
    }
    
    return hr;
}

// ------------------------------------------------------------------------
//
// StopStreaming
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::StopStreaming()
{
    DbgLog((LOG_TRACE, 2, TEXT("CWMWriter::StopStreaming()")));
   
    // first wake all input streams, in case any are blocked
    for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos ; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        pwp->WakeMeUp();
    }            
     
    //
    // tell the wm writer we're done
    //
    HRESULT hr = m_pWMWriter->EndWriting();
    if( FAILED( hr ) )
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::StopStreaming IWMWriter::EndWriting failed [hr=0x%08lx]"), hr));
    }
    if( SUCCEEDED( hr ) && m_bIndexFile )
    {    
        hr = IndexFile();
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 2,
                     TEXT("CWMWriter::StopStream IWMWriter::IndexFile failed [hr=0x%08lx]"), hr));
        }        
    }
    m_cActiveAudioStreams = 0;
    return hr;
}

// ------------------------------------------------------------------------
//
// Receive
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::Receive( CWMWriterInputPin * pPin, IMediaSample * pSample, REFERENCE_TIME *prtStart, REFERENCE_TIME *prtEnd )
{
    HRESULT hr = S_OK;

    if(m_State != State_Stopped)
    {
        if(!m_fErrorSignaled)
        {
            hr = S_OK;

            if( 0 == m_cActiveAudioStreams )
            {
                ASSERT( PINTYPE_AUDIO != pPin->m_fdwPinType );
                
                //
                // !Important: If there's no active audio stream make sure we don't deliver a video 
                // (or non-audio) sample with a sample time later than the end time of the last audio 
                // sample passed to the wmsdk, since they may never release it!!
                //
                REFERENCE_TIME rtLastAudioTimeExtent = 0;
                for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
                {   
                    CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

                    if( pwp == pPin ) // skip ourself
                        continue;
                        
                    if( pwp->m_fdwPinType == PINTYPE_AUDIO )
                    {
                        ASSERT( pwp->m_fEOSReceived );
                        
                        // this audio stream ended
                        if( pwp->m_rtLastDeliveredEndTime > rtLastAudioTimeExtent )
                            rtLastAudioTimeExtent = pwp->m_rtLastDeliveredEndTime;
                            
                    }
                }
                if( *prtStart > rtLastAudioTimeExtent )    
                {
                    //
                    // this sample starts later than the end time of the last audio queued. 
                    // don't send it!
                    //
                    DbgLog((LOG_TRACE, 5,
                            TEXT("CWMWriter::Receive WARNING: Rejecting a non-audio sample starting beyond the last audio time (last audio time %dms)! Forcing EOS"),
                            (DWORD)(rtLastAudioTimeExtent / 10000 ) ) );
                    //                            
                    // force EOS for this pin
                    //
                    if( !pPin->m_fEOSReceived )
                        pPin->EndOfStream();                            
    
                    return S_OK;                            
                }                                    
            }   
            
            INSSBuffer * pNSSBuffer = NULL;
            if( pPin->m_bCompressedMode )
            {
                //
                // the compressed input case - have the WMSDK writer do a copy
                // deadlock problems may result otherwise. 
                // for example, we've noticed uncompressed audio needs 3 seconds of
                // buffering before the writer gets moving
                //
                // this block has the WMSDK allocate a new INSSBuffer sample that we 
                // copy our sample into
                //
                BYTE * pbBuffer;
                DWORD  cbBuffer;
        
                hr = m_pWMWriter->AllocateSample( pSample->GetSize(), &pNSSBuffer );
                if( SUCCEEDED( hr ) )
                {
                    hr = CopyOurSampleToNSBuffer( pNSSBuffer, pSample );
                }
            }
            else
            {
                //
                // the uncompressed input case - avoid unnecessary copy
                // this block takes the IMediaSample that we've been given and wraps
                // with our private class to make it look like an INSSBuffer, thus
                // avoiding the extra copy
                //
                CWMSample *pWMSample = new CWMSample(NAME("WMSample"),pSample) ;
                if( pWMSample )
                {
                    hr = pWMSample->QueryInterface( IID_INSSBuffer, (void **) &pNSSBuffer );
                    ASSERT( SUCCEEDED( hr ) );
                }
            }

            if( pNSSBuffer && SUCCEEDED( hr ) )
            {
                // prepare sample flags
                DWORD dwSampleFlags = 0;
                if( S_OK == pSample->IsDiscontinuity() )
                {
                    dwSampleFlags |= WM_SF_DISCONTINUITY;
                }                
                if( S_OK == pSample->IsSyncPoint() )
                {
                    dwSampleFlags |= WM_SF_CLEANPOINT;
                }                
                
                if( pPin->m_bCompressedMode )
                {
                    ASSERT( m_pWMWriterAdvanced );
                    DbgLog((LOG_TRACE, 15,
                            TEXT("CWMWriter::Receive calling WriteStreamSample (adjusted rtStart = %dms)"),
                            (LONG) (*prtStart / 10000) ) );
                    // for now assume each input pin maps to 1 output stream (which are 1-based)
                    hr = m_pWMWriterAdvanced->WriteStreamSample(  (WORD) (pPin->m_numPin+1), // assume 1-1 in-out mapping
                                                                  *prtStart,     // presentation time
                                                                  0xFFFFFFFF,    // not yet supported by wmdsdk
                                                                  0xFFFFFFFF,    // ditto
                                                                  dwSampleFlags,
                                                                  pNSSBuffer );  // the data
                    DbgLog((LOG_TRACE, 15,
                            TEXT("CWMWriter::Receive back from WriteStreamSample") ) );
                }
                else
                {                    
                    DbgLog((LOG_TRACE, 15,
                            TEXT("CWMWriter::Receive calling WriteSample (adjusted rtStart = %dms)"),
                            (LONG) (*prtStart / 10000) ) );
                    hr = m_pWMWriter->WriteSample(  pPin->m_numPin,// input number
                                                    *prtStart,    // presentation time
                                                    dwSampleFlags,
                                                    pNSSBuffer );  // the data
                    DbgLog((LOG_TRACE, 15, 
                            TEXT("CWMWriter::Receive back from WriteSample") ) );
                }                            
                pNSSBuffer->Release(); 
                pPin->m_rtLastDeliveredStartTime = *prtStart;
                pPin->m_rtLastDeliveredEndTime = *prtEnd; // not necessarily known, but guaranteed >= prtStart
                
                if(hr != S_OK)
                {
                    DbgLog((LOG_TRACE, 1,
                            TEXT("CWMWriter::Receive IWMWriter::WriteSample returned error %08x on pin %d. refusing everything"),
                            hr, pPin->m_numStream));
                    m_fErrorSignaled = TRUE;
                    if(FAILED(hr))
                    {
                        NotifyEvent(EC_ERRORABORT, hr, 0);
                    }
                }
#if 0
#ifdef DEBUG  // !!! experimental debug code to see if we're dropping samples while writing,
                // !!! especially to the net
                else
                {
                    WM_WRITER_STATISTICS stats;

                    HRESULT hrStat = m_pWMWriterAdvanced->GetStatistics(0, &stats);  // stream-specific samples?

                    if (SUCCEEDED(hrStat)) {
                        DbgLog((LOG_TIMING, 2, TEXT("Dropped samples: %d / %d, Sample rate = %d"),
                        (DWORD) stats.qwDroppedSampleCount, (DWORD) stats.qwSampleCount,
                        stats.dwCurrentSampleRate));

                    }
                }
#endif
#endif
            }
            else
            {            
                m_fErrorSignaled = TRUE;
                NotifyEvent(EC_ERRORABORT, hr, 0);
            }
        }
        else
        {
            DbgLog((LOG_TRACE, 1,
                    TEXT("CWMWriter:: Error signaled or output not connected %d"),
                    pPin->m_numStream));
            hr = S_FALSE;
        }
    }
    else
    {
        DbgLog((LOG_TRACE,1, TEXT("CWMWriter: Receive when stopped!")));
        hr = VFW_E_NOT_RUNNING;
    }
    return NOERROR;
}

HRESULT CWMWriter::CopyOurSampleToNSBuffer(
    INSSBuffer     *pNSDest,
    IMediaSample   *pSource)
{

    if( !pNSDest || !pSource )
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // Copy the sample data
    BYTE *pSourceBuffer, *pDestBuffer;
    long lDataLength = pSource->GetActualDataLength();
    DWORD dwDestSize;
    
    HRESULT hr = pNSDest->GetBufferAndLength(&pDestBuffer, &dwDestSize);
    ASSERT( SUCCEEDED( hr ) );
    if( SUCCEEDED( hr ) )
    {
        // make sure it fits!
        ASSERT(dwDestSize >= (DWORD)lDataLength);
        if( dwDestSize < (DWORD) lDataLength )
        {
            // uh oh... could try and copy as much as would fit, but probably pointless
            DbgLog((LOG_TRACE, 1, "ERROR: CWMWriter::CopyOurSampleToNSBuffer dwDestSize < lDataLength (returning %08lx)", hr));
            hr = E_UNEXPECTED;
        }
        else
        {
            pSource->GetPointer(&pSourceBuffer);

            CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lDataLength );

            // set the data length
            HRESULT hrInt = pNSDest->SetLength( lDataLength );
            ASSERT( SUCCEEDED( hrInt ) ); // shouldn't fail right?
        }
    }
    return hr;
}

// ------------------------------------------------------------------------
//
// IndexFile
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::IndexFile()
{
    DbgLog((LOG_TRACE, 15, "CWMWriter::IndexFile()"));
    CWMWriterIndexerCallback * pCallback = new CWMWriterIndexerCallback(this);
    if( !pCallback )
        return E_OUTOFMEMORY;
        
    pCallback->AddRef();        
    
    IWMIndexer *pWMIndexer;
    
    HRESULT hr = S_OK;
    
    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateIndexer( &pWMIndexer );
        if( FAILED( hr ) )
        {        
            DbgLog((LOG_TRACE, 1, "ERROR: CWMWriter::IndexFile WMCreateIndexer failed (0x%08lx)", hr));
            return hr;
        }        
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::IndexFile - Exception calling WMCreateIndexer probably due to wmvcore.dll not present. Aborting. ")));
        return HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }
    
    //
    // create indexing event
    //
    HANDLE hIndexEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( !hIndexEvent )
    {
        DbgLog((LOG_TRACE, 1, TEXT("ERROR - failed to create index event")));
        hr = E_OUTOFMEMORY;
    }
    else
    {        
        DbgLog((LOG_TRACE, 2, TEXT("Starting file indexing")));
        hr = pWMIndexer->StartIndexing(m_wszFileName, pCallback, &hIndexEvent);
        if (SUCCEEDED(hr)) 
        {
            m_hrIndex = S_OK;
            DWORD dw = WaitForSingleObject( hIndexEvent, INFINITE );
            hr = m_hrIndex;
            DbgLog((LOG_TRACE, 2, TEXT("Finished indexing, callback returned 0x%08lx"), hr));
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::IndexFile StartIndexing failed (0x%08lx)"), hr));
        }        
        CloseHandle( hIndexEvent );     
    }
    
    pWMIndexer->Release();
    if( pCallback )
    {
        pCallback->Release();
    }
    return hr;
}

// ------------------------------------------------------------------------
//
// Stop
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::Stop()
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::Stop(...)")));
    CAutoLock lock(&m_csFilter);


    FILTER_STATE state = m_State;

    HRESULT hr = CBaseFilter::Stop();
    if(FAILED(hr))
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::Stop failed.")));
        return hr;
    }

    if(state != State_Stopped ) 
    {
        // close and clean up the file data
        hr = StopStreaming();
        if (FAILED(hr)) {
            return hr;
        }
    }        

    if(m_fErrorSignaled)
        return S_OK;

    return hr;
}

// ------------------------------------------------------------------------
//
// Pause
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::Pause()
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::Pause(...)")));
    CAutoLock l(&m_csFilter);

    if( m_State == State_Stopped )
    {
        m_fErrorSignaled = TRUE;

        // make sure we've been given a filename
        HRESULT hr = CanPause();
        if(FAILED(hr))
        {
            return hr;
        }

        hr = StartStreaming();
        if(FAILED(hr))
        {
            DbgLog(( LOG_TRACE, 2,
                TEXT("CWMWriter::Pause: StartStreaming failed.")));
            return hr;
        }
        
        m_fErrorSignaled = FALSE;
    }

    return CBaseFilter::Pause();
}

// ------------------------------------------------------------------------
//
// CanPause
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::CanPause()
{
    HRESULT hr = S_OK;
    
    // can't run without a filename and a wmsdk writer
    if( !m_pWMWriter || 0 == m_wszFileName )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }
    
    // also, we currently don't support running if all our inputs aren't connected
    ASSERT( m_cConnections == m_lstInputPins.GetCount() );
    if( m_cConnections != m_lstInputPins.GetCount() )
        return E_FAIL;    
    
    if( !m_pWMProfile )
    {
        // need to have a valid profile
        return E_FAIL;
    }
    
    //    
    // delay the SetOutputFilename until we pause from stop, since the wmsdk writer
    // will overwrite the file on this call
    //
    if( m_bResetFilename )
    {    
        hr = m_pWMWriter->SetOutputFilename( m_wszFileName );
        if( SUCCEEDED( hr ) )
        {
            m_bResetFilename = FALSE;
        }        
        else
        {   
            DbgLog(( LOG_TRACE, 2, TEXT("IWMWriter::SetOutputFilename failed [0x%08lx]"), hr ));
            return hr;
        }    
    }        
    
#if DEBUG
    for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        ASSERT( pwp->IsConnected() );
    }

#endif

    return S_OK;
}

// ------------------------------------------------------------------------
//
// Run
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::Run(...)")));
    CAutoLock l(&m_csFilter);
    
    // Is there any change needed
    if (m_State == State_Running) {
        return NOERROR;
    }
    
    return CBaseFilter::Run(tStart);
}

// ------------------------------------------------------------------------
//
// EndOfStream
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::EndOfStream()
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter: EOS")));
    CAutoLock lock(&m_csFilter);

    if(!m_fErrorSignaled)
    {
        if(m_State == State_Running)
        {
            NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
        }
        else if(m_State == State_Paused)
        {
            // m_fEosSignaled set, so will be signaled on run
        }
        else
        {
            ASSERT(m_State == State_Stopped);
            // we could have stopped already; ignore EOS
        }
    }
    return S_OK;
}

// ------------------------------------------------------------------------
//
// EndOfStreamFromPin
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::EndOfStreamFromPin(int pinNum)
{
    CAutoLock lock(&m_csFilter);

    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::EndOfStreamFromPin EOS pin %d"), pinNum));

    int cEos = 0;
    for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

        // wake up the other streams since this one is done
        //
        pwp->WakeMeUp();

        if( pwp->m_fEOSReceived ) 
        {
            cEos++;
        }            
            
        if( pwp->m_numPin == pinNum && PINTYPE_AUDIO == pwp->m_fdwPinType )
        {
            //
            // decrement number of active audio streams
            //
            ASSERT( m_cActiveAudioStreams > 0 );
            m_cActiveAudioStreams--;
            DbgLog((LOG_TRACE, 3, TEXT("CWMWriter - active audio streams %d"), m_cActiveAudioStreams));
        }            
    }
    
    if(cEos == m_cConnections)
    {
        EndOfStream(); // tell filter to send EC_COMPLETE        
        DbgLog((LOG_TRACE, 3, TEXT("asf: final eos")));
    }

    return hr;
}


// ------------------------------------------------------------------------
// IConfigAsfWriter
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
//
// ConfigureFilterUsingProfile
//
// Set the writer to use the passed in profile
//
// ------------------------------------------------------------------------

STDMETHODIMP CWMWriter::ConfigureFilterUsingProfile( IWMProfile * pWMProfile )
{
    CAutoLock lock(&m_csFilter);

    ASSERT( pWMProfile );
    if( !pWMProfile )
        return E_POINTER;
   
    if( !m_pWMWriter )
        return E_FAIL;
         
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    PinList lstReconnectPins(NAME("List of reconnect pins"));
    
    // if we're currently connected, remember connections before disconnecting
    PrepareForReconnect( lstReconnectPins );
    
    // move all input pins to the recycle list and reset the pin count, so that
    // we effectively hide them from view
    ASSERT( m_cInputs == m_lstInputPins.GetCount() );
    
    // clean up any previous one, profile must be deleted before deleting pins!
    DeleteProfile();
    
    DeletePins( TRUE ); // Recycle deleted pins
    
    ASSERT( 0 == m_cInputs );
    ASSERT( 0 == m_lstInputPins.GetCount() );

    // first configure wmsdk for this profile
    ASSERT( m_pWMWriter );
    
    HRESULT hr = m_pWMWriter->SetProfile( pWMProfile );
    if( SUCCEEDED( hr ) )
    {   
        // save off the guid for this profile in case filter gets persisted
        IWMProfile2* pWMProfile2;
        HRESULT hrInt = pWMProfile->QueryInterface( IID_IWMProfile2, (void **) &pWMProfile2 );
        ASSERT( SUCCEEDED( hrInt ) );
        if( SUCCEEDED( hrInt ) )
        {
            hrInt = pWMProfile2->GetProfileID( &m_guidProfile );
            if( FAILED( hrInt ) )
            {
                m_guidProfile = GUID_NULL;
            }
            else
            {
                // make sure filter profile config is set to config by guid mode
                m_fdwConfigMode = CONFIG_F_BY_GUID;
            }   
                                 
            pWMProfile2->Release();        
        }        
    
        m_pWMProfile = pWMProfile; 
        m_pWMProfile->AddRef(); // keep a hold on it
        
        DWORD cInputs;
        hr = m_pWMWriter->GetInputCount( &cInputs );
        if( SUCCEEDED( hr ) )
        { 
            // check output stream count as well
            // for now if the 2 are equal than assume there's a 1-to-1
            // correspondence between streams and set input types based
            // on the output stream types
            DWORD cStreams;
            hr = pWMProfile->GetStreamCount( &cStreams );
            if( SUCCEEDED( hr ) )
            { 
                if( cStreams == cInputs )
                {
                    // use output streams to configure inputs
                    for( int i = 0; i < (int)cStreams; i++ )
                    {            
                        CComPtr<IWMStreamConfig> pConfig;
                        hr = pWMProfile->GetStream( i, &pConfig );
                        if( SUCCEEDED( hr ) )
                        {
                            CLSID MajorType;
                            hr = pConfig->GetStreamType( &MajorType );
                            if( SUCCEEDED( hr ) )
                            {
                        
                                if( MEDIATYPE_Audio == MajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need an audio pin") ) );
                                    hr = AddNextPin(0, PINTYPE_AUDIO, pConfig);
                                    if(FAILED( hr ) )
                                        break;
                                }                            
                                else if( MEDIATYPE_Video == MajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need a video pin") ) );
                                    hr = AddNextPin(0, PINTYPE_VIDEO, pConfig);
                                    if(FAILED( hr ) )
                                        break;
                                }
                            }                        
                        }
                    }
                }
                else
                {
                    // use input info to configure inputs
                    for( int i = 0; i < (int)cInputs; i++ )
                    {            
                        CComPtr<IWMInputMediaProps> pInputMediaProps;
                        
                        // use the major type of the first media type enumerated for this 
                        // pin's creation (used for naming pin)
                        hr = m_pWMWriter->GetInputFormat( i
                                                        , 0 // we want the 0-th type
                                                        , (IWMInputMediaProps ** )&pInputMediaProps );
                        if( SUCCEEDED( hr ) )
                        {
                            GUID guidMajorType;
                            hr = pInputMediaProps->GetType( &guidMajorType );
                            ASSERT( SUCCEEDED( hr ) );
                            if( SUCCEEDED( hr ) )
                            {
                                if( MEDIATYPE_Audio == guidMajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need an audio pin") ) );
                                    
                                    // use NULL for output stream's config info, since we 
                                    // don't know which output stream this input flows to
                                    hr = AddNextPin(0, PINTYPE_AUDIO, NULL); 
                                    if(FAILED( hr ) )
                                        break;
                                }                            
                                else if( MEDIATYPE_Video == guidMajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need a video pin") ) );
                                    
                                    // use NULL for output stream's config info, since we 
                                    // don't know which output stream this input flows to
                                    hr = AddNextPin(0, PINTYPE_VIDEO, NULL);
                                    if(FAILED( hr ) )
                                        break;
                                }
                            }                        
                        }
                        else
                        {
                            // don't continue
                            break;
                        }                            
                    }

                }
            }
        }
    }
    if( SUCCEEDED( hr ) )
    {
        // attempt to restore previous connections
        ReconnectPins( lstReconnectPins );
    }    
    
    // free any remaining reconnect pins
    IPin * pPin;
    while ( pPin = lstReconnectPins.RemoveHead() )
    {
        pPin->Release();
    }

    NotifyEvent( EC_GRAPH_CHANGED, 0, 0 ); 
    return hr;
}

// ------------------------------------------------------------------------
//
// ReconnectPins
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::ReconnectPins( PinList & lstReconnectPins )
{
    HRESULT hr = S_OK;
    for ( POSITION Pos1 = lstReconnectPins.GetHeadPosition(); Pos1 ;  )
    {
        POSITION Pos1Orig = Pos1;
        IPin * pReconnectPin = lstReconnectPins.GetNext( Pos1 );
        
        for (POSITION Pos2 = m_lstInputPins.GetHeadPosition(); Pos2; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos2 );
            
            hr = pReconnectPin->Connect( pwp, NULL );
            if( SUCCEEDED( hr ) )
            {
                // pull it off the reconnect list and release our hold on it
                pReconnectPin->Release();
                lstReconnectPins.Remove( Pos1Orig );
                
                break;
            }                
        }
    }
    // what to return for partial connections?    
    return S_OK;
}    

// ------------------------------------------------------------------------
//
// PreparePinsForReconnect
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::PrepareForReconnect( PinList & lstReconnectPins )
{
    if( m_cConnections )
    {
        ASSERT( 0 == lstReconnectPins.GetCount() );
     
        // at least one pin is connected, so remember connected pins before disconnecting
        for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            IPin * pPeer;
            HRESULT hr = pwp->ConnectedTo( &pPeer );
            if( SUCCEEDED( hr ) )
            {
                // Note that we want to make sure the pin doesn't go away after adding it to the list
                // Since it already has a refcount on it from the ConnectedTo call, we just don't 
                // call Release on the pin
                
                lstReconnectPins.AddTail( pPeer );
                
                pwp->Disconnect();
                pPeer->Disconnect();
                
                // Don't call Release, per comment above!                
                //pPeer->Release(); 
            }
        }
    }
    return S_OK;
}    

// ------------------------------------------------------------------------
//
// ConfigureFilterUsingProfile
//
// Set the writer to use a system profile id
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::ConfigureFilterUsingProfileId( DWORD dwProfileId )
{
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    CAutoLock lock(&m_csFilter);

    // if this is a different profile than the current remove all input pins
            
    // now create input pins according to this profile

    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = S_OK;
    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateProfileManager( &pIWMProfileManager );
        
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::CreateWMWriter - Exception calling WMCreateProfileManager probably due to wmvcore.dll not present. Aborting. ")));
        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }
   
    //
    // for now (DX8 and Millennium) this method assumes legacy 4_0 version profiles
    //        
#ifdef  USE_7_0_PROFILES_IN_CONFIGBYID
    if( SUCCEEDED( hr ) )
    {    
        // this code is provide for internally building the filter to instead have this method use 7_0 profiles
        IWMProfileManager2*	pIPM2 = NULL;
        HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                                            ( void ** )&pIPM2 );
        if( SUCCEEDED( hrInt ) )
        {
            pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
            pIPM2->Release();
        }
#ifdef DEBUG        
        else
        {
            ASSERT( SUCCEEDED( hrInt ) );
        
            // else if IWMProfileManager2 isn't supported I guess we assume that we're 
            // running on Apollo bits and the hack isn't needed?  
            DbgLog(( LOG_TRACE, 2, TEXT("CWMWriter::ConfigureFilterUsingProfileId failed [0x%08lx]"), hrInt ));
        }        
#endif                
    }
#endif      

    if( SUCCEEDED( hr ) )
    {   
        // to validate the id passed in we could re-query for this or cache it the first time
        // re-querying for now
        DWORD cProfiles;
        hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
        if( SUCCEEDED( hr ) )
        {
            if( dwProfileId >= cProfiles )
            {
                DbgLog( ( LOG_TRACE
                      , 3
                      , TEXT("CWMWriter::ConfigureFilterUsingProfileId: ERROR - invalid profile id (%d)")
                      , dwProfileId ) );
                      
                hr = E_FAIL;   
            }
        }
    }
    if( SUCCEEDED( hr ) )
    {                    
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( dwProfileId, &pIWMProfile );
        if( SUCCEEDED( hr ) )
        {
            hr = ConfigureFilterUsingProfile( pIWMProfile );
        }            
    }    

    if( SUCCEEDED( hr ) )
    {    
        m_dwProfileId = dwProfileId;
        m_fdwConfigMode = CONFIG_F_BY_ID;
    }        
    else        
    {    
        m_dwProfileId = PROFILE_ID_NOT_SET;
    }    
    return hr;
}


// ------------------------------------------------------------------------
//
// ConfigureFilterUsingGuid
//
// Set the writer to use a wm profile guid
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::ConfigureFilterUsingProfileGuid( REFGUID guidProfile )
{
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    CAutoLock lock(&m_csFilter);

    // if this is a different profile than the current remove all input pins
            
    // now create input pins according to this profile

    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = S_OK;

    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateProfileManager( &pIWMProfileManager );
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::CreateWMWriter - Exception calling WMCreateProfileManager probably due to wmvcore.dll not present. Aborting. (0x%08lx)")));
        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }
    
    if( SUCCEEDED( hr ) )
    {                    
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadProfileByID( guidProfile, &pIWMProfile );
        if( SUCCEEDED( hr ) )
        {
            hr = ConfigureFilterUsingProfile( pIWMProfile );
        }            
#ifdef DEBUG
        else
        {
            DbgLog(( LOG_TRACE, 2,
                     TEXT("CWMWriter::CreateWMWriter - IWMProfileManager::LoadProfileByID failed (0x%08lx)"), 
                     hr));
        }        
#endif        
    }    
    // hmm... what do we do here?? now we've picked a profile directly, so we don't
    // know whether/which profile id it matches.
    
    // then try just not setting it    
    m_dwProfileId = PROFILE_ID_NOT_SET;
    if( SUCCEEDED( hr ) )
    {    
        m_fdwConfigMode = CONFIG_F_BY_GUID;
        m_guidProfile = guidProfile;
        
    }    
    return hr;
}

// ------------------------------------------------------------------------
//
// GetCurrentProfileGuid
//
// Get the current profile guid
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::GetCurrentProfileGuid( GUID *pProfileGuid )
{
    if( NULL == pProfileGuid )
    {
        return E_POINTER;
    }

    *pProfileGuid = m_guidProfile;

    return S_OK;
}    


// ------------------------------------------------------------------------
// IFileSinkFilter

STDMETHODIMP CWMWriter::SetFileName 
(
    LPCOLESTR wszFileName,
    const AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(wszFileName, E_POINTER);
    CAutoLock lock(&m_csFilter);

    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    HRESULT hr = S_OK;

    // do we need to release current WMWriter object to change name?
    Close(); // when to open??

    long cLetters = lstrlenW(wszFileName);
    // rely on the wmsdk for this type of validation?
    //if(cLetters > MAX_PATH)
    //    return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

    m_wszFileName = new WCHAR[cLetters + 1];
    if(m_wszFileName == 0)
        return E_OUTOFMEMORY;

    lstrcpyW(m_wszFileName, wszFileName);

    if(pmt)
    {
        ASSERT( FALSE ); // we don't support this
    }

    if( !m_pGraph )
        return S_OK; // can't do much more until we've been added to the graph

    if( !m_pWMWriter )
    {
        // need to create writer and configure output filename
        hr = LoadInternal();
    }
    else
    {        
        // else just configure wmsdk writer for output filename
        hr = Open();
    }        
    if( FAILED( hr ) )
    {   
        DbgLog(( LOG_TRACE, 2, TEXT("CWMWriter::Open file failed [0x%08lx]"), hr ));
        return hr;
    }    

    return S_OK;
}

STDMETHODIMP CWMWriter::SetMode( DWORD dwFlags )
{
    // refuse flags we don't know 
    if(dwFlags & ~AM_FILE_OVERWRITE)
    {
        return E_INVALIDARG;
    }
    
    CAutoLock lock(&m_csFilter);

    HRESULT hr = S_OK;

    if(m_State == State_Stopped)
    {
        m_dwOpenFlags = dwFlags;
    }
    else
    {
        hr = VFW_E_WRONG_STATE;
    }

    return hr;
}

STDMETHODIMP CWMWriter::GetCurFile
(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(ppszFileName, E_POINTER);

    *ppszFileName = NULL;
    if(m_wszFileName!=NULL)
    {
        *ppszFileName = (LPOLESTR)QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW(m_wszFileName)));
        if (*ppszFileName != NULL)
            lstrcpyW(*ppszFileName, m_wszFileName);
        else
            return E_OUTOFMEMORY;
    }

    if(pmt)
    {
        // not really supported, but fill in something I guess
        pmt->majortype = GUID_NULL;
        pmt->subtype = GUID_NULL;
    }

    return S_OK;
}

STDMETHODIMP CWMWriter::GetMode( DWORD *pdwFlags )
{
    CheckPointer(pdwFlags, E_POINTER);
    *pdwFlags = m_dwOpenFlags;
    return S_OK;
}



//-----------------------------------------------------------------------------
//                  ISpecifyPropertyPages implementation
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// GetPages
//
// Returns the clsid's of the property pages we support
//
//-----------------------------------------------------------------------------
STDMETHODIMP CWMWriter::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_WMAsfWriterProperties;

    return NOERROR;

} // GetPages

//-----------------------------------------------------------------------------
//
// CPersistStream
//
//-----------------------------------------------------------------------------
STDMETHODIMP CWMWriter::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

HRESULT CWMWriter::WriteToStream(IStream *pStream)
{
    FilterPersistData fpd;
    fpd.dwcb = sizeof(fpd);
    HRESULT hr = S_OK;
    
    fpd.guidProfile   = m_guidProfile;
    fpd.fdwConfigMode = m_fdwConfigMode;
        
    if( PROFILE_ID_NOT_SET == m_dwProfileId )
    {
        fpd.dwProfileId = 0;
    }
    else
    {
        fpd.dwProfileId = m_dwProfileId;
    }    
        
    hr = pStream->Write(&fpd, sizeof(fpd), 0);

    return hr;
}

HRESULT CWMWriter::ReadFromStream(IStream *pStream)
{
    FilterPersistData fpd;
    HRESULT hr = S_OK;

    hr = pStream->Read(&fpd, sizeof(fpd), 0);
    if(FAILED(hr))
        return hr;

    if(fpd.dwcb != sizeof(fpd))
        return VFW_E_INVALID_FILE_VERSION;

    if( CONFIG_F_BY_GUID == fpd.fdwConfigMode )
        hr = ConfigureFilterUsingProfileGuid( fpd.guidProfile );
    else
        hr = ConfigureFilterUsingProfileId( fpd.dwProfileId );
    
    return hr;
}

int CWMWriter::SizeMax()
{
    return sizeof(FilterPersistData);
}

//-----------------------------------------------------------------------------
// IMediaSeeking
//-----------------------------------------------------------------------------

HRESULT CWMWriter::IsFormatSupported(const GUID * pFormat)
{
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CWMWriter::QueryPreferredFormat(GUID *pFormat)
{
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CWMWriter::SetTimeFormat(const GUID * pFormat)
{
    HRESULT hr = S_OK;
    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
        m_TimeFormat = FORMAT_TIME;
    
    return hr;
}

HRESULT CWMWriter::IsUsingTimeFormat(const GUID * pFormat)
{
    HRESULT hr = S_OK;
    if (m_TimeFormat == FORMAT_TIME && *pFormat == TIME_FORMAT_MEDIA_TIME) {
        ;
    } else {
        hr = S_FALSE;
    }
    
    return hr;
}

HRESULT CWMWriter::GetTimeFormat(GUID *pFormat)
{
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    
    return S_OK;
}

HRESULT CWMWriter::GetDuration(LONGLONG *pDuration)
{
    HRESULT hr = S_OK;
    CAutoLock lock(&m_csFilter);
    
    if(m_TimeFormat == FORMAT_TIME)
    {
        *pDuration = 0;
        for( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            if(pwp->IsConnected())
            {
                IPin *pPinUpstream;
                if(pwp->ConnectedTo(&pPinUpstream) == S_OK)
                {
                    IMediaSeeking *pIms;
                    hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
                    if(SUCCEEDED(hr))
                    {
                        LONGLONG dur = 0;
                        hr = pIms->GetDuration(&dur);
                        
                        if(SUCCEEDED(hr))
                            *pDuration = max(dur, *pDuration);
                        
                        pIms->Release();
                    }
                    
                    pPinUpstream->Release();
                }
            }            
            if(FAILED(hr))
                break;
        }
    } 
    else 
    {
        *pDuration = 0;
        return E_UNEXPECTED;
    }
            
    return hr;
}


HRESULT CWMWriter::GetStopPosition(LONGLONG *pStop)
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    
    REFERENCE_TIME rtLastTime = 0;    
    if( FORMAT_TIME == m_TimeFormat )
    {    
        for( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            if( pwp->m_rtLastTimeStamp > rtLastTime )
            {
                rtLastTime = pwp->m_rtLastTimeStamp;
            }
        }
        *pCurrent = rtLastTime;
    }        
    
    return S_OK;
}

HRESULT CWMWriter::GetCapabilities( DWORD * pCapabilities )
{
    CAutoLock lock(&m_csFilter);
    *pCapabilities = 0;
    
    // for the time format, we can get a duration by asking the upstream
    // filters
    if(m_TimeFormat == FORMAT_TIME)
    {
        *pCapabilities |= AM_SEEKING_CanGetDuration;
        for( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            if(pwp->IsConnected())
            {
                IPin *pPinUpstream;
                if(pwp->ConnectedTo(&pPinUpstream) == S_OK)
                {
                    IMediaSeeking *pIms;
                    HRESULT hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
                    if(SUCCEEDED(hr))
                    {
                        hr = pIms->CheckCapabilities(pCapabilities);
                        pIms->Release();
                    }
                    
                    pPinUpstream->Release();
                }
            }            
        }
    }
    
    // we always know the current position
    *pCapabilities |= AM_SEEKING_CanGetCurrentPos ;
    
    return S_OK;
}

HRESULT CWMWriter::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCapabilities &= dwMask;
    
    return S_OK;
}


HRESULT CWMWriter::ConvertTimeFormat(
                                     LONGLONG * pTarget, const GUID * pTargetFormat,
                                     LONGLONG    Source, const GUID * pSourceFormat )
{
    return E_NOTIMPL;
}


HRESULT CWMWriter::SetPositions(
                                LONGLONG * pCurrent,  DWORD CurrentFlags,
                                LONGLONG * pStop,  DWORD StopFlags )
{
    // not yet implemented. this might be how we append to a file. and
    // how we write less than an entire file.
    return E_NOTIMPL;
}


HRESULT CWMWriter::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hr;
    //if( pCurrent )
    //    *pCurrent = m_LastVidTime;
    
    hr = GetDuration( pStop);
    
    return hr;
}

HRESULT CWMWriter::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::SetRate( double dRate)
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::GetRate( double * pdRate)
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::GetPreroll(LONGLONG *pPreroll)
{
    return E_NOTIMPL;
}



// IWMHeaderInfo forwarded to WMSDK 
STDMETHODIMP CWMWriter::GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeCount(wStreamNum, pcAttributes);
}


STDMETHODIMP CWMWriter::GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByIndex(wIndex, pwStreamNum, pwszName,
                                        pcchNameLen, pType, pValue, pcbLength);
}


STDMETHODIMP CWMWriter::GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByName(pwStreamNum, pszName, pType,
                                       pValue, pcbLength);
}


STDMETHODIMP CWMWriter::SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->SetAttribute(wStreamNum, pszName, Type, pValue, cbLength);
}


STDMETHODIMP CWMWriter::GetMarkerCount( WORD *pcMarkers )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarkerCount(pcMarkers);
}


STDMETHODIMP CWMWriter::GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarker(wIndex, pwszMarkerName, pcchMarkerNameLen, pcnsMarkerTime);
}


STDMETHODIMP CWMWriter::AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddMarker(pwszMarkerName, cnsMarkerTime);
}

STDMETHODIMP CWMWriter::RemoveMarker( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveMarker(wIndex);
}

STDMETHODIMP CWMWriter::GetScriptCount( WORD *pcScripts )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScriptCount(pcScripts);
}

STDMETHODIMP CWMWriter::GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScript(wIndex, pwszType, pcchTypeLen, pwszCommand,
                              pcchCommandLen, pcnsScriptTime);
}

STDMETHODIMP CWMWriter::AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddScript(pwszType, pwszCommand, cnsScriptTime);
}

STDMETHODIMP CWMWriter::RemoveScript( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveScript(wIndex);
}

// if the current time of the pin is 1/2 second greater than any other pin
// then wake the slower pin up. This happens for all slower pins, not just
// one. This algorithm is self-regulating. If you have more than 2 pins,
// the faster one will always slow down for any of the slower pins. Then,
// slower pins catch up and the fastest of THOSE pins will then stall out.
// This will keep things approximately interleaved within a second...
//
BOOL CWMWriter::HaveIDeliveredTooMuch( CWMWriterInputPin * pPin, REFERENCE_TIME Start )
{
    // !!! this routine isn't threadsafe on the pin's m_rtLastTimeStamp, does it
    // matter? I can't tell. I think it's all okay.

    DbgLog((LOG_TRACE, 3, TEXT("Pin %ld, Have I delivered too much?"), pPin->m_numPin ));

#ifdef DEBUG
    REFERENCE_TIME MaxLag = 0;
#endif

    BOOL bSleep = FALSE;
    
    for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

        // if this pin has received an EOS, then don't look at it
        //
        if( pwp->m_fEOSReceived )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %ld is at EOS"), pwp->m_numPin ));
            continue;
        }

        // if we're ourself, then don't look at us
        //
        if( pPin == pwp )
        {
            continue;
        }

#ifdef DEBUG
        if( Start - pwp->m_rtLastTimeStamp > MaxLag )
        {
            MaxLag = Start - pwp->m_rtLastTimeStamp;
        }
#endif
        //
        // IF we've caught up to this pin (within our blocking range) AND if no other
        // pins need it to stay blocked (i.e. its m_rtLastTimeStamp is less than
        // BLOCKINGSIZE + every other pin's time stamp)
        // THEN wake this pin up
        //
        BOOL bWakeUpPin = FALSE;
        
        //
        // Unblock other pin whenever we're just within blocking range
        //
        // Remember the wmsdk depends on audio for clocking and this design requires 
        // that the audio also be somewhat ahead of video, so we can't leave an audio 
        // pin blocked until the video catches up, because they'll cause us to deadlock.
        //
        if( Start >= pwp->m_rtLastDeliveredEndTime - WAKEUP_RANGE )
        {
            bWakeUpPin = TRUE;
            
            //
            // we've caught up to this pin (within our block range)
            // now make sure it doesn't need to stay blocked for another pin
            //
            for ( POSITION Pos2 = m_lstInputPins.GetHeadPosition(); Pos2; )
            {
                CWMWriterInputPin * const pwp2 = m_lstInputPins.GetNext( Pos2 );
                if( pwp2->m_fEOSReceived )
                {
                    continue;
                }
                //
                // skip ourself and the pin we'd like to wake up
                //
                if( pwp2 == pPin || pwp2 == pwp )
                {
                    continue;
                }
            
                DbgLog( ( LOG_TRACE
                      , 15
                      , TEXT("Checking with other pins whether its ok to wake up pin %ld. Is it ok with you pin %ld?")
                      , pwp->m_numPin
                      , pwp2->m_numPin ) );
                
                if( pwp->m_rtLastTimeStamp > BLOCKINGSIZE + pwp2->m_rtLastDeliveredStartTime )
                {
                    //
                    // this pin is too far ahead of some other pin, so don't wake it up
                    // no need to continue this loop
                    //
                    bWakeUpPin = FALSE;
                    DbgLog( ( LOG_TRACE
                          , 15
                          , TEXT("No, waking pin %ld up isn't ok with pin %ld.")
                          , pwp->m_numPin
                          , pwp2->m_numPin ) );
                    break;
                }
            }
        }            
        
        if( bWakeUpPin )
        {
            //
            // we've caught up to this pin and so have all other pins 
            // so wake it up in case it was sleeping
            //
            pwp->WakeMeUp();
        }
        
        //        
        // now see if we're too far ahead of this pin and we need to rest to let others catch up
        //
        if( Start > pwp->m_rtLastDeliveredEndTime + BLOCKINGSIZE )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %ld is lagging by %ldms, YES"), pwp->m_numPin, long( ( Start - pwp->m_rtLastTimeStamp ) / 10000 ) ));

            // yep, we're over
            //
            bSleep = TRUE;
        }
    }

#ifdef DEBUG
    if( !bSleep )
    {    
        DbgLog((LOG_TRACE, 3, TEXT("No, I haven't, max lag = %ld"), long( MaxLag / 10000 ) ));
    }        
#endif

    return bSleep;
}

//
// IServiceProvider
//
STDMETHODIMP CWMWriter::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (NULL == ppv) 
    {
        return E_POINTER;
    }
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;
    
    if (IID_IWMWriterAdvanced2 == guidService) 
    {
        if( m_pWMWriter )
        {
            //
            // For this interface we pass out the writer's interface directly. 
            //
            // In general, we'd like most calls to pass through our filter, to keep the user from 
            // overriding our control on the writer. However, for the 2 methods on the IWMWriterAdvanced2 
            // interface its less of an issue. 
            // However the user could still get at the writer's IWMWriterAdvanced interface pointer from this 
            // interface, so this exposes that risk.
            //
            hr = m_pWMWriter->QueryInterface( riid, (void **) ppv );
        }
        else
        {
            hr = E_FAIL;
        }            
    }
    return hr;
}


//
// CWMWriterIndexerCallback
//
HRESULT CWMWriterIndexerCallback::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IWMStatusCallback) 
    {
	    return GetInterface(static_cast<IWMStatusCallback *>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid,ppv);
}


STDMETHODIMP CWMWriterIndexerCallback::OnStatus(WMT_STATUS Status, 
                     HRESULT hr,
                     WMT_ATTR_DATATYPE dwType,
                     BYTE *pValue,
                     void *pvContext )
{
    switch (Status) {
        case WMT_INDEX_PROGRESS:
            ASSERT(dwType == WMT_TYPE_DWORD);
            DbgLog((LOG_TRACE, 15, TEXT("Indexing: OnStatus(WMT_INDEX_PROGRESS - %d%% done)"), *(DWORD *) pValue));
            m_pFilter->NotifyEvent( EC_WMT_INDEX_EVENT, Status, *(DWORD *)pValue );
            break;

        case WMT_OPENED:
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_OPENED)")));
            break;

        case WMT_STARTED:
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_STARTED)")));
            m_pFilter->NotifyEvent( EC_WMT_INDEX_EVENT, Status, 0 );
            break;

        case WMT_STOPPED:
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_STOPPED)")));
            // don't set event until we get closed?
            break;

        case WMT_CLOSED:
            // how to handle? should we wait for this after the stop??
            ASSERT( pvContext );
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_CLOSED) (*pvContext = 0x%08lx)"), *(HANDLE *)pvContext));
            m_pFilter->m_hrIndex = hr;
            SetEvent( *(HANDLE *)pvContext );
            m_pFilter->NotifyEvent( EC_WMT_INDEX_EVENT, Status, 0 );
            break;

        case WMT_ERROR:
            DbgLog((LOG_TRACE, 1, TEXT("ERROR Indexing: OnStatus(WMT_ERROR) - 0x%lx"), hr));
            m_pFilter->m_hrIndex = hr; // pointless really
            // still need to wait for a WMT_CLOSED message, 
            // which means we'll lose the failure as well
            break;
            
        default:
            DbgLog((LOG_TRACE, 1, TEXT("Indexing: OnStatus() Unknown callback! (Status = %ld)"), (DWORD)Status));
            break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfwrite\proppage.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// proppage.h
//----------------------------------------------------------------------------

// {D9F9C262-6231-11d3-8B1D-00C04FB6BD3D}
EXTERN_GUID(CLSID_WMAsfWriterProperties, 
0xd9f9c262, 0x6231, 0x11d3, 0x8b, 0x1d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d);

class CProfileSelectDlg;

class CWMWriterProperties : public CBasePropertyPage
{

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    DECLARE_IUNKNOWN;

private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();
    HRESULT GetProfileIndexFromGuid( DWORD *pdwProfileIndex, GUID guidProfile );

    void SetDirty();
    void FillProfileList();

    CWMWriterProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CWMWriterProperties();

    HWND        m_hwndProfileCB ;       // Handle of the profile combo box
    HWND        m_hwndIndexFileChkBox ; // Handle of the index filter check box

    IConfigAsfWriter * m_pIConfigAsfWriter;

};  // class WMWriterProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfwrite\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// resource ids 
//
#define ASFWRITER_BASE                  100

// dialog
#define IDD_ASFWRITERPROPS              ASFWRITER_BASE

// strings
#define IDS_TITLE                       ASFWRITER_BASE+1

// controls
#define IDC_PROFILE_LIST                ASFWRITER_BASE+2
#define IDC_INDEX_FILE                  ASFWRITER_BASE+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\asfwrite\inpin.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <wmsdk.h>
#include "asfwrite.h"

#ifdef RECONNECT_FOR_POS_YUV
#include <ks.h>
#include <ksproxy.h>
#endif

BOOL IsCompressed( DWORD biCompression );
BOOL IsAmTypeEqualWmType( AM_MEDIA_TYPE * pmt, WM_MEDIA_TYPE * pwmt);
BOOL IsPackedYUVType( BOOL bNegBiHeight, AM_MEDIA_TYPE * pmt );

#ifdef OFFER_INPUT_TYPES
void CopyWmTypeToAmType( AM_MEDIA_TYPE * pmt,  WM_MEDIA_TYPE * pwmt);
#endif

#ifdef DEBUG
void LogMediaType( AM_MEDIA_TYPE * pmt );
#endif

// ------------------------------------------------------------------------
// 
// CWMWriterInputPin class constructor
//
// ------------------------------------------------------------------------
CWMWriterInputPin::CWMWriterInputPin(
                            CWMWriter *pWMWriter,
                            HRESULT * phr,
                            LPCWSTR pName,
                            int numPin,
                            DWORD dwPinType,
                            IWMStreamConfig * pWMStreamConfig)
    : CBaseInputPin(NAME("AsfWriter Input"), pWMWriter, &pWMWriter->m_csFilter, phr, pName)
    , m_pFilter(pWMWriter)
    , m_numPin( numPin )
    , m_numStream( numPin+1 ) // output stream nums are 1-based, for now assume
                              // a 1-to-1 relationship between input pins and asf streams
    , m_bConnected( FALSE )
    , m_fEOSReceived( FALSE )
    , m_pWMInputMediaProps( NULL )
    , m_fdwPinType( dwPinType )
    , m_pWMStreamConfig( pWMStreamConfig ) // not add ref'd currently
    , m_lpInputMediaPropsArray( NULL )
    , m_cInputMediaTypes( 0 )
    , m_bCompressedMode( FALSE )
    , m_rtFirstSampleOffset( 0 )
    , m_cSample( 0 )
    , m_rtLastTimeStamp( 0 )
    , m_rtLastDeliveredStartTime( 0 )
    , m_rtLastDeliveredEndTime( 0 )
    , m_bNeverSleep( FALSE )
{
    DbgLog((LOG_TRACE,4,TEXT("CWMWriterInputPin::CWMWriterInputPin")));

    // create the sync object for interleaving
    //
    m_hWakeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( !m_hWakeEvent )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    *phr = BuildInputTypeList(); // build input media type list based on current profile
}

// ------------------------------------------------------------------------
//
// Update - initialize a recycled pin
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::Update
(   
    LPCWSTR pName, 
    int numPin, 
    DWORD dwPinType, 
    IWMStreamConfig * pWMStreamConfig 
)
{
    HRESULT hr = S_OK;
    m_numPin = numPin;
    m_numStream = numPin + 1;
    m_fdwPinType = dwPinType;
    m_pWMStreamConfig = pWMStreamConfig; // no ref count currently
    m_bCompressedMode = FALSE;
    
    // need to update the name
    if (pName) {
        delete[] m_pName;    
        
        DWORD nameLen = lstrlenW(pName)+1;
        m_pName = new WCHAR[nameLen];
        if (m_pName) {
            CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
        }
    }
    hr = BuildInputTypeList(); // build list of input types we'll offer
    return hr;
}

// ------------------------------------------------------------------------
//
// destructor
//
// ------------------------------------------------------------------------
CWMWriterInputPin::~CWMWriterInputPin()
{
    DbgLog((LOG_TRACE,4,TEXT("CWMWriterInputPin::~CWMWriterInputPin")));
    if( m_lpInputMediaPropsArray )
    {    
        for( int i = 0; i < (int) m_cInputMediaTypes; ++i )
        {
            // release our type list
            m_lpInputMediaPropsArray[i]->Release();
            m_lpInputMediaPropsArray[i] = NULL;
        }
        QzTaskMemFree( m_lpInputMediaPropsArray );
    }    
    m_cInputMediaTypes = 0;

    if( m_hWakeEvent ) 
    {
        CloseHandle( m_hWakeEvent );
        m_hWakeEvent = NULL;
    }
}


// ------------------------------------------------------------------------
//
// NonDelegatingQueryInterface
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriterInputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if(riid == IID_IAMStreamConfig) {
        // supported for compressed input mode
        return GetInterface((IAMStreamConfig *)this, ppv);
    } else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

// ------------------------------------------------------------------------
//
// BuildInputTypeList
// 
// Build a list of media types using wmsdk enumeration of input streams. First 
// element of list will be the same as the output type for this pin, to allow
// for supporting compressed stream writing.
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::BuildInputTypeList()
{
    if( m_lpInputMediaPropsArray )
    {    
        // release any previous type list
        for( int i = 0; i < (int) m_cInputMediaTypes; ++i )
        {
            // release our type list
            m_lpInputMediaPropsArray[i]->Release();
            m_lpInputMediaPropsArray[i] = NULL;
        }
        
        // release any previous prop array
        QzTaskMemFree( m_lpInputMediaPropsArray );
    }
    
    // now rebuild list
    m_cInputMediaTypes = 0; 

    // first ask wmsdk for count of supported input types
    DWORD cTypesNotIncCompressed;
    HRESULT hr = m_pFilter->m_pWMWriter->GetInputFormatCount( m_numPin, &cTypesNotIncCompressed );
    if(SUCCEEDED( hr ) )
    {
        ASSERT( cTypesNotIncCompressed > 0 );
        
        DWORD cTotalTypes = cTypesNotIncCompressed;
        BOOL bIncludeCompressedType = FALSE;        
        if( m_pWMStreamConfig )
        {        
            // its not a mrb profile so now add one for the compressed input which matches 
            // this pin's output
            bIncludeCompressedType = TRUE;
            cTotalTypes++; // add one for compressed input
        }
        
        DbgLog((LOG_TRACE,4,TEXT("CWMWriterInputPin::BuildInputTypeList input types for pin %d (supports %d types, not including compressed type)"),
                m_numPin,
                cTypesNotIncCompressed ) );
                
        m_lpInputMediaPropsArray = (IWMMediaProps ** ) QzTaskMemAlloc(cTotalTypes * sizeof(IWMMediaProps *) );
        if( !m_lpInputMediaPropsArray )
            return E_OUTOFMEMORY;
            
        if( bIncludeCompressedType )
        {        
            // now put the output type into position 0
            hr = m_pWMStreamConfig->QueryInterface( IID_IWMMediaProps, (void **) &m_lpInputMediaPropsArray[0] );
            ASSERT( SUCCEEDED( hr ) );
            if( SUCCEEDED( hr ) )
            {
                m_cInputMediaTypes++;
            }
            else
            {
                DbgLog((LOG_TRACE,3,TEXT("CWMWriterInputPin::BuildInputTypeList QI for IWMWMediaProps failed for pin %d (hr = 0x%08lx"),
                        m_numPin,
                        hr ) );
            }            
        }
                    
        for( int i = 0; i < (int) cTypesNotIncCompressed; ++i )
        {
            hr = m_pFilter->m_pWMWriter->GetInputFormat( m_numPin
                                                       , i
                                                       , (IWMInputMediaProps ** )&m_lpInputMediaPropsArray[m_cInputMediaTypes] );
            ASSERT( SUCCEEDED( hr ) );
            if( FAILED( hr ) )
            {
                DbgLog((LOG_TRACE,3,TEXT("CWMWriterInputPin::BuildInputTypeList GetInputFormat failed for pin %d, index %d (hr = 0x%08lx"),
                        m_numPin,
                        i,                        
                        hr ) );
                break;
            }
            else
            {
#ifdef DEBUG            
                //
                //  dbglog enumerated input types
                //
                DWORD cbType = 0;
                HRESULT hr2 =  m_lpInputMediaPropsArray[m_cInputMediaTypes]->GetMediaType( NULL, &cbType );
                if( SUCCEEDED( hr2 ) || ASF_E_BUFFERTOOSMALL == hr2 )
                {        
                    WM_MEDIA_TYPE *pwmt = (WM_MEDIA_TYPE * ) new BYTE[cbType];
                    if( pwmt )
                    {                    
                        hr2 =  m_lpInputMediaPropsArray[m_cInputMediaTypes]->GetMediaType( pwmt, &cbType );
                        if( SUCCEEDED( hr2 ) )
                        {
                            DbgLog((LOG_TRACE, 8
                                  , TEXT("WMWriter::BuildInputTypeList WMSDK media type #%i (stream %d)") 
                                  , i, m_numPin ) );
                            LogMediaType( ( AM_MEDIA_TYPE * )pwmt );                                 
                    
                        }                                                       
                    }
                    delete []pwmt;              
                }  
#endif            
                m_cInputMediaTypes++; // only increment after we've debug logged
            }
        }
    }
    else
    {
        DbgLog((LOG_TRACE,3,TEXT("CWMWriterInputPin::BuildInputTypeList GetInputFormatCount failed for pin %d (hr = 0x%08lx"),
                m_numPin,
                hr ) );
    }    
    
    return hr;    
}

// ------------------------------------------------------------------------
//
// SetMediaType
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::SetMediaType(const CMediaType *pmt)
{
    // Set the base class media type (should always succeed)
    HRESULT hr = CBasePin::SetMediaType(pmt);
    if( SUCCEEDED( hr ) )
    {       
        hr = m_pFilter->m_pWMWriter->GetInputProps( m_numPin
                                                  , &m_pWMInputMediaProps );
        ASSERT( SUCCEEDED( hr ) );
        if( FAILED( hr ) )
        {            
            DbgLog((LOG_TRACE
                   , 1
                   , TEXT("WMWriter::SetMediaType GetInputProps failed for input %d [hr = 0x%08lx]") 
                   , m_numPin
                   , hr));
            return hr;                   
        }
        
        if( IsPackedYUVType( TRUE, &m_mt ) ) // look for negative biHeight
        {   
            // wmsdk codecs can't handle SetInputProps with negative height (wmsdk bug 6656)
            CMediaType cmt( m_mt );
            HEADER(cmt.Format())->biHeight = -HEADER(m_mt.pbFormat)->biHeight;
        
            // now set the input type to the wmsdk writer
            hr = m_pWMInputMediaProps->SetMediaType( (WM_MEDIA_TYPE *) &cmt );
        }
        else
        {        
            // now set the input type to the wmsdk writer
            hr = m_pWMInputMediaProps->SetMediaType( (WM_MEDIA_TYPE *) pmt );
        }
        ASSERT( SUCCEEDED( hr ) );
        if( FAILED( hr ) )
        {            
            DbgLog((LOG_TRACE
                  , 1
                  , TEXT("CWMWriterInputPin::SetMediaType SetMediaType failed for input %d [hr = 0x%08lx]") 
                  , m_numPin
                  , hr));
            return hr;                  
        }
        if( !m_bCompressedMode )
        {
            hr = m_pFilter->m_pWMWriter->SetInputProps( m_numPin
                                                      , m_pWMInputMediaProps );
                                                                      
            ASSERT( SUCCEEDED( hr ) );
            if( FAILED( hr ) )
            {            
                DbgLog((LOG_TRACE
                      , 1
                      , TEXT("CWMWriterInputPin::SetMediaType SetInputProps failed for input %d [hr = 0x%08lx]")
                      , m_numPin
                      , hr));
            }
        }
    }
    return hr;
}

//
//  Disconnect 
//
STDMETHODIMP CWMWriterInputPin::Disconnect()
{
    HRESULT hr = CBaseInputPin::Disconnect();
    
    return hr;
}


HRESULT CWMWriterInputPin::CompleteConnect(IPin *pReceivePin)
{
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriterInputPin::CompleteConnect") ));
             
#ifdef RECONNECT_FOR_POS_YUV
    //
    // #ifdef'ing out to just get out of the YUV +biHeight reconnect business for now 
    //
    //
    // if we're using a packed YUV type which doesn't have a negative biHeight then make a last attempt
    // to reset the current type to use a negative height, to avoid mpeg4 encoder and possible decoder
    // problems with the vertical orientation. Currently mpeg4 and Duck decoders have this bug.
    //
    if( IsPackedYUVType( FALSE, &m_mt ) ) // look for positive biHeight
    { 
        BOOL bIsUpstreamFilterKs = FALSE;
        if( pReceivePin )
        {
            //
            // HACK!
            // oops, this workaround breaks kswdmcap filters like
            // the bt829 video capture filter because it has a bug which
            // causes it to succeed QueryAccept but fail the reconnection 
            // so, don't reconnect to a KsProxy pin!
            //
            IKsObject * pKsObject = NULL;
            HRESULT hrKsQI = pReceivePin->QueryInterface( _uuidof( IKsObject ), ( void ** ) &pKsObject );
            if( SUCCEEDED( hrKsQI ) )
            {
                bIsUpstreamFilterKs = TRUE;
                pKsObject->Release();
            }                            
        }
        
        if( !bIsUpstreamFilterKs )
        {        
            CMediaType cmt( m_mt );
            HEADER(cmt.Format())->biHeight = -HEADER(m_mt.pbFormat)->biHeight;
        
            HRESULT hrInt = QueryAccept( &cmt );
            if( SUCCEEDED( hrInt ) )
            {        
                hrInt = m_pFilter->ReconnectPin(this, &cmt);
                ASSERT( SUCCEEDED( hrInt ) );
            }            
        }            
    }
#endif       
                                 
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if(FAILED(hr))
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriterInputPin::CompleteConnect CompleteConnect")));
        return hr;
    }

    if(!m_bConnected)
    {
        m_pFilter->CompleteConnect(m_numPin);
    }
    m_bConnected = TRUE;

    DumpGraph( m_pFilter->m_pGraph, 1 );

    return hr;
}

HRESULT CWMWriterInputPin::BreakConnect()
{
    if(m_bConnected)
    {
        m_pFilter->BreakConnect( m_numPin );
        ASSERT(m_pFilter->m_cConnections < m_pFilter->m_cInputs);
    }
    m_bConnected = FALSE;

    return CBaseInputPin::BreakConnect();
}

// 
// GetMediaType
// 
// Override to offer any custom types
//
HRESULT CWMWriterInputPin::GetMediaType(int iPosition,CMediaType *pmt)
{
#ifndef OFFER_INPUT_TYPES // the default now is to NOT define OFFER_INPUT_TYPES
    
    HRESULT hr = VFW_S_NO_MORE_ITEMS;
    if( 0 == iPosition )
    {
        //
        // try to give at least a hint of what kind of pin we are by offering
        // 1 partial type
        //
        if( !pmt )
        {
            hr = E_POINTER;
        }                    
        else if(PINTYPE_AUDIO == m_fdwPinType) 
        {        
            pmt->SetType(&MEDIATYPE_Audio);
            hr = S_OK;
        }            
        else if(PINTYPE_VIDEO == m_fdwPinType) 
        {
            pmt->SetType(&MEDIATYPE_Video);
            hr = S_OK;
        }        
    }    
    return hr;
#else
    // 
    // NOTE:
    // This path is currently turned off, mostly due to problems found in the mp3 audio decoder,
    // where its output pin would accept types offered by our input pin, but then not do the 
    // format rate conversion correctly.
    //
    if( iPosition < 0 || iPosition >= (int) m_cInputMediaTypes )
        return VFW_S_NO_MORE_ITEMS;
        
    if( !pmt )
        return E_POINTER;        

    DWORD cbSize = 0;
    HRESULT hr =  m_lpInputMediaPropsArray[iPosition]->GetMediaType( NULL, &cbSize );

    WM_MEDIA_TYPE * pwmt = (WM_MEDIA_TYPE *) new BYTE[cbSize];

    if( !pwmt )
        return E_OUTOFMEMORY;

    if( SUCCEEDED( hr ) || ASF_E_BUFFERTOOSMALL == hr )
    {
        hr =  m_lpInputMediaPropsArray[iPosition]->GetMediaType( pwmt, &cbSize );
        if( SUCCEEDED( hr ) )
        {
            CopyWmTypeToAmType( pmt, pwmt );
        }
    }
    delete []pwmt;
    return hr;         
#endif    
}

// ------------------------------------------------------------------------
//
// CheckMediaType
//
// check whether we can support a given input media type using our 
// type list
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::CheckMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriterWriteInputPin::CheckMediaType")));

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    HRESULT hr2 = S_OK; // for internal errors
    
    m_bCompressedMode = FALSE;
    
    for( int i = 0; i < (int) m_cInputMediaTypes; ++i )
    {
        DWORD cbType = 0;
        hr2 =  m_lpInputMediaPropsArray[i]->GetMediaType( NULL, &cbType );
        if( SUCCEEDED( hr2 ) || ASF_E_BUFFERTOOSMALL == hr2 )
        {        
            WM_MEDIA_TYPE *pwmt = (WM_MEDIA_TYPE * ) new BYTE[cbType];
            if( !pwmt )
                return E_OUTOFMEMORY;
                
            hr2 =  m_lpInputMediaPropsArray[i]->GetMediaType( pwmt, &cbType );
            if(SUCCEEDED( hr2 ) && ( pmt->majortype == pwmt->majortype ) )
            {
                if( IsAmTypeEqualWmType( (AM_MEDIA_TYPE *)pmt, pwmt ) )
                {
                    if( 0 == i )
                    {
                        //
                        // i = 0 which is the type that matches the output type to allow in compressed inputs
                        // require an exact match, right?
                        // accept only if it's a compressed input
                        // if so, we use advanced writer interface to write sample directly, 
                        //
                        // !! For compressed inputs make sure format matches profile format exactly
                        // 
                        if( pmt->majortype == MEDIATYPE_Video &&
                            pwmt->pbFormat && pwmt->cbFormat && // wmsdk workaround for DuplicateMediaType bug with dmo
                            IsCompressed (HEADER(pwmt->pbFormat)->biCompression) &&
		                    ( HEADER(pmt->pbFormat)->biWidth     == HEADER( pwmt->pbFormat)->biWidth ) &&
		                    ( HEADER(pmt->pbFormat)->biHeight    == HEADER( pwmt->pbFormat)->biHeight ) &&
		                    ( HEADER(pmt->pbFormat)->biSize      == HEADER( pwmt->pbFormat)->biSize ) &&
		                    ( HEADER(pmt->pbFormat)->biBitCount  == HEADER( pwmt->pbFormat)->biBitCount ) )
                        {
                            hr = S_OK;
                            m_bCompressedMode = TRUE;
                            break;
                        }   
                        else if( pmt->majortype == MEDIATYPE_Audio &&
                            pwmt->pbFormat &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->wFormatTag      !=  WAVE_FORMAT_PCM ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nChannels       ==  ((WAVEFORMATEX *)pmt->pbFormat)->nChannels ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nSamplesPerSec  ==  ((WAVEFORMATEX *)pmt->pbFormat)->nSamplesPerSec ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nAvgBytesPerSec ==  ((WAVEFORMATEX *)pmt->pbFormat)->nAvgBytesPerSec ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nBlockAlign     ==  ((WAVEFORMATEX *)pmt->pbFormat)->nBlockAlign ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->wBitsPerSample  ==  ((WAVEFORMATEX *)pmt->pbFormat)->wBitsPerSample ) )
                        {
                            hr = S_OK;
                            m_bCompressedMode = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        hr = S_OK;
                        break;
                    }                                                       
                }
            }  
            delete []pwmt;              
        }            
    }
    return SUCCEEDED( hr2 ) ? hr : hr2;
}

//
// IAMStreamConfig 
//
// GetFormat() is the only method we support on this interface.
// 
// It's used to query the asf writer's input pin for it's destination 
// compression format, which is defined in the current profile.
// If an upstream pin wants to avoid wmsdk recompression for this stream
// then it should query us for this format and use that format when connecting
// to this pin.
//
HRESULT CWMWriterInputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("CWrapperOutputPin - IAMStreamConfig::GetFormat")));

    if( !ppmt )
        return E_POINTER;        

    if( !m_lpInputMediaPropsArray )
        return E_FAIL;

    // make sure we don't get reconfigured to a new profile in the middle of this
    CAutoLock lock(&m_pFilter->m_csFilter);
    
    // allocate the buffer, the output format is stored in position 0
    DWORD cbSize = 0;
    HRESULT hr =  m_lpInputMediaPropsArray[0]->GetMediaType( NULL, &cbSize );
    if( SUCCEEDED( hr ) || ASF_E_BUFFERTOOSMALL == hr )
    {
        WM_MEDIA_TYPE *pwmt = (WM_MEDIA_TYPE * ) new BYTE[cbSize];
        if( pwmt )
        {
            hr = m_lpInputMediaPropsArray[0]->GetMediaType( pwmt, &cbSize );
            if( S_OK == hr )
            {
                // now we must copy this to a dshow-type media type, so that our FreeMediaType
                // function won't crash when it tries to free the format block first!

                // allocate a new copy of the wm media type
                *ppmt = CreateMediaType( (AM_MEDIA_TYPE *) pwmt );
                if( !*ppmt )
                {
                    delete []pwmt;
                    return E_OUTOFMEMORY;
                }
            }
            delete []pwmt;
        }
    }
    return hr;         
}



// handle dynamic format changes
HRESULT CWMWriterInputPin::QueryAccept( const AM_MEDIA_TYPE *pmt )
{
    HRESULT hr = S_FALSE;
    {
        CAutoLock lock(&m_pFilter->m_csFilter);
        if( m_pFilter->m_State != State_Stopped )
        {
            // accept only audio format changes even when running
            if( m_mt.majortype == MEDIATYPE_Audio &&
                pmt->majortype == MEDIATYPE_Audio &&
                pmt->formattype == FORMAT_WaveFormatEx &&
                pmt->cbFormat == pmt->cbFormat)
            {
	            hr = S_OK;
            }
            else if(m_mt.majortype == MEDIATYPE_Interleaved &&
                pmt->majortype == MEDIATYPE_Interleaved &&
                pmt->formattype == FORMAT_DvInfo &&
                m_mt.cbFormat == pmt->cbFormat &&
                pmt->pbFormat != NULL)
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;
        }        
    }
    if( S_OK == hr )
    {    
        hr = CBaseInputPin::QueryAccept(pmt);
    } 
    DbgLog( ( LOG_TRACE
          , 3
          , TEXT("CWMWriterInputPin::QueryAccept() returning 0x%08lx")
          , hr ) );
        
    return hr;
}

// =================================================================
// Implements IMemInputPin interface
// =================================================================

//
// EndOfStream
//
// Tell filter this pin's done receiving
//
STDMETHODIMP CWMWriterInputPin::EndOfStream(void)
{
    HRESULT hr;
    {
        CAutoLock lock(&m_pFilter->m_csFilter);

        // call CheckStreaming instead??
        if(m_bFlushing)
            return S_OK;

        if(m_pFilter->m_State == State_Stopped)
            return S_FALSE;

        //ASSERT( !m_fEOSReceived ); // can this happen legally? Yes, if we force it in Receive
        if( m_fEOSReceived )
        {        
            DbgLog(( LOG_TRACE, 2, TEXT("CWMWriterInputPin::EndOfStream Error - already received EOS for pin" ) ) );
            return E_UNEXPECTED;
        }
        m_fEOSReceived = TRUE;            
        hr = m_pFilter->EndOfStreamFromPin(m_numPin);
    }

    return hr;
}

//
// HandleFormatChange
//
HRESULT CWMWriterInputPin::HandleFormatChange( const CMediaType *pmt )
{
    // CBaseInputPin::Receive only calls CheckMediaType, so it doesn't
    // check the additional constraints put on on-the-fly format changes
    // (handled through QueryAccept).
    HRESULT hr = QueryAccept( pmt );   
    
    // upstream filter should have checked
    ASSERT(hr == S_OK);
    
    if(hr == S_OK)
    {
        hr = SetMediaType( pmt );
        DbgLog( ( LOG_TRACE
              , 3
              , TEXT("CWMWriterInputPin::HandleFormatChange SetMediaType() returned 0x%08lx for dynamic change")
              , hr ) );
    }
    return hr;
}


// receive on sample from upstream
HRESULT CWMWriterInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;
    CAutoLock lock(&m_csReceive);
    
    // check all is well with the base class
    hr = CBaseInputPin::Receive(pSample);
    if( S_OK != hr )
        return hr;

    REFERENCE_TIME rtStart, rtStop;
    AM_SAMPLE2_PROPERTIES * pSampleProps = SampleProps();
    if(pSampleProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED)
    {
        hr = HandleFormatChange( (CMediaType *) pSampleProps->pMediaType );
        if(FAILED(hr)) {
            return hr;
        }
    }
    
    long len = pSample->GetActualDataLength( );
    
    hr = pSample->GetTime(&rtStart, &rtStop);
    if( SUCCEEDED( hr ) )
    {    
#ifdef DEBUG 
        if( VFW_S_NO_STOP_TIME == hr )
        {
            DbgLog(( LOG_TRACE, 5,
                     TEXT("CWMWriterInputPin::Receive GetTime on sample returned VFW_S_NO_STOP_TIME") ) ); 
        }        
#endif
    
        m_rtLastTimeStamp = rtStart;
        
        DbgLog(( LOG_TRACE, 15,
                 TEXT("CWMWriterInputPin::Receive %s sample (#%ld) with timestamp %dms, discontinuity %2d"), 
                 (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid"), 
                 m_cSample,
                 (LONG) ( rtStart/10000 ),
                 ( S_OK == pSample->IsDiscontinuity() ) ));

        if( 0 == m_cSample && rtStart < 0 )
        {
            // with 10ms pre-roll a timestamp should never be < -10ms, right?
            // It may be necessary to offset other streams at end of writing to account for
            // any offset necessary for pre-0 times of individual streams.
            
            // save timestamp offset to use to 0-base sample times in case of pre-roll
            m_rtFirstSampleOffset = rtStart;
        }        
        m_cSample++;
           
        rtStart -= m_rtFirstSampleOffset;
        rtStop -= m_rtFirstSampleOffset;
        ASSERT( rtStart >= 0 );

        if( len == 0 )
        {
            //
            // ??? 0 length?
            // usb video capture occassionally sends 0-length sample with valid timestamps
            //
            DbgLog(( LOG_TRACE, 3,
                     TEXT("CWMWriterInputPin::Receive %s got a 0-length sample"), 
                     (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid") ) );

            hr = S_OK;
        }
        else
        {
            if( m_pFilter->HaveIDeliveredTooMuch( this, rtStart ) )
            {
                DbgLog( (LOG_TRACE, 3, TEXT("Pin %ld has delivered too much at %ld"), m_numPin, long( rtStart / 10000 ) ) );
                SleepUntilReady( );
            }
            
            ASSERT( rtStop >= rtStart );
            if( rtStop < rtStart )
                rtStop = rtStart+1; // ??
            
            hr = m_pFilter->Receive(this, pSample, &rtStart, &rtStop );
        }
    }    
    else if( 0 == len )
    {
        //
        // lookout, the bt829 video capture driver occassionally gives 0-length sample 
        // with no timestamps during transitions!
        //
        DbgLog(( LOG_TRACE, 3,
                 TEXT("CWMWriterInputPin::Receive Received 0-length %s sample (#%ld) with no timestamp...Passing on it"), 
                 (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid"), 
                 m_cSample ) );
        hr = S_OK;  // don't fail receive because of this
    }    
    else
    {
        // uh-oh, we require timestamps on every sample for asf writer!
        m_pFilter->m_fErrorSignaled = TRUE;
        m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriterInputPin::Receive Error: %s sample has no timestamp!"), 
                 (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid") ) );
    }    
    return hr;
}


STDMETHODIMP CWMWriterInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    /*  Go for 64 0.5 second buffers - 8 byte aligned */
    pProps->cBuffers = 64;
    pProps->cbBuffer = 1024*8;
    pProps->cbAlign = 1;
    pProps->cbPrefix = 0;
    
    return S_OK;
}

/* Get told which allocator the upstream output pin is actually going to use */
STDMETHODIMP CWMWriterInputPin::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
#ifdef DEBUG        
    if(pAllocator) {
        ALLOCATOR_PROPERTIES propActual, Prop;
        
        HRESULT hr = pAllocator->GetProperties( &Prop );
        if( SUCCEEDED( hr ) )
        {        
            hr = GetAllocatorRequirements( &propActual );
            ASSERT( SUCCEEDED( hr ) );
        
            if( Prop.cBuffers < propActual.cBuffers ||
                Prop.cbBuffer < propActual.cbBuffer )
            {            
                //
                // hmm, we either need to run with less or do a copy
                // what if cBuffers = 1? this is the case for the avi dec
                // so far it looks like we'll be ok with just using the upstream 
                // allocator, even if cBuffers is 1
                //
                DbgLog(( LOG_TRACE, 2,
                         TEXT("CWMWriterInputPin::NotifyAllocator upstream allocator is smaller then we'd prefer (cBuffers = %ld, cbBuffers = %ld)"), 
                         Prop.cBuffers,
                         Prop.cbBuffer ) ); 
            }                         
        }
    }
#endif        
    
    return  CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
} // NotifyAllocator

HRESULT CWMWriterInputPin::Active()
{
    ASSERT(IsConnected());        // base class

    if(m_pAllocator == 0)
        return E_FAIL;

    m_fEOSReceived = FALSE;
    
    // reset sample counter, timestamp offset    
    m_cSample = 0;
    m_rtFirstSampleOffset = 0;
    m_rtLastTimeStamp = 0;
    m_rtLastDeliveredStartTime = 0;
    m_rtLastDeliveredEndTime = 0;
    m_bNeverSleep = FALSE;

    return S_OK;
}


HRESULT CWMWriterInputPin::Inactive()
{
    ASSERT(IsConnected());        // base class

    return CBaseInputPin::Inactive();
}

#ifdef OFFER_INPUT_TYPES

// ------------------------------------------------------------------------
//
// CopyWmTypeToAmType
//
// ------------------------------------------------------------------------
void CopyWmTypeToAmType( AM_MEDIA_TYPE * pmt, WM_MEDIA_TYPE *pwmt )
{
    pmt->majortype             = pwmt->majortype;
    pmt->subtype               = pwmt->subtype;
    pmt->bFixedSizeSamples     = pwmt->bFixedSizeSamples;
    pmt->bTemporalCompression  = pwmt->bTemporalCompression;
    pmt->lSampleSize           = pwmt->lSampleSize;
    pmt->formattype            = pwmt->formattype;
    ((CMediaType *)pmt)->SetFormat(pwmt->pbFormat, pwmt->cbFormat);
}
#endif

// ------------------------------------------------------------------------
//
// IsAmTypeEqualWmType - compare WM_MEDIA_TYPE and AM_MEDIA_TYPEs
//
// Note that "Equal" here is to be taken as "does the input typed offered
// look enough like a type acceptable to the WMSDK?"
//
// ------------------------------------------------------------------------
BOOL IsAmTypeEqualWmType( AM_MEDIA_TYPE * pmt, WM_MEDIA_TYPE * pwmt)
{

#ifdef DEBUG
    DbgLog((LOG_TRACE,15,TEXT("WMWriter:IsAmTypeEqualWmType: Checking whether types match" )));
    DbgLog((LOG_TRACE,15,TEXT("WMWriter:IsAmTypeEqualWmType: Type offered to input pin:" )));
    LogMediaType( pmt );
    DbgLog((LOG_TRACE,15,TEXT("WMWriter:IsAmTypeEqualWmType: WMSDK enumerated type:" )));
    LogMediaType( (AM_MEDIA_TYPE * ) pwmt ); // in debug assume they're defined the same
#endif
        
    // assume for now that formats will always need to match for valid connections to the writer
    if( pmt->majortype  == pwmt->majortype  && 
        pmt->formattype == pwmt->formattype )
    {
#ifdef DEBUG    
        if( pmt->majortype == MEDIATYPE_Audio )
        {        
            // need to fix other things if this changes
            ASSERT( pwmt->pbFormat && 0 != pwmt->cbFormat );
        }   
#endif
        if ( ( pmt->majortype   == MEDIATYPE_Video &&
               pmt->cbFormat    >= sizeof( VIDEOINFOHEADER ) &&
               pmt->subtype     == pwmt->subtype ) ||
             ( pmt->majortype   == MEDIATYPE_Audio &&
               pmt->cbFormat   == pwmt->cbFormat &&
               ((WAVEFORMATEX *) pmt->pbFormat)->wFormatTag      == ((WAVEFORMATEX *) pwmt->pbFormat)->wFormatTag  &&
               ((WAVEFORMATEX *) pmt->pbFormat)->nBlockAlign     == ((WAVEFORMATEX *) pwmt->pbFormat)->nBlockAlign  &&
               // oops, the wmsdk can't resample odd rate pcm audio so ensure sample rates match!
               //
               // note that this has one very bad side effect, which is if the sample rate
               // isn't supported directly and we pull in acmwrap, acmwrap will always connect
               // with it's 2nd enumerated output type, which is 44k, stereo!!!!
               //
               ((WAVEFORMATEX *) pmt->pbFormat)->nSamplesPerSec  == ((WAVEFORMATEX *) pwmt->pbFormat)->nSamplesPerSec ) )
        {
        
            DbgLog( ( LOG_TRACE,15,TEXT("WMWriter: IsAmTypeEqualWmType - types match") ) );
            return TRUE;
        }                                                                                 
    }
    DbgLog( ( LOG_TRACE,15,TEXT("WMWriter: IsAmTypeEqualWmType - types don't match") ) );
    return FALSE;
}

#ifdef DEBUG
void LogMediaType( AM_MEDIA_TYPE * pmt )
{
    ASSERT( pmt );
    if( !pmt ) 
        return;
        
    if( !pmt->pbFormat || 0 == pmt->cbFormat )
    {    
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  partial media type only, format data not supplied" )));
        return;
    }    
    
    if( pmt->majortype == MEDIATYPE_Audio )
    { 
        WAVEFORMATEX * pwfx = (WAVEFORMATEX *) pmt->pbFormat;
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  wFormatTag      %u" ), pwfx->wFormatTag));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nChannels       %u" ), pwfx->nChannels));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nSamplesPerSec  %lu"), pwfx->nSamplesPerSec));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nAvgBytesPerSec %lu"), pwfx->nAvgBytesPerSec));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nBlockAlign     %u" ), pwfx->nBlockAlign));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  wBitsPerSample  %u" ), pwfx->wBitsPerSample));
    }
    else if( pmt->majortype == MEDIATYPE_Video )
    {    
        LPBITMAPINFOHEADER pbmih = HEADER( pmt->pbFormat );
        
        DbgLog((LOG_TRACE,15,TEXT("WMWriter: biComp: %lx bitDepth: %d"),
        		pbmih->biCompression,
        		pbmih->biBitCount ) );
        DbgLog((LOG_TRACE,15,TEXT("WMWriter: biWidth: %ld biHeight: %ld biSize: %ld"),
				pbmih->biWidth,
				pbmih->biHeight,
				pbmih->biSize ) );
    }
    else
    {                                
        DbgLog((LOG_TRACE,15,TEXT("  non video or audio media type" )));
    }                                
}
#endif

// ------------------------------------------------------------------------
//
// IsCompressed - compressed video?
//
// ------------------------------------------------------------------------
BOOL IsCompressed( DWORD biCompression )
{
    switch( biCompression )
    {
        case BI_RGB:
            return( FALSE );
    };
    
    return( TRUE );
}

// ------------------------------------------------------------------------
//
// CWMSample methods
//
CWMSample::CWMSample(
    TCHAR *pName,
    IMediaSample  * pSample ) :
        CBaseObject( pName ),
        m_pSample( pSample ),
        m_cOurRef( 0 )
{
    DbgLog(( LOG_TRACE, 100,
    
             TEXT("CWMSample::CWMSample constructor this = 0x%08lx, m_pSample = 0x%08lx "), 
             this, m_pSample ) );

}

// override say what interfaces we support where
STDMETHODIMP CWMSample::NonDelegatingQueryInterface(
                                            REFIID riid,
                                            void** ppv )
{
    if( riid == IID_INSSBuffer )
    {
        return( GetInterface( (INSSBuffer *)this, ppv ) );
    }
    else
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWMSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    DbgLog(( LOG_TRACE, 100,
             TEXT("CWMSample::Release entered with m_cOurRef = %ld (this = 0x%08lx, m_pSample = 0x%08lx)"), 
             m_cOurRef, this, m_pSample ) );
    if (m_cOurRef == 1) {
        lRef = 0;
        m_cOurRef = 0;
        m_pSample->Release();
        DbgLog(( LOG_TRACE, 100,
                 TEXT("CWMSample::Release releasing sample and deleting object (this = 0x%08lx, m_pSample = 0x%08lx)"), 
                 this, m_pSample ) );
        delete this;
    } else {
        lRef = InterlockedDecrement(&m_cOurRef);
    }
    ASSERT(lRef >= 0);
    return lRef;
}

STDMETHODIMP_(ULONG) CWMSample::AddRef()
{
    DbgLog(( LOG_TRACE, 100,
             TEXT("CWMSample::AddRef entered with m_cOurRef = %ld (this = 0x%08lx, m_pSample = 0x%08lx)"), 
             m_cOurRef, this, m_pSample ) );
    // if this is the first addref grab a hold on the media sample we've wrapped
    if (m_cOurRef == 0) {
        m_pSample->AddRef();
    }        
    return InterlockedIncrement(&m_cOurRef);
}

STDMETHODIMP CWMSample::QueryInterface( REFIID riid, void **ppvObject )
{
    return NonDelegatingQueryInterface( riid, ppvObject );
} 

// ------------------------------------------------------------------------
//
// methods to make our wrapped IMediaSample look like an INSSBuffer sample
//
STDMETHODIMP CWMSample::GetLength( DWORD *pdwLength )
{
    if( NULL == pdwLength )
    {
        return( E_INVALIDARG );
    }
    *pdwLength = m_pSample->GetActualDataLength();

    return( S_OK );
}

STDMETHODIMP CWMSample::SetLength( DWORD dwLength )
{
    return m_pSample->SetActualDataLength( dwLength );
} 

STDMETHODIMP CWMSample::GetMaxLength( DWORD * pdwLength )
{
    if( NULL == pdwLength )
    {
        return( E_INVALIDARG );
    }

    *pdwLength = m_pSample->GetSize();
    return( S_OK );
} 

STDMETHODIMP CWMSample::GetBufferAndLength(
    BYTE  ** ppdwBuffer,
    DWORD *  pdwLength )
{
    if( !ppdwBuffer || !pdwLength )
        return E_POINTER;
        
    HRESULT hr = m_pSample->GetPointer( ppdwBuffer );
    if( SUCCEEDED( hr ) )
        *pdwLength = m_pSample->GetActualDataLength();
    
    return hr;        
} 

STDMETHODIMP CWMSample::GetBuffer( BYTE ** ppdwBuffer )
{
    if( !ppdwBuffer )
        return E_POINTER;

    return m_pSample->GetPointer( ppdwBuffer );
} 

void
CWMWriterInputPin::SleepUntilReady( )
{
    DbgLog((LOG_TRACE, 5, "Pin %ld Going to sleep...", m_numPin ));
    
    DWORD dw = WaitForSingleObject( m_hWakeEvent, INFINITE );
    
    DbgLog((LOG_TRACE, 5, "Pin %ld Woke up!", m_numPin ));
}

void
CWMWriterInputPin::WakeMeUp( )
{
    DbgLog((LOG_TRACE, 5, "Waking Pin %ld", m_numPin  ));
    SetEvent( m_hWakeEvent );
}

// 
// Helper to determine whether a media type is a packed YUV format
// that will require us to do a reconnect for. State of bNegBiHeight
// arg determines whether we look for a positive or negative height
// type.
//
BOOL IsPackedYUVType( BOOL bNegBiHeight, AM_MEDIA_TYPE * pmt )
{
    ASSERT( pmt );
    if( pmt &&
        pmt->majortype == MEDIATYPE_Video &&
        pmt->pbFormat && 
        0 != pmt->cbFormat && // wmsdk workaround for DuplicateMediaType bug with dmo
        ( MEDIASUBTYPE_YUY2 == pmt->subtype ||
          MEDIASUBTYPE_UYVY == pmt->subtype ||
          MEDIASUBTYPE_CLJR == pmt->subtype ) )
    {
        if( bNegBiHeight )
        {
            if( 0 > HEADER(pmt->pbFormat)->biHeight )
            {
                return TRUE;
            }
        }            
        else if( 0 < HEADER(pmt->pbFormat)->biHeight )
        {
            return TRUE;
        }                    
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\asferr.h ===
//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================
///////////////////////////////////////////////////////////////////////////
//
// ASFErr.h - definition of ASF HRESULT codes
//
// Copyright (c) 1997  Microsoft Corporation
//
// This file is generated by the MC tool from ASFErr.mc
//

#ifndef _ASFERR_H
#define _ASFERR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Errors (2000 - 2999)
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ASF_E_BUFFEROVERRUN
//
// MessageText:
//
//  An attempt was made to seek or position past the end of a buffer.%0
//
#define ASF_E_BUFFEROVERRUN              0xC00D07D0L

//
// MessageId: ASF_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The supplied input or output buffer was too small.%0
//
#define ASF_E_BUFFERTOOSMALL             0xC00D07D1L

//
// MessageId: ASF_E_BADLANGUAGEID
//
// MessageText:
//
//  The language ID was not found.%0
//
#define ASF_E_BADLANGUAGEID              0xC00D07D2L

//
// MessageId: ASF_E_NOPAYLOADLENGTH
//
// MessageText:
//
//  The multiple payload packet is missing the payload length.%0
//
#define ASF_E_NOPAYLOADLENGTH            0xC00D07DBL

//
// MessageId: ASF_E_TOOMANYPAYLOADS
//
// MessageText:
//
//  The packet contains too many payloads.%0
//
#define ASF_E_TOOMANYPAYLOADS            0xC00D07DCL

//
// MessageId: ASF_E_PACKETCONTENTTOOLARGE
//
// MessageText:
//
//  ASF_E_PACKETCONTENTTOOLARGE
//
#define ASF_E_PACKETCONTENTTOOLARGE      0xC00D07DEL

//
// MessageId: ASF_E_UNKNOWNPACKETSIZE
//
// MessageText:
//
//  Expecting a fixed packet size but min. and max. are not equal.%0
//
#define ASF_E_UNKNOWNPACKETSIZE          0xC00D07E0L

//
// MessageId: ASF_E_INVALIDHEADER
//
// MessageText:
//
//  ASF_E_INVALIDHEADER
//
#define ASF_E_INVALIDHEADER              0xC00D07E2L

//
// MessageId: ASF_E_NOCLOCKOBJECT
//
// MessageText:
//
//  The object does not have a valid clock object.%0
//
#define ASF_E_NOCLOCKOBJECT              0xC00D07E6L

//
// MessageId: ASF_E_UNKNOWNCLOCKTYPE
//
// MessageText:
//
//  ASF_E_UNKNOWNCLOCKTYPE
//
#define ASF_E_UNKNOWNCLOCKTYPE           0xC00D07EBL

//
// MessageId: ASF_E_OPAQUEPACKET
//
// MessageText:
//
//  An attempt was made to restore or access an opaque packet.%0
//
#define ASF_E_OPAQUEPACKET               0xC00D07EDL

//
// MessageId: ASF_E_WRONGVERSION
//
// MessageText:
//
//  ASF_E_WRONGVERSION
//
#define ASF_E_WRONGVERSION               0xC00D07EEL

//
// MessageId: ASF_E_OVERFLOW
//
// MessageText:
//
//  An attempt was made to store a value which was larger than then destination's maximum value.%0
//
#define ASF_E_OVERFLOW                   0xC00D07EFL

//
// MessageId: ASF_E_NOTFOUND
//
// MessageText:
//
//  The object was not found.%0
//
#define ASF_E_NOTFOUND                   0xC00D07F0L

//
// Someone else is using MessageIds 2033 & 2034, so we skip them
// 
// 2033 = NS_E_NOTHING_TO_DO
// 2034 = NS_E_NO_MULTICAST

//
// MessageId: ASF_E_OBJECTTOOBIG
//
// MessageText:
//
//  The object is too large to be processed in the requested manner.%0
//
#define ASF_E_OBJECTTOOBIG               0xC00D07F3L

//
// MessageId: ASF_E_UNEXPECTEDVALUE
//
// MessageText:
//
//  A value was not set as expected.%0
//
#define ASF_E_UNEXPECTEDVALUE            0xC00D07F4L

//
// MessageId: ASF_E_INVALIDSTATE
//
// MessageText:
//
//  The request is not valid in the object's current state.%0
//
#define ASF_E_INVALIDSTATE               0xC00D07F5L

//
// MessageId: ASF_E_NOLIBRARY
//
// MessageText:
//
//  This object does not have a valid library pointer; it was not properly created or it has been Shutdown().%0
//
#define ASF_E_NOLIBRARY                  0xC00D07F6L

//
// MessageId: ASF_E_ALREADYINITIALIZED
//
// MessageText:
//
//  This object has already been initialized; the setting cannot be changed.%0
//
#define ASF_E_ALREADYINITIALIZED         0xC00D07F7L

//
// MessageId: ASF_E_INVALIDINIT
//
// MessageText:
//
//  This object has not been initialized properly; that operation cannot be performed.%0
//
#define ASF_E_INVALIDINIT                0xC00D07F8L

//
// MessageId: ASF_E_NOHEADEROBJECT
//
// MessageText:
//
//  The ASF Header object could not be found.%0
//
#define ASF_E_NOHEADEROBJECT             0xC00D07F9L

//
// MessageId: ASF_E_NODATAOBJECT
//
// MessageText:
//
//  The ASF Data object could not be found.%0
//
#define ASF_E_NODATAOBJECT               0xC00D07FAL

//
// MessageId: ASF_E_NOINDEXOBJECT
//
// MessageText:
//
//  The ASF Index object could not be found.%0
//
#define ASF_E_NOINDEXOBJECT              0xC00D07FBL

//
// MessageId: ASF_E_NOSTREAMPROPS
//
// MessageText:
//
//  A Stream Properties object with the correct stream number could not be found.%0
//
#define ASF_E_NOSTREAMPROPS              0xC00D07FCL

//
// MessageId: ASF_E_NOFILEPROPS
//
// MessageText:
//
//  The File Properties object could not be found.%0
//
#define ASF_E_NOFILEPROPS                0xC00D07FDL

//
// MessageId: ASF_E_NOLANGUAGELIST
//
// MessageText:
//
//  The Language List object could not be found.%0
//
#define ASF_E_NOLANGUAGELIST             0xC00D07FEL

//
// MessageId: ASF_E_NOINDEXPARAMETERS
//
// MessageText:
//
//  The Index Parameters object could not be found.%0
//
#define ASF_E_NOINDEXPARAMETERS          0xC00D07FFL

//
// MessageId: ASF_E_UNSUPPORTEDERRORCONCEALMENT
//
// MessageText:
//
//  The requested error concealment strategy is not supported by this component.%0
//
#define ASF_E_UNSUPPORTEDERRORCONCEALMENT 0xC00D0800L

//
// MessageId: ASF_E_INVALIDFLAGS
//
// MessageText:
//
//  The flags for this object or set of objects are not properly set.%0
//
#define ASF_E_INVALIDFLAGS               0xC00D0801L

//
// MessageId: ASF_E_BADDATADESCRIPTOR
//
// MessageText:
//
//  One or more data descriptors is not properly set.%0
//
#define ASF_E_BADDATADESCRIPTOR          0xC00D0802L

//
// MessageId: ASF_E_BADINDEXTIMEINTERVAL
//
// MessageText:
//
//  The index has an invalid time interval (probably zero).%0
//
#define ASF_E_BADINDEXTIMEINTERVAL       0xC00D0803L

//
// MessageId: ASF_E_INVALIDTIME
//
// MessageText:
//
//  The given time value is not valid.%0
//
#define ASF_E_INVALIDTIME                0xC00D0804L

//
// MessageId: ASF_E_INVALIDINDEX
//
// MessageText:
//
//  The given index value is not valid.%0
//
#define ASF_E_INVALIDINDEX               0xC00D0805L

//
// MessageId: ASF_E_STREAMNUMBERINUSE
//
// MessageText:
//
//  The specified stream number is already in use.%0
//
#define ASF_E_STREAMNUMBERINUSE          0xC00D0806L

//
// MessageId: ASF_E_BADMEDIATYPE
//
// MessageText:
//
//  The specified media type does not work with this component.%0
//
#define ASF_E_BADMEDIATYPE               0xC00D0807L

//
// MessageId: ASF_E_WRITEFAILED
//
// MessageText:
//
//  The object could not be written as specified.%0
//
#define ASF_E_WRITEFAILED                0xC00D0808L

//
// MessageId: ASF_E_NOTENOUGHDESCRIPTORS
//
// MessageText:
//
//  The given data unit requires a larger number of descriptors to be fully parsed.%0
//
#define ASF_E_NOTENOUGHDESCRIPTORS       0xC00D0809L

//
// MessageId: ASF_E_INDEXBLOCKUNLOADED
//
// MessageText:
//
//  The index entries for the specified index block have been unloaded from memory and are not available.%0
//
#define ASF_E_INDEXBLOCKUNLOADED         0xC00D080AL

//
// MessageId: ASF_E_NOTENOUGHBANDWIDTH
//
// MessageText:
//
//  The specified bandwidth is not large enough.%0
//
#define ASF_E_NOTENOUGHBANDWIDTH         0xC00D080BL

//
// MessageId: ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE
//
// MessageText:
//
//  The object has exceeded its maximum size.%0
//
#define ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE  0xC00D080CL

//
// MessageId: ASF_E_BADDATAUNIT
//
// MessageText:
//
//  The given data unit is corrupted, badly formatted, or otherwise not valid.%0
//
#define ASF_E_BADDATAUNIT                0xC00D080DL

//
// MessageId: ASF_E_HEADERSIZE
//
// MessageText:
//
//  The ASF header has exceeded the specified maximum size.%0
//
#define ASF_E_HEADERSIZE                 0xC00D080EL


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Success Codes (2000 - 2999)
//

//
// MessageId: ASF_S_OPAQUEPACKET
//
// MessageText:
//
//  ASF_S_OPAQUEPACKET
//
#define ASF_S_OPAQUEPACKET               0x000D07F0L


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Warnings (2000 - 2999)
//


#endif // _ASFERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\qasf\qasf.cpp ===
//
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//

#include <streams.h>
#undef SubclassWindow

#include <initguid.h>
#define INITGUID

// If FILTER_LIB is defined then the component filters
// are being built as filter libs, to link into this dll,
// hence we need all these gubbins!

#include <wmsdk.h>
#include <qnetwork.h>
#include <wmsdkdrm.h>
#include <wmsecure.h>
#ifndef _WIN64
#include <asfread.h>
#include <asfwrite.h>
#include <proppage.h>
#endif
#include "..\..\..\dmo\wrapper\filter.h"

// individual source filter's includes
CFactoryTemplate g_Templates[] =
{
#ifndef _WIN64
    { L"WM ASF Reader", &CLSID_WMAsfReader, CreateASFReaderInstance, NULL, &sudWMAsfRead },
    { L"WM ASF Writer", &CLSID_WMAsfWriter, CWMWriter::CreateInstance, NULL, &sudWMAsfWriter },
    { L"WM ASF Writer Properties", &CLSID_WMAsfWriterProperties, CWMWriterProperties::CreateInstance },
#endif
    { L"DMO Wrapper Filter", &CLSID_DMOWrapperFilter, CMediaWrapperFilter::CreateInstance, NULL, NULL }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

extern "C" BOOL QASFDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

BOOL QASFDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
    BOOL f = DllEntryPoint(hInstance, ulReason, pv);

    // if loading this dll, we want to call the 2nd dll entry point
    // only if the first one succeeded. if unloading, always call
    // both. if the second one fails, undo the first one.  HAVE NOT
    // verified that failing DllEntryPoint for ATTACH does not cause
    // the loader to call in again w/ DETACH. but that seems silly
    if(f || ulReason == DLL_PROCESS_DETACH)
    {
        if (ulReason == DLL_PROCESS_ATTACH)
        {
            DisableThreadLibraryCalls(hInstance);
        }
        else if (ulReason == DLL_PROCESS_DETACH)
        {
            // We hit this ASSERT in NT setup
            // ASSERT(_Module.GetLockCount()==0 );
        }
    }

    return f;
}

//
// stub entry points
//

STDAPI
QASF_DllRegisterServer( void )
{
#if 0 // !!! register ASF stuff here???
  // register the still video source filetypes
  HKEY hkey;
  OLECHAR wch[80];
  char ch[80];
  StringFromGUID2(CLSID_ASFRead, wch, 80);
  LONG l = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.asf"),
						&hkey);
  if (l == ERROR_SUCCESS) {
#ifdef UNICODE
	l = RegSetValueEx(hkey, L"Source Filter", 0, REG_SZ, (BYTE *)wch,
								_tcslen(wch));
#else
  	WideCharToMultiByte(CP_ACP, 0, wch, -1, ch, sizeof(ch), NULL, NULL);
	l = RegSetValueEx(hkey, "Source Filter", 0, REG_SZ, (BYTE *)ch,
								_tcslen(ch));
#endif
	RegCloseKey(hkey);
	if (l != ERROR_SUCCESS) {
	    ASSERT(0);
	    return E_UNEXPECTED;
	}
  }
  l = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.wma"),
						&hkey);
  if (l == ERROR_SUCCESS) {
#ifdef UNICODE
	l = RegSetValueEx(hkey, L"Source Filter", 0, REG_SZ, (BYTE *)wch,
								_tcslen(wch));
#else
  	WideCharToMultiByte(CP_ACP, 0, wch, -1, ch, sizeof(ch), NULL, NULL);
	l = RegSetValueEx(hkey, "Source Filter", 0, REG_SZ, (BYTE *)ch,
								_tcslen(ch));
#endif
	RegCloseKey(hkey);
	if (l != ERROR_SUCCESS) {
	    ASSERT(0);
	    return E_UNEXPECTED;
	}
  }
  l = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.nsc"),
						&hkey);
  if (l == ERROR_SUCCESS) {
#ifdef UNICODE
	l = RegSetValueEx(hkey, L"Source Filter", 0, REG_SZ, (BYTE *)wch,
								_tcslen(wch));
#else
  	WideCharToMultiByte(CP_ACP, 0, wch, -1, ch, sizeof(ch), NULL, NULL);
	l = RegSetValueEx(hkey, "Source Filter", 0, REG_SZ, (BYTE *)ch,
								_tcslen(ch));
#endif
	RegCloseKey(hkey);
	if (l != ERROR_SUCCESS) {
	    ASSERT(0);
	    return E_UNEXPECTED;
	}
  }
#endif

  HRESULT hr =  AMovieDllRegisterServer2( TRUE );

  return hr;
}

STDAPI
QASF_DllUnregisterServer( void )
{
  HRESULT hr = AMovieDllRegisterServer2( FALSE );

  return hr;
}

//  BOOL WINAPI
//  DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
//  {
//      return QASFDllEntry(hInstance, ulReason, pv);
//  }

STDAPI
QASF_DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **ppv)
{
    HRESULT hr = DllGetClassObject(rClsID, riid, ppv);

    return hr;
}

STDAPI QASF_DllCanUnloadNow(void)
{
    HRESULT hr = DllCanUnloadNow();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsdk.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:        wmsdk.h
//
//  Description: WMSDK global include file
//
//============================================================================

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT (\"EULA\").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================

#include "wmsdkidl.h"
#include "asferr.h"
#include "nserror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsdkdrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       WMAudioDRM.h
//
//--------------------------------------------------------------------------

#ifndef _WMSDKDRM_H
#define _WMSDKDRM_H

#include "wmsdk.h"

///////////////////////////////////////////////////////////////////////////////
//
// WMCreateDRMReader:
//     Called to create DRM-enabled writer
//     Implementation linked in from WMSDKDRM.lib.
//
HRESULT STDMETHODCALLTYPE WMCreateDRMReader(
                            /* [in] */  IUnknown*   pUnkDRM,
                            /* [in] */  DWORD       dwRights,
                            /* [out] */ IWMReader **ppDRMReader );


///////////////////////////////////////////////////////////////////////////////
//
// WMCreateDRMWriter:
//     Called to create DRM-enabled writer
//     Implementation linked in from WMSDKDRM.lib.
//
//
HRESULT STDMETHODCALLTYPE WMCreateDRMWriter(
                            /* [in] */  IUnknown*   pUnkDRM,
                            /* [out] */ IWMWriter** ppDRMWriter );




#endif  // _WMSDKDRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsbuffer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 24 07:28:47 2000
 */
/* Compiler settings for .\wmsbuffer.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsbuffer_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);


void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer2_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer2_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer2_GetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [out] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_GetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer2_SetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [in] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_SetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBufferAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBufferAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocateBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocatePageSizeBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocatePageSizeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\nserror.h ===
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for NetShow events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup

 12000 - 12999 = Windows Media Networking

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Success Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
//  The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 0x000D0000L

//
// MessageId: NS_S_CALLABORTED
//
// MessageText:
//
//  The requested operation was aborted by the client.%0
//
#define NS_S_CALLABORTED                 0x000D0001L

//
// MessageId: NS_S_STREAM_TRUNCATED
//
// MessageText:
//
//  The stream was purposefully stopped before completion.%0
//
#define NS_S_STREAM_TRUNCATED            0x000D0002L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Warning Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_W_SERVER_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum file bitrate value specified is greater than the server's configured maximum bandwidth.%0
//
#define NS_W_SERVER_BANDWIDTH_LIMIT      0x800D0003L

//
// MessageId: NS_W_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum bandwidth value specified is less than the maximum filebitrate.%0
//
#define NS_W_FILE_BANDWIDTH_LIMIT        0x800D0004L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                0xC00D0005L

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
//  Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               0xC00D0006L

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
//  Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          0xC00D0007L

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
//  Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           0xC00D0008L

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
//  Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           0xC00D0009L

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
//  Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            0xC00D000AL

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
//  There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          0xC00D000BL

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
//  There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    0xC00D000CL

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
//  Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                0xC00D000DL

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.%0
//
#define NS_E_NETWORK_BUSY                0xC00D000EL

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
//  The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               0xC00D000FL

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
//  The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           0xC00D0010L

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
//  Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               0xC00D0011L

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
//  There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           0xC00D0012L

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
//  There was no timely response from the server.%0
//
#define NS_E_TIMEOUT                     0xC00D0013L

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
//  Error writing to the network.%0
//
#define NS_E_NET_WRITE                   0xC00D0014L

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
//  Error reading from the network.%0
//
#define NS_E_NET_READ                    0xC00D0015L

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
//  Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  0xC00D0016L

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
//  Error reading from a disk.%0
//
#define NS_E_DISK_READ                   0xC00D0017L

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
//  Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  0xC00D0018L

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
//  Error reading from a file.%0
//
#define NS_E_FILE_READ                   0xC00D0019L

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              0xC00D001AL

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
//  The file already exists.%0
//
#define NS_E_FILE_EXISTS                 0xC00D001BL

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
//  The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                0xC00D001CL

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
//  Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            0xC00D001DL

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
//  Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      0xC00D001EL

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
//  Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            0xC00D001FL

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
//  Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            0xC00D0020L

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
//  Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         0xC00D0021L

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
//  An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     0xC00D0022L

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
//  Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 0xC00D0023L

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
//  An unknown error occurred.%0
//
#define NS_E_INTERNAL                    0xC00D0024L

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
//  The requested resource is in use.%0
//
#define NS_E_BUSY                        0xC00D0025L

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
//  The specified protocol is not recognized. Be sure that the file name and syntax, such as slashes, are correct for the protocol.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    0xC00D0026L

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
//  The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     0xC00D0027L

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
//  An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    0xC00D0028L

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
//  The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          0xC00D0029L

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
//  The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    0xC00D002AL

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
//  The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             0xC00D002BL

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
//  There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      0xC00D002CL

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
//  The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              0xC00D002DL

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
//  An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              0xC00D002EL

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                0xC00D002FL

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        0xC00D0030L

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
//  The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             0xC00D0031L

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
//  The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            0xC00D0032L

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
//  There is no stream available.%0
//
#define NS_E_NO_STREAM                   0xC00D0033L

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
//  There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  0xC00D0034L

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            0xC00D0035L

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
//  The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              0xC00D0036L

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
//  The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           0xC00D0037L

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
//  The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       0xC00D0038L

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
//  The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         0xC00D0039L

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
//  The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           0xC00D003AL

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
//  The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             0xC00D003BL

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
//  The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              0xC00D003CL

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
//  The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             0xC00D003DL

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
//  The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    0xC00D003EL

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
//  The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              0xC00D003FL

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
//  The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   0xC00D0040L

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
//  The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         0xC00D0041L

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
//  The specified key is not valid.
//
#define NS_E_INVALID_KEY                 0xC00D0042L

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
//  The specified port is not valid.
//
#define NS_E_INVALID_PORT                0xC00D0043L

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
//  The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 0xC00D0044L

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
//  The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              0xC00D0045L

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_MMSAUTOSERVER_CANTFINDWALKER
//
// MessageText:
//
//  Unable to load the appropriate file parser.%0
//
#define NS_E_MMSAUTOSERVER_CANTFINDWALKER 0xC00D0046L

//
// MessageId: NS_E_MAX_BITRATE
//
// MessageText:
//
//  Cannot exceed the maximum bandwidth limit.%0
//
#define NS_E_MAX_BITRATE                 0xC00D0047L

//
// MessageId: NS_E_LOGFILEPERIOD
//
// MessageText:
//
//  Invalid value for LogFilePeriod.%0
//
#define NS_E_LOGFILEPERIOD               0xC00D0048L

//
// MessageId: NS_E_MAX_CLIENTS
//
// MessageText:
//
//  Cannot exceed the maximum client limit.%0
//  
//
#define NS_E_MAX_CLIENTS                 0xC00D0049L

//
// MessageId: NS_E_LOG_FILE_SIZE
//
// MessageText:
//
//  Log File Size too small.%0
//  
//
#define NS_E_LOG_FILE_SIZE               0xC00D004AL

//
// MessageId: NS_E_MAX_FILERATE
//
// MessageText:
//
//  Cannot exceed the maximum file rate.%0
//
#define NS_E_MAX_FILERATE                0xC00D004BL

//
// File Walker Errors
//
//
// MessageId: NS_E_WALKER_UNKNOWN
//
// MessageText:
//
//  Unknown file type.%0
//
#define NS_E_WALKER_UNKNOWN              0xC00D004CL

//
// MessageId: NS_E_WALKER_SERVER
//
// MessageText:
//
//  The specified file, %1, cannot be loaded onto the specified server, %2.%0
//
#define NS_E_WALKER_SERVER               0xC00D004DL

//
// MessageId: NS_E_WALKER_USAGE
//
// MessageText:
//
//  There was a usage error with file parser.%0
//
#define NS_E_WALKER_USAGE                0xC00D004EL


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
/////////////////////////////////////////////////////////////////////////


 // Tiger Events

 // %1 is the tiger name

//
// MessageId: NS_I_TIGER_START
//
// MessageText:
//
//  The Title Server %1 is running.%0
//
#define NS_I_TIGER_START                 0x400D004FL

//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
//  The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  0xC00D0050L


 // Cub Events

 // %1 is the cub ID
 // %2 is the cub name

//
// MessageId: NS_I_CUB_START
//
// MessageText:
//
//  Content Server %1 (%2) is starting.%0
//
#define NS_I_CUB_START                   0x400D0051L

//
// MessageId: NS_I_CUB_RUNNING
//
// MessageText:
//
//  Content Server %1 (%2) is running.%0
//
#define NS_I_CUB_RUNNING                 0x400D0052L

//
// MessageId: NS_E_CUB_FAIL
//
// MessageText:
//
//  Content Server %1 (%2) has failed.%0
//
#define NS_E_CUB_FAIL                    0xC00D0053L


 // Disk Events

 // %1 is the tiger disk ID
 // %2 is the device name
 // %3 is the cub ID
//
// MessageId: NS_I_DISK_START
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, is running.%0
//
#define NS_I_DISK_START                  0x400D0054L

//
// MessageId: NS_E_DISK_FAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has failed.%0
//
#define NS_E_DISK_FAIL                   0xC00D0055L

//
// MessageId: NS_I_DISK_REBUILD_STARTED
//
// MessageText:
//
//  Started rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_STARTED        0x400D0056L

//
// MessageId: NS_I_DISK_REBUILD_FINISHED
//
// MessageText:
//
//  Finished rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_FINISHED       0x400D0057L

//
// MessageId: NS_I_DISK_REBUILD_ABORTED
//
// MessageText:
//
//  Aborted rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_ABORTED        0x400D0058L


 // Admin Events

//
// MessageId: NS_I_LIMIT_FUNNELS
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the data stream limit to %2 streams.%0
//
#define NS_I_LIMIT_FUNNELS               0x400D0059L

//
// MessageId: NS_I_START_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started disk %2.%0
//
#define NS_I_START_DISK                  0x400D005AL

//
// MessageId: NS_I_STOP_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped disk %2.%0
//
#define NS_I_STOP_DISK                   0x400D005BL

//
// MessageId: NS_I_STOP_CUB
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped Content Server %2.%0
//
#define NS_I_STOP_CUB                    0x400D005CL

//
// MessageId: NS_I_KILL_VIEWER
//
// MessageText:
//
//  A NetShow administrator at network location %1 disconnected viewer %2 from the system.%0
//
#define NS_I_KILL_VIEWER                 0x400D005DL

//
// MessageId: NS_I_REBUILD_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started rebuilding disk %2.%0
//
#define NS_I_REBUILD_DISK                0x400D005EL

//
// MessageId: NS_W_UNKNOWN_EVENT
//
// MessageText:
//
//  Unknown %1 event encountered.%0
//
#define NS_W_UNKNOWN_EVENT               0x800D005FL


 // Alerts

//
// MessageId: NS_E_MAX_FUNNELS_ALERT
//
// MessageText:
//
//  The NetShow data stream limit of %1 streams was reached.%0
//
#define NS_E_MAX_FUNNELS_ALERT           0xC00D0060L

//
// MessageId: NS_E_ALLOCATE_FILE_FAIL
//
// MessageText:
//
//  The NetShow Video Server was unable to allocate a %1 block file named %2.%0
//
#define NS_E_ALLOCATE_FILE_FAIL          0xC00D0061L

//
// MessageId: NS_E_PAGING_ERROR
//
// MessageText:
//
//  A Content Server was unable to page a block.%0
//
#define NS_E_PAGING_ERROR                0xC00D0062L

//
// MessageId: NS_E_BAD_BLOCK0_VERSION
//
// MessageText:
//
//  Disk %1 has unrecognized control block version %2.%0
//
#define NS_E_BAD_BLOCK0_VERSION          0xC00D0063L

//
// MessageId: NS_E_BAD_DISK_UID
//
// MessageText:
//
//  Disk %1 has incorrect uid %2.%0
//
#define NS_E_BAD_DISK_UID                0xC00D0064L

//
// MessageId: NS_E_BAD_FSMAJOR_VERSION
//
// MessageText:
//
//  Disk %1 has unsupported file system major version %2.%0
//
#define NS_E_BAD_FSMAJOR_VERSION         0xC00D0065L

//
// MessageId: NS_E_BAD_STAMPNUMBER
//
// MessageText:
//
//  Disk %1 has bad stamp number in control block.%0
//
#define NS_E_BAD_STAMPNUMBER             0xC00D0066L

//
// MessageId: NS_E_PARTIALLY_REBUILT_DISK
//
// MessageText:
//
//  Disk %1 is partially reconstructed.%0
//
#define NS_E_PARTIALLY_REBUILT_DISK      0xC00D0067L

//
// MessageId: NS_E_ENACTPLAN_GIVEUP
//
// MessageText:
//
//  EnactPlan gives up.%0
//
#define NS_E_ENACTPLAN_GIVEUP            0xC00D0068L


 // MCMADM warnings/errors

//
// MessageId: MCMADM_I_NO_EVENTS
//
// MessageText:
//
//  Event initialization failed, there will be no MCM events.%0
//
#define MCMADM_I_NO_EVENTS               0x400D0069L

//
// MessageId: MCMADM_E_REGKEY_NOT_FOUND
//
// MessageText:
//
//  The key was not found in the registry.%0
//
#define MCMADM_E_REGKEY_NOT_FOUND        0xC00D006AL

//
// MessageId: NS_E_NO_FORMATS
//
// MessageText:
//
//  No stream formats were found in an NSC file.%0
//
#define NS_E_NO_FORMATS                  0xC00D006BL

//
// MessageId: NS_E_NO_REFERENCES
//
// MessageText:
//
//  No reference URLs were found in an ASX file.%0
//
#define NS_E_NO_REFERENCES               0xC00D006CL

//
// MessageId: NS_E_WAVE_OPEN
//
// MessageText:
//
//  Error opening wave device, the device might be in use.%0
//
#define NS_E_WAVE_OPEN                   0xC00D006DL

//
// MessageId: NS_I_LOGGING_FAILED
//
// MessageText:
//
//  The logging operation failed.
//
#define NS_I_LOGGING_FAILED              0x400D006EL

//
// MessageId: NS_E_CANNOTCONNECTEVENTS
//
// MessageText:
//
//  Unable to establish a connection to the NetShow event monitor service.%0
//
#define NS_E_CANNOTCONNECTEVENTS         0xC00D006FL

//
// MessageId: NS_I_LIMIT_BANDWIDTH
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the maximum bandwidth limit to %2 bps.%0
//
#define NS_I_LIMIT_BANDWIDTH             0x400D0070L

//
// MessageId: NS_E_NO_DEVICE
//
// MessageText:
//
//  No device driver is present on the system.%0
//
#define NS_E_NO_DEVICE                   0xC00D0071L

//
// MessageId: NS_E_NO_SPECIFIED_DEVICE
//
// MessageText:
//
//  No specified device driver is present.%0
//
#define NS_E_NO_SPECIFIED_DEVICE         0xC00D0072L


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               0xC00D07F1L

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
//  Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                0xC00D07F2L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
//  Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              0xC00D00C8L

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
//  Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             0xC00D00C9L

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
//  Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           0xC00D00CAL

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
//  %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      0xC00D00CBL

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
//  The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            0xC00D00CCL

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
//  The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                0xC00D00CDL

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
//  Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           0xC00D00CEL

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
//  Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             0xC00D00CFL

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
//  Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         0xC00D00D0L

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
//  UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                0xC00D00D1L

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
//  TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                0xC00D00D2L

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
//  HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               0xC00D00D3L

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
//  The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             0xC00D00D4L

//
// MessageId: NS_E_TITLE_BITRATE
//
// MessageText:
//
//  Source file exceeds the per title maximum bitrate. See NetShow Theater documentation for more information.%0
//
#define NS_E_TITLE_BITRATE               0xC00D00D5L

//
// MessageId: NS_E_EMPTY_PROGRAM_NAME
//
// MessageText:
//
//  The program name cannot be empty.%0
//
#define NS_E_EMPTY_PROGRAM_NAME          0xC00D00D6L

//
// MessageId: NS_E_MISSING_CHANNEL
//
// MessageText:
//
//  Station %1 does not exist.%0
//
#define NS_E_MISSING_CHANNEL             0xC00D00D7L

//
// MessageId: NS_E_NO_CHANNELS
//
// MessageText:
//
//  You need to define at least one station before this operation can complete.%0
//
#define NS_E_NO_CHANNELS                 0xC00D00D8L


/////////////////////////////////////////////////////////////////////
// This error message is to replace previous NS_E_INVALID_INDEX which 
// takes an index value for the error message string.  For some application
// obtain the index value at reporting error time is very difficult, so we
// use this string to avoid the problem.
//////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INDEX2
//
// MessageText:
//
//  The index specified is invalid.%0
//
#define NS_E_INVALID_INDEX2              0xC00D00D9L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
// IdRange = 400..599
//
// Admin Events:
//
// Alerts:
//
// Title Server:
//      %1 is the Title Server name
//
// Content Server:
//      %1 is the Content Server ID
//      %2 is the Content Server name
//      %3 is the Peer Content Server name (optional)
//
// Disks:
//      %1 is the Title Server disk ID
//      %2 is the device name
//      %3 is the Content Server ID
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_CUB_FAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has failed its link to Content Server %3.%0
//
#define NS_E_CUB_FAIL_LINK               0xC00D0190L

//
// MessageId: NS_I_CUB_UNFAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has established its link to Content Server %3.%0
//
#define NS_I_CUB_UNFAIL_LINK             0x400D0191L

//
// MessageId: NS_E_BAD_CUB_UID
//
// MessageText:
//
//  Content Server %1 (%2) has incorrect uid %3.%0
//
#define NS_E_BAD_CUB_UID                 0xC00D0192L

//
// MessageId: NS_I_RESTRIPE_START
//
// MessageText:
//
//  Restripe operation has started.%0
//
#define NS_I_RESTRIPE_START              0x400D0193L

//
// MessageId: NS_I_RESTRIPE_DONE
//
// MessageText:
//
//  Restripe operation has completed.%0
//
#define NS_I_RESTRIPE_DONE               0x400D0194L

//
// MessageId: NS_E_GLITCH_MODE
//
// MessageText:
//
//  Server unreliable because multiple components failed.%0
//
#define NS_E_GLITCH_MODE                 0xC00D0195L

//
// MessageId: NS_I_RESTRIPE_DISK_OUT
//
// MessageText:
//
//  Content disk %1 (%2) on Content Server %3 has been restriped out.%0
//
#define NS_I_RESTRIPE_DISK_OUT           0x400D0196L

//
// MessageId: NS_I_RESTRIPE_CUB_OUT
//
// MessageText:
//
//  Content server %1 (%2) has been restriped out.%0
//
#define NS_I_RESTRIPE_CUB_OUT            0x400D0197L

//
// MessageId: NS_I_DISK_STOP
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has been offlined.%0
//
#define NS_I_DISK_STOP                   0x400D0198L

//
// MessageId: NS_I_CATATONIC_FAILURE
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, will be failed because it is catatonic.%0
//
#define NS_I_CATATONIC_FAILURE           0x800D0199L

//
// MessageId: NS_I_CATATONIC_AUTO_UNFAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, auto online from catatonic state.%0
//
#define NS_I_CATATONIC_AUTO_UNFAIL       0x800D019AL

//
// MessageId: NS_E_NO_MEDIA_PROTOCOL
//
// MessageText:
//
//  Content Server %1 (%2) is unable to communicate with the Media System Network Protocol.%0
//
#define NS_E_NO_MEDIA_PROTOCOL           0xC00D019BL


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INPUT_FORMAT
//
// MessageText:
//
//  The input media format is invalid.%0
//
#define NS_E_INVALID_INPUT_FORMAT        0xC00D0BB8L

//
// MessageId: NS_E_MSAUDIO_NOT_INSTALLED
//
// MessageText:
//
//  The MSAudio codec is not installed on this system.%0
//
#define NS_E_MSAUDIO_NOT_INSTALLED       0xC00D0BB9L

//
// MessageId: NS_E_UNEXPECTED_MSAUDIO_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the MSAudio codec.%0
//
#define NS_E_UNEXPECTED_MSAUDIO_ERROR    0xC00D0BBAL

//
// MessageId: NS_E_INVALID_OUTPUT_FORMAT
//
// MessageText:
//
//  The output media format is invalid.%0
//
#define NS_E_INVALID_OUTPUT_FORMAT       0xC00D0BBBL

//
// MessageId: NS_E_NOT_CONFIGURED
//
// MessageText:
//
//  The object must be fully configured before audio samples can be processed.%0
//
#define NS_E_NOT_CONFIGURED              0xC00D0BBCL

//
// MessageId: NS_E_PROTECTED_CONTENT
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_PROTECTED_CONTENT           0xC00D0BBDL

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            0xC00D0BBEL

//
// MessageId: NS_E_TAMPERED_CONTENT
//
// MessageText:
//
//  This media file is corrupted or invalid. Contact the content provider for a new file.%0
//
#define NS_E_TAMPERED_CONTENT            0xC00D0BBFL

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
//  The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           0xC00D0BC0L

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
//  You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    0xC00D0BC1L

//
// MessageId: NS_E_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested audio codec is not installed on this system.%0
//
#define NS_E_AUDIO_CODEC_NOT_INSTALLED   0xC00D0BC2L

//
// MessageId: NS_E_AUDIO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the audio codec.%0
//
#define NS_E_AUDIO_CODEC_ERROR           0xC00D0BC3L

//
// MessageId: NS_E_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested video codec is not installed on this system.%0
//
#define NS_E_VIDEO_CODEC_NOT_INSTALLED   0xC00D0BC4L

//
// MessageId: NS_E_VIDEO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the video codec.%0
//
#define NS_E_VIDEO_CODEC_ERROR           0xC00D0BC5L

//
// MessageId: NS_E_INVALIDPROFILE
//
// MessageText:
//
//  The Profile is invalid.%0
//
#define NS_E_INVALIDPROFILE              0xC00D0BC6L

//
// MessageId: NS_E_INCOMPATIBLE_VERSION
//
// MessageText:
//
//  A new version of the SDK is needed to play the requested content.%0
//
#define NS_E_INCOMPATIBLE_VERSION        0xC00D0BC7L

//
// MessageId: NS_S_REBUFFERING
//
// MessageText:
//
//  The requested operation has caused the source to rebuffer.%0
//
#define NS_S_REBUFFERING                 0x000D0BC8L

//
// MessageId: NS_S_DEGRADING_QUALITY
//
// MessageText:
//
//  The requested operation has caused the source to degrade codec quality.%0
//
#define NS_S_DEGRADING_QUALITY           0x000D0BC9L

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
//  The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                0xC00D0BCAL

//
// MessageId: NS_E_NOT_CONNECTED
//
// MessageText:
//
//  The requested URL cannot be accessed because there is no network connection.%0
//
#define NS_E_NOT_CONNECTED               0xC00D0BCBL

//
// MessageId: NS_E_TOO_MUCH_DATA
//
// MessageText:
//
//  The encoding process was unable to keep up with the amount of supplied data.%0
//
#define NS_E_TOO_MUCH_DATA               0xC00D0BCCL

//
// MessageId: NS_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The given property is not supported.%0
//
#define NS_E_UNSUPPORTED_PROPERTY        0xC00D0BCDL

//
// MessageId: NS_E_8BIT_WAVE_UNSUPPORTED
//
// MessageText:
//
//  Windows Media Player cannot copy the files to the CD because they are 8-bit. Convert the files to 16-bit, 44-kHz stereo files by using Sound Recorder or another audio-processing program, and then try again.%0
//
#define NS_E_8BIT_WAVE_UNSUPPORTED       0xC00D0BCEL



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Player Errors
//
// IdRange = 4000 - 4999
//
/////////////////////////////////////////////////////////////////////////

//
// WMP CD Filter Error codes
//
//
// MessageId: NS_E_NO_CD
//
// MessageText:
//
//  There is no CD in the CD-ROM drive. Insert a CD, and try again.%0
//
#define NS_E_NO_CD                       0xC00D0FA0L

//
// MessageId: NS_E_CANT_READ_DIGITAL
//
// MessageText:
//
//  Unable to perform digital reads on this compact disc drive.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_CANT_READ_DIGITAL           0xC00D0FA1L

//
// MessageId: NS_E_DEVICE_DISCONNECTED
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try downloading the file again.%0
//
#define NS_E_DEVICE_DISCONNECTED         0xC00D0FA2L

//
// MessageId: NS_E_DEVICE_NOT_SUPPORT_FORMAT
//
// MessageText:
//
//  Your Music Player does not support this song's format.%0
//
#define NS_E_DEVICE_NOT_SUPPORT_FORMAT   0xC00D0FA3L

//
// MessageId: NS_E_SLOW_READ_DIGITAL
//
// MessageText:
//
//  Digital reads on this compact disc drive are too slow.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_SLOW_READ_DIGITAL           0xC00D0FA4L

//
// MessageId: NS_E_MIXER_INVALID_LINE
//
// MessageText:
//
//  An invalid line error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_LINE          0xC00D0FA5L

//
// MessageId: NS_E_MIXER_INVALID_CONTROL
//
// MessageText:
//
//  An invalid control error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_CONTROL       0xC00D0FA6L

//
// MessageId: NS_E_MIXER_INVALID_VALUE
//
// MessageText:
//
//  An invalid value error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_VALUE         0xC00D0FA7L

//
// MessageId: NS_E_MIXER_UNKNOWN_MMRESULT
//
// MessageText:
//
//  An unrecognized MMRESULT occurred in the mixer.%0
//
#define NS_E_MIXER_UNKNOWN_MMRESULT      0xC00D0FA8L

//
// MessageId: NS_E_USER_STOP
//
// MessageText:
//
//  User has stopped the operation.%0
//
#define NS_E_USER_STOP                   0xC00D0FA9L

//
// MessageId: NS_E_MP3_FORMAT_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file cannot be found.%0
//
#define NS_E_MP3_FORMAT_NOT_FOUND        0xC00D0FAAL

//
// MessageId: NS_E_CD_READ_ERROR_NO_CORRECTION
//
// MessageText:
//
//  Windows Media Player cannot read the CD. It may contain flaws. Turn on error correction, and try again.%0
//
#define NS_E_CD_READ_ERROR_NO_CORRECTION 0xC00D0FABL

//
// MessageId: NS_E_CD_READ_ERROR
//
// MessageText:
//
//  Windows Media Player cannot read the CD. Be sure the CD is free of dirt and scratches and the CD-ROM drive is functioning properly.%0
//
#define NS_E_CD_READ_ERROR               0xC00D0FACL

//
// MessageId: NS_E_CD_SLOW_COPY
//
// MessageText:
//
//  To speed up the copy process, do not play CD tracks while copying.%0
//
#define NS_E_CD_SLOW_COPY                0xC00D0FADL

//
// MessageId: NS_E_CD_COPYTO_CD
//
// MessageText:
//
//  Cannot copy directly from a CDROM to a CD drive.%0
//
#define NS_E_CD_COPYTO_CD                0xC00D0FAEL

//
// MessageId: NS_E_MIXER_NODRIVER
//
// MessageText:
//
//  Could not open a sound mixer driver.%0
//
#define NS_E_MIXER_NODRIVER              0xC00D0FAFL

//
// MessageId: NS_E_REDBOOK_ENABLED_WHILE_COPYING
//
// MessageText:
//
//  Windows Media Player has detected that a setting for the CD-ROM drive will cause audio CDs to copy incorrectly; no audio is copied. Change the CD-ROM drive setting in Device Manager, and then try again.%0
//
#define NS_E_REDBOOK_ENABLED_WHILE_COPYING 0xC00D0FB0L

//
// MessageId: NS_E_CD_REFRESH
//
// MessageText:
//
//  Trying to refresh the CD playlist.%0
//
#define NS_E_CD_REFRESH                  0xC00D0FB1L

//
// MessageId: NS_E_CD_DRIVER_PROBLEM
//
// MessageText:
//
//  Windows Media Player must switch to analog  mode  because there is a problem reading the CD-ROM drive in digital mode. Verify that the CD-ROM drive is installed correctly or try to update the drivers for the CD-ROM drive, and then try to use digital mode again.%0
//
#define NS_E_CD_DRIVER_PROBLEM           0xC00D0FB2L

//
// MessageId: NS_E_WONT_DO_DIGITAL
//
// MessageText:
//
//  Windows Media Player must switch to analog mode because there is a problem reading the CD-ROM drive  in digital mode.%0
//
#define NS_E_WONT_DO_DIGITAL             0xC00D0FB3L

//
// WMP IWMPXMLParser Error codes
//
//
// MessageId: NS_E_WMPXML_NOERROR
//
// MessageText:
//
//  A call was made to GetParseError on the XML parser but there was no error to retrieve.%0
//
#define NS_E_WMPXML_NOERROR              0xC00D0FB4L

//
// MessageId: NS_E_WMPXML_ENDOFDATA
//
// MessageText:
//
//  The XML Parser ran out of data while parsing.%0
//
#define NS_E_WMPXML_ENDOFDATA            0xC00D0FB5L

//
// MessageId: NS_E_WMPXML_PARSEERROR
//
// MessageText:
//
//  A generic parse error occurred in the XML parser but no information is available.%0
//
#define NS_E_WMPXML_PARSEERROR           0xC00D0FB6L

//
// MessageId: NS_E_WMPXML_ATTRIBUTENOTFOUND
//
// MessageText:
//
//  A call get GetNamedAttribute or GetNamedAttributeIndex on the XML parser resulted in the index not being found.%0
//
#define NS_E_WMPXML_ATTRIBUTENOTFOUND    0xC00D0FB7L

//
// MessageId: NS_E_WMPXML_PINOTFOUND
//
// MessageText:
//
//  A call was made go GetNamedPI on the XML parser, but the requested Processing Instruction was not found.%0
//
#define NS_E_WMPXML_PINOTFOUND           0xC00D0FB8L

//
// MessageId: NS_E_WMPXML_EMPTYDOC
//
// MessageText:
//
//  Persist was called on the XML parser, but the parser has no data to persist.%0
//
#define NS_E_WMPXML_EMPTYDOC             0xC00D0FB9L

//
// Miscellaneous Media Player Error codes
//
//
// MessageId: NS_E_WMP_WINDOWSAPIFAILURE
//
// MessageText:
//
//  A Windows API call failed but no error information was available.%0
//
#define NS_E_WMP_WINDOWSAPIFAILURE       0xC00D0FC8L

//
// MessageId: NS_E_WMP_RECORDING_NOT_ALLOWED
//
// MessageText:
//
//  Windows Media Player cannot copy the file. Either the license restricts copying, or you must obtain a license to copy the file.%0
//
#define NS_E_WMP_RECORDING_NOT_ALLOWED   0xC00D0FC9L

//
// MessageId: NS_E_DEVICE_NOT_READY
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and try again.%0
//
#define NS_E_DEVICE_NOT_READY            0xC00D0FCAL

//
// MessageId: NS_E_DAMAGED_FILE
//
// MessageText:
//
//  Windows Media Player cannot play the file because it is either damaged or corrupt.%0
//
#define NS_E_DAMAGED_FILE                0xC00D0FCBL

//
// MessageId: NS_E_MPDB_GENERIC
//
// MessageText:
//
//  An error occurred when the Player was attempting to access information in your media library. Try closing and then reopening the Player.%0
//
#define NS_E_MPDB_GENERIC                0xC00D0FCCL

//
// MessageId: NS_E_FILE_FAILED_CHECKS
//
// MessageText:
//
//  The file cannot be added to Media Library because it is smaller than the minimum-size requirement. Adjust the size requirements, and then try again.%0
//
#define NS_E_FILE_FAILED_CHECKS          0xC00D0FCDL

//
// MessageId: NS_E_MEDIA_LIBRARY_FAILED
//
// MessageText:
//
//  Windows Media Player could not create Media Library. Check with your system administrator to get the necessary permissions to create Media Library on your computer, and then try installing the Player again.%0
//
#define NS_E_MEDIA_LIBRARY_FAILED        0xC00D0FCEL

//
// MessageId: NS_E_SHARING_VIOLATION
//
// MessageText:
//
//  The file is already in use. Close other programs that may be using the file, or stop playing the file, and try again.%0
//
#define NS_E_SHARING_VIOLATION           0xC00D0FCFL

//
// Generic Media PlayerUI error codes
//
//
// MessageId: NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED
//
// MessageText:
//
//  The control (%s) does not support creation of sub-controls, yet (%d) sub-controls have been specified.%0
//
#define NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED 0xC00D0FDEL

//
// MessageId: NS_E_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  Version mismatch: (%.1f required, %.1f found).%0
//
#define NS_E_WMP_UI_VERSIONMISMATCH      0xC00D0FDFL

//
// MessageId: NS_E_WMP_UI_NOTATHEMEFILE
//
// MessageText:
//
//  The layout manager was given valid XML that wasn't a theme file.%0
//
#define NS_E_WMP_UI_NOTATHEMEFILE        0xC00D0FE0L

//
// MessageId: NS_E_WMP_UI_SUBELEMENTNOTFOUND
//
// MessageText:
//
//  The %s subelement could not be found on the %s object.%0
//
#define NS_E_WMP_UI_SUBELEMENTNOTFOUND   0xC00D0FE1L

//
// MessageId: NS_E_WMP_UI_VERSIONPARSE
//
// MessageText:
//
//  An error occurred parsing the version tag.\nValid version tags are of the form:\n\n\t<?wmp version='1.0'?>.%0
//
#define NS_E_WMP_UI_VERSIONPARSE         0xC00D0FE2L

//
// MessageId: NS_E_WMP_UI_VIEWIDNOTFOUND
//
// MessageText:
//
//  The view specified in for the 'currentViewID' property (%s) was not found in this theme file.%0
//
#define NS_E_WMP_UI_VIEWIDNOTFOUND       0xC00D0FE3L

//
// MessageId: NS_E_WMP_UI_PASSTHROUGH
//
// MessageText:
//
//  This error used internally for hit testing.%0
//
#define NS_E_WMP_UI_PASSTHROUGH          0xC00D0FE4L

//
// MessageId: NS_E_WMP_UI_OBJECTNOTFOUND
//
// MessageText:
//
//  Attributes were specified for the %s object, but the object was not available to send them to.%0
//
#define NS_E_WMP_UI_OBJECTNOTFOUND       0xC00D0FE5L

//
// MessageId: NS_E_WMP_UI_SECONDHANDLER
//
// MessageText:
//
//  The %s event already has a handler, the second handler was ignored.%0
//
#define NS_E_WMP_UI_SECONDHANDLER        0xC00D0FE6L

//
// MessageId: NS_E_WMP_UI_NOSKININZIP
//
// MessageText:
//
//  No .wms file found in skin archive.%0
//
#define NS_E_WMP_UI_NOSKININZIP          0xC00D0FE7L

//
// MessageId: NS_S_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  An upgrade may be needed for the theme manager to correctly show this skin. Skin reports version: %.1f.%0
//
#define NS_S_WMP_UI_VERSIONMISMATCH      0x000D0FE8L

//
// MessageId: NS_S_WMP_EXCEPTION
//
// MessageText:
//
//  An error occurred in one of the UI components.%0
//
#define NS_S_WMP_EXCEPTION               0x000D0FE9L

//
// MessageId: NS_E_WMP_URLDOWNLOADFAILED
//
// MessageText:
//
//  Windows Media Player cannot download the file. Check the path to the server, and then try again. For example, if you specified "mms://" in the file name, and the file was actually located on a path beginning with "http://" the file cannot be downloaded, even though it can be played.%0
//
#define NS_E_WMP_URLDOWNLOADFAILED       0xC00D0FEAL

//
// WMP Regional button control
//
//
// MessageId: NS_E_WMP_RBC_JPGMAPPINGIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a mappingImage.%0
//
#define NS_E_WMP_RBC_JPGMAPPINGIMAGE     0xC00D1004L

//
// MessageId: NS_E_WMP_JPGTRANSPARENCY
//
// MessageText:
//
//  JPG Images are not recommended when using a transparencyColor.%0
//
#define NS_E_WMP_JPGTRANSPARENCY         0xC00D1005L

//
// WMP Slider control
//
//
// MessageId: NS_E_WMP_INVALID_MAX_VAL
//
// MessageText:
//
//  The Max property cannot be less than Min property.%0
//
#define NS_E_WMP_INVALID_MAX_VAL         0xC00D1009L

//
// MessageId: NS_E_WMP_INVALID_MIN_VAL
//
// MessageText:
//
//  The Min property cannot be greater than Max property.%0
//
#define NS_E_WMP_INVALID_MIN_VAL         0xC00D100AL

//
// WMP CustomSlider control
//
//
// MessageId: NS_E_WMP_CS_JPGPOSITIONIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a positionImage.%0
//
#define NS_E_WMP_CS_JPGPOSITIONIMAGE     0xC00D100EL

//
// MessageId: NS_E_WMP_CS_NOTEVENLYDIVISIBLE
//
// MessageText:
//
//  The (%s) image's size is not evenly divisible by the positionImage's size.%0
//
#define NS_E_WMP_CS_NOTEVENLYDIVISIBLE   0xC00D100FL

//
// WMP ZIP Decoder
//
//
// MessageId: NS_E_WMPZIP_NOTAZIPFILE
//
// MessageText:
//
//  The ZIP reader opened a file and its signature didn't match that of ZIP files.%0
//
#define NS_E_WMPZIP_NOTAZIPFILE          0xC00D1018L

//
// MessageId: NS_E_WMPZIP_CORRUPT
//
// MessageText:
//
//  The ZIP reader has detected that the file is corrupt.%0
//
#define NS_E_WMPZIP_CORRUPT              0xC00D1019L

//
// MessageId: NS_E_WMPZIP_FILENOTFOUND
//
// MessageText:
//
//  GetFileStream, SaveToFile, or SaveTemp file was called on the ZIP reader with a filename that was not found in the zip file.%0
//
#define NS_E_WMPZIP_FILENOTFOUND         0xC00D101AL

//
// WMP Image Decoding Error codes
//
//
// MessageId: NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED
//
// MessageText:
//
//  Image type not supported.%0
//
#define NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED 0xC00D1022L

//
// MessageId: NS_E_WMP_IMAGE_INVALID_FORMAT
//
// MessageText:
//
//  Image file may be corrupt.%0
//
#define NS_E_WMP_IMAGE_INVALID_FORMAT    0xC00D1023L

//
// MessageId: NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file. GIF file may be corrupt.%0
//
#define NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE 0xC00D1024L

//
// MessageId: NS_E_WMP_GIF_INVALID_FORMAT
//
// MessageText:
//
//  Invalid GIF file.%0
//
#define NS_E_WMP_GIF_INVALID_FORMAT      0xC00D1025L

//
// MessageId: NS_E_WMP_GIF_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Invalid GIF version. Only 87a or 89a supported.%0
//
#define NS_E_WMP_GIF_BAD_VERSION_NUMBER  0xC00D1026L

//
// MessageId: NS_E_WMP_GIF_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No images found in GIF file.%0
//
#define NS_E_WMP_GIF_NO_IMAGE_IN_FILE    0xC00D1027L

//
// MessageId: NS_E_WMP_PNG_INVALIDFORMAT
//
// MessageText:
//
//  Invalid PNG image file format.%0
//
#define NS_E_WMP_PNG_INVALIDFORMAT       0xC00D1028L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH
//
// MessageText:
//
//  PNG bitdepth not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH 0xC00D1029L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
//  Compression format defined in PNG file not supported,%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION 0xC00D102AL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_FILTER
//
// MessageText:
//
//  Filter method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_FILTER  0xC00D102BL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_INTERLACE
//
// MessageText:
//
//  Interlace method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_INTERLACE 0xC00D102CL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC
//
// MessageText:
//
//  Bad CRC in PNG file.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC 0xC00D102DL

//
// MessageId: NS_E_WMP_BMP_INVALID_BITMASK
//
// MessageText:
//
//  Invalid bitmask in BMP file.%0
//
#define NS_E_WMP_BMP_INVALID_BITMASK     0xC00D102EL

//
// MessageId: NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED
//
// MessageText:
//
//  Topdown DIB not supported.%0
//
#define NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED 0xC00D102FL

//
// MessageId: NS_E_WMP_BMP_BITMAP_NOT_CREATED
//
// MessageText:
//
//  Bitmap could not be created.%0
//
#define NS_E_WMP_BMP_BITMAP_NOT_CREATED  0xC00D1030L

//
// MessageId: NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED
//
// MessageText:
//
//  Compression format defined in BMP not supported.%0
//
#define NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED 0xC00D1031L

//
// MessageId: NS_E_WMP_BMP_INVALID_FORMAT
//
// MessageText:
//
//  Invalid Bitmap format.%0
//
#define NS_E_WMP_BMP_INVALID_FORMAT      0xC00D1032L

//
// MessageId: NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL
//
// MessageText:
//
//  JPEG Arithmetic coding not supported.%0
//
#define NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL 0xC00D1033L

//
// MessageId: NS_E_WMP_JPG_INVALID_FORMAT
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_INVALID_FORMAT      0xC00D1034L

//
// MessageId: NS_E_WMP_JPG_BAD_DCTSIZE
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_BAD_DCTSIZE         0xC00D1035L

//
// MessageId: NS_E_WMP_JPG_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Internal version error. Unexpected JPEG library version.%0
//
#define NS_E_WMP_JPG_BAD_VERSION_NUMBER  0xC00D1036L

//
// MessageId: NS_E_WMP_JPG_BAD_PRECISION
//
// MessageText:
//
//  Internal JPEG Library error. Unsupported JPEG data precision.%0
//
#define NS_E_WMP_JPG_BAD_PRECISION       0xC00D1037L

//
// MessageId: NS_E_WMP_JPG_CCIR601_NOTIMPL
//
// MessageText:
//
//  JPEG CCIR601 not supported.%0
//
#define NS_E_WMP_JPG_CCIR601_NOTIMPL     0xC00D1038L

//
// MessageId: NS_E_WMP_JPG_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No image found in JPEG file.%0
//
#define NS_E_WMP_JPG_NO_IMAGE_IN_FILE    0xC00D1039L

//
// MessageId: NS_E_WMP_JPG_READ_ERROR
//
// MessageText:
//
//  Could not read JPEG file.%0
//
#define NS_E_WMP_JPG_READ_ERROR          0xC00D103AL

//
// MessageId: NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL
//
// MessageText:
//
//  JPEG Fractional sampling not supported.%0
//
#define NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL 0xC00D103BL

//
// MessageId: NS_E_WMP_JPG_IMAGE_TOO_BIG
//
// MessageText:
//
//  JPEG image too large. Maximum image size supported is 65500 X 65500.%0
//
#define NS_E_WMP_JPG_IMAGE_TOO_BIG       0xC00D103CL

//
// MessageId: NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file reached in JPEG file.%0
//
#define NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE 0xC00D103DL

//
// MessageId: NS_E_WMP_JPG_SOF_UNSUPPORTED
//
// MessageText:
//
//  Unsupported JPEG SOF marker found.%0
//
#define NS_E_WMP_JPG_SOF_UNSUPPORTED     0xC00D103EL

//
// MessageId: NS_E_WMP_JPG_UNKNOWN_MARKER
//
// MessageText:
//
//  Unknown JPEG marker found.%0
//
#define NS_E_WMP_JPG_UNKNOWN_MARKER      0xC00D103FL

//
// MessageId: NS_S_WMP_LOADED_GIF_IMAGE
//
// MessageText:
//
//  Successfully loaded a GIF file.%0
//
#define NS_S_WMP_LOADED_GIF_IMAGE        0x000D1040L

//
// MessageId: NS_S_WMP_LOADED_PNG_IMAGE
//
// MessageText:
//
//  Successfully loaded a PNG file.%0
//
#define NS_S_WMP_LOADED_PNG_IMAGE        0x000D1041L

//
// MessageId: NS_S_WMP_LOADED_BMP_IMAGE
//
// MessageText:
//
//  Successfully loaded a BMP file.%0
//
#define NS_S_WMP_LOADED_BMP_IMAGE        0x000D1042L

//
// MessageId: NS_S_WMP_LOADED_JPG_IMAGE
//
// MessageText:
//
//  Successfully loaded a JPG file.%0
//
#define NS_S_WMP_LOADED_JPG_IMAGE        0x000D1043L

//
// WMP WM Runtime Error codes
//
//
// MessageId: NS_E_WMG_INVALIDSTATE
//
// MessageText:
//
//  Operation attempted in an invalid graph state.%0
//
#define NS_E_WMG_INVALIDSTATE            0xC00D1054L

//
// MessageId: NS_E_WMG_SINKALREADYEXISTS
//
// MessageText:
//
//  A renderer cannot be inserted in a stream while one already exists.%0
//
#define NS_E_WMG_SINKALREADYEXISTS       0xC00D1055L

//
// MessageId: NS_E_WMG_NOSDKINTERFACE
//
// MessageText:
//
//  A necessary WM SDK interface to complete the operation doesn't exist at this time.%0
//
#define NS_E_WMG_NOSDKINTERFACE          0xC00D1056L

//
// MessageId: NS_E_WMG_NOTALLOUTPUTSRENDERED
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Player could not download the codec.%0
//
#define NS_E_WMG_NOTALLOUTPUTSRENDERED   0xC00D1057L

//
// MessageId: NS_E_WMR_UNSUPPORTEDSTREAM
//
// MessageText:
//
//  Windows Media Player cannot play the file. The Player does not support the format you are trying to play.%0
//
#define NS_E_WMR_UNSUPPORTEDSTREAM       0xC00D1059L

//
// MessageId: NS_E_WMR_PINNOTFOUND
//
// MessageText:
//
//  An operation was attempted on a pin that doesn't exist in the DirectShow filter graph.%0
//
#define NS_E_WMR_PINNOTFOUND             0xC00D105AL

//
// MessageId: NS_E_WMR_WAITINGONFORMATSWITCH
//
// MessageText:
//
//  Specified operation cannot be completed while waiting for a media format change from the SDK.%0
//
#define NS_E_WMR_WAITINGONFORMATSWITCH   0xC00D105BL

//
// WMP Playlist Error codes
//
//
// MessageId: NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT
//
// MessageText:
//
//  The format of this file was not recognized as a valid playlist format.%0
//
#define NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT 0xC00D1068L

//
// MessageId: NS_E_ASX_INVALIDFORMAT
//
// MessageText:
//
//  This file was believed to be an ASX playlist, but the format was not recognized.%0
//
#define NS_E_ASX_INVALIDFORMAT           0xC00D1069L

//
// MessageId: NS_E_ASX_INVALIDVERSION
//
// MessageText:
//
//  The version of this playlist is not supported. Click Details to go to the microsoft web site and see if there is a newer version of the player to install.%0
//
#define NS_E_ASX_INVALIDVERSION          0xC00D106AL

//
// MessageId: NS_E_ASX_INVALID_REPEAT_BLOCK
//
// MessageText:
//
//  Format of a REPEAT loop within the current playlist file is invalid.%0
//
#define NS_E_ASX_INVALID_REPEAT_BLOCK    0xC00D106BL

//
// MessageId: NS_E_ASX_NOTHING_TO_WRITE
//
// MessageText:
//
//  Windows Media Player cannot export the playlist because it is empty.%0
//
#define NS_E_ASX_NOTHING_TO_WRITE        0xC00D106CL

//
// MessageId: NS_E_URLLIST_INVALIDFORMAT
//
// MessageText:
//
//  Windows Media Player does not recognize this file as a supported playlist.%0
//
#define NS_E_URLLIST_INVALIDFORMAT       0xC00D106DL

//
// MessageId: NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified attribute does not exist.%0
//
#define NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST 0xC00D106EL

//
// MessageId: NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS
//
// MessageText:
//
//  The specified attribute already exists.%0
//
#define NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS 0xC00D106FL

//
// MessageId: NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE
//
// MessageText:
//
//  Can not retrieve the specified attribute.%0
//
#define NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE 0xC00D1070L

//
// MessageId: NS_E_WMX_ITEM_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified item does not exist in the current playlist.%0
//
#define NS_E_WMX_ITEM_DOES_NOT_EXIST     0xC00D1071L

//
// MessageId: NS_E_WMX_ITEM_TYPE_ILLEGAL
//
// MessageText:
//
//  Items of the specified type can not be created within the current playlist.%0
//
#define NS_E_WMX_ITEM_TYPE_ILLEGAL       0xC00D1072L

//
// MessageId: NS_E_WMX_ITEM_UNSETTABLE
//
// MessageText:
//
//  The specified item can not be set in the current playlist.%0
//
#define NS_E_WMX_ITEM_UNSETTABLE         0xC00D1073L

//
// WMP Core  Error codes
//
//
// MessageId: NS_E_WMPCORE_NOSOURCEURLSTRING
//
// MessageText:
//
//  Windows Media Player cannot find the file. Be sure the path is typed correctly. If it is, the file may not exist in the specified location, or the computer where the file is stored may be offline.%0
//
#define NS_E_WMPCORE_NOSOURCEURLSTRING   0xC00D107CL

//
// MessageId: NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT
//
// MessageText:
//
//  Failed to create the Global Interface Table.%0
//
#define NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT 0xC00D107DL

//
// MessageId: NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE
//
// MessageText:
//
//  Failed to get the marshalled graph event handler interface.%0
//
#define NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE 0xC00D107EL

//
// MessageId: NS_E_WMPCORE_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer is too small for copying media type.%0
//
#define NS_E_WMPCORE_BUFFERTOOSMALL      0xC00D107FL

//
// MessageId: NS_E_WMPCORE_UNAVAILABLE
//
// MessageText:
//
//  Current state of the player does not allow the operation.%0
//
#define NS_E_WMPCORE_UNAVAILABLE         0xC00D1080L

//
// MessageId: NS_E_WMPCORE_INVALIDPLAYLISTMODE
//
// MessageText:
//
//  Playlist manager does not understand the current play mode (shuffle, normal etc).%0
//
#define NS_E_WMPCORE_INVALIDPLAYLISTMODE 0xC00D1081L

//
// MessageId: NS_E_WMPCORE_ITEMNOTINPLAYLIST
//
// MessageText:
//
//  The item is not in the playlist.%0
//
#define NS_E_WMPCORE_ITEMNOTINPLAYLIST   0xC00D1086L

//
// MessageId: NS_E_WMPCORE_PLAYLISTEMPTY
//
// MessageText:
//
//  There are no items in this playlist. Add items to the playlist, and try again.%0
//
#define NS_E_WMPCORE_PLAYLISTEMPTY       0xC00D1087L

//
// MessageId: NS_E_WMPCORE_NOBROWSER
//
// MessageText:
//
//  The Web site cannot be accessed. A Web browser is not detected on your computer.%0
//
#define NS_E_WMPCORE_NOBROWSER           0xC00D1088L

//
// MessageId: NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL 0xC00D1089L

//
// MessageId: NS_E_WMPCORE_GRAPH_NOT_IN_LIST
//
// MessageText:
//
//  Graph with the specified URL was not found in the prerolled graph list.%0
//
#define NS_E_WMPCORE_GRAPH_NOT_IN_LIST   0xC00D108AL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA
//
// MessageText:
//
//  Operation could not be performed because the playlist does not have more than one item.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA 0xC00D108BL

//
// MessageId: NS_E_WMPCORE_ERRORSINKNOTREGISTERED
//
// MessageText:
//
//  An error sink was never registered for the calling object.%0
//
#define NS_E_WMPCORE_ERRORSINKNOTREGISTERED 0xC00D108CL

//
// MessageId: NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
//  The error manager is not available to respond to errors.%0
//
#define NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE 0xC00D108DL

//
// MessageId: NS_E_WMPCORE_WEBHELPFAILED
//
// MessageText:
//
//  Failed launching WebHelp URL.%0
//
#define NS_E_WMPCORE_WEBHELPFAILED       0xC00D108EL

//
// MessageId: NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED
//
// MessageText:
//
//  Could not resume playing next item in playlist.%0
//
#define NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED 0xC00D108FL

//
// MessageId: NS_E_WMPCORE_NO_REF_IN_ENTRY
//
// MessageText:
//
//  No URL specified in the Ref attribute in playlist file.%0
//
#define NS_E_WMPCORE_NO_REF_IN_ENTRY     0xC00D1090L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY 0xC00D1091L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An invalid playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL 0xC00D1092L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An empty string for a playlist attribute value was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY 0xC00D1093L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL 0xC00D1094L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY 0xC00D1095L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL 0xC00D1096L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An illegal value for a playlist item attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY 0xC00D1097L

//
// MessageId: NS_E_WMPCORE_LIST_ENTRY_NO_REF
//
// MessageText:
//
//  No entries found in the playlist file.%0
//
#define NS_E_WMPCORE_LIST_ENTRY_NO_REF   0xC00D1098L

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_TRUSTED
//
// MessageText:
//
//  The codec downloaded for this media does not appear to be properly signed. Installation is not possible.%0
//
#define NS_E_WMPCORE_CODEC_NOT_TRUSTED   0xC00D109AL

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file could not be found.%0
//
#define NS_E_WMPCORE_CODEC_NOT_FOUND     0xC00D109BL

//
// MessageId: NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED
//
// MessageText:
//
//  Some of the codecs required by this media are not installed on your system. Since the option for automatic codec acquisition is disabled, no codecs will be downloaded.%0
//
#define NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED 0xC00D109CL

//
// MessageId: NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST
//
// MessageText:
//
//  Failed to download the playlist file.%0
//
#define NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST 0xC00D109DL

//
// MessageId: NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST
//
// MessageText:
//
//  Failed to build the playlist.%0
//
#define NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST 0xC00D109EL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE
//
// MessageText:
//
//  Playlist has no alternates to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE 0xC00D109FL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED
//
// MessageText:
//
//  No more playlist alternates available to switch to.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED 0xC00D10A0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND
//
// MessageText:
//
//  Could not find the name of the alternate playlist to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND 0xC00D10A1L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED
//
// MessageText:
//
//  Failed to switch to an alternate for this media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED 0xC00D10A2L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize an alternate for the media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED 0xC00D10A3L

//
// MessageId: NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY
//
// MessageText:
//
//  No URL specified for the roll over Refs in the playlist file.%0
//
#define NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY 0xC00D10A4L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME
//
// MessageText:
//
//  Encountered a playlist with no name.%0
//
#define NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME 0xC00D10A5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT
//
// MessageText:
//
//  A required attribute in the event block of the playlist was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT 0xC00D10A6L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY
//
// MessageText:
//
//  No items were found in the event block of the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY 0xC00D10A7L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_STACK_EMPTY
//
// MessageText:
//
//  No playlist was found while returning from a nested playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_STACK_EMPTY 0xC00D10A8L

//
// MessageId: NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE
//
// MessageText:
//
//  The media item is not active currently.%0
//
#define NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE 0xC00D10A9L

//
// MessageId: NS_E_WMPCORE_USER_CANCEL
//
// MessageText:
//
//  Open was aborted by user.%0
//
#define NS_E_WMPCORE_USER_CANCEL         0xC00D10ABL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY
//
// MessageText:
//
//  No items were found inside the playlist repeat block.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY 0xC00D10ACL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to start of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE 0xC00D10ADL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to the end of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE 0xC00D10AEL

//
// MessageId: NS_E_WMPCORE_INVALID_PLAYLIST_URL
//
// MessageText:
//
//  Playlist URL supplied to the playlist manager is invalid.%0
//
#define NS_E_WMPCORE_INVALID_PLAYLIST_URL 0xC00D10AFL

//
// MessageId: NS_E_WMPCORE_MISMATCHED_RUNTIME
//
// MessageText:
//
//  Player is selecting a runtime that is not valid for this media file type.%0
//
#define NS_E_WMPCORE_MISMATCHED_RUNTIME  0xC00D10B0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot import the playlist to Media Library because the playlist is empty.%0
//
#define NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS 0xC00D10B1L

//
// MessageId: NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION
//
// MessageText:
//
//  An error has occurred that could prevent the changing of the video contrast on this media.%0
//
#define NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION 0xC00D10B2L

//
// MessageId: NS_E_WMPCORE_MEDIA_UNAVAILABLE
//
// MessageText:
//
//  Windows Media Player cannot play this file. Connect to the Internet or insert the removable media on which the file is located, and then try to play the file again.%0
//
#define NS_E_WMPCORE_MEDIA_UNAVAILABLE   0xC00D10B3L

//
// MessageId: NS_E_WMPCORE_WMX_ENTRYREF_NO_REF
//
// MessageText:
//
//  The playlist contains an ENTRYREF for which no href was parsed. Check the syntax of playlist file.%0
//
#define NS_E_WMPCORE_WMX_ENTRYREF_NO_REF 0xC00D10B4L

//
// MessageId: NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST
//
// MessageText:
//
//  Windows Media Player cannot play any items in this playlist. For additional information, right-click an item that cannot be played, and then click Error Details.%0
//
#define NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST 0xC00D10B5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot play some or all of the playlist items.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS 0xC00D10B6L

//
// MessageId: NS_E_WMPCORE_BUSY
//
// MessageText:
//
//  Windows Media Player could not handle your request for digital media content in a timely manner. Try again later.%0
//
#define NS_E_WMPCORE_BUSY                0xC00D10B7L

//
// MessageId: NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE
//
// MessageText:
//
//  There is no child playlist available for this media item at this time.%0
//
#define NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE 0xC00D10B8L

//
// MessageId: NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST
//
// MessageText:
//
//  There is no child playlist for this media item.%0
//
#define NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST 0xC00D10B9L

//
// MessageId: NS_E_WMPCORE_FILE_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play one or more files. Right-click the file, and then click Error Details to view information about the error.%0
//
#define NS_E_WMPCORE_FILE_NOT_FOUND      0xC00D10BAL

//
// MessageId: NS_E_WMPCORE_TEMP_FILE_NOT_FOUND
//
// MessageText:
//
//  The temporary file was not found.%0
//
#define NS_E_WMPCORE_TEMP_FILE_NOT_FOUND 0xC00D10BBL

//
// MessageId: NS_E_WMDM_REVOKED
//
// MessageText:
//
//  Windows Media Player cannot transfer media to the portable device without an update.  Please click details to find out how to update your device.%0
//
#define NS_E_WMDM_REVOKED                0xC00D10BCL

//
// MessageId: NS_E_DDRAW_GENERIC
//
// MessageText:
//
//  Windows Media Player cannot play the video stream because of a problem with your video card.%0
//
#define NS_E_DDRAW_GENERIC               0xC00D10BDL

//
// MessageId: NS_E_DISPLAY_MODE_CHANGE_FAILED
//
// MessageText:
//
//  Windows Media Player failed to change the screen mode for fullscreen video playback.%0
//
#define NS_E_DISPLAY_MODE_CHANGE_FAILED  0xC00D10BEL

//
// MessageId: NS_E_PLAYLIST_CONTAINS_ERRORS
//
// MessageText:
//
//  One or more items in the playlist cannot be played. For more details, right-click an item in the playlist, and then click Error Details.%0
//
#define NS_E_PLAYLIST_CONTAINS_ERRORS    0xC00D10BFL

//
// WMP Core  Success codes
//
//
// MessageId: NS_S_WMPCORE_PLAYLISTCLEARABORT
//
// MessageText:
//
//  Failed to clear playlist because it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTCLEARABORT  0x000D10FEL

//
// MessageId: NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT
//
// MessageText:
//
//  Failed to remove item in the playlist since it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT 0x000D10FFL

//
// MessageId: NS_S_WMPCORE_PLAYLIST_CREATION_PENDING
//
// MessageText:
//
//  Playlist is being generated asynchronously.%0
//
#define NS_S_WMPCORE_PLAYLIST_CREATION_PENDING 0x000D1102L

//
// MessageId: NS_S_WMPCORE_MEDIA_VALIDATION_PENDING
//
// MessageText:
//
//  Validation of the media is pending...%0
//
#define NS_S_WMPCORE_MEDIA_VALIDATION_PENDING 0x000D1103L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED
//
// MessageText:
//
//  Encountered more than one Repeat block during ASX processing.%0
//
#define NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED 0x000D1104L

//
// MessageId: NS_S_WMPCORE_COMMAND_NOT_AVAILABLE
//
// MessageText:
//
//  Current state of WMP disallows calling this method or property.%0
//
#define NS_S_WMPCORE_COMMAND_NOT_AVAILABLE 0x000D1105L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED
//
// MessageText:
//
//  Name for the playlist has been auto generated.%0
//
#define NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED 0x000D1106L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS
//
// MessageText:
//
//  The imported playlist does not contain all items from the original.%0
//
#define NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS 0x000D1107L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA
//
// MessageText:
//
//  The M3U playlist has been ignored because it only contains one item.%0
//
#define NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA 0x000D1108L

//
// MessageId: NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING
//
// MessageText:
//
//  The open for the child playlist associated with this media is pending.%0
//
#define NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING 0x000D1109L

//
// WMP Internet Manager error codes
//
//
// MessageId: NS_E_WMPIM_USEROFFLINE
//
// MessageText:
//
//  Windows Media Player has detected that you are not connected to the Internet. Connect to the Internet, and then try again.%0
//
#define NS_E_WMPIM_USEROFFLINE           0xC00D1126L

//
// MessageId: NS_E_WMPIM_USERCANCELED
//
// MessageText:
//
//  User cancelled attempt to connect to the Internet.%0
//
#define NS_E_WMPIM_USERCANCELED          0xC00D1127L

//
// MessageId: NS_E_WMPIM_DIALUPFAILED
//
// MessageText:
//
//  Attempt to dial connection to the Internet failed.%0
//
#define NS_E_WMPIM_DIALUPFAILED          0xC00D1128L

//
// WMP Backup and restore error and success codes
//
//
// MessageId: NS_E_WMPBR_NOLISTENER
//
// MessageText:
//
//  No window is currently listening to Backup and Restore events.%0
//
#define NS_E_WMPBR_NOLISTENER            0xC00D1130L

//
// MessageId: NS_E_WMPBR_BACKUPCANCEL
//
// MessageText:
//
//  Backup of your licenses has been cancelled.  Please try again to ensure license backup.%0
//
#define NS_E_WMPBR_BACKUPCANCEL          0xC00D1131L

//
// MessageId: NS_E_WMPBR_RESTORECANCEL
//
// MessageText:
//
//  The licenses were not restored because the restoration was cancelled.%0
//
#define NS_E_WMPBR_RESTORECANCEL         0xC00D1132L

//
// MessageId: NS_E_WMPBR_ERRORWITHURL
//
// MessageText:
//
//  An error occurred during the backup or restore operation that requires a web page be displayed to the user.%0
//
#define NS_E_WMPBR_ERRORWITHURL          0xC00D1133L

//
// MessageId: NS_E_WMPBR_NAMECOLLISION
//
// MessageText:
//
//  The licenses were not backed up because the backup was cancelled.%0
//
#define NS_E_WMPBR_NAMECOLLISION         0xC00D1134L

//
// MessageId: NS_S_WMPBR_SUCCESS
//
// MessageText:
//
//  Backup or Restore successful!.%0
//
#define NS_S_WMPBR_SUCCESS               0x000D1135L

//
// MessageId: NS_S_WMPBR_PARTIALSUCCESS
//
// MessageText:
//
//  Transfer complete with limitations.%0
//
#define NS_S_WMPBR_PARTIALSUCCESS        0x000D1136L

//
// WMP Effects Success codes
//
//
// MessageId: NS_S_WMPEFFECT_TRANSPARENT
//
// MessageText:
//
//  Request to the effects control to change transparency status to transparent.%0
//
#define NS_S_WMPEFFECT_TRANSPARENT       0x000D1144L

//
// MessageId: NS_S_WMPEFFECT_OPAQUE
//
// MessageText:
//
//  Request to the effects control to change transparency status to opaque.%0
//
#define NS_S_WMPEFFECT_OPAQUE            0x000D1145L

//
// WMP Application Success codes
//
//
// MessageId: NS_S_OPERATION_PENDING
//
// MessageText:
//
//  The requested application pane is performing an operation and will not be relased.%0
//
#define NS_S_OPERATION_PENDING           0x000D114EL

//
// WMP DVD Error Codes
//
//
// MessageId: NS_E_DVD_NO_SUBPICTURE_STREAM
//
// MessageText:
//
//  Windows Media Player cannot display subtitles or highlights in menus. Reinstall the DVD decoder or contact your device manufacturer to obtain an updated decoder, and then try again.%0
//
#define NS_E_DVD_NO_SUBPICTURE_STREAM    0xC00D1162L

//
// MessageId: NS_E_DVD_COPY_PROTECT
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with digital copyright protection.%0
//
#define NS_E_DVD_COPY_PROTECT            0xC00D1163L

//
// MessageId: NS_E_DVD_AUTHORING_PROBLEM
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc is incompatible with the Player.%0
//
#define NS_E_DVD_AUTHORING_PROBLEM       0xC00D1164L

//
// MessageId: NS_E_DVD_INVALID_DISC_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_INVALID_DISC_REGION     0xC00D1165L

//
// MessageId: NS_E_DVD_COMPATIBLE_VIDEO_CARD
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because your video card does not support DVD playback.%0
//
#define NS_E_DVD_COMPATIBLE_VIDEO_CARD   0xC00D1166L

//
// MessageId: NS_E_DVD_MACROVISION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with analog copyright protection.%0
//
#define NS_E_DVD_MACROVISION             0xC00D1167L

//
// MessageId: NS_E_DVD_SYSTEM_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the region assigned to your DVD drive does not match the region assigned to your DVD decoder.%0
//
#define NS_E_DVD_SYSTEM_DECODER_REGION   0xC00D1168L

//
// MessageId: NS_E_DVD_DISC_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. To play the disc by using the Player, you must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_DISC_DECODER_REGION     0xC00D1169L

//
// MessageId: NS_E_DVD_NO_VIDEO_STREAM
//
// MessageText:
//
//  Windows Media Player is currently unable to play DVD video. Close any open files and quit any other running programs, and then try again.%0
//
#define NS_E_DVD_NO_VIDEO_STREAM         0xC00D116AL

//
// MessageId: NS_E_DVD_NO_AUDIO_STREAM
//
// MessageText:
//
//  Windows Media Player cannot play DVD audio. Verify that your sound card is set up correctly, and then try again.%0
//
#define NS_E_DVD_NO_AUDIO_STREAM         0xC00D116BL

//
// MessageId: NS_E_DVD_GRAPH_BUILDING
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Close any open files and quit any other running programs, and then try again. If the problem continues, restart your computer.%0
//
#define NS_E_DVD_GRAPH_BUILDING          0xC00D116CL

//
// MessageId: NS_E_DVD_NO_DECODER
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a compatible DVD decoder is not installed on your computer.%0
//
#define NS_E_DVD_NO_DECODER              0xC00D116DL

//
// MessageId: NS_E_DVD_PARENTAL
//
// MessageText:
//
//  Windows Media Player cannot play this DVD segment because the segment has a parental rating higher than the rating you are authorized to view.%0
//
#define NS_E_DVD_PARENTAL                0xC00D116EL

//
// MessageId: NS_E_DVD_CANNOT_JUMP
//
// MessageText:
//
//  Windows Media Player cannot skip to the requested location in the DVD at this time.%0
//
#define NS_E_DVD_CANNOT_JUMP             0xC00D116FL

//
// MessageId: NS_E_DVD_DEVICE_CONTENTION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because it is currently in use by another program. Quit the other program that is using the DVD, and then try to play it again.%0
//
#define NS_E_DVD_DEVICE_CONTENTION       0xC00D1170L

//
// MessageId: NS_E_DVD_NO_VIDEO_MEMORY
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Double-click Display in Control Panel to lower your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_MEMORY         0xC00D1171L

//
// WMP PDA Error codes
//
//
// MessageId: NS_E_NO_CD_BURNER
//
// MessageText:
//
//  A CD recorder (burner) was not detected. Connect a CD recorder, and try copying again.%0
//
#define NS_E_NO_CD_BURNER                0xC00D1176L

//
// MessageId: NS_E_DEVICE_IS_NOT_READY
//
// MessageText:
//
//  Windows Media Player does not detect any removable media in your portable device. Insert the media in the device or check the connection between the device and your computer, and then press F5 to refresh.%0
//
#define NS_E_DEVICE_IS_NOT_READY         0xC00D1177L

//
// MessageId: NS_E_PDA_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the specified file. Your portable device does not support the specified format.%0
//
#define NS_E_PDA_UNSUPPORTED_FORMAT      0xC00D1178L

//
// MessageId: NS_E_NO_PDA
//
// MessageText:
//
//  Windows Media Player cannot detect a connected portable device. Connect your portable device, and try again.%0
//
#define NS_E_NO_PDA                      0xC00D1179L

//
// General Remapped Error codes in WMP
//
//
// MessageId: NS_E_WMP_PROTOCOL_PROBLEM
//
// MessageText:
//
//  Windows Media Player could not open the specified URL. Be sure Windows Media Player is configured to use all available protocols, and then try again.%0
//
#define NS_E_WMP_PROTOCOL_PROBLEM        0xC00D1194L

//
// MessageId: NS_E_WMP_NO_DISK_SPACE
//
// MessageText:
//
//  Windows Media Player cannot open the file because there is not enough disk space on your computer. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_NO_DISK_SPACE           0xC00D1195L

//
// MessageId: NS_E_WMP_LOGON_FAILURE
//
// MessageText:
//
//  The user name or password is incorrect. Type your user name or password again.%0
//
#define NS_E_WMP_LOGON_FAILURE           0xC00D1196L

//
// MessageId: NS_E_WMP_CANNOT_FIND_FILE
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMP_CANNOT_FIND_FILE        0xC00D1197L

//
// MessageId: NS_E_WMP_SERVER_INACCESSIBLE
//
// MessageText:
//
//  Windows Media Player cannot connect to the server. The server name may be incorrect or the server is busy. Try again later.%0
//
#define NS_E_WMP_SERVER_INACCESSIBLE     0xC00D1198L

//
// MessageId: NS_E_WMP_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file is either corrupt or the Player does not support the format you are trying to play.%0
//
#define NS_E_WMP_UNSUPPORTED_FORMAT      0xC00D1199L

//
// MessageId: NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Internet security setting on your computer is set too high. Lower your browser's security setting, and then try again.%0
//
#define NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT 0xC00D119AL

//
// MessageId: NS_E_WMP_PLAYLIST_EXISTS
//
// MessageText:
//
//  Windows Media Player cannot create the playlist because the name already exists. Type a different playlist name.%0
//
#define NS_E_WMP_PLAYLIST_EXISTS         0xC00D119BL

//
// MessageId: NS_E_WMP_NONMEDIA_FILES
//
// MessageText:
//
//  Windows Media Player could not delete the playlist because it contains non-digital media files. Any digital media files in the playlist were deleted. Use Windows Explorer to delete non-digital media files, and then try deleting the playlist again.%0
//
#define NS_E_WMP_NONMEDIA_FILES          0xC00D119CL

//
// MessageId: NS_E_WMP_INVALID_ASX
//
// MessageText:
//
//  Windows Media Player cannot play the selected playlist.  The format of the playlist is either invalid or is not recognized.%0
//
#define NS_E_WMP_INVALID_ASX             0xC00D119DL

//
// MessageId: NS_E_WMP_ALREADY_IN_USE
//
// MessageText:
//
//  Windows Media Player is already in use. Stop playing any content and close all Player dialog boxes and then try again.%0
//
#define NS_E_WMP_ALREADY_IN_USE          0xC00D119EL

//
// WMP CD Filter Error codes extension
//
//
// MessageId: NS_E_CD_NO_BUFFERS_READ
//
// MessageText:
//
//  Windows Media Player encountered an error when reading the CD-ROM drive in digital mode. You can try to use digital mode again, or you can switch the Player to analog mode.%0
//
#define NS_E_CD_NO_BUFFERS_READ          0xC00D11F8L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Server Errors
//
// IdRange = 5000 - 5999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_REDIRECT
//
// MessageText:
//
//  The client is redirected to another server.%0
//
#define NS_E_REDIRECT                    0xC00D1388L

//
// MessageId: NS_E_STALE_PRESENTATION
//
// MessageText:
//
//  The streaming media description is no longer current.%0
//
#define NS_E_STALE_PRESENTATION          0xC00D1389L


 // Namespace Errors

//
// MessageId: NS_E_NAMESPACE_WRONG_PERSIST
//
// MessageText:
//
//  Attempt to create a persistent namespace node under a transient parent node.%0
//
#define NS_E_NAMESPACE_WRONG_PERSIST     0xC00D138AL

//
// MessageId: NS_E_NAMESPACE_WRONG_TYPE
//
// MessageText:
//
//  Unable to store a value in a namespace node of different value type.%0
//
#define NS_E_NAMESPACE_WRONG_TYPE        0xC00D138BL

//
// MessageId: NS_E_NAMESPACE_NODE_CONFLICT
//
// MessageText:
//
//  Unable to remove the root namespace node.%0
//
#define NS_E_NAMESPACE_NODE_CONFLICT     0xC00D138CL

//
// MessageId: NS_E_NAMESPACE_NODE_NOT_FOUND
//
// MessageText:
//
//  Could not find the specified namespace node.%0
//
#define NS_E_NAMESPACE_NODE_NOT_FOUND    0xC00D138DL

//
// MessageId: NS_E_NAMESPACE_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied to hold namespace node string is too small.%0
//
#define NS_E_NAMESPACE_BUFFER_TOO_SMALL  0xC00D138EL

//
// MessageId: NS_E_NAMESPACE_TOO_MANY_CALLBACKS
//
// MessageText:
//
//  Callback list on a namespace node is at maximum size.%0
//
#define NS_E_NAMESPACE_TOO_MANY_CALLBACKS 0xC00D138FL

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_CALLBACK
//
// MessageText:
//
//  Attempt to register an already-registered callback on a namespace node.%0
//
#define NS_E_NAMESPACE_DUPLICATE_CALLBACK 0xC00D1390L

//
// MessageId: NS_E_NAMESPACE_CALLBACK_NOT_FOUND
//
// MessageText:
//
//  Could not find callback in namespace when attempting to remove callback.%0
//
#define NS_E_NAMESPACE_CALLBACK_NOT_FOUND 0xC00D1391L

//
// MessageId: NS_E_NAMESPACE_NAME_TOO_LONG
//
// MessageText:
//
//  The length of a namespace node name exceeds the allowed maximum length.%0
//
#define NS_E_NAMESPACE_NAME_TOO_LONG     0xC00D1392L

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_NAME
//
// MessageText:
//
//  Cannot create a namespace node which already exists.%0
//
#define NS_E_NAMESPACE_DUPLICATE_NAME    0xC00D1393L

//
// MessageId: NS_E_NAMESPACE_EMPTY_NAME
//
// MessageText:
//
//  The name of a namespace node cannot be a null string.%0
//
#define NS_E_NAMESPACE_EMPTY_NAME        0xC00D1394L

//
// MessageId: NS_E_NAMESPACE_INDEX_TOO_LARGE
//
// MessageText:
//
//  Finding a child namespace node by index failed because the index exceeded the number of children.%0
//
#define NS_E_NAMESPACE_INDEX_TOO_LARGE   0xC00D1395L

//
// MessageId: NS_E_NAMESPACE_BAD_NAME
//
// MessageText:
//
//  The name supplied for a namespace node is not valid.%0
//
#define NS_E_NAMESPACE_BAD_NAME          0xC00D1396L


 // Cache Errors

//
// MessageId: NS_E_CACHE_ARCHIVE_CONFLICT
//
// MessageText:
//
//  Archive request conflicts with other requests in progress.%0
//
#define NS_E_CACHE_ARCHIVE_CONFLICT      0xC00D1397L

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified origin server cannot be found.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND 0xC00D1398L

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_TIMEOUT
//
// MessageText:
//
//  The specified origin server does not respond.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_TIMEOUT 0xC00D1399L

//
// MessageId: NS_E_CACHE_NOT_BROADCAST
//
// MessageText:
//
//  The internal code for HTTP status code 412 Precondition Failed due to not broadcast type.%0
//
#define NS_E_CACHE_NOT_BROADCAST         0xC00D139AL

//
// MessageId: NS_E_CACHE_CANNOT_BE_CACHED
//
// MessageText:
//
//  The internal code for HTTP status code 403 Forbidden due to not cacheable.%0
//
#define NS_E_CACHE_CANNOT_BE_CACHED      0xC00D139BL

//
// MessageId: NS_E_CACHE_NOT_MODIFIED
//
// MessageText:
//
//  The internal code for HTTP status code 304 Not Modified.%0
//
#define NS_E_CACHE_NOT_MODIFIED          0xC00D139CL


// Object Model Errors

//
// MessageId: NS_E_CANNOT_REMOVE_PUBLISHING_POINT
//
// MessageText:
//
//  Publishing Points of type Cache or Proxy cannot be removed.%0
//
#define NS_E_CANNOT_REMOVE_PUBLISHING_POINT 0xC00D139DL

//
// MessageId: NS_E_CANNOT_REMOVE_PLUGIN
//
// MessageText:
//
//  Cannot remove last instance of plugin.%0
//
#define NS_E_CANNOT_REMOVE_PLUGIN        0xC00D139EL

//
// MessageId: NS_E_WRONG_PUBLISHING_POINT_TYPE
//
// MessageText:
//
//  Publishing Points of type Cache or Proxy do not support this property or method.%0
//
#define NS_E_WRONG_PUBLISHING_POINT_TYPE 0xC00D139FL

//
// MessageId: NS_E_UNSUPPORTED_LOAD_TYPE
//
// MessageText:
//
//  The Plugin does not support the specified Load Type.%0
//
#define NS_E_UNSUPPORTED_LOAD_TYPE       0xC00D13A0L

//
// MessageId: NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION
//
// MessageText:
//
//  The Plugin does not support any Load Types.  The Plugin must support at least one Load Type.%0
//
#define NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION 0xC00D13A1L


// Playlist Errors 5300-5399

//
// MessageId: NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING
//
// MessageText:
//
//  The playlist entry is already playing.%0
//
#define NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING 0xC00D14B4L


// Datapath Errors -- 5400 - 5499

//
// MessageId: NS_E_DATAPATH_NO_SINK
//
// MessageText:
//
//  The datapath does not have a sink.%0
//
#define NS_E_DATAPATH_NO_SINK            0xC00D1518L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Tools Errors
//
// IdRange = 7000 - 7999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_BAD_MARKIN
//
// MessageText:
//
//  The Mark In time should be greater than 0 and less than Mark Out time.%0
//
#define NS_E_BAD_MARKIN                  0xC00D1B58L

//
// MessageId: NS_E_BAD_MARKOUT
//
// MessageText:
//
//  The Mark Out time should be greater than Mark In time and less than file duration.%0
//
#define NS_E_BAD_MARKOUT                 0xC00D1B59L

//
// MessageId: NS_E_NOMATCHING_MEDIASOURCE
//
// MessageText:
//
//  No matching media source is found in source group %1.%0
//
#define NS_E_NOMATCHING_MEDIASOURCE      0xC00D1B5AL

//
// MessageId: NS_E_UNSUPPORTED_SOURCETYPE
//
// MessageText:
//
//  Unsupported source type.%0
//
#define NS_E_UNSUPPORTED_SOURCETYPE      0xC00D1B5BL

//
// MessageId: NS_E_TOO_MANY_AUDIO
//
// MessageText:
//
//  No more than 1 audio input is allowed.%0
//
#define NS_E_TOO_MANY_AUDIO              0xC00D1B5CL

//
// MessageId: NS_E_TOO_MANY_VIDEO
//
// MessageText:
//
//  No more than 2 video inputs are allowed.%0
//
#define NS_E_TOO_MANY_VIDEO              0xC00D1B5DL

//
// MessageId: NS_E_NOMATCHING_ELEMENT
//
// MessageText:
//
//  No matching element is found in the list.%0
//
#define NS_E_NOMATCHING_ELEMENT          0xC00D1B5EL

//
// MessageId: NS_E_MISMATCHED_MEDIACONTENT
//
// MessageText:
//
//  The profile's media content doesn't match the media content defined in the source group.%0
//
#define NS_E_MISMATCHED_MEDIACONTENT     0xC00D1B5FL

//
// MessageId: NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  Cannot remove an active source group from the source group collection while encoder is currently running.%0
//
#define NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP 0xC00D1B60L

//
// MessageId: NS_E_AUDIODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified audio capture device because it is in use right now.%0
//
#define NS_E_AUDIODEVICE_BUSY            0xC00D1B61L

//
// MessageId: NS_E_AUDIODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified audio capture device because unexpected error occurred.%0
//
#define NS_E_AUDIODEVICE_UNEXPECTED      0xC00D1B62L

//
// MessageId: NS_E_AUDIODEVICE_BADFORMAT
//
// MessageText:
//
//  Audio capture device doesn't support specified audio format.%0
//
#define NS_E_AUDIODEVICE_BADFORMAT       0xC00D1B63L

//
// MessageId: NS_E_VIDEODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified video capture device because it is in use right now.%0
//
#define NS_E_VIDEODEVICE_BUSY            0xC00D1B64L

//
// MessageId: NS_E_VIDEODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified video capture device because unexpected error occurred.%0
//
#define NS_E_VIDEODEVICE_UNEXPECTED      0xC00D1B65L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING
//
// MessageText:
//
//  This operation is not allowed while encoder is running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING 0xC00D1B66L

//
// MessageId: NS_E_NO_PROFILE_IN_SOURCEGROUP
//
// MessageText:
//
//  No profile is set in source group.%0
//
#define NS_E_NO_PROFILE_IN_SOURCEGROUP   0xC00D1B67L

//
// MessageId: NS_E_VIDEODRIVER_UNSTABLE
//
// MessageText:
//
//  The video capture driver returned an unrecoverable error.  It is now in an unstable state.%0
//
#define NS_E_VIDEODRIVER_UNSTABLE        0xC00D1B68L

//
// MessageId: NS_E_VIDCAPSTARTFAILED
//
// MessageText:
//
//  The video input device could not be started.%0
//
#define NS_E_VIDCAPSTARTFAILED           0xC00D1B69L

//
// MessageId: NS_E_VIDSOURCECOMPRESSION
//
// MessageText:
//
//  The video input source does not support the requested output format or color depth.%0
//
#define NS_E_VIDSOURCECOMPRESSION        0xC00D1B6AL

//
// MessageId: NS_E_VIDSOURCESIZE
//
// MessageText:
//
//  The video input source does not support the request capture size.%0
//
#define NS_E_VIDSOURCESIZE               0xC00D1B6BL

//
// MessageId: NS_E_ICMQUERYFORMAT
//
// MessageText:
//
//  Unable to obtain output information from video compressor.%0
//
#define NS_E_ICMQUERYFORMAT              0xC00D1B6CL

//
// MessageId: NS_E_VIDCAPCREATEWINDOW
//
// MessageText:
//
//  Unable to create video capture window.%0
//
#define NS_E_VIDCAPCREATEWINDOW          0xC00D1B6DL

//
// MessageId: NS_E_VIDCAPDRVINUSE
//
// MessageText:
//
//  There already is a running stream active on this video input device.%0
//
#define NS_E_VIDCAPDRVINUSE              0xC00D1B6EL

//
// MessageId: NS_E_NO_MEDIAFORMAT_IN_SOURCE
//
// MessageText:
//
//  No media format is set in source.%0
//
#define NS_E_NO_MEDIAFORMAT_IN_SOURCE    0xC00D1B6FL

//
// MessageId: NS_E_NO_VALID_OUTPUT_STREAM
//
// MessageText:
//
//  Cannot find valid output stream from source.%0
//
#define NS_E_NO_VALID_OUTPUT_STREAM      0xC00D1B70L

//
// MessageId: NS_E_NO_VALID_SOURCE_PLUGIN
//
// MessageText:
//
//  Cannot find valid source plugin to support specified source.%0
//
#define NS_E_NO_VALID_SOURCE_PLUGIN      0xC00D1B71L

//
// MessageId: NS_E_NO_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  No source group is currently active.%0
//
#define NS_E_NO_ACTIVE_SOURCEGROUP       0xC00D1B72L

//
// MessageId: NS_E_NO_SCRIPT_STREAM
//
// MessageText:
//
//  No script stream is set in current active source group.%0
//
#define NS_E_NO_SCRIPT_STREAM            0xC00D1B73L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING
//
// MessageText:
//
//  This operation is not allowed when file archival is started.%0
//
#define NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING 0xC00D1B74L

//
// MessageId: NS_E_INVALIDPACKETSIZE
//
// MessageText:
//
//  The MaxPacketSize value specified is invalid.%0
//
#define NS_E_INVALIDPACKETSIZE           0xC00D1B75L

//
// MessageId: NS_E_PLUGIN_CLSID_NOTINVALID
//
// MessageText:
//
//  The plugin CLSID specified is invalid.%0
//
#define NS_E_PLUGIN_CLSID_NOTINVALID     0xC00D1B76L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVETYPE
//
// MessageText:
//
//  This Archive type is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVETYPE     0xC00D1B77L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVEOPERATION
//
// MessageText:
//
//  This Archive operation is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVEOPERATION 0xC00D1B78L

//
// MessageId: NS_E_ARCHIVE_FILENAME_NOTSET
//
// MessageText:
//
//  The local archive filename was not set.%0
//
#define NS_E_ARCHIVE_FILENAME_NOTSET     0xC00D1B79L

//
// MessageId: NS_E_SOURCEGROUP_NOTPREPARED
//
// MessageText:
//
//  The SourceGroup is not yet prepared.%0
//
#define NS_E_SOURCEGROUP_NOTPREPARED     0xC00D1B7AL

//
// MessageId: NS_E_PROFILE_MISMATCH
//
// MessageText:
//
//  Profiles on the sourcegroups do not match.%0
//
#define NS_E_PROFILE_MISMATCH            0xC00D1B7BL

//
// MessageId: NS_E_INCORRECTCLIPSETTINGS
//
// MessageText:
//
//  The clip settings specified on the source are incorrect.%0
//
#define NS_E_INCORRECTCLIPSETTINGS       0xC00D1B7CL

//
// MessageId: NS_E_NOSTATSAVAILABLE
//
// MessageText:
//
//  No statistics are available at this time.%0
//
#define NS_E_NOSTATSAVAILABLE            0xC00D1B7DL

//
// MessageId: NS_E_NOTARCHIVING
//
// MessageText:
//
//  Encoder is not archiving.%0
//
#define NS_E_NOTARCHIVING                0xC00D1B7EL

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED
//
// MessageText:
//
//  This operation is not allowed while encoder is not running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED 0xC00D1B7FL

//
// MessageId: NS_E_NOSOURCEGROUPS
//
// MessageText:
//
//  This SourceGroupCollection does not contain any SourceGroups.%0
//
#define NS_E_NOSOURCEGROUPS              0xC00D1B80L

//
// MessageId: NS_E_INVALIDINPUTFPS
//
// MessageText:
//
//  Because this source group does not have a frame rate of 30 frames per second, you cannot use the inverse telecine feature.%0
//
#define NS_E_INVALIDINPUTFPS             0xC00D1B81L

//
// MessageId: NS_E_NO_DATAVIEW_SUPPORT
//
// MessageText:
//
//  Internal problems are preventing the preview or postview of your content.%0
//
#define NS_E_NO_DATAVIEW_SUPPORT         0xC00D1B82L

//
// MessageId: NS_E_CODEC_UNAVAILABLE
//
// MessageText:
//
//  One or more codecs required to open this media could not be found.%0
//
#define NS_E_CODEC_UNAVAILABLE           0xC00D1B83L

//
// MessageId: NS_E_ARCHIVE_SAME_AS_INPUT
//
// MessageText:
//
//  The output archive file specified is the same as an input source in one of the source groups.%0
//
#define NS_E_ARCHIVE_SAME_AS_INPUT       0xC00D1B84L

//
// MessageId: NS_E_SOURCE_NOTSPECIFIED
//
// MessageText:
//
//  The input source has not been setup completely.%0
//
#define NS_E_SOURCE_NOTSPECIFIED         0xC00D1B85L

//
// MessageId: NS_E_NO_REALTIME_TIMECOMPRESSION
//
// MessageText:
//
//  Cannot apply time compression transform plug-in to a real time broadcast session.%0
//
#define NS_E_NO_REALTIME_TIMECOMPRESSION 0xC00D1B86L

//
// MessageId: NS_E_UNSUPPORTED_ENCODER_DEVICE
//
// MessageText:
//
//  The Encoder was unable to open this device. Please see the system requirements for more information.%0
//
#define NS_E_UNSUPPORTED_ENCODER_DEVICE  0xC00D1B87L

//
// MessageId: NS_E_UNEXPECTED_DISPLAY_SETTINGS
//
// MessageText:
//
//  Encoding cannot start because the display size or color setting has changed since the current session was defined. Restore the previous settings or create a new session.%0
//
#define NS_E_UNEXPECTED_DISPLAY_SETTINGS 0xC00D1B88L

//
// MessageId: NS_E_NO_AUDIODATA
//
// MessageText:
//
//  No audio data has been received for multiple seconds.  Check the audio source and restart the encoder.%0
//
#define NS_E_NO_AUDIODATA                0xC00D1B89L

//
// MessageId: NS_E_INPUTSOURCE_PROBLEM
//
// MessageText:
//
//  One or all of your specified input sources are not working properly. Make sure your input sources are configured correctly.%0
//
#define NS_E_INPUTSOURCE_PROBLEM         0xC00D1B8AL

//
// MessageId: NS_E_WME_VERSION_MISMATCH
//
// MessageText:
//
//  The supplied configuration file is not supported by this version of the encoder.%0
//
#define NS_E_WME_VERSION_MISMATCH        0xC00D1B8BL

//
// MessageId: NS_E_NO_REALTIME_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used with real-time encoding.%0
//
#define NS_E_NO_REALTIME_PREPROCESS      0xC00D1B8CL

//
// MessageId: NS_E_NO_REPEAT_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used when source is set to loop.%0
//
#define NS_E_NO_REPEAT_PREPROCESS        0xC00D1B8DL


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     0xC00D2711L

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     0xC00D2712L

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
//  Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      0xC00D2713L

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR 0xC00D2714L

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR 0xC00D2715L

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         0xC00D2716L

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  0xC00D2717L

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
//  The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         0xC00D2718L

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
//  Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         0xC00D2719L

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     0xC00D271BL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST 0xC00D271CL

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    0xC00D271DL

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
//  The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE 0xC00D271EL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED 0xC00D271FL

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
//  The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               0xC00D2720L

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_KEY_ERROR               0xC00D2721L

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           0xC00D2722L

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           0xC00D2723L

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     0xC00D2725L

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
//  Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        0x000D2726L

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
//  Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          0x000D2727L

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION 0xC00D2728L

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
//  The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      0xC00D272AL

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
//  You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       0xC00D272BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
//  You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         0xC00D272CL

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   0xC00D272FL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
//  A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT 0xC00D2730L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT 0xC00D2731L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT 0xC00D2732L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT 0xC00D2733L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT 0xC00D2734L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT 0xC00D2735L

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
//  The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     0xC00D2736L

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      0xC00D2737L

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     0xC00D2738L

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       0xC00D2739L

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             0xC00D273AL

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            0xC00D273BL

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR 0xC00D273CL

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR 0xC00D273DL

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           0xC00D273EL

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
//  The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER 0xC00D273FL

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         0xC00D2740L

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION 0xC00D2741L

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
//  Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           0xC00D2742L

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
//  One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          0xC00D2743L

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
//  You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      0xC00D2744L

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
//  Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       0x000D2746L

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
//  Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       0x000D2747L

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
//  The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        0xC00D2748L

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
//  A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        0xC00D2749L

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  0xC00D274AL

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
//  A license cannot be found for this media file. Use License Management to transfer a license for this file from the original computer, or acquire a new license.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    0xC00D274BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
//  A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE 0xC00D274CL

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
//  Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     0xC00D274DL

//
// MessageId: NS_E_DRM_NEED_UPGRADE
//
// MessageText:
//
//  A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE            0xC00D274EL

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
//  Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          0xC00D274FL

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
//  Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  0xC00D2750L

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD 0xC00D2751L

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         0xC00D2752L

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
//  You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           0xC00D2753L

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
//  The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   0xC00D2754L

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
//  To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            0xC00D2755L

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
//  You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       0xC00D2756L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT 0xC00D2757L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT 0xC00D2758L

;// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
//  Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     0xC00D2759L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT 0xC00D275AL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT 0xC00D275BL

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied is not sufficient.%0.
//
#define NS_E_DRM_BUFFER_TOO_SMALL        0xC00D275CL

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The property requested is not supported.%0.
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    0xC00D275DL

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested operation.%0.
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      0xC00D275EL

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
//  Some of the licenses could not be stored.%0.
//
#define NS_E_DRM_STORE_NOTALLSTORED      0xC00D275FL

//
// MessageId: NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID
//
// MessageText:
//
//  The Digital Rights Management security upgrade component could not be validated. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID 0xC00D2760L

//
// MessageId: NS_E_DRM_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_DRM_INVALID_DATA            0xC00D2761L

//
// MessageId: NS_E_DRM_UNABLE_TO_CONTACT_SERVER
//
// MessageText:
//
//  Unable to contact the server for the requested operation.%0
//
#define NS_E_DRM_UNABLE_TO_CONTACT_SERVER 0xC00D2762L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT 0xC00D2763L

;// License Reasons Section
;// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
;// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
//  The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         0xC00D27D8L

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
//  The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      0xC00D27D9L

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       0xC00D27DAL

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
//  The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0.
//
#define NS_E_DRM_STORE_NEEDINDI          0xC00D27DBL

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
//  Your machine does not meet the requirements for storing the license.%0.
//
#define NS_E_DRM_STORE_NOTALLOWED        0xC00D27DCL

//
// MessageId: NS_E_DRM_LICENSE_APP_NOTALLOWED
//
// MessageText:
//
//  The license for this file requires an upgraded version of your player or a different player.%0.
//
#define NS_E_DRM_LICENSE_APP_NOTALLOWED  0xC00D27DDL

//
// MessageId: NS_S_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_S_DRM_NEEDS_INDIVIDUALIZATION 0x000D27DEL

//
// MessageId: NS_E_DRM_LICENSE_CERT_EXPIRED
//
// MessageText:
//
//  The license server's certificate expired. Make sure your system clock is set correctly. Contact your content provider for further assistance. %0.
//
#define NS_E_DRM_LICENSE_CERT_EXPIRED    0xC00D27DFL

//
// MessageId: NS_E_DRM_LICENSE_SECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_SECLOW          0xC00D27E0L

//
// MessageId: NS_E_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
//  The content owner for the license you just acquired is no longer supporting their content. Contact the content owner for a newer version of the content.%0
//
#define NS_E_DRM_LICENSE_CONTENT_REVOKED 0xC00D27E1L

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           0xC00D280AL

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           0xC00D280BL

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
//  The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           0xC00D280CL

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  0xC00D280DL

;// End of License Reasons Section


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Setup Specific Errors
//
// IdRange = 11000..11999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_S_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation is successful.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_S_REBOOT_RECOMMENDED          0x000D2AF8L

//
// MessageId: NS_S_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  The system will not function correctly until the system is rebooted.%0
//
#define NS_S_REBOOT_REQUIRED             0x000D2AF9L

//
// MessageId: NS_E_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation failed.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_E_REBOOT_RECOMMENDED          0xC00D2AFAL

//
// MessageId: NS_E_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation failed.  The system will not function correctly until the system is rebooted.%0
//
#define NS_E_REBOOT_REQUIRED             0xC00D2AFBL


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
//  The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            0xC00D2EE0L

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
//  The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           0xC00D2EE1L

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
//  The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       0xC00D2EE2L

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
//  The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 0xC00D2EE3L

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
//  The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            0xC00D2EE4L

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
//  The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               0xC00D2EE5L

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          0xC00D2EE6L

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
//  The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           0xC00D2EE7L

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
//  The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         0xC00D2EE8L

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          0xC00D2EE9L

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
//  The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            0xC00D2EEAL

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      0xC00D2EEBL

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
//  The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    0xC00D2EECL

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
//  The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             0xC00D2EEDL

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
//  Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     0xC00D2EEEL

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          0xC00D2EEFL

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           0xC00D2EF0L

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
//  Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           0xC00D2EF1L


#endif // _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\avisrc\avisrc.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// AVIFile Source filter
//
// A Quartz source filter. We read avi files using the AVIFile apis, and
// push the data into streams. Supports IFileSourceFilter through which the
// filename is passed in. Exposes one pin per stream in the file. Creates one
// worker thread per connected pin. The worker thread pushes the data into
// the stream when active - it does not distinguish between running and paused
// mode.
//
// Positional information is supported by the pins, which expose IMediaPosition.
// upstream pins will use this to tell us the start/stop position and rate to
// use
//

#include <streams.h>
#include <vfw.h>

#include "avisrc.h"

// setup data

const AMOVIESETUP_MEDIATYPE
sudAVIVidType = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_MEDIATYPE
sudAVIAudType = { &MEDIATYPE_Audio      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudAVIDocPins[] = { { L"VideoOutput"       // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , TRUE                 // bZero
                     , TRUE                 // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L""                  // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVIVidType }     // lpTypes
                   , { L"AudioOutput"       // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , TRUE                 // bZero
                     , TRUE                 // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L""                  // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVIAudType } };  // lpTypes

const AMOVIESETUP_FILTER
sudAVIDoc = { &CLSID_AVIDoc            // clsID
            , L"AVI/WAV File Source"   // strName
            , MERIT_UNLIKELY           // dwMerit
            , 2                        // nPins
            , psudAVIDocPins };        // lpPin

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"AVI/WAV File Source"
    , &CLSID_AVIDoc
    , CAVIDocument::CreateInstance
    , NULL
    , &sudAVIDoc }
  ,
    { L""
    , &CLSID_AVIDocWriter
    , CAVIDocWrite::CreateInstance
    , NULL
    , NULL }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

/* Implements the CAVIDocument public member functions */


// constructors etc
CAVIDocument::CAVIDocument(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CUnknown(pName, pUnk),
      m_nStreams(0),
      m_paStreams(NULL),
      m_pFile(NULL)
{
    // need to do this before any avifile apis
    if (*phr == S_OK) {
        AVIFileInit();
        // should we check the return value?

        /* Create the interfaces we own */

        m_pFilter = new CImplFilter( NAME("Filter interfaces"), this, phr );
        if (m_pFilter == NULL) {
	    *phr = E_OUTOFMEMORY;
	    // no point in trying to create m_pFileSourceFilter, but we better null out
	    // the pointer to stop the destructor trying to free it
	    m_pFileSourceFilter = NULL;
	}
        else {
            m_pFileSourceFilter = new CImplFileSourceFilter( NAME("IFileSourceFilter interface"), this, phr );
            if (m_pFileSourceFilter == NULL) {
		delete m_pFilter;
		m_pFilter = NULL;
		*phr = E_OUTOFMEMORY;
            }
        }
    } else {
	m_pFilter = NULL;
	m_pFileSourceFilter = NULL;
    }

}

CAVIDocument::~CAVIDocument()
{
    CloseFile();

    /* Delete the interfaces we own */

    /* IBaseFilter */

    if (m_pFilter) {
	delete m_pFilter;
    }

    /* IFileSourceFilter */

    if (m_pFileSourceFilter) {
	delete m_pFileSourceFilter;
    }

    // need to do one of these for each AVIFileInit
    AVIFileExit();
}


// create a new instance of this class
CUnknown *
CAVIDocument::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CAVIDocument(NAME("AVI core document"), pUnk, phr);
}


// override this to say what interfaces we support where
STDMETHODIMP
CAVIDocument::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{

    /* See if we have the interface */
    /* try each of our interface supporting objects in turn */

    HRESULT hr;
    hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
    if (SUCCEEDED(hr)) {
        return hr;	// ppv has been set appropriately
    }

    hr = m_pFilter->NonDelegatingQueryInterface(riid, ppv);
    if (SUCCEEDED(hr)) {
        return hr;	// ppv has been set appropriately
    }

    return m_pFileSourceFilter->NonDelegatingQueryInterface(riid, ppv);
}


// return a non-addrefed pointer to the CBasePin.
CBasePin *
CAVIDocument::GetPin(int n)
{
    if ((m_nStreams > 0) && (n < m_nStreams) && m_paStreams[n]) {
	return m_paStreams[n];
    }
    return NULL;
}

//
// FindPin
//
// Set *ppPin to the IPin* that has the id Id.
// or to NULL if the Id cannot be matched.
//
HRESULT CAVIDocument::FindPin(LPCWSTR pwszPinId, IPin **ppPin)
{
    WCHAR szBuf [8] ;

    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));

    int ii = WstrToInt(pwszPinId);    // in sdk\classes\base\util

    // validate that string passed is valid.

    IntToWstr(ii, szBuf);
    if (0 != lstrcmpW(pwszPinId, szBuf))
    {
        //  They don't match.
        *ppPin = NULL;
        return VFW_E_NOT_FOUND;
    }

    *ppPin = GetPin(ii);
    if (*ppPin!=NULL) {
        (*ppPin)->AddRef();
        return S_OK;
    } else {
        return VFW_E_NOT_FOUND;
    }
}

//
// FindPinNumber
//
// return the number of the pin with this IPin* or -1 if none
int CAVIDocument::FindPinNumber (IPin * pPin){
   for (int ii = 0; ii < m_nStreams; ++ii)
      {
      if ((IPin *)m_paStreams[ii] == pPin)
          return ii;
      }
   return -1;
}


//
// QueryId
//
// Set ppwsz to point to a QzTaskMemAlloc'd pin id
//
STDMETHODIMP CAVIStream::QueryId (
   LPWSTR *ppwsz)
{
    CheckPointer(ppwsz, E_POINTER);
    ValidateReadWritePtr(ppwsz, sizeof(LPWSTR));


    int ii = m_pDoc->FindPinNumber(this);
    ASSERT(ii>=0);

    *ppwsz = (LPWSTR)QzTaskMemAlloc(8);
    if (*ppwsz==NULL) return E_OUTOFMEMORY;

    IntToWstr(ii, *ppwsz);
    return NOERROR;
}



// close all references to a file opened by m_ImplFileSourceFilter::Load
// called when loading another file, and by destructor.
void
CAVIDocument::CloseFile(void)
{
    // ensure that all streams are inactive
    m_pFilter->Stop();

    if (m_paStreams) {
	for (int i = 0; i < m_nStreams; i++) {
	    if (m_paStreams[i]) {
		delete m_paStreams[i];
	    }
	}
	delete[] m_paStreams;
	m_paStreams = NULL;
	m_nStreams = 0;
    }

    if (m_pFile) {
	m_pFile->Release();
	m_pFile = NULL;
    }
}


/* Implements the CImplFilter class */


/* Constructor */

CAVIDocument::CImplFilter::CImplFilter(
    TCHAR *pName,
    CAVIDocument *pAVIDocument,
    HRESULT *phr)
    : CBaseFilter(pName, pAVIDocument->GetOwner(), pAVIDocument, CLSID_AVIDoc)
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFilter::CImplFilter")));
    m_pAVIDocument = pAVIDocument;
}

/* Destructor */

CAVIDocument::CImplFilter::~CImplFilter()
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFilter::~CImplFilter")));
}


/* Implements the CImplFileSourceFilter class */


/* Constructor */

CAVIDocument::CImplFileSourceFilter::CImplFileSourceFilter(
    TCHAR *pName,
    CAVIDocument *pAVIDocument,
    HRESULT *phr)
    : CUnknown(pName, pAVIDocument->GetOwner())
    , m_pFileName(NULL)
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFileSourceFilter::CImplFileSourceFilter")));
    m_pAVIDocument = pAVIDocument;
}

/* Destructor */

CAVIDocument::CImplFileSourceFilter::~CImplFileSourceFilter()
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFileSourceFilter::~CImplFileSourceFilter")));
    Unload();
}

/* Override this to say what interfaces we support and where */

STDMETHODIMP CAVIDocument::CImplFileSourceFilter::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    /* Do we have this interface */

    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

STDMETHODIMP
CAVIDocument::CImplFileSourceFilter::Unload()
{
    if (m_pFileName) {
	delete[] m_pFileName;
	m_pFileName = NULL;
    }
    return S_OK;
}

STDMETHODIMP
CAVIDocument::CImplFileSourceFilter::Load(
    LPCOLESTR pszFileName,
    const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(pszFileName, E_POINTER);

    // is there a file loaded at the moment ?

    ASSERT(m_pAVIDocument);
    if (m_pAVIDocument->m_pFile) {
	// get rid of it
	m_pAVIDocument->CloseFile();
    }

    // Remove previous name
    Unload();

    //
    // do the init of the file and streams within it
    //

    DbgLog((LOG_TRACE,1,TEXT("File name to load %ls"),pszFileName));
    DbgLog((LOG_TRACE,1,TEXT("Owning document %d and AVIFILE pointer %d"),
	   m_pAVIDocument,m_pAVIDocument->m_pFile));

    HRESULT hr = AVIFileOpenW(
		    &m_pAVIDocument->m_pFile,
		    pszFileName,
		    MMIO_READ | OF_SHARE_DENY_WRITE,
		    NULL);

    if (FAILED(hr)) {
	m_pAVIDocument->m_pFile = NULL;
	return hr;
    }

    // count the streams and create a stream object for each
    AVIFILEINFOW fi;
    m_pAVIDocument->m_pFile->Info(&fi, sizeof(fi));

    m_pAVIDocument->m_paStreams = new CAVIStream *[fi.dwStreams];
    if (NULL == m_pAVIDocument->m_paStreams) {
        return E_OUTOFMEMORY;
    }
    m_pAVIDocument->m_nStreams = fi.dwStreams;

    for (int i = 0; i < m_pAVIDocument->m_nStreams; i++) {
	PAVISTREAM ps;
	hr = m_pAVIDocument->m_pFile->GetStream(&ps, 0, i);

	if (!FAILED(hr)) {
	    AVISTREAMINFOW si;
	    ps->Info(&si, sizeof(si));

	    m_pAVIDocument->m_paStreams[i] =
		new CAVIStream(
			NAME("AVI stream"),     //TCHAR *pName,
			&hr,                    //HRESULT * phr,
			m_pAVIDocument,         //CAVIDocument *
			ps,                     //PAVISTREAM pStream,
			&si                     //stream info (incl. name)
		    );

	    if (FAILED(hr)) {
		delete m_pAVIDocument->m_paStreams[i];
		m_pAVIDocument->m_paStreams[i] = NULL;
	    }

	    // release our copy of this pointer. Pin will have addrefed if
	    // it wants to keep it
	    ps->Release();

	} else {
	    m_pAVIDocument->m_paStreams[i] = NULL;
	}
    }

    //
    // Record the file name for GetCurFile
    //
    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)];
    if (m_pFileName!=NULL) {
        lstrcpyW(m_pFileName, pszFileName);
    }

    return NOERROR;
}

STDMETHODIMP
CAVIDocument::CImplFileSourceFilter::GetCurFile(
		LPOLESTR * ppszFileName,
                AM_MEDIA_TYPE *pmt)
{
    // return the current file name from avifile

    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
        *ppszFileName = (LPOLESTR) QzTaskMemAlloc( sizeof(WCHAR)
                                                 * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName!=NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        } else {
            return E_OUTOFMEMORY;
        }
    }

    if (pmt) {
        ZeroMemory(pmt, sizeof(*pmt));
    }

    return NOERROR;
}


/* Implements the CAVIStream class */


CAVIStream::CAVIStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CAVIDocument * pDoc,
    PAVISTREAM pStream,
    AVISTREAMINFOW* pSI)
    : CBaseOutputPin(pObjectName, pDoc->m_pFilter, pDoc, phr, pSI->szName)
    , m_pPosition(0)
    , m_pDoc(pDoc)
    , m_pStream(pStream)
    , m_lLastPaletteChange(-1)
{
    m_pStream->AddRef();

    // read the info and set duration, start pos.
    // note that if all the streams in the movie are authored to start
    // at a time > 0, we will still play the movie from 0 and expect everyone
    // to enjoy the subsequent period of silence.
    m_info = *pSI;

    m_Start = m_info.dwStart;
    m_Length = m_info.dwLength;
    m_lNextPaletteChange = m_Length+1;
}

CAVIStream::~CAVIStream()
{
    if (m_pPosition) {
	delete m_pPosition;
    }

    m_pStream->Release();
}

STDMETHODIMP
CAVIStream::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
    if (riid == IID_IMediaPosition) {
	if (!m_pPosition) {
	    HRESULT hr = S_OK;
	    m_pPosition = new CImplPosition(NAME("avi stream CImplPosition"),
					    this,
					    &hr);
	    if (m_pPosition == NULL) {
		return E_OUTOFMEMORY;
	    }
	    if (FAILED(hr)) {
		delete m_pPosition;
		m_pPosition = NULL;
		return hr;
	    }
	}
	return m_pPosition->NonDelegatingQueryInterface(riid, pv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, pv);
    }
}


// IPin interfaces


// return default media type & format
HRESULT
CAVIStream::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
	return E_INVALIDARG;
    }
    if (iPosition>0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    m_fccType.SetFOURCC(m_info.fccType);
    pt->SetType(&m_fccType);
    if (m_info.fccType == streamtypeVIDEO) {

	pt->SetType(&MEDIATYPE_Video);
	m_fccSubtype.SetFOURCC(m_info.fccHandler);
	pt->SetSubtype(&m_fccSubtype);
        pt->SetFormatType(&FORMAT_VideoInfo);

    } else if (m_info.fccType == streamtypeAUDIO) {

	pt->SetType(&MEDIATYPE_Audio);
        pt->SetFormatType(&FORMAT_WaveFormatEx);
	// set subtype for audio ??
    }

    // set samplesize
    if (m_info.dwSampleSize) {
	pt->SetSampleSize(m_info.dwSampleSize);
    } else {
	pt->SetVariableSize();
    }

    // is this stream temporally compressed ?

    // if there are any non-key frames, then there is no temporal
    // compression. Unfortunately we can't search for non-key frames, so
    // we simply ask if each of the first N are key, and if any is not,
    // then we set the temporal compression flag. For now, N is 5.
    // If N is too big then we take forever to start up...

    // assume no temporal compression
    pt->SetTemporalCompression(FALSE);
    for (LONG n = 0; n < 5; n++) {


	LONG sNextKey = AVIStreamFindSample(
			    m_pStream,
			    n,
			    FIND_NEXT|FIND_KEY);

	if (sNextKey > n) {
	    // this sample is not key, therefore there is temporal compression
    	    pt->SetTemporalCompression(TRUE);
    	    break;
	}
    }


    long cb = 0;        // number of bytes this format requires
    BYTE *pF = NULL;    // pointer to memory containing format
    long offset = 0;    // offset into block to read format

    // find out the size of the format info

    HRESULT hr = m_pStream->ReadFormat(0, NULL, &cb);
    if (FAILED(hr)) {
	return hr;
    }

    long cbReal = cb;

    // map an AVIFILE video format into VIDEOINFOHEADER structures

    if (m_info.fccType == streamtypeVIDEO) {
	ASSERT(cb >= sizeof(BITMAPINFOHEADER));
	offset = SIZE_PREHEADER;
	cbReal += offset;
    }
    if (m_info.fccType == streamtypeAUDIO && cbReal < sizeof(WAVEFORMATEX)) {
        cbReal = sizeof(WAVEFORMATEX);
    }

    pF = new BYTE[cbReal];
    if (pF == NULL) {
	return E_OUTOFMEMORY;
    }
    ZeroMemory(pF,cbReal);		// slightly timeconsuming...

    // set the frame rate for video streams
    if (m_info.fccType == streamtypeVIDEO) {
	ASSERT(m_info.dwRate);
	// if the frame rate is 0 then we have a problem about to occur
        ((VIDEOINFOHEADER *)pF)->AvgTimePerFrame =
			(LONGLONG)m_info.dwScale * (LONGLONG)10000000 /
						(LONGLONG)m_info.dwRate;
    }

    // read the actual stream format
    // it would be quicker and more efficient to call
    // pt->AllocFormat and read the format directly into that buffer
    // rather than allocating our own, reading, and calling SetFormat
    // which will do a copy, remembering of course the offset at the
    // front of the buffer

    hr = m_pStream->ReadFormat(0,pF + offset,&cb);
    if (SUCCEEDED(hr)) {
	if (!pt->SetFormat(pF, cbReal)) {
	    hr = E_OUTOFMEMORY;
	}
	else
        if (m_info.fccType == streamtypeAUDIO) {
	    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pF;

	    pt->SetSubtype(&FOURCCMap(pwfx->wFormatTag));

	    if (0 == m_info.dwSuggestedBufferSize) {
		// Set up an approx 0.125 seconds of buffer with a
		// minimum of 4K
                m_info.dwSuggestedBufferSize = max(2048, pwfx->nAvgBytesPerSec/8);

		// N.B.: This has NOT set the number of buffers.
		// That will be decided later
	    }
        } else if (m_info.fccType == streamtypeVIDEO) {

	    GUID subtype = GetBitmapSubtype((BITMAPINFOHEADER *)(pF + offset));
	    pt->SetSubtype(&subtype);
            // not fixing typo in legacy component
	    if (m_info.dwFlags /* && AVISF_VIDEO_PALCHANGES */) {
		m_lNextPaletteChange = AVIStreamFindSample(m_pStream, m_info.dwStart, FIND_NEXT | FIND_FORMAT);
		if (m_lNextPaletteChange == -1) {
                    m_lNextPaletteChange = m_info.dwLength+1;
		}
	    }

	} else {
	    DbgLog((LOG_ERROR, 1, "Unknown fcctype from AVIFILE %4hs", &m_info.fccType));
	}

    }

    delete[] pF;
    return hr;
}

// check if the pin can support this specific proposed type&format
HRESULT
CAVIStream::CheckMediaType(const CMediaType* pt)
{
    // we support exactly the type specified in the file header, and
    // no other.

    CMediaType mt;
    GetMediaType(0,&mt);
    if (mt == *pt) {
	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

HRESULT
CAVIStream::DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?
    if (m_info.fccType == streamtypeAUDIO)
	pProperties->cBuffers = 8;
    else
	pProperties->cBuffers = 4;

    ASSERT(m_info.dwSuggestedBufferSize > 0);
    // This assert is always hit when you open a wave file and it would
    // be nice if someone who understands it could fix it.
    // I'm leaving the assert in as a reminder to them.
    // To allow progress on other fronts in the meantime:

    if (m_info.dwSuggestedBufferSize <= 0)
        m_info.dwSuggestedBufferSize = 4096;

    pProperties->cbBuffer = m_info.dwSuggestedBufferSize;

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // buffers are too small - can't use this allocator
    if (Actual.cbBuffer < (long) m_info.dwSuggestedBufferSize) {
        // !!! need better error codes
	return E_INVALIDARG;
    }
    return NOERROR;
}


// returns the sample number showing at time t
LONG
CAVIStream::RefTimeToSample(CRefTime t)
{
    LONG s = AVIStreamTimeToSample(m_pStream, t.Millisecs());

    return s;
}

CRefTime
CAVIStream::SampleToRefTime(LONG s)
{
     CRefTime t(AVIStreamSampleToTime(m_pStream, s));
     return t;
}

LONG
CAVIStream::StartFrom(LONG sample)
{

    // if this stream has a start position offset then we cannot
    // ask for samples before that
    if (sample < m_Start) {
	return m_Start;
    }

    // we don't use the IsTemporalCompressed flag as we can't reliably
    // work it out.

    // if temporal compression, find prev key frame

    LONG s = AVIStreamFindSample(
	    m_pStream,
	    sample,
	    FIND_PREV | FIND_KEY);

    if (s < 0) {
	return sample;
    } else {
	return s;
    }
}


// this pin has gone active. Start the thread pushing
HRESULT
CAVIStream::Active()
{
    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
	return hr;
    }


    // start the thread
    if (!m_Worker.ThreadExists()) {
	if (!m_Worker.Create(this)) {
	    return E_FAIL;
	}
    }

    return m_Worker.Run();
}

// pin has gone inactive. Stop and exit the worker thread
HRESULT
CAVIStream::Inactive()
{
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr;
    if (m_Worker.ThreadExists()) {
	hr = m_Worker.Stop();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = m_Worker.Exit();
	if (FAILED(hr)) {
	    return hr;
	}
    }
    return CBaseOutputPin::Inactive();
}

STDMETHODIMP
CAVIStream::Notify(IBaseFilter * pSender, Quality q)
{
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // ideas anyone?

   return E_NOTIMPL;  // We are (currently) NOT handling this
}


/* ----- Implements the CAVIWorker class ------------------------------ */


CAVIWorker::CAVIWorker()
{
    m_pPin = NULL;
}

BOOL
CAVIWorker::Create(CAVIStream * pStream)
{
    CAutoLock lock(&m_AccessLock);

    if (m_pPin) {
	return FALSE;
    }
    m_pPin = pStream;
    return CAMThread::Create();
}


HRESULT
CAVIWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CAVIWorker::Stop()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CAVIWorker::Exit()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
	return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    m_pPin = NULL;
    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CAVIWorker::ThreadProc()
{

    BOOL bExit = FALSE;
    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }
    return NOERROR;
}

void
CAVIWorker::DoRunLoop(void)
{
    // snapshot start and stop times from the other thread
    CRefTime tStart, tStopAt;
    double dRate;
    LONG sStart;
    LONG sStopAt;

    if (m_pPin->m_pPosition) {
	CAutoLock lock(m_pPin->m_pPosition);

	tStart = m_pPin->m_pPosition->Start();
	tStopAt = m_pPin->m_pPosition->Stop();
	dRate = m_pPin->m_pPosition->Rate();

	// hold times in avifile sample format
	sStart = m_pPin->RefTimeToSample(tStart);
	sStopAt = m_pPin->RefTimeToSample(tStopAt);

    } else {
	// no-one has accessed the IMediaPosition - use known length
	sStart = 0;
	dRate = 1.0;

	// note that tStopAt is the time at which we stop, but
	// sStopAt is the last sample to send. So tStopAt is the end time
	// for sample sStopAt.
	sStopAt = m_pPin->m_Length - 1;
	tStart = 0;
	tStopAt = m_pPin->SampleToRefTime(m_pPin->m_Length);
    }


    // if the stream is temporally compressed, we need to start from
    // the previous key frame and play from there. All samples until the
    // actual start will be marked with negative times.
    // we send tStart as time 0, and start from tCurrent which may be
    // negative
    LONG sCurrent = m_pPin->StartFrom(sStart);

    while (TRUE) {

	ASSERT(m_pPin->m_pStream);

    	// each time before re-entering the push loop, check for changes
	// in start, stop or rate. If start has not changed, pick up from the
	// same current position.
	if (m_pPin->m_pPosition) {
	    CAutoLock lock(m_pPin->m_pPosition);

	    if (tStart != m_pPin->m_pPosition->Start()) {
		tStart = m_pPin->m_pPosition->Start();
		sStart = m_pPin->RefTimeToSample(tStart);
		sCurrent = m_pPin->StartFrom(sStart);
	    }

	    if (m_pPin->m_pPosition->Stop() != tStopAt) {
		tStopAt = m_pPin->m_pPosition->Stop();
		sStopAt = m_pPin->RefTimeToSample(tStopAt);
	    }
	    dRate = m_pPin->m_pPosition->Rate();
	}

	// check we are not going over the end
	sStopAt = min(sStopAt, m_pPin->m_Length-1);

        // set the variables checked by PushLoop - these can also be set
        // on the fly
        m_pPin->SetRate(dRate);
        m_pPin->SetStopAt(sStopAt, tStopAt);

	// tell AVIFile to start its streaming code
	AVIStreamBeginStreaming(
	    m_pPin->m_pStream,
	    sCurrent,
	    sStopAt,
	    1000);


	ASSERT(sCurrent >= 0);

	// returns S_OK if reached end
	HRESULT hr = PushLoop(sCurrent, sStart, tStart);
	if (S_OK == hr) {

	    // all done
	    // reached end of stream - notify downstream
	    m_pPin->DeliverEndOfStream();
	
	    break;
	} else if (FAILED(hr)) {

	    // signal an error to the filter graph and stop

	    // This could be the error reported from GetBuffer when we
	    // are stopping. In that case, nothing is wrong, really
	    if (hr != VFW_E_NOT_COMMITTED) {
	        DbgLog((LOG_ERROR,1,TEXT("PushLoop failed! hr=%lx"), hr));
	        m_pPin->m_pDoc->m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

	        m_pPin->DeliverEndOfStream();
	    } else {
	        DbgLog((LOG_TRACE,1,TEXT("PushLoop failed! But I don't care")));
	    }

	    break;
	} // else S_FALSE - go round again

	Command com;
	if (CheckRequest(&com)) {
	    // if it's a run command, then we're already running, so
	    // eat it now.
	    if (com == CMD_RUN) {
		GetRequest();
		Reply(NOERROR);
	    } else {
		break;
	    }
	}
    }


    // end streaming
    AVIStreamEndStreaming(m_pPin->m_pStream);
    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop")));
}


// return S_OK if reach sStop, S_FALSE if pos changed, or else error
HRESULT
CAVIWorker::PushLoop(
    LONG sCurrent,
    LONG sStart,
    CRefTime tStart
    )
{
    DbgLog((LOG_TRACE,1,TEXT("Entering streaming loop: start = %d, stop=%d"),
	    sCurrent, m_pPin->GetStopAt()));

    LONG sFirst = sCurrent; // remember the first thing we're sending

    // since we are starting on a new segment, notify the downstream pin
    m_pPin->DeliverNewSegment(tStart, m_pPin->GetStopTime(), m_pPin->GetRate());


    // we send one sample at m_sStopAt, but we set the time stamp such that
    // it won't get rendered except for media types that understand static
    // rendering (eg video). This means that play from 10 to 10 does the right
    // thing (completing, with frame 10 visible and no audio).

    while (sCurrent <= m_pPin->GetStopAt()) {

	LONG sCount;

	// get a buffer
	DbgLog((LOG_TRACE,5,TEXT("Getting buffer...")));

	// Fake the time stamps, so DirectDraw can be used if we're connected
	// directly to the renderer (we must pass non-NULL numbers to
	// GetDeliveryBuffer).
	// We don't really know sCount yet, so we're basically guessing, but
	// we don't have a choice.. to get the same sCount as we're about to
	// calculate below, we need to have already called GetDeliveryBuffer!
	CRefTime tStartMe, tStopMe;
	IMediaSample * pSample;
	HRESULT hr;

        double dRate = m_pPin->GetRate();
        LONG sStop = m_pPin->GetStopAt();

	if (dRate) {
	    tStartMe = m_pPin->SampleToRefTime(sCurrent) - tStart;
	    if (m_pPin->m_mt.IsFixedSize())
	        sCount = (sStop+1) - sCurrent;  // real answer may be smaller
	    else
	        sCount = 1;

	    tStopMe = m_pPin->SampleToRefTime(sCurrent + sCount) - tStart;

	    if (dRate != 1.0) {
		tStartMe = LONGLONG( tStartMe.GetUnits() / dRate);
		tStopMe = LONGLONG( tStopMe.GetUnits() / dRate);
	    }

	    hr = m_pPin->GetDeliveryBuffer((IMediaSample **) &pSample,
                                           (REFERENCE_TIME *) &tStartMe,
                                           (REFERENCE_TIME *) &tStopMe,
                                           0);
	}
	else
	    hr = m_pPin->GetDeliveryBuffer(&pSample, NULL, NULL, 0);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Error %lx getting delivery buffer"), hr));
	    return hr;
	}

	DbgLog((LOG_TRACE,5,TEXT("Got buffer, size=%d"), pSample->GetSize()));

	if (m_pPin->m_mt.IsFixedSize()) {
	    // package all fixed size samples into one buffer,
	    // if they fit, except that key samples must
	    // be at the start of the buffer.

	    // allow one sample at sStopAt
	    sCount = (sStop+1) - sCurrent;

	    // how many fit ?
	    sCount = min(sCount, pSample->GetSize() / (LONG) m_pPin->m_mt.GetSampleSize());

	    if (m_pPin->m_mt.IsTemporalCompressed()) {

		// look for a sync point in a sample after the first one
		// and break before it
		LONG sNextKey = AVIStreamFindSample(
				    m_pPin->m_pStream,
				    sCurrent+1,
				    FIND_NEXT|FIND_KEY);
		if (sNextKey != -1) {
		    sCount = min(sCount, sNextKey - sCurrent);
		}
	    }
	} else {
	    // variable-size samples, therefore one per buffer
	    sCount = 1;
	}

	// mark sample as preroll or not....
	pSample->SetPreroll(sCurrent < sStart);
	
	// mark as a sync point if the first sample is one
	if (AVIStreamFindSample(
		m_pPin->m_pStream,
		sCurrent,
		FIND_NEXT|FIND_KEY) == sCurrent) {
	    pSample->SetSyncPoint(TRUE);
	} else {
	    pSample->SetSyncPoint(FALSE);
	}

	// If this is the first thing we're sending, it is discontinuous
	// from the last thing they received.
	if (sCurrent == sFirst)
	    pSample->SetDiscontinuity(TRUE);
	else
	    pSample->SetDiscontinuity(FALSE);

	PBYTE pbuf;
	hr = pSample->GetPointer(&pbuf);
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	    pSample->Release();
	    return E_OUTOFMEMORY;
	}

	LONG lBytes;

	hr = AVIStreamRead(
		    m_pPin->m_pStream,
		    sCurrent,
		    sCount,
		    pbuf,
		    pSample->GetSize(),
		    &lBytes,
		    &sCount);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("AVIStreamRead failed! hr=%lx"), hr));
	    pSample->Release();
	    return hr;
	}

	hr = pSample->SetActualDataLength(lBytes);
	ASSERT(SUCCEEDED(hr));

	// set the start/stop time for this sample.
	CRefTime tThisStart = m_pPin->SampleToRefTime(sCurrent) - tStart;
	CRefTime tThisEnd = m_pPin->SampleToRefTime(sCurrent + sCount) - tStart;

	// we may have pushed a sample past the stop time, but we need to
	// make sure that the stop time is correct
	tThisEnd = min(tThisEnd, m_pPin->GetStopTime());

	// adjust both times by Rate... unless Rate is 0

	if (dRate && (dRate!=1.0)) {
	    tThisStart = LONGLONG( tThisStart.GetUnits() / dRate);
	    tThisEnd = LONGLONG( tThisEnd.GetUnits() / dRate);
	}

	pSample->SetTime((REFERENCE_TIME *)&tThisStart,
                         (REFERENCE_TIME *)&tThisEnd);

	// IF there are palette changes...

        if ((m_pPin->m_info.fccType == streamtypeVIDEO)
	   && (m_pPin->m_info.dwFlags & AVISF_VIDEO_PALCHANGES)) {

	    // if we are in the range of the current palette do nothing
	    if ((sCurrent < (m_pPin->m_lLastPaletteChange))
	      || (sCurrent >= (m_pPin->m_lNextPaletteChange)))
	    {
		VIDEOINFOHEADER* pFormat = (VIDEOINFOHEADER*)m_pPin->m_mt.Format();
		LONG offset = SIZE_PREHEADER;

		// Assert that the new format will fit into the old format
		LONG cb;
                hr = m_pPin->m_pStream->ReadFormat(sCurrent, NULL, &cb);
		if (!FAILED(hr)) {
		    LONG cbLength = (LONG)m_pPin->m_mt.FormatLength();
		    ASSERT(cb+offset <= cbLength);
		    // otherwise we had better reallocate the format buffer
		}

		hr = m_pPin->m_pStream->ReadFormat(sCurrent,&(pFormat->bmiHeader),&cb);
		ASSERT(hr == S_OK);	// should be as we only just checked above

		AM_MEDIA_TYPE mt;
		CopyMediaType( &mt, &(m_pPin->m_mt) );
		pSample->SetMediaType(&mt);
		FreeMediaType(mt);

		m_pPin->m_lLastPaletteChange = sCurrent;
		m_pPin->m_lNextPaletteChange = AVIStreamFindSample(m_pPin->m_pStream, sCurrent, FIND_NEXT | FIND_FORMAT);
		if (m_pPin->m_lNextPaletteChange == -1)
		    m_pPin->m_lNextPaletteChange = m_pPin->m_info.dwLength+1;
	    }
	}


	DbgLog((LOG_TRACE,5,TEXT("Sending buffer, size = %d"), lBytes));
	hr = m_pPin->Deliver(pSample);

	// done with buffer. connected pin may have its own addref
	DbgLog((LOG_TRACE,4,TEXT("Sample is delivered - releasing")));
	pSample->Release();
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("... but sample FAILED to deliver! hr=%lx"), hr));
	    // pretend everything's OK.  If we return an error, we'll panic
	    // and send EC_ERRORABORT and EC_COMPLETE, which is the wrong thing
	    // to do if we've tried to deliver something downstream.  Only
	    // if the downstream guy never got a chance to see the data do I
	    // feel like panicing.  For instance, the downstream guy could
	    // be failing because he's already seen EndOfStream (this thread
	    // hasn't noticed it yet) and he's already sent EC_COMPLETE and I
	    // would send another one!
	    return S_OK;
	}
	sCurrent += sCount;
	// what about hr==S_FALSE... I thought this would mean that
	// no more data should be sent down the pipe.

	// any other requests ?
	Command com;
	if (CheckRequest(&com)) {
	    return S_FALSE;
	}

    }

    return S_OK;
}

// ------ IMediaPosition implementation -----------------------

HRESULT
CAVIStream::CImplPosition::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

    CAutoLock lock(&m_pStream->m_Worker.m_AccessLock);

    if (m_pStream->m_Worker.ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	m_pStream->DeliverBeginFlush();

	// make sure we have stopped pushing
	m_pStream->m_Worker.Stop();

	// complete the flush
	m_pStream->DeliverEndFlush();

	// restart
	m_pStream->m_Worker.Run();
    }
    return S_OK;
}

HRESULT
CAVIStream::CImplPosition::ChangeRate()
{
    // changing the rate can be done on the fly

    m_pStream->SetRate(Rate());
    return S_OK;
}

HRESULT
CAVIStream::CImplPosition::ChangeStop()
{
    // we don't need to restart the worker thread to handle stop changes
    // and in any case that would be wrong since it would then start
    // pushing from the wrong place. Set the variables used by
    // the PushLoop
    REFERENCE_TIME tStopAt = Stop();
    LONG sStopAt = m_pStream->RefTimeToSample(tStopAt);
    m_pStream->SetStopAt(sStopAt, tStopAt);

    return S_OK;

}

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)

CAVIStream::CImplPosition::CImplPosition(
    TCHAR* pName,
    CAVIStream* pStream,
    HRESULT* phr)
    : CSourcePosition(pName, pStream->GetOwner(), phr, (CCritSec*)this),
      m_pStream(pStream)
{
    m_Duration = (LONGLONG)m_pStream->SampleToRefTime(m_pStream->m_Length);
    m_Stop = m_Duration;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsecure.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 21 15:21:55 2000
 */
/* Compiler settings for .\wmsecure.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsecure_h__
#define __wmsecure_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMAuthorizer_FWD_DEFINED__
#define __IWMAuthorizer_FWD_DEFINED__
typedef interface IWMAuthorizer IWMAuthorizer;
#endif 	/* __IWMAuthorizer_FWD_DEFINED__ */


#ifndef __IWMSecureChannel_FWD_DEFINED__
#define __IWMSecureChannel_FWD_DEFINED__
typedef interface IWMSecureChannel IWMSecureChannel;
#endif 	/* __IWMSecureChannel_FWD_DEFINED__ */


#ifndef __IWMGetSecureChannel_FWD_DEFINED__
#define __IWMGetSecureChannel_FWD_DEFINED__
typedef interface IWMGetSecureChannel IWMGetSecureChannel;
#endif 	/* __IWMGetSecureChannel_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsecure_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
EXTERN_GUID( IID_IWMAuthorizer,     0xd9b67d36, 0xa9ad, 0x4eb4, 0xba, 0xef, 0xdb, 0x28, 0x4e, 0xf5, 0x50, 0x4c );
EXTERN_GUID( IID_IWMSecureChannel,  0x2720598a, 0xd0f2, 0x4189, 0xbd, 0x10, 0x91, 0xc4, 0x6e, 0xf0, 0x93, 0x6f );
EXTERN_GUID( IID_IWMGetSecureChannel, 0x94bc0598, 0xc3d2, 0x11d3, 0xbe, 0xdf, 0x00, 0xc0, 0x4f, 0x61, 0x29, 0x86 );


extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0000_v0_0_s_ifspec;

#ifndef __IWMAuthorizer_INTERFACE_DEFINED__
#define __IWMAuthorizer_INTERFACE_DEFINED__

/* interface IWMAuthorizer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMAuthorizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9B67D36-A9AD-4eb4-BAEF-DB284EF5504C")
    IWMAuthorizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCertCount( 
            /* [out] */ DWORD __RPC_FAR *pcCerts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCert( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSharedData( 
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData,
            /* [in] */ BYTE __RPC_FAR *pbCert,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMAuthorizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMAuthorizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMAuthorizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertCount )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCerts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCert )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSharedData )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData,
            /* [in] */ BYTE __RPC_FAR *pbCert,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData);
        
        END_INTERFACE
    } IWMAuthorizerVtbl;

    interface IWMAuthorizer
    {
        CONST_VTBL struct IWMAuthorizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMAuthorizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMAuthorizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMAuthorizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMAuthorizer_GetCertCount(This,pcCerts)	\
    (This)->lpVtbl -> GetCertCount(This,pcCerts)

#define IWMAuthorizer_GetCert(This,dwIndex,ppbCertData)	\
    (This)->lpVtbl -> GetCert(This,dwIndex,ppbCertData)

#define IWMAuthorizer_GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)	\
    (This)->lpVtbl -> GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMAuthorizer_GetCertCount_Proxy( 
    IWMAuthorizer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcCerts);


void __RPC_STUB IWMAuthorizer_GetCertCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMAuthorizer_GetCert_Proxy( 
    IWMAuthorizer __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData);


void __RPC_STUB IWMAuthorizer_GetCert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMAuthorizer_GetSharedData_Proxy( 
    IWMAuthorizer __RPC_FAR * This,
    /* [in] */ DWORD dwCertIndex,
    /* [in] */ const BYTE __RPC_FAR *pbSharedData,
    /* [in] */ BYTE __RPC_FAR *pbCert,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData);


void __RPC_STUB IWMAuthorizer_GetSharedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMAuthorizer_INTERFACE_DEFINED__ */


#ifndef __IWMSecureChannel_INTERFACE_DEFINED__
#define __IWMSecureChannel_INTERFACE_DEFINED__

/* interface IWMSecureChannel */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMSecureChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2720598A-D0F2-4189-BD10-91C46EF0936F")
    IWMSecureChannel : public IWMAuthorizer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WMSC_AddCertificate( 
            /* [in] */ IWMAuthorizer __RPC_FAR *pCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_AddSignature( 
            /* [in] */ BYTE __RPC_FAR *pbCertSig,
            /* [in] */ DWORD cbCertSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Connect( 
            /* [in] */ IWMSecureChannel __RPC_FAR *pOtherSide) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_IsConnected( 
            /* [out] */ BOOL __RPC_FAR *pfIsConnected) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_GetValidCertificate( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertificate,
            /* [out] */ DWORD __RPC_FAR *pdwSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Encrypt( 
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Decrypt( 
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Lock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Unlock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_SetSharedData( 
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSecureChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSecureChannel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertCount )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCerts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCert )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSharedData )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData,
            /* [in] */ BYTE __RPC_FAR *pbCert,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_AddCertificate )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ IWMAuthorizer __RPC_FAR *pCert);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_AddSignature )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbCertSig,
            /* [in] */ DWORD cbCertSig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Connect )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ IWMSecureChannel __RPC_FAR *pOtherSide);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_IsConnected )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsConnected);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Disconnect )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_GetValidCertificate )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertificate,
            /* [out] */ DWORD __RPC_FAR *pdwSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Encrypt )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Decrypt )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Lock )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Unlock )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_SetSharedData )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData);
        
        END_INTERFACE
    } IWMSecureChannelVtbl;

    interface IWMSecureChannel
    {
        CONST_VTBL struct IWMSecureChannelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSecureChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSecureChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSecureChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSecureChannel_GetCertCount(This,pcCerts)	\
    (This)->lpVtbl -> GetCertCount(This,pcCerts)

#define IWMSecureChannel_GetCert(This,dwIndex,ppbCertData)	\
    (This)->lpVtbl -> GetCert(This,dwIndex,ppbCertData)

#define IWMSecureChannel_GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)	\
    (This)->lpVtbl -> GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)


#define IWMSecureChannel_WMSC_AddCertificate(This,pCert)	\
    (This)->lpVtbl -> WMSC_AddCertificate(This,pCert)

#define IWMSecureChannel_WMSC_AddSignature(This,pbCertSig,cbCertSig)	\
    (This)->lpVtbl -> WMSC_AddSignature(This,pbCertSig,cbCertSig)

#define IWMSecureChannel_WMSC_Connect(This,pOtherSide)	\
    (This)->lpVtbl -> WMSC_Connect(This,pOtherSide)

#define IWMSecureChannel_WMSC_IsConnected(This,pfIsConnected)	\
    (This)->lpVtbl -> WMSC_IsConnected(This,pfIsConnected)

#define IWMSecureChannel_WMSC_Disconnect(This)	\
    (This)->lpVtbl -> WMSC_Disconnect(This)

#define IWMSecureChannel_WMSC_GetValidCertificate(This,ppbCertificate,pdwSignature)	\
    (This)->lpVtbl -> WMSC_GetValidCertificate(This,ppbCertificate,pdwSignature)

#define IWMSecureChannel_WMSC_Encrypt(This,pbData,cbData)	\
    (This)->lpVtbl -> WMSC_Encrypt(This,pbData,cbData)

#define IWMSecureChannel_WMSC_Decrypt(This,pbData,cbData)	\
    (This)->lpVtbl -> WMSC_Decrypt(This,pbData,cbData)

#define IWMSecureChannel_WMSC_Lock(This)	\
    (This)->lpVtbl -> WMSC_Lock(This)

#define IWMSecureChannel_WMSC_Unlock(This)	\
    (This)->lpVtbl -> WMSC_Unlock(This)

#define IWMSecureChannel_WMSC_SetSharedData(This,dwCertIndex,pbSharedData)	\
    (This)->lpVtbl -> WMSC_SetSharedData(This,dwCertIndex,pbSharedData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_AddCertificate_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ IWMAuthorizer __RPC_FAR *pCert);


void __RPC_STUB IWMSecureChannel_WMSC_AddCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_AddSignature_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbCertSig,
    /* [in] */ DWORD cbCertSig);


void __RPC_STUB IWMSecureChannel_WMSC_AddSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Connect_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ IWMSecureChannel __RPC_FAR *pOtherSide);


void __RPC_STUB IWMSecureChannel_WMSC_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_IsConnected_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsConnected);


void __RPC_STUB IWMSecureChannel_WMSC_IsConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Disconnect_Proxy( 
    IWMSecureChannel __RPC_FAR * This);


void __RPC_STUB IWMSecureChannel_WMSC_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_GetValidCertificate_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertificate,
    /* [out] */ DWORD __RPC_FAR *pdwSignature);


void __RPC_STUB IWMSecureChannel_WMSC_GetValidCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Encrypt_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD cbData);


void __RPC_STUB IWMSecureChannel_WMSC_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Decrypt_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD cbData);


void __RPC_STUB IWMSecureChannel_WMSC_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Lock_Proxy( 
    IWMSecureChannel __RPC_FAR * This);


void __RPC_STUB IWMSecureChannel_WMSC_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Unlock_Proxy( 
    IWMSecureChannel __RPC_FAR * This);


void __RPC_STUB IWMSecureChannel_WMSC_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_SetSharedData_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ DWORD dwCertIndex,
    /* [in] */ const BYTE __RPC_FAR *pbSharedData);


void __RPC_STUB IWMSecureChannel_WMSC_SetSharedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSecureChannel_INTERFACE_DEFINED__ */


#ifndef __IWMGetSecureChannel_INTERFACE_DEFINED__
#define __IWMGetSecureChannel_INTERFACE_DEFINED__

/* interface IWMGetSecureChannel */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMGetSecureChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94bc0598-c3d2-11d3-bedf-00c04f612986")
    IWMGetSecureChannel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPeerSecureChannelInterface( 
            /* [out] */ IWMSecureChannel __RPC_FAR *__RPC_FAR *ppPeer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMGetSecureChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMGetSecureChannel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMGetSecureChannel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMGetSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPeerSecureChannelInterface )( 
            IWMGetSecureChannel __RPC_FAR * This,
            /* [out] */ IWMSecureChannel __RPC_FAR *__RPC_FAR *ppPeer);
        
        END_INTERFACE
    } IWMGetSecureChannelVtbl;

    interface IWMGetSecureChannel
    {
        CONST_VTBL struct IWMGetSecureChannelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMGetSecureChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMGetSecureChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMGetSecureChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMGetSecureChannel_GetPeerSecureChannelInterface(This,ppPeer)	\
    (This)->lpVtbl -> GetPeerSecureChannelInterface(This,ppPeer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMGetSecureChannel_GetPeerSecureChannelInterface_Proxy( 
    IWMGetSecureChannel __RPC_FAR * This,
    /* [out] */ IWMSecureChannel __RPC_FAR *__RPC_FAR *ppPeer);


void __RPC_STUB IWMGetSecureChannel_GetPeerSecureChannelInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMGetSecureChannel_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmsecure_0246 */
/* [local] */ 

HRESULT STDMETHODCALLTYPE WMCreateSecureChannel( IWMSecureChannel** ppChannel );


extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0246_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0246_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsdkidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 24 07:28:46 2000
 */
/* Compiler settings for .\wmsdkidl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif 	/* __IWMMediaProps_FWD_DEFINED__ */


#ifndef __IWMVideoMediaProps_FWD_DEFINED__
#define __IWMVideoMediaProps_FWD_DEFINED__
typedef interface IWMVideoMediaProps IWMVideoMediaProps;
#endif 	/* __IWMVideoMediaProps_FWD_DEFINED__ */


#ifndef __IWMWriter_FWD_DEFINED__
#define __IWMWriter_FWD_DEFINED__
typedef interface IWMWriter IWMWriter;
#endif 	/* __IWMWriter_FWD_DEFINED__ */


#ifndef __IWMInputMediaProps_FWD_DEFINED__
#define __IWMInputMediaProps_FWD_DEFINED__
typedef interface IWMInputMediaProps IWMInputMediaProps;
#endif 	/* __IWMInputMediaProps_FWD_DEFINED__ */


#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif 	/* __IWMReader_FWD_DEFINED__ */


#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif 	/* __IWMOutputMediaProps_FWD_DEFINED__ */


#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif 	/* __IWMStatusCallback_FWD_DEFINED__ */


#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif 	/* __IWMReaderCallback_FWD_DEFINED__ */


#ifndef __IWMCredentialCallback_FWD_DEFINED__
#define __IWMCredentialCallback_FWD_DEFINED__
typedef interface IWMCredentialCallback IWMCredentialCallback;
#endif 	/* __IWMCredentialCallback_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif 	/* __IWMMetadataEditor_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo_FWD_DEFINED__
#define __IWMHeaderInfo_FWD_DEFINED__
typedef interface IWMHeaderInfo IWMHeaderInfo;
#endif 	/* __IWMHeaderInfo_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo2_FWD_DEFINED__
#define __IWMHeaderInfo2_FWD_DEFINED__
typedef interface IWMHeaderInfo2 IWMHeaderInfo2;
#endif 	/* __IWMHeaderInfo2_FWD_DEFINED__ */


#ifndef __IWMProfileManager_FWD_DEFINED__
#define __IWMProfileManager_FWD_DEFINED__
typedef interface IWMProfileManager IWMProfileManager;
#endif 	/* __IWMProfileManager_FWD_DEFINED__ */


#ifndef __IWMProfileManager2_FWD_DEFINED__
#define __IWMProfileManager2_FWD_DEFINED__
typedef interface IWMProfileManager2 IWMProfileManager2;
#endif 	/* __IWMProfileManager2_FWD_DEFINED__ */


#ifndef __IWMProfile_FWD_DEFINED__
#define __IWMProfile_FWD_DEFINED__
typedef interface IWMProfile IWMProfile;
#endif 	/* __IWMProfile_FWD_DEFINED__ */


#ifndef __IWMProfile2_FWD_DEFINED__
#define __IWMProfile2_FWD_DEFINED__
typedef interface IWMProfile2 IWMProfile2;
#endif 	/* __IWMProfile2_FWD_DEFINED__ */


#ifndef __IWMStreamConfig_FWD_DEFINED__
#define __IWMStreamConfig_FWD_DEFINED__
typedef interface IWMStreamConfig IWMStreamConfig;
#endif 	/* __IWMStreamConfig_FWD_DEFINED__ */


#ifndef __IWMPacketSize_FWD_DEFINED__
#define __IWMPacketSize_FWD_DEFINED__
typedef interface IWMPacketSize IWMPacketSize;
#endif 	/* __IWMPacketSize_FWD_DEFINED__ */


#ifndef __IWMStreamList_FWD_DEFINED__
#define __IWMStreamList_FWD_DEFINED__
typedef interface IWMStreamList IWMStreamList;
#endif 	/* __IWMStreamList_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion_FWD_DEFINED__
#define __IWMMutualExclusion_FWD_DEFINED__
typedef interface IWMMutualExclusion IWMMutualExclusion;
#endif 	/* __IWMMutualExclusion_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced_FWD_DEFINED__
#define __IWMWriterAdvanced_FWD_DEFINED__
typedef interface IWMWriterAdvanced IWMWriterAdvanced;
#endif 	/* __IWMWriterAdvanced_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced2_FWD_DEFINED__
#define __IWMWriterAdvanced2_FWD_DEFINED__
typedef interface IWMWriterAdvanced2 IWMWriterAdvanced2;
#endif 	/* __IWMWriterAdvanced2_FWD_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_FWD_DEFINED__
#define __IWMWriterPostViewCallback_FWD_DEFINED__
typedef interface IWMWriterPostViewCallback IWMWriterPostViewCallback;
#endif 	/* __IWMWriterPostViewCallback_FWD_DEFINED__ */


#ifndef __IWMWriterPostView_FWD_DEFINED__
#define __IWMWriterPostView_FWD_DEFINED__
typedef interface IWMWriterPostView IWMWriterPostView;
#endif 	/* __IWMWriterPostView_FWD_DEFINED__ */


#ifndef __IWMWriterSink_FWD_DEFINED__
#define __IWMWriterSink_FWD_DEFINED__
typedef interface IWMWriterSink IWMWriterSink;
#endif 	/* __IWMWriterSink_FWD_DEFINED__ */


#ifndef __IWMRegisterCallback_FWD_DEFINED__
#define __IWMRegisterCallback_FWD_DEFINED__
typedef interface IWMRegisterCallback IWMRegisterCallback;
#endif 	/* __IWMRegisterCallback_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink_FWD_DEFINED__
#define __IWMWriterFileSink_FWD_DEFINED__
typedef interface IWMWriterFileSink IWMWriterFileSink;
#endif 	/* __IWMWriterFileSink_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink2_FWD_DEFINED__
#define __IWMWriterFileSink2_FWD_DEFINED__
typedef interface IWMWriterFileSink2 IWMWriterFileSink2;
#endif 	/* __IWMWriterFileSink2_FWD_DEFINED__ */


#ifndef __IWMWriterNetworkSink_FWD_DEFINED__
#define __IWMWriterNetworkSink_FWD_DEFINED__
typedef interface IWMWriterNetworkSink IWMWriterNetworkSink;
#endif 	/* __IWMWriterNetworkSink_FWD_DEFINED__ */


#ifndef __IWMClientConnections_FWD_DEFINED__
#define __IWMClientConnections_FWD_DEFINED__
typedef interface IWMClientConnections IWMClientConnections;
#endif 	/* __IWMClientConnections_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced_FWD_DEFINED__
#define __IWMReaderAdvanced_FWD_DEFINED__
typedef interface IWMReaderAdvanced IWMReaderAdvanced;
#endif 	/* __IWMReaderAdvanced_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced2_FWD_DEFINED__
#define __IWMReaderAdvanced2_FWD_DEFINED__
typedef interface IWMReaderAdvanced2 IWMReaderAdvanced2;
#endif 	/* __IWMReaderAdvanced2_FWD_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_FWD_DEFINED__
#define __IWMReaderAllocatorEx_FWD_DEFINED__
typedef interface IWMReaderAllocatorEx IWMReaderAllocatorEx;
#endif 	/* __IWMReaderAllocatorEx_FWD_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_FWD_DEFINED__
#define __IWMReaderTypeNegotiation_FWD_DEFINED__
typedef interface IWMReaderTypeNegotiation IWMReaderTypeNegotiation;
#endif 	/* __IWMReaderTypeNegotiation_FWD_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_FWD_DEFINED__
#define __IWMReaderCallbackAdvanced_FWD_DEFINED__
typedef interface IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced;
#endif 	/* __IWMReaderCallbackAdvanced_FWD_DEFINED__ */


#ifndef __IWMDRMReader_FWD_DEFINED__
#define __IWMDRMReader_FWD_DEFINED__
typedef interface IWMDRMReader IWMDRMReader;
#endif 	/* __IWMDRMReader_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_FWD_DEFINED__
#define __IWMReaderNetworkConfig_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig IWMReaderNetworkConfig;
#endif 	/* __IWMReaderNetworkConfig_FWD_DEFINED__ */


#ifndef __IWMReaderStreamClock_FWD_DEFINED__
#define __IWMReaderStreamClock_FWD_DEFINED__
typedef interface IWMReaderStreamClock IWMReaderStreamClock;
#endif 	/* __IWMReaderStreamClock_FWD_DEFINED__ */


#ifndef __IWMIndexer_FWD_DEFINED__
#define __IWMIndexer_FWD_DEFINED__
typedef interface IWMIndexer IWMIndexer;
#endif 	/* __IWMIndexer_FWD_DEFINED__ */


#ifndef __IWMLicenseBackup_FWD_DEFINED__
#define __IWMLicenseBackup_FWD_DEFINED__
typedef interface IWMLicenseBackup IWMLicenseBackup;
#endif 	/* __IWMLicenseBackup_FWD_DEFINED__ */


#ifndef __IWMLicenseRestore_FWD_DEFINED__
#define __IWMLicenseRestore_FWD_DEFINED__
typedef interface IWMLicenseRestore IWMLicenseRestore;
#endif 	/* __IWMLicenseRestore_FWD_DEFINED__ */


#ifndef __IWMBackupRestoreProps_FWD_DEFINED__
#define __IWMBackupRestoreProps_FWD_DEFINED__
typedef interface IWMBackupRestoreProps IWMBackupRestoreProps;
#endif 	/* __IWMBackupRestoreProps_FWD_DEFINED__ */


#ifndef __IWMCodecInfo_FWD_DEFINED__
#define __IWMCodecInfo_FWD_DEFINED__
typedef interface IWMCodecInfo IWMCodecInfo;
#endif 	/* __IWMCodecInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsbuffer.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsdkidl_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
typedef unsigned __int64 QWORD;






























////////////////////////////////////////////////////////////////
//
// These are the special case attributes that give information 
// about the Windows Media file.
//
static const DWORD g_dwWMSpecialAttributes = 14;
static const WCHAR *g_wszWMDuration = L"Duration";
static const WCHAR *g_wszWMBitrate = L"Bitrate";
static const WCHAR *g_wszWMSeekable = L"Seekable";
static const WCHAR *g_wszWMStridable = L"Stridable";
static const WCHAR *g_wszWMBroadcast = L"Broadcast";
static const WCHAR *g_wszWMProtected = L"Is_Protected";
static const WCHAR *g_wszWMTrusted = L"Is_Trusted";
static const WCHAR *g_wszWMSignature_Name = L"Signature_Name";
static const WCHAR *g_wszWMHasAudio = L"HasAudio";
static const WCHAR *g_wszWMHasImage = L"HasImage";
static const WCHAR *g_wszWMHasScript = L"HasScript";
static const WCHAR *g_wszWMHasVideo = L"HasVideo";
static const WCHAR *g_wszWMCurrentBitrate = L"CurrentBitrate";
static const WCHAR *g_wszWMOptimalBitrate = L"OptimalBitrate";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const DWORD g_dwWMContentAttributes = 5;
static const WCHAR *g_wszWMTitle = L"Title";
static const WCHAR *g_wszWMAuthor = L"Author";
static const WCHAR *g_wszWMDescription = L"Description";
static const WCHAR *g_wszWMRating = L"Rating";
static const WCHAR *g_wszWMCopyright = L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to set DRM properties.
//
static const WCHAR *g_wszWMUse_DRM = L"Use_DRM";
static const WCHAR *g_wszWMDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszWMDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR *g_wszWMAlbumTitle = L"WM/AlbumTitle";
static const WCHAR *g_wszWMTrack = L"WM/Track";
static const WCHAR *g_wszWMPromotionURL = L"WM/PromotionURL";
static const WCHAR *g_wszWMAlbumCoverURL = L"WM/AlbumCoverURL";
static const WCHAR *g_wszWMGenre = L"WM/Genre";
static const WCHAR *g_wszWMYear = L"WM/Year";
static const WCHAR *g_wszWMGenreID = L"WM/GenreID";
static const WCHAR *g_wszWMMCDI = L"WM/MCDI";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR *g_wszWMBannerImageType = L"BannerImageType";
static const WCHAR *g_wszWMBannerImageData = L"BannerImageData";
static const WCHAR *g_wszWMBannerImageURL = L"BannerImageURL";
static const WCHAR *g_wszWMCopyrightURL = L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const DWORD g_dwWMNSCAttributes = 5;
static const WCHAR *g_wszWMNSCName = L"NSC_Name";
static const WCHAR *g_wszWMNSCAddress = L"NSC_Address";
static const WCHAR *g_wszWMNSCPhone = L"NSC_Phone";
static const WCHAR *g_wszWMNSCEmail = L"NSC_Email";
static const WCHAR *g_wszWMNSCDescription = L"NSC_Description";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR *g_wszEarlyDataDelivery = L"EarlyDataDelivery";
static const WCHAR *g_wszJustInTimeDecode = L"JustInTimeDecode";
static const WCHAR *g_wszSingleOutputBuffer = L"SingleOutputBuffer";
static const WCHAR *g_wszSoftwareScaling = L"SoftwareScaling";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetInputSetting
//
static const WCHAR *g_wszDeinterlaceMode = L"DeinterlaceMode";

////////////////////////////////////////////////////////////////
//
// Flags that can be passed into the Start method of IWMReader
//
#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )

#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)
#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)
#define WAVE_FORMAT_DRM            0x0009

enum __MIDL___MIDL_itf_wmsdkidl_0000_0001
    {	WM_SF_CLEANPOINT	= 0x1,
	WM_SF_DISCONTINUITY	= 0x2
    };

enum __MIDL___MIDL_itf_wmsdkidl_0000_0002
    {	WM_SFEX_NOTASYNCPOINT	= 0x2
    };
typedef 
enum WMT_STATUS
    {	WMT_ERROR	= 0,
	WMT_OPENED	= 1,
	WMT_BUFFERING_START	= 2,
	WMT_BUFFERING_STOP	= 3,
	WMT_EOF	= 4,
	WMT_END_OF_FILE	= 4,
	WMT_END_OF_SEGMENT	= 5,
	WMT_END_OF_STREAMING	= 6,
	WMT_LOCATING	= 7,
	WMT_CONNECTING	= 8,
	WMT_NO_RIGHTS	= 9,
	WMT_MISSING_CODEC	= 10,
	WMT_STARTED	= 11,
	WMT_STOPPED	= 12,
	WMT_CLOSED	= 13,
	WMT_STRIDING	= 14,
	WMT_TIMER	= 15,
	WMT_INDEX_PROGRESS	= 16,
	WMT_SAVEAS_START	= 17,
	WMT_SAVEAS_STOP	= 18,
	WMT_NEW_SOURCEFLAGS	= 19,
	WMT_NEW_METADATA	= 20,
	WMT_BACKUPRESTORE_BEGIN	= 21,
	WMT_SOURCE_SWITCH	= 22,
	WMT_ACQUIRE_LICENSE	= 23,
	WMT_INDIVIDUALIZE	= 24,
	WMT_NEEDS_INDIVIDUALIZATION	= 25,
	WMT_NO_RIGHTS_EX	= 26,
	WMT_BACKUPRESTORE_END	= 27,
	WMT_BACKUPRESTORE_CONNECTING	= 28,
	WMT_BACKUPRESTORE_DISCONNECTING	= 29,
	WMT_ERROR_WITHURL	= 30,
	WMT_RESTRICTED_LICENSE	= 31,
	WMT_CLIENT_CONNECT	= 32,
	WMT_CLIENT_DISCONNECT	= 33
    }	WMT_STATUS;

typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    }	WMT_RIGHTS;

typedef 
enum WMT_STREAM_SELECTION
    {	WMT_OFF	= 0,
	WMT_CLEANPOINT_ONLY	= 1,
	WMT_ON	= 2
    }	WMT_STREAM_SELECTION;

typedef 
enum WMT_ATTR_DATATYPE
    {	WMT_TYPE_DWORD	= 0,
	WMT_TYPE_STRING	= 1,
	WMT_TYPE_BINARY	= 2,
	WMT_TYPE_BOOL	= 3,
	WMT_TYPE_QWORD	= 4,
	WMT_TYPE_WORD	= 5,
	WMT_TYPE_GUID	= 6
    }	WMT_ATTR_DATATYPE;

typedef 
enum WMT_ATTR_IMAGETYPE
    {	WMT_IMAGETYPE_BITMAP	= 1,
	WMT_IMAGETYPE_JPEG	= 2,
	WMT_IMAGETYPE_GIF	= 3
    }	WMT_ATTR_IMAGETYPE;

typedef 
enum WMT_VERSION
    {	WMT_VER_4_0	= 0x40000,
	WMT_VER_7_0	= 0x70000
    }	WMT_VERSION;

typedef 
enum WMT_NET_PROTOCOL
    {	WMT_PROTOCOL_HTTP	= 0
    }	WMT_NET_PROTOCOL;

typedef 
enum WMT_PLAY_MODE
    {	WMT_PLAY_MODE_AUTOSELECT	= 0,
	WMT_PLAY_MODE_LOCAL	= 1,
	WMT_PLAY_MODE_DOWNLOAD	= 2,
	WMT_PLAY_MODE_STREAMING	= 3
    }	WMT_PLAY_MODE;

typedef 
enum WMT_PROXY_SETTINGS
    {	WMT_PROXY_SETTING_NONE	= 0,
	WMT_PROXY_SETTING_MANUAL	= 1,
	WMT_PROXY_SETTING_AUTO	= 2,
	WMT_PROXY_SETTING_BROWSER	= 3
    }	WMT_PROXY_SETTINGS;

typedef 
enum WMT_CODEC_INFO_TYPE
    {	WMT_CODECINFO_AUDIO	= 0,
	WMT_CODECINFO_VIDEO	= 1,
	WMT_CODECINFO_UNKNOWN	= 0xffffffff
    }	WMT_CODEC_INFO_TYPE;

typedef 
enum DRM_HTTP_STATUS
    {	HTTP_NOTINITIATED	= 0,
	HTTP_CONNECTING	= HTTP_NOTINITIATED + 1,
	HTTP_REQUESTING	= HTTP_CONNECTING + 1,
	HTTP_RECEIVING	= HTTP_REQUESTING + 1,
	HTTP_COMPLETED	= HTTP_RECEIVING + 1
    }	DRM_HTTP_STATUS;

typedef 
enum DRM_INDIVIDUALIZATION_STATUS
    {	INDI_UNDEFINED	= 0,
	INDI_BEGIN	= 0x1,
	INDI_SUCCEED	= 0x2,
	INDI_FAIL	= 0x4,
	INDI_CANCEL	= 0x8,
	INDI_DOWNLOAD	= 0x10,
	INDI_INSTALL	= 0x20
    }	DRM_INDIVIDUALIZATION_STATUS;


enum __MIDL___MIDL_itf_wmsdkidl_0000_0003
    {	WM_DM_NOTINTERLACED	= 0,
	WM_DM_DEINTERLACE_NORMAL	= 1,
	WM_DM_DEINTERLACE_HALFSIZE	= 2,
	WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE	= 3,
	WM_DM_DEINTERLACE_INVERSETELECINE	= 4
    };
typedef struct  _WMWriterStatistics
    {
    QWORD qwSampleCount;
    QWORD qwByteCount;
    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;
    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
    }	WM_WRITER_STATISTICS;

typedef struct  _WMReaderStatistics
    {
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD wQuality;
    }	WM_READER_STATISTICS;

typedef struct  _WMReaderClientInfo
    {
    DWORD cbSize;
    WCHAR __RPC_FAR *wszLang;
    WCHAR __RPC_FAR *wszBrowserUserAgent;
    WCHAR __RPC_FAR *wszBrowserWebPage;
    QWORD qwReserved;
    LPARAM __RPC_FAR *pReserved;
    WCHAR __RPC_FAR *wszHostExe;
    QWORD qwHostVersion;
    }	WM_READER_CLIENTINFO;

typedef struct  _WMIndividualizeStatus
    {
    HRESULT hr;
    DRM_INDIVIDUALIZATION_STATUS enIndiStatus;
    LPSTR pszIndiRespUrl;
    DWORD dwHTTPRequest;
    DRM_HTTP_STATUS enHTTPStatus;
    DWORD dwHTTPReadProgress;
    DWORD dwHTTPReadTotal;
    }	WM_INDIVIDUALIZE_STATUS;

typedef struct  _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    WCHAR __RPC_FAR *wszURL;
    WCHAR __RPC_FAR *wszLocalFilename;
    BYTE __RPC_FAR *pbPostData;
    DWORD dwPostDataSize;
    }	WM_GET_LICENSE_DATA;

typedef struct  _WMClientProperties
    {
    DWORD dwIPAddress;
    DWORD dwPort;
    }	WM_CLIENT_PROPERTIES;

typedef struct  _WMPortNumberRange
    {
    WORD wPortBegin;
    WORD wPortEnd;
    }	WM_PORT_NUMBER_RANGE;

typedef struct  _WMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown __RPC_FAR *pUnk;
    ULONG cbFormat;
    /* [size_is] */ BYTE __RPC_FAR *pbFormat;
    }	WM_MEDIA_TYPE;

typedef struct tagWMVIDEOINFOHEADER
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER;
typedef struct tagWMSCRIPTFORMAT
{
    GUID    scriptType; 
} WMSCRIPTFORMAT;
// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base 
EXTERN_GUID(WMMEDIASUBTYPE_Base, 
0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video 
EXTERN_GUID(WMMEDIATYPE_Video, 
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 
EXTERN_GUID(WMMEDIASUBTYPE_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 
EXTERN_GUID(WMMEDIASUBTYPE_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 
EXTERN_GUID(WMMEDIASUBTYPE_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 
EXTERN_GUID(WMMEDIASUBTYPE_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 
EXTERN_GUID(WMMEDIASUBTYPE_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 
EXTERN_GUID(WMMEDIASUBTYPE_I420, 
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV 
EXTERN_GUID(WMMEDIASUBTYPE_IYUV, 
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 
EXTERN_GUID(WMMEDIASUBTYPE_YV12, 
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 
EXTERN_GUID(WMMEDIASUBTYPE_YUY2, 
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY 
EXTERN_GUID(WMMEDIASUBTYPE_UYVY, 
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU 
EXTERN_GUID(WMMEDIASUBTYPE_YVYU, 
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 
EXTERN_GUID(WMMEDIASUBTYPE_YVU9, 
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 
EXTERN_GUID(WMMEDIASUBTYPE_MP43, 
0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S 
EXTERN_GUID(WMMEDIASUBTYPE_MP4S, 
0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 
EXTERN_GUID(WMMEDIASUBTYPE_WMV1, 
0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 
EXTERN_GUID(WMMEDIASUBTYPE_MSS1, 
0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio 
EXTERN_GUID(WMMEDIATYPE_Audio, 
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM 
EXTERN_GUID(WMMEDIASUBTYPE_PCM, 
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM 
EXTERN_GUID(WMMEDIASUBTYPE_DRM, 
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet 
EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, 
0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_Script 
EXTERN_GUID(WMMEDIATYPE_Script, 
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31            WMMEDIATYPE_Image 
EXTERN_GUID(WMMEDIATYPE_Image, 
0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); 
// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo 
EXTERN_GUID(WMFORMAT_VideoInfo, 
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx 
EXTERN_GUID(WMFORMAT_WaveFormatEx, 
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script 
EXTERN_GUID(WMFORMAT_Script, 
0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); 
// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings 
EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, 
0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); 
EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );
EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );
EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );
EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );
EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );
EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );
EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );
EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );
EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );
EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );
EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );
EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );
EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);
EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);
EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);
EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);
EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);
EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);
EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);
EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);
EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );
HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );
HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );
HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );
HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );
HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );
HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );
HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_s_ifspec;

#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

/* interface IWMMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMediaProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        END_INTERFACE
    } IWMMediaPropsVtbl;

    interface IWMMediaProps
    {
        CONST_VTBL struct IWMMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMediaProps_GetType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMediaProps_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_GetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
    /* [out][in] */ DWORD __RPC_FAR *pcbType);


void __RPC_STUB IWMMediaProps_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_SetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);


void __RPC_STUB IWMMediaProps_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMVideoMediaProps_INTERFACE_DEFINED__
#define __IWMVideoMediaProps_INTERFACE_DEFINED__

/* interface IWMVideoMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCF-2B2B-11d3-B36B-00C04F6108FF")
    IWMVideoMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxKeyFrameSpacing( 
            /* [out] */ LONGLONG __RPC_FAR *pllTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxKeyFrameSpacing( 
            /* [in] */ LONGLONG llTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ DWORD __RPC_FAR *pdwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ LONGLONG __RPC_FAR *pllTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ LONGLONG llTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ DWORD dwQuality);
        
        END_INTERFACE
    } IWMVideoMediaPropsVtbl;

    interface IWMVideoMediaProps
    {
        CONST_VTBL struct IWMVideoMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMVideoMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMVideoMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMVideoMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMVideoMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMVideoMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMVideoMediaProps_GetMaxKeyFrameSpacing(This,pllTime)	\
    (This)->lpVtbl -> GetMaxKeyFrameSpacing(This,pllTime)

#define IWMVideoMediaProps_SetMaxKeyFrameSpacing(This,llTime)	\
    (This)->lpVtbl -> SetMaxKeyFrameSpacing(This,llTime)

#define IWMVideoMediaProps_GetQuality(This,pdwQuality)	\
    (This)->lpVtbl -> GetQuality(This,pdwQuality)

#define IWMVideoMediaProps_SetQuality(This,dwQuality)	\
    (This)->lpVtbl -> SetQuality(This,dwQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ LONGLONG __RPC_FAR *pllTime);


void __RPC_STUB IWMVideoMediaProps_GetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ LONGLONG llTime);


void __RPC_STUB IWMVideoMediaProps_SetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwQuality);


void __RPC_STUB IWMVideoMediaProps_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ DWORD dwQuality);


void __RPC_STUB IWMVideoMediaProps_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMVideoMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMWriter_INTERFACE_DEFINED__
#define __IWMWriter_INTERFACE_DEFINED__

/* interface IWMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProfileByID( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilename( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD __RPC_FAR *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormatCount( 
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormat( 
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfileByID )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfile )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputFilename )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputCount )( 
            IWMWriter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormatCount )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormat )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMWriter __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterVtbl;

    interface IWMWriter
    {
        CONST_VTBL struct IWMWriterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriter_SetProfileByID(This,guidProfile)	\
    (This)->lpVtbl -> SetProfileByID(This,guidProfile)

#define IWMWriter_SetProfile(This,pProfile)	\
    (This)->lpVtbl -> SetProfile(This,pProfile)

#define IWMWriter_SetOutputFilename(This,pwszFilename)	\
    (This)->lpVtbl -> SetOutputFilename(This,pwszFilename)

#define IWMWriter_GetInputCount(This,pcInputs)	\
    (This)->lpVtbl -> GetInputCount(This,pcInputs)

#define IWMWriter_GetInputProps(This,dwInputNum,ppInput)	\
    (This)->lpVtbl -> GetInputProps(This,dwInputNum,ppInput)

#define IWMWriter_SetInputProps(This,dwInputNum,pInput)	\
    (This)->lpVtbl -> SetInputProps(This,dwInputNum,pInput)

#define IWMWriter_GetInputFormatCount(This,dwInputNumber,pcFormats)	\
    (This)->lpVtbl -> GetInputFormatCount(This,dwInputNumber,pcFormats)

#define IWMWriter_GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)	\
    (This)->lpVtbl -> GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)

#define IWMWriter_BeginWriting(This)	\
    (This)->lpVtbl -> BeginWriting(This)

#define IWMWriter_EndWriting(This)	\
    (This)->lpVtbl -> EndWriting(This)

#define IWMWriter_AllocateSample(This,dwSampleSize,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwSampleSize,ppSample)

#define IWMWriter_WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriter_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriter_SetProfileByID_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IWMWriter_SetProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetProfile_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pProfile);


void __RPC_STUB IWMWriter_SetProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetOutputFilename_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriter_SetOutputFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcInputs);


void __RPC_STUB IWMWriter_GetInputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);


void __RPC_STUB IWMWriter_GetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);


void __RPC_STUB IWMWriter_SetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormatCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriter_GetInputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormat_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IWMWriter_GetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_BeginWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_BeginWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_EndWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_EndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_AllocateSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwSampleSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);


void __RPC_STUB IWMWriter_AllocateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_WriteSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriter_WriteSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_Flush_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMInputMediaProps_INTERFACE_DEFINED__
#define __IWMInputMediaProps_INTERFACE_DEFINED__

/* interface IWMInputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD5-2B2B-11d3-B36B-00C04F6108FF")
    IWMInputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGroupName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMInputMediaPropsVtbl;

    interface IWMInputMediaProps
    {
        CONST_VTBL struct IWMInputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMInputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMInputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMInputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMInputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMInputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMInputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#define IWMInputMediaProps_GetGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetGroupName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetConnectionName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetGroupName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMInputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

/* interface IWMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD6-2B2B-11d3-B36B-00C04F6108FF")
    IWMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD __RPC_FAR *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputCount )( 
            IWMReader __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormatCount )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormat )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IWMReader __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderVtbl;

    interface IWMReader
    {
        CONST_VTBL struct IWMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReader_Open(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> Open(This,pwszURL,pCallback,pvContext)

#define IWMReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNumber,pcFormats)

#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)

#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> Start(This,cnsStart,cnsDuration,fRate,pvContext)

#define IWMReader_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMReader_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMReader_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReader_Open_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Close_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcOutputs);


void __RPC_STUB IWMReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_SetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormatCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormat_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Start_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Stop_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Pause_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Resume_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReader_INTERFACE_DEFINED__ */


#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

/* interface IWMOutputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMOutputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD7-2B2B-11d3-B36B-00C04F6108FF")
    IWMOutputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMOutputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamGroupName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMOutputMediaPropsVtbl;

    interface IWMOutputMediaProps
    {
        CONST_VTBL struct IWMOutputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMOutputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMOutputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMOutputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMOutputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetStreamGroupName(This,pwszName,pcchName)

#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetStreamGroupName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetStreamGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetConnectionName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMOutputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

/* interface IWMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
    IWMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMStatusCallbackVtbl;

    interface IWMStatusCallback
    {
        CONST_VTBL struct IWMStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStatusCallback_OnStatus_Proxy( 
    IWMStatusCallback __RPC_FAR * This,
    /* [in] */ WMT_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStatusCallback_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

/* interface IWMReaderCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD8-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSample( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSample )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackVtbl;

    interface IWMReaderCallback
    {
        CONST_VTBL struct IWMReaderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallback_OnSample_Proxy( 
    IWMReaderCallback __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallback_OnSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMCredentialCallback_INTERFACE_DEFINED__
#define __IWMCredentialCallback_INTERFACE_DEFINED__

/* interface IWMCredentialCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCredentialCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("342e0eb7-e651-450c-975b-2ace2c90c48e")
    IWMCredentialCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireCredentials( 
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCredentialCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireCredentials )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IWMCredentialCallbackVtbl;

    interface IWMCredentialCallback
    {
        CONST_VTBL struct IWMCredentialCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCredentialCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCredentialCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCredentialCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCredentialCallback_AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)	\
    (This)->lpVtbl -> AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCredentialCallback_AcquireCredentials_Proxy( 
    IWMCredentialCallback __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszRealm,
    /* [in] */ WCHAR __RPC_FAR *pwszSite,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
    /* [in] */ DWORD cchUser,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
    /* [in] */ DWORD cchPassword,
    /* [in] */ HRESULT hrStatus,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IWMCredentialCallback_AcquireCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCredentialCallback_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

/* interface IWMMetadataEditor */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD9-2B2B-11d3-B36B-00C04F6108FF")
    IWMMetadataEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        END_INTERFACE
    } IWMMetadataEditorVtbl;

    interface IWMMetadataEditor
    {
        CONST_VTBL struct IWMMetadataEditorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Open_Proxy( 
    IWMMetadataEditor __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMMetadataEditor_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Close_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Flush_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo_INTERFACE_DEFINED__
#define __IWMHeaderInfo_INTERFACE_DEFINED__

/* interface IWMHeaderInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDA-2B2B-11d3-B36B-00C04F6108FF")
    IWMHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkerCount( 
            /* [out] */ WORD __RPC_FAR *pcMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarker( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMarker( 
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMarker( 
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptCount( 
            /* [out] */ WORD __RPC_FAR *pcScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScript( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScript( 
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScript( 
            /* [in] */ WORD wIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        END_INTERFACE
    } IWMHeaderInfoVtbl;

    interface IWMHeaderInfo
    {
        CONST_VTBL struct IWMHeaderInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WORD __RPC_FAR *pcAttributes);


void __RPC_STUB IWMHeaderInfo_GetAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByIndex_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByName_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_SetAttribute_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMHeaderInfo_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarkerCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcMarkers);


void __RPC_STUB IWMHeaderInfo_GetMarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
    /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_GetMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [in] */ QWORD cnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_AddMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScriptCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcScripts);


void __RPC_STUB IWMHeaderInfo_GetScriptCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszType,
    /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
    /* [out] */ WCHAR __RPC_FAR *pwszCommand,
    /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
    /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);


void __RPC_STUB IWMHeaderInfo_GetScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszType,
    /* [in] */ WCHAR __RPC_FAR *pwszCommand,
    /* [in] */ QWORD cnsScriptTime);


void __RPC_STUB IWMHeaderInfo_AddScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo2_INTERFACE_DEFINED__
#define __IWMHeaderInfo2_INTERFACE_DEFINED__

/* interface IWMHeaderInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CF9781-454E-482e-B393-85FAE487A810")
    IWMHeaderInfo2 : public IWMHeaderInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfo( 
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfo )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo2Vtbl;

    interface IWMHeaderInfo2
    {
        CONST_VTBL struct IWMHeaderInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo2_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo2_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo2_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo2_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo2_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo2_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo2_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo2_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo2_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo2_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo2_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo2_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)


#define IWMHeaderInfo2_GetCodecInfoCount(This,pcCodecInfos)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos)

#define IWMHeaderInfo2_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfoCount_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcCodecInfos);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfo_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [in] */ DWORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pcchName,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchDescription,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
    /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
    /* [out] */ BYTE __RPC_FAR *pbCodecInfo);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager_INTERFACE_DEFINED__
#define __IWMProfileManager_INTERFACE_DEFINED__

/* interface IWMProfileManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d16679f2-6ca0-472d-8d31-2f5d55aee155")
    IWMProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyProfile( 
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByID( 
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByData( 
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileCount( 
            /* [out] */ DWORD __RPC_FAR *pcProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadSystemProfile( 
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        END_INTERFACE
    } IWMProfileManagerVtbl;

    interface IWMProfileManager
    {
        CONST_VTBL struct IWMProfileManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager_CreateEmptyProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ WMT_VERSION dwVersion,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_CreateEmptyProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByID_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByData_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_SaveProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
    /* [in] */ WCHAR __RPC_FAR *pwszProfile,
    /* [out][in] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMProfileManager_SaveProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_GetSystemProfileCount_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProfiles);


void __RPC_STUB IWMProfileManager_GetSystemProfileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadSystemProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ DWORD dwProfileIndex,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadSystemProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager2_INTERFACE_DEFINED__
#define __IWMProfileManager2_INTERFACE_DEFINED__

/* interface IWMProfileManager2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A924E51-73C1-494d-8019-23D37ED9B89A")
    IWMProfileManager2 : public IWMProfileManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileVersion( 
            WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSystemProfileVersion( 
            WMT_VERSION dwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION dwVersion);
        
        END_INTERFACE
    } IWMProfileManager2Vtbl;

    interface IWMProfileManager2
    {
        CONST_VTBL struct IWMProfileManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager2_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager2_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager2_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager2_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager2_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager2_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)


#define IWMProfileManager2_GetSystemProfileVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetSystemProfileVersion(This,pdwVersion)

#define IWMProfileManager2_SetSystemProfileVersion(This,dwVersion)	\
    (This)->lpVtbl -> SetSystemProfileVersion(This,dwVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager2_GetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfileManager2_GetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager2_SetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION dwVersion);


void __RPC_STUB IWMProfileManager2_SetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile_INTERFACE_DEFINED__
#define __IWMProfile_INTERFACE_DEFINED__

/* interface IWMProfile */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDB-2B2B-11d3-B36B-00C04F6108FF")
    IWMProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ const WCHAR __RPC_FAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamByNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconfigStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStream( 
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD __RPC_FAR *pcME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewMutualExclusion( 
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        END_INTERFACE
    } IWMProfileVtbl;

    interface IWMProfile
    {
        CONST_VTBL struct IWMProfileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile_GetVersion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfile_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszName);


void __RPC_STUB IWMProfile_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszDescription);


void __RPC_STUB IWMProfile_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMProfile_GetStreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwStreamIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMProfile_RemoveStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_ReconfigStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_ReconfigStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ REFGUID guidStreamType,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_CreateNewStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusionCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcME);


void __RPC_STUB IWMProfile_GetMutualExclusionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwMEIndex,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_GetMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_RemoveMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_AddMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_CreateNewMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile_INTERFACE_DEFINED__ */


#ifndef __IWMProfile2_INTERFACE_DEFINED__
#define __IWMProfile2_INTERFACE_DEFINED__

/* interface IWMProfile2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07E72D33-D94E-4be7-8843-60AE5FF7E5F5")
    IWMProfile2 : public IWMProfile
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProfileID( 
            /* [out] */ GUID __RPC_FAR *pguidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfileID )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidID);
        
        END_INTERFACE
    } IWMProfile2Vtbl;

    interface IWMProfile2
    {
        CONST_VTBL struct IWMProfile2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile2_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile2_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile2_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile2_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile2_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile2_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile2_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile2_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile2_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile2_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile2_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile2_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile2_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile2_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile2_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile2_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile2_GetProfileID_Proxy( 
    IWMProfile2 __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidID);


void __RPC_STUB IWMProfile2_GetProfileID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile2_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig_INTERFACE_DEFINED__
#define __IWMStreamConfig_INTERFACE_DEFINED__

/* interface IWMStreamConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDC-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID __RPC_FAR *pguidStreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            /* [out] */ WORD __RPC_FAR *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamName( 
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [in] */ WCHAR __RPC_FAR *pwszInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitrate( 
            /* [out] */ DWORD __RPC_FAR *pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBitrate( 
            /* [in] */ DWORD pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferWindow( 
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferWindow( 
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamType )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMStreamConfigVtbl;

    interface IWMStreamConfig
    {
        CONST_VTBL struct IWMStreamConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamType_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidStreamType);


void __RPC_STUB IWMStreamConfig_GetStreamType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNum);


void __RPC_STUB IWMStreamConfig_GetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamConfig_SetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
    /* [out][in] */ WORD __RPC_FAR *pcchStreamName);


void __RPC_STUB IWMStreamConfig_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszStreamName);


void __RPC_STUB IWMStreamConfig_SetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszInputName,
    /* [out][in] */ WORD __RPC_FAR *pcchInputName);


void __RPC_STUB IWMStreamConfig_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszInputName);


void __RPC_STUB IWMStreamConfig_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBitrate);


void __RPC_STUB IWMStreamConfig_GetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD pdwBitrate);


void __RPC_STUB IWMStreamConfig_SetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);


void __RPC_STUB IWMStreamConfig_GetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMStreamConfig_SetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize_INTERFACE_DEFINED__
#define __IWMPacketSize_INTERFACE_DEFINED__

/* interface IWMPacketSize */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDFB97AB-188F-40b3-B643-5B7903975C59")
    IWMPacketSize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPacketSize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPacketSize __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        END_INTERFACE
    } IWMPacketSizeVtbl;

    interface IWMPacketSize
    {
        CONST_VTBL struct IWMPacketSizeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize_GetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);


void __RPC_STUB IWMPacketSize_GetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize_SetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [in] */ DWORD dwMaxPacketSize);


void __RPC_STUB IWMPacketSize_SetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize_INTERFACE_DEFINED__ */


#ifndef __IWMStreamList_INTERFACE_DEFINED__
#define __IWMStreamList_INTERFACE_DEFINED__

/* interface IWMStreamList */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDD-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMStreamList __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        END_INTERFACE
    } IWMStreamListVtbl;

    interface IWMStreamList
    {
        CONST_VTBL struct IWMStreamListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamList_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMStreamList_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMStreamList_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamList_GetStreams_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
    /* [out][in] */ WORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMStreamList_GetStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_AddStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_RemoveStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamList_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion_INTERFACE_DEFINED__
#define __IWMMutualExclusion_INTERFACE_DEFINED__

/* interface IWMMutualExclusion */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMutualExclusion : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFGUID guidType);
        
        END_INTERFACE
    } IWMMutualExclusionVtbl;

    interface IWMMutualExclusion
    {
        CONST_VTBL struct IWMMutualExclusionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion_GetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMutualExclusion_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion_SetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMMutualExclusion_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced_INTERFACE_DEFINED__
#define __IWMWriterAdvanced_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE3-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSinkCount( 
            /* [out] */ DWORD __RPC_FAR *pcSinks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLiveSource( 
            BOOL fIsLiveSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncTolerance( 
            /* [out] */ DWORD __RPC_FAR *pmsWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        END_INTERFACE
    } IWMWriterAdvancedVtbl;

    interface IWMWriterAdvanced
    {
        CONST_VTBL struct IWMWriterAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSinkCount_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcSinks);


void __RPC_STUB IWMWriterAdvanced_GetSinkCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwSinkNum,
    /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);


void __RPC_STUB IWMWriterAdvanced_GetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_AddSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_AddSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_RemoveSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_RemoveSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_WriteStreamSample_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD msSampleSendTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriterAdvanced_WriteStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetLiveSource_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    BOOL fIsLiveSource);


void __RPC_STUB IWMWriterAdvanced_SetLiveSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_IsRealTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterAdvanced_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetWriterTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);


void __RPC_STUB IWMWriterAdvanced_GetWriterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetStatistics_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);


void __RPC_STUB IWMWriterAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD msWindow);


void __RPC_STUB IWMWriterAdvanced_SetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsWindow);


void __RPC_STUB IWMWriterAdvanced_GetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced2_INTERFACE_DEFINED__
#define __IWMWriterAdvanced2_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962dc1ec-c046-4db8-9cc7-26ceae500817")
    IWMWriterAdvanced2 : public IWMWriterAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMWriterAdvanced2Vtbl;

    interface IWMWriterAdvanced2
    {
        CONST_VTBL struct IWMWriterAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced2_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced2_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced2_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced2_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced2_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced2_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced2_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced2_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced2_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced2_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced2_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced2_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_GetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMWriterAdvanced2_GetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_SetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMWriterAdvanced2_SetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_INTERFACE_DEFINED__
#define __IWMWriterPostViewCallback_INTERFACE_DEFINED__

/* interface IWMWriterPostViewCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostViewCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9D6549D-A193-4f24-B308-03123D9B7F8D")
    IWMWriterPostViewCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPostViewSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForPostView( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPostViewSample )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForPostView )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMWriterPostViewCallbackVtbl;

    interface IWMWriterPostViewCallback
    {
        CONST_VTBL struct IWMWriterPostViewCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostViewCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostViewCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostViewCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostViewCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMWriterPostViewCallback_OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMWriterPostViewCallback_AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_OnPostViewSample_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_OnPostViewSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_AllocateForPostView_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_AllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostViewCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostView_INTERFACE_DEFINED__
#define __IWMWriterPostView_INTERFACE_DEFINED__

/* interface IWMWriterPostView */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81E20CE4-75EF-491a-8004-FC53C45BDC3E")
    IWMWriterPostView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPostViewCallback( 
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormatCount( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormat( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewCallback )( 
            IWMWriterPostView __RPC_FAR * This,
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormatCount )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormat )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        END_INTERFACE
    } IWMWriterPostViewVtbl;

    interface IWMWriterPostView
    {
        CONST_VTBL struct IWMWriterPostViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostView_SetPostViewCallback(This,pCallback,pvContext)	\
    (This)->lpVtbl -> SetPostViewCallback(This,pCallback,pvContext)

#define IWMWriterPostView_SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)	\
    (This)->lpVtbl -> SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)

#define IWMWriterPostView_GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)	\
    (This)->lpVtbl -> GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)

#define IWMWriterPostView_GetPostViewProps(This,wStreamNumber,ppOutput)	\
    (This)->lpVtbl -> GetPostViewProps(This,wStreamNumber,ppOutput)

#define IWMWriterPostView_SetPostViewProps(This,wStreamNumber,pOutput)	\
    (This)->lpVtbl -> SetPostViewProps(This,wStreamNumber,pOutput)

#define IWMWriterPostView_GetPostViewFormatCount(This,wStreamNumber,pcFormats)	\
    (This)->lpVtbl -> GetPostViewFormatCount(This,wStreamNumber,pcFormats)

#define IWMWriterPostView_GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)

#define IWMWriterPostView_SetAllocateForPostView(This,wStreamNumber,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForPostView(This,wStreamNumber,fAllocate)

#define IWMWriterPostView_GetAllocateForPostView(This,wStreamNumber,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForPostView(This,wStreamNumber,pfAllocate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewCallback_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    IWMWriterPostViewCallback __RPC_FAR *pCallback,
    void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostView_SetPostViewCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_SetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_GetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMWriterPostView_GetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ IWMMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMWriterPostView_SetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormatCount_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriterPostView_GetPostViewFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormat_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMWriterPostView_GetPostViewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMWriterPostView_SetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMWriterPostView_GetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostView_INTERFACE_DEFINED__ */


#ifndef __IWMWriterSink_INTERFACE_DEFINED__
#define __IWMWriterSink_INTERFACE_DEFINED__

/* interface IWMWriterSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnHeader( 
            /* [in] */ INSSBuffer __RPC_FAR *pHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateDataUnit( 
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnit( 
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndWriting( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterSinkVtbl;

    interface IWMWriterSink
    {
        CONST_VTBL struct IWMWriterSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterSink_OnHeader_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pHeader);


void __RPC_STUB IWMWriterSink_OnHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_IsRealTime_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterSink_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_AllocateDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ DWORD cbDataUnit,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);


void __RPC_STUB IWMWriterSink_AllocateDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);


void __RPC_STUB IWMWriterSink_OnDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnEndWriting_Proxy( 
    IWMWriterSink __RPC_FAR * This);


void __RPC_STUB IWMWriterSink_OnEndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterSink_INTERFACE_DEFINED__ */


#ifndef __IWMRegisterCallback_INTERFACE_DEFINED__
#define __IWMRegisterCallback_INTERFACE_DEFINED__

/* interface IWMRegisterCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRegisterCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF4B1F99-4DE2-4e49-A363-252740D99BC1")
    IWMRegisterCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRegisterCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMRegisterCallbackVtbl;

    interface IWMRegisterCallback
    {
        CONST_VTBL struct IWMRegisterCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRegisterCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRegisterCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRegisterCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRegisterCallback_Advise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Advise(This,pCallback,pvContext)

#define IWMRegisterCallback_Unadvise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Unadvise(This,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Advise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Unadvise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRegisterCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink_INTERFACE_DEFINED__
#define __IWMWriterFileSink_INTERFACE_DEFINED__

/* interface IWMWriterFileSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE5-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterFileSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        END_INTERFACE
    } IWMWriterFileSinkVtbl;

    interface IWMWriterFileSink
    {
        CONST_VTBL struct IWMWriterFileSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink_Open_Proxy( 
    IWMWriterFileSink __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriterFileSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink2_INTERFACE_DEFINED__
#define __IWMWriterFileSink2_INTERFACE_DEFINED__

/* interface IWMWriterFileSink2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14282BA7-4AEF-4205-8CE5-C229035A05BC")
    IWMWriterFileSink2 : public IWMWriterFileSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ QWORD cnsStopTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStopped( 
            /* [out] */ BOOL __RPC_FAR *pfStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDuration( 
            /* [out] */ QWORD __RPC_FAR *pcnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileSize( 
            /* [out] */ QWORD __RPC_FAR *pcbFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [out] */ BOOL __RPC_FAR *pfClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsStopped )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileDuration )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileSize )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClosed )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfClosed);
        
        END_INTERFACE
    } IWMWriterFileSink2Vtbl;

    interface IWMWriterFileSink2
    {
        CONST_VTBL struct IWMWriterFileSink2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink2_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink2_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink2_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink2_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink2_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink2_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink2_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink2_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink2_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink2_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Start_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStartTime);


void __RPC_STUB IWMWriterFileSink2_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Stop_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStopTime);


void __RPC_STUB IWMWriterFileSink2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsStopped_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfStopped);


void __RPC_STUB IWMWriterFileSink2_IsStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileDuration_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsDuration);


void __RPC_STUB IWMWriterFileSink2_GetFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileSize_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcbFile);


void __RPC_STUB IWMWriterFileSink2_GetFileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Close_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This);


void __RPC_STUB IWMWriterFileSink2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsClosed_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfClosed);


void __RPC_STUB IWMWriterFileSink2_IsClosed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterNetworkSink_INTERFACE_DEFINED__
#define __IWMWriterNetworkSink_INTERFACE_DEFINED__

/* interface IWMWriterNetworkSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterNetworkSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE7-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterNetworkSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumClients( 
            /* [in] */ DWORD dwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumClients( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkProtocol( 
            /* [in] */ WMT_NET_PROTOCOL protocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkProtocol( 
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostURL( 
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterNetworkSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD dwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ WMT_NET_PROTOCOL protocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostURL )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterNetworkSinkVtbl;

    interface IWMWriterNetworkSink
    {
        CONST_VTBL struct IWMWriterNetworkSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterNetworkSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterNetworkSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterNetworkSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterNetworkSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterNetworkSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterNetworkSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterNetworkSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterNetworkSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterNetworkSink_SetMaximumClients(This,dwMaxClients)	\
    (This)->lpVtbl -> SetMaximumClients(This,dwMaxClients)

#define IWMWriterNetworkSink_GetMaximumClients(This,pdwMaxClients)	\
    (This)->lpVtbl -> GetMaximumClients(This,pdwMaxClients)

#define IWMWriterNetworkSink_SetNetworkProtocol(This,protocol)	\
    (This)->lpVtbl -> SetNetworkProtocol(This,protocol)

#define IWMWriterNetworkSink_GetNetworkProtocol(This,pProtocol)	\
    (This)->lpVtbl -> GetNetworkProtocol(This,pProtocol)

#define IWMWriterNetworkSink_GetHostURL(This,pwszURL,pcchURL)	\
    (This)->lpVtbl -> GetHostURL(This,pwszURL,pcchURL)

#define IWMWriterNetworkSink_Open(This,pdwPortNum)	\
    (This)->lpVtbl -> Open(This,pdwPortNum)

#define IWMWriterNetworkSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterNetworkSink_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ DWORD dwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_SetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_GetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ WMT_NET_PROTOCOL protocol);


void __RPC_STUB IWMWriterNetworkSink_SetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);


void __RPC_STUB IWMWriterNetworkSink_GetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetHostURL_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszURL,
    /* [out][in] */ DWORD __RPC_FAR *pcchURL);


void __RPC_STUB IWMWriterNetworkSink_GetHostURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Open_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);


void __RPC_STUB IWMWriterNetworkSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Disconnect_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Close_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterNetworkSink_INTERFACE_DEFINED__ */


#ifndef __IWMClientConnections_INTERFACE_DEFINED__
#define __IWMClientConnections_INTERFACE_DEFINED__

/* interface IWMClientConnections */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMClientConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73C66010-A299-41df-B1F0-CCF03B09C1C6")
    IWMClientConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientCount( 
            /* [out] */ DWORD __RPC_FAR *pcClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientProperties( 
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMClientConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMClientConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMClientConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientCount )( 
            IWMClientConnections __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientProperties )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);
        
        END_INTERFACE
    } IWMClientConnectionsVtbl;

    interface IWMClientConnections
    {
        CONST_VTBL struct IWMClientConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMClientConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMClientConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMClientConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMClientConnections_GetClientCount(This,pcClients)	\
    (This)->lpVtbl -> GetClientCount(This,pcClients)

#define IWMClientConnections_GetClientProperties(This,dwClientNum,pClientProperties)	\
    (This)->lpVtbl -> GetClientProperties(This,dwClientNum,pClientProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientCount_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcClients);


void __RPC_STUB IWMClientConnections_GetClientCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientProperties_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [in] */ DWORD dwClientNum,
    /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);


void __RPC_STUB IWMClientConnections_GetClientProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMClientConnections_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced_INTERFACE_DEFINED__
#define __IWMReaderAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEA-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserProvidedClock( 
            /* [in] */ BOOL fUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserProvidedClock( 
            /* [out] */ BOOL __RPC_FAR *pfUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeliverTime( 
            /* [in] */ QWORD cnsTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManualStreamSelection( 
            /* [in] */ BOOL fSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManualStreamSelection( 
            /* [out] */ BOOL __RPC_FAR *pfSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveSelectionCallbacks( 
            /* [in] */ BOOL fGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveSelectionCallbacks( 
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForStream( 
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForStream( 
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyLateDelivery( 
            QWORD cnsLateness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced __RPC_FAR * This,
            QWORD cnsLateness);
        
        END_INTERFACE
    } IWMReaderAdvancedVtbl;

    interface IWMReaderAdvanced
    {
        CONST_VTBL struct IWMReaderAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fUserClock);


void __RPC_STUB IWMReaderAdvanced_SetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfUserClock);


void __RPC_STUB IWMReaderAdvanced_GetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_DeliverTime_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsTime);


void __RPC_STUB IWMReaderAdvanced_DeliverTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fSelection);


void __RPC_STUB IWMReaderAdvanced_SetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfSelection);


void __RPC_STUB IWMReaderAdvanced_GetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetStreamsSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);


void __RPC_STUB IWMReaderAdvanced_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStreamSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);


void __RPC_STUB IWMReaderAdvanced_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_SetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_GetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_SetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_GetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwStreamNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwSreamNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStatistics_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);


void __RPC_STUB IWMReaderAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetClientInfo_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);


void __RPC_STUB IWMReaderAdvanced_SetClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxOutputSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxStreamSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_NotifyLateDelivery_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    QWORD cnsLateness);


void __RPC_STUB IWMReaderAdvanced_NotifyLateDelivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL __RPC_FAR *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced2_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced2_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WMT_PLAY_MODE Mode);


void __RPC_STUB IWMReaderAdvanced2_SetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);


void __RPC_STUB IWMReaderAdvanced2_GetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetBufferProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pcnsBuffering);


void __RPC_STUB IWMReaderAdvanced2_GetBufferProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetDownloadProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
    /* [out] */ QWORD __RPC_FAR *pcnsDownload);


void __RPC_STUB IWMReaderAdvanced2_GetDownloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetSaveAsProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent);


void __RPC_STUB IWMReaderAdvanced2_GetSaveAsProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SaveFileAs_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMReaderAdvanced2_SaveFileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetProtocolName_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);


void __RPC_STUB IWMReaderAdvanced2_GetProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StartAtMarker_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WORD wMarkerIndex,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_StartAtMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMReaderAdvanced2_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMReaderAdvanced2_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_Preroll_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate);


void __RPC_STUB IWMReaderAdvanced2_Preroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ BOOL fLogClientID);


void __RPC_STUB IWMReaderAdvanced2_SetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfLogClientID);


void __RPC_STUB IWMReaderAdvanced2_GetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StopBuffering_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced2_StopBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStreamEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutputEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAllocatorEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAllocatorEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForStreamEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForStreamEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForOutputEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForOutputEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TryOutputProps )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderTypeNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderTypeNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderTypeNegotiation_TryOutputProps_Proxy( 
    IWMReaderTypeNegotiation __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReaderTypeNegotiation_TryOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSample )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTime )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSelection )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStream )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutput )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallbackAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext)

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSample_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnTime_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsCurrentTime,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSelection_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamCount,
    /* [in] */ WORD __RPC_FAR *pStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnOutputPropsChanged_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnOutputPropsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForStream_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForOutput_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDRMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireLicense )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Individualize )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelIndividualization )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    (This)->lpVtbl -> AcquireLicense(This,dwFlags)

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelLicenseAcquisition(This)

#define IWMDRMReader_Individualize(This,dwFlags)	\
    (This)->lpVtbl -> Individualize(This,dwFlags)

#define IWMDRMReader_CancelIndividualization(This)	\
    (This)->lpVtbl -> CancelIndividualization(This)

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> MonitorLicenseAcquisition(This)

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This)

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMReader_AcquireLicense_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_AcquireLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_Individualize_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_Individualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelIndividualization_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelIndividualization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_MonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_MonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelMonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelMonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_SetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMReader_SetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_GetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMDRMReader_GetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD __RPC_FAR *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetProtocolRollover )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_GetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ QWORD cnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_SetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [out][in] */ DWORD __RPC_FAR *pcRanges);


void __RPC_STUB IWMReaderNetworkConfig_GetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [in] */ DWORD cRanges);


void __RPC_STUB IWMReaderNetworkConfig_SetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS ProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszHostName,
    /* [out][in] */ DWORD __RPC_FAR *pcchHostName);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszHostName);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwPort);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ DWORD dwPort);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
    /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ BOOL fBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetProtocolRollover_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetProtocolRollover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_GetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_SetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetNumProtocolsSupported_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProtocols);


void __RPC_STUB IWMReaderNetworkConfig_GetNumProtocolsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetSupportedProtocolName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolNum,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);


void __RPC_STUB IWMReaderNetworkConfig_GetSupportedProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_AddLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl);


void __RPC_STUB IWMReaderNetworkConfig_AddLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pwszUrl,
    /* [out][in] */ DWORD __RPC_FAR *pcchUrl);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrlCount_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwUrlCount);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrlCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetLoggingUrlList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetLoggingUrlList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD __RPC_FAR *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD __RPC_FAR *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KillTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderStreamClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderStreamClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    (This)->lpVtbl -> GetTime(This,pcnsNow)

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId)

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    (This)->lpVtbl -> KillTimer(This,dwTimerId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_GetTime_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD __RPC_FAR *pcnsNow);


void __RPC_STUB IWMReaderStreamClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_SetTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD cnsWhen,
    /* [in] */ void __RPC_FAR *pvParam,
    /* [out] */ DWORD __RPC_FAR *pdwTimerId);


void __RPC_STUB IWMReaderStreamClock_SetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_KillTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ DWORD dwTimerId);


void __RPC_STUB IWMReaderStreamClock_KillTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIndexer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIndexer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIndexing )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IWMIndexer __RPC_FAR * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer_StartIndexing_Proxy( 
    IWMIndexer __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMIndexer_StartIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIndexer_Cancel_Proxy( 
    IWMIndexer __RPC_FAR * This);


void __RPC_STUB IWMIndexer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BackupLicenses )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseBackup )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback)

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    (This)->lpVtbl -> CancelLicenseBackup(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseBackup_BackupLicenses_Proxy( 
    IWMLicenseBackup __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseBackup_BackupLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseBackup_CancelLicenseBackup_Proxy( 
    IWMLicenseBackup __RPC_FAR * This);


void __RPC_STUB IWMLicenseBackup_CancelLicenseBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreLicenses )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseRestore )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback)

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    (This)->lpVtbl -> CancelLicenseRestore(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseRestore_RestoreLicenses_Proxy( 
    IWMLicenseRestore __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseRestore_RestoreLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseRestore_CancelLicenseRestore_Proxy( 
    IWMLicenseRestore __RPC_FAR * This);


void __RPC_STUB IWMLicenseRestore_CancelLicenseRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD __RPC_FAR *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropCount )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByIndex )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByName )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllProps )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBackupRestoreProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBackupRestoreProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    (This)->lpVtbl -> GetPropCount(This,pcProps)

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength)

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    (This)->lpVtbl -> RemoveProp(This,pcwszName)

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    (This)->lpVtbl -> RemoveAllProps(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropCount_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcProps);


void __RPC_STUB IWMBackupRestoreProps_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByIndex_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByName_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_SetProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMBackupRestoreProps_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pcwszName);


void __RPC_STUB IWMBackupRestoreProps_RemoveProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveAllProps_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This);


void __RPC_STUB IWMBackupRestoreProps_RemoveAllProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecInfoCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [out] */ DWORD __RPC_FAR *pcCodecs);


void __RPC_STUB IWMCodecInfo_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormatCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ DWORD __RPC_FAR *pcFormat);


void __RPC_STUB IWMCodecInfo_GetCodecFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormat_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);


void __RPC_STUB IWMCodecInfo_GetCodecFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsysprf.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:        wmsysprf.prx
//
//  Description: This file contains the GUIDs of the system profiles.
//
//============================================================================

///////////////////////////////////////////////////////////////////////////////

/* fd7f47f1-72a6-45a4-80f0-3aecefc32c07 */
EXTERN_GUID( WMProfile_V40_DialUpMBR, 
             0xfd7f47f1,
             0x72a6,
             0x45a4,
             0x80, 0xf0, 0x3a, 0xec, 0xef, 0xc3, 0x2c, 0x07 );

///////////////////////////////////////////////////////////////////////////////

/* 82cd3321-a94a-4ffc-9c2b-092c10ca16e7 */
EXTERN_GUID( WMProfile_V40_IntranetMBR, 
             0x82cd3321,
             0xa94a,
             0x4ffc,
             0x9c, 0x2b, 0x09, 0x2c, 0x10, 0xca, 0x16, 0xe7 );

///////////////////////////////////////////////////////////////////////////////

/* 5a1c2206-dc5e-4186-beb2-4c5a994b132e */
EXTERN_GUID( WMProfile_V40_2856100MBR, 
             0x5a1c2206,
             0xdc5e,
             0x4186,
             0xbe, 0xb2, 0x4c, 0x5a, 0x99, 0x4b, 0x13, 0x2e );

///////////////////////////////////////////////////////////////////////////////

/* D508978A-11A0-4d15-B0DA-ACDC99D4F890 */
EXTERN_GUID( WMProfile_V40_6VoiceAudio,
             0xD508978A,
             0x11A0,
             0x4d15,
             0xb0, 0xda, 0xac, 0xdc, 0x99, 0xd4, 0xf8, 0x90 );

///////////////////////////////////////////////////////////////////////////////

/* 0f4be81f-d57d-41e1-b2e3-2fad986bfec2 */
EXTERN_GUID( WMProfile_V40_16AMRadio, 
             0x0f4be81f,
             0xd57d,
             0x41e1,
             0xb2, 0xe3, 0x2f, 0xad, 0x98, 0x6b, 0xfe, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* 7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1 */
EXTERN_GUID( WMProfile_V40_288FMRadioMono, 
             0x7fa57fc8,
             0x6ea4,
             0x4645,
             0x8a, 0xbf, 0xb6, 0xe5, 0xa8, 0xf8, 0x14, 0xa1 );

///////////////////////////////////////////////////////////////////////////////

/* 22fcf466-aa40-431f-a289-06d0ea1a1e40 */
EXTERN_GUID( WMProfile_V40_288FMRadioStereo, 
             0x22fcf466,
             0xaa40,
             0x431f,
             0xa2, 0x89, 0x06, 0xd0, 0xea, 0x1a, 0x1e, 0x40 );

///////////////////////////////////////////////////////////////////////////////

/* e8026f87-e905-4594-a3c7-00d00041d1d9 */
EXTERN_GUID( WMProfile_V40_56DialUpStereo, 
             0xe8026f87,
             0xe905,
             0x4594,
             0xa3, 0xc7, 0x00, 0xd0, 0x00, 0x41, 0xd1, 0xd9 );

///////////////////////////////////////////////////////////////////////////////

/* 4820b3f7-cbec-41dc-9391-78598714c8e5 */
EXTERN_GUID( WMProfile_V40_64Audio, 
             0x4820b3f7,
             0xcbec,
             0x41dc,
             0x93, 0x91, 0x78, 0x59, 0x87, 0x14, 0xc8, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* 0efa0ee3-9e64-41e2-837f-3c0038f327ba */
EXTERN_GUID( WMProfile_V40_96Audio, 
             0x0efa0ee3,
             0x9e64,
             0x41e2,
             0x83, 0x7f, 0x3c, 0x00, 0x38, 0xf3, 0x27, 0xba );

///////////////////////////////////////////////////////////////////////////////

/* 93ddbe12-13dc-4e32-a35e-40378e34279a */
EXTERN_GUID( WMProfile_V40_128Audio, 
             0x93ddbe12,
             0x13dc,
             0x4e32,
             0xa3, 0x5e, 0x40, 0x37, 0x8e, 0x34, 0x27, 0x9a );

///////////////////////////////////////////////////////////////////////////////

/* bb2bc274-0eb6-4da9-b550-ecf7f2b9948f */
EXTERN_GUID( WMProfile_V40_288VideoVoice, 
             0xbb2bc274,
             0x0eb6,
             0x4da9,
             0xb5, 0x50, 0xec, 0xf7, 0xf2, 0xb9, 0x94, 0x8f );

///////////////////////////////////////////////////////////////////////////////

/* ac617f2d-6cbe-4e84-8e9a-ce151a12a354 */
EXTERN_GUID( WMProfile_V40_288VideoAudio, 
             0xac617f2d,
             0x6cbe,
             0x4e84,
             0x8e, 0x9a, 0xce, 0x15, 0x1a, 0x12, 0xa3, 0x54 );

///////////////////////////////////////////////////////////////////////////////

/* abf2f00d-d555-4815-94ce-8275f3a70bfe */
EXTERN_GUID( WMProfile_V40_288VideoWebServer, 
             0xabf2f00d,
             0xd555,
             0x4815,
             0x94, 0xce, 0x82, 0x75, 0xf3, 0xa7, 0x0b, 0xfe );

///////////////////////////////////////////////////////////////////////////////

/* e21713bb-652f-4dab-99de-71e04400270f */
EXTERN_GUID( WMProfile_V40_56DialUpVideo, 
             0xe21713bb,
             0x652f,
             0x4dab,
             0x99, 0xde, 0x71, 0xe0, 0x44, 0x00, 0x27, 0x0f );

///////////////////////////////////////////////////////////////////////////////

/* b756ff10-520f-4749-a399-b780e2fc9250 */
EXTERN_GUID( WMProfile_V40_56DialUpVideoWebServer, 
             0xb756ff10,
             0x520f,
             0x4749,
             0xa3, 0x99, 0xb7, 0x80, 0xe2, 0xfc, 0x92, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* 8f99ddd8-6684-456b-a0a3-33e1316895f0 */
EXTERN_GUID( WMProfile_V40_100Video, 
             0x8f99ddd8,
             0x6684,
             0x456b,
             0xa0, 0xa3, 0x33, 0xe1, 0x31, 0x68, 0x95, 0xf0 );

///////////////////////////////////////////////////////////////////////////////

/* 541841c3-9339-4f7b-9a22-b11540894e42 */
EXTERN_GUID( WMProfile_V40_250Video, 
             0x541841c3,
             0x9339,
             0x4f7b,
             0x9a, 0x22, 0xb1, 0x15, 0x40, 0x89, 0x4e, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* 70440e6d-c4ef-4f84-8cd0-d5c28686e784 */
EXTERN_GUID( WMProfile_V40_512Video, 
             0x70440e6d,
             0xc4ef,
             0x4f84,
             0x8c, 0xd0, 0xd5, 0xc2, 0x86, 0x86, 0xe7, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* b4482a4c-cc17-4b07-a94e-9818d5e0f13f */
EXTERN_GUID( WMProfile_V40_1MBVideo, 
             0xb4482a4c,
             0xcc17,
             0x4b07,
             0xa9, 0x4e, 0x98, 0x18, 0xd5, 0xe0, 0xf1, 0x3f );

///////////////////////////////////////////////////////////////////////////////

/* 55374ac0-309b-4396-b88f-e6e292113f28 */
EXTERN_GUID( WMProfile_V40_3MBVideo, 
             0x55374ac0,
             0x309b,
             0x4396,
             0xb8, 0x8f, 0xe6, 0xe2, 0x92, 0x11, 0x3f, 0x28 );

///////////////////////////////////////////////////////////////////////////////

/* 5B16E74B-4068-45b5-B80E-7BF8C80D2C2F */
EXTERN_GUID( WMProfile_V70_DialUpMBR, 
             0x5b16e74b,
             0x4068,
             0x45b5,
             0xb8, 0xe, 0x7b, 0xf8, 0xc8, 0xd, 0x2c, 0x2f );

///////////////////////////////////////////////////////////////////////////////

/* 045880DC-34B6-4ca9-A326-73557ED143F3 */
EXTERN_GUID( WMProfile_V70_IntranetMBR, 
             0x45880dc,
             0x34b6,
             0x4ca9,
             0xa3, 0x26, 0x73, 0x55, 0x7e, 0xd1, 0x43, 0xf3 );

///////////////////////////////////////////////////////////////////////////////

/* 07DF7A25-3FE2-4a5b-8B1E-348B0721CA70 */
EXTERN_GUID( WMProfile_V70_2856100MBR, 
             0x7df7a25,
             0x3fe2,
             0x4a5b,
             0x8b, 0x1e, 0x34, 0x8b, 0x7, 0x21, 0xca, 0x70 );

///////////////////////////////////////////////////////////////////////////////

/* B952F38E-7DBC-4533-A9CA-B00B1C6E9800 */
EXTERN_GUID( WMProfile_V70_288VideoVoice, 
             0xb952f38e,
             0x7dbc,
             0x4533,
             0xa9, 0xca, 0xb0, 0xb, 0x1c, 0x6e, 0x98, 0x0 );

///////////////////////////////////////////////////////////////////////////////

/* 58BBA0EE-896A-4948-9953-85B736F83947 */
EXTERN_GUID( WMProfile_V70_288VideoAudio, 
             0x58bba0ee,
             0x896a,
             0x4948,
             0x99, 0x53, 0x85, 0xb7, 0x36, 0xf8, 0x39, 0x47 );

///////////////////////////////////////////////////////////////////////////////

/* 70A32E2B-E2DF-4ebd-9105-D9CA194A2D50 */
EXTERN_GUID( WMProfile_V70_288VideoWebServer, 
             0x70a32e2b,
             0xe2df,
             0x4ebd,
             0x91, 0x5, 0xd9, 0xca, 0x19, 0x4a, 0x2d, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* DEF99E40-57BC-4ab3-B2D1-B6E3CAF64257 */
EXTERN_GUID( WMProfile_V70_56VideoWebServer, 
             0xdef99e40,
             0x57bc,
             0x4ab3,
             0xb2, 0xd1, 0xb6, 0xe3, 0xca, 0xf6, 0x42, 0x57 );

///////////////////////////////////////////////////////////////////////////////

/* C2B7A7E9-7B8E-4992-A1A1-068217A3B311 */
EXTERN_GUID( WMProfile_V70_64VideoISDN,
             0xc2b7a7e9,
             0x7b8e,
             0x4992,
             0xa1, 0xa1, 0x06, 0x82, 0x17, 0xa3, 0xb3, 0x11 );

///////////////////////////////////////////////////////////////////////////////

/* D9F3C932-5EA9-4c6d-89B4-2686E515426E */
EXTERN_GUID( WMProfile_V70_100Video, 
             0xd9f3c932,
             0x5ea9,
             0x4c6d,
             0x89, 0xb4, 0x26, 0x86, 0xe5, 0x15, 0x42, 0x6e );

///////////////////////////////////////////////////////////////////////////////

/* AFE69B3A-403F-4a1b-8007-0E21CFB3DF84 */
EXTERN_GUID( WMProfile_V70_256Video,
             0xafe69b3a,
             0x403f,
             0x4a1b,
             0x80, 0x7, 0xe, 0x21, 0xcf, 0xb3, 0xdf, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* F3D45FBB-8782-44df-97C6-8678E2F9B13D */
EXTERN_GUID( WMProfile_V70_384Video,
             0xf3d45fbb,
             0x8782,
             0x44df,
             0x97, 0xc6, 0x86, 0x78, 0xe2, 0xf9, 0xb1, 0x3d );

///////////////////////////////////////////////////////////////////////////////

/* 0326EBB6-F76E-4964-B0DB-E729978D35EE */
EXTERN_GUID( WMProfile_V70_768Video, 
             0x326ebb6,
             0xf76e,
             0x4964,
             0xb0, 0xdb, 0xe7, 0x29, 0x97, 0x8d, 0x35, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* 0B89164A-5490-4686-9E37-5A80884E5146 */
EXTERN_GUID( WMProfile_V70_1500Video, 
             0xb89164a,
             0x5490,
             0x4686,
             0x9e, 0x37, 0x5a, 0x80, 0x88, 0x4e, 0x51, 0x46 );

///////////////////////////////////////////////////////////////////////////////

/* AA980124-BF10-4e4f-9AFD-4329A7395CFF */
EXTERN_GUID( WMProfile_V70_2000Video,
             0xaa980124,
             0xbf10,
             0x4e4f, 
             0x9a, 0xfd, 0x43, 0x29, 0xa7, 0x39, 0x5c, 0xff );

///////////////////////////////////////////////////////////////////////////////

/* 7A747920-2449-4d76-99CB-FDB0C90484D4 */
EXTERN_GUID( WMProfile_V70_700FilmContentVideo,
             0x7a747920,
             0x2449,
             0x4d76,
             0x99, 0xcb, 0xfd, 0xb0, 0xc9, 0x4, 0x84, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* F6A5F6DF-EE3F-434c-A433-523CE55F516B */
EXTERN_GUID( WMProfile_V70_1500FilmContentVideo,
             0xf6a5f6df,
             0xee3f,
             0x434c,
             0xa4, 0x33, 0x52, 0x3c, 0xe5, 0x5f, 0x51, 0x6b );

///////////////////////////////////////////////////////////////////////////////

/* EABA9FBF-B64F-49b3-AA0C-73FBDD150AD0 */
EXTERN_GUID( WMProfile_V70_6VoiceAudio, 
             0xeaba9fbf,
             0xb64f,
             0x49b3,
             0xaa, 0xc, 0x73, 0xfb, 0xdd, 0x15, 0xa, 0xd0 );

///////////////////////////////////////////////////////////////////////////////

/* C012A833-A03B-44a5-96DC-ED95CC65582D */
EXTERN_GUID( WMProfile_V70_288FMRadioMono, 
             0xc012a833,
             0xa03b,
             0x44a5,
             0x96, 0xdc, 0xed, 0x95, 0xcc, 0x65, 0x58, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* E96D67C9-1A39-4dc4-B900-B1184DC83620 */
EXTERN_GUID( WMProfile_V70_288FMRadioStereo, 
             0xe96d67c9,
             0x1a39,
             0x4dc4,
             0xb9, 0x0, 0xb1, 0x18, 0x4d, 0xc8, 0x36, 0x20 );

///////////////////////////////////////////////////////////////////////////////

/* 674EE767-0949-4fac-875E-F4C9C292013B */
EXTERN_GUID( WMProfile_V70_56DialUpStereo,
             0x674ee767,
             0x949,
             0x4fac,
             0x87, 0x5e, 0xf4, 0xc9, 0xc2, 0x92, 0x1, 0x3b );

///////////////////////////////////////////////////////////////////////////////

/* 91DEA458-9D60-4212-9C59-D40919C939E4 */
EXTERN_GUID( WMProfile_V70_64AudioISDN,
             0x91dea458,
             0x9d60,
             0x4212,
             0x9c, 0x59, 0xd4, 0x09, 0x19, 0xc9, 0x39, 0xe4 );

///////////////////////////////////////////////////////////////////////////////

/* B29CFFC6-F131-41db-B5E8-99D8B0B945F4 */
EXTERN_GUID( WMProfile_V70_64Audio, 
             0xb29cffc6,
             0xf131,
             0x41db,
             0xb5, 0xe8, 0x99, 0xd8, 0xb0, 0xb9, 0x45, 0xf4 );

///////////////////////////////////////////////////////////////////////////////

/* A9D4B819-16CC-4a59-9F37-693DBB0302D6 */
EXTERN_GUID( WMProfile_V70_96Audio, 
             0xa9d4b819,
             0x16cc,
             0x4a59,
             0x9f, 0x37, 0x69, 0x3d, 0xbb, 0x3, 0x2, 0xd6 );

///////////////////////////////////////////////////////////////////////////////

/* C64CF5DA-DF45-40d3-8027-DE698D68DC66 */
EXTERN_GUID( WMProfile_V70_128Audio, 
             0xc64cf5da,
             0xdf45,
             0x40d3,
             0x80, 0x27, 0xde, 0x69, 0x8d, 0x68, 0xdc, 0x66 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\avisrc\avisrc.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

//
// prototype stream handler for avi files
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//

extern const AMOVIESETUP_FILTER sudAVIDoc;

// forward declarations

class CAVIStream;       // owns a particular stream
class CAVIDocument;     // overall container class

#include <dynlink.h>	// implements dynamic linking

// worker thread object
class CAVIWorker : public CAMThread DYNLINKAVI
{

    CAVIStream * m_pPin;

    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

    // return S_OK if reach sStop, S_FALSE if pos changed, or else error
    HRESULT PushLoop(
		LONG sCurrent,
		LONG sStart,
		CRefTime tStart
		);

public:
    CAVIWorker();

    BOOL Create(CAVIStream * pStream);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};


//
// CAVIDocument represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
// supports (via nested implementations)
//  -- IBaseFilter
//  -- IMediaFilter
//  -- IFileSourceFilter
//

class CAVIDocument : public CUnknown, public CCritSec DYNLINKAVI
{

public:

    // constructors etc
    CAVIDocument(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAVIDocument();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // pin enumerator calls this
    int GetPinCount() {
	return m_nStreams;
    };

    CBasePin * GetPin(int n);
    HRESULT FindPin(LPCWSTR Id, IPin **ppPin);
    int FindPinNumber(IPin *iPin);


public:


    /* Nested implementation classes */


    /* Implements the IBaseFilter and IMediaFilter interfaces */

    class CImplFilter : public CBaseFilter
    {

    private:

	CAVIDocument *m_pAVIDocument;

    public:

	CImplFilter(
	    TCHAR *pName,
	    CAVIDocument *pAVIDocument,
	    HRESULT *phr);

	~CImplFilter();

	// map getpin/getpincount for base enum of pins to owner
	int GetPinCount() {
	    return m_pAVIDocument->GetPinCount();
	};

	CBasePin * GetPin(int n) {
	    return m_pAVIDocument->GetPin(n);
	};

        STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin)
            {return m_pAVIDocument->FindPin(Id, ppPin);};

    };


    /* Implements the IFileSourceFilter interface */


    class CImplFileSourceFilter : public CUnknown,
			     public IFileSourceFilter DYNLINKAVI
    {

    private:

	CAVIDocument *m_pAVIDocument;
        LPOLESTR      m_pFileName;  // set by Load, used by GetCurFile

    public:

	CImplFileSourceFilter(
	    TCHAR *pName,
	    CAVIDocument *pAVIDocument,
	    HRESULT *phr);

	~CImplFileSourceFilter();

	DECLARE_IUNKNOWN

	/* Override this to say what interfaces we support and where */
	STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

	STDMETHODIMP Load(
			LPCOLESTR pszFileName,
			const AM_MEDIA_TYPE *pmt);

	/* Free any resources acquired by Load */
	STDMETHODIMP Unload();

	STDMETHODIMP GetCurFile(
			LPOLESTR * ppszFileName,
                        AM_MEDIA_TYPE *pmt);
    };

    /* End of nested interfaces */


// implementation details

private:

    /* Let the nested interfaces access our private state */

    friend class CImplFilter;
    friend class CImplFileSourceFilter;
    friend class CAVIStream;

    // stream's worker thread can get private state
    friend class CAVIWorker;

    CImplFilter        *m_pFilter;          /* IBaseFilter */
    CImplFileSourceFilter   *m_pFileSourceFilter;     /* IFileSourceFilter */

    CAVIStream ** m_paStreams;
    int m_nStreams;
    PAVIFILE m_pFile;

    void CloseFile(void);
};


// CAVIStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CAVIDocument object and
// returned via the EnumPins interface.
//

class CAVIStream : public CBaseOutputPin DYNLINKAVI
{

public:

    CAVIStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CAVIDocument * pDoc,
	PAVISTREAM pStream,
	AVISTREAMINFOW * pSI);

    ~CAVIStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    STDMETHODIMP QueryId(LPWSTR *Id);

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();


    // ----- called by worker thread ---

    // where is the key frame preceding sample ?
    LONG StartFrom(LONG sample);

    // returns the sample number starting at or after time t
    LONG RefTimeToSample(CRefTime t);

    // returns the RefTime for s (media time)
    CRefTime SampleToRefTime(LONG s);

    // override to receive Notification messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // access the stop and rate variables used by PushLoop
    // called by worker thread and
    double GetRate(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        return m_dRate;
    }
    void SetRate(double dRate) {
        // not atomic so hold critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        m_dRate = dRate;
    }
    LONG GetStopAt(void) {
        // atomic so no critsec
        return m_sStopAt;
    }
    REFERENCE_TIME GetStopTime(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        return m_tStopAt;
    }
    void SetStopAt(LONG sStopAt, REFERENCE_TIME tStop) {
        // not atomic - so use critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        m_tStopAt = tStop;
        m_sStopAt = sStopAt;
    }


private:

    friend class CAVIWorker;

    PAVISTREAM m_pStream;
    CAVIWorker m_Worker;
    CAVIDocument * m_pDoc;

    LONG m_Start;       // stream start position from header
    LONG m_Length;      // stream duration from header

    // store the type/subtype classids
    FOURCCMap m_fccType;
    FOURCCMap m_fccSubtype;

    // the worker thread PushLoop is checking against these for every sample
    // Use Get/SetRate Get/SetStop to access from worker thread
    LONG m_sStopAt;
    REFERENCE_TIME m_tStopAt;
    double m_dRate;

    // implementation of IMediaPosition
    class CImplPosition : public CSourcePosition, public CCritSec
    {
    protected:
	CAVIStream * m_pStream;
	HRESULT ChangeStart();
	HRESULT ChangeStop();
	HRESULT ChangeRate();
    public:
	CImplPosition(TCHAR*, CAVIStream*, HRESULT*);
	double Rate() {
	    return m_Rate;
	};
	CRefTime Start() {
	    return m_Start;
	};
	CRefTime Stop() {
	    return m_Stop;
	};
    };

    // stream header - passed in constructor
    AVISTREAMINFOW m_info;

    // It would be good to allocate a block of memory specific to
    // each stream rather than loading up ALL stream types with video
    // information.  However to save time these two LONGs can exist
    // in all stream types.
    LONG	m_lLastPaletteChange;
    LONG 	m_lNextPaletteChange;

    friend class CImplPosition;
    CImplPosition * m_pPosition;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\capture.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


// Video Capture filter
//
//

#include <streams.h>

extern "C" {
#include "thunk.h"
};

//  #define _INC_MMDEBUG_CODE_ TRUE
//  #define MODULE_DEBUG_PREFIX "Capture\\"

#ifdef FILTER_DLL
  // define the GUIDs for streams and my CLSID in this file
  #include <initguid.h>
  #include <olectlid.h>  // to get IID_IProp...
#endif

static char pszDll16[] = "VIDX16.DLL";
static char pszDll32[] = "CAPTURE.DLL";

#include "driver.h"

// setup data now done by the class manager
#if 0

const AMOVIESETUP_MEDIATYPE
sudVFWCaptureType = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL };  // clsMinorType

const AMOVIESETUP_PIN
psudVFWCapturePins[] =  { L"Output"         // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudVFWCaptureType };// lpTypes

const AMOVIESETUP_FILTER
sudVFWCapture  = { &CLSID_VfwCapture     // clsID
                 , L"VFW Capture "       // strName
                 , MERIT_DO_NOT_USE      // dwMerit
                 , 1                     // nPins
                 , psudVFWCapturePins }; // lpPin
#endif


#ifdef FILTER_DLL

  // list of class ids and creator functions for class factory
  CFactoryTemplate g_Templates[] = {
    {L"VFW Capture Filter", &CLSID_VfwCapture, CVfwCapture::CreateInstance, NULL, NULL},
    {L"VFW Capture Filter Property Page", &CLSID_CaptureProperties, CPropPage::CreateInstance, NULL, NULL}
  };
  int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif

// define some of the X86 specific functions so that NON X86 will build correctly.

// ------ Implements the CVfwCapture public member functions --------

// disable warning about using this in initalizer list.  It could be
// a problem since 'this' is not yet fully constructed, but since all
// we are doing is passing a the 'this' pointer to be stored, it's ok.
//
#pragma warning(disable:4355)

static int cRefCount = 0;

extern "C" {
int g_IsNT;
};

// constructor
//
CVfwCapture::CVfwCapture(
   TCHAR *pName,
   LPUNKNOWN pUnk,
   HRESULT *phr)
   :
   m_lock(),
   m_pStream(NULL),
   m_pOverlayPin(NULL),
   m_pPreviewPin(NULL),
   m_Specify(this, phr),
   m_Options(this, phr),
   m_fDialogUp(FALSE),
   m_iVideoId(-1),
   m_pPersistStreamDevice(NULL),
   CBaseFilter(pName, pUnk, &m_lock, CLSID_VfwCapture),
   CPersistStream(pUnk, phr)
{
   DbgLog((LOG_TRACE,1,TEXT("*Instantiating the VfwCapture filter")));

   ASSERT(cRefCount >= 0);
   if (++cRefCount == 1) {
      DbgLog((LOG_TRACE,2,TEXT("This is the first instance")));

      OSVERSIONINFO OSVer;
      OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
      BOOL bRet = GetVersionEx((LPOSVERSIONINFO) &OSVer);
      ASSERT(bRet);

      g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

      if (!g_IsNT) {
          EXECUTE_ASSERT(ThunkInit());
      }
      else {
	  NTvideoInitHandleList();
      }
   }

// old code to test IAMVfwCaptureDialogs
#if 0
	HRESULT hr;
   	DbgLog((LOG_TRACE,1,TEXT("Testing HasDialog(Format)")));
	hr = HasDialog(VfwCaptureDialog_Format);
   	DbgLog((LOG_TRACE,1,TEXT("%08x"), hr));
   	DbgLog((LOG_TRACE,1,TEXT("Testing HasDialog(Display)")));
	hr = HasDialog(VfwCaptureDialog_Display);
   	DbgLog((LOG_TRACE,1,TEXT("%08x"), hr));
   	DbgLog((LOG_TRACE,1,TEXT("Testing ShowDialog(Format)")));
	hr = ShowDialog(VfwCaptureDialog_Format, NULL);
   	DbgLog((LOG_TRACE,1,TEXT("Testing SendDriverMessage(ShowSourceDlg)")));
	hr = SendDriverMessage(VfwCaptureDialog_Source,
				DRV_USER + 100 /* DVM_DIALOG */, NULL, 0);
#endif

}

// destructor
//
CVfwCapture::~CVfwCapture()
{
   DbgLog((LOG_TRACE,1,TEXT("*Destroying the VfwCapture filter")));

   // ensure that all streams are inactive
   Stop();

   delete m_pStream;
   if (m_pOverlayPin)
	delete m_pOverlayPin;
   if (m_pPreviewPin)
	delete m_pPreviewPin;

   if (--cRefCount == 0) {
      if (!g_IsNT) {
          // disconnect the thunking stuff
          //
          ThunkTerm();
      }
      else {
	  NTvideoDeleteHandleList();
      }
   }
   ASSERT(cRefCount >= 0);

   if(m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
   }

   // free the memory associated with the streams
   //
}

// create a new instance of this class
//
CUnknown * CVfwCapture::CreateInstance (
   LPUNKNOWN pUnk,
   HRESULT * phr )
{
   return new CVfwCapture(NAME("VFW Capture"), pUnk, phr);
}

// override this to say what interfaces we support where
//
STDMETHODIMP CVfwCapture::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
   // See if we have the interface
   // try each of our interface supporting objects in turn
   //
   if (riid == IID_VfwCaptureOptions) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IVfwCaptureOptions")));
      return GetInterface((IVfwCaptureOptions *)&(this->m_Options),ppv);
   } else if (riid == IID_ISpecifyPropertyPages) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for ISpecifyPropertyPages")));
      return GetInterface((ISpecifyPropertyPages *)&(this->m_Specify),ppv);
   } else if (riid == IID_IAMVfwCaptureDialogs) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IAMVfwCaptureDialogs")));
      return GetInterface((LPUNKNOWN)(IAMVfwCaptureDialogs *)this, ppv);
   } else if (riid == IID_IPersistPropertyBag) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IPeristRegistryKey")));
      return GetInterface((IPersistPropertyBag*)this, ppv);
   } else if(riid == IID_IPersistStream) {
       DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IPersistStream")));
       return GetInterface((IPersistStream *) this, ppv);
   } else if(riid == IID_IAMFilterMiscFlags) {
       DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IAMFilterMiscFlags")));
       return GetInterface((IAMFilterMiscFlags *) this, ppv);
   }

   // nope, try the base class.
   //
   HRESULT hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
   if (SUCCEEDED(hr))
       return hr;      // ppv has been set appropriately

   return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

STDMETHODIMP CVfwCapture::CSpecifyProp::GetPages(CAUUID *pPages)
{
   DbgLog((LOG_TRACE,2,TEXT("CSpecifyProp::GetPages")));

   pPages->cElems = 1;
   pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems);
   if ( ! pPages->pElems)
       return E_OUTOFMEMORY;

   pPages->pElems[0] = CLSID_CaptureProperties;
   return NOERROR;
}

// how many pins do we have?
//
int CVfwCapture::GetPinCount()
{
   DbgLog((LOG_TRACE,5,TEXT("CVfwCap::GetPinCount")));

   if (m_pOverlayPin || m_pPreviewPin)
	return 2;
   else if(m_pStream)
	return 1;
   else
        return 0;
}


// return a non-addrefed pointer to the CBasePin.
//
CBasePin * CVfwCapture::GetPin(int ii)
{
   DbgLog((LOG_TRACE,5,TEXT("CVfwCap::GetPin")));

   if (ii == 0 && m_pStream)
      return m_pStream;
   if (ii == 1 && m_pOverlayPin)
      return m_pOverlayPin;
   if (ii == 1 && m_pPreviewPin)
      return m_pPreviewPin;
   return NULL;
}

// ===============  Implements the ICImplFilter class ===============

// override CBaseFilter::Run
//

// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP CVfwCapture::Run(REFERENCE_TIME tStart)
{
   DbgLog((LOG_TRACE,1,TEXT("CVfwCap::Run at %d"),
			(LONG)((CRefTime)tStart).Millisecs()));

   CAutoLock cObjectLock(m_pLock);

   // remember the stream time offset before notifying the pins
   //
   m_tStart = tStart;

   // if we are in the stopped state, first
   // pause the filter.
   //
   if (m_State == State_Stopped)
      {
      // !!! If the real Pause got an error, this will try a second time
      HRESULT hr = Pause();
      if (FAILED(hr))
         return hr;
      }

    // Tell the Stream Control stuff what's going on
    if (m_pPreviewPin)
	m_pPreviewPin->NotifyFilterState(State_Running, tStart);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->NotifyFilterState(State_Running, tStart);
#endif
    if (m_pStream)
	m_pStream->NotifyFilterState(State_Running, tStart);

   // now put our streaming video pin into the Run state
   //
   if (m_State == State_Paused) {
	HRESULT hr;
   	int cPins = GetPinCount();

        // do we have a streaming pin?
        if (cPins > 0) {
            CCapStream *pPin = m_pStream;
            if (pPin->IsConnected()) {
                hr = pPin->ActiveRun(tStart);
                if (FAILED(hr))
                    return hr;
            }
	    CCapOverlay *pPinO = m_pOverlayPin;
	    if (pPinO && pPinO->IsConnected()) {
                hr = pPinO->ActiveRun(tStart);
                if (FAILED(hr))
                    return hr;
	    }
	    CCapPreview *pPinP = m_pPreviewPin;
	    if (pPinP && pPinP->IsConnected()) {
                hr = pPinP->ActiveRun(tStart);
                if (FAILED(hr))
                    return hr;
	    }
	}
   }

   m_State = State_Running;
   return S_OK;
}

// override CBaseFilter::Pause
//

// Put the filter into a paused state.

STDMETHODIMP CVfwCapture::Pause()
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Pause")));

    // We have a driver dialog up that is about to change the capture settings.
    // Now is NOT a good time to start streaming.
    if (m_State == State_Stopped && m_fDialogUp) {
        DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Pause - Dialog up. SORRY!")));
	return E_UNEXPECTED;
    }

    CAutoLock cObjectLock(m_pLock);

    // Tell the Stream Control stuff what's going on
    if (m_pPreviewPin)
	m_pPreviewPin->NotifyFilterState(State_Paused, 0);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->NotifyFilterState(State_Paused, 0);
#endif
    if (m_pStream)
	m_pStream->NotifyFilterState(State_Paused, 0);

    // notify the pins of the change from Run-->Pause
    if (m_State == State_Running) {
	HRESULT hr;
	int cPins = GetPinCount();

	// make sure we have pins
	if (cPins > 0) {
	    CCapStream *pPin = m_pStream;
            if (pPin->IsConnected()) {
	        hr = pPin->ActivePause();
	        if (FAILED(hr))
		    return hr;
            }
	    CCapOverlay *pPinO = m_pOverlayPin;
            if (pPinO && pPinO->IsConnected()) {
	        hr = pPinO->ActivePause();
	        if (FAILED(hr))
		    return hr;
            }
	    CCapPreview *pPinP = m_pPreviewPin;
            if (pPinP && pPinP->IsConnected()) {
	        hr = pPinP->ActivePause();
	        if (FAILED(hr))
		    return hr;
            }
	}
    }

    // notify all pins BACKWARDS! so the overlay pin is started first, so the
    // overlay channel is intitialized before the capture channel (this is the
    // order AVICap did things in and we have to do the same thing or buggy
    // drivers like the Broadway or BT848 based drivers won't preview while
    // capturing.
    if (m_State == State_Stopped) {
	int cPins = GetPinCount();
	for (int c = cPins - 1; c >=  0; c--) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Active();
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }

    m_State = State_Paused;
    return S_OK;
}


STDMETHODIMP CVfwCapture::Stop()
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Stop")));

    CAutoLock cObjectLock(m_pLock);

    // Shame on the base classes
    if (m_State == State_Running) {
	HRESULT hr = Pause();
	if (FAILED(hr))
	    return hr;
    }

    // Tell the Stream Control stuff what's going on
    if (m_pPreviewPin)
	m_pPreviewPin->NotifyFilterState(State_Stopped, 0);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->NotifyFilterState(State_Stopped, 0);
#endif
    if (m_pStream)
	m_pStream->NotifyFilterState(State_Stopped, 0);

    return CBaseFilter::Stop();
}


// tell the stream control stuff what clock to use
STDMETHODIMP CVfwCapture::SetSyncSource(IReferenceClock *pClock)
{
    if (m_pStream)
	m_pStream->SetSyncSource(pClock);
    if (m_pPreviewPin)
	m_pPreviewPin->SetSyncSource(pClock);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->SetSyncSource(pClock);
#endif
    return CBaseFilter::SetSyncSource(pClock);
}


// tell the stream control stuff what sink to use
STDMETHODIMP CVfwCapture::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::JoinFilterGraph")));

    HRESULT hr = S_OK;

    // TAPI wants to create multiple filters at once, but only have one in
    // a graph at a time, so we delay taking any resources until now
    if (m_pStream == NULL && pGraph != NULL) {
	if (m_iVideoId != -1) {
            CreatePins(&hr);
            if (FAILED(hr))
	        return hr;
	    IncrementPinVersion();
            DbgLog((LOG_TRACE,1,TEXT("* Creating pins")));
	} else {
	    // we haven't been told what device to use yet!
            DbgLog((LOG_TRACE,1,TEXT("* Delay creating pins")));
	}
    } else if (pGraph != NULL) {
	// take resources only when in the filter graph
	hr = m_pStream->ConnectToDriver();
	if (FAILED(hr))
	    return hr;
	hr = m_pStream->LoadOptions();
	if (FAILED(hr))
	    return hr;
        DbgLog((LOG_TRACE,1,TEXT("* Reconnecting")));
    } else if (m_pStream) {
	// give back resources when not in graph
	m_pStream->DisconnectFromDriver();
   	delete [] m_pStream->m_cs.tvhPreview.vh.lpData;
   	m_pStream->m_cs.tvhPreview.vh.lpData = NULL;
   	delete m_pStream->m_user.pvi;
   	m_pStream->m_user.pvi = NULL;
        DbgLog((LOG_TRACE,1,TEXT("* Disconnecting")));
    }

    hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (hr == S_OK && m_pStream)
	m_pStream->SetFilterGraph(m_pSink);
#ifdef OVERLAY_SC
    if (hr == S_OK && m_pOverlayPin)
	m_pOverlayPin->SetFilterGraph(m_pSink);
#endif
    if (hr == S_OK && m_pPreviewPin)
	m_pPreviewPin->SetFilterGraph(m_pSink);
    return hr;
}


// we don't send any data during PAUSE, so to avoid hanging renderers, we
// need to return VFW_S_CANT_CUE when paused
STDMETHODIMP CVfwCapture::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
	return VFW_S_CANT_CUE;
    else
        return S_OK;
}

STDMETHODIMP CVfwCapture::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Load")));

    HRESULT hr = S_OK;
    CAutoLock cObjectLock(m_pLock);

    // We already have some pins, thank you
    if (m_pStream)
	return E_UNEXPECTED;

    m_fAvoidOverlay = FALSE;

    // Default to capture device #0
    if (pPropBag == NULL) {
        m_iVideoId = 0;
	// if we're in the graph already, we can make our pins and take
	// resources
	if (m_pGraph)
            CreatePins(&hr);
	return hr;
    }

    VARIANT var;
    var.vt = VT_I4;
    HRESULT hrX = pPropBag->Read(L"AvoidOverlay", &var, 0);
    if(SUCCEEDED(hrX))
    {
        DbgLog((LOG_TRACE,1,TEXT("*** OVERLAYS SWITCHED OFF")));
        m_fAvoidOverlay = TRUE;
    }

    var.vt = VT_I4;
    hr = pPropBag->Read(L"VFWIndex", &var, 0);
    if(SUCCEEDED(hr))
    {
        hr = S_OK;
        m_iVideoId = var.lVal;
	if (m_pGraph)
            CreatePins(&hr);
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0);

    // save moniker with addref. ignore error if qi fails
    if(SUCCEEDED(hr)) {
        pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);
    }

    return hr;
}

STDMETHODIMP CVfwCapture::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CVfwCapture::InitNew()
{
   if(m_pStream)
   {
       ASSERT(m_iVideoId != -1);
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }
   else
   {
       return S_OK;
   }
}

STDMETHODIMP CVfwCapture::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_VfwCapture;
    return S_OK;
}

// struct CapturePersist
// {
//     DWORD dwSize;
//     LONG iVideoId;
// };

HRESULT CVfwCapture::WriteToStream(IStream *pStream)
{
    ASSERT(m_iVideoId >= -1 && m_iVideoId < 10);
    HRESULT hr = E_FAIL;

    if(m_pPersistStreamDevice)
    {
        // the size field of CapturePersist was used as a version
        // number. previously 8, now 12
        DWORD dwVersion = 12;

        hr =  pStream->Write(&dwVersion, sizeof(dwVersion), 0);
        if(SUCCEEDED(hr))
        {
            hr = m_pPersistStreamDevice->Save(pStream, TRUE);
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CVfwCapture::ReadFromStream(IStream *pStream)
{

   DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::ReadFromStream")));

   if(m_pStream)
   {
       ASSERT(m_iVideoId != -1);
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   ASSERT(m_iVideoId == -1);

   DWORD dwVersion;
   HRESULT hr = pStream->Read(&dwVersion, sizeof(dwVersion), 0);
   if(FAILED(hr)) {
       return hr;
   }

   if(dwVersion != 12) {
      return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
   }

   IPersistStream *pMonPersistStream;
   hr = CoCreateInstance(CLSID_CDeviceMoniker, NULL, CLSCTX_INPROC_SERVER,
                         IID_IPersistStream, (void **)&pMonPersistStream);
   if(SUCCEEDED(hr))
   {
       hr = pMonPersistStream->Load(pStream);
       if(SUCCEEDED(hr))
       {
           IPropertyBag *pPropBag;
           hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
           if(SUCCEEDED(hr))
           {
               hr = Load(pPropBag, 0);
               pPropBag->Release();
           }
       }

       pMonPersistStream->Release();
   }

   return hr;
}

int CVfwCapture::SizeMax()
{
    ULARGE_INTEGER ulicb;
    HRESULT hr = E_FAIL;;
    if(m_pPersistStreamDevice)
    {
        hr = m_pPersistStreamDevice->GetSizeMax(&ulicb);
        if(hr == S_OK)
        {
            // space for version number
            ulicb.QuadPart += sizeof(DWORD);
        }
    }

    return hr == S_OK ? (int)ulicb.QuadPart : 0;
}


// ===============  Implements the COptions imbedded class ===============

STDMETHODIMP
CVfwCapture::COptions::VfwCapSetOptions (
   const VFWCAPTUREOPTIONS *pOpt)
{
   DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapSetOptions")));

   if (!m_pCap->m_pStream)
      return E_UNEXPECTED;
   return m_pCap->m_pStream->SetOptions(pOpt);
}

STDMETHODIMP
CVfwCapture::COptions::VfwCapGetOptions (
   VFWCAPTUREOPTIONS * pOpt)
{
   DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapGetOptions")));

   if ( ! m_pCap->m_pStream)
      return E_UNEXPECTED;
   return m_pCap->m_pStream->GetOptions(pOpt);
}

STDMETHODIMP CVfwCapture::COptions::VfwCapGetCaptureStats(CAPTURESTATS *pcs)
{
    DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapGetCaptureStats")));

    if ( ! m_pCap->m_pStream)
        return E_UNEXPECTED;

    if (pcs) {
	*pcs = m_pCap->m_pStream->m_capstats;
    	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

STDMETHODIMP
CVfwCapture::COptions::VfwCapDriverDialog (
   HWND hwnd,
   UINT uDrvType,
   UINT uQuery)
{
   DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapDriverDialog")));

   if (!m_pCap->m_pStream)
      return E_UNEXPECTED;
   return m_pCap->m_pStream->DriverDialog(hwnd, uDrvType, uQuery);
}

//======================================================================


//IAMVfwCaptureDialogs stuff

HRESULT CVfwCapture::HasDialog(int iDialog)
{
    if (!m_pStream)
        return E_UNEXPECTED;

    HVIDEO hVideo;
    if (iDialog == VfwCaptureDialog_Source)
	hVideo = m_pStream->m_cs.hVideoExtIn;
    else if (iDialog == VfwCaptureDialog_Format)
	hVideo = m_pStream->m_cs.hVideoIn;
    else if (iDialog == VfwCaptureDialog_Display)
	hVideo = m_pStream->m_cs.hVideoExtOut;
    else
	return S_FALSE;

    if (videoDialog(hVideo, GetDesktopWindow(), VIDEO_DLG_QUERY) == 0)
	return S_OK;
    else
	return S_FALSE;
}


HRESULT CVfwCapture::ShowDialog(int iDialog, HWND hwnd)
{
    if (!m_pStream)
        return E_UNEXPECTED;

    // Before we bring the dialog up, make sure we're not streaming, or about to
    // Also make sure another dialog isn't already up (I'm paranoid)
    // Then don't allow us to stream any more while the dialog is up (we can't
    // very well keep the critsect for a day and a half).
    m_pLock->Lock();
    if (m_State != State_Stopped || m_fDialogUp) {
        m_pLock->Unlock();
	return VFW_E_NOT_STOPPED;
    }
    m_fDialogUp = TRUE;
    m_pLock->Unlock();

    HVIDEO hVideo;
    if (iDialog == VfwCaptureDialog_Source)
	hVideo = m_pStream->m_cs.hVideoExtIn;
    else if (iDialog == VfwCaptureDialog_Format)
	hVideo = m_pStream->m_cs.hVideoIn;
    else if (iDialog == VfwCaptureDialog_Display)
	hVideo = m_pStream->m_cs.hVideoExtOut;
    else {
	m_fDialogUp = FALSE;
	return E_INVALIDARG;
    }

    if (hwnd == NULL)
	hwnd = GetDesktopWindow();

    DWORD dw = videoDialog(hVideo, hwnd, 0);

    // this changed our output format!
    if (dw == 0 && iDialog == VfwCaptureDialog_Format) {
        DbgLog((LOG_TRACE,1,TEXT("Changed output formats")));
        // The dialog changed the driver's internal format.  Get it again.
        m_pStream->GetFormatFromDriver();
        if (m_pStream->m_user.pvi->bmiHeader.biBitCount <= 8)
	    m_pStream->InitPalette();

        // Now reconnect us so the graph starts using the new format
        HRESULT hr = m_pStream->Reconnect(TRUE);
	if (hr != S_OK)
	    dw = VFW_E_CANNOT_CONNECT;
    }

    m_fDialogUp = FALSE;

    return dw;
}


HRESULT CVfwCapture::SendDriverMessage(int iDialog, int uMsg, long dw1, long dw2)
{

    if (!m_pStream)
        return E_UNEXPECTED;

    // This could do anything!  Bring up a dialog, who knows.
    // Don't take any crit sect or do any kind of protection.
    // They're on their own

    HVIDEO hVideo;
    if (iDialog == VfwCaptureDialog_Source)
	hVideo = m_pStream->m_cs.hVideoExtIn;
    else if (iDialog == VfwCaptureDialog_Format)
	hVideo = m_pStream->m_cs.hVideoIn;
    else if (iDialog == VfwCaptureDialog_Display)
	hVideo = m_pStream->m_cs.hVideoExtOut;
    else
	return E_INVALIDARG;

    return (HRESULT)videoMessage(hVideo, uMsg, dw1, dw2);
}

void CVfwCapture::CreatePins(HRESULT *phr)
{
   if(FAILED(*phr))
       return;

   CAutoLock cObjectLock(m_pLock);

   if(m_pStream)
   {
       *phr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   // create our output pins for the video data stream, and maybe overlay
   //
   m_pStream = CreateStreamPin(this, m_iVideoId, phr);

   if (m_pStream == NULL)
	return;

   // If we can do h/w preview with overlay, great, otherwise we'll do a
   // non-overlay preview
   if (m_pStream->m_cs.bHasOverlay) {
	m_pOverlayPin = CreateOverlayPin(this,phr);
   } else {
	m_pPreviewPin = CreatePreviewPin(this,phr);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\cmeasure.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
/*+ cmeasure.h
 *
 * routines to capture performance data for the capture filter
 *
 *-===============================================================*/

#ifdef JMK_HACK_TIMERS

#error JMK_HACK_TIMERS is broken, it assumes the VFWCAPTUREOPTIONS and _qc_user
#error structures are identical, and they aren't (measureInit)

#if !defined _INC_MEASURE_
#define _INC_MEASURE_

 #include "mmtimers.h"
 #ifndef FCC
  #define FCC(dw) (((dw & 0xFF) << 24) | ((dw & 0xFF00) << 8) | ((dw & 0xFF0000) >> 8) | ((dw & 0xFF000000) >> 24))
 #endif

 #ifndef JMK_LOG_SIZE
  #define JMK_LOG_SIZE 1000
 #endif

 #ifndef JMK_MAX_STRAMS
  #define JMK_MAX_STREAMS 2
 #endif

 struct _timerstuff {
     DWORD dwStampTime;        // Stamped in the VIDEOHDR
     DWORD dwTick;             // frame stamp converted to a tick time
     DWORD dwTimeWritten;      // Time Deliver called
     DWORD dwTimeToWrite;      // Time Deliver returned
     DWORD ixBuffer;           // which buffer we used
     DWORD dwArriveTime;       // what time the frame 'arrived'
     };

 struct _qc_user {
      UINT  uVideoID;      // id of video driver to open
      DWORD dwTimeLimit;   // stop capturing at this time???
      DWORD dwTickScale;   // frame rate rational
      DWORD dwTickRate;    // frame rate = dwRate/dwScale in ticks/sec
      DWORD dwRefTimeConv; // conversion to ReferenceTime
      UINT  nHeaders;      //
      UINT  cbFormat;      // sizeof VIDEOINFOHEADER
      VIDEOINFOHEADER * pvi;
      };

 struct _qc_cap {
      CAPDRIVERCAPS  caps;        // returned capabilities from the capture driver
      HVIDEO         hVideoIn;    // video input driver
      MMRESULT       mmr;         // open fail/success code
      THKVIDEOHDR    tvhPreview;
      DWORD          pSamplePreview;
      UINT           cbBuffer;           // max size of video frame data
      UINT           nHeaders;           // number of video headers
      DWORD          paHdrs;
      BOOL           fBuffersOnHardware; // TRUE if all video buffers are in hardware
      DWORD          hEvtBufferDone;
      DWORD          h0EvtBufferDone;
      UINT           iNext;
      LONGLONG       tTick;              // duration of a single tick
      };

 struct _qcap {
     DWORD   nPrio;
     DWORD   nFramesCaptured;
     DWORD   nFramesDropped;
     DWORD   dwTimerFrequency;
     UINT    state;
     DWORD   dwElapsedTime;
     struct _qc_user user;
     VIDEOINFOHEADER       vi;
     struct _qc_cap  cs;
     };

 struct _timerriff {
     FOURCC fccRIFF;       // 'RIFF'
     DWORD  cbTotal;       // total (inclusive) size of riff data
     FOURCC fccJMKD;       // 'JMKD' data type identifier

     DWORD  fccQCAP;       // 'VCHD' capture data header
     DWORD  cbQCAP;        // sizeof qcap data
     struct _qcap qcap;

     DWORD  fccChunk;      // chunk data type tag
     DWORD  cbChunk;       // non-inclusive size of chunk data
     };

 struct _measurestate {
   HANDLE hMemTimers;
   UINT   cbMemTimers;
   UINT   ixCurrent;
   UINT   nMax;
   struct _timerriff * pTimerRiff;
   struct _timerstuff * pCurStuff;
   struct _timerstuff * pStuff;
   PCTIMER pctBase;
   };

   extern struct _measurestate ms[JMK_MAX_STREAMS];

   extern void measureBegin(UINT id);
   extern void measureEnd(UINT id);
   extern void measureFree(UINT id);
   extern void measureAllocate(
      UINT id,
      UINT nMax);
   extern void measureInit(
      UINT id,
      struct _qc_user * pUser,
      UINT           cbUser,
      struct _qc_cap *  pCap,
      UINT           cbCap);

   #define jmkAlloc  measureAllocate(m_id, JMK_LOG_SIZE);
   #define jmkInit   measureInit(m_id,              \
        (struct _qc_user *)&m_user, sizeof(m_user), \
        (struct _qc_cap *)&m_cs, sizeof(m_cs));
   #define jmkFree  measureFree(m_id);
   #define jmkBegin measureBegin(m_id);
   #define jmkEnd   measureEnd(m_id);
   #define LOGFITS(id)  (id < NUMELMS(ms) && ms[id].pTimerRiff)

   #define jmkFrameArrives(ptvh,ix) if (LOGFITS(m_id)) {    \
     ms[m_id].pCurStuff->dwArriveTime = pcGetTicks();       \
     ms[m_id].pCurStuff->ixBuffer     = ix;                 \
     ++(ms[m_id].pTimerRiff->qcap.nFramesCaptured);         \
     ms[m_id].pTimerRiff->qcap.dwElapsedTime = pcGetTime(); \
     }
   #define jmkBeforeDeliver(ptvh,dwlTick) if (LOGFITS(m_id)) {            \
     ms[m_id].pCurStuff->dwStampTime = ptvh->vh.dwTimeCaptured;           \
     ms[m_id].pCurStuff->dwTick = (DWORD)dwlTick;                         \
     ms[m_id].pCurStuff->dwTimeWritten = pcDeltaTicks(&ms[m_id].pctBase); \
     }
   #define jmkAfterDeliver(ptvh) if (LOGFITS(m_id)) {                     \
     ms[m_id].pCurStuff->dwTimeToWrite = pcDeltaTicks(&ms[m_id].pctBase); \
     if (++(ms[m_id].ixCurrent) > ms[m_id].nMax)                          \
        ms[m_id].ixCurrent = 0;                                           \
     ms[m_id].pCurStuff = ms[m_id].pStuff + ms[m_id].ixCurrent;           \
     }

#endif //_INC_MEASURE_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if (defined _INC_MEASURE_CODE_) && (_INC_MEASURE_CODE_ != FALSE)
#undef _INC_MEASURE_CODE_
#define _INC_MEASURE_CODE_ FALSE

 #define _INC_MMTIMERS_CODE_ TRUE
 #include "mmtimers.h"

 struct _measurestate ms[JMK_MAX_STREAMS];

 void measureAllocate(UINT id,
                      UINT nMaxFrames)
 {
     BOOL bCreated = FALSE; // true if we create the mapping object
     TCHAR szName[30];
     struct _timerriff * pTimer;

     wsprintf (szName, "jmkCaptureRiff%d", id);

     //assert (!ms[id].pTimerRiff);
     ms[id].cbMemTimers = sizeof(struct _timerriff)
                        + (sizeof(struct _timerstuff) * nMaxFrames);
     if ( ! ms[id].cbMemTimers)
        return;

     ms[id].hMemTimers = CreateFileMapping((HANDLE)-1, NULL,
                                           PAGE_READWRITE,
                                           0, ms[id].cbMemTimers,
                                           szName);
     if (0 == GetLastError())
        bCreated = TRUE;

     if (ms[id].hMemTimers)
        ms[id].pTimerRiff = pTimer = (struct _timerriff *)
           MapViewOfFile (ms[id].hMemTimers, FILE_MAP_WRITE, 0, 0, 0);

     if (pTimer)
        {
        // if we created the memory, initialize it.
        // otherwise, assume that it is what we expect
        //
        if (bCreated)
           {
           ZeroMemory ((LPVOID)pTimer, ms[id].cbMemTimers);
           pTimer->fccRIFF = FCC('RIFF');
           pTimer->cbTotal = ms[id].cbMemTimers - 8; // (total does not include first two fields)
           pTimer->fccJMKD = FCC('JMKD');
           pTimer->fccQCAP = FCC('QCAP');
           pTimer->cbQCAP  = sizeof(struct _qcap);
           pTimer->fccChunk = FCC('TICK');
           pTimer->cbChunk = pTimer->cbTotal - sizeof(*pTimer);
           }
        else if (pTimer->fccRIFF != FCC('RIFF')         ||
                 pTimer->cbTotal < sizeof(*pTimer) ||
                 pTimer->fccJMKD != FCC('JMKD')         ||
                 pTimer->fccQCAP != FCC('QCAP')         ||
                 pTimer->cbQCAP != sizeof(struct _qcap) ||
                 pTimer->fccChunk != FCC('TICK')        ||
                 pTimer->cbChunk < sizeof(*ms[id].pStuff)
                 )
           {
           ms[id].pTimerRiff = pTimer = NULL;
           return;
           }
        }
 }

 void measureInit (UINT id,
                   struct _qc_user * pUser,
                   UINT              cbUser,
                   struct _qc_cap *  pCap,
                   UINT              cbCap)
 {
     struct _qcap * pqc;

     //assert (cbUser = sizeof(*pUser));
     //assert (cbCap = sizeof(*pCap));

     if (LOGFITS(id))
        {
        struct _timerriff * pTimer = ms[id].pTimerRiff;

        // reset counters and stuff to 0.
        //
        ms[id].ixCurrent = 0;
        ms[id].pCurStuff = ms[id].pStuff = (struct _timerstuff *)(pTimer+1);
        ms[id].nMax = pTimer->cbChunk / sizeof(*(ms[id].pStuff));

        // fill in qcap from the contents of the capture stream
        //
        pqc = &pTimer->qcap;
        pqc->nPrio = GetThreadPriority(GetCurrentThread());
        pqc->nFramesCaptured = 0;
        pqc->nFramesDropped  = 0;
        pqc->dwTimerFrequency = pc.dwTimerKhz;
        pqc->state = 0;
        pqc->dwElapsedTime = 0;

        CopyMemory (&pqc->user, pUser, min(cbUser, sizeof(pqc->user)));
        ZeroMemory (&pqc->vi, sizeof(pqc->vi));
        if (pUser->pvi && ! IsBadReadPtr(pUser->pvi, pUser->cbFormat))
           CopyMemory (&pqc->vi, pUser->pvi,
                       min(pUser->cbFormat, sizeof(pqc->vi)));

        CopyMemory (&pqc->cs, pCap, min(cbCap, sizeof(pqc->cs)));

        // zero out the tick buffer.  this also forces it to be present...
        //
        ZeroMemory (ms[id].pStuff, pTimer->cbChunk);
        }
  }

  void measureFree(UINT id)
  {
     if (ms[id].pTimerRiff)
       UnmapViewOfFile (ms[id].pTimerRiff);
     ms[id].pTimerRiff = NULL;

     if (ms[id].hMemTimers)
        CloseHandle (ms[id].hMemTimers);
     ms[id].hMemTimers = NULL;
  }

  void measureBegin(UINT id)
  {
     // set the base for our time measurement
     // and make sure that the base for write delta times
     // is the same as the base for the capture in general
     //
     if (id == 0)
        pcBegin();
     if (LOGFITS(id))
        {
        ms[id].pctBase = pc.base;
        ms[id].pTimerRiff->qcap.state = 1;
        }
  }

  void measureEnd(UINT id)
  {
     if (LOGFITS(id))
        {
        ms[id].pTimerRiff->qcap.state = 2;
        ms[id].pTimerRiff->qcap.dwElapsedTime = pcGetTime();
        }
  }

#endif


# if 0
               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff)
                    pTimerRiff->vchd.dwDropFramesNotAppended += nDropCount;
               #endif


           #ifdef JMK_HACK_TIMERS
	    if (pTimerRiff) {
	        if (nTimerIndex == CLIPBOARDLOGSIZE)
		    nTimerIndex = 0;
	
// nTimerIndex will be OK	if ((nTimerIndex < CLIPBOARDLOGSIZE) && pTimerStuff)
		if (pTimerStuff)
		{
	
		    pCurTimerStuff = &pTimerStuff[nTimerIndex];
                    ++nTimerIndex;

		    pCurTimerStuff->nFramesAppended = 0;
		    pCurTimerStuff->nDummyFrames  = (WORD)lpcs->dwFramesDropped;
		    pCurTimerStuff->dwFrameTickTime = dwTime;
		    pCurTimerStuff->dwFrameStampTime = lpvh->dwTimeCaptured;
		    pCurTimerStuff->dwVideoChunkCount = lpcs->dwVideoChunkCount;
                    pCurTimerStuff->dwTimeWritten = pcDeltaTicks(&pctWriteBase);
		    pCurTimerStuff->dwTimeToWrite = 0;
		    pCurTimerStuff->nVideoIndex = lpcs->iNextVideo;
		    pCurTimerStuff->nAudioIndex = lpcs->iNextWave;
		}
	    } // fClipboardLogging
           #endif // JMK_HACK_TIMERS



               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff) {
                    pTimerRiff->vchd.dwDropFramesAppended += nAppendDummyFrames;
		    pCurTimerStuff->nFramesAppended = nAppendDummyFrames;
		}
               #endif


           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
                pCurTimerStuff->dwTimeToWrite = pcDeltaTicks(&pctWriteBase);
                pCurTimerStuff->bPending = *lpbPending;
            }
           #endif


   #ifdef JMK_HACK_TIMERS
    // Allocate memory for logging capture results to the clipboard if requested
    if (GetProfileIntA ("Avicap32", "ClipboardLogging", FALSE))
    {
        AuxDebugEx (2, DEBUGLINE "ClipboardLogging Enabled\r\n");
        InitPerformanceCounters();
        pcBegin(), pctWriteBase = pc.base;

	hMemTimers = GlobalAlloc(GHND | GMEM_ZEROINIT,
                             sizeof(struct _timerriff) +
                             sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE);

	if (hMemTimers && (pTimerRiff = GlobalLock (hMemTimers)))
	    ;
	else if (hMemTimers)
	{
	    GlobalFree(hMemTimers);
	    pTimerRiff = 0;
	    pTimerStuff = 0;
	    hMemTimers = 0;
	}
	nTimerIndex = 0;
	nSleepCount = 0;
    }  // if ClipboardLogging
   #endif  // JMK_HACK_TIMERS


   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
	UINT ii;

        pTimerRiff->fccRIFF = RIFFTYPE('RIFF'); //MAKEFOURCC('R','I','F','F');
	pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
	    		  sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE;
        pTimerRiff->fccJMKD = RIFFTYPE('JMKD'); //MAKEFOURCC('J','M','K','D');
        pTimerRiff->fccVCHD = RIFFTYPE('VCHD'); //MAKEFOURCC('V','C','H','D');
	
	pTimerRiff->cbVCHD  = sizeof(struct _vchd);
	pTimerRiff->vchd.nPrio = GetThreadPriority(GetCurrentThread());
	pTimerRiff->vchd.bmih = lpcs->lpBitsInfo->bmiHeader;
	pTimerRiff->vchd.cap  = lpcs->sCapParms;
	pTimerRiff->vchd.dwDropFramesAppended = 0;
	pTimerRiff->vchd.dwDropFramesNotAppended = 0;
        pTimerRiff->vchd.dwTimerFrequency = pcGetTickRate();
	
	for (ii = 0; ii < NUMELMS(pTimerRiff->vchd.atvh); ++ii)
	{
	    if (lpcs->alpVideoHdr[ii])
            {
	        struct _thkvideohdr * ptvh = (LPVOID)lpcs->alpVideoHdr[ii];
               #ifndef CHICAGO
                assert (sizeof(CAPVIDEOHDR) == sizeof(*ptvh));
               #endif
                pTimerRiff->vchd.atvh[ii] = *ptvh;
                pTimerRiff->vchd.nMaxVideoBuffers = ii;
            }
        }
	
        pTimerRiff->fccChunk = RIFFTYPE('VCAP'); //MAKEFOURCC('V','C','A','P');
	pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);
	
	pTimerStuff = (LPVOID)(pTimerRiff + 1);
	pCurTimerStuff = &pTimerStuff[0];
    }  // fClipboardLogging
   #endif  // JMK_HACK_TIMERS


           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
               pCurTimerStuff->nSleepCount = ++nSleepCount;
               pCurTimerStuff->dwSleepBegin = pcGetTicks();
            }
           #endif

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
	    {
               pCurTimerStuff->dwSleepEnd = pcGetTicks();
	    }
           #endif



   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
        UINT    ii;
	UINT	kk;
        LPSTR   psz;
        HGLOBAL hMem;

        kk = (lpcs->dwVideoChunkCount >= CLIPBOARDLOGSIZE) ?
			CLIPBOARDLOGSIZE : nTimerIndex;

        hMem = GlobalAlloc (GHND, (16 * 5 + 2) * kk + 80);
	
        if (hMem && (psz = GlobalLock (hMem)))
        {
            pTimerRiff->vchd.dwFramesCaptured = lpcs->dwVideoChunkCount;
            pTimerRiff->vchd.dwFramesDropped = lpcs->dwFramesDropped;

            pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
                                  sizeof(struct _timerstuff) * nTimerIndex;
            pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);

            lstrcpyA(psz, "Slot#, VideoIndex, ExpectedTime, DriverTime, AccumulatedDummyFrames, CurrentAppendedDummies");
            for (ii = 0; ii < kk; ++ii)
            {
                psz += lstrlenA(psz);
                wsprintfA(psz, "\r\n%d, %ld, %ld, %ld, %d, %d",
			  ii,
			  pTimerStuff[ii].dwVideoChunkCount,
                          pTimerStuff[ii].dwFrameTickTime,
                          pTimerStuff[ii].dwFrameStampTime,
                          pTimerStuff[ii].nDummyFrames,
			  pTimerStuff[ii].nFramesAppended
                          );
            }

            GlobalUnlock (hMem);
            GlobalUnlock (hMemTimers);

            if (OpenClipboard (lpcs->hwnd))
            {
                EmptyClipboard ();
                SetClipboardData (CF_RIFF, hMemTimers);
                SetClipboardData (CF_TEXT, hMem);
                CloseClipboard ();
            }
            else
            {
                GlobalFree (hMem);
                GlobalFree (hMemTimers);
            }
        }
        else
        {
            // Failed to allocate or lock hMem.  Cleanup.
            //
            if (hMem)
                GlobalFree(hMem);

            // Free off the timer block.  (We have not set the
            // clipboard data.)
            //
            if (hMemTimers)
            {
                GlobalUnlock(hMemTimers);
                GlobalFree(hMemTimers);
            }
        }

        hMemTimers = NULL;
        pTimerRiff = NULL;
	pTimerStuff = NULL;
	pCurTimerStuff = NULL;
    }
   #endif



#endif // 0

#else	// JMK_HACK_TIMERS not defined
   #define jmkAlloc
   #define jmkInit
   #define jmkFree
   #define jmkBegin
   #define jmkEnd
   #define jmkFrameArrives(ptvh,ix)
   #define jmkBeforeDeliver(ptvh,tick)
   #define jmkAfterDeliver(ptvh)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\driver.h ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

#include <mmreg.h>
#include <olectl.h>

#include "ivideo32.h" // videoXXX api's
//#include "mmdebug.h"  // JMK's debug macros
#include "capture.h"  // Filter
#include "resource.h" // dlg resource ID's (for property page)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\common.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#define MIN_VIDEO_BUFFERS  1		// changing this will change vidx16.dll

#define MAX_VIDEO_BUFFERS  64		// by default, as much as possible
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\capture.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


//
// implements Video capture using Win95 16 bit capture drivers
//

extern const AMOVIESETUP_FILTER sudVFWCapture ;

// forward declarations

class CCapStream;       // the filter's video stream output pin
class CCapOverlay;      // the filter's overlay preview pin
class CCapPreview;      // the filter's non-overlay preview pin
class CVfwCapture;      // the filter class

// this structure contains all settings of the capture
// filter that are user settable
//
typedef struct _vfwcaptureoptions {

   UINT  uVideoID;      // id of video driver to open
   DWORD dwTimeLimit;   // stop capturing at this time???

   DWORD dwTickScale;   // frame rate rational
   DWORD dwTickRate;    // frame rate = dwRate/dwScale in ticks/sec
   DWORD usPerFrame;	// frame rate expressed in microseconds per frame
   DWORD dwLatency;	// time added for latency, in 100ns units

   UINT  nMinBuffers;   // number of buffers to use for capture
   UINT  nMaxBuffers;   // number of buffers to use for capture

   UINT  cbFormat;      // sizeof VIDEOINFO stuff
   VIDEOINFOHEADER * pvi;     // pointer to VIDEOINFOHEADER (media type)

} VFWCAPTUREOPTIONS;

#define NUM_DROPPED 100				// remember 100 of them
typedef struct _capturestats {
    DWORDLONG dwlNumDropped;
    DWORDLONG dwlDropped[NUM_DROPPED];
    DWORDLONG dwlNumCaptured;
    DWORDLONG dwlTotalBytes;
    DWORDLONG msCaptureTime;
    double     flFrameRateAchieved;
    double     flDataRateAchieved;
} CAPTURESTATS;

#if 0 // -- moved to uuids.h

DEFINE_GUID(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F);

#endif

DEFINE_GUID(IID_VfwCaptureOptions,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x20);

DECLARE_INTERFACE_(IVfwCaptureOptions,IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // IVfwCaptureOptions methods
   STDMETHOD(VfwCapSetOptions)(THIS_ const VFWCAPTUREOPTIONS * pOpt) PURE;
   STDMETHOD(VfwCapGetOptions)(THIS_ VFWCAPTUREOPTIONS * pOpt) PURE;
   STDMETHOD(VfwCapGetCaptureStats)(THIS_ CAPTURESTATS * pcs) PURE;
   STDMETHOD(VfwCapDriverDialog)(THIS_ HWND hwnd, UINT uDrvType, UINT uQuery) PURE;
};

#define STUPID_COMPILER_BUG

//
// CVfwCapture represents an video capture driver
//
//  -- IBaseFilter
//  -- IMediaFilter
//  -- ISpecifyPropertyPages
//  -- IVfwCaptureOptions
//

// UNTESTED code to make the h/w overlay pin support stream control
// (unnecessary since overlay is supposedly free)
// #define OVERLAY_SC


class CVfwCapture :
  public CBaseFilter,
  public IPersistPropertyBag,
  public IAMVfwCaptureDialogs,
  public CPersistStream,
  public IAMFilterMiscFlags
{
public:

   // constructors etc
   CVfwCapture(TCHAR *, LPUNKNOWN, HRESULT *);
   ~CVfwCapture();

   // create a new instance of this class
   static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

   // override this to say what interfaces we support where
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

   DECLARE_IUNKNOWN

public:

   // IAMVfwCaptureDialogs stuff
   STDMETHODIMP HasDialog(int iDialog);
   STDMETHODIMP ShowDialog(int iDialog, HWND hwnd);
   STDMETHODIMP SendDriverMessage(int iDialog, int uMsg, long dw1, long dw2);

   // pin enumerator calls this
   //
   int GetPinCount();
   CBasePin * GetPin(int ix);

   // override RUN so that we can pass it on to the streams
   // (the base class just calls Active/Inactive for each stream)
   //
   STDMETHODIMP Run(REFERENCE_TIME tStart);

   // override PAUSE so that we can know when we transition from RUN->PAUSE
   //
   STDMETHODIMP Pause();

   // override STOP because the base class is broken
   //
   STDMETHODIMP Stop();

   // override GetState to return VFW_S_CANT_CUE when pausing
   //
   STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

   // for IAMStreamControl
   STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
   STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

   // IPersistPropertyBag methods
   STDMETHOD(InitNew)(THIS);
   STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
   STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                   BOOL fSaveAllProperties);

   STDMETHODIMP GetClassID(CLSID *pClsid);

   // CPersistStream
   HRESULT WriteToStream(IStream *pStream);
   HRESULT ReadFromStream(IStream *pStream);
   int SizeMax();
   // STDMETHODIMP GetClassID(CLSID *pClsid);

   // IAMFilterMiscFlags to indicate that we're a source (really a push source)
   ULONG STDMETHODCALLTYPE GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_SOURCE; }

   // ---------  Nested implementation classes ----------

   class CSpecifyProp : public CUnknown, public ISpecifyPropertyPages
   {
      CVfwCapture * m_pCap;           // parent CVfwCapture class

   public:
      // constructor
      //
      CSpecifyProp (CVfwCapture * pCap, HRESULT *phr) :
	 CUnknown(NAME("SpecifyPropertyPages"), pCap->GetOwner(), phr),
         m_pCap(pCap)
         {
         };

      DECLARE_IUNKNOWN

      // ISpecifyPropertyPages methods
      //
      STDMETHODIMP GetPages(CAUUID *pPages);
   };

   class COptions : public CUnknown, public IVfwCaptureOptions
   {
      CVfwCapture * m_pCap;           // parent CVfwCapture class

   public:
      // constructor
      //
      COptions (CVfwCapture * pCap, HRESULT *phr) :
	 CUnknown(NAME("Options"), pCap->GetOwner(), phr),
         m_pCap(pCap)
         {
         };

      DECLARE_IUNKNOWN

      // these interfaces allow property pages to get
      // and set the user editable settings for us
      //
      STDMETHODIMP VfwCapSetOptions(const VFWCAPTUREOPTIONS * pOpt);
      STDMETHODIMP VfwCapGetOptions(VFWCAPTUREOPTIONS * pOpt);
      STDMETHODIMP VfwCapGetCaptureStats(CAPTURESTATS * pcs);
      STDMETHODIMP VfwCapDriverDialog(HWND hwnd, UINT uType, UINT uQuery);

   };

   // -------- End of nested interfaces -------------


private:

   // Let the nested interfaces access our private state
   //
   friend class CCapStream;
   friend class CCapOverlay;
   friend class CCapPreview;
   friend class CCapOverlayNotify;
   friend class CPropPage;
   friend class CSpecifyProp;
   friend class COptions;

   // MikeCl - a way to avoid using overlay
   BOOL m_fAvoidOverlay;

   // device # of device to open
   int m_iVideoId;

   // persist stream saved from  IPersistPropertyBag::Load
   IPersistStream *m_pPersistStreamDevice;
    
   void CreatePins(HRESULT *phr);

   // property page stuff
   //
   CSpecifyProp    m_Specify;
   COptions        m_Options;

   BOOL		   m_fDialogUp;

   CCritSec        m_lock;
   CCapStream *    m_pStream;   // video data output pin
   CCapOverlay *   m_pOverlayPin; // overlay preview pin
   CCapPreview *   m_pPreviewPin; // non-overlay preview pin
   //CTimeStream * m_pTimeA;      // SMPTE timecode stream
};

#define ALIGNUP(dw,align) ((LONG_PTR)(((LONG_PTR)(dw)+(align)-1) / (align)) * (align))

class CFrameSample : public CMediaSample
{
public:
   CFrameSample(
       IMemAllocator *pAllocator,
       HRESULT *phr,
       LPTHKVIDEOHDR ptvh)
       :
       m_ptvh(ptvh),
       CMediaSample(NAME("Video Frame"),
                    (CBaseAllocator *)pAllocator,
                    phr,
                    ptvh->vh.lpData,
                    (long)ptvh->vh.dwBufferLength)
       {
       };

   LPTHKVIDEOHDR GetFrameHeader() {return m_ptvh;};

private:
   const LPTHKVIDEOHDR m_ptvh;
};

// CCapStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CVfwCapture object and
// returned via the EnumPins interface.
//

class CCapStream : public CBaseOutputPin, public IAMStreamConfig,
		   public IAMVideoCompression, public IAMDroppedFrames,
		   public IAMBufferNegotiation, public CBaseStreamControl,
		   public IKsPropertySet, public IAMPushSource
{
public:
   CCapStream(
        TCHAR *pObjectName,
        CVfwCapture *pCapture,
        UINT iVideoId,
        HRESULT * phr,
        LPCWSTR pName);

    // ddraw stuff just so we can take the win16 lock
    LPDIRECTDRAWSURFACE m_pDrawPrimary; // DirectDraw primary surface
    IDirectDraw *m_pdd;         // ddraw object
    
   virtual ~CCapStream();

    DECLARE_IUNKNOWN

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt,
					LPBYTE pSCC);

    /* IAMVideoCompression methods */
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality) {return E_NOTIMPL;};
    STDMETHODIMP get_Quality(double FAR* pQuality) {return E_NOTIMPL;};
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;};
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize) {return E_NOTIMPL;};
    STDMETHODIMP OverrideKeyFrame(long FrameNumber) {return E_NOTIMPL;};
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size)
			{return E_NOTIMPL;};
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);

    /* IAMBufferNegotiation methods */
    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop);
    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop);


    /* IAMDroppedFrames methods */
    STDMETHODIMP GetNumDropped(long FAR* plDropped);
    STDMETHODIMP GetNumNotDropped(long FAR* plNotDropped);
    STDMETHODIMP GetDroppedInfo(long lSize, long FAR* plArray,
			long FAR* plNumCopied);
    STDMETHODIMP GetAverageFrameSize(long FAR* plAverageSize);

    // IAMPushSource
    STDMETHODIMP GetPushSourceFlags( ULONG  *pFlags );
    STDMETHODIMP SetPushSourceFlags( ULONG   Flags );
    STDMETHODIMP GetLatency( REFERENCE_TIME  *prtLatency );
    STDMETHODIMP SetStreamOffset( REFERENCE_TIME  rtOffset );
    STDMETHODIMP GetStreamOffset( REFERENCE_TIME  *prtOffset );
    STDMETHODIMP GetMaxStreamOffset( REFERENCE_TIME  *prtOffset );
    STDMETHODIMP SetMaxStreamOffset( REFERENCE_TIME  rtOffset );

    /* IKsPropertySet stuff */
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

   // expose our extra interfaces
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

   HRESULT GetMediaType(int iPosition, CMediaType* pt);

   // check if the pin can support this specific proposed type&format
   HRESULT CheckMediaType(const CMediaType*);

   // set the new mediatype to use
   HRESULT SetMediaType(const CMediaType*);

   // say how big our buffers should be and how many we want
   HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                            ALLOCATOR_PROPERTIES *pProperties);

   // override this to force our own allocator
   HRESULT DecideAllocator(IMemInputPin *pPin,
                           IMemAllocator **ppAlloc);

   // Override to start & stop streaming
   HRESULT Active();		// Stop-->Pause
   HRESULT Inactive();		// Pause-->Stop
   HRESULT ActiveRun(REFERENCE_TIME tStart);	// Pause-->Run
   HRESULT ActivePause();	// Run-->Pause

   // override to receive Notification messages
   STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

   class CAlloc : public CUnknown,
                  public IMemAllocator
      {
      private:
         CCapStream * m_pStream;     // parent stream

      protected:
         friend class CCapStream;
         ALLOCATOR_PROPERTIES parms;

      public:
          CAlloc(TCHAR *, CCapStream *, HRESULT *);
          ~CAlloc();

      DECLARE_IUNKNOWN

      STDMETHODIMP SetProperties(
  		    ALLOCATOR_PROPERTIES* pRequest,
  		    ALLOCATOR_PROPERTIES* pActual);

      // return the properties actually being used on this allocator
      STDMETHODIMP GetProperties(
  		    ALLOCATOR_PROPERTIES* pProps);

      // override Commit to allocate memory. We handle the GetBuffer
      //state changes
      STDMETHODIMP Commit();

      // override this to handle the memory freeing. We handle any outstanding
      // GetBuffer calls
      STDMETHODIMP Decommit();

      // get container for a sample. Blocking, synchronous call to get the
      // next free buffer (as represented by an IMediaSample interface).
      // on return, the time etc properties will be invalid, but the buffer
      // pointer and size will be correct. The two time parameters are
      // optional and either may be NULL, they may alternatively be set to
      // the start and end times the sample will have attached to it

      STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                             REFERENCE_TIME * pStartTime,
                             REFERENCE_TIME * pEndTime,
                             DWORD dwFlags);

      // final release of a CMediaSample will call this
      STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
      };

private:
    // methods for the helper thread
    //
    BOOL Create();
    BOOL Pause();
    BOOL Run();
    BOOL Stop();
    BOOL Destroy();

    static DWORD WINAPI ThreadProcInit(void *pv);
    DWORD ThreadProc();

    enum ThdState {TS_Not, TS_Create, TS_Init, TS_Pause, TS_Run, TS_Stop, TS_Destroy, TS_Exit};
    HANDLE   m_hThread;
    DWORD    m_tid;
    ThdState m_state;     // used to communicate state changes between worker thread and main
                          // Worker thread can make
                          //    Init->Pause, Stop->Destroy, Destroy->Exit transitions
                          // main thread(s) can make
                          //    Pause->Run, Pause->Stop, Run->Pause, Run->Stop transitions
                          // other transitions are invalid
   #ifdef DEBUG
    LPSTR StateName(ThdState state) {
       static char szState[] = "Not    \0Create \0Init   \0Pause  \0"
                               "Run    \0Stop   \0Destroy\0Exit   \0";
       if (state <= TS_Exit && state >= TS_Not)
          return szState + (int)state * 8;
       return "<Invalid>";
    };
   #endif

    void DumpState (ThdState state) ;

    ThdState ChangeState(ThdState state)
    {
        DumpState (state) ;
        return (ThdState) InterlockedExchange ((LONG *)&m_state, (LONG)state);
    } ;

    UINT *m_pBufferQueue; // what order we sent the buffers to the driver in
    UINT m_uiQueueHead;   // next buffer going to driver goes here
    UINT m_uiQueueTail;   // next buffer coming from driver is here

    HANDLE   m_hEvtPause; // Signalled when the worker is in the pause state
    HANDLE   m_hEvtRun;   // Signalled when the worker is in the run state

    BOOL ThreadExists() {return (m_hThread != NULL);};
    BOOL IsRunning() {return m_state == TS_Run;};

    // for IAMBufferNegotiation
    ALLOCATOR_PROPERTIES m_propSuggested;

    REFERENCE_TIME m_rtLatency;
    REFERENCE_TIME m_rtStreamOffset;
    REFERENCE_TIME m_rtMaxStreamOffset;

    // deal with user controllable options
    //
private:
    VFWCAPTUREOPTIONS m_user;
    HRESULT LoadOptions (void);
protected:
    CAPTURESTATS m_capstats;
public:
    HRESULT SetOptions(const VFWCAPTUREOPTIONS * pUser);
    HRESULT GetOptions(VFWCAPTUREOPTIONS * pUser);
    HRESULT DriverDialog(HWND hwnd, UINT uType, UINT uQuery);

    HRESULT Reconnect(BOOL fCapturePinToo);

private:

    // return the time of a given tick
    //
    REFERENCE_TIME TickToRefTime (DWORD nTick) {
       const DWORD dw100ns = 10 * 1000 * 1000;
       REFERENCE_TIME time =
          UInt32x32To64(dw100ns, m_user.dwTickScale)
          * nTick
          / m_user.dwTickRate;
       return time;
       };

    void ReduceScaleAndRate ();
    int ProfileInt(LPSTR pszKey, int iDefault);
    HRESULT ConnectToDriver (void);
    HRESULT DisconnectFromDriver (void);
    HRESULT InitPalette (void);
    HRESULT SendFormatToDriver(VIDEOINFOHEADER *);
    HRESULT GetFormatFromDriver (void);

    struct _cap_parms {
       // video driver stuff
       //
       HVIDEO         hVideoIn;     // video input
       HVIDEO         hVideoExtIn;  // external in (source control)
       HVIDEO         hVideoExtOut; // external out (overlay; not required)
       MMRESULT       mmr;          // open fail/success code
       BOOL           bHasOverlay;  // TRUE if ExtOut has overlay support

       // the preview buffer.  once created it persists until
       // the stream destructor because the renderer assumes
       // that it can keep a pointer to this and not crash
       // if it uses it after stopping the stream.
       // (no longer a problem)
       // !!! can we remove all this Preview still frame stuff?
       //
       UINT           cbVidHdr;       // size of a videohdr (or videohdrex)
       THKVIDEOHDR    tvhPreview;     // preview video header
       CFrameSample * pSamplePreview; // CMediaSample for preview buffer

       // video header & buffer stuff
       //
       UINT           cbBuffer;           // max size of video frame data
       UINT           nHeaders;           // number of video headers
       struct _cap_hdr {
          THKVIDEOHDR  tvh;
          } * paHdr;
       BOOL           fBuffersOnHardware; // TRUE if all video buffers are in hardware
       HANDLE         hEvtBufferDone;     // this event signalled when a buffer is ready
       DWORD_PTR      h0EvtBufferDone;    // on Win95 this is a Ring0 alias of the above event

       LONGLONG       tTick;              // duration of a single tick
       LONGLONG       llLastTick;	  // the last frame sent downstream
       DWORDLONG      dwlLastTimeCaptured;// the last driver time stamp
       DWORDLONG      dwlTimeCapturedOffset;// wraparound compensation
       UINT           uiLastAdded;	  // the last buffer AddBuffer'd
       DWORD	      dwFirstFrameOffset; // when 1st frame was captured
       LONGLONG       llFrameCountOffset; // add this to frame number
       BOOL	      fReRun;		  // went from Run->Pause->Run
       BOOL	      fLastSampleDiscarded; // due to IAMStreamControl
       CRefTime       rtThisFrameTime;  // clock time when frame was captured
       CRefTime	      rtLastStamp;	  // last frame delivered had this stamp
       CRefTime	      rtDriverStarted;	// when videoStreamStart was called
       CRefTime	      rtDriverLatency;  // how long it takes captured frame to
					// get noticed by ring 3

       } m_cs;

    // methods for capture loop
    //
    HRESULT Prepare();       // allocate resources in preparation for capture loop
    HRESULT FakePreview(BOOL); // fake a preview stream
    HRESULT Capture();       // capture loop. executes while in the run state
    HRESULT StillFrame();    // send still frame while in pause mode
    HRESULT Flush();         // flush any data in the pipe (while stopping).
    HRESULT Unprepare();     // free resources used by capture loop
    HRESULT SendFrame(LPTHKVIDEOHDR ptvh, BOOL bDiscon, BOOL bPreroll);
    BOOL    Committed() {return m_cs.paHdr != NULL;};
    HRESULT ReleaseFrame(LPTHKVIDEOHDR ptvh);

private:
   friend class CAlloc;
   friend class CVfwCapture::COptions;
   friend class CVfwCapture;
   friend class CCapOverlay;
   friend class CCapPreview;
   friend class CCapOverlayNotify;
   CAlloc        m_Alloc; // allocator
   CVfwCapture * m_pCap;  // parent
   CMediaType  * m_pmt;   // media type for this pin

#ifdef PERF
    int m_perfWhyDropped;
#endif // PERF

   CCritSec m_ReleaseLock;
};


// CCapOverlayNotify
// where the video renderer informs us of window moves/clips so we can fix
// the overlay
//
class CCapOverlayNotify : public CUnknown, public IOverlayNotify
{
    public:
        /* Constructor and destructor */
        CCapOverlayNotify(TCHAR              *pName,
                       CVfwCapture	  *pFilter,
                       LPUNKNOWN           pUnk,
                       HRESULT            *phr);
        ~CCapOverlayNotify();

        /* Unknown methods */

        DECLARE_IUNKNOWN

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
        STDMETHODIMP_(ULONG) NonDelegatingRelease();
        STDMETHODIMP_(ULONG) NonDelegatingAddRef();

        /* IOverlayNotify methods */

        STDMETHODIMP OnColorKeyChange(
            const COLORKEY *pColorKey);         // Defines new colour key

        STDMETHODIMP OnClipChange(
            const RECT *pSourceRect,            // Area of video to play
            const RECT *pDestinationRect,       // Area of video to play
            const RGNDATA *pRegionData);        // Header describing clipping

        STDMETHODIMP OnPaletteChange(
            DWORD dwColors,                     // Number of colours present
            const PALETTEENTRY *pPalette);      // Array of palette colours

        STDMETHODIMP OnPositionChange(
            const RECT *pSourceRect,            // Area of video to play with
            const RECT *pDestinationRect);      // Area video goes

    private:
        CVfwCapture *m_pFilter;

} ;


// CCapOverlay
// represents the overlay output pin that connects to the renderer
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CVfwCapture object and
// returned via the EnumPins interface.
//
class CCapOverlay : public CBaseOutputPin, public IKsPropertySet
#ifdef OVERLAY_SC
					, public CBaseStreamControl
#endif
{
public:
   CCapOverlay(
        TCHAR *pObjectName,
        CVfwCapture *pCapture,
        HRESULT * phr,
        LPCWSTR pName);

   virtual ~CCapOverlay();

    /* IKsPropertySet stuff */
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

   HRESULT GetMediaType(int iPosition, CMediaType* pt);

   // check if the pin can support this specific proposed type&format
   HRESULT CheckMediaType(const CMediaType*);

   // override this to not do anything with allocators
   HRESULT DecideAllocator(IMemInputPin *pPin,
                           IMemAllocator **ppAlloc);

   // override these to use IOverlay, not IMemInputPin
   STDMETHODIMP Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
   HRESULT BreakConnect();
   HRESULT CheckConnect(IPin *pPin);

   DECLARE_IUNKNOWN

   // expose our extra interfaces
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

#ifdef OVERLAY_SC

   STDMETHODIMP StopAt(const REFERENCE_TIME * ptStop, BOOL bBlockData, BOOL bSendExtra, DWORD dwCookie);
   STDMETHODIMP StartAt(const REFERENCE_TIME * ptStart, DWORD dwCookie);
#endif

   HRESULT Active();		// Stop-->Pause
   HRESULT Inactive();		// Pause-->Stop
   HRESULT ActiveRun(REFERENCE_TIME tStart);	// Pause-->Run
   HRESULT ActivePause();	// Run-->Pause

   // say how big our buffers should be and how many we want
   HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                            ALLOCATOR_PROPERTIES *pProperties)
   {
	return NOERROR;
   };

private:
   CVfwCapture * m_pCap;     // parent
   IOverlay    * m_pOverlay; // Overlay window on output pin
   CCapOverlayNotify m_OverlayNotify; // Notify object
   BOOL         m_bAdvise;   // Advise id
   BOOL		m_fRunning;  // am I running?
#ifdef OVERLAY_SC
   HANDLE   	m_hThread;   // thread for IAMStreamControl
   DWORD    	m_tid;
   CAMEvent     m_EventAdvise;
   DWORD_PTR    m_dwAdvise;
   REFERENCE_TIME m_rtStart, m_rtEnd;	// for IAMStreamControl
   BOOL		m_fHaveThread;
   DWORD	m_dwCookieStart, m_dwCookieStop;

   static DWORD WINAPI ThreadProcInit(void *pv);
   DWORD ThreadProc();
#endif

   friend class CVfwCapture;
   friend class CCapOverlayNotify;
};


// CCapPreview
// represents the non-overlay preview pin that connects to the renderer
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CVfwCapture object and
// returned via the EnumPins interface.
//
class CCapPreview : public CBaseOutputPin, public CBaseStreamControl,
		    public IKsPropertySet, public IAMPushSource
{
public:
   CCapPreview(
        TCHAR *pObjectName,
        CVfwCapture *pCapture,
        HRESULT * phr,
        LPCWSTR pName);

   virtual ~CCapPreview();

   DECLARE_IUNKNOWN

    /* IKsPropertySet stuff */
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

   // override this to say what interfaces we support where
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

   HRESULT GetMediaType(int iPosition, CMediaType* pt);

   // check if the pin can support this specific proposed type&format
   HRESULT CheckMediaType(const CMediaType*);

   HRESULT ActiveRun(REFERENCE_TIME tStart);	// Pause-->Run
   HRESULT ActivePause();	// Run-->Pause
   HRESULT Active();		// Stop-->Pause
   HRESULT Inactive();		// Pause-->Stop

   STDMETHODIMP Notify(IBaseFilter *pFilter, Quality q);

   // say how big our buffers should be and how many we want
   HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                            ALLOCATOR_PROPERTIES *pProperties);

   // IAMPushSource
   STDMETHODIMP GetPushSourceFlags( ULONG *pFlags );
   STDMETHODIMP SetPushSourceFlags( ULONG  Flags  );
   STDMETHODIMP GetLatency( REFERENCE_TIME  *prtLatency );
   STDMETHODIMP SetStreamOffset( REFERENCE_TIME  rtOffset );
   STDMETHODIMP GetStreamOffset( REFERENCE_TIME  *prtOffset );
   STDMETHODIMP GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset );
   STDMETHODIMP SetMaxStreamOffset( REFERENCE_TIME  rtOffset );

private:
   static DWORD WINAPI ThreadProcInit(void *pv);
   DWORD ThreadProc();
   HRESULT CapturePinActive(BOOL fActive);
   HRESULT ReceivePreviewFrame(IMediaSample * lpPrevSample, int iSize);
   HRESULT CopyPreviewFrame(LPVOID lpOutputBuffer);

   CVfwCapture * m_pCap;  // parent
   BOOL		m_fActuallyRunning; // is this filter is running state?
   BOOL		m_fThinkImRunning; // does the preview thread realize that?
   REFERENCE_TIME m_rtRun;
   HANDLE	m_hThread;
   DWORD	m_tid;
   HANDLE	m_hEventRun;
   HANDLE	m_hEventStop;
   HANDLE	m_hEventFrameValid;
   HANDLE	m_hEventActiveChanged;
   CAMEvent     m_EventAdvise;
   DWORD_PTR    m_dwAdvise;
   BOOL		m_fCapturing;	// is the streaming pin active?
   IMediaSample* m_pPreviewSample;
   int		m_iFrameSize;
   BOOL		m_fFrameValid;
   BOOL		m_fLastSampleDiscarded;	// for IAMStreamControl

   COutputQueue *m_pOutputQueue;

   REFERENCE_TIME m_rtLatency;
   REFERENCE_TIME m_rtStreamOffset;
   REFERENCE_TIME m_rtMaxStreamOffset;
   LONG m_cPreviewBuffers;

   friend class CVfwCapture;
   friend class CCapStream;
};


// this helper function creates an output pin for streaming video.
//
CCapStream * CreateStreamPin (
   CVfwCapture * pCapture,
   UINT          iVideoId,
   HRESULT    *  phr);

// this helper function creates an output pin for overlay
//
CCapOverlay * CreateOverlayPin (
   CVfwCapture * pCapture,
   HRESULT    *  phr);

// this helper function creates an output pin for non-overlay preview
//
CCapPreview * CreatePreviewPin (
   CVfwCapture * pCapture,
   HRESULT    *  phr);

// property page class to show properties of
// and object that exposes IVfwCaptureOptions
//
class CPropPage : public CBasePropertyPage
{
   IVfwCaptureOptions * m_pOpt;    // object that we are showing options from
   IPin *m_pPin;

public:

   CPropPage(TCHAR *, LPUNKNOWN, HRESULT *);

   // create a new instance of this class
   //
   static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

   HRESULT OnConnect(IUnknown *pUnknown);
   HRESULT OnDisconnect();
   INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\property.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "driver.h"

// !!! make a property page for capturing a palette that only legacy has and 
// so it won't conflict with standard property pages of other cap filters

// constructor
//
CPropPage::CPropPage (TCHAR * pszName, LPUNKNOWN punk, HRESULT *phr) :
   CBasePropertyPage(pszName, punk, IDD_PROPERTIES, IDS_NAME)
   ,m_pOpt(NULL)
   ,m_pPin(NULL)
{
   DbgLog((LOG_TRACE,1,TEXT("CPropPage constructor")));
}

// create a new instance of this class
//
CUnknown *CPropPage::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropPage(NAME("VFW Capture Property Page"),pUnk,phr);
}


HRESULT CPropPage::OnConnect(IUnknown *pUnknown)
{
    DbgLog((LOG_TRACE,2,TEXT("Getting IVfwCaptureOptions")));

    HRESULT hr = (pUnknown)->QueryInterface(IID_VfwCaptureOptions,
                                            (void **)&m_pOpt);
    if (FAILED(hr))
        return E_NOINTERFACE;

    // Now get our streaming pin's IPin... we want it in INITDIALOG
    IEnumPins *pins;
    IPin *pPin;
    IBaseFilter *pFilter;
    hr = pUnknown->QueryInterface(IID_IBaseFilter, (void **)&pFilter);
    if (FAILED(hr))
        return NOERROR;	// oh well
	
    hr = pFilter->EnumPins(&pins);
    pFilter->Release();
    if (SUCCEEDED(hr)) {
        DWORD n;
        hr = pins->Next(1, &pPin, &n);
	if (hr == S_OK) {
	    ASSERT(m_pPin == NULL);
	    m_pPin = pPin;
	}
        pins->Release();
    }
    return NOERROR;
}


HRESULT CPropPage::OnDisconnect()
{
    DbgLog((LOG_TRACE,2,TEXT("Releasing IVfwCaptureOptions")));
    if (m_pOpt)
        m_pOpt->Release();
    m_pOpt = NULL;
    if (m_pPin)
        m_pPin->Release();
    m_pPin = NULL;
    return NOERROR;
}


// Handles the messages for our property window
//
INT_PTR CPropPage::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   HRESULT hr = E_FAIL;
   const int versize = 40;
   const int descsize = 40;

   DbgLog((LOG_TRACE,99,TEXT("CPropPage::DialogProc  %08x %04x %08x %08x"),
				hwnd, uMsg, wParam, lParam));

   switch (uMsg)
      {
      case WM_INITDIALOG:

   // alpha compiler bug blows up if we don't encase this case in braces
   {

         DbgLog((LOG_TRACE,2,TEXT("Initializing the Dialog Box")));
	 CAPTURESTATS cs;
	 m_pOpt->VfwCapGetCaptureStats(&cs);
	 SetDlgItemInt(hwnd, ID_FRAMESCAPTURED, (int)cs.dwlNumCaptured, FALSE);
	 SetDlgItemInt(hwnd,ID_MSCAPTURED,(int)(cs.msCaptureTime / 1000),FALSE);
	 SetDlgItemInt(hwnd, ID_FRAMESDROPPED, (int)cs.dwlNumDropped, FALSE);
	 SetDlgItemInt(hwnd, ID_FRAMESPERSEC,(int)cs.flFrameRateAchieved,FALSE);
	 SetDlgItemInt(hwnd, ID_BYTESPERSEC, (int)cs.flDataRateAchieved, FALSE);

	 // Which dialog boxes does this driver have?
	 EnableWindow(GetDlgItem(hwnd, ID_SOURCE),
                		m_pOpt->VfwCapDriverDialog(hwnd,
				VIDEO_EXTERNALIN, VIDEO_DLG_QUERY) == 0);
	 EnableWindow(GetDlgItem(hwnd, ID_FORMAT),
                		m_pOpt->VfwCapDriverDialog(hwnd,
				VIDEO_IN, VIDEO_DLG_QUERY) == 0);
	 EnableWindow(GetDlgItem(hwnd, ID_DISPLAY),
                		m_pOpt->VfwCapDriverDialog(hwnd,
				VIDEO_EXTERNALOUT, VIDEO_DLG_QUERY) == 0);
			
	 // put the driver name in the dialog box
	 WCHAR wachVer[versize], wachDesc[descsize];
	 TCHAR tachDesc[versize + descsize + 5];
	 long lCap;
	 IAMVideoCompression *pVC;
	 if (m_pPin)
             hr = m_pPin->QueryInterface(IID_IAMVideoCompression,
								(void **)&pVC);
	 if (hr == NOERROR) {
	     LONG l1, l2;
             double l3;
	     hr = pVC->GetInfo(wachVer, (int *)&versize, wachDesc,
					(int *)&versize, &l1, &l2, &l3, &lCap);
	     if (hr == NOERROR) {
		 wsprintf(tachDesc, TEXT("%ls   %ls"), wachDesc, wachVer);
	         SetDlgItemText(hwnd, ID_DESC, tachDesc);
	     }
	     pVC->Release();
	 }

         return TRUE;
   }


      case WM_COMMAND:
         {
         UINT uID = GET_WM_COMMAND_ID(wParam,lParam);
         switch (uID)
            {
            case ID_SOURCE:
            case ID_FORMAT:
            case ID_DISPLAY:
                static UINT auType[] = {VIDEO_EXTERNALIN, VIDEO_IN,
							VIDEO_EXTERNALOUT};
                if (m_pOpt->VfwCapDriverDialog(hwnd,
				auType[uID - ID_SOURCE], FALSE) == NOERROR)
                    m_bDirty = TRUE;
                break;
            }
         }
         return TRUE;
      }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\preview.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    Methods for CCapPreview - the preview pin that doesn't use overlay

*/

#include <streams.h>
#include "driver.h"

// when the filter graph isn't using stream offsets we'll be using
// only 1 buffer, but even when it is note that we'll generally be
// using less buffers than this since the max filter graph latency 
// can be set by the app
// in default case make high enough to not block audio capture's 
// default 500ms buffers
const DWORD MAX_PREVIEW_BUFFERS = 15; 
                                      

CCapPreview * CreatePreviewPin(CVfwCapture * pCapture, HRESULT * phr)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapPreview::CreatePreviewPin(%08lX,%08lX)"),
        pCapture, phr));

   WCHAR wszPinName[16];
   lstrcpyW(wszPinName, L"Preview");

   CCapPreview * pPreview = new CCapPreview(NAME("Video Preview Stream"),
				pCapture, phr, wszPinName);
   if (!pPreview)
      *phr = E_OUTOFMEMORY;

   // if initialization failed, delete the stream array
   // and return the error
   //
   if (FAILED(*phr) && pPreview)
      delete pPreview, pPreview = NULL;

   return pPreview;
}

//#pragma warning(disable:4355)


// CCapPreview constructor
//
CCapPreview::CCapPreview(TCHAR *pObjectName, CVfwCapture *pCapture,
        HRESULT * phr, LPCWSTR pName)
   :
   CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, phr, pName),
   m_pCap(pCapture),
   m_pOutputQueue(NULL),
   m_fActuallyRunning(FALSE),
   m_fThinkImRunning(FALSE),
   m_hThread(NULL),
   m_tid(0),
   m_hEventRun(NULL),
   m_hEventStop(NULL),
   m_dwAdvise(0),
   m_fCapturing(FALSE),
   m_hEventActiveChanged(NULL),
   m_hEventFrameValid(NULL),
   m_pPreviewSample(NULL),
   m_iFrameSize(0),
   m_fLastSampleDiscarded(FALSE),
   m_fFrameValid(FALSE),
   m_rtLatency(0),
   m_rtStreamOffset(0),
   m_rtMaxStreamOffset(0),
   m_cPreviewBuffers(1)
{
   DbgLog((LOG_TRACE,1,TEXT("CCapPreview constructor")));
   ASSERT(pCapture);
}


CCapPreview::~CCapPreview()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Preview pin")));
    ASSERT(m_pOutputQueue == NULL);
};


STDMETHODIMP CCapPreview::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMStreamControl) {
	return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    } else if (riid == IID_IAMPushSource) {
        return GetInterface((LPUNKNOWN)(IAMPushSource *)this, ppv);
    } else if (riid == IID_IKsPropertySet) {
	return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv);
    }

   return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}


#if 0
// Override this because we don't want any allocator!
//
HRESULT CCapPreview::DecideAllocator(IMemInputPin * pPin,
                        IMemAllocator ** pAlloc) {
    /*  We just don't want one so everything's OK as it is */
    return S_OK;
}
#endif


HRESULT CCapPreview::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapPreview::GetMediaType #%d"), iPosition));

    // we preview the same format as we capture
    return m_pCap->m_pStream->GetMediaType(iPosition, pmt);
}


// We accept overlay connections only
//
HRESULT CCapPreview::CheckMediaType(const CMediaType *pMediaType)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapPreview::CheckMediaType")));

    // Only accept what our capture pin is providing.  I will not switch
    // our capture pin over to a new format just because somebody changes
    // the preview pin.
    CMediaType cmt;
    HRESULT hr = m_pCap->m_pStream->GetMediaType(0, &cmt);
    if (hr == S_OK && cmt == *pMediaType)
	return NOERROR;
    else
	return E_FAIL;
}


HRESULT CCapPreview::ActiveRun(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Pause->Run")));

    ASSERT(IsConnected());

    m_fActuallyRunning = TRUE;
    m_rtRun = tStart;

    // tell our thread to start previewing
    SetEvent(m_hEventRun);

    return NOERROR;
}


HRESULT CCapPreview::ActivePause()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Run->Pause")));

    m_fActuallyRunning = FALSE;
    
    return NOERROR;
}


HRESULT CCapPreview::Active()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Stop->Pause")));

    ASSERT(IsConnected());

    m_hEventRun = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventRun) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create Run event")));
        return E_OUTOFMEMORY;
    }
    m_hEventStop = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventStop) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create Stop event")));
        return E_OUTOFMEMORY;
    }

    m_hEventActiveChanged = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventActiveChanged) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create ActiveChanged event")));
        return E_OUTOFMEMORY;
    }

    m_hEventFrameValid = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventFrameValid) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create FrameValid event")));
        return E_OUTOFMEMORY;
    }

    m_EventAdvise.Reset();
    m_fFrameValid = FALSE;

    m_hThread = CreateThread(NULL, 0, CCapPreview::ThreadProcInit, this,
				0, &m_tid);
    if (!m_hThread) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create Preview thread")));
       return E_OUTOFMEMORY;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }
    //  create the queue
    ASSERT(m_pOutputQueue == NULL);
    hr = S_OK;
    m_pOutputQueue = new COutputQueue(GetConnected(), // input pin
                                      &hr,            // return code
                                      (m_cPreviewBuffers == 1) ?// auto detect as long as > 1 buffer
                                         FALSE : TRUE,          // if only 1 buffer don't create separate thread
                                      FALSE,	      // ignored for >1 buffer, else don't create thread
                                      1,              // no batching
                                      FALSE,          // not used if no batching
                                      m_cPreviewBuffers); // queue size
    if (m_pOutputQueue == NULL) {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    return hr;
}


HRESULT CCapPreview::Inactive()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Pause->Stop")));

    ASSERT(IsConnected());

    // tell our thread to give up and die
    SetEvent(m_hEventStop);
    SetEvent(m_hEventFrameValid);
    SetEvent(m_hEventActiveChanged);

    // We're waiting for an advise that will now never come
    if (m_pCap->m_pClock && m_dwAdvise) {
	m_pCap->m_pClock->Unadvise(m_dwAdvise);
	m_EventAdvise.Set();
    }

    WaitForSingleObject(m_hThread, INFINITE);

    CloseHandle(m_hThread);
    CloseHandle(m_hEventRun);
    CloseHandle(m_hEventStop);
    CloseHandle(m_hEventActiveChanged);
    CloseHandle(m_hEventFrameValid);
    m_hEventRun = NULL;
    m_hEventStop = NULL;
    m_hEventActiveChanged = NULL;
    m_hEventFrameValid = NULL;
    m_tid = 0;
    m_hThread = NULL;
    
    //CAutoLock lck(this); // necessary???
    HRESULT hr = CBaseOutputPin::Inactive();
    if( FAILED( hr ) )
    {    
        //  Incorrect state transition 
        return hr;
    }
            
    delete m_pOutputQueue;
    m_pOutputQueue = NULL;
    
    return S_OK;
}


HRESULT CCapPreview::DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pProperties)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapPreview DecideBufferSize")));

   ASSERT(pAllocator);
   ASSERT(pProperties);
   
   LONG cBuffers = 1; 
   if( m_rtMaxStreamOffset > m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame )
   {       
       cBuffers = (LONG)(m_rtMaxStreamOffset / m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame);
       cBuffers++; // align up                            
       DbgLog((LOG_TRACE,
               4,
               TEXT("buffers required for preview to cover max Graph Latency: %d"), 
               cBuffers ) );
   }   
   m_cPreviewBuffers = min( cBuffers, MAX_PREVIEW_BUFFERS );

   // !!! more preview buffers?
   if (pProperties->cBuffers < m_cPreviewBuffers)
       pProperties->cBuffers = m_cPreviewBuffers;

   if (pProperties->cbAlign == 0)
	pProperties->cbAlign = 1;

// who cares
#if 0
   // we should honour the alignment and prefix as long as they result in a
   // 4-byte aligned buffer. Note that it is the start of the prefix that
   // is aligned.

   // we want alignment of 4 bytes
   if (pProperties->cbAlign == 0)
	pProperties->cbAlign = 4;
   // they might want a different alignment
   if ((pProperties->cbAlign % 4) != 0)
      pProperties->cbAlign = ALIGNUP(pProperties->cbAlign, 4);

   // !!! cbAlign must be a power of 2, or ALIGNUP will fail - fix this
#endif

   // This is how big we need each buffer to be
   pProperties->cbBuffer = max(pProperties->cbBuffer,
		(long)(m_pCap->m_pStream->m_user.pvi ?
		m_pCap->m_pStream->m_user.pvi->bmiHeader.biSizeImage : 4096));
   // Make the prefix + buffer size meet the alignment restriction
   pProperties->cbBuffer = (long)ALIGNUP(pProperties->cbBuffer +
				pProperties->cbPrefix, pProperties->cbAlign) -
				pProperties->cbPrefix;

   ASSERT(pProperties->cbBuffer);

   DbgLog((LOG_TRACE,2,TEXT("Preview: %d buffers, prefix %d size %d align %d"),
			pProperties->cBuffers, pProperties->cbPrefix,
			pProperties->cbBuffer,
			pProperties->cbAlign));

   // assume that our latency will be 1 frame ??
   m_rtLatency = m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame;
   m_rtStreamOffset = 0;   
   DbgLog((LOG_TRACE,4,TEXT("Max stream offset for preview pin is %dms"), (LONG) (m_rtMaxStreamOffset/10000) ) );

   ALLOCATOR_PROPERTIES Actual;
   return pAllocator->SetProperties(pProperties,&Actual);

   // !!! Are we sure we'll be happy with this?

}



HRESULT CCapPreview::Notify(IBaseFilter *pFilter, Quality q)
{
    return NOERROR;
}


// The streaming pin is active ==> We can't call any video APIs anymore
// The streaming pin is inactive ==> We can
HRESULT CCapPreview::CapturePinActive(BOOL fActive)
{
    DbgLog((LOG_TRACE,2,TEXT("Capture pin says Active=%d"), fActive));

    if (fActive == m_fCapturing)
	return S_OK;
    m_fCapturing = fActive;

    // stop thread from waiting for us to send a valid frame - no more to come
    if (!fActive)
        SetEvent(m_hEventFrameValid);

    // Wait until the worker thread notices the difference - it will only set
    // this event if m_fThinkImRunning is set
    if (m_fThinkImRunning)
        WaitForSingleObject(m_hEventActiveChanged, INFINITE);

    ResetEvent(m_hEventActiveChanged);

    return S_OK;
}


// The streaming pin is sending us a frame to preview
HRESULT CCapPreview::ReceivePreviewFrame(IMediaSample* pSample, int iSize)
{
    // I'm not the least bit interested in previewing right now, or
    // we haven't used the last one yet, or we don't have a place to put it
    if (!m_fActuallyRunning || m_fFrameValid || m_pPreviewSample) {
        //DbgLog((LOG_TRACE,4,TEXT("Not interested")));
        return S_OK;
    }
    
    DbgLog((LOG_TRACE,4,TEXT("Capture pin is giving us a preview frame")));

    //
    // The preview thread won't try to get an output buffer for preview until
    // we signal that we've got one ready. We need to addref this buffer to 
    // ensure it's kept around until the preview thread has gotten a buffer
    // to put it into.
    //
    
    // any previous buffer should've been released otherwise
    // not true, this could fire occasionally if GetDeliveryBuffer fails for example.
    //ASSERT( NULL == m_pPreviewSample );
    
    // take a hold on this one until the preview thread's ready to copy it (and done)
    ULONG ulRef = pSample->AddRef();
    // something scary that I noticed: occasionally the refcount on this sample was 0 when we got it
    // it seems to happen only when the Stop/Inactive/Destroy path occurred on the CCapStream thread
    if( 2 > ulRef )
        DbgLog((LOG_TRACE,2,TEXT("CCapPreview ReceivePrevewFrame UNEXPECTED pSample->AddRef returned %d"), ulRef));
    
    // now save a pointer to this sample since we'll need it once we've gotten 
    // a buffer to put it in
    m_pPreviewSample = pSample;

    // cache the sample size
    m_iFrameSize = iSize;
    
    m_fFrameValid = TRUE;
    
    // signal that we've got a frame ready to preview
    SetEvent(m_hEventFrameValid);
    return S_OK;
}

// This is where we actually copy the preview frame into the output buffer
HRESULT CCapPreview::CopyPreviewFrame(LPVOID lpOutputBuff)
{
    ASSERT( m_pPreviewSample ); // shouldn't have gotten here otherwise!
    ASSERT( m_fFrameValid );    // ditto
    ASSERT( lpOutputBuff );
    
    // !!! can't avoid mem copy without using our own allocator
    // !!! we do this copy memory even if preview pin is OFF (IAMStreamControl)
    // because we can't risk blocking this call by calling CheckStreamState
    LPBYTE lp;
    HRESULT hr = m_pPreviewSample->GetPointer(&lp);
    if( SUCCEEDED( hr ) )
    {    
        CopyMemory(lpOutputBuff, lp, m_iFrameSize);
    }
    
    // we're done with the preview sample so release it for re-use    
    m_pPreviewSample->Release();
    m_pPreviewSample = NULL; 
    
    // should we just make void return instead?    
    return hr;
}

DWORD WINAPI CCapPreview::ThreadProcInit(void *pv)
{
    CCapPreview *pThis = (CCapPreview *)pv;
    return pThis->ThreadProc();
}


DWORD CCapPreview::ThreadProc()
{
    IMediaSample *pSample;
    CRefTime rtStart, rtEnd;
    REFERENCE_TIME rtOffsetStart, rtOffsetEnd;
    DWORD dw;
    HVIDEO hVideoIn;
    HRESULT hr;
    THKVIDEOHDR tvh;
    BOOL fCaptureActive = m_fCapturing;
    int iWait;
    HANDLE hWait[2] = {m_hEventFrameValid, m_hEventStop};
    HANDLE hWaitRunStop[2] = {m_hEventRun, m_hEventStop};

    DbgLog((LOG_TRACE,2,TEXT("CCapPreview ThreadProc")));

    // the capture pin created this when he was created
    hVideoIn = m_pCap->m_pStream->m_cs.hVideoIn;

    hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);
    if (hr != NOERROR)
	return 0;
    ZeroMemory (&tvh, sizeof(tvh));
    tvh.vh.dwBufferLength = pSample->GetSize();
    pSample->Release();

    // !!! Is this safe when capture pin is streaming?
    dw = vidxAllocPreviewBuffer(hVideoIn, (LPVOID *)&tvh.vh.lpData,
                                    sizeof(tvh.vh), tvh.vh.dwBufferLength);
    if (dw) {
        DbgLog((LOG_ERROR,1,TEXT("*** CAN'T MAKE PREVIEW BUFFER!")));
        return 0;
    }
    tvh.p32Buff = tvh.vh.lpData;

    // Send preview frames as long as we're running.  Die when not streaming
    while (1) {

        // only preview while running
        iWait = WAIT_OBJECT_0;
        if (!m_fActuallyRunning) {
       	    DbgLog((LOG_TRACE,3,TEXT("Preview thread waiting for RUN/STOP")));
	        iWait = WaitForMultipleObjects(2, hWaitRunStop, FALSE, INFINITE);
       	    DbgLog((LOG_TRACE,3,TEXT("Preview thread got RUN/STOP")));
        }
        ResetEvent(m_hEventRun);

        // if we stopped instead of ran
        if (iWait != WAIT_OBJECT_0)
	        break;

        while (m_fActuallyRunning) {

            m_fThinkImRunning = TRUE;   // we now know we're running
           
            if (m_fCapturing != fCaptureActive) {
                DbgLog((LOG_TRACE,3,TEXT("Preview thread noticed Active=%d"),
                        m_fCapturing));
                SetEvent(m_hEventActiveChanged);
                fCaptureActive = m_fCapturing;
            }
               
            if (fCaptureActive) {
                DbgLog((LOG_TRACE,4,TEXT("PREVIEW using streaming pic")));

                // m_hEventFrameValid, m_hEventStop
                iWait = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

                // time for our thread to die - don't reset the event because
                // we may need it to fire when we break out of this loop
                if (iWait != WAIT_OBJECT_0 ) {
                    DbgLog((LOG_TRACE,2,TEXT("Wait for streaming pic abort1")));
                    continue;
                }

                // the streaming pin stopped being active... switch again
                if (!m_fFrameValid) {
                    DbgLog((LOG_TRACE,2,TEXT("Wait for streaming pic abort2")));
                    ResetEvent(m_hEventFrameValid);
                    
                    // can we be here with an addref'd preview sample? 
                    if( m_pPreviewSample )
                    {            
                        m_pPreviewSample->Release();
                        m_pPreviewSample = NULL;
                    }                
                    continue;
                }
                //
                // !!
                // Remember if we get here we've got an addref'd m_pPreviewSample and
                // we must release it ourselves if we hit a failure and don't explicitly 
                // call CopyPreviewFrame (which does release the sample)
                //
            }
            // now get a delivery buffer           
            // (don't call WaitForMultipleObjects while we're holding the sample!)
            hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);
            if (FAILED(hr))
            {            
                if( m_pPreviewSample )
                {            
                    m_pPreviewSample->Release();
                    m_pPreviewSample = NULL;
                }                
                break;
            }            
            PBYTE lpFrame;    
            hr = pSample->GetPointer((LPBYTE *)&lpFrame);
            if (FAILED(hr))
            {            
                if( m_pPreviewSample )
                {            
                    m_pPreviewSample->Release();
                    m_pPreviewSample = NULL;
                }                
                break; 
            }  
             
            if (fCaptureActive) {
                // we must have a preview frame ready to copy
                DbgLog((LOG_TRACE,4,TEXT("PREVIEW using streaming pic - copying preview frame")));

                // Note: this will release the sample as well
                hr = CopyPreviewFrame(lpFrame); 
                if( FAILED( hr ) )
                {                
                    if( m_pPreviewSample )
                    {            
                        m_pPreviewSample->Release();
                        m_pPreviewSample = NULL;
                    }
                    break;
                }
                        
                pSample->SetActualDataLength(m_iFrameSize);
            
                // it's now ok to grab another
                ResetEvent(m_hEventFrameValid);
    	
                // done with the current preview frame
                m_fFrameValid = FALSE;
        
            } else {
                DbgLog((LOG_TRACE,4,TEXT("PREVIEW using vidxFrame")));
                dw = vidxFrame(hVideoIn, &tvh.vh);
                if (dw == 0) {
                    // !!! Inefficient unless we use our own allocator
                    // !!! Even if pin is OFF, we still do this
                    CopyMemory(lpFrame, tvh.vh.lpData, tvh.vh.dwBytesUsed);
                } else {
                    pSample->Release();
                    DbgLog((LOG_ERROR,1,TEXT("*Can't capture still frame!")));
                    break;
                }
                pSample->SetActualDataLength(tvh.vh.dwBytesUsed);
            }
            if (m_pCap->m_pClock) {
                m_pCap->m_pClock->GetTime((REFERENCE_TIME *)&rtStart);
                rtStart = rtStart - m_pCap->m_tStart;
                // ask Danny why this driver latency isn't accounted for
                // on preview pin timestamp??
                //      - m_pCap->m_pStream->m_cs.rtDriverLatency;
                // (add stream offset to start and end times in SetTime)
                rtEnd= rtStart + m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame;
                // !!! NO TIME STAMPS for preview unless we know the latency
                // of the graph... we could drop every frame needlessly!
                // We only send another preview frame when this one is done,
                // so we won't get a backup if decoding is slow.
                // Actually, adding a latency time would still be broken
                // if the latency was > 1 frame length, because the renderer
                // would hold on to the sample until past the time for the
                // next frame, and we wouldn't send out the next preview frame
                // as soon as we should, and our preview frame rate would suffer
                //     But besides all that, we really need time stamps for
                // the stream control stuff to work, so we'll have to live
                // with preview frame rates being inferior if we have an
                // oustanding stream control request.
                AM_STREAM_INFO am;
                GetInfo(&am);
                if ( m_rtStreamOffset == 0 )
                {
                    // no offset needed, use old code
                    if ( am.dwFlags & AM_STREAM_INFO_START_DEFINED ||
                         am.dwFlags & AM_STREAM_INFO_STOP_DEFINED) {
                        //DbgLog((LOG_TRACE,0,TEXT("TIME STAMPING ANYWAY")));
                        pSample->SetTime((REFERENCE_TIME *)&rtStart,
					                     (REFERENCE_TIME *)&rtEnd);
                    }                        
                }
                else
                {
                    // this is hacky, but since stream control will block we can't give it
                    // sample times which use the stream offset.
                    // Since CheckStreamState takes a sample but only needs the start and
                    // end times for it we need to call SetTime on the sample twice, once
                    // for stream control (without the offset) and again before we deliver
                    // (with the offset).
                    pSample->SetTime( (REFERENCE_TIME *) &rtStart 
                                    , (REFERENCE_TIME *) &rtEnd );
                }
            }

		    int iStreamState = CheckStreamState(pSample);
            pSample->SetDiscontinuity(FALSE);
                
            if( iStreamState != STREAM_FLOWING ) 
            {
                DbgLog((LOG_TRACE,4,TEXT("*PREVIEW Discarding frame at %d"),
							(int)rtStart));
                m_fLastSampleDiscarded = TRUE;

                // release the sample ourselves since it won't be given to the output queue
                pSample->Release();
            }
            else
            {        
                DbgLog((LOG_TRACE,4,TEXT("*PREV Sending frame at %d"), (LONG)(rtStart/10000)));
                if (m_fLastSampleDiscarded)
                    pSample->SetDiscontinuity(TRUE);
                
                if( 0 < m_rtStreamOffset )
                {
                    // we need to offset the sample time, so add the offset in
                    // now that we're about to deliver
                    rtOffsetStart = rtStart + m_rtStreamOffset;
                    rtOffsetEnd = rtEnd + m_rtStreamOffset;
                    pSample->SetTime( (REFERENCE_TIME *) &rtOffsetStart
                                    , (REFERENCE_TIME *) &rtOffsetEnd );
                }                                
                pSample->SetSyncPoint(TRUE);	// I don't know for sure
                pSample->SetPreroll(FALSE);
                DbgLog((LOG_TRACE,4,TEXT("*Delivering a preview frame")));
                m_pOutputQueue->Receive(pSample);
            }
            
            // if previewing ourself, wait for time till next frame
            // !!! streaming pin may wait on this to become active
            if (!fCaptureActive && m_pCap->m_pClock) {
                hr = m_pCap->m_pClock->AdviseTime(
                                        m_rtRun, 
                                        rtEnd, // remember, this isn't offset
                                        (HEVENT)(HANDLE) m_EventAdvise, 
                                        &m_dwAdvise);
                if (SUCCEEDED(hr)) {
                    m_EventAdvise.Wait();
                }
                m_dwAdvise = 0;
            }
        }

        m_fThinkImRunning = FALSE;

        // make sure it wasn't set again if we didn't notice a run->pause->run
        // transition
        ResetEvent(m_hEventRun);

        SetEvent(m_hEventActiveChanged);
    }

    vidxFreePreviewBuffer(hVideoIn, (LPVOID *)&tvh.vh.lpData);

    DbgLog((LOG_TRACE,2,TEXT("CCapPreview ThreadProc is dead")));
    return 0;
}

// IAMPushSource
HRESULT CCapPreview::GetPushSourceFlags( ULONG  *pFlags )
{
    *pFlags = 0 ; // we timestamp with graph clock, the default
    return S_OK;
}    

HRESULT CCapPreview::SetPushSourceFlags( ULONG  Flags )
{
    // changing mode not supported
    return E_FAIL;
}    

HRESULT CCapPreview::GetLatency( REFERENCE_TIME  *prtLatency )
{
    *prtLatency = m_rtLatency;
    return S_OK;
}    

HRESULT CCapPreview::SetStreamOffset( REFERENCE_TIME  rtOffset )
{
    HRESULT hr = S_OK;
    //
    // if someone attempts to set an offset larger then our max 
    // assert in debug for the moment...
    //
    // it may be ok to set a larger offset than we know we can handle, if
    // there's sufficient downstream buffering. but we'll return S_FALSE
    // in that case to warn the user that they need to handle this themselves.
    //
    ASSERT( rtOffset <= m_rtMaxStreamOffset );
    if( rtOffset > m_rtMaxStreamOffset )
    {    
        DbgLog( ( LOG_TRACE
              , 1
              , TEXT("CCapPreview::SetStreamOffset trying to set offset of %dms when limit is %dms") 
              , rtOffset
              , m_rtMaxStreamOffset ) );
        hr = S_FALSE;
        // but set it anyway
    }
    m_rtStreamOffset = rtOffset;
    
    return hr;
}

HRESULT CCapPreview::GetStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtStreamOffset;
    return S_OK;
}

HRESULT CCapPreview::GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset )
{
    *prtMaxOffset = m_rtMaxStreamOffset;
    return S_OK;
}

HRESULT CCapPreview::SetMaxStreamOffset( REFERENCE_TIME  rtOffset )
{
    m_rtMaxStreamOffset = rtOffset;
    return S_OK;
}

//
// PIN CATEGORIES - let the world know that we are a PREVIEW pin
//

HRESULT CCapPreview::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CCapPreview::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
	return E_POINTER;

    if (pcbReturned)
	*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
	return S_OK;

    if (cbPropData < sizeof(GUID))
	return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_PREVIEW;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CCapPreview::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
	*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\overlay.cpp ===
// !!! Paint black in window when not running, please

// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    Methods for CCapOverlay, CCapOverlayNotify

*/

#include <streams.h>
#include "driver.h"

CCapOverlay * CreateOverlayPin(CVfwCapture * pCapture, HRESULT * phr)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapOverlay::CreateOverlayPin(%08lX,%08lX)"),
        pCapture, phr));

   WCHAR wszPinName[16];
   lstrcpyW(wszPinName, L"Preview");

   CCapOverlay * pOverlay = new CCapOverlay(NAME("Video Overlay Stream"),
				pCapture, phr, wszPinName);
   if (!pOverlay)
      *phr = E_OUTOFMEMORY;

   // if initialization failed, delete the stream array
   // and return the error
   //
   if (FAILED(*phr) && pOverlay)
      delete pOverlay, pOverlay = NULL;

   return pOverlay;
}

//#pragma warning(disable:4355)


// CCapOverlay constructor
//
CCapOverlay::CCapOverlay(TCHAR *pObjectName, CVfwCapture *pCapture,
        HRESULT * phr, LPCWSTR pName)
   :
   CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, phr, pName),
   m_OverlayNotify(NAME("Overlay notification interface"), pCapture, NULL, phr),
   m_pCap(pCapture),
   m_fRunning(FALSE)
#ifdef OVERLAY_SC
   ,m_hThread(NULL),
   m_tid(0),
   m_dwAdvise(0),
   m_rtStart(0),
   m_rtEnd(0),
   m_fHaveThread(FALSE)
#endif
{
   DbgLog((LOG_TRACE,1,TEXT("CCapOverlay constructor")));
   ASSERT(pCapture);
}


CCapOverlay::~CCapOverlay()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Overlay pin")));
};


// Say if we're prepared to connect to a given input pin from
// this output pin
//
STDMETHODIMP CCapOverlay::Connect(IPin *pReceivePin,
                                        const AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::Connect")));

    /*  Call the base class to make sure the directions match! */
    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt);
    if (FAILED(hr)) {
        return hr;
    }
    /*  We're happy if we can get an IOverlay interface */

    hr = pReceivePin->QueryInterface(IID_IOverlay,
                                     (void **)&m_pOverlay);

    // we were promised this would work
    ASSERT(SUCCEEDED(hr));

    /*  Because we're not going to get called again - except to
        propose a media type - we set up a callback here.

        There's only one overlay pin so we don't need any context.
    */

    hr = m_pOverlay->Advise(&m_OverlayNotify,
                            ADVISE_CLIPPING | ADVISE_POSITION);

    /*
        We don't need to hold on to the IOverlay pointer
        because BreakConnect will be called before the receiving
        pin goes away.
    */


    if (FAILED(hr)) {
	// !!! Shouldn't happen, but this isn't quite right
        Disconnect();
	pReceivePin->Disconnect();
        return hr;
    } else {
        m_bAdvise = TRUE;
    }

    return hr;
}


STDMETHODIMP CCapOverlay::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    DbgLog((LOG_TRACE,99,TEXT("CCapOverlay::NonDelegatingQueryInterface")));
    if (ppv)
	*ppv = NULL;

    /* Do we have this interface */

    if (riid == IID_IKsPropertySet) {
        return GetInterface((LPUNKNOWN) (IKsPropertySet *) this, ppv);
#ifdef OVERLAY_SC
    } else if (riid == IID_IAMStreamControl) {
        return GetInterface((LPUNKNOWN) (IAMStreamControl *) this, ppv);
#endif
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


#ifdef OVERLAY_SC

// overidden because we aren't an IMemInputPin... we have no delivering
// to do to notice when to start and stop.  We need a thread. Ick. Fun.
STDMETHODIMP CCapOverlay::StopAt(const REFERENCE_TIME * ptStop, BOOL bBlockData, DWORD dwCookie)
{
    REFERENCE_TIME rt;

    CAutoLock cObjectLock(m_pCap->m_pLock);

    // we must be connected and running
    if (!IsConnected() || m_pCap->m_State != State_Running)
	return E_UNEXPECTED;

    // we are stopped!
    if (!m_fRunning)
	return NOERROR;

    // Stop now.  That's easy enough
    if (ptStop == NULL) {
	ActivePause();
	return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
    }
	
    // can't do this without a clock
    if (m_pCap->m_pClock == NULL)
	return E_FAIL;

    // cancel the stop
    if (*ptStop == MAX_TIME) {
	if (m_rtEnd > 0) {
	    m_rtEnd = 0;
	    if (m_dwAdvise) {
	        m_pCap->m_pClock->Unadvise(m_dwAdvise);
		m_EventAdvise.Set();
	    }
 	}
	return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
    }

    m_pCap->m_pClock->GetTime(&rt);
    // Stop in the past.  That's easy enough. Stop now.
    if (*ptStop <= rt) {
	ActivePause();
	return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
    }

    // stop in the future.  That's tricky.  We need a thread to notice
    // "when's later, Daddy?"

    m_rtEnd = *ptStop;	// DO THIS BEFORE m_fHaveThread test or thread 
    			// could die after we think it's staying around
    m_dwCookieStop = dwCookie;

    // we need a new thread
    if (m_fHaveThread == FALSE) {
	// we made one before that we haven't closed
	if (m_hThread) {
    	    WaitForSingleObject(m_hThread, INFINITE);
    	    CloseHandle(m_hThread);
	    m_hThread = NULL;
	    m_tid = 0;
	}
	m_EventAdvise.Reset();
	m_fHaveThread = TRUE;
	m_hThread = CreateThread(NULL, 0, CCapOverlay::ThreadProcInit, this,
				0, &m_tid);
        if (!m_hThread) {
            DbgLog((LOG_ERROR,1,TEXT("Can't create Overlay thread")));
           return E_OUTOFMEMORY;
        }
    }
    return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
}


STDMETHODIMP CCapOverlay::StartAt(const REFERENCE_TIME * ptStart, DWORD dwCookie)
{
    REFERENCE_TIME rt;

    CAutoLock cObjectLock(m_pCap->m_pLock);

    // we must be connected and running
    if (!IsConnected() || m_pCap->m_State != State_Running)
	return E_UNEXPECTED;

    // we are running!
    if (m_fRunning)
	return NOERROR;

    // Start now.  That's easy enough
    if (ptStart == NULL) {
	ActiveRun(0);
	return CBaseStreamControl::StartAt(ptStart, dwCookie);
    }
	
    // can't do this without a clock
    if (m_pCap->m_pClock == NULL)
	return E_FAIL;

    // cancel the start
    if (*ptStart == MAX_TIME) {
	if (m_rtStart > 0) {
	    m_rtStart = 0;
	    if (m_dwAdvise) {
	        m_pCap->m_pClock->Unadvise(m_dwAdvise);
		m_EventAdvise.Set();
	    }
 	}
	return CBaseStreamControl::StartAt(ptStart, dwCookie);
    }

    m_pCap->m_pClock->GetTime(&rt);
    // Start in the past.  That's easy enough. Start now.
    if (*ptStart <= rt) {
	ActiveRun(0);
	return CBaseStreamControl::StartAt(ptStart, dwCookie);
    }

    // start in the future.  That's tricky.  We need a thread to notice
    // "when's later, Daddy?"

    m_rtStart = *ptStart;// DO THIS BEFORE m_fHaveThread test or thread 
    			 // could die after we think it's staying around
    m_dwCookieStart = dwCookie;

    // we need a new thread
    if (m_fHaveThread == FALSE) {
	// we made one before that we haven't closed
	if (m_hThread) {
    	    WaitForSingleObject(m_hThread, INFINITE);
    	    CloseHandle(m_hThread);
	    m_hThread = NULL;
	    m_tid = 0;
	}
	m_EventAdvise.Reset();
	m_fHaveThread = TRUE;
	m_hThread = CreateThread(NULL, 0, CCapOverlay::ThreadProcInit, this,
				0, &m_tid);
        if (!m_hThread) {
            DbgLog((LOG_ERROR,1,TEXT("Can't create Overlay thread")));
           return E_OUTOFMEMORY;
        }
    }
    return CBaseStreamControl::StartAt(ptStart, dwCookie);
}
#endif	// OVERLAY_SC


// !!! The base classes change all the time and I won't pick up their bug fixes!
//
HRESULT CCapOverlay::BreakConnect()
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::BreakConnect")));

    if (m_pOverlay != NULL) {
        if (m_bAdvise) {
            m_pOverlay->Unadvise();
            m_bAdvise = FALSE;
        }
        m_pOverlay->Release();
        m_pOverlay = NULL;
    }

#if 0
    // we've broken our connection, so next time we reconnect don't allow
    // repainting until we've actually drawn something in the first place
    m_pFilter->m_fOKToRepaint = FALSE;
#endif

    return CBaseOutputPin::BreakConnect();
}


// Override this because we don't want any allocator!
//
HRESULT CCapOverlay::DecideAllocator(IMemInputPin * pPin,
                        IMemAllocator ** pAlloc) {
    /*  We just don't want one so everything's OK as it is */
    return S_OK;
}


HRESULT CCapOverlay::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("NULL format, no can do")));
	return E_INVALIDARG;
    }
	
    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    // We provide a media type of OVERLAY with an 8 bit format (silly
    // renderer won't accept it if we don't set up an 8 bit format)

    BYTE aFormat[sizeof(VIDEOINFOHEADER) + SIZE_PALETTE];
    VIDEOINFOHEADER *pFormat = (VIDEOINFOHEADER *)aFormat;
    ZeroMemory(pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE);

    pFormat->bmiHeader.biWidth =
			m_pCap->m_pStream->m_user.pvi->bmiHeader.biWidth;
    pFormat->bmiHeader.biHeight =
			m_pCap->m_pStream->m_user.pvi->bmiHeader.biHeight;

// we don't work with funny rectangles. Sorry
#if 0
    // I bet the renderer ignores these rectangles and I'll need to call
    // IBasicVideo::put_Source* and ::put_Destination* instead
    // The idea is to make OnClipChange's source and target match these numbers
    pFormat->rcSource = m_pCap->m_pStream->m_user.pvi->rcSource;
    pFormat->rcTarget = m_pCap->m_pStream->m_user.pvi->rcTarget;
#endif

    pFormat->bmiHeader.biSize   = sizeof(BITMAPINFOHEADER);
    pFormat->bmiHeader.biPlanes = 1;
    pFormat->bmiHeader.biBitCount = 8;

    pmt->SetFormat((PBYTE)pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE);
    pmt->SetFormatType(&FORMAT_VideoInfo);

    if (pmt->pbFormat == NULL) {
        return E_OUTOFMEMORY;
    }

    pmt->majortype = MEDIATYPE_Video;
    pmt->subtype   = MEDIASUBTYPE_Overlay;
    pmt->bFixedSizeSamples    = FALSE;
    pmt->bTemporalCompression = FALSE;	
    pmt->lSampleSize          = 0;

    return NOERROR;
}


// We accept overlay connections only
//
HRESULT CCapOverlay::CheckMediaType(const CMediaType *pMediaType)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::CheckMediaType")));
    if (pMediaType->subtype == MEDIASUBTYPE_Overlay)
        return NOERROR;
    else
	return E_FAIL;
}


// Don't insist on IMemInputPin
//
HRESULT CCapOverlay::CheckConnect(IPin *pPin)
{
    // we don't connect to anyone who doesn't support IOverlay.
    // after all, we're an overlay pin
    HRESULT hr = pPin->QueryInterface(IID_IOverlay, (void **)&m_pOverlay);

    if (FAILED(hr)) {
        return E_NOINTERFACE;
    } else {
	m_pOverlay->Release();
	m_pOverlay = NULL;
    }

    return CBasePin::CheckConnect(pPin);
}


HRESULT CCapOverlay::Active()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Stop->Pause")));

    videoStreamInit(m_pCap->m_pStream->m_cs.hVideoExtOut, 0, 0, 0, 0);

    // don't let the base class Active() get called for non-IMemInput pins
    return NOERROR;
}


HRESULT CCapOverlay::Inactive()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Pause->Stop")));

    // turn off overlay
    videoStreamFini(m_pCap->m_pStream->m_cs.hVideoExtOut);

#ifdef OVERLAY_SC
    CAutoLock cObjectLock(m_pCap->m_pLock);

    // kill our thread
    m_rtStart = 0; 
    m_rtEnd = 0;
    if (m_pCap->m_pClock && m_dwAdvise) {
        m_pCap->m_pClock->Unadvise(m_dwAdvise);
	m_EventAdvise.Set();
    }

    // we haven't properly shut down our thread yet
    if (m_hThread) {
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_tid = 0;
        m_hThread = NULL;
    }
#endif

    return NOERROR;
}


HRESULT CCapOverlay::ActiveRun(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Pause->Run")));

    ASSERT(m_pCap->m_pOverlayPin->IsConnected());

    m_fRunning = TRUE;

    HVIDEO hVideoExtOut = m_pCap->m_pStream->m_cs.hVideoExtOut;
    if (hVideoExtOut == NULL || m_pOverlay == NULL)
	return NOERROR;

    HWND hwnd;
    HDC  hdc;
    m_pOverlay->GetWindowHandle(&hwnd);
    if (hwnd)
	hdc = GetDC(hwnd);
    if (hwnd == NULL || hdc == NULL)
	return NOERROR;

    RECT rcSrc, rcDst;
    rcSrc.left = 0; rcSrc.top = 0;
    rcSrc.right = HEADER(m_mt.Format())->biWidth;
    rcSrc.bottom = HEADER(m_mt.Format())->biHeight;
    GetClientRect (hwnd, &rcDst);
    ClientToScreen(hwnd, (LPPOINT)&rcDst);
    ClientToScreen(hwnd, (LPPOINT)&rcDst + 1);

    DbgLog((LOG_TRACE,2,TEXT("Starting overlay (%d,%d) to (%d,%d)"),
		rcSrc.right, rcSrc.bottom, rcDst.right - rcDst.left,
		rcDst.bottom - rcDst.top));

    // turn overlay on
    vidxSetRect(m_pCap->m_pStream->m_cs.hVideoExtOut, DVM_SRC_RECT,
		rcSrc.left, rcSrc.top, rcSrc.right, rcSrc.bottom);
    vidxSetRect(m_pCap->m_pStream->m_cs.hVideoExtOut, DVM_DST_RECT,
		rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
    // INIT now done in PAUSE
    videoUpdate(m_pCap->m_pStream->m_cs.hVideoExtOut, hwnd, hdc);

    ReleaseDC(hwnd, hdc);
    return NOERROR;
}


HRESULT CCapOverlay::ActivePause()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Run->Pause")));

    DbgLog((LOG_TRACE,2,TEXT("Turning OVERLAY off")));

    m_fRunning = FALSE;

    return NOERROR;
}


#if 0
// Return the IOverlay interface we are using (AddRef'd)
//
IOverlay *CCapOverlay::GetOverlayInterface()
{
    if (m_pOverlay) {
        m_pOverlay->AddRef();
    }
    return m_pOverlay;
}
#endif



#ifdef OVERLAY_SC
DWORD WINAPI CCapOverlay::ThreadProcInit(void *pv)
{
    CCapOverlay *pThis = (CCapOverlay *)pv;
    return pThis->ThreadProc();
}


DWORD CCapOverlay::ThreadProc()
{
    DbgLog((LOG_TRACE,2,TEXT("Starting CCapOverlay ThreadProc")));

    REFERENCE_TIME rt;
    HRESULT hr;

    // protect from other people dicking with m_rtStart and m_rtEnd
    m_pCap->m_pLock->Lock();

    while (m_rtStart > 0 || m_rtEnd > 0) {

	rt = m_rtStart;
	if (m_rtEnd < rt)
	    rt = m_rtEnd;


        hr = m_pCap->m_pClock->AdviseTime(
		// this was the reference time when our stream started playing
            	(REFERENCE_TIME) m_pCap->m_tStart,
		// this is the offset from our start time when we want to
		// wake up.
            	(REFERENCE_TIME) rt,
            	(HEVENT)(HANDLE) m_EventAdvise,		// event to fire
            	&m_dwAdvise);                       	// Advise cookie

        m_pCap->m_pLock->Unlock();

        if (SUCCEEDED(hr)) {
	    m_EventAdvise.Wait();
        } else {
	    DbgLog((LOG_TRACE,1,TEXT("AdviseTime ERROR, doing it now")));
        }

        m_pCap->m_pLock->Lock();

        m_dwAdvise = 0;
	m_pCap->m_pClock->GetTime(&rt);
	if (m_rtStart < rt) {
	    m_rtStart = 0;
	    ActiveRun(0);
	}
	if (m_rtEnd < rt) {
	    m_rtEnd = 0;
	    ActivePause();
	}
    }


    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay ThreadProc is dead")));

    // somebody needs to kill me officially later
    m_fHaveThread = FALSE;

    m_pCap->m_pLock->Unlock();
    return 0;
}
#endif	// OVERLAY_SC



//=========================================================================//
//***			I N T E R M I S S I O N				***//
//=========================================================================//




/*
        IOverlayNotify
*/

CCapOverlayNotify::CCapOverlayNotify(TCHAR              * pName,
                               CVfwCapture 	  * pFilter,
                               LPUNKNOWN            pUnk,
                               HRESULT            * phr) :
    CUnknown(pName, pUnk)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating CCapOverlayNotify")));
    m_pFilter = pFilter;
}


CCapOverlayNotify::~CCapOverlayNotify()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying CCapOverlayNotify")));
}


STDMETHODIMP CCapOverlayNotify::NonDelegatingQueryInterface(REFIID riid,
                                                         void ** ppv)
{
    DbgLog((LOG_TRACE,99,TEXT("CCapOverlayNotify::QueryInterface")));
    if (ppv)
	*ppv = NULL;

    /* Do we have this interface */

    if (riid == IID_IOverlayNotify) {
        return GetInterface((LPUNKNOWN) (IOverlayNotify *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP_(ULONG) CCapOverlayNotify::NonDelegatingRelease()
{
    return m_pFilter->Release();
}


STDMETHODIMP_(ULONG) CCapOverlayNotify::NonDelegatingAddRef()
{
    return m_pFilter->AddRef();
}


STDMETHODIMP CCapOverlayNotify::OnColorKeyChange(
    const COLORKEY *pColorKey)          // Defines new colour key
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlayNotify::OnColorKeyChange")));

// We expect the hardware to handle colour key stuff, so I'm really
// hoping that the renderer will never draw the colour key itself.

    return NOERROR;
}


// The calls to OnClipChange happen in sync with the window. So it's called
// with an empty clip list before the window moves to freeze the video, and
// then when the window has stabilised it is called again with the new clip
// list. The OnPositionChange callback is for overlay cards that don't want
// the expense of synchronous clipping updates and just want to know when
// the source or destination video positions change. They will NOT be called
// in sync with the window but at some point after the window has changed
// (basicly in time with WM_SIZE etc messages received). This is therefore
// suitable for overlay cards that don't inlay their data to the framebuffer

STDMETHODIMP CCapOverlayNotify::OnClipChange(
    const RECT    * pSourceRect,         // Area of source video to use
    const RECT    * pDestinationRect,    // screen co-ords of window
    const RGNDATA * pRegionData)         // Header describing clipping
{
    if (!m_pFilter->m_pOverlayPin)
	return NOERROR;

    if (!m_pFilter->m_pOverlayPin->IsConnected())
	return NOERROR;

    if (IsRectEmpty(pSourceRect) && IsRectEmpty(pDestinationRect))
	return NOERROR;

    HWND hwnd = NULL;
    HDC  hdc;
    if (m_pFilter->m_pOverlayPin->m_pOverlay)
        m_pFilter->m_pOverlayPin->m_pOverlay->GetWindowHandle(&hwnd);

    if (hwnd == NULL || !IsWindowVisible(hwnd))
	return NOERROR;
    if (hwnd)
	hdc = GetDC(hwnd);
    if (hdc == NULL)
	return NOERROR;

    DbgLog((LOG_TRACE,3,TEXT("OnClip/PositionChange (%d,%d) (%d,%d)"),
        		pSourceRect->right - pSourceRect->left,
        		pSourceRect->bottom - pSourceRect->top,
        		pDestinationRect->right - pDestinationRect->left,
        		pDestinationRect->bottom - pDestinationRect->top));

    // It's up to us to keep garbage out of the window by painting it if
    // we're not running, and the hardware has nothing to draw
    if (!m_pFilter->m_pOverlayPin->m_fRunning) {
	RECT rcC;
	GetClientRect(hwnd, &rcC);
	HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(BLACK_BRUSH));
	PatBlt(hdc, 0, 0, rcC.right, rcC.bottom, PATCOPY);
	SelectObject(hdc, hbrOld);
        ReleaseDC(hwnd, hdc);
	return NOERROR;
    }

    vidxSetRect(m_pFilter->m_pStream->m_cs.hVideoExtOut, DVM_SRC_RECT,
			pSourceRect->left, pSourceRect->top,
			pSourceRect->right, pSourceRect->bottom);
    vidxSetRect(m_pFilter->m_pStream->m_cs.hVideoExtOut, DVM_DST_RECT,
			pDestinationRect->left, pDestinationRect->top,
			pDestinationRect->right, pDestinationRect->bottom);
    videoStreamInit(m_pFilter->m_pStream->m_cs.hVideoExtOut, 0, 0, 0, 0);
    videoUpdate(m_pFilter->m_pStream->m_cs.hVideoExtOut, hwnd, hdc);

    ReleaseDC(hwnd, hdc);

    return NOERROR;
}


STDMETHODIMP CCapOverlayNotify::OnPaletteChange(
    DWORD dwColors,                     // Number of colours present
    const PALETTEENTRY *pPalette)       // Array of palette colours
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlayNotify::OnPaletteChange")));

    return NOERROR;
}


STDMETHODIMP CCapOverlayNotify::OnPositionChange(
    const RECT *pSourceRect,            // Area of video to play with
    const RECT *pDestinationRect)       // Area video goes
{

    return OnClipChange(pSourceRect, pDestinationRect, NULL);
}



//
// PIN CATEGORIES - let the world know that we are a PREVIEW pin
//

HRESULT CCapOverlay::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CCapOverlay::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
	return E_POINTER;

    if (pcbReturned)
	*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
	return S_OK;

    if (cbPropData < sizeof(GUID))
	return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_PREVIEW;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CCapOverlay::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
	*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\ivideo32.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_IVIDEO32
#define _INC_IVIDEO32   50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#include <vfw.h>

#define LOADDS
#define EXPORT

// unicode conversions
int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

/****************************************************************************

                        video APIs

****************************************************************************/

#include "vidx.h"

#if defined _WIN32

void NTvideoInitHandleList(void);
void NTvideoDeleteHandleList(void);

#ifdef UNICODE
  #define videoGetErrorText  videoGetErrorTextW
  #define NTvideoGetErrorText  NTvideoGetErrorTextW
#else
  #define videoGetErrorText  videoGetErrorTextA
  #define NTvideoGetErrorText  NTvideoGetErrorTextA
#endif // !UNICODE

DWORD WINAPI videoOpen(
   LPHVIDEO lphVideo,
   DWORD dwDevice,
   DWORD dwFlags);
DWORD WINAPI NTvideoOpen(
   LPHVIDEO lphVideo,
   DWORD dwDevice,
   DWORD dwFlags);

DWORD WINAPI videoClose (
   HVIDEO hVideo);
DWORD WINAPI NTvideoClose (
   HVIDEO hVideo);

DWORD WINAPI videoDialog (
   HVIDEO hVideo,
   HWND   hWndParent,
   DWORD  dwFlags);
DWORD WINAPI NTvideoDialog (
   HVIDEO hVideo,
   HWND   hWndParent,
   DWORD  dwFlags);

DWORD WINAPI videoGetChannelCaps(
   HVIDEO hVideo,
   LPCHANNEL_CAPS lpChannelCaps,
   DWORD dwSize);
DWORD WINAPI NTvideoGetChannelCaps(
   HVIDEO hVideo,
   LPCHANNEL_CAPS lpChannelCaps,
   DWORD dwSize);

DWORD WINAPI videoUpdate (
   HVIDEO hVideo,
   HWND   hWnd,
   HDC    hDC);
DWORD WINAPI NTvideoUpdate (
   HVIDEO hVideo,
   HWND   hWnd,
   HDC    hDC);

DWORD WINAPI videoConfigure (
   HVIDEO  hVideo,
   UINT    msg,
   DWORD   dwFlags,
   LPDWORD lpdwReturn,
   LPVOID  lpData1,
   DWORD   dwSize1,
   LPVOID  lpData2,
   DWORD   dwSize2);
DWORD WINAPI NTvideoConfigure (
   HVIDEO  hVideo,
   UINT    msg,
   DWORD   dwFlags,
   LPDWORD lpdwReturn,
   LPVOID  lpData1,
   DWORD   dwSize1,
   LPVOID  lpData2,
   DWORD   dwSize2);

DWORD WINAPI videoFrame (
   HVIDEO hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvideoFrame (
   HVIDEO hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);

DWORD WINAPI videoGetErrorTextA(
   HVIDEO hVideo,
   UINT   wError,
   LPSTR  lpText,
   UINT   wSize);
DWORD WINAPI NTvideoGetErrorTextA(
   HVIDEO hVideo,
   UINT   wError,
   LPSTR  lpText,
   UINT   wSize);
DWORD WINAPI videoGetErrorTextW(
   HVIDEO hVideo,
   UINT   wError,
   LPWSTR  lpText,
   UINT   wSize);
DWORD WINAPI NTvideoGetErrorTextW(
   HVIDEO hVideo,
   UINT   wError,
   LPWSTR  lpText,
   UINT   wSize);

DWORD WINAPI videoStreamInit (
   HVIDEO hVideo,
   DWORD  dwMicroSecPerFrame,
   DWORD_PTR  dwCallback,
   DWORD_PTR  dwCallbackInst,
   DWORD  dwFlags);
DWORD WINAPI NTvideoStreamInit (
   HVIDEO hVideo,
   DWORD  dwMicroSecPerFrame,
   DWORD_PTR  dwCallback,
   DWORD_PTR  dwCallbackInst,
   DWORD  dwFlags);

DWORD WINAPI videoStreamFini (
   HVIDEO hVideo);
DWORD WINAPI NTvideoStreamFini (
   HVIDEO hVideo);

//DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
//            LPVIDEOHDREX lpVHdr,DWORD dwSize);
//DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
//            LPVIDEOHDREX lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(
   HVIDEO     hVideo,
   LPVIDEOHDR lpVHdr,
   DWORD      dwSize);
DWORD WINAPI NTvideoStreamUnprepareHeader(
   HVIDEO     hVideo,
   LPVIDEOHDR lpVHdr,
   DWORD      dwSize);

// Added for Win95 & NT PPC
//
DWORD WINAPI videoStreamAllocBuffer(HVIDEO hVideo,
            LPVOID FAR * plpBuffer, DWORD dwSize);
DWORD WINAPI NTvideoStreamAllocBuffer(HVIDEO hVideo,
            LPVOID FAR * plpBuffer, DWORD dwSize);
DWORD WINAPI videoStreamFreeBuffer(HVIDEO hVideo,
            LPVOID lpBuffer);
DWORD WINAPI NTvideoStreamFreeBuffer(HVIDEO hVideo,
            LPVOID lpBuffer);


DWORD WINAPI videoSetRect(HVIDEO hVideo, DWORD dwMsg, RECT rc);
DWORD WINAPI NTvideoSetRect(HVIDEO hVideo, DWORD dwMsg, RECT rc);

DWORD WINAPI NTvideoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc,
				UINT cbDesc, LPTSTR lpszVer, UINT cbVer);
DWORD WINAPI videoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc,
				UINT cbDesc, LPTSTR lpszVer, UINT cbVer);

LRESULT WINAPI NTvideoMessage(HVIDEO hVideo, UINT uMsg, LPARAM dw1, LPARAM dw2);
LRESULT WINAPI videoMessage(HVIDEO hVideo, UINT uMsg, LPARAM dw1, LPARAM dw2);

#endif // _WIN32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_IVIDEO32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\outpin.cpp ===
/*+
 *
 * Implement CCapStream
 *
 *-== Copyright (c) Microsoft Corporation 1996. All Rights Reserved ==*/


#include <streams.h>
#include "driver.h"
#include "common.h"

// turn on performance measuring code
//
//#define JMK_HACK_TIMERS
#include "cmeasure.h"

// ============== Implements the CAviStream class ==================

CCapStream * CreateStreamPin (
   CVfwCapture * pCapture,
   UINT          iVideoId,
   HRESULT     * phr)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::CreateStreamPin(%08lX,%08lX)"),
        pCapture, phr));

   WCHAR wszPinName[16];
   lstrcpyW(wszPinName, L"~Capture");

   CCapStream * pStream = new CCapStream(NAME("Video Capture Stream"),
				pCapture, iVideoId, phr, wszPinName);
   if (!pStream)
      *phr = E_OUTOFMEMORY;

   // if initialization failed, delete the stream array
   // and return the error
   //
   if (FAILED(*phr) && pStream)
      delete pStream, pStream = NULL;

   return pStream;
}


#pragma warning(disable:4355)
CCapStream::CCapStream(TCHAR *pObjectName, CVfwCapture *pCapture, UINT iVideoId,
        HRESULT * phr, LPCWSTR pName)
   :
   CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, phr, pName),
   m_Alloc(NAME("Cap stream allocator"), this, phr),
   m_pCap(pCapture),
   m_pmt(NULL),
   m_hThread(NULL),
   m_state(TS_Not),
   m_hEvtPause(NULL),
   m_hEvtRun(NULL),
   m_pBufferQueue(NULL),
   m_tid(0),
   m_rtLatency(0),
   m_rtStreamOffset(0),
   m_rtMaxStreamOffset(0),
   m_pDrawPrimary(0),
   m_pdd(0)
{
    DbgLog((LOG_TRACE,1,TEXT("CCapStream constructor")));
    ASSERT(pCapture);

   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS )
   {
       HRESULT hrTmp = CoCreateInstance(
           CLSID_DirectDraw, NULL, CLSCTX_ALL, IID_IDirectDraw, (void **)&m_pdd);
       if(SUCCEEDED(hrTmp))
       {
           hrTmp = m_pdd->Initialize(0);

           if(SUCCEEDED(hrTmp)) {
               hrTmp = m_pdd->SetCooperativeLevel(0, DDSCL_NORMAL);
           }

           if(FAILED(hrTmp)) {
               m_pdd->Release();
               m_pdd = 0;
           }
       }
   }
    
   ZeroMemory (&m_user, sizeof(m_user));
   ZeroMemory (&m_cs, sizeof(m_cs));
   ZeroMemory (&m_capstats, sizeof(m_capstats));

   // initialize to no suggestion from app (IAMBufferNegotiation)
   m_propSuggested.cBuffers = -1;
   m_propSuggested.cbBuffer = -1;
   m_propSuggested.cbAlign = -1;
   m_propSuggested.cbPrefix = -1;

   // use the capture device we're told to
   m_user.uVideoID      = iVideoId;

   // !!! Is it evil to hold resource for life of filter?
   if (SUCCEEDED(*phr))
      *phr = ConnectToDriver();

   if (SUCCEEDED(*phr))
      *phr = LoadOptions();

   jmkAlloc   // allocate and init perf logging buffers
   jmkInit

   // make sure allocator doesn't get destroyed until we are ready for it to.
   // ???
   //m_Alloc.NonDelegatingAddRef();

#ifdef PERF
   m_perfWhyDropped = MSR_REGISTER(TEXT("cap why dropped"));
#endif // PERF;
}


CCapStream::~CCapStream()
{
   if(m_pdd) {
       m_pdd->Release();
   }
    
   DbgLog((LOG_TRACE,1,TEXT("CCapStream destructor")));

   // we don't let go of resources until the filter goes away
   // done when we leave the graph // DisconnectFromDriver();

   jmkFree   // free perf logging buffers

   // freed when we leave the filtergraph
   // delete [] m_cs.tvhPreview.vh.lpData;

   // freed in Unprepare
   // delete m_cs.pSamplePreview;

   // freed when we leave the filtergraph
   // delete m_user.pvi;

   if (m_hThread)
      CloseHandle (m_hThread);
   m_hThread = NULL;

   DbgLog((LOG_TRACE,2,TEXT("CCapStream destructor finished")));
}


STDMETHODIMP CCapStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
#if 0
    if (riid == IID_IMediaPosition)
	return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    if (riid == IID_IMemAllocator) {
	return GetInterface((IMemAllocator *)&m_Alloc, ppv);
#endif
    if (riid == IID_IAMStreamConfig) {
	return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    } else if (riid == IID_IAMVideoCompression) {
	return GetInterface((LPUNKNOWN)(IAMVideoCompression *)this, ppv);
    } else if (riid == IID_IAMDroppedFrames) {
	return GetInterface((LPUNKNOWN)(IAMDroppedFrames *)this, ppv);
    } else if (riid == IID_IAMBufferNegotiation) {
	return GetInterface((LPUNKNOWN)(IAMBufferNegotiation *)this, ppv);
    } else if (riid == IID_IAMStreamControl) {
	return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    } else if (riid == IID_IAMPushSource) {
    return GetInterface((LPUNKNOWN)(IAMPushSource *)this, ppv);
    } else if (riid == IID_IKsPropertySet) {
	return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv);
    }

   return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}

int CCapStream::ProfileInt(
   LPSTR pszKey,
   int   iDefault)
{
   return GetProfileIntA ("Capture", pszKey, iDefault);
}

void CCapStream::ReduceScaleAndRate (void)
{
   // this is a macro to allow the optimizer to take advantage of the
   // fact the factor is a constant at compile time
   //
   #define ReduceByFactor(factor) {                 \
      while (!(m_user.dwTickRate % (factor))) {     \
         if (!(m_user.dwTickScale % (factor)))      \
            m_user.dwTickScale /= (factor);         \
         else                                       \
            break;                                  \
         m_user.dwTickRate /= (factor);             \
         }                                          \
      }

   ReduceByFactor (5);
   ReduceByFactor (3);
   ReduceByFactor (2);

   #undef ReduceByFactor
}

// Allocates a VIDEOINFOHEADER big enough to hold the given format
static VIDEOINFOHEADER * AllocVideoinfo(LPBITMAPINFOHEADER lpbi)
{
   UINT cb = GetBitmapFormatSize(lpbi);
   VIDEOINFOHEADER * pvi = (VIDEOINFOHEADER *)(new BYTE[cb]);
   if (pvi)
      ZeroMemory(pvi, cb);
   return pvi;
}

//
// Whenever we get a new format from the driver, OR
// start using a new palette, we must reallocate
// our global BITMAPINFOHEADER.  This allows JPEG
// quantization tables to be tacked onto the BITMAPINFO
// or any other format specific stuff.  The color table
// is always offset biSize from the start of the BITMAPINFO.
// Returns: 0 on success, or DV_ERR_... code
//

HRESULT
CCapStream::LoadOptions (void)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream LoadOptions")));

   // make something (anything) valid to start with
   static BITMAPINFOHEADER bmih = {
      sizeof (BITMAPINFOHEADER),                    //biSize
      1,                                            //biWidth
      1,                                            //biHeight
      1,                                            //biPlanes
      16,                                  	    //biBitCount

      BI_RGB,                                       //biCompression
      WIDTHBYTES(160 * 16) * 120,   		    //biSizeImage
      0,                                            //biXPelsPerMeter
      0,                                            //biYPelsPerMeter
      0,                                            //biClrUsed
      0                                             //biClrImportant
   };
   LPBITMAPINFOHEADER pbih = &bmih;

// I connect earlier now
#if 0
   m_user.uVideoID      = ProfileInt("VideoID", 0);
   HRESULT hr = ConnectToDriver();
   if (FAILED(hr))
      return hr;
#endif
   HRESULT hr = S_OK;

   m_user.dwLatency   = ProfileInt("Latency", 666666);	// 1/15 second
   m_user.dwTickScale   = ProfileInt("TickScale", 100);
   m_user.dwTickRate    = ProfileInt("TickRate", 2997);	// 29.97 fps
   // !! change at your own risk... 16 bit guy won't know it
   m_user.nMinBuffers   = ProfileInt("MinBuffers", MIN_VIDEO_BUFFERS);
   m_user.nMaxBuffers   = ProfileInt("MaxBuffers", MAX_VIDEO_BUFFERS);
   DbgLog((LOG_TRACE,2,TEXT("Min # buffers=%d  Max # buffers=%d"),
				m_user.nMinBuffers, m_user.nMaxBuffers));

// !!! TEST
#if 0
    ALLOCATOR_PROPERTIES prop;
    IAMBufferNegotiation *pBN;
    prop.cBuffers = ProfileInt("cBuffers", MAX_VIDEO_BUFFERS);
    prop.cbBuffer = ProfileInt("cbBuffer", 65536);
    prop.cbAlign = ProfileInt("cbAlign", 4);
    prop.cbPrefix = ProfileInt("cbPrefix", 0);
    hr = QueryInterface(IID_IAMBufferNegotiation, (void **)&pBN);
    if (hr == NOERROR) {
	pBN->SuggestAllocatorProperties(&prop);
 	pBN->Release();
    }
#endif

   //
   // REFERENCE_TIME and dwScale & dwTickRate are both large
   // numbers, we strip off the common factors from dwRate/dwScale
   //
   ReduceScaleAndRate();
   DbgLog((LOG_TRACE,2,TEXT("Default Scale=%d Rate=%d"), m_user.dwTickScale,
							m_user.dwTickRate));

   // create a VIDEOINFOHEADER for the m_user structure
   //
   m_user.pvi = AllocVideoinfo(pbih);
   if (!m_user.pvi) {
      hr = E_OUTOFMEMORY;
   } else {

      CopyMemory(&m_user.pvi->bmiHeader, pbih, pbih->biSize);

      // start with no funky rectangles
      m_user.pvi->rcSource.top = 0; m_user.pvi->rcSource.left = 0;
      m_user.pvi->rcSource.right = 0; m_user.pvi->rcSource.bottom = 0;
      m_user.pvi->rcTarget.top = 0; m_user.pvi->rcTarget.left = 0;
      m_user.pvi->rcTarget.right = 0; m_user.pvi->rcTarget.bottom = 0;

      HRESULT hrT = GetFormatFromDriver ();
      if (FAILED(hrT))
            hr = hrT;

      // if this is a palettized mode, get the palette
      //
      if (m_user.pvi->bmiHeader.biBitCount <= 8) {
         HRESULT hrT = InitPalette ();
         if (FAILED(hrT))
            hr = hrT;
      }

      // Now send the format back to the driver, because AVICAP did, and we
      // have to do everything it does, or somebody's driver will hang...
      // ... in this case the ISVRIII NT
      SendFormatToDriver(m_user.pvi);

      // grab a frame to kick the driver in the head or preview won't work until
      // we start streaming capture
      THKVIDEOHDR tvh;
      ZeroMemory (&tvh, sizeof(tvh));
      tvh.vh.dwBufferLength = m_user.pvi->bmiHeader.biSizeImage;
      DWORD dw = vidxAllocPreviewBuffer(m_cs.hVideoIn, (LPVOID *)&tvh.vh.lpData,
                                    sizeof(tvh.vh), tvh.vh.dwBufferLength);
      if (dw == 0) {
          tvh.p32Buff = tvh.vh.lpData;
          dw = vidxFrame(m_cs.hVideoIn, &tvh.vh);
          vidxFreePreviewBuffer(m_cs.hVideoIn, (LPVOID *)&tvh.vh.lpData);
      }

      m_user.pvi->AvgTimePerFrame = TickToRefTime (1);
      // we don't know our data rate.  Sorry.  Hope nobody minds
      m_user.pvi->dwBitRate = 0;
      m_user.pvi->dwBitErrorRate = 0;

      // set the size of the VIDEOINFOHEADER to the size of valid data
      // for this format.
      //
      m_user.cbFormat = GetBitmapFormatSize(&m_user.pvi->bmiHeader);
   }

// we need to stay connected or the driver will forget what we just told it
#if 0
   DisconnectFromDriver();
#endif
   return hr;
}

// set user settings from the supplied buffer
//
HRESULT CCapStream::SetOptions (
    const VFWCAPTUREOPTIONS * pUser)
{
   if (m_user.pvi)
	delete m_user.pvi;
   m_user = *pUser;
   if (m_user.pvi)
      {
      m_user.pvi = AllocVideoinfo(&pUser->pvi->bmiHeader);
      if (m_user.pvi)
          CopyMemory (m_user.pvi, pUser->pvi, pUser->cbFormat);
      else
         return E_OUTOFMEMORY;
      }
   return S_OK;
}

// copy user settings into the supplied structure
//
HRESULT CCapStream::GetOptions (
   VFWCAPTUREOPTIONS * pUser)
{
   *pUser = m_user;
   if (m_user.pvi)
      {
	// caller will free this
      pUser->pvi = AllocVideoinfo(&m_user.pvi->bmiHeader);
      if (pUser->pvi)
         CopyMemory(pUser->pvi, m_user.pvi, m_user.cbFormat);
      else
         return E_OUTOFMEMORY;
      };

   return S_OK;
}

HRESULT CCapStream::GetMediaType(
   int          iPosition,
   CMediaType * pMediaType)
{
   DbgLog((LOG_TRACE,3,TEXT("CCapStream GetMediaType")));

   // check it is the single type they want
   if (iPosition < 0)
       return E_INVALIDARG;
   if (iPosition > 0 ||  ! m_user.pvi)
       return VFW_S_NO_MORE_ITEMS;

   pMediaType->majortype = MEDIATYPE_Video;
   pMediaType->subtype   = GetBitmapSubtype(&m_user.pvi->bmiHeader);
   // I'm trusting the driver to give me the biggest possible size
   pMediaType->SetSampleSize (m_user.pvi->bmiHeader.biSizeImage);
   // !!! This is NOT necessarily true
   pMediaType->bTemporalCompression = FALSE;
   pMediaType->SetFormat ((BYTE *)m_user.pvi, m_user.cbFormat);
   pMediaType->formattype = FORMAT_VideoInfo;

   return S_OK;
}


// check if the pin can support this specific proposed type and format
//
HRESULT CCapStream::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr;

    if (pmt == NULL || pmt->Format() == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type/format is NULL")));
	return E_POINTER;
    }

    DbgLog((LOG_TRACE,3,TEXT("CheckMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

    // we only support MEDIATYPE_Video
    if (*pmt->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: not VIDEO")));
	return VFW_E_INVALIDMEDIATYPE;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmt->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: format not VIDINFO")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    RECT rcS = ((VIDEOINFOHEADER *)pmt->Format())->rcSource;
    RECT rcT = ((VIDEOINFOHEADER *)pmt->Format())->rcTarget;
    if (!IsRectEmpty(&rcT) && (rcT.left != 0 || rcT.top != 0 ||
			HEADER(pmt->Format())->biWidth != rcT.right ||
			HEADER(pmt->Format())->biHeight != rcT.bottom)) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: can't use funky rcTarget")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    // We don't know what this would be relative to... reject everything
    if (!IsRectEmpty(&rcS)) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: can't use funky rcSource")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // quickly test to see if this is the current format (what we provide in
    // GetMediaType).  We accept that
    //
    CMediaType mt;
    GetMediaType(0,&mt);
    if (mt == *pmt) {
	DbgLog((LOG_TRACE,3,TEXT("CheckMediaType SUCCEEDED")));
	return NOERROR;
    }

   // The only other way to see if we accept something is to set the hardware
   // to use that format, and see if it worked.  (Remember to set it back)

   // This is a BAD IDEA IF WE ARE CAPTURING RIGHT NOW.  Sorry, but I'll have
   // to fail. I can't change the capture format.
   if (m_pCap->m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

   VIDEOINFOHEADER *pvi = m_user.pvi;
   if (FAILED(hr = SendFormatToDriver((VIDEOINFOHEADER *)(pmt->Format())))) {
	DbgLog((LOG_TRACE,3,TEXT("CheckMediaType FAILED")));
	return hr;
   }
   EXECUTE_ASSERT(SendFormatToDriver(pvi) == S_OK);

   DbgLog((LOG_TRACE,3,TEXT("CheckMediaType SUCCEEDED")));
   return NOERROR;
}


// set the new media type
//
HRESULT CCapStream::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr;
    DbgLog((LOG_TRACE,2,TEXT("SetMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

    ASSERT(m_pCap->m_State == State_Stopped);

    if (FAILED(hr = SendFormatToDriver((VIDEOINFOHEADER *)(pmt->Format())))) {
	ASSERT(FALSE);	// we were promised this would work
	DbgLog((LOG_ERROR,1,TEXT("ACK! SetMediaType FAILED")));
	return hr;
    }

    // Now remember that this is the current format
    CopyMemory(m_user.pvi, pmt->Format(), SIZE_PREHEADER);
    CopyMemory(&m_user.pvi->bmiHeader, HEADER(pmt->Format()),
					HEADER(pmt->Format())->biSize);

    // Set the frame rate to what was in the media type, if there is one
    if (((VIDEOINFOHEADER *)(pmt->pbFormat))->AvgTimePerFrame) {
 	const LONGLONG ll = 100000000000;
	m_user.dwTickScale = 10000;
	m_user.dwTickRate = (DWORD)(ll /
			((VIDEOINFOHEADER *)(pmt->pbFormat))->AvgTimePerFrame);
	ReduceScaleAndRate();
        DbgLog((LOG_TRACE,2,TEXT("SetMediaType: New frame rate is %d/%dfps"),
				m_user.dwTickRate, m_user.dwTickScale));
    }

    // now reconnect our preview pin to use the same format as us
    Reconnect(FALSE);

    return CBasePin::SetMediaType(pmt);
}


HRESULT CCapStream::DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pProperties)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream DecideBufferSize")));

   ASSERT(pAllocator);
   ASSERT(pProperties);

    // the user has requested something specific?
    if (m_propSuggested.cBuffers > 0) {
	pProperties->cBuffers = m_propSuggested.cBuffers;
    // otherwise we want all the buffers we can
    } else {
        pProperties->cBuffers = MAX_VIDEO_BUFFERS;
    }

    // the user has requested a specific prefix
    if (m_propSuggested.cbPrefix >= 0)
	pProperties->cbPrefix = m_propSuggested.cbPrefix;

    // the user has requested a specific alignment
    if (m_propSuggested.cbAlign > 0)
	pProperties->cbAlign = m_propSuggested.cbAlign;

   // don't blow up
   if (pProperties->cbAlign == 0)
	pProperties->cbAlign = 1;

   // the user has a preference for buffer size
   if (m_propSuggested.cbBuffer > 0)
       pProperties->cbBuffer = m_propSuggested.cbBuffer;
   // I'm trusting the driver to set biSizeImage to the largest possible size
   // This is how big we need each buffer to be
   else if (m_user.pvi && (long)m_user.pvi->bmiHeader.biSizeImage >
						pProperties->cbBuffer)
       pProperties->cbBuffer = (long)m_user.pvi->bmiHeader.biSizeImage;

   // I don't remember why, but this IS IMPORTANT
   pProperties->cbBuffer = (long)ALIGNUP(pProperties->cbBuffer +
   				pProperties->cbPrefix, pProperties->cbAlign) -
   				pProperties->cbPrefix;

   ASSERT(pProperties->cbBuffer);

   DbgLog((LOG_TRACE,2,TEXT("Using %d buffers, prefix %d size %d align %d"),
			pProperties->cBuffers, pProperties->cbPrefix,
			pProperties->cbBuffer,
			pProperties->cbAlign));

   //
   // note that for the capture pin we don't want to specify any default
   // latency, this way when the graph isn't doing any audio preview the
   // the most this stream's offset will ever be is the latency reported
   // by the preview pin (1 frame currently)
   //
   m_rtLatency = 0;
   m_rtStreamOffset = 0;
   m_rtMaxStreamOffset = 0;

   ALLOCATOR_PROPERTIES Actual;
   return pAllocator->SetProperties(pProperties,&Actual);

   // It's our allocator, we know we'll be happy with what it decided

}

//
//  Override DecideAllocator because we insist on our own allocator since
//  it's 0 cost in terms of bytes
//
HRESULT
CCapStream::DecideAllocator(
   IMemInputPin   *pPin,
   IMemAllocator **ppAlloc)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream DecideAllocator")));

   *ppAlloc = (IMemAllocator *)&m_Alloc;
   (*ppAlloc)->AddRef();

   // get downstream prop request
   // the derived class may modify this in DecideBufferSize, but
   // we assume that he will consistently modify it the same way,
   // so we only get it once
   ALLOCATOR_PROPERTIES prop;
   ZeroMemory(&prop, sizeof(prop));

   // whatever he returns, we assume prop is either all zeros
   // or he has filled it out.
   pPin->GetAllocatorRequirements(&prop);

   HRESULT hr = DecideBufferSize(*ppAlloc,&prop);
   if (SUCCEEDED(hr))
      {
      // our buffers are not read only
      hr = pPin->NotifyAllocator(*ppAlloc,FALSE);
      if (SUCCEEDED(hr))
         return NOERROR;
      }

   (*ppAlloc)->Release();
   *ppAlloc = NULL;
   return hr;
}

// =================== IPin interfaces ===========================
//

// all in base classes
#if 0
//
// return an qzTaskMemAlloc'd string containing the name
// of the current pin.  memory allocated by qzTaskMemAlloc
// will be freed by the caller
//
STDMETHODIMP CCapStream::QueryId (
   LPWSTR *ppwsz)
{
    int ii = m_pCap->FindPinNumber(this);
    if (ii < 0)
       return E_INVALIDARG;

    *ppwsz = (LPWSTR)QzTaskMemAlloc(sizeof(WCHAR) * 8);
    IntToWstr(ii, *ppwsz);
    return NOERROR;
}
#endif

//
// ThreadProc for a stream.
//
// General strategy for thread synchronization:
//   as much as possible we try to handle thread state transitions without
//   trying to grab any critical sections. we use InterlockedExchange of a
//   thread state variable and count on the fact that only Active and Inactive
//   and the ThreadProc can change the thread state
//
//   this works because: the caller of Active/Inactive is serialized so we
//   will never try to make two state changes simultaneously.
//   so state transitions boil down to a few simple possibilities:
//
//   Not->Create   - Create() does this. effectively serializes Create
//                   so that the first thread does the work and subsequent
//                   threads fail.
//
//   Create->Init  - worker does this when it starts up. worker will always
//                   proceed to Pause, this state exists only to make debugging
//                   easier.
//   Init->Pause   - worker does this when done with initialization.
//
//   Pause->Run    - user does  this via Run()
//   Run->Pause    - user does this via Pause()
//
//   Run->Stop     - user does this via Stop()
//   Pause->Stop   - user does this via Stop()
//
//   Stop->Destroy - another debugging state. worker sets destroy to indicate
//                   that it has noticed Stop request and is not shutting down
//                   thread always proceeds to Exit from
//   Destroy->Exit - worker does this prior to dying.  this is a debug transition
//   Exit->Not     - Destroy() does this after waiting for the worker to die.
//
//   When Active returns, worker should always be in Pause or Run state
//   When Inactive returns, worker should always be in Not state (worker does
//      not exist)
//
DWORD CCapStream::ThreadProc()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream ThreadProc")));

   ThdState state; // current state
   state = ChangeState (TS_Init);
   ASSERT (state == TS_Create);

// we connect earlier now
#if 0
   HRESULT hr = ConnectToDriver();
   if (hr)
      goto bail;
#endif

   // do the work necessary to go into the paused state
   //
   HRESULT hr = Prepare();
   if (hr) {
       DbgLog((LOG_ERROR,1,TEXT("*** Error preparing the allocator. Can't capture")));
       SetEvent(m_hEvtPause);	// main thread is blocked right now!
       goto bail;
   }

   // goto into paused state
   //
   state = ChangeState (TS_Pause);
   ASSERT (state == TS_Init);
   SetEvent(m_hEvtPause);

   while (m_state != TS_Stop) {

       // don't start capturing until we run (or stop)
       WaitForSingleObject(m_hEvtRun, INFINITE);
       ResetEvent(m_hEvtRun);

       // stream until not running, or we get an error
       Capture();

   }

   // we expect to be in the Stop state when we get to here.
   // flush any downstream buffers.
   //
   ASSERT (m_state == TS_Stop);
   ResetEvent(m_hEvtPause);	// for next time we pause
   Flush();

bail:
   // change the state to destroy to indicate that we are exiting
   //
   state = ChangeState (TS_Destroy);

   // free stuff
   //
   Unprepare();

   // stay connected now
   // DisconnectFromDriver();

   // change state to Exit and then get out of here
   //
   ChangeState (TS_Exit);
   return 0;
}

DWORD WINAPI CCapStream::ThreadProcInit (void * pv)
{
   CCapStream * pThis = (CCapStream *) pv;
   return pThis->ThreadProc();
}

// create the worker thread for this stream
//
BOOL CCapStream::Create()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Create")));

   // return fail if someone else is already creating / has created
   // the worker thread
   //
   ASSERT (m_state == TS_Not);
   if (ChangeState(TS_Create) > TS_Not)
      return FALSE;

   ASSERT (!m_hEvtPause);
   m_hEvtPause = CreateEvent(NULL, TRUE, FALSE, NULL);
   if (!m_hEvtPause)
      goto bail;
   ASSERT (!m_hEvtRun);
   m_hEvtRun = CreateEvent(NULL, TRUE, FALSE, NULL);
   if (!m_hEvtRun)
      goto bail;


   m_hThread = CreateThread (NULL, 0,
                             CCapStream::ThreadProcInit,
                             this,
                             0,
                             &m_tid);
   if ( ! m_hThread)
      goto bail;

   return m_hThread != NULL;

bail:
   if (m_hEvtPause)
      CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
   if (m_hEvtRun)
      CloseHandle(m_hEvtRun), m_hEvtRun = NULL;

   m_state = TS_Not;
   return FALSE;
}

// Wait for the worker thread to die
//
BOOL CCapStream::Destroy()
{
   // return trivial success if there is nothing to destroy
   //
   if (m_state == TS_Not)
      return TRUE;

   // Wait for the thread to die. (Destroy must be preceeded by
   // a Stop or we could deadlock here)
   //
   ASSERT (m_state >= TS_Stop);
   WaitForSingleObject (m_hThread, INFINITE);
   ASSERT (m_state == TS_Exit);

   // cleanup
   //
   CloseHandle(m_hThread), m_hThread = NULL;
   m_tid = 0;
   CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
   CloseHandle(m_hEvtRun), m_hEvtRun = NULL;
   m_state = TS_Not;
   return TRUE;
}

// set the worker thread into the run state.  This call
// does not wait for the state transition to be complete before
// returning.
//
BOOL CCapStream::Run()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Run")));

   // a transition to run state is only valid if the current
   // state is Pause (or already Running)
   //
   ThdState state = m_state;
   if (state != TS_Run && state != TS_Pause)
      return FALSE;

   // change the state and turn on the 'run' event
   // in case the thread is blocked on it.  If state that we are
   // changing from is not Run or Pause, then something is seriously wrong!!
   //
   state = ChangeState(TS_Run);
   ASSERT(state == TS_Run || state == TS_Pause);
   SetEvent(m_hEvtRun);
   // Go capture, go! Note when we started it
   if (m_pCap->m_pClock)
       m_pCap->m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtDriverStarted);
   else
       m_cs.rtDriverStarted = m_pCap->m_tStart;	
   videoStreamStart(m_cs.hVideoIn);
   // these need to be zeroed every time the driver is told to stream, because
   // the driver will start counting from 0 again
   m_cs.dwlLastTimeCaptured = 0;
   m_cs.dwlTimeCapturedOffset = 0;
   return TRUE;
}

// put the stream into the paused state and wait for it to get there.
// if the current state is Pause, returns trivial success;
// if the current state is not Run or Init, returns FALSE for failure.
//
BOOL CCapStream::Pause()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Pause")));

   ThdState state = m_state;

   // that was easy
   if (state == TS_Pause)
      return TRUE;

   // it is valid to go into the pause state only if currently
   // in the Create/Init (depending on if our thread has run yet) or Run state
   //
   ASSERT (state == TS_Create || state == TS_Init || state == TS_Run);

   // if we are in the init state, we will fall into the pause state
   // naturally, we just have to wait for it to happen
   //
   if (state == TS_Create || state == TS_Init) {
      WaitForSingleObject (m_hEvtPause, INFINITE);
      state = m_state;
      DbgLog((LOG_TRACE,2,TEXT("Transition Create->Init->Pause complete")));

   } else if (state == TS_Run) {

      state = ChangeState (TS_Pause);
      ASSERT(state == TS_Run);

      // since we aren't running, stop capturing frames for now
      videoStreamStop(m_cs.hVideoIn);

      // the worker thread may hang going from run->pause in Deliver, so
      // it can't signal anything to us.
      // WaitForSingleObject(m_hEvtPause, INFINITE);

      state = m_state;
      m_cs.fReRun = TRUE;  // if we are RUN now, it will have been RUN-PAUSE-RUN
      DbgLog((LOG_TRACE,2,TEXT("Transition Run->Pause complete")));
   }

   return (state == TS_Pause);
}

// stop the worker thread
//
BOOL CCapStream::Stop()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Stop")));

   ThdState state = m_state;
   if (state >= TS_Stop)
      return TRUE;

   // Don't go from Run->Stop without Pause
   if (state == TS_Run)
      Pause();

   state = ChangeState (TS_Stop);
   SetEvent(m_hEvtRun);		// we won't be running, unblock our thread
   m_cs.fReRun = FALSE;	// next RUN is not a RUN-PAUSE-RUN
   DbgLog((LOG_TRACE,2,TEXT("Transition Pause->Stop complete")));

   // we expect that Stop can only be called when the thread is in a
   // Pause state.
   //
   ASSERT (state == TS_Pause);
   return TRUE;
}

// this pin has gone active. (transition to Paused state),
// return from this call when ready to go into run state.
//
HRESULT CCapStream::Active()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from STOP-->PAUSE")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   if ( ! IsConnected())
      return NOERROR;

   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS && m_pdd)
   {
       ASSERT(m_pDrawPrimary == 0);

       DDSURFACEDESC SurfaceDesc;
       SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
       SurfaceDesc.dwFlags = DDSD_CAPS;
       SurfaceDesc.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
       m_pdd->CreateSurface(&SurfaceDesc,&m_pDrawPrimary,NULL);

       // continue on failure risking incorrect operation
   }

   // before we do anything, warn our preview pin we are going active
   if (m_pCap->m_pPreviewPin)
      m_pCap->m_pPreviewPin->CapturePinActive(TRUE);

   hr = CBaseOutputPin::Active();
   if (FAILED(hr)) {
      if (m_pCap->m_pPreviewPin)
         m_pCap->m_pPreviewPin->CapturePinActive(FALSE);
      return hr;
   }

   // start the thread
   //
   ASSERT ( ! ThreadExists());
   if (!Create()) {
      if (m_pCap->m_pPreviewPin)
         m_pCap->m_pPreviewPin->CapturePinActive(FALSE);
      return E_FAIL;
   }

   // wait until the worker thread is done with initialization and
   // has entered the paused state
   //
   hr = E_FAIL;
   if (Pause())
      hr = S_OK;
   else {
	Stop();		// something went wrong.  Destroy thread before we
	Destroy();	// get confused
   }

   ASSERT (hr != S_OK || m_state == TS_Pause);
   if (FAILED(hr))
      if (m_pCap->m_pPreviewPin)
         m_pCap->m_pPreviewPin->CapturePinActive(FALSE);
   return hr;
}

// this pin has gone from PAUSE to RUN mode
//
HRESULT CCapStream::ActiveRun(REFERENCE_TIME tStart)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from PAUSE-->RUN")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   ASSERT (IsConnected() && ThreadExists());

   hr = E_FAIL;
   if (Run())
      hr = S_OK;

   ASSERT (hr != S_OK || m_state == TS_Run);
   return hr;
}

// this pin has gone from RUN to PAUSE mode
//
HRESULT CCapStream::ActivePause()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from RUN-->PAUSE")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   ASSERT (IsConnected() && ThreadExists());

   hr = E_FAIL;
   if (Pause())
      hr = S_OK;

   ASSERT (hr != S_OK || m_state == TS_Pause);
   return hr;
}

//
// Inactive
//
// Pin is inactive - shut down the worker thread
// Waits for the worker to exit before returning.
//
HRESULT CCapStream::Inactive()
{
    if(m_pDrawPrimary) {
        m_pDrawPrimary->Release();
        m_pDrawPrimary = 0;
    }

   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from PAUSE-->STOP")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   //
   if ( ! IsConnected())
       return NOERROR;

   // Tell our preview pin to STOP USING our buffers
   if (m_pCap->m_pPreviewPin)
      m_pCap->m_pPreviewPin->CapturePinActive(FALSE);

   // Now destroy all the capture buffers, since nobody is using them anymore
   //
   Stop();

   // need to do this before trying to stop the thread, because
   // we may be stuck waiting for our own allocator!!
   //
   hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator
   if (FAILED(hr))
      return hr;

   // wait for the worker thread to die
   //
   Destroy();

   return NOERROR;
}


STDMETHODIMP
CCapStream::Notify(
   IBaseFilter * pSender,
   Quality q)
{
   DbgLog((LOG_TRACE,5,TEXT("CCapStream Notify")));
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // !!! ideas anyone?

   return NOERROR;
}

void CCapStream::DumpState(ThdState state)
{
        DbgLog((LOG_TRACE,6, TEXT("%x:CCapStream ChangeState(%d:%s) current=%d:%s"),
             this,
             (int)state, StateName(state),
             (int)m_state, StateName(m_state)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\stream.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include "driver.h"
#include "common.h"
#include "ivideo32.h"

extern "C" {
    extern int g_IsNT;
};

// turn on performance measuring code
//
//#define JMK_HACK_TIMERS
#include "cmeasure.h" // perf logging stuff


#ifndef _WIN64
// on Win95 we have to convert the event handle we will be using as a
// callback into a VxD handle, on NT this is unnecessary.
// since the Win95 kernel does not publish this entry point and it does
// not exist on NT, we dynamically link to it
//
static DWORD WINAPI OpenVxDHandle(
    HANDLE hEvent)
{
    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    GetVersionEx(&osv);
    if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
       {
       #define idOpenVxDHandle "OpenVxDHandle"
       typedef DWORD (WINAPI *PFNOPENVXDHANDLE)(HANDLE);
       static DWORD (WINAPI *pfnOpenVxDHandle)(HANDLE);
       if ( ! pfnOpenVxDHandle)
          {
          HMODULE hModule = GetModuleHandle(TEXT("Kernel32"));
          if (!hModule)
             {
             ASSERT(0);
             return 0;
             }
          pfnOpenVxDHandle = (PFNOPENVXDHANDLE)GetProcAddress (hModule, idOpenVxDHandle);
          if ( ! pfnOpenVxDHandle)
             {
             ASSERT (0);
             return 0;
             }
          }
       return pfnOpenVxDHandle (hEvent);
       }
    else
       return (DWORD)hEvent;
}
#endif

#define ONEMEG (1024L * 1024L)
DWORD_PTR GetFreePhysicalMemory(void)
{
    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);

    GlobalMemoryStatus(&ms);

    if (ms.dwTotalPhys > 8L * ONEMEG)
        return ms.dwTotalPhys - ONEMEG * 4;

    #define FOREVER_FREE 32768L   // Always keep this free for swap space
    return (ms.dwTotalPhys / 2) - FOREVER_FREE;
}

// =============== IMemAllocator interfaces ======================

CCapStream::CAlloc::CAlloc(
    TCHAR      * pname,
    CCapStream * pStream,
    HRESULT    * phr)
    :
    CUnknown(pname, pStream->GetOwner()),
    m_pStream(pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CCapStream::CAlloc constructor")));
}

CCapStream::CAlloc::~CAlloc()
{
    DbgLog((LOG_TRACE,1,TEXT("CCapStream::CAlloc destructor")));

static int iDestructorCalls = 0;
++iDestructorCalls;
}

#if 0
// override this to publicise our interfaces
STDMETHODIMP
CCapStream::CAlloc::NonDelegatingQueryInterface (
   REFIID riid,
   void **ppv)
{
   if (riid == IID_IMemAllocator)
      return GetInterface((IMemAllocator *) this, ppv);
   return m_pStream->NonDelegatingQueryInterface(riid, ppv);
}
#endif

STDMETHODIMP
CCapStream::CAlloc::SetProperties (
   ALLOCATOR_PROPERTIES * pRequest,
   ALLOCATOR_PROPERTIES * pActual)
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::SetProperties")));

   // if we have already allocated headers & buffers
   // ignore the requested and return the actual.
   // otherwise, make a note of the requested so that
   // we can honour it later.
   //
   if ( ! m_pStream->Committed())
      {
      parms.cBuffers  = pRequest->cBuffers;
      parms.cbBuffer  = pRequest->cbBuffer;
      parms.cbAlign   = pRequest->cbAlign;
      parms.cbPrefix  = pRequest->cbPrefix;
      }

   pActual->cBuffers     = (long)parms.cBuffers;
   pActual->cbBuffer     = (long)parms.cbBuffer;
   pActual->cbAlign      = (long)parms.cbAlign;
   pActual->cbPrefix     = (long)parms.cbPrefix;

   return S_OK;
}

STDMETHODIMP
CCapStream::CAlloc::GetProperties (
   ALLOCATOR_PROPERTIES * pProps)
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::GetProperties")));

   pProps->cBuffers = (long)parms.cBuffers;
   pProps->cbBuffer = (long)parms.cbBuffer;
   pProps->cbAlign = (long)parms.cbAlign;
   pProps->cbPrefix = (long)parms.cbPrefix;
   return S_OK;
}

// override Commit to allocate memory. We handle the GetBuffer
//state changes
STDMETHODIMP
CCapStream::CAlloc::Commit ()
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::Commit")));

   return S_OK;
}

// override this to handle the memory freeing. We handle any outstanding
// GetBuffer calls
STDMETHODIMP
CCapStream::CAlloc::Decommit ()
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::Decommit")));

   return S_OK;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct. The two time parameters are
// optional and either may be NULL, they may alternatively be set to
// the start and end times the sample will have attached to it

STDMETHODIMP
CCapStream::CAlloc::GetBuffer (
   IMediaSample **ppBuffer,
   REFERENCE_TIME * pStartTime,
   REFERENCE_TIME * pEndTime,
   DWORD dwFlags)
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::GetBuffer")));

   return E_FAIL;
}

// final release of a IMediaSample will call this
STDMETHODIMP
CCapStream::CAlloc::ReleaseBuffer (
   IMediaSample * pSample)
{
   DbgLog((LOG_TRACE,5,TEXT("CAlloc::ReleaseBuffer")));

   LPTHKVIDEOHDR ptvh = ((CFrameSample *)pSample)->GetFrameHeader();

   ASSERT (ptvh == &m_pStream->m_cs.tvhPreview || (CFrameSample *)ptvh->dwUser == pSample );
   return m_pStream->ReleaseFrame(ptvh);
}

HRESULT
CCapStream::ConnectToDriver()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::ConnectToDriver")));

   // Open and initialize all the channels in the SAME ORDER that AVICap did,
   // for compatability with buggy drivers like Broadway and BT848.

   // Open the VIDEO_IN driver, the one we mostly talk to, and who provides
   // the video FORMAT dialog
   m_cs.mmr = videoOpen(&m_cs.hVideoIn, m_user.uVideoID, VIDEO_IN);
   if (m_cs.mmr)
      {
      ASSERT(!"Failed videoOpen - Aborting");
      return VFW_E_NO_CAPTURE_HARDWARE;
      }

   // Now open the EXTERNALIN device.  He's only good for providing the video
   // SOURCE dialog, so it doesn't really matter if we can't get him
   m_cs.hVideoExtIn = NULL;
   m_cs.mmr = videoOpen(&m_cs.hVideoExtIn, m_user.uVideoID, VIDEO_EXTERNALIN);

  #if 0
   if (m_cs.mmr)
      {
      ASSERT(!"Failed videoOpen - Aborting");
      videoClose (m_cs.hVideoIn);
      return E_FAIL;
      }
  #endif

   // Now open the EXTERNALOUT device.  He's only good for providing the video
   // DISPLAY dialog, and for overlay, so it doesn't really matter if we can't
   // get him
   m_cs.hVideoExtOut = NULL;

   // Do we support overlay?
   m_cs.bHasOverlay = FALSE;
   if (videoOpen(&m_cs.hVideoExtOut, m_user.uVideoID, VIDEO_EXTERNALOUT) ==
								DV_ERR_OK) {
	CHANNEL_CAPS VideoCapsExternalOut;
        if (m_cs.hVideoExtOut && videoGetChannelCaps(m_cs.hVideoExtOut,
                &VideoCapsExternalOut, sizeof(CHANNEL_CAPS)) == DV_ERR_OK) {
            m_cs.bHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags &
                				(DWORD)VCAPS_OVERLAY);
        } else {
            DbgLog((LOG_TRACE,2,TEXT("*** ERROR calling videoGetChannelCaps")));
	}
   } else {
       DbgLog((LOG_ERROR,1,TEXT("*** ERROR opening VIDEO_EXTERNALOUT")));
   }

   // VidCap does this, so I better too or some cards will refuse to preview
   if (m_cs.mmr == 0)
       videoStreamInit(m_cs.hVideoExtIn, 0, 0, 0, 0);

   if (m_pCap->m_fAvoidOverlay) {
       m_cs.bHasOverlay = FALSE;
   }

   if (m_cs.bHasOverlay)
       DbgLog((LOG_TRACE,1,TEXT("Driver supports OVERLAY")));
   else
       DbgLog((LOG_TRACE,1,TEXT("Driver does NOT support OVERLAY")));

   return S_OK;
}

HRESULT
CCapStream::DisconnectFromDriver()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::DisconnectFromDriver")));

   if (m_cs.hVideoIn)
      videoClose (m_cs.hVideoIn);
   if (m_cs.hVideoExtIn) {
      videoStreamFini(m_cs.hVideoExtIn);	// this one was streaming
      videoClose (m_cs.hVideoExtIn);
   }
   if (m_cs.hVideoExtOut)
      videoClose (m_cs.hVideoExtOut);
   return S_OK;
}

HRESULT
CCapStream::InitPalette ()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::InitPalette")));

   struct {
      WORD         wVersion;
      WORD         wNumEntries;
      PALETTEENTRY aEntry[256];
      } pal;
   ZeroMemory(&pal, sizeof(pal));
   pal.wVersion = 0x0300;
   pal.wNumEntries = 256;

   // if we are connected to a driver. query it for its
   // palette, otherwise use the default system palette
   //
   if ( ! m_cs.hVideoIn ||
        DV_ERR_OK  != videoConfigure (m_cs.hVideoIn,
                                      DVM_PALETTE,
                                      VIDEO_CONFIGURE_GET
                                      | VIDEO_CONFIGURE_CURRENT,
                                      NULL,
                                      &pal,
                                      sizeof(pal),
                                      NULL,
                                      0))
      {
      HPALETTE hPal = (HPALETTE)GetStockObject (DEFAULT_PALETTE);
      GetObject (hPal, sizeof(pal.wNumEntries), &pal.wVersion);
      ASSERT (pal.wNumEntries <= NUMELMS(pal.aEntry));
      pal.wNumEntries = (WORD)min(pal.wNumEntries,NUMELMS(pal.aEntry));
      GetPaletteEntries(hPal, 0, pal.wNumEntries, pal.aEntry);
      }

   // convert the palette into a bitmapinfo set of RGBQUAD's
   //
   ASSERT (m_user.pvi);
   RGBQUAD *      pRGB = ((LPBITMAPINFO)&m_user.pvi->bmiHeader)->bmiColors;
   PALETTEENTRY * pe   = pal.aEntry;
   for (UINT ii = 0; ii < (UINT)pal.wNumEntries; ++ii, ++pRGB, ++pe)
      {
      pRGB->rgbBlue  = pe->peBlue;
      pRGB->rgbGreen = pe->peGreen;
      pRGB->rgbRed   = pe->peRed;
      //pRGB->rgbReserved = pe->peFlags;
      }

   m_user.pvi->bmiHeader.biClrUsed = pal.wNumEntries;

   return S_OK;
}

//
// tell the driver what format to use
//
HRESULT CCapStream::SendFormatToDriver(VIDEOINFOHEADER *pvi)
{
    DbgLog((LOG_TRACE,2,TEXT("CCapStream::SendFormatToDriver")));

    ASSERT (m_cs.hVideoIn && pvi);
    if (!m_cs.hVideoIn || !pvi)
	return E_FAIL;

    if (videoConfigure(m_cs.hVideoIn,
                      DVM_FORMAT,
                      VIDEO_CONFIGURE_SET, NULL,
                      &pvi->bmiHeader,
                      pvi->bmiHeader.biSize,
                      NULL, 0))
	return VFW_E_INVALIDMEDIATYPE;

// nobody really supports VIDEOIN source or dest rectangles.  Even if they
// did, I'm not sure what I should do about it
#if 0
    // If we have specific rectangles, use them, otherwise use Width x Height
    DWORD dwErrSrc, dwErrDst;
    if (pvi->rcSource.right && pvi->rcSource.bottom) {
	dwErrSrc = vidxSetRect(m_cs.hVideoIn, DVM_SRC_RECT, pvi->rcSource.left,
		pvi->rcSource.top, pvi->rcSource.right, pvi->rcSource.bottom);
    } else {
	dwErrSrc = vidxSetRect(m_cs.hVideoIn, DVM_SRC_RECT, 0, 0,
		pvi->bmiHeader.biWidth, pvi->bmiHeader.biHeight);
    }

    if (pvi->rcTarget.right && pvi->rcTarget.bottom) {
	dwErrDst = vidxSetRect(m_cs.hVideoIn, DVM_DST_RECT, pvi->rcTarget.left,
		pvi->rcTarget.top, pvi->rcTarget.right, pvi->rcTarget.bottom);
    } else {
	dwErrDst = vidxSetRect(m_cs.hVideoIn, DVM_DST_RECT, 0, 0,
		pvi->bmiHeader.biWidth, pvi->bmiHeader.biHeight);
    }
#endif

    // !!! Do I need to set the palette too?  Do I care?

    return S_OK;
}

//
// ask the driver what format to use, and stuff that in our internal VIDEOINFOH
// Use the current VIDEOINFOHEADER's data rate and frame rate
//
HRESULT CCapStream::GetFormatFromDriver ()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapStream::GetFormatFromDriver")));

    ASSERT (m_cs.hVideoIn);
    if ( ! m_cs.hVideoIn)
	return E_FAIL;

    // How large is the BITMAPINFOHEADER?
    DWORD biSize = 0;
    videoConfigure(m_cs.hVideoIn, DVM_FORMAT,
                   VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE,
                   &biSize, 0, 0, NULL, 0);
    if ( ! biSize)
	biSize = sizeof (BITMAPINFOHEADER);

    // allocate space for a videoinfo that will hold it
    //
    UINT cb = sizeof(VIDEOINFOHEADER)
             + biSize - sizeof(BITMAPINFOHEADER)
             + sizeof(RGBQUAD) * 256;	// space for PALETTE or BITFIELDS
    VIDEOINFOHEADER * pvi = (VIDEOINFOHEADER *)(new BYTE[cb]);
    
    if ( ! pvi)
	    return E_OUTOFMEMORY;
    LPBITMAPINFOHEADER pbih = &pvi->bmiHeader;
    

    if (videoConfigure(m_cs.hVideoIn, DVM_FORMAT,
                       VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL,
                       pbih, biSize, NULL, 0)) {
	// very bad. the driver can't tell us its format. we're hosed.
	ASSERT(!"Cant get format from driver");
    delete [] (BYTE *) pvi;
	return E_FAIL;
    }

    if (pvi->bmiHeader.biSizeImage == 0 &&
			(pvi->bmiHeader.biCompression == BI_RGB ||
			pvi->bmiHeader.biCompression == BI_BITFIELDS)) {
        DbgLog((LOG_TRACE,2,TEXT("Fixing biSizeImage from a broken driver")));
	pvi->bmiHeader.biSizeImage = DIBSIZE(pvi->bmiHeader);
    }

    // dont require that we've already got a videoinfo, but
    // we expect it. so assert that it's true.
    //
    ASSERT (m_user.pvi);
    if (m_user.pvi) {

	// I assuming preserving these is the best philosophy
	pvi->rcSource = m_user.pvi->rcSource;
	pvi->rcTarget = m_user.pvi->rcTarget;
	pvi->dwBitRate = m_user.pvi->dwBitRate;
	pvi->dwBitErrorRate = m_user.pvi->dwBitErrorRate;
	pvi->AvgTimePerFrame = m_user.pvi->AvgTimePerFrame;

// Do not touch the source and target rectangles.  Leave them as they were.
// This won't compile anyway
#if 0
	RECT rcSrc, rcDst;
        DWORD dwErrSrc = 1, dwErrDst = 1;

	// This won't compile
	dwErrSrc = videoMessage(m_cs.hVideoIn, DVM_SRC_RECT, &rcSrc,
				CONFIGURE_GET | CONFIGURE_GET_CURRENT);
	dwErrDst = videoMessage(m_cs.hVideoIn, DVM_DST_RECT, &rcDst,
				CONFIGURE_GET | CONFIGURE_GET_CURRENT);

	if (dwErrSrc || dwErrDst)
	    DbgLog((LOG_ERROR,1,TEXT("vidxGetRect FAILED!")));

	if (dwErrSrc == 0 && rcSrc.right && rcSrc.bottom) {
	    pvi->rcSource.left = rcSrc.left;
	    pvi->rcSource.top = rcSrc.top;
	    pvi->rcSource.right = rcSrc.right;
	    pvi->rcSource.bottom = rcSrc.bottom;
	} else {
	    pvi->rcSource.left = pvi->rcSource.top = 0;
	    pvi->rcSource.right = pvi->bmiHeader.biWidth;
	    pvi->rcSource.bottom = pvi->bmiHeader.biHeight;
	}
	if (dwErrDst == 0 && rcDst.right && rcDst.bottom) {
	    pvi->rcTarget.left = rcDst.left;
	    pvi->rcTarget.top = rcDst.top;
	    pvi->rcTarget.right = rcDst.right;
	    pvi->rcTarget.bottom = rcDst.bottom;
	} else {
	    pvi->rcTarget.left = pvi->rcTarget.top = 0;
	    pvi->rcTarget.right = pvi->bmiHeader.biWidth;
	    pvi->rcTarget.bottom = pvi->bmiHeader.biHeight;
	}
#endif

	delete [] m_user.pvi;
    }

    m_user.pvi = pvi;
    m_user.cbFormat = cb;

    // BOGUS cap is broken and doesn't reset num colours
    // WINNOV reports 256 colours of 24 bit YUV8 - scary!
    if (m_user.pvi->bmiHeader.biBitCount > 8)
	m_user.pvi->bmiHeader.biClrUsed = 0;

    return S_OK;
}


// called when stopping. flush any buffers that may
// be still downstream
HRESULT
CCapStream::Flush()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::Flush")));

   BeginFlush();
   EndFlush();

   return S_OK;
}

HRESULT
CCapStream::Prepare()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::Prepare")));

   HRESULT hr = E_OUTOFMEMORY;
   m_cs.paHdr = NULL;
   m_cs.hEvtBufferDone = NULL;
   m_cs.h0EvtBufferDone = 0;
   m_cs.llLastTick = (LONGLONG)-1;
   m_cs.uiLastAdded = (UINT)-1;
   m_cs.dwFirstFrameOffset = 0;
   m_cs.llFrameCountOffset = 0;
   m_cs.fReRun = FALSE;
   m_cs.rtLastStamp = 0;
   m_cs.rtDriverLatency = -1;	// not set yet
   m_cs.fLastSampleDiscarded = FALSE;
   //m_cs.cbVidHdr = sizeof(VIDEOHDREX);
   m_cs.cbVidHdr = sizeof(VIDEOHDR);

   // reset stats every time we stream
   m_capstats.dwlNumDropped = 0;
   m_capstats.dwlNumCaptured = 0;
   m_capstats.dwlTotalBytes = 0;
   m_capstats.msCaptureTime = 0;
   m_capstats.flFrameRateAchieved = 0.;
   m_capstats.flDataRateAchieved = 0.;

   // can't do anything if no videoformat has been choosen
   //
   if ( ! m_user.pvi)
      {
      DbgLog((LOG_ERROR,1,TEXT("no video format chosen")));
      goto bail;
      }

   m_cs.hEvtBufferDone = CreateEvent (NULL, FALSE, FALSE, NULL);
   if (!m_cs.hEvtBufferDone)
      {
      DbgLog((LOG_ERROR,1,TEXT("failed to create buffer done event")));
      goto bail;
      }

#ifndef _WIN64
   m_cs.h0EvtBufferDone = OpenVxDHandle(m_cs.hEvtBufferDone);
#else
   m_cs.h0EvtBufferDone = (DWORD_PTR)m_cs.hEvtBufferDone;
#endif
   if (!m_cs.h0EvtBufferDone)
      {
      DbgLog((LOG_ERROR,1,TEXT("failed to create event's Ring 0 handle")));
      goto bail;
      }

   // for each buffer, allocate the user requested size
   // Also, align allocation size up to nearest align boundary
   //
   m_cs.cbBuffer = m_Alloc.parms.cbPrefix + m_Alloc.parms.cbBuffer;
   ASSERT(m_user.pvi->bmiHeader.biSizeImage + m_Alloc.parms.cbPrefix
				<= m_cs.cbBuffer);
   // Allocate cbAlign bytes too much so we can align the buffer start
   m_cs.cbBuffer += m_Alloc.parms.cbAlign;

   // try to get the requested number of buffers, but make sure
   // to get at least MIN_VIDEO_BUFFERS and no more than MAX_VIDEO_BUFFERS
   //
   m_cs.nHeaders = max(m_Alloc.parms.cBuffers, (long)m_user.nMinBuffers);
   m_cs.nHeaders = min(m_cs.nHeaders, m_user.nMaxBuffers);

   // limit the number of buffers to the amount of physical
   // memory (since we will try to keep them all locked down
   // at once)
   //
   if (m_cs.nHeaders > m_user.nMinBuffers)
      {
      DWORD_PTR dwFree;
      DWORDLONG dwlUser;

      // How much actual free physical memory exists?
      dwFree = GetFreePhysicalMemory();

      // How much memory will be used if we allocate per the request?
      dwlUser = (m_cs.cbBuffer * m_cs.nHeaders);

      DbgLog((LOG_TRACE,2,TEXT("Buffers take up %d bytes, phys mem=%d"),
						(DWORD)dwlUser, dwFree));

      // If request is greater than available memory, force fewer buffers
      //
      if (dwlUser > (DWORDLONG)dwFree)
         {
	 // only use up 80% of physical memory
         m_cs.nHeaders = (UINT)(((dwFree * 8) / 10) / m_cs.cbBuffer);
         m_cs.nHeaders = min (m_user.nMaxBuffers, m_cs.nHeaders);
         m_cs.nHeaders = max (m_user.nMinBuffers, m_cs.nHeaders);
         }
      }

   DbgLog((LOG_TRACE,2,TEXT("We are trying to get %d buffers"), m_cs.nHeaders));

   // allocate headers for all of the buffers that we will be using
   //
   if (vidxAllocHeaders(m_cs.hVideoIn,
                        m_cs.nHeaders,
                        sizeof(m_cs.paHdr[0]),
                        (LPVOID *)&m_cs.paHdr))
      {
      DbgLog((LOG_ERROR,1,TEXT("vidxAllocHeaders failed")));
      goto bail;
      }

   // allocate each buffer, if buffer allocation ever fails
   // just set the number of buffers to the number of successes
   // and continue on.
   //
   UINT ii;
   for (ii = 0; ii < m_cs.nHeaders; ++ii)
      {
      LPTHKVIDEOHDR ptvh;

      if (vidxAllocBuffer (m_cs.hVideoIn, ii, (LPVOID *)&ptvh, m_cs.cbBuffer))
          break;
      ASSERT (ptvh == &m_cs.paHdr[ii].tvh);
      ASSERT (!IsBadWritePtr(ptvh->p32Buff, m_cs.cbBuffer));

      // fix the memory we got to obey alignment
      ptvh->vh.lpData = (LPBYTE) ALIGNUP(ptvh->p32Buff, m_Alloc.parms.cbAlign) +
							m_Alloc.parms.cbPrefix;
      // we added cbAlign up top, so take it back now
      ptvh->vh.dwBufferLength = m_cs.cbBuffer - m_Alloc.parms.cbAlign -
							m_Alloc.parms.cbPrefix;

      ptvh->vh.dwBytesUsed = 0;
      ptvh->vh.dwTimeCaptured = 0;
      ptvh->vh.dwFlags = 0;

      ptvh->dwIndex = ii;	// Which buffer is this?

      ASSERT (!IsBadWritePtr(ptvh->vh.lpData, ptvh->vh.dwBufferLength));
      DbgLog((LOG_TRACE,4,TEXT("Alloc'd: ptvh %08lX, buffer %08lX, size %d, p32 %08lX, p16 %08lX"),
           ptvh, ptvh->vh.lpData, ptvh->vh.dwBufferLength, ptvh->p32Buff, ptvh->p16Alloc));

      hr = S_OK;
      CFrameSample * pSample = new CFrameSample(&m_Alloc, &hr, ptvh);
      DbgLog((LOG_TRACE,4,TEXT("Buffer[%d] ptvh = %08lX pSample = %08lX"),
						ii, ptvh, pSample));
      ptvh->dwUser = (DWORD_PTR)pSample;
      if (FAILED(hr) || ! pSample)
         {
         DbgLog((LOG_ERROR,1,TEXT("Failed to create CFrameSample for buffer %d")
									, ii));
         break;
         }
      }
   m_cs.nHeaders = ii;

   // This is where we will remember in what order we gave the buffers to 
   // the driver
   m_pBufferQueue = (UINT *)QzTaskMemAlloc(ii * sizeof(UINT));
   //DbgLog((LOG_TRACE,5,TEXT("QUEUE: got space for %d frames"), ii));

   if (m_cs.nHeaders < m_user.nMinBuffers)
      {
      DbgLog((LOG_ERROR,1,TEXT("FAIL: %d is less than MIN_VIDEO_BUFFERS"),
								m_cs.nHeaders));
      hr = E_FAIL;
      goto bail;
      }

#ifdef TIME_DRIVER	// !!!
    long ms;
#endif

   // calculate the requested microsec per frame
   // RefTime is in 100ns units, so we divide by
   // 10 to get microsec/frame. (the +5 is to handle rounding)
   //
   {
   m_user.usPerFrame = (DWORD) ((TickToRefTime(1) + 5) / 10);

   // Open the driver for streaming access
   //
   hr = E_FAIL;
   DbgLog((LOG_TRACE,1,TEXT("Initializing with %d usPerFrame"),
						m_user.usPerFrame));

#ifdef TIME_DRIVER 	// !!!
   ms = timeGetTime();
#endif

   if (videoStreamInit(m_cs.hVideoIn,
                       m_user.usPerFrame,
                       m_cs.h0EvtBufferDone,
                       0,
                       CALLBACK_EVENT))
      {
      DbgLog((LOG_ERROR,1,TEXT("videoStreamInit failed")));
      goto bail;
      }
   }

   for (ii = 0; ii < m_cs.nHeaders; ++ii)
      {
      ASSERT (m_cs.cbVidHdr >= sizeof(VIDEOHDR));

      // vidxAddBuffer can fail if there is not enough memory to
      // prepare (lock down) the buffer. This is ok, we will just
      // make due with the buffers that we have
      //
      if (vidxAddBuffer(m_cs.hVideoIn,
                        &m_cs.paHdr[ii].tvh.vh,
                        m_cs.cbVidHdr))
         {

// legacy VFW capture filter makes no attempt at time code/line 21
#if 0
         // if the first request to queue up an extended header
         // failed. try again with old size videohdr.
         //
         if (0 == ii && m_cs.cbVidHdr > sizeof(VIDEOHDR))
            {
            // if we succeed with the smaller header, continue on
            // otherwise, go deal with the failure.
            //
	    // Eliminate the extended VIDEOHDR stuff?
            m_cs.cbVidHdr = sizeof(VIDEOHDR);
            if ( !vidxAddBuffer(m_cs.hVideoIn,
                                &m_cs.paHdr[ii].tvh.vh,
                                m_cs.cbVidHdr))
               continue;
            }
#endif

         // free all of the pSamples that we will not be using
         //
         for (UINT jj = ii; jj < m_cs.nHeaders; ++jj)
            {
            CFrameSample * pSample = (CFrameSample *)m_cs.paHdr[jj].tvh.dwUser;
            m_cs.paHdr[jj].tvh.dwUser = 0;
            delete pSample;
            }

         // set the buffer count to the number of prepared buffers
         // note, we have no method of freeing the allocated but
         // unprepared buffers.  we will ignore them for now and free
         // them when Unprepare()
	 // I guess vidxFreeHeaders frees them all?
         //
         m_cs.nHeaders = ii;
         break;
         }
      }

      // To start with, we gave the buffers to the driver in numerical order.
      // From now on, we will use this list to know what buffer to wait for
      // next, and when we send another buffer to the driver.  We can't assume
      // they'll always be in the same order.  What if a downstream filter
      // decides to hold on to a sample longer than the next one we send it?
      UINT kk;
      for (kk = 0; kk < m_cs.nHeaders; kk++)
	  m_pBufferQueue[kk] = kk;
      m_uiQueueHead = 0;
      m_uiQueueTail = 0;

#ifdef TIME_DRIVER	// !!!
      char ach[80];
      wsprintf(ach, "Took %d ms", timeGetTime() - ms);
      MessageBox(NULL, ach, ach, MB_OK);
#endif

   DbgLog((LOG_TRACE,1,TEXT("We are capturing with %d buffers"),m_cs.nHeaders));

   // if we have 0 buffers to capture into DO NOT BAIL... bad things seem to
   // happen if you fail a Pause transition, and we start hanging later

   return S_OK;

bail:
   Unprepare();
   return hr;
}

HRESULT
CCapStream::Unprepare()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapStream::Unprepare")));

    LONG lNotDropped, lDropped, lAvgFrameSize;
#ifdef DEBUG
    LONG lDroppedInfo[NUM_DROPPED], lSize;
#endif

    // Why not use our official interface to test it
    GetNumDropped(&lDropped);
    GetNumNotDropped(&lNotDropped);
    GetAverageFrameSize(&lAvgFrameSize);

    if (m_capstats.msCaptureTime) {
        m_capstats.flFrameRateAchieved = (double)(LONGLONG)lNotDropped * 1000. /
				(double)(LONGLONG)m_capstats.msCaptureTime;
        m_capstats.flDataRateAchieved = (double)(LONGLONG)lNotDropped
				/ (double)(LONGLONG)m_capstats.msCaptureTime *
 				1000. * (double)(LONGLONG)lAvgFrameSize;
    } else {
	// !!! If no frames captured, it will think msCaptureTime = 0
        m_capstats.flFrameRateAchieved = 0.;
        m_capstats.flDataRateAchieved = 0.;
    }

#ifdef DEBUG
    GetDroppedInfo(NUM_DROPPED, lDroppedInfo, &lSize);

    DbgLog((LOG_TRACE,1,TEXT("Captured %d frames in %d seconds"),
				lNotDropped,
				(int)(m_capstats.msCaptureTime / 1000)));
    DbgLog((LOG_TRACE,1,TEXT("Frame rate acheived %d.%d fps"),
					(int)m_capstats.flFrameRateAchieved,
					(int)((m_capstats.flFrameRateAchieved -
					(int)m_capstats.flFrameRateAchieved)
					* 10)));
    DbgLog((LOG_TRACE,1,TEXT("Data rate acheived %d bytes/sec"),
					(int)m_capstats.flDataRateAchieved));
    DbgLog((LOG_TRACE,1,TEXT("Dropped %d frames"),
					lDropped));
    DbgLog((LOG_TRACE,1,TEXT("=================")));
    LONG l;
    for (l=0; l < lSize; l++)
    {
        DbgLog((LOG_TRACE,2,TEXT("%d"), (int)lDroppedInfo[l]));
    }
#endif

   // Delete the Preview frame sample
   // The preview buffer is implicitly freed by closing the driver
   delete m_cs.pSamplePreview;
   //ZeroMemory (&m_cs.tvhPreview, sizeof(m_cs.tvhPreview));
   m_cs.pSamplePreview = NULL;

   for (UINT ii = 0; ii < m_cs.nHeaders; ++ii)
      {
      delete (CFrameSample *)m_cs.paHdr[ii].tvh.dwUser;
      // The buffer itself will be freed with the headers.
      }

   if (m_cs.hVideoIn)
      {
      videoStreamReset (m_cs.hVideoIn);
      vidxFreeHeaders (m_cs.hVideoIn);
      m_cs.paHdr = NULL;
      videoStreamFini (m_cs.hVideoIn);
      }

   //DbgLog((LOG_TRACE,5,TEXT("QUEUE: freeing queue")));
   if (m_pBufferQueue)
       QzTaskMemFree(m_pBufferQueue);
   m_pBufferQueue = NULL;

   if (m_cs.hEvtBufferDone)
      CloseHandle (m_cs.hEvtBufferDone), m_cs.hEvtBufferDone = NULL;

   m_cs.nHeaders = 0;
   return S_OK;
}

// returns S_FALSE if the pin is off (IAMStreamControl)
//
HRESULT
CCapStream::SendFrame (
   LPTHKVIDEOHDR ptvh,
   BOOL          bDiscon,
   BOOL          bPreroll)
{
   DWORDLONG dwlTimeCaptured;

   DbgLog((LOG_TRACE,5,TEXT("CCapStream::SendFrame")));

   HRESULT hr = S_OK;
   CFrameSample * pSample = (CFrameSample *)ptvh->dwUser;

   // this was set up already, but maybe somebody has overwritten it?
   // ptvh->vh.lpData = (LPBYTE) ALIGNUP(ptvh->p32Buff, m_Alloc.parms.cbAlign) + m_Alloc.parms.cbPrefix;

   // Even though the capture time is reported in ms, some drivers internally
   // use us and wrap around every 72 minutes!! this is really bad,
   // we need to figure out the non-wrapped time, or we'll think every
   // frame is old and stop capturing!!
   dwlTimeCaptured = ptvh->vh.dwTimeCaptured + m_cs.dwlTimeCapturedOffset;
   // could wrap at 4,294,967ms if buggy driver wraps microsecs internally
   if (dwlTimeCaptured < m_cs.dwlLastTimeCaptured &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured > 4000000 &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured < 4400000) {
	dwlTimeCaptured += 4294967;
	m_cs.dwlTimeCapturedOffset += 4294967;
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
	DbgLog((LOG_TRACE,1,TEXT("******  MICROSECONDS WRAPPED  *******")));
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
   }
   // WILL wrap at 4,294,967,296ms
   if (dwlTimeCaptured < m_cs.dwlLastTimeCaptured &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured > 4000000000 &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured < 4400000000) {
	dwlTimeCaptured += 4294967296;
	m_cs.dwlTimeCapturedOffset += 4294967296;
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
	DbgLog((LOG_TRACE,1,TEXT("******  MILLISECONDS WRAPPED  *******")));
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
   }
   m_cs.dwlLastTimeCaptured = dwlTimeCaptured;

   // what frame number is this (based on the time captured)?  Round such that
   // if frames 1 and 2 are expected at 33 and 66ms, anything from 17 to 49 will
   // considered frame 1.
   //
   // frame = ((ms + 1/2(ms per frame)) * rate) / (1000 * scale);
   //
   // then we add an offset if we so desire
   //
   DWORDLONG dwlTick = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset +
			m_user.usPerFrame / 2000) * m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;
   ASSERT (dwlTick < (DWORDLONG)0x100000000);

   // Now what frame number would this be using a different algorithm,
   // considering anything from 33 to 65ms to be frame 1?
   //
   DWORDLONG dwlTickPrime = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset) *
			m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;

   // If we are RUN, and frames 0-10 come through, then we are PAUSEd and RUN
   // again, the first thing coming through may be frame 11 left over from the
   // first RUN, and then they'll start back at 0 again (the driver starts over
   // again).  This confuses our time stamping, becuase we are supposed to send
   // 9 10 11 12 13 not 9 10 11 0 1 2.  We will wait for the first back-in-time
   // we see after being re-run, and add an offset to each frame number to
   // keep stamping the numbers where we left off.
   //
   // We could mess up if we get a wacky back in time thing for another
   // reason!
   if (m_cs.fReRun && m_cs.llLastTick != -1 &&
				dwlTick < (DWORDLONG)m_cs.llLastTick) {
	m_cs.fReRun = FALSE;	// don't do this again
	m_cs.llFrameCountOffset = m_cs.llLastTick + 1;
	m_cs.llLastTick = -1;	// force recalc of new first frame offset
	DbgLog((LOG_TRACE,2,TEXT("Add %d to frame numbers cuz we were re-run"),
						(int)m_cs.llFrameCountOffset));
   }

   // This is the first thing we've captured.  Or, we just noticed above that
   // we've been rerun.
   if (m_cs.llLastTick == -1) {

        // !!! The driver may capture a frame and take forever to tell us,
	// so the current clock time when we notice a frame is captured is
	// NOT correct.  To prevent sync from being off we will assume that
	// this latency is the always the same as the first latency.  We will
	// see how much time elapsed between starting the capture process
	// and us noticing a frame was captured, and subtract the time the
	// driver says it took to capture the first frame (over this short
	// an interval we'll assume the two clocks are in sync)
	// !!! quick cam says 1st frame is captured after 64 frames have been
	// captured, and this inflates the latency and breaks sync.  I better
	// do this test with only 1 buffer outstanding?
	if (m_cs.rtDriverLatency < 0) { // only once please, or that's bad
	    m_cs.rtDriverLatency = m_cs.rtThisFrameTime - m_cs.rtDriverStarted -
				(LONGLONG)dwlTimeCaptured * 10000;
	    if (m_cs.rtDriverLatency < 0)
	        m_cs.rtDriverLatency = 0;	// don't laugh...
	    DbgLog((LOG_TRACE,1,TEXT("Driver latency appears to be %dms"),
				(int)(m_cs.rtDriverLatency / 10000)));
	}

	// !!! Using a FirstFrameOffset was my way of making the first frame
	// we capture always look like frame #0, so we never drop the first
 	// frame.  But that messed up the RUN-PAUSE-RUN case (after re-running
  	// dwlTick would be 20 million) and it also could mess sync up.
	// m_cs.dwFirstFrameOffset = dwlTimeCaptured;
	m_cs.dwFirstFrameOffset = 0;

	// new offset, recalculate
        dwlTick = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset +
			m_user.usPerFrame / 2000) * m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;
        dwlTickPrime = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset) *
			m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;
	m_cs.llLastTick = (LONGLONG)dwlTick - 1; // don't think we've dropped
	DbgLog((LOG_TRACE,2,TEXT("First frame captured %dms after streaming"),
						dwlTimeCaptured));
	if (m_cs.dwFirstFrameOffset > m_user.usPerFrame / 1000)
	    DbgLog((LOG_ERROR,1,TEXT("*** Boy, the first frame arrived late! (%dms)"),
						dwlTimeCaptured));
   }

   if (ptvh->vh.dwBytesUsed)
   {
      // !!! It isn't necessarily a keyframe, I can't tell
      pSample->SetSyncPoint (ptvh->vh.dwFlags & VHDR_KEYFRAME);
      pSample->SetActualDataLength (ptvh->vh.dwBytesUsed);
      // !!! isn't it a discontinuity if we dropped the last frame, too?
      // For us all-key frame guys, it probably doesn't matter
      pSample->SetDiscontinuity(bDiscon);
      pSample->SetPreroll(bPreroll);

      // Here's the thing.  If we are expecting frames at 10, 20, 30, 40 ms,
      // but we see them at 9, 24, 36, 43, we should say "close enough" and
      // capture the four frames.  But we normally round such that frame 3
      // is anything from 25-34ms, so we'll think we got frame 1, 2, 4, 4
      // and drop a frame.  So we also have dwlTickPrime, which is the frame
      // number rounded such that anything from 30-39 is considered frame 3.
      // So if dwlTick thinks 36 belongs as frame 4, but dwlTickPrime thinks
      // it belongs as frame 3, we'll admit it's probably frame three and not
      // needlessly drop a frame.  Using either dwlTick or dwlTickPrime alone
      // would both think a frame was dropped (either 3 or 1)
      if ((LONGLONG)dwlTick == m_cs.llLastTick + 2 &&
				(LONGLONG)dwlTickPrime == m_cs.llLastTick + 1)
	  dwlTick = dwlTickPrime;

      // !!! Do we need a dwlTickPrime2 for when Tick==LastTick and 
      //  !!! TickPrime2 == LastTick+1 ???

      // Use the clock's graph to mark the times for the samples.  The video
      // capture card's clock is going to drift from the graph clock, so you'll
      // think we're dropping frames or sending too many frames if you look at
      // the time stamps, so we have an agreement to mark the MediaTime with the
      // frame number so you can tell if any frames are dropped.
      // Use the time we got in Run() to determine the stream time.  Also add
      // a latency (HACK!) to prevent preview renderers from thinking we're
      // late.
      // If we are RUN, PAUSED, RUN, we won't send stuff smoothly where we
      // left off because of the async nature of pause.
      CRefTime rtSample;
      CRefTime rtEnd;
      if (m_pCap->m_pClock) {
	    // This sample's time stamp is (clock time when captured -
	    // clock time given in Run(rt) + !!! NO LATENCY FOR CAP PIN !!!)
      	    rtSample = m_cs.rtThisFrameTime 
                       - m_pCap->m_tStart
                       - m_cs.rtDriverLatency; // we add the offset in SetTime
                       // + m_user.dwLatency;
      	    rtEnd    = rtSample + m_user.pvi->AvgTimePerFrame;
            DbgLog((LOG_TRACE,4,TEXT("driver stamp %d, stream time is %d"),
				(LONG)dwlTimeCaptured,
				(LONG)rtSample.Millisecs()));
      } else {
	    // no clock, use our driver time stamps
      	    rtSample = TickToRefTime((DWORD)dwlTick);
      	    rtEnd    = rtSample + m_user.pvi->AvgTimePerFrame;
            DbgLog((LOG_ERROR,1,TEXT("No clock! Stream time is %d"),
					(LONG)rtSample.Millisecs()));
      }
      LONGLONG llStart = dwlTick;
      LONGLONG llEnd = dwlTick + 1;
      pSample->SetMediaTime(&llStart, &llEnd);

      // when we're adding offsets to our timestamps we need to do more work...
      // because since stream control will block we can't give it
      // sample times which use the stream offset.
      // Since CheckStreamState takes a sample but only needs the start and
      // end times for it we need to call SetTime on the sample twice, once
      // for stream control (without the offset) and again before we deliver
      // (with the offset).

      pSample->SetTime((REFERENCE_TIME *)&rtSample, (REFERENCE_TIME *)&rtEnd);

      // IAMStreamControl stuff.  Has somebody turned us off for now?
      int iStreamState = CheckStreamState(pSample);
      if (iStreamState == STREAM_FLOWING) {
          DbgLog((LOG_TRACE,4,TEXT("*CAP Sending frame %d"), (int)llStart));
	  if (m_cs.fLastSampleDiscarded)
              pSample->SetDiscontinuity(TRUE);
	  m_cs.fLastSampleDiscarded = FALSE;
      } else {
          DbgLog((LOG_TRACE,4,TEXT("*CAPTURE Discarding frame %d"),
								(int)llStart));
	  m_cs.fLastSampleDiscarded = TRUE;
	  hr = S_FALSE;		// discarding
      }
      
      // now reset the time accounting for the stream offset if we've got a clock
      if( 0 < m_rtStreamOffset && m_pCap->m_pClock )
      {  
         REFERENCE_TIME rtOffsetStart = rtSample + m_rtStreamOffset;    
         REFERENCE_TIME rtOffsetEnd   = rtEnd + m_rtStreamOffset;    
         pSample->SetTime( (REFERENCE_TIME *) &rtOffsetStart
                         , (REFERENCE_TIME *) &rtOffsetEnd );
      }                         

      // Oh look.  This time stamp is less than the last time stamp we
      // delivered.  Not allowed!  We won't be delivering it.
      if (rtSample < m_cs.rtLastStamp)
            DbgLog((LOG_TRACE,1,TEXT("Avoiding sending a backwards in time stamp")));

      // This frame # might not be one higher than last frame #.  If not,
      // something funny is up.  If it's stamp is not higher than the last stamp
      // we delivered, it's not going to be delivered anyway, so who cares if
      // something funny is going on.  It shouldn't count as being dropped.
      // Ditto if this stream has been turned off for now
      if (iStreamState == STREAM_FLOWING && rtSample >= m_cs.rtLastStamp &&
				dwlTick != (DWORDLONG)(m_cs.llLastTick + 1)) {
	    if ((LONGLONG)dwlTick > m_cs.llLastTick + 1)
            {
                DbgLog((LOG_ERROR,1,TEXT("*** DROPPED %d frames: Expected %d got %d (%d)"),
				(int)(dwlTick - m_cs.llLastTick - 1),
	  			(DWORD)m_cs.llLastTick + 1, (DWORD)dwlTick,
				dwlTimeCaptured));
                MSR_INTEGER(m_perfWhyDropped, 1);
            }
	    else
            {
                DbgLog((LOG_ERROR,1,TEXT("*** TIME SHIFT: Expected %d got %d (%d)"),
	  			(DWORD)m_cs.llLastTick + 1, (DWORD)dwlTick,
				dwlTimeCaptured));
                MSR_INTEGER(m_perfWhyDropped, 2);
            }
	    DWORDLONG dwl;
	    for (dwl=(DWORDLONG)(m_cs.llLastTick + 1); dwl<dwlTick; dwl++)
	    {
		if (m_capstats.dwlNumDropped < NUM_DROPPED)
		    m_capstats.dwlDropped[m_capstats.dwlNumDropped] = dwl;
		m_capstats.dwlNumDropped++;
	    }
      }

      // Don't deliver it if it's a wierd backwards in time frame or if the
      // time stamp is earlier than the last one delivered or if the stream
      // is off for now
      if (iStreamState == STREAM_FLOWING && rtSample >= m_cs.rtLastStamp &&
			dwlTick > (DWORDLONG)m_cs.llLastTick) {
	  m_capstats.dwlTotalBytes += ptvh->vh.dwBytesUsed;
	  m_capstats.dwlNumCaptured++;
	  // !!! This won't work if we're RUN-PAUSE-RUN, it will only think
	  // we've been running for the time of the second RUN, but it counts
	  // ALL the frames captured in both!
	  // Also, this doesn't account for when the stream is turned off
	  m_capstats.msCaptureTime = dwlTimeCaptured - m_cs.dwFirstFrameOffset;
	  DbgLog((LOG_TRACE,3,TEXT("Stamps(%u): Time(%d,%d) MTime(%d) Drv(%d)"),
			m_pBufferQueue[m_uiQueueTail],
			(LONG)rtSample.Millisecs(), (LONG)rtEnd.Millisecs(),
			(LONG)llStart, dwlTimeCaptured));

          jmkBeforeDeliver(ptvh,dwlTick)
          hr = Deliver (pSample);
          jmkAfterDeliver(ptvh)
	  if (hr == S_FALSE)
		hr = E_FAIL;	// stop delivering anymore, this is serious

	  m_cs.rtLastStamp = rtSample;	// this is the last stamp delivered
      }

      if (rtSample >= m_cs.rtLastStamp &&
			dwlTick > (DWORDLONG)m_cs.llLastTick) {
	  // don't just update this if we're FLOWING, or we'll think we
	  // dropped all the samples during the time we were DISCARDING
	  // rtLastStamp will be equal to rtSample if we delivered it.
          m_cs.llLastTick = dwlTick;
      }

   } else {
      DbgLog((LOG_ERROR,1,TEXT("*** BUFFER (%08lX %ld %lu) returned EMPTY!"),
			pSample, (DWORD)dwlTick, dwlTimeCaptured));
   }

   return hr;
}

HRESULT
CCapStream::ReleaseFrame (
   LPTHKVIDEOHDR ptvh)
{

   HRESULT hr = S_OK;

   // when the preview buffer is released, it doesn't get queued
   // back to the capture driver. other buffers do.
   //
   if (ptvh == &m_cs.tvhPreview)
      return S_OK;

   DDSURFACEDESC SurfaceDesc;
   SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);

   bool fPrimaryLocked = false;

   // lock our ddraw surface so that we take the win16 lock. On Win9x,
   // we may be called with the win16 lock held. Since vidxAddBuffer
   // takes the win16 lock, we can't guarantee m_ReleaseLock and the
   // win16 lock will be taken in the same order on each thread.
   // 
   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS) {
       if(m_pDrawPrimary) {
           fPrimaryLocked = SUCCEEDED(m_pDrawPrimary->Lock(
               0, &SurfaceDesc, DDLOCK_WAIT, (HANDLE) NULL));
       }
       // continue on failure risking incorrect operation.
   } else {
       m_ReleaseLock.Lock();
   }

   // just to be careful, make sure that the correct start
   // pointer is in place
   // Maybe somebody wrecked it, we are not read-only buffers
   ptvh->vh.lpData = (LPBYTE) ALIGNUP(ptvh->p32Buff, m_Alloc.parms.cbAlign) + m_Alloc.parms.cbPrefix;

   DbgLog((LOG_TRACE,4,TEXT("Giving buffer (%d) back to the driver"),
							ptvh->dwIndex));

   if (vidxAddBuffer(m_cs.hVideoIn,
                     &ptvh->vh,
                     m_cs.cbVidHdr)) {
       DbgLog((LOG_ERROR,1,TEXT("******* ADD BUFFER FAILED!")));
       hr = E_FAIL;
   } else {
        //DbgLog((LOG_TRACE,5,TEXT("PUT QUEUE: pos %d gets %d"), m_uiQueueHead, ptvh->dwIndex));
	m_pBufferQueue[m_uiQueueHead] = ptvh->dwIndex;
	if (++m_uiQueueHead >= m_cs.nHeaders)
	    m_uiQueueHead = 0;
   }

   if (++m_cs.uiLastAdded >= m_cs.nHeaders)
	m_cs.uiLastAdded = 0;
   if (m_cs.uiLastAdded != ptvh->dwIndex) {
        DWORD dw = m_cs.uiLastAdded;
        m_cs.uiLastAdded = ptvh->dwIndex;
	// Use dw to keep the above code fairly atomic... DPF will get prempted
        DbgLog((LOG_TRACE,4,TEXT("*** Out of order AddBuffer - %d not %d"),
							ptvh->dwIndex, dw));
   }

   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS) {
       if(fPrimaryLocked) {
           m_pDrawPrimary->Unlock(SurfaceDesc.lpSurface);
       }
   } else {
       m_ReleaseLock.Unlock();
   }

   return hr;
}


// Fake a preview stream by sending copies of some of our captured frames
//
HRESULT CCapStream::FakePreview(BOOL fForcePreview)
{
    LPTHKVIDEOHDR ptvhNext;
    static int iii = 0;
    UINT uiT, uiPreviewIndex;
    HRESULT hr = S_OK;
    CFrameSample *pSample;

    // no preview pin, no can do
    if (!m_pCap->m_pPreviewPin)
	return S_OK;

    // If the NEXT frame is not done yet, we have some spare time and can
    // send THIS frame to the preview guy to preview
    // We might be asked to preview no matter what (fForcePreview)
    // !!! Preview every 30th frame in case we never have time?
    // !!! Don't check next done flag, check # of queued buffers?
    // 
    // I am going to be clever and not preview the current frame we're
    // about to deliver out our capture pin, because that might be
    // 10 seconds or more old (we may have lots of buffering).  Rather I
    // will grovel through all the buffers the driver has been given and find
    // the most recent one that is DONE, and use that as our preview frame.
    //

    // we don't want a preview frame
    ptvhNext = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;
    if (!fForcePreview && (ptvhNext->vh.dwFlags & VHDR_DONE) && iii++ != 30)
	return S_OK;
		
    // find the most recent DONE frame
    uiPreviewIndex = m_uiQueueTail;
    if (fForcePreview || iii == 31) {
 	while (1) {
	    uiT = uiPreviewIndex + 1;
	    if (uiT == m_cs.nHeaders)
	        uiT = 0;
	    if (uiT == m_uiQueueHead)
		break;
	    if (!(m_cs.paHdr[m_pBufferQueue[uiT]].tvh.vh.dwFlags & VHDR_DONE))
		break;
	    uiPreviewIndex = uiT;
	}
    }

    // DO NOT addref and release this, or it will cause the the sample to
    // be given to the driver again and mess everything up!
    pSample = (CFrameSample *)m_cs.paHdr[m_pBufferQueue[uiPreviewIndex]].
								tvh.dwUser;
    iii = 0;
    DbgLog((LOG_TRACE,4,TEXT("Previewing buffer %d (capturing %d)"),
				m_pBufferQueue[uiPreviewIndex],
				m_pBufferQueue[m_uiQueueTail]));
	m_pCap->m_pPreviewPin->ReceivePreviewFrame(pSample,
    		m_cs.paHdr[m_pBufferQueue[uiPreviewIndex]].tvh.vh.dwBytesUsed);
    return hr;
}


HRESULT CCapStream::Capture()
{
   DbgLog((LOG_TRACE,1,TEXT("CCapStream::Capture")));

   HRESULT hr = E_FAIL;
   DWORD dwOldPrio = GetThreadPriority(GetCurrentThread());
   if (dwOldPrio != THREAD_PRIORITY_HIGHEST)
      SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

   // start streams
   //
   BOOL bDiscon = TRUE;

   // done by main thread on RUN
   // videoStreamStart(m_cs.hVideoIn);

   jmkBegin // begin perf logging

   // stream as long as we're running
   while (m_state == TS_Run && m_cs.nHeaders > 0)
   {
      LPTHKVIDEOHDR ptvh = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;

      DbgLog((LOG_TRACE,5,TEXT("Checking for done buffers [%d]"), m_pBufferQueue[m_uiQueueTail]));
      //DbgLog((LOG_TRACE,5,TEXT("GET QUEUE: pos %d says wait for %d"), m_uiQueueTail, m_pBufferQueue[m_uiQueueTail]));

      //for (UINT ii = 0; ii < m_cs.nHeaders; ++ii)
      //   AuxDebugDump (5, m_cs.paHdr+ii, sizeof(m_cs.paHdr[0].tvh));

      if (!(ptvh->vh.dwFlags & VHDR_DONE)) {
	 // STOP will hang until this event times out. So make sure this never
	 // waits across a state transition
	 // !!! PAUSE will still keep waiting until the timeout for slow rates
	 HANDLE hStuff[2] = {m_cs.hEvtBufferDone, m_hEvtRun};
         int i = WaitForMultipleObjects(2, hStuff, FALSE,
						m_user.usPerFrame / 500);

	 if (i == WAIT_TIMEOUT) {
      	     DbgLog((LOG_ERROR,1,TEXT("*** Waiting for buffer %d TIMED OUT!"),
						m_pBufferQueue[m_uiQueueTail]));
      	     //DbgLog((LOG_ERROR,1,TEXT("*** Driver starved or may not be sending callbacks!")));
         } else if (i == WAIT_OBJECT_0 && !(ptvh->vh.dwFlags & VHDR_DONE)) {
      	     DbgLog((LOG_ERROR,1,TEXT("*** GOT %d EVENT BUT NO DONE BIT!"),
						m_pBufferQueue[m_uiQueueTail]));
	 }
      } else {

	 // note the clock time as close as possible to the capturing of this
	 // frame.
	 // !!! The driver could capture it, wait 2 seconds, and then deliver it
	 // and this will really confuse the MUX who will not keep the file in
	 // sync unless it does the right thing.
	 // !!! If Deliver blocks on a frame, the next frame may be marked DONE
	 // but I'll take a long time before this code runs and stamp it wrong!
	 if (m_pCap->m_pClock)
         {     
	     m_pCap->m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtThisFrameTime);
         
             DbgLog((LOG_TRACE,15,TEXT("stream time when frame received %dms"),
		        	(LONG)(m_cs.rtThisFrameTime-m_pCap->m_tStart) ) );
         }
         jmkFrameArrives(ptvh, m_pBufferQueue[m_uiQueueTail])

   	 ptvh->vh.dwFlags &= ~VHDR_DONE;

	 if (m_pBufferQueue[m_uiQueueTail] == m_cs.uiLastAdded) {
   	     DbgLog((LOG_ERROR,1,TEXT("*** Danger Will Robinson! - card is STARVING")));
	 }

   	 CFrameSample * pSample = (CFrameSample *)ptvh->dwUser;
   	 pSample->AddRef();
         hr = SendFrame (ptvh, bDiscon, FALSE);

         bDiscon = FALSE;

	 // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
	 if (FAILED(hr)) {
	     // so the next time we enter this function we're ready to continue
             if (++m_uiQueueTail >= m_cs.nHeaders)
                 m_uiQueueTail = 0;
	     pSample->Release();
	     break;
         }

	 // If we have spare time, we'll send something out our preview pin
	 // If SendFrame returned S_FALSE, we are not capturing, so we will
	 // always preview since we know we can't hurt capture performance

	 FakePreview(hr == S_FALSE ? TRUE : FALSE);

	 // Please don't increment m_uiQueueTail until after the SendFrame
	 // and FakePreview
         if (++m_uiQueueTail >= m_cs.nHeaders)
            m_uiQueueTail = 0;

	 // now we're all done with this sample
	 pSample->Release();
      }
   }

   // the main thread will stop the capture because this thread probably hung
   // in Deliver going from run->pause and will never get to this line!
   // (The video renderer will hold samples in Receive in pause mode)
   // videoStreamStop (m_cs.hVideoIn);

   jmkEnd // stop perf logging

   SetThreadPriority (GetCurrentThread(), dwOldPrio);
   return hr;
}

#if 0
HRESULT
CCapStream::StillFrame()
{
   DbgLog((LOG_TRACE,1,TEXT("CCapStream::StillFrame")));
   MMRESULT mmr;
   HRESULT  hr = S_OK;
   LPTHKVIDEOHDR ptvh = &m_cs.tvhPreview;

   if ( ! ptvh->vh.lpData)
      {
      ZeroMemory (ptvh, sizeof(*ptvh));
      ptvh->vh.dwBufferLength = m_cs.cbBuffer;

      mmr = vidxAllocPreviewBuffer (m_cs.hVideoIn,
                                    (LPVOID *)&ptvh->vh.lpData,
                                    sizeof(ptvh->vh),
                                    m_cs.cbBuffer);
      if (mmr)
         return E_FAIL;

      // SendFrame expects to find a copy of the buffer pointer
      // in ptvh->p32Buff, so we need to put it there.
      //
      ptvh->p32Buff = ptvh->vh.lpData;

      // Is this aligned right?

      m_cs.pSamplePreview = new CFrameSample(&m_Alloc, &hr, &m_cs.tvhPreview);
      m_cs.tvhPreview.dwUser = (DWORD)m_cs.pSamplePreview;
      }

   hr = E_FAIL;
   mmr = vidxFrame (m_cs.hVideoIn, &ptvh->vh);
   if ( ! mmr)
      {
      ptvh->vh.dwTimeCaptured = 0;
      hr = SendFrame (ptvh, TRUE, TRUE);
      }

   return hr;
}
#endif


HRESULT CCapStream::DriverDialog(HWND hwnd, UINT uType, UINT uQuery)
{
    BOOL fMustReconnect = FALSE;
    DbgLog((LOG_TRACE,1,TEXT("CCapStream::DriverDialog")));

    HVIDEO hVideo = NULL;
    switch (uType)
    {
      case VIDEO_IN:
         hVideo = m_cs.hVideoIn;
	 fMustReconnect = (uQuery != VIDEO_DLG_QUERY);
         break;

      case VIDEO_EXTERNALIN:
         hVideo = m_cs.hVideoExtIn;
         break;


      case VIDEO_EXTERNALOUT:
         hVideo = m_cs.hVideoExtOut;
         break;
    }

    if (!hVideo)
        return E_INVALIDARG;

    // Before we bring the dialog up, make sure we're not streaming, or about to
    // Also make sure another dialog isn't already up (I'm paranoid)
    // Then don't allow us to stream any more while the dialog is up (we can't
    // very well keep the critsect for a day and a half).
    m_pCap->m_pLock->Lock();
    if (m_pCap->m_State != State_Stopped || m_pCap->m_fDialogUp) {
        m_pCap->m_pLock->Unlock();
	return E_UNEXPECTED;	// even queries should fail
    }
    if (uQuery != VIDEO_DLG_QUERY) {
        m_pCap->m_fDialogUp = TRUE;	// don't allow start streaming
    }
    m_pCap->m_pLock->Unlock();

    MMRESULT mmr = videoDialog(hVideo, hwnd, uQuery);

    if (mmr) {
        m_pCap->m_fDialogUp = FALSE;
        if (uQuery == VIDEO_DLG_QUERY)
            return S_FALSE;
        return E_FAIL;
    }

    if (mmr == 0 && fMustReconnect && uQuery != VIDEO_DLG_QUERY) {

        DbgLog((LOG_TRACE,1,TEXT("Changing output formats")));
        // The dialog changed the driver's internal format.  Get it again.
        GetFormatFromDriver();
        SendFormatToDriver(m_user.pvi);	// unnecessary, but AVICAP32 did it
        if (m_user.pvi->bmiHeader.biBitCount <= 8)
	    InitPalette();

        // Now reconnect us so the graph starts using the new format
        Reconnect(TRUE);
    }

    if (uQuery != VIDEO_DLG_QUERY)
        m_pCap->m_fDialogUp = FALSE;

    return S_OK;
}

HRESULT CCapStream::Reconnect(BOOL fCapturePinToo)
{
      HRESULT hr;

      if (fCapturePinToo && IsConnected()) {
         DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our streaming pin")));
         CMediaType cmt;
	 GetMediaType(0, &cmt);
	 hr = GetConnected()->QueryAccept(&cmt);
	 if (hr == S_OK) {
	    m_pCap->m_pGraph->Reconnect(this);
	 } else {
            DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr;
#if 0
            // This will fail if we switch from 8 bit to 16 bit RGB connected
            // to a renderer that needs a colour converter inserted to do 16 bit
	    // Oh boy.  We're going to have to get clever and insert some
	    // filters between us to help us reconnect
            DbgLog((LOG_TRACE,1,TEXT("Whoa! We *really* need to reconnect!")));
	    IPin *pCon = GetConnected();
	    pCon->AddRef();	// or it will go away in Disconnect
	    m_pCap->m_pGraph->Disconnect(GetConnected());
	    m_pCap->m_pGraph->Disconnect(this);
	    IGraphBuilder *pFG;
	    HRESULT hr = m_pCap->m_pGraph->QueryInterface(IID_IGraphBuilder,
								(void **)&pFG);
	    if (hr == NOERROR) {
	        hr = pFG->Connect(this, pCon);
		pFG->Release();
	    }
	    pCon->Release();
	    if (hr != NOERROR)
                DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr; 	// notify application that graph is broken!
	    // !!! Tell app that graph has changed?
#endif
	 }

	 // We need to FAIL our return code if reconnecting the preview pin 
	 // will fail, even though we are doing it asynchronously.  Here we
	 // predict it will fail, to warn the caller.
         CCapPreview *pPreviewPin = m_pCap->m_pPreviewPin;
         if (pPreviewPin && pPreviewPin->IsConnected()) {
	     hr = pPreviewPin->GetConnected()->QueryAccept(&cmt);
	     if (hr != S_OK) {
         	 DbgLog((LOG_ERROR,1,TEXT("** RECONNECT preview will FAIL!")));
		 return hr;
	     }
	 }

	 // when this pin gets reconnected it will call us again to do the
	 // other two pins
	 return S_OK;
      }

      // Now reconnect the overlay pin
      CCapOverlay *pOverlayPin = m_pCap->m_pOverlayPin;
      if (pOverlayPin && pOverlayPin->IsConnected()) {
         DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our overlay pin")));
         CMediaType cmt;
	 pOverlayPin->GetMediaType(0, &cmt);
	 if (S_OK == pOverlayPin->GetConnected()->QueryAccept(&cmt)) {
	    m_pCap->m_pGraph->Reconnect(pOverlayPin);
	 } else {
	    // Huh?
	    ASSERT(FALSE);
	 }
      }

      // Now reconnect the non-overlay preview pin
      CCapPreview *pPreviewPin = m_pCap->m_pPreviewPin;
      if (pPreviewPin && pPreviewPin->IsConnected()) {
         DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our preview pin")));
         CMediaType cmt;
	 pPreviewPin->GetMediaType(0, &cmt);
	 hr = pPreviewPin->GetConnected()->QueryAccept(&cmt);
	 if (hr == S_OK) {
	    m_pCap->m_pGraph->Reconnect(pPreviewPin);
	 } else {
            DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr;
#if 0
	    // Oh boy.  We're going to have to get clever and insert some
	    // filters between us to help us reconnect
            DbgLog((LOG_TRACE,1,TEXT("Whoa! We *really* need to reconnect!")));
	    IPin *pCon = pPreviewPin->GetConnected();
	    pCon->AddRef();	// or it will go away in Disconnect
	    m_pCap->m_pGraph->Disconnect(pPreviewPin->GetConnected());
	    m_pCap->m_pGraph->Disconnect(pPreviewPin);
	    IGraphBuilder *pFG;
	    HRESULT hr = m_pCap->m_pGraph->QueryInterface(IID_IGraphBuilder,
								(void **)&pFG);
	    if (hr == NOERROR) {
	        hr = pFG->Connect(pPreviewPin, pCon);
		pFG->Release();
	    }
	    pCon->Release();
	    if (hr != NOERROR)
                DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr;
	    // !!! We need to notify application that graph is different
#endif
	 }
      }
      return S_OK;
}

//=============================================================================

// IAMStreamConfig stuff

// Tell the capture card to capture a specific format.  If it isn't connected,
// then it will use that format to connect when it does.  If already connected,
// then it will reconnect with the new format.
//
HRESULT CCapStream::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;

    if (pmt == NULL)
	return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(m_pCap->m_pLock);

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat %x %dbit %dx%d"),
		HEADER(pmt->pbFormat)->biCompression,
		HEADER(pmt->pbFormat)->biBitCount,
		HEADER(pmt->pbFormat)->biWidth,
		HEADER(pmt->pbFormat)->biHeight));

    if (m_pCap->m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    // If this is the same format as we already are using, don't bother
    CMediaType mt;
    GetMediaType(0,&mt);
    if (mt == *pmt) {
	return NOERROR;
    }

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) {
	DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat rejected")));
	return hr;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
	hr = GetConnected()->QueryAccept(pmt);
	if (hr != NOERROR) {
	    DbgLog((LOG_TRACE,2,TEXT("Rejected by capture peer")));
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }

    // Changing our format will reconnect the preview pin too, so make sure
    // that peer can accept the new format before saying yes.
    if (m_pCap->m_pPreviewPin && m_pCap->m_pPreviewPin->IsConnected()) {
	hr = m_pCap->m_pPreviewPin->GetConnected()->QueryAccept(pmt);
	if (hr != NOERROR) {
	    DbgLog((LOG_TRACE,2,TEXT("Rejected by preview peer")));
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }

    // OK, we're using it
    hr = SetMediaType((CMediaType *)pmt);

    // Changing the format means reconnecting if necessary
    if (hr == NOERROR)
        Reconnect(TRUE);

    return hr;
}


// What format is the capture card capturing right now?
// The caller must free it with DeleteMediaType(*ppmt)
//
HRESULT CCapStream::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
	return E_POINTER;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
	return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
	CoTaskMemFree(*ppmt);
	*ppmt = NULL;
	return hr;
    }
    return NOERROR;
}


//
//
HRESULT CCapStream::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetNumberOfCapabilities")));

    if (piCount == NULL || piSize == NULL)
	return E_POINTER;

    *piCount = 0;
    *piSize = 0;

    return NOERROR;
}


// find out some capabilities of this capture device
//
HRESULT CCapStream::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt,
						LPBYTE pSCC)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    // !!! sorry, I have no clue what to say
    return E_NOTIMPL;

#if 0
    // Sorry, no more.
    if (i != 0)
	return S_FALSE;

    GetMediaType(0, (CMediaType *)pmt);

    ZeroMemory(pVSCC, sizeof(VIDEO_STREAM_CONFIG_CAPS));

    // Maybe the EXTERNALIN's channel caps tell me about the possible
    // output sizes?
#endif

// This is meaningless, but it's how we get channel caps
#if 0
    CHANNEL_CAPS VideoCaps;
    if (m_cs.hVideoIn && videoGetChannelCaps(m_cs.hVideoIn,
                	&VideoCaps, sizeof(CHANNEL_CAPS)) == DV_ERR_OK) {
	pVSCC->VideoGranularityXPos = VideoCaps.dwDstRectXMod;
	pVSCC->VideoGranularityYPos = VideoCaps.dwDstRectYMod;
	pVSCC->VideoGranularityWidth = VideoCaps.dwDstRectWidthMod;
	pVSCC->VideoGranularityHeight = VideoCaps.dwDstRectHeightMod;
	pVSCC->CroppingGranularityXPos = VideoCaps.dwSrcRectXMod;
	pVSCC->CroppingGranularityYPos = VideoCaps.dwSrcRectYMod;
	pVSCC->CroppingGranularityWidth = VideoCaps.dwSrcRectWidthMod;
	pVSCC->CroppingGranularityHeight = VideoCaps.dwSrcRectHeightMod;
	// We don't allow funky rectangles in our media types
	pVSCC->fCanStretch = FALSE; //VideoCaps.dwFlags & VCAPS_CAN_SCALE;
	pVSCC->fCanShrink = FALSE; //VideoCaps.dwFlags & VCAPS_CAN_SCALE;
        return NOERROR;
    } else {
        DbgLog((LOG_TRACE,2,TEXT("ERROR getting stream caps")));
	return E_FAIL;
    }
#endif

    return NOERROR;
}


//=============================================================================

// IAMVideoCompression stuff

// Get some information about the driver
//
HRESULT CCapStream::GetInfo(LPWSTR pszVersion, int *pcbVersion, LPWSTR pszDescription, int *pcbDescription, long FAR* pDefaultKeyFrameRate, long FAR* pDefaultPFramesPerKey, double FAR* pDefaultQuality, long FAR* pCapabilities)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMVideoCompression::GetInfo")));

    // we can't do anything programmatically
    if (pCapabilities)
        *pCapabilities = 0;
    if (pDefaultKeyFrameRate)
        *pDefaultKeyFrameRate = 0;
    if (pDefaultPFramesPerKey)
        *pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
        *pDefaultQuality = 0;

    if (pcbVersion == NULL && pcbDescription == NULL)
	return NOERROR;

    // get the driver version and description
    #define DESCSIZE 80
    DWORD dwRet;
    WCHAR wachVer[DESCSIZE], wachDesc[DESCSIZE];
    wachVer[0] = 0; wachDesc[0] = 0;
    char achVer[DESCSIZE], achDesc[DESCSIZE];

#ifndef UNICODE
    if (g_IsNT)
#endif
    {
	// NT will return unicode strings even though the API says not
        dwRet = videoCapDriverDescAndVer(m_user.uVideoID, (TCHAR *) wachDesc, // !!!
				DESCSIZE, (TCHAR *) wachVer, DESCSIZE);
	DbgLog((LOG_TRACE,2,TEXT("%ls   %ls"), wachDesc, wachVer));
    }
#ifndef UNICODE 
    else 
    {
        dwRet = videoCapDriverDescAndVer(m_user.uVideoID, achDesc,
				DESCSIZE, achVer, DESCSIZE);
	DbgLog((LOG_TRACE,2,TEXT("%s   %s"), achDesc, achVer));
    }
#endif

    if (!dwRet && !g_IsNT) {
	Imbstowcs(wachDesc, achDesc, DESCSIZE);
	Imbstowcs(wachVer, achVer, DESCSIZE);
    }

    if (pszVersion && pcbVersion)
        lstrcpynW(pszVersion, wachVer, min(*pcbVersion / 2, DESCSIZE));
    if (pszDescription && pcbDescription)
        lstrcpynW(pszDescription, wachDesc, min(*pcbDescription / 2, DESCSIZE));

    // return the length in bytes needed (incl. NULL)
    if (pcbVersion)
	*pcbVersion = lstrlenW(wachVer) * 2 + 2;
    if (pcbDescription)
	*pcbDescription = lstrlenW(wachDesc) * 2 + 2;

    return NOERROR;
}


//=============================================================================

/* IAMDroppedFrames stuff */

// How many frames did we drop?
//
HRESULT CCapStream::GetNumDropped(long FAR* plDropped)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetNumDropped - %d dropped"),
			(int)m_capstats.dwlNumDropped));

    if (plDropped == NULL)
	return E_POINTER;

    *plDropped = (long)m_capstats.dwlNumDropped;
    return NOERROR;
}


// How many frames did we not drop?
//
HRESULT CCapStream::GetNumNotDropped(long FAR* plNotDropped)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetNumNotDropped - %d not dropped"),
					(int)m_capstats.dwlNumCaptured));

    if (plNotDropped == NULL)
	return E_POINTER;

    *plNotDropped = (long)(m_capstats.dwlNumCaptured);
    return NOERROR;
}


// Which frames did we drop (give me up to lSize of them - we got lNumCopied)
//
HRESULT CCapStream::GetDroppedInfo(long lSize, long FAR* plArray, long FAR* plNumCopied)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetDroppedInfo")));

    if (lSize <= 0)
	return E_INVALIDARG;
    if (plArray == NULL || plNumCopied == NULL)
	return E_POINTER;

    *plNumCopied = min(lSize, NUM_DROPPED);
    *plNumCopied = (long)min(*plNumCopied, m_capstats.dwlNumDropped);

    LONG l;
    for (l = 0; l < *plNumCopied; l++) {
	plArray[l] = (long)m_capstats.dwlDropped[l];
    }

    return NOERROR;
}


HRESULT CCapStream::GetAverageFrameSize(long FAR* plAverageSize)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetAvergeFrameSize - %d"),
		m_capstats.dwlNumCaptured ?
		(long)(m_capstats.dwlTotalBytes / m_capstats.dwlNumCaptured) :
		0));

    if (plAverageSize == NULL)
	return E_POINTER;

    *plAverageSize = m_capstats.dwlNumCaptured ?
    		(long)(m_capstats.dwlTotalBytes / m_capstats.dwlNumCaptured) :
		0;

    return NOERROR;
}


///////////////////////////////
// IAMBufferNegotiation methods
///////////////////////////////

HRESULT CCapStream::SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("SuggestAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pCap->m_pLock);

    if (pprop == NULL)
	return E_POINTER;

    // sorry, too late
    if (IsConnected())
	return VFW_E_ALREADY_CONNECTED;

    m_propSuggested = *pprop;

    DbgLog((LOG_TRACE,2,TEXT("cBuffers-%d  cbBuffer-%d  cbAlign-%d  cbPrefix-%d"),
		pprop->cBuffers,
                pprop->cbBuffer,
                pprop->cbAlign,
                pprop->cbPrefix));

    return NOERROR;
}


HRESULT CCapStream::GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("GetAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pCap->m_pLock);

    if (!IsConnected())
	return VFW_E_NOT_CONNECTED;

    if (pprop == NULL)
	return E_POINTER;

    *pprop = m_Alloc.parms;

    return NOERROR;
}

// IAMPushSource
HRESULT CCapStream::GetPushSourceFlags( ULONG *pFlags )
{
    *pFlags = 0 ; // we timestamp with graph clock, no special requirements
    return S_OK;
}    

HRESULT CCapStream::SetPushSourceFlags( ULONG Flags )
{
    // we don't support this currently
    return E_FAIL;
}    

HRESULT CCapStream::GetLatency( REFERENCE_TIME  *prtLatency )
{
    *prtLatency = m_rtLatency;
    return S_OK;
}    

HRESULT CCapStream::SetStreamOffset( REFERENCE_TIME  rtOffset )
{
    m_rtStreamOffset = rtOffset;
    return S_OK;
}

HRESULT CCapStream::GetStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtStreamOffset;
    return S_OK;
}

HRESULT CCapStream::GetMaxStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtMaxStreamOffset;
    return S_OK;
}

HRESULT CCapStream::SetMaxStreamOffset( REFERENCE_TIME  rtOffset )
{
    m_rtMaxStreamOffset = rtOffset; // streaming pin doesn't really care about this at this point
    return S_OK;
}

//
// PIN CATEGORIES - let the world know that we are a CAPTURE pin
//

HRESULT CCapStream::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CCapStream::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
	return E_POINTER;

    if (pcbReturned)
	*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
	return S_OK;

    if (cbPropData < sizeof(GUID))
	return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_CAPTURE;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CCapStream::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
	*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\resource.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#define IDD_PROPERTIES   300
#define IDS_NAME	 299

#define ID_SOURCE        301
#define ID_FORMAT        302
#define ID_DISPLAY       303
#define ID_FRAMESCAPTURED 304
#define ID_FRAMESDROPPED 305
#define ID_FRAMESPERSEC  306
#define ID_BYTESPERSEC   307
#define ID_MSCAPTURED    308
#define ID_XXX1		 309
#define ID_XXX2		 310
#define ID_XXX3		 311
#define ID_XXX4		 312
#define ID_XXX5		 313
#define ID_XXX6		 314
#define ID_XXX7		 315
#define ID_XXX8		 316
#define ID_XXX9		 317
#define ID_DESC		 318
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\thunk.c ===
/*****************************************************************************
 *
 *  Thunk.c
 *
 *  Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Thunking to 16-bit code without using the thunk compiler.
 *      This is important if you want your DLL to run on both Win95
 *      and Windows NT.
 *
 *****************************************************************************/

#pragma warning(disable:4054)           /* cannot cast to function ptr */
#pragma warning(disable:4055)           /* cannot cast from function ptr */

#pragma warning(disable:4115)           /* rpcndr.h: parenthesized type */
#pragma warning(disable:4201)           /* winnt.h: nameless union */
#pragma warning(disable:4214)           /* winnt.h: unsigned bitfields */
#pragma warning(disable:4514)           /* winnt.h: fiber goo */

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <pshpack1.h>                   /* Byte packing, please */

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FARPROC | GetProcOrd |
 *
 *          GetProcAddress on a DLL by ordinal.
 *
 *          Win95 does not let you GetProcAddress on KERNEL32 by ordinal,
 *          so we need to do it the evil way.
 *
 *  @parm   HINSTANCE | hinstDll |
 *
 *          The instance handle of the DLL we want to get the ordinal
 *          from.  The only DLL you need to use this function for is
 *          KERNEL32.
 *
 *  @parm   UINT | ord |
 *
 *          The ordinal you want to retrieve.
 *
 ***************************************************************************/

#define pvAdd(pv, cb) ((LPVOID)((LPSTR)(pv) + (DWORD)(cb)))
#define pvSub(pv1, pv2) (DWORD)((LPSTR)(pv1) - (LPSTR)(pv2))

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
                          DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC NTAPI
GetProcOrd(HINSTANCE hinstDll, UINT_PTR ord)
{
    FARPROC fp;

    /*
     *  Make sure the MZ header is good.
     */

    PIMAGE_DOS_HEADER pidh = (LPVOID)hinstDll;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
        pidh->e_magic == IMAGE_DOS_SIGNATURE) {

        /*
         *  Make sure the PE header is good.
         */
        PIMAGE_NT_HEADERS pinth = pvAdd(pidh, pidh->e_lfanew);
        if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
            pinth->Signature == IMAGE_NT_SIGNATURE) {

            /*
             *  Make sure the export table is good and the ordinal
             *  is within range.
             */
            PIMAGE_EXPORT_DIRECTORY pedt =
                                pvAdd(pidh, poteExp(pinth)->VirtualAddress);
            if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
                (ord - pedt->Base) < pedt->NumberOfFunctions) {

                PDWORD peat = pvAdd(pidh, pedt->AddressOfFunctions);
                fp = (FARPROC)pvAdd(pidh, peat[ord - pedt->Base]);
                if (pvSub(fp, peat) >= poteExp(pinth)->Size) {
                    /* fp is valid */
                } else {                /* Note: We don't support forwarding */
                    fp = 0;
                }
            } else {
                fp = 0;
            }
        } else {
            fp = 0;
        }
    } else {
        fp = 0;
    }

    return fp;
}

/***************************************************************************
 *
 *  This structure starts out life as the things that we will GetProcAddress
 *  for.  And then it turns into pointers to functions.
 *
 ***************************************************************************/

#pragma BEGIN_CONST_DATA

static TCHAR c_tszKernel32[] = TEXT("KERNEL32");

static LPCSTR c_rgpszKernel32[] = {
    (LPVOID) 35,            /* LoadLibrary16 */
    (LPVOID) 36,            /* FreeLibrary16 */
    (LPVOID) 37,            /* GetProcAddress16 */

    "QT_Thunk",
    "MapLS",
    "UnMapLS",
    "MapSL",
    "MapSLFix",
};

#pragma END_CONST_DATA

typedef struct MANUALIMPORTTABLE {  /* mit */

    /* By ordinal */
    HINSTANCE   (NTAPI *LoadLibrary16)(LPCSTR);
    BOOL        (NTAPI *FreeLibrary16)(HINSTANCE);
    FARPROC     (NTAPI *GetProcAddress16)(HINSTANCE, LPCSTR);

    /* By name */
    void        (__cdecl *QT_Thunk)(void);
    LPVOID      (NTAPI   *MapLS)(LPVOID);
    void        (NTAPI   *UnMapLS)(LPVOID);
    LPVOID      (NTAPI   *MapSL)(LPVOID);
    LPVOID      (NTAPI   *MapSLFix)(LPVOID);

} MIT;

static MIT s_mit;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *          l = a 32-bit integer
 *          s = a 16-bit integer
 *
 *          P = returns a pointer
 *          L = returns a 32-bit integer
 *          S = returns a 16-bit signed integer
 *          U = returns a 16-bit unsigned integer
 *
 *  @parm   FARPROC | fp |
 *
 *          16:16 function to call.
 *
 *  @parm   PCSTR | pszSig |
 *
 *          Function signature.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

#ifndef NON_X86
__declspec(naked) DWORD
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, 60;                /* QT_Thunk needs 60 bytes */
        push    ebx;
        push    edi;
        push    esi;

        /* Thunk all the parameters according to the signature */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
thunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Q: Pointer? */
        jz      thunkPtr;               /* Y: Do the pointer */
        cmp     al, 'l';                /* Q: Long? */
        jz      thunkLong;              /* Y: Do the long */
        cmp     al, 's';                /* Q: Short? */
        jnz     thunkDone;              /* N: Done */

                                        /* Y: Do the short */
        lodsd;                          /* eax = *ppvArg++ */
        push    ax;                     /* Push the short */
        jmp     thunkLoop;

thunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    s_mit.MapLS;            /* Map it */
        mov     [esi][-4], eax;         /* Save it for unmapping */
        push    eax;
        jmp     thunkLoop;

thunkLong:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        jmp     thunkLoop;
thunkDone:

        /* Call the 16:16 procedure */

        mov     edx, fp;
        call    s_mit.QT_Thunk;
        shl     eax, 16;                /* Convert DX:AX to EDX */
        shld    edx, eax, 16;

        /* Translate the return code according to the signature */

        mov     al, [ebx][-1];          /* Get return code type */
        cmp     al, 'P';                /* Pointer? */
        jz      retvalPtr;              /* Y: Do the pointer */
        cmp     al, 'S';                /* Signed? */
        jz      retvalSigned;           /* Y: Do the signed short */
        cmp     al, 'U';                /* Unsigned? */
        mov     edi, edx;               /* Assume long or void */
        jnz     retvalOk;               /* N: Then long or void */

        movzx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalPtr:
        push    edx;                    /* Pointer */
        call    s_mit.MapSL;            /* Map it up */
        jmp     retvalOk;

retvalSigned:                           /* Signed */
        movsx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalOk:                               /* Return value in EDI */

        /* Now unthunk the parameters */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
unthunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Pointer? */
        jz      unthunkPtr;             /* Y: Do the pointer */
        cmp     al, 'l';                /* Long? */
        jz      unthunkSkip;            /* Y: Skip it */
        cmp     al, 's';                /* Short? */
        jnz     unthunkDone;            /* N: Done */
unthunkSkip:
        lodsd;                          /* eax = *ppvArg++ */
        jmp     unthunkLoop;

unthunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    s_mit.UnMapLS;          /* Unmap it */
        jmp     unthunkLoop;

unthunkDone:

        /* Done */

        mov     eax, edi;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}
#else
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
        return  0;
}
#endif

#pragma warning(default:4035)

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          Initialize the various goo we need in KERNEL32.
 *
 *          Returns FALSE if we cannot initialize the thunks.
 *          (For example, if the platform doesn't support flat thunks.)
 *
 *          Note that you must never ever call this function more
 *          than once.
 *
 ***************************************************************************/

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#endif

#pragma BEGIN_CONST_DATA

static char c_szVidx16[] = "VIDX16.DLL";

static LPCSTR c_rgpszVidx16[] = {
    (LPCSTR)6,      /* vidxAllocHeaders             */
    (LPCSTR)7,      /* vidxFreeHeaders              */
    (LPCSTR)8,      /* vidxAllocBuffer              */
    (LPCSTR)9,      /* vidxAllocPreviewBuffer       */
    (LPCSTR)10,     /* vidxFreeBuffer               */
    (LPCSTR)11,     /* vidxSetRect                  */
    (LPCSTR)12,     /* vidxFrame                    */
    (LPCSTR)13,     /* vidxAddBuffer                */
    (LPCSTR)14,     /* vidxGetErrorText             */
    (LPCSTR)15,     /* vidxUpdate                   */
    (LPCSTR)16,     /* vidxDialog                   */
    (LPCSTR)17,     /* vidxStreamInit               */
    (LPCSTR)18,     /* vidxStreamFini               */
    (LPCSTR)19,     /* vidxConfigure                */
    (LPCSTR)20,     /* vidxOpen                     */
    (LPCSTR)21,     /* vidxClose                    */
    (LPCSTR)22,     /* vidxGetChannelCaps           */
    (LPCSTR)23,     /* vidxStreamReset              */
    (LPCSTR)24,     /* vidxStreamStart              */
    (LPCSTR)25,     /* vidxStreamStop               */
    (LPCSTR)26,     /* vidxStreamUnprepareHeader    */
    (LPCSTR)27,     /* vidxCapDriverDescAndVer      */
    (LPCSTR)28,     /* vidxMessage      	    */
    (LPCSTR)29,     /* vidxFreePreviewBuffer        */
};

#pragma END_CONST_DATA

static HINSTANCE s_hinstVidx16;

static FARPROC s_rgfpVidx16[ARRAYSIZE(c_rgpszVidx16)];

#define s_fpvidxAllocHeaders            s_rgfpVidx16[0]
#define s_fpvidxFreeHeaders             s_rgfpVidx16[1]
#define s_fpvidxAllocBuffer             s_rgfpVidx16[2]
#define s_fpvidxAllocPreviewBuffer      s_rgfpVidx16[3]
#define s_fpvidxFreeBuffer              s_rgfpVidx16[4]
#define s_fpvidxSetRect                 s_rgfpVidx16[5]
#define s_fpvidxFrame                   s_rgfpVidx16[6]
#define s_fpvidxAddBuffer               s_rgfpVidx16[7]

#define s_fpvideoGetErrorText           s_rgfpVidx16[8]
#define s_fpvideoUpdate                 s_rgfpVidx16[9]
#define s_fpvideoDialog                 s_rgfpVidx16[10]
#define s_fpvideoStreamInit             s_rgfpVidx16[11]
#define s_fpvideoStreamFini             s_rgfpVidx16[12]
#define s_fpvideoConfigure              s_rgfpVidx16[13]
#define s_fpvideoOpen                   s_rgfpVidx16[14]
#define s_fpvideoClose                  s_rgfpVidx16[15]
#define s_fpvideoGetChannelCaps         s_rgfpVidx16[16]
#define s_fpvideoStreamReset            s_rgfpVidx16[17]
#define s_fpvideoStreamStart            s_rgfpVidx16[18]
#define s_fpvideoStreamStop             s_rgfpVidx16[19]
#define s_fpvideoStreamUnprepareHeader  s_rgfpVidx16[20]
#define s_fpvideoCapDriverDescAndVer    s_rgfpVidx16[21]
#define s_fpvideoMessage    		s_rgfpVidx16[22]
#define s_fpvidxFreePreviewBuffer       s_rgfpVidx16[23]

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkTerm |
 *
 *          Free it.
 *
 ***************************************************************************/

void NTAPI
ThunkTerm(void)
{
    if (s_hinstVidx16) {
        s_mit.FreeLibrary16(s_hinstVidx16);
        s_hinstVidx16 = 0;
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE NTAPI
ThunkGetProcAddresses(FARPROC rgfp[], LPCSTR rgpsz[], UINT cfp,
                      LPCSTR pszLibrary)
{
    HINSTANCE hinst;

    hinst = s_mit.LoadLibrary16(pszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = s_mit.GetProcAddress16(hinst, rgpsz[ifp]);
            if (!rgfp[ifp]) {
                s_mit.FreeLibrary16(hinst);
                hinst = 0;
                break;
            }
        }
    } else {
        hinst = 0;
    }

    return hinst;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          GetProcAddress16 our brains out.
 *
 ***************************************************************************/

BOOL NTAPI
ThunkInit(void)
{
    HINSTANCE hinstK32 = GetModuleHandle(c_tszKernel32);
    BOOL fRc;

    if (hinstK32) {
        int i;
        FARPROC *rgfpMit = (LPVOID)&s_mit;

        for (i = 0; i < ARRAYSIZE(c_rgpszKernel32); i++) {
            if ((LONG_PTR)(c_rgpszKernel32[i]) & ~(LONG_PTR)65535) {
                rgfpMit[i] = GetProcAddress(hinstK32, c_rgpszKernel32[i]);
            } else {
                rgfpMit[i] = GetProcOrd(hinstK32, (UINT_PTR)c_rgpszKernel32[i]);
            }
            if (!rgfpMit[i]) return FALSE;  /* Aigh! */
        }

        s_hinstVidx16 =
            ThunkGetProcAddresses(s_rgfpVidx16, c_rgpszVidx16,
                                  ARRAYSIZE(s_rgfpVidx16),
                                  c_szVidx16);

        if (!s_hinstVidx16) {
            goto failed;
        }

        fRc = 1;

    } else {
    failed:;
        ThunkTerm();

        fRc = 0;
    }

    return fRc;
}


/***************************************************************************
 *
 *  Now come the actual thunklets.
 *
 ***************************************************************************/

// typedef DWORD   HDR32;
// typedef DWORD   HVIDEO;
// typedef DWORD  *LPHVIDEO;
typedef struct channel_caps_tag CHANNEL_CAPS, *LPCHANNEL_CAPS;


#include "ivideo32.h"

typedef PTR32 FAR * PPTR32;

extern int g_IsNT;


#define tHVIDEO                 "l"
#define tUINT                   "s"
#define tHWND                   "s"
#define tHDC                    "s"
#define tint                    "s"
#define tDWORD                  "l"
#define tLPARAM                 "l"
#define tDWORD_PTR              "l"	// exactly like DWORD, or we'll blow up
#define tHDR32                  "l"
#define tPTR32                  "l"
#define tLPVIDEOHDR             "p"	// was l
#define tLPVOID                 "p"
#define tLPDWORD                "p"
#define tPPTR32                 "p"
#define tLPSTR                  "p"
#define tLPTSTR                 "p"
#define tLPHVIDEO               "p"
#define tLPCHANNEL_CAPS         "p"
#define rDWORD                  "L"
#define rLRESULT                "L"

#pragma BEGIN_CONST_DATA


#define MAKETHUNK1(rT, fn, t1, a1)                                          \
rT NTAPI                                                                    \
fn(t1 a1)                                                                   \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1);                                                  \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1                                                       \
        r##rT,     a1);                                                     \
}                                                                           \

#define MAKETHUNK2(rT, fn, t1, a1, t2, a2)                                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2)                                                            \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2);                                               \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2                                                 \
        r##rT,   a1,     a2);                                               \
}                                                                           \

#define MAKETHUNK3(rT, fn, t1, a1, t2, a2, t3, a3)                          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3)                                                     \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3);                                            \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3                                           \
        r##rT,   a1,     a2,   a3);                                         \
}                                                                           \

#define MAKETHUNK4(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4)                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4)                                              \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4);                                         \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4                                     \
        r##rT,     a1,   a2,   a3,   a4);                                   \
}                                                                           \

#define MAKETHUNK5(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5)          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5)                                       \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5);                                      \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5                               \
        r##rT,     a1,   a2,   a3,   a4,   a5);                             \
}                                                                           \

#define MAKETHUNK6(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6)  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6)                                \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6);                                   \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6                         \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6);                       \
}                                                                           \

#define MAKETHUNK7(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6,  \
                           t7, a7)                                          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6, t7 a7)                         \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6,a7);                                \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6 t##t7                   \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6,   a7);                 \
}                                                                           \

#define MAKETHUNK8(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6,  \
                           t7, a7, t8, a8)                                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6, t7 a7, t8 a8)                  \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6,a7,a8);                             \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6 t##t7 t##t8             \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6,   a7,   a8);           \
}                                                                           \

MAKETHUNK4(DWORD,   vidxAllocHeaders,
           HVIDEO,  hv,
           UINT,    nHeaders,
           UINT,    cbHeader,
           PPTR32,  lp32Hdrs)

MAKETHUNK1(DWORD,   vidxFreeHeaders,
           HVIDEO,  hv)

MAKETHUNK4(DWORD,   vidxAllocBuffer,
           HVIDEO,  hv,
           UINT,    iHdr,
           PPTR32,  pp32Hdr,
           DWORD,   dwSize)

MAKETHUNK4(DWORD,   vidxAllocPreviewBuffer,
           HVIDEO,  hv,
           PPTR32,  pp32Hdr,
           UINT,    cbHdr,
           DWORD,   cbData)

MAKETHUNK2(DWORD,   vidxFreePreviewBuffer,
           HVIDEO,  hv,
           PPTR32,  pp32Hdr)

MAKETHUNK2(DWORD,   vidxFreeBuffer,
           HVIDEO,  hv,
           DWORD,   p32Hdr)

MAKETHUNK4(DWORD,   videoGetErrorText,
           HVIDEO,  hv,
           UINT,    wError,
           LPTSTR,   lpText,
           UINT,    wSize)

MAKETHUNK6(DWORD,   vidxSetRect,
           HVIDEO,  hv,
           UINT,    wMsg,
           int,     left,
           int,     top,
           int,     right,
           int,     bottom)

MAKETHUNK3(DWORD,   videoUpdate,
           HVIDEO,  hv,
           HWND,    hWnd,
           HDC,     hDC)

MAKETHUNK3(DWORD,   videoDialog,
           HVIDEO,  hv,
           HWND,    hWndParent,
           DWORD,   dwFlags)

MAKETHUNK5(DWORD,   videoStreamInit,
           HVIDEO,  hvideo,
           DWORD,   dwMicroSecPerFrame,
           DWORD_PTR,   dwCallback,
           DWORD_PTR,   dwCallbackInst,
           DWORD,   dwFlags)

MAKETHUNK1(DWORD,   videoStreamFini,
           HVIDEO,  hvideo)

MAKETHUNK2(DWORD,   vidxFrame,
           HVIDEO,  hvideo,
           LPVIDEOHDR, p32hdr)

MAKETHUNK8(DWORD,   videoConfigure,
           HVIDEO,  hvideo,
           UINT,    msg,
           DWORD,   dwFlags,
           LPDWORD, lpdwReturn,
           LPVOID,  lpData1,
           DWORD,   dwSize1,
           LPVOID,  lpData2,
           DWORD,   dwSize2)

MAKETHUNK3(DWORD,   videoOpen,
           LPHVIDEO,phv,
           DWORD,   dwDevice,
           DWORD,   dwFlags)

MAKETHUNK1(DWORD,   videoClose,
           HVIDEO,  hv)

MAKETHUNK3(DWORD,   videoGetChannelCaps,
           HVIDEO,  hv,
           LPCHANNEL_CAPS, lpcc,
           DWORD,  dwSize)

MAKETHUNK3(DWORD,   vidxAddBuffer,
           HVIDEO,  hvideo,
           PTR32,   p32Hdr,
           DWORD,   dwSize)

MAKETHUNK1(DWORD,   videoStreamReset,
           HVIDEO,  hvideo)

MAKETHUNK1(DWORD,   videoStreamStart,
           HVIDEO,  hvideo)

MAKETHUNK1(DWORD,   videoStreamStop,
           HVIDEO,  hvideo)

MAKETHUNK3(DWORD,   videoStreamUnprepareHeader,
           HVIDEO,  hvideo,
           LPVIDEOHDR,   lpVHdr,
           DWORD,   dwSize)

MAKETHUNK5(DWORD,   videoCapDriverDescAndVer,
           DWORD,  dwDeviceID,
           LPTSTR, lpszDesc,
           UINT,   cbDesc,
           LPTSTR, lpszVer,
           UINT,   cbVer)

MAKETHUNK4(LRESULT,   videoMessage,
           HVIDEO,  hVideo,
           UINT,    uMsg,
           LPARAM,   dw1,
           LPARAM,   dw2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\avi\capture\video.c ===
/****************************************************************************
    video.c

    Contains video APIs

    Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.

****************************************************************************/

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <windowsx.h>

#include <mmsystem.h>
#ifdef WIN32
#include <mmddk.h>
#include <stdlib.h>
#endif

#include <vfw.h>
//#include "win32.h"
#if defined (NT_BUILD)
#include "vc50\msviddrv.h"
#else
#include "msviddrv.h"
#endif 
//#include "msvideo.h"
#include <ivideo32.h>
// #include "msvideoi.h"

#if 0
#include <windows.h>
//#include <windowsx.h>
#include <mmsystem.h>
#include "win32.h"
#include "msviddrv.h"
//#include "msvideo.h"
#include "ivideo32.h"
#include "msvideoi.h"
#endif

#ifdef DEBUG
  //extern void FAR CDECL dprintf(LPSTR, ...);
  #define dprintf ; / ## /
#else
  #define dprintf ; / ## /
#endif


#ifndef DVM_STREAM_FREEBUFFER
  #define DVM_STREAM_ALLOCBUFFER    (DVM_START + 312)
  #define DVM_STREAM_FREEBUFFER    (DVM_START + 313)
#endif

#define SZCODE const TCHAR
#define STATICDT static
#define STATICFN static

/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)		(TRUE)
#define HugePageUnlock(x, y)

#define MapSL(x)	x

#define GetCurrentTask() GetCurrentThread()
#define MAXVIDEODRIVERS 10

#define DebugErr(this, that)

#pragma warning(disable:4002)
#define AuxDebugEx()
#define assert()

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

SZCODE  szNull[]        = TEXT("");
SZCODE  szVideo[]       = TEXT("msvideo");

#ifndef WIN32
SZCODE  szDrivers[]     = "Drivers";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

SZCODE szDriversDescRegKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");

UINT    wTotalVideoDevs;                  // total video devices
extern HINSTANCE ghInstDll;               // our module handle





// -----------------------------------------------------------
// If the following structure changes, update AVICAP and AVICAP.32 also!!!

typedef struct tCapDriverInfo {
   TCHAR szKeyEnumName[MAX_PATH];
   TCHAR szDriverName[MAX_PATH];
   TCHAR szDriverDescription[MAX_PATH];
   TCHAR szDriverVersion[80];
   TCHAR szSoftwareKey[MAX_PATH];
   DWORD dnDevNode;         // Set if this is a PnP device
   BOOL  fOnlySystemIni;    // If the [path]drivername is only in system.ini
   BOOL  fDisabled;         // User has disabled driver in the control panel
   BOOL  fActive;           // Reserved
} CAPDRIVERINFO, FAR *LPCAPDRIVERINFO;

#ifndef DEVNODE
typedef	DWORD	   DEVNODE;	// Devnode.
#endif

#ifndef LPHKEY
typedef HKEY FAR * LPHKEY;
#endif

// Registry settings of interest to capture drivers
SZCODE  szRegKey[]          = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo");
SZCODE  szRegActive[]       = TEXT("Active");
SZCODE  szRegDisabled[]     = TEXT("Disabled");
SZCODE  szRegDescription[]  = TEXT("Description");
SZCODE  szRegDevNode[]      = TEXT("DevNode");
SZCODE  szRegDriver[]       = TEXT("Driver");
SZCODE  szRegSoftwareKey[]  = TEXT("SOFTWAREKEY");

LPCAPDRIVERINFO aCapDriverList[MAXVIDEODRIVERS]; // Array of all capture drivers


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegOpenMSVideoKey | This function returns a key
 *      for the msvideo node in the registry.
 *      If the key does not exist it will be created,
 *      and the default entries made.
 *
 * @rdesc Returns Key on success, else NULL.
 ****************************************************************************/
HKEY videoRegOpenMSVideoKey (void)
{
    HKEY hKey = NULL;

    // Get the key if it already exists
    if (RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szRegKey,
                &hKey) != ERROR_SUCCESS) {

        // Otherwise make a new key
        if (RegCreateKey (
                        HKEY_LOCAL_MACHINE,
                        szRegKey,
                        &hKey) == ERROR_SUCCESS) {
            // Add the default entries to the msvideo node?

        }
    }
    return hKey;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegGetDriverByIndex | This function returns information
 *      about a capture driver by index from the registry.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm LPDEVNODE | lpDevnode | Specifies a far pointer to a buffer
 *   used to return an <t DEVNODE> handle.  For non Plug-and-Play devices,
 *   this return value will be NULL.
 *
 * @parm LPBOOL | lpEnabled | Specifies a far pointer to a buffer
 *   used to return a <t BOOL> flag.  If this value is TRUE, the driver is
 *   enabled, if FALSE, the corresponding device is disabled.
 *
 * @rdesc Returns TRUE if successful, or FALSE if a driver was not found
 *  with the <p dwDeviceID> index.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 ****************************************************************************/


BOOL videoRegGetKeyByIndex (
        HKEY            hKeyMSVideoRoot,
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo,
        LPHKEY          phKeyChild)
{
    BOOL fOK = FALSE;
    HKEY hKeyEnum;
    int i;

    *phKeyChild = (HKEY) 0;

    for (i=0; i < MAXVIDEODRIVERS; i++) {	//

        if (RegEnumKey (
                hKeyMSVideoRoot,
                i,
                lpCapDriverInfo-> szKeyEnumName,
                sizeof(lpCapDriverInfo->szKeyEnumName)/sizeof(TCHAR)) != ERROR_SUCCESS)
            break;

        // Found a subkey, does it match the requested index?
        if (i == (int) dwDeviceID) {

            if (RegOpenKey (
                        hKeyMSVideoRoot,
                        lpCapDriverInfo-> szKeyEnumName,
                        &hKeyEnum) == ERROR_SUCCESS) {

                *phKeyChild = hKeyEnum;  // Found it!!!
                fOK = TRUE;

            }
            break;
        }
    } // endof all driver indices
    return fOK;
}

// Fetches driver info listed in the registry.
// Returns: TRUE if the index was valid, FALSE if no driver at that index
// Note: Registry entry ordering is random.

BOOL videoRegGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    DWORD dwType;
    DWORD dwSize;
    BOOL fOK;
    HKEY hKeyChild;
    HKEY hKeyMSVideoRoot;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    if (!(hKeyMSVideoRoot = videoRegOpenMSVideoKey()))
        return FALSE;

    if (fOK = videoRegGetKeyByIndex (
                hKeyMSVideoRoot,
                dwDeviceID,
                lpCapDriverInfo,
                &hKeyChild)) {

        // Fetch the values:
        //      Active
        //      Disabled
        //      Description
        //      DEVNODE
        //      Driver
        //      SOFTWAREKEY

        dwSize = sizeof(BOOL);          // Active
        RegQueryValueEx(
                   hKeyChild,
                   szRegActive,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fActive,
                   &dwSize);

        dwSize = sizeof(BOOL);          // Enabled
        RegQueryValueEx(
                   hKeyChild,
                   szRegDisabled,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fDisabled,
                   &dwSize);
        // Convert this thing to a bool
        lpCapDriverInfo->fDisabled = (lpCapDriverInfo->fDisabled == '1');

        // DriverDescription
        dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDescription,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

        // DEVNODE
        dwSize = sizeof(DEVNODE);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDevNode,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->dnDevNode,
                   &dwSize);

        // DriverName
        dwSize = sizeof (lpCapDriverInfo->szDriverName) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDriver,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverName,
                   &dwSize);

        // SoftwareKey
        dwSize = sizeof (lpCapDriverInfo->szSoftwareKey) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegSoftwareKey,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szSoftwareKey,
                   &dwSize);

        RegCloseKey (hKeyChild);

    } // if the subkey could be opened

    RegCloseKey (hKeyMSVideoRoot);

    return fOK;
}

// Fetches driver info listed in system.ini
// Returns: TRUE if the index was valid, FALSE if no driver at that index

BOOL videoIniGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    int w = (int) dwDeviceID;
    BOOL fOK = FALSE;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    lstrcpy(szKey, szVideo);	//
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }

    // Only get its driver name
    if (GetPrivateProfileString(szDrivers, szKey, szNull,	//
                lpCapDriverInfo->szDriverName,
                sizeof(lpCapDriverInfo->szDriverName)/sizeof(TCHAR),
                szSystemIni)) {

        HKEY hKey = NULL;
        DWORD dwSize, dwType;

        // Get the key if it already exists

        // Get Drivers.Desc from its Drivers32 driver name
        if (ERROR_SUCCESS == RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szDriversDescRegKey,
                &hKey) != ERROR_SUCCESS) {
            // DriverDescription
            dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
            // [drivers.desc]
            //   DriverName = DriverDescription
            dwType = REG_SZ;
            RegQueryValueEx(
                   hKey,
                   lpCapDriverInfo->szDriverName,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

            RegCloseKey (hKey);
        }  else {
            dprintf("videoIniGetDriverByIndex: RegOpenKey of Drivers.Desc failed !!\n");
        }





        // Found an entry at the requested index
        // The description and version info will be inserted as
        // requested by the client app.

        lpCapDriverInfo-> fOnlySystemIni = TRUE;

        fOK = TRUE;
    }

    return fOK;
}

DWORD videoFreeDriverList (void)

{
    int i;

    // Free the driver list
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    wTotalVideoDevs = 0;

    return DV_ERR_OK;
}

// This function may be called a number of times to create the
// current driver array.  Since Capscrn assumes it can throw a
// driver into system.ini on the fly and have it immediately accessible,
// this routine is called on videoGetNumDevs() and when AVICapx.dll
// tries to get the driver description and version.
//
// Drivers in the registry will be the first entries in the list.
//
// If a driver is listed in the registry AND in system.ini AND
// the full path to the drivers match, the system.ini entry will NOT
// be in the resulting list.

// The variable wTotalVideoDevs is set as a byproduct of this function.

// Returns DV_ERR_OK on success, even if no drivers are installed.
//
DWORD videoCreateDriverList (void)

{
    int i, j, k;


    // Delete the existing list
    videoFreeDriverList ();

    // Allocate an array of pointers to all possible capture drivers
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        aCapDriverList[i] = (LPCAPDRIVERINFO) GlobalAllocPtr (
                GMEM_MOVEABLE |
                GMEM_SHARE |
                GMEM_ZEROINIT,
                sizeof (CAPDRIVERINFO));
        if (aCapDriverList[i] == NULL) {
            videoFreeDriverList ();
            return DV_ERR_NOMEM;
        }
    }

    // Walk the list of Registry drivers and get each entry
    // Get VFW drivers from MediaResource\MsVideo
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (videoRegGetDriverByIndex (
                    (DWORD) i, aCapDriverList[wTotalVideoDevs])) {

            dprintf("MediaResource: idx %d, DriverName %x, Desc %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName, aCapDriverList[wTotalVideoDevs]->szDriverDescription);

            wTotalVideoDevs++;	//
        }
        else
            break;
    }

    if (wTotalVideoDevs == MAXVIDEODRIVERS)
        goto AllDone;

    // Now add the entries listed in system.ini, [Drivers#2] section, (msvideo[0-9] = driver.drv)
    // to the driver array, ONLY if the entry doesn't exactly match
    // an existing registry entry.

    for (j = 0; j < MAXVIDEODRIVERS; j++) {
        // Get driver name such as *.dll
        if (videoIniGetDriverByIndex ((DWORD) j,
                        aCapDriverList[wTotalVideoDevs])) {

            // Found an entry, now see if it is a duplicate of an existing
            // registry entry

            for (k = 0; k < (int) wTotalVideoDevs; k++) {

                if (lstrcmpi (aCapDriverList[k]->szDriverName,
                    aCapDriverList[wTotalVideoDevs]->szDriverName) == 0) {

                    // Found an exact match, so skip it!
                    goto SkipThisEntry;
                }
            }

            if (wTotalVideoDevs >= MAXVIDEODRIVERS - 1)
                break;

            dprintf("Drivers32: idx %d, DriverName %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName);

            wTotalVideoDevs++;

SkipThisEntry:
            ;
        } // If sytem.ini entry was found
    } // For all system.ini possibilities

AllDone:


    // Decrement wTotalVideoDevs for any entries which are marked as disabled
    // And remove disabled entries from the list
    for (i = 0; i < MAXVIDEODRIVERS; ) {

        if (aCapDriverList[i] && aCapDriverList[i]->fDisabled) {

            GlobalFreePtr (aCapDriverList[i]);

            // Shift down the remaining drivers
            for (j = i; j < MAXVIDEODRIVERS - 1; j++) {
                aCapDriverList[j] = aCapDriverList[j + 1];
            }
            aCapDriverList[MAXVIDEODRIVERS - 1] = NULL;

            wTotalVideoDevs--;
        }
        else
            i++;
    }

    // Free the unused pointers
    for (i = wTotalVideoDevs; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    // Put PnP drivers first in the list
    // These are the only entries that have a DevNode
    for (k = i = 0; i < (int) wTotalVideoDevs; i++) {
        if (aCapDriverList[i]-> dnDevNode) {
            LPCAPDRIVERINFO lpCDTemp;

            if (k != i) {
                // Swap the entries
                lpCDTemp = aCapDriverList[k];
                aCapDriverList[k] = aCapDriverList[i];
                aCapDriverList[i] = lpCDTemp;
            }
            k++;   // Index of first non-PnP driver
        }
    }

    dprintf("videoCreateDriverList: DeviceList contains %d Video Device(s).\n", wTotalVideoDevs);

    return DV_ERR_OK;
}





// ----------------------------------------------------------------------
//
// To clean up when a WOW app exits, we need to maintain a list of
// open devices. A list of HANDLEINFO structs is hung off g_pHandles.
// An item is added to the head of this list in videoOpen, and removed
// in videoClose. When a WOW app exits, winmm will call our WOWAppExit
// function: for each entry in the list that is owned by the exiting thread,
// we call videoClose to close the device and remove the handle entry.
//

#define THKHVIDEO_STAMP  MAKEFOURCC('t','V','H','x')
typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
typedef struct _thk_hvideo {
    struct _thk_hvideo * pNext;
    DWORD          Stamp;
    UINT           nHeaders;
    UINT           cbAllocHdr;
    UINT           cbVidHdr;
    UINT           spare;
    LPVOID         paHdrs;
    PTR32          p32aHdrs;
    LPVOID         pVSyncMem;
    DWORD          p32VSyncMem;
    DWORD          pid;

    HVIDEO         hVideo;
    HVIDEO         hFill;

    DWORD_PTR          dwCallback;
    DWORD_PTR          dwUser;

    LPTHKVIDEOHDR  pPreviewHdr;

    } THKHVIDEO;


// one of these per open handle
typedef struct _HANDLEINFO {
    HVIDEO hv;
    HANDLE hThread;
    THKHVIDEO tv;
    struct _HANDLEINFO * pNext;
} HANDLEINFO, * PHANDLEINFO;

// head of global list of open handles
PHANDLEINFO g_pHandles;

// critical section that protects global list
CRITICAL_SECTION csHandles;

// init list and critsec
void
NTvideoInitHandleList()
{
    g_pHandles = NULL;
    InitializeCriticalSection(&csHandles);
}

// finished with critsec list
void
NTvideoDeleteHandleList()
{
    // don't need critical section as no-one else can be using
    // it now (we are about to delete the critsec)

    // empty everything out of the list
    while (g_pHandles) {
        videoClose(g_pHandles->hv);
    }

    DeleteCriticalSection(&csHandles);
}



// add a handle to the list
void
NTvideoAddHandle(HVIDEO hv)
{
    PHANDLEINFO pinfo = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLEINFO));

    if (!pinfo) {
        // couldn't allocate the memory - best thing to do is
        // forget it - nothing bad will happen except that we
        // might possibly fail to clean up if this is a wow app and
        // it exits without closing the capture device.
        return;
    }

    pinfo->hv = hv;
    pinfo->hThread = GetCurrentTask();
    ZeroMemory(&pinfo->tv, sizeof(THKHVIDEO));
    pinfo->tv.Stamp = THKHVIDEO_STAMP;

    EnterCriticalSection(&csHandles);

    pinfo->pNext = g_pHandles;
    g_pHandles = pinfo;

    LeaveCriticalSection(&csHandles);
}

// delete an entry from the handle list given the HVIDEO.
// caller must close the HVIDEO
// should be called before closing (in case the HVIDEO is reassigned after
// closing and before removing from the list
void
NTvideoDelete(HVIDEO hv)
{
    PHANDLEINFO * ppNext;
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    ppNext = &g_pHandles;
    while (*ppNext) {
        if ((*ppNext)->hv == hv) {
            pinfo = *ppNext;
            *ppNext = pinfo->pNext;
            HeapFree(GetProcessHeap(), 0, pinfo);
            break;

        } else {
            ppNext = &(*ppNext)->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}

// close any handles open by this task
void
AppCleanup(HANDLE hTask)
{
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    pinfo = g_pHandles;
    while (pinfo) {

        if (pinfo->hThread == hTask) {

            // get the next pointer before videoClose deletes the entry
            HVIDEO hv = pinfo->hv;
            pinfo = pinfo->pNext;

            videoClose(hv);
        } else {
            pinfo = pinfo->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}


// ----------------------------------------------------------------------




/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
LRESULT WINAPI NTvideoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return SendDriverMessage ((HDRVR)hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI NTvideoGetNumDevs(void)
{
    DWORD dwNumDevs = 0;

    if(DV_ERR_OK == videoCreateDriverList ()) {
       dwNumDevs = wTotalVideoDevs;  // Save it before reseting to 0 in videoFreeDriverList.
       videoFreeDriverList ();    
    }
                                                                       
    return dwNumDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetErrorText | This function retrieves a
 *   description of the error identified by the error number.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *	This might be NULL if the error is not device specific.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer used to
 *       return the zero-terminated string corresponding to the error number.
 *
 * @parm UINT | wSize | Specifies the length, in bytes, of the buffer
 *       referenced by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_BADERRNUM | Specified error number is out of range.
 *   @flag DV_ERR_SIZEFIELD | The return buffer is not large enough
 *         to handle the error text.
 *
 * @comm If the error description is longer than the buffer,
 *   the description is truncated. The returned error string is always
 *   zero-terminated. If <p wSize> is zero, nothing is copied and zero
 *   is returned.
 ****************************************************************************/
#ifdef UNICODE  // Translate UNICODE response to ansi
DWORD WINAPI NTvideoGetErrorTextA(HVIDEO hVideo, UINT wError,
			LPSTR lpText, UINT wSize)
{
    return DV_ERR_NOTSUPPORTED;

#if 0
    VIDEO_GETERRORTEXT_PARMS vet;

    if (IsBadWritePtr (lpText, wSize))
        return DV_ERR_PARAM1;

    lpText[0] = 0;
    if (((wError >= DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringA(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        DWORD dwResult;
        LPWSTR lpwstr = LocalAlloc(LPTR, wSize*sizeof(WCHAR));
        if (NULL == lpwstr) {
            return(DV_ERR_NOMEM);
        }
        vet.dwError = (DWORD) wError;
        vet.lpText = lpwstr;
        vet.dwLength = (DWORD) wSize;
        dwResult = (DWORD)NTvideoMessage (hVideo, DVM_GETERRORTEXT, (LPARAM) (LPVOID) &vet,
                        NULL);
        if (DV_ERR_OK == dwResult) {
            Iwcstombs(lpText, lpwstr, wSize);
        }
        LocalFree(lpwstr);
        return(dwResult);
    }
    else
        return DV_ERR_BADERRNUM;
#endif
}
#endif //UNICODE

//
// The unicode/Win16 equivalent of the above
//

DWORD WINAPI NTvideoGetErrorTextW(HVIDEO hVideo, UINT wError,
			LPWSTR lpText, UINT wSize)
{
    return DV_ERR_NOTSUPPORTED;

#if 0
    VIDEO_GETERRORTEXT_PARMS vet;
    lpText[0] = 0;

    if (((wError > DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringW(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        vet.dwError = (DWORD) wError;
        vet.lpText = lpText;
        vet.dwLength = (DWORD) wSize;
        return (DWORD)NTvideoMessage (hVideo, DVM_GETERRORTEXT, (LPARAM) (LPVOID) &vet,
                        NULL);
    }
    else
        return DV_ERR_BADERRNUM;
#endif
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI NTvideoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
			DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return (DWORD)NTvideoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (LPARAM)lpChannelCaps,
		dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoUpdate | This function directs a channel to
 *   repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWnd | Specifies the handle of the window to be used
 *      by the channel for image display.
 *
 * @parm HDC | hDC | Specifies a handle to a device context.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_UNSUPPORTED | Specified message is unsupported.
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm This message is normally sent
 *   whenever the client window receives a <m WM_MOVE>, <m WM_SIZE>,
 *   or <m WM_PAINT> message.
 ****************************************************************************/
DWORD WINAPI NTvideoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC)
{
    if ((!hVideo) || (!hWnd) || (!hDC) )
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_UPDATE, (LPARAM)hWnd, (LPARAM)hDC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *	     for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock mem