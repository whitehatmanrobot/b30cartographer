 }

    if (S_OK == hr)
    {
        //
        // Set the Path property.
        //

        hr = pwcoInstance->Put(
                c_wszPath,
                0,
                &vt,
                NULL
                );

        //
        // Clearing the variant will free the BSTR we allocated
        // above.
        //

        VariantClear(&vt);
    }


    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set max file size
        //

        V_VT(&vt) = VT_I4;
        V_I4(&vt) = pfwSettings->ulMaxFileSize;

        hr = pwcoInstance->Put(
                c_wszMaxFileSize,
                0,
                &vt,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set log dropped packets value
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszLogDroppedPackets,
                pfwSettings->fLogDroppedPackets
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set log connections value
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszLogConnections,
                pfwSettings->fLogConnections
                );
    }

    return hr;
}

HRESULT
CHNetCfgMgr::InstallBridge(
    GUID                *pguid,
    INetCfg             *pnetcfgExisting
    )
{
    HRESULT                 hr = S_OK;
    INetCfg                 *pnetcfg = NULL;
    INetCfgLock             *pncfglock = NULL;
    INetCfgComponent        *pncfgcomp = NULL;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we can't acquire NetCfg.
        if( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    // ===================================================================
    // (cut here)
    //
    // Check if the bridge component already exists
    //
    // **
    // Remove this check when it becomes legal to have
    // multiple bridges
    // **
    //
    hr = pnetcfg->FindComponent(
            c_wszSBridgeMPID,
            &pncfgcomp
            );

    // S_OK indicates that the bridge component is present, which is BAD.
    // We take any other success code to indicate that the search succeeded,
    // but that the bridge component was not present (which is what we want).
    // We take failure codes to mean the search blew up.
    if ( S_OK == hr )
    {
        // Bridge was present
        pncfgcomp->Release();
        hr = E_UNEXPECTED;
    }
    // (cut here)
    // ===================================================================

    if ( SUCCEEDED(hr) )
    {
        const GUID          guidClass = GUID_DEVCLASS_NET;
        INetCfgClassSetup   *pncfgsetup = NULL;

        //
        // Recover the NetCfgClassSetup interface
        //
        hr = pnetcfg->QueryNetCfgClass(
                &guidClass,
                IID_PPV_ARG(INetCfgClassSetup, &pncfgsetup)
                );

        if ( SUCCEEDED(hr) )
        {
            //
            // Install the bridge miniport component
            //
            hr = pncfgsetup->Install(
                    c_wszSBridgeMPID,
                    NULL,
                    NSF_PRIMARYINSTALL,
                    0,
                    NULL,
                    NULL,
                    &pncfgcomp
                    );

            if ( SUCCEEDED(hr) )
            {
                hr = pncfgcomp->GetInstanceGuid(pguid);
                pncfgcomp->Release();
            }

            pncfgsetup->Release();
        }
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();

            // Signal that the bridge should be drawn
            SignalNewConnection( pguid );
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}

HRESULT
CHNetCfgMgr::CreateConnectionAndPropertyInstances(
    GUID *pGuid,
    BOOLEAN fLanConnection,
    LPCWSTR pszwName,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

{
    HRESULT hr;
    BSTR bstr = NULL;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties;
    IWbemCallResult *pResult;
    VARIANT vt;

    _ASSERT(NULL != pGuid);
    _ASSERT(NULL != pszwName);
    _ASSERT(NULL != ppwcoConnection);
    _ASSERT(NULL != ppwcoProperties);

    //
    // Create the HNet_Connection instance
    //

    hr = SpawnNewInstance(
            m_piwsHomenet,
            c_wszHnetConnection,
            &pwcoConnection
            );

    //
    // Fill out the HNet_Connection instance
    //

    if (WBEM_S_NO_ERROR == hr)
    {
        LPOLESTR wszGuid;

        //
        // Set GUID property
        //

        hr = StringFromCLSID(*pGuid, &wszGuid);

        if (S_OK == hr)
        {
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(wszGuid);

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoConnection->Put(
                        c_wszGuid,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            CoTaskMemFree(wszGuid);
        }

        //
        // Set Name property
        //

        if (WBEM_S_NO_ERROR == hr)
        {
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(pszwName);

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoConnection->Put(
                        c_wszName,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Set the IsLan property
            //

            hr = SetBooleanValue(
                    pwcoConnection,
                    c_wszIsLanConnection,
                    fLanConnection
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Commit the object and retrieve its path
            //

            pResult = NULL;
            hr = m_piwsHomenet->PutInstance(
                    pwcoConnection,
                    WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                    NULL,
                    &pResult
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                pwcoConnection->Release();
                pwcoConnection = NULL;

                hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
                pResult->Release();

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = GetWmiObjectFromPath(
                            m_piwsHomenet,
                            bstr,
                            &pwcoConnection
                            );

                    if (FAILED(hr))
                    {
                        SysFreeString(bstr);
                        bstr = NULL;
                    }

                    //
                    // The bstr will be freed below on success
                    //
                }
            }
        }

        if (FAILED(hr) && NULL != pwcoConnection)
        {
            //
            // Something went wrong -- get rid
            // of the instance we created
            //

            pwcoConnection->Release();
            pwcoConnection = NULL;
        }
    }

    if (S_OK == hr)
    {
        //
        // Create the HNet_ConnectionProperties instance
        //

        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetProperties,
                &pwcoProperties
                );

        //
        // Fill out the HNet_ConnectionProperties instance
        //

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Set the path to our connection
            //

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = bstr;
            hr = pwcoProperties->Put(
                    c_wszConnection,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
            bstr = NULL;

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsFirewalled,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsIcsPublic,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsIcsPrivate,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Commit properties instance to the store
                //

                pResult = NULL;
                hr = m_piwsHomenet->PutInstance(
                        pwcoProperties,
                        WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                        NULL,
                        &pResult
                        );

                if (WBEM_S_NO_ERROR == hr)
                {
                    pwcoProperties->Release();
                    pwcoProperties = NULL;

                    hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
                    pResult->Release();

                    if (WBEM_S_NO_ERROR == hr)
                    {
                        hr = GetWmiObjectFromPath(
                                m_piwsHomenet,
                                bstr,
                                &pwcoProperties
                                );

                        SysFreeString(bstr);
                        bstr = NULL;
                    }
                }
            }

            if (FAILED(hr))
            {
                //
                // Something went wrong -- get rid of the instances
                // we created. We also need to delete the connection
                // instance from the store.
                //

                DeleteWmiInstance(m_piwsHomenet, pwcoConnection);

                pwcoConnection->Release();
                pwcoConnection = NULL;

                if (NULL != pwcoProperties)
                {
                    pwcoProperties->Release();
                    pwcoProperties = NULL;
                }
            }
        }
    }

    if (bstr) {
        SysFreeString (bstr);
        bstr = NULL;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Transferring reference, so skip release on pwco[x] and
        // addref on ppwco[x]
        //

        *ppwcoConnection = pwcoConnection;
        *ppwcoProperties = pwcoProperties;
    }

    return hr;
}

BOOLEAN
CHNetCfgMgr::ProhibitedByPolicy(
    DWORD dwPerm
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fProhibited = FALSE;

    if (NULL == m_pNetConnUiUtil)
    {
        Lock();

        if (NULL == m_pNetConnUiUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionUiUtilities,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(INetConnectionUiUtilities, &m_pNetConnUiUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        fProhibited = !m_pNetConnUiUtil->UserHasPermission(dwPerm);
    }

    return fProhibited;
}

HRESULT
CHNetCfgMgr::UpdateNetman()

{
    HRESULT hr = S_OK;

    if (NULL == m_pNetConnHNetUtil)
    {
        Lock();

        if (NULL == m_pNetConnHNetUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionHNetUtil,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(INetConnectionHNetUtil, &m_pNetConnHNetUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pNetConnHNetUtil->NotifyUpdate();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnetconn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N E T C O N N . C P P
//
//  Contents:   CHNetConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Prototype for iphlpapi routine. For some reason, this isn't defined
// in any header.
//

extern "C"
DWORD
APIENTRY
SetAdapterIpAddress(LPSTR AdapterName,
                    BOOL EnableDHCP,
                    ULONG IPAddress,
                    ULONG SubnetMask,
                    ULONG DefaultGateway
                    );

//
// CLSIDs for connection objects. We don't want to pull in all of the
// other guids that are defined in nmclsid.h, so we copy these
// into here
//

#define INITGUID
#include <guiddef.h>
DEFINE_GUID(CLSID_DialupConnection,
0xBA126AD7,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnection,
0xBA126ADB,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
#undef INITGUID

//
// ATL Methods
//

HRESULT
CHNetConn::FinalConstruct()

{
    HRESULT hr = S_OK;

    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT
CHNetConn::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrConnection) SysFreeString(m_bstrConnection);
    if (m_bstrProperties) SysFreeString(m_bstrProperties);
    if (m_pNetConn) m_pNetConn->Release();
    if (m_bstrWQL) SysFreeString(m_bstrWQL);
    if (m_wszName) CoTaskMemFree(m_wszName);
    if (m_pGuid) CoTaskMemFree(m_pGuid);
    if (m_pNetConnUiUtil) m_pNetConnUiUtil->Release();
    if (m_pNetConnHNetUtil) m_pNetConnHNetUtil->Release();
    if (m_pNetConnRefresh) m_pNetConnRefresh->Release();

    return S_OK;
}

//
// Ojbect initialization
//

HRESULT
CHNetConn::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoProperties
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoConnection;
    VARIANT vt;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoProperties);

    //
    // Store pointer to our namespace.
    //

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    //
    // Get the path to the properties
    //

    hr = GetWmiPathFromObject(pwcoProperties, &m_bstrProperties);

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the path to the HNet_Connection from our properties
        //

        hr = pwcoProperties->Get(
                c_wszConnection,
                0,
                &vt,
                NULL,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        m_bstrConnection = V_BSTR(&vt);

        //
        // BSTR ownership transfered to object
        //

        VariantInit(&vt);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the underying connection object
        //

        hr = GetConnectionObject(&pwcoConnection);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // See if this is a lan connection
        //

        hr = GetBooleanValue(
                pwcoConnection,
                c_wszIsLanConnection,
                &m_fLanConnection
                );

        pwcoConnection->Release();
    }

    return hr;
}

HRESULT
CHNetConn::InitializeFromConnection(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoProperties;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoConnection);

    //
    // Store pointer to our namespace.
    //

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    //
    // Get the path to our connection
    //

    hr = GetWmiPathFromObject(pwcoConnection, &m_bstrConnection);

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the HNet_ConnectionProperties for our connection and
        // store its path
        //

        hr = GetPropInstanceFromConnInstance(
                piwsNamespace,
                pwcoConnection,
                &pwcoProperties
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = GetWmiPathFromObject(pwcoProperties, &m_bstrProperties);

            pwcoProperties->Release();
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // See if this is a lan connection
        //

        hr = GetBooleanValue(
                pwcoConnection,
                c_wszIsLanConnection,
                &m_fLanConnection
                );
    }

    return hr;
}

HRESULT
CHNetConn::InitializeFromInstances(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection,
    IWbemClassObject *pwcoProperties
    )

{
    HRESULT hr;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoConnection);
    _ASSERT(NULL != pwcoProperties);

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    hr = GetWmiPathFromObject(pwcoConnection, &m_bstrConnection);

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetWmiPathFromObject(pwcoProperties, &m_bstrProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoConnection,
                c_wszIsLanConnection,
                &m_fLanConnection
                );
    }

    return hr;
}

HRESULT
CHNetConn::InitializeFull(
    IWbemServices *piwsNamespace,
    BSTR bstrConnection,
    BSTR bstrProperties,
    BOOLEAN fLanConnection
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrConnection);
    _ASSERT(NULL == m_bstrProperties);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrConnection);
    _ASSERT(NULL != bstrProperties);

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();
    m_fLanConnection = fLanConnection;

    m_bstrConnection = SysAllocString(bstrConnection);
    if (NULL != m_bstrConnection)
    {
        m_bstrProperties = SysAllocString(bstrProperties);
        if (NULL == m_bstrProperties)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT
CHNetConn::SetINetConnection(
    INetConnection *pConn
    )

{
    Lock();

    _ASSERT(NULL == m_pNetConn);
    _ASSERT(NULL != pConn);

    m_pNetConn = pConn;
    m_pNetConn->AddRef();

    Unlock();

    return S_OK;
}

//
// IHNetConnection methods
//

STDMETHODIMP
CHNetConn::GetINetConnection(
    INetConnection **ppNetConnection
    )

{
    HRESULT hr = S_OK;
    GUID *pGuid;

    if (NULL != ppNetConnection)
    {
        *ppNetConnection = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        Lock();

        if (NULL != m_pNetConn)
        {
            //
            // We've already cached away a pointer.
            //

            *ppNetConnection = m_pNetConn;
            (*ppNetConnection)->AddRef();
        }
        else
        {
            //
            // We don't have a cached pointer. Create the correct
            // connection object type and initialize appropriately.
            //

            hr = GetGuidInternal(&pGuid);

            if (S_OK == hr)
            {
                if (m_fLanConnection)
                {
                    INetLanConnection *pLanConnection;

                    hr = CoCreateInstance(
                            CLSID_LanConnection,
                            NULL,
                            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                            IID_PPV_ARG(INetLanConnection, &pLanConnection)
                            );

                    if (SUCCEEDED(hr))
                    {
                        LANCON_INFO lanInfo;

                        //
                        // We must set the proxy blanket on the object we just
                        // created.
                        //

                        SetProxyBlanket(pLanConnection);
                        
                        //
                        // We don't need to include the name to initialize
                        // a LAN connection -- the guid is sufficient.
                        //

                        lanInfo.szwConnName = NULL;
                        lanInfo.fShowIcon = TRUE;
                        lanInfo.guid = *pGuid;

                        hr = pLanConnection->SetInfo(
                                LCIF_COMP,
                                &lanInfo
                                );

                        if (SUCCEEDED(hr))
                        {
                            hr = pLanConnection->QueryInterface(
                                    IID_PPV_ARG(
                                        INetConnection,
                                        ppNetConnection
                                        )
                                    );

                            if (SUCCEEDED(hr))
                            {
                                SetProxyBlanket(*ppNetConnection);
                            }
                        }

                        pLanConnection->Release();
                                
                    }
                }
                else
                {
                    INetRasConnection *pRasConnection;

                    hr = CoCreateInstance(
                            CLSID_DialupConnection,
                            NULL,
                            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                            IID_PPV_ARG(INetRasConnection, &pRasConnection)
                            );

                    if (SUCCEEDED(hr))
                    {
                        OLECHAR *pszwName;
                        OLECHAR *pszwPath;

                        //
                        // We must set the proxy blanket on the object we just
                        // created.
                        //

                        SetProxyBlanket(pRasConnection);
                        
                        //
                        // We need to obtain the name and path of a RAS
                        // connection in order to initialize it.
                        //

                        hr = GetRasConnectionName(&pszwName);

                        if (S_OK == hr)
                        {
                            hr = GetRasPhonebookPath(&pszwPath);

                            if (S_OK == hr)
                            {
                                RASCON_INFO rasInfo;

                                rasInfo.pszwPbkFile = pszwPath;
                                rasInfo.pszwEntryName = pszwName;
                                rasInfo.guidId = *pGuid;

                                hr = pRasConnection->SetRasConnectionInfo(
                                        &rasInfo
                                        );

                                if (SUCCEEDED(hr))
                                {
                                    hr = pRasConnection->QueryInterface(
                                            IID_PPV_ARG(
                                                INetConnection,
                                                ppNetConnection
                                                )
                                            );

                                    if (SUCCEEDED(hr))
                                    {
                                        SetProxyBlanket(*ppNetConnection);
                                    }
                                }

                                CoTaskMemFree(pszwPath);
                            }
                            
                            CoTaskMemFree(pszwName);
                        }

                        pRasConnection->Release();
                    }
                }
                
                if (SUCCEEDED(hr))
                {
                    //
                    // Cache the connection
                    //

                    m_pNetConn = *ppNetConnection;
                    m_pNetConn->AddRef();
                    hr = S_OK;
                }
            }
        }

        Unlock();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetGuid(
    GUID **ppGuid
    )

{
    HRESULT hr = S_OK;

    if (NULL == ppGuid)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Allocate memory for the guid
        //

        *ppGuid = reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

        if (NULL == *ppGuid)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        GUID *pGuid;

        //
        // Get our guid
        //

        hr = GetGuidInternal(&pGuid);

        if (SUCCEEDED(hr))
        {
            CopyMemory(
                reinterpret_cast<PVOID>(*ppGuid),
                reinterpret_cast<PVOID>(pGuid),
                sizeof(GUID)
                );
        }
        else
        {
            CoTaskMemFree(*ppGuid);
            *ppGuid = NULL;
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetName(
    OLECHAR **ppszwName
    )

{
    HRESULT hr = S_OK;
    INetConnection *pConn;
    NETCON_PROPERTIES *pProps;
    OLECHAR *pszwOldName = NULL;

    if (NULL != ppszwName)
    {
        *ppszwName = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        Lock();

        hr = GetINetConnection(&pConn);

        if (S_OK == hr)
        {
            hr = pConn->GetProperties(&pProps);

            if (SUCCEEDED(hr))
            {
                pszwOldName = m_wszName;
                m_wszName = pProps->pszwName;

                //
                // We can't call NcFreeNetconProperties, as that
                // would free the string pointer we just tucked away.
                //

                CoTaskMemFree(pProps->pszwDeviceName);
                CoTaskMemFree(pProps);
                hr = S_OK;
            }

            pConn->Release();
        }

        //
        // If the new name is not the same as the old name
        // store the new name
        //

        if (S_OK == hr
            && (NULL == pszwOldName
                || 0 != wcscmp(pszwOldName, m_wszName)))
        {
            IWbemClassObject *pwcoConnection;
            HRESULT hr2;
            VARIANT vt;

            hr2 = GetConnectionObject(&pwcoConnection);

            if (WBEM_S_NO_ERROR == hr2)
            {
                //
                // Write the retrieved name to the store. (While the stored
                // name is used only for debugging purposes, it's worth the
                // hit to keep it up to date.)
                //

                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(m_wszName);

                if (NULL != V_BSTR(&vt))
                {
                    hr2 = pwcoConnection->Put(
                            c_wszName,
                            0,
                            &vt,
                            NULL
                            );

                    VariantClear(&vt);

                    if (WBEM_S_NO_ERROR == hr2)
                    {
                        m_piwsHomenet->PutInstance(
                            pwcoConnection,
                            WBEM_FLAG_UPDATE_ONLY,
                            NULL,
                            NULL
                            );
                    }
                }

                pwcoConnection->Release();
            }
        }

        if (S_OK == hr)
        {
            ULONG ulSize = (wcslen(m_wszName) + 1) * sizeof(OLECHAR);

            *ppszwName = reinterpret_cast<OLECHAR*>(
                            CoTaskMemAlloc(ulSize)
                            );

            if (NULL != *ppszwName)
            {
                CopyMemory(
                    reinterpret_cast<PVOID>(*ppszwName),
                    reinterpret_cast<PVOID>(m_wszName),
                    ulSize
                    );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        Unlock();
    }

    if (NULL != pszwOldName)
    {
        CoTaskMemFree(pszwOldName);
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetRasPhonebookPath(
    OLECHAR **ppszwPath
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;
    IWbemClassObject *pwcoConnection;

    if (NULL != ppszwPath)
    {
        *ppszwPath = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (TRUE == m_fLanConnection)
    {
        hr = E_UNEXPECTED;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionObject(&pwcoConnection);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoConnection->Get(
                c_wszPhonebookPath,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoConnection->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        *ppszwPath = reinterpret_cast<OLECHAR*>(
                        CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                        * sizeof(OLECHAR))
                        );

        if (NULL != *ppszwPath)
        {
            wcscpy(*ppszwPath, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        VariantClear(&vt);
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetProperties(
    HNET_CONN_PROPERTIES **ppProperties
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppProperties)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProperties = reinterpret_cast<HNET_CONN_PROPERTIES*>(
                            CoTaskMemAlloc(sizeof(HNET_CONN_PROPERTIES))
                            );

        if (NULL == *ppProperties)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = InternalGetProperties(pwcoProperties, *ppProperties);
            pwcoProperties->Release();
        }

        if (FAILED(hr))
        {
            CoTaskMemFree(*ppProperties);
            *ppProperties = NULL;
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetControlInterface(
    REFIID iid,
    void **ppv
    )

{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES Props;

    if (NULL != ppv)
    {
        *ppv = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // See if a simple QI will produce the desired interface
        //

        hr = QueryInterface(iid, ppv);
        if (FAILED(hr))
        {
            //
            // Nope. Get our properties and see if it's appropriate to
            // provide the requested control interface.
            //

            IWbemClassObject *pwcoProperties;

            hr = GetConnectionPropertiesObject(&pwcoProperties);

            if (WBEM_S_NO_ERROR == hr)
            {
                hr = InternalGetProperties(pwcoProperties, &Props);
                pwcoProperties->Release();
            }

            if (S_OK == hr)
            {
                if (IsEqualGUID(
                        __uuidof(IHNetFirewalledConnection),
                        iid
                        ))
                {
                    if (TRUE == Props.fFirewalled)
                    {
                        CComObject<CHNFWConn> *pfwConn;
                        hr = CComObject<CHNFWConn>::CreateInstance(&pfwConn);
                        if (SUCCEEDED(hr))
                        {
                            pfwConn->AddRef();

                            hr = pfwConn->InitializeFull(
                                            m_piwsHomenet,
                                            m_bstrConnection,
                                            m_bstrProperties,
                                            m_fLanConnection
                                            );

                            if (SUCCEEDED(hr))
                            {
                                hr = pfwConn->QueryInterface(iid, ppv);
                            }

                            pfwConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetIcsPublicConnection),
                            iid
                            ))
                {
                    if (TRUE == Props.fIcsPublic)
                    {
                        CComObject<CHNIcsPublicConn> *pIcsPubConn;
                        hr = CComObject<CHNIcsPublicConn>::CreateInstance(&pIcsPubConn);
                        if (SUCCEEDED(hr))
                        {
                            pIcsPubConn->AddRef();

                            hr = pIcsPubConn->InitializeFull(
                                                m_piwsHomenet,
                                                m_bstrConnection,
                                                m_bstrProperties,
                                                m_fLanConnection
                                                );

                            if (SUCCEEDED(hr))
                            {
                                hr = pIcsPubConn->QueryInterface(iid, ppv);
                            }

                            pIcsPubConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetIcsPrivateConnection),
                            iid
                            ))
                {
                    if (TRUE == Props.fIcsPrivate)
                    {
                        CComObject<CHNIcsPrivateConn> *pIcsPrvConn;
                        hr = CComObject<CHNIcsPrivateConn>::CreateInstance(&pIcsPrvConn);
                        if (SUCCEEDED(hr))
                        {
                            pIcsPrvConn->AddRef();

                            hr = pIcsPrvConn->InitializeFull(
                                                m_piwsHomenet,
                                                m_bstrConnection,
                                                m_bstrProperties,
                                                m_fLanConnection
                                                );

                            if (SUCCEEDED(hr))
                            {
                                hr = pIcsPrvConn->QueryInterface(iid, ppv);
                            }

                            pIcsPrvConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetBridge),
                            iid
                            ))
                {
                    if (TRUE == Props.fBridge)
                    {
                        CComObject<CHNBridge> *pBridge;
                        hr = CComObject<CHNBridge>::CreateInstance(&pBridge);
                        if (SUCCEEDED(hr))
                        {
                            pBridge->AddRef();

                            hr = pBridge->InitializeFull(
                                            m_piwsHomenet,
                                            m_bstrConnection,
                                            m_bstrProperties,
                                            m_fLanConnection
                                            );

                            if (SUCCEEDED(hr))
                            {
                                hr = pBridge->QueryInterface(iid, ppv);
                            }

                            pBridge->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else if (IsEqualGUID(
                            __uuidof(IHNetBridgedConnection),
                            iid
                            ))
                {
                    if (TRUE == Props.fPartOfBridge)
                    {
                        CComObject<CHNBridgedConn> *pBridgeConn;
                        hr = CComObject<CHNBridgedConn>::CreateInstance(&pBridgeConn);
                        if (SUCCEEDED(hr))
                        {
                            pBridgeConn->AddRef();

                            hr = pBridgeConn->InitializeFull(
                                                m_piwsHomenet,
                                                m_bstrConnection,
                                                m_bstrProperties,
                                                m_fLanConnection
                                                );

                            if (SUCCEEDED(hr))
                            {
                                hr = pBridgeConn->QueryInterface(iid, ppv);
                            }

                            pBridgeConn->Release();
                        }
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
                else
                {
                    //
                    // Unknown control interface
                    //

                    hr = E_NOINTERFACE;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::Firewall(
    IHNetFirewalledConnection **ppFirewalledConn
    )
{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppFirewalledConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppFirewalledConn = NULL;

        //
        // We fail immediately if firewalling is prohibited by policy,
        // or if RRAS is configured.
        //

        if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
        {
            hr = HN_E_POLICY;
        }

        if (IsRrasConfigured())
        {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT);
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (S_OK == hr)
    {
        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (S_OK == hr)
        {
            if (FALSE == hnProps.fCanBeFirewalled || TRUE == hnProps.fFirewalled)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                //
                // Set the firewalled property to true
                //

                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsFirewalled,
                        TRUE
                        );
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //

            UpdateNetman();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Create the new object
            //

            CComObject<CHNFWConn> *pfwConn;
            hr = CComObject<CHNFWConn>::CreateInstance(&pfwConn);

            if (SUCCEEDED(hr))
            {
                pfwConn->AddRef();

                hr = pfwConn->InitializeFull(
                        m_piwsHomenet,
                        m_bstrConnection,
                        m_bstrProperties,
                        m_fLanConnection
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pfwConn->QueryInterface(
                            IID_PPV_ARG(IHNetFirewalledConnection, ppFirewalledConn)
                            );
                }

                pfwConn->Release();
            }
        }

        pwcoProperties->Release();
    }

    if (S_OK == hr)
    {
        //
        // Make sure the service is started
        //

        DWORD dwError = StartOrUpdateService();
        if (NO_ERROR != dwError)
        {
            (*ppFirewalledConn)->Unfirewall();
            (*ppFirewalledConn)->Release();
            *ppFirewalledConn = NULL;
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RefreshNetConnectionsUI();

    }

    return hr;
}

STDMETHODIMP
CHNetConn::SharePublic(
    IHNetIcsPublicConnection **ppIcsPublicConn
    )
{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppIcsPublicConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIcsPublicConn = NULL;

        //
        // We fail immediately if sharing is prohibited by policy,
        // or if RRAS is configured.
        //

        if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
        {
            hr = HN_E_POLICY;
        }

        if (IsRrasConfigured())
        {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT);
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (S_OK == hr)
        {
            if (FALSE == hnProps.fCanBeIcsPublic || TRUE == hnProps.fIcsPublic)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                //
                // Set the ICS Public property to true
                //
                hr = SetBooleanValue(
                        pwcoProperties,
                        c_wszIsIcsPublic,
                        TRUE
                        );
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //

            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create the new object
        //

        CComObject<CHNIcsPublicConn> *pIcsConn;
        hr = CComObject<CHNIcsPublicConn>::CreateInstance(&pIcsConn);

        if (SUCCEEDED(hr))
        {
            pIcsConn->AddRef();

            hr = pIcsConn->InitializeFull(
                    m_piwsHomenet,
                    m_bstrConnection,
                    m_bstrProperties,
                    m_fLanConnection
                    );

            if (SUCCEEDED(hr))
            {
                hr = pIcsConn->QueryInterface(
                        IID_PPV_ARG(IHNetIcsPublicConnection, ppIcsPublicConn)
                        );
            }

            pIcsConn->Release();
        }
    }

    if (S_OK == hr)
    {
        //
        // Make sure the service is started
        //

        DWORD dwError = StartOrUpdateService();
        if (NO_ERROR != dwError)
        {
            (*ppIcsPublicConn)->Unshare();
            (*ppIcsPublicConn)->Release();
            *ppIcsPublicConn = NULL;
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RefreshNetConnectionsUI();

    }

    if (S_OK == hr && m_fLanConnection)
    {
        DWORD dwMode;
        DWORD dwLength = sizeof(dwMode);
        BOOL fResult;

        //
        // If this is a LAN connection, make sure that WinInet is
        // not set to dial always (#143885)
        //

        fResult =
            InternetQueryOption(
                NULL,
                INTERNET_OPTION_AUTODIAL_MODE,
                &dwMode,
                &dwLength
                );

        _ASSERT(TRUE == fResult);

        if (fResult && AUTODIAL_MODE_ALWAYS == dwMode)
        {
            //
            // Set the mode to contingent dialing.
            //

            dwMode = AUTODIAL_MODE_NO_NETWORK_PRESENT;
            fResult =
                InternetSetOption(
                    NULL,
                    INTERNET_OPTION_AUTODIAL_MODE,
                    &dwMode,
                    sizeof(dwMode)
                    );

            _ASSERT(TRUE == fResult);
        }
    }
    else if (S_OK == hr)
    {
        RASAUTODIALENTRYW adEntry;
        OLECHAR *pszwName;
        HRESULT hr2;

        //
        // Set this to be the RAS default connection. Errors
        // are not propagated to caller.
        //

        hr2 = GetName(&pszwName);

        if (S_OK == hr2)
        {
            ZeroMemory(&adEntry, sizeof(adEntry));
            adEntry.dwSize = sizeof(adEntry);
            wcsncpy(
                adEntry.szEntry,
                pszwName,
                sizeof(adEntry.szEntry)/sizeof(WCHAR)
                );

            RasSetAutodialAddress(
                NULL,
                0,
                &adEntry,
                sizeof(adEntry),
                1
                );

            CoTaskMemFree(pszwName);
        }
    }

    return hr;
}

STDMETHODIMP
CHNetConn::SharePrivate(
    IHNetIcsPrivateConnection **ppIcsPrivateConn
    )
{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IWbemClassObject *pwcoProperties;

    if (NULL == ppIcsPrivateConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIcsPrivateConn = NULL;

        //
        // We fail immediately if sharing is prohibited by policy,
        // or if RRAS is configured.
        //

        if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
        {
            hr = HN_E_POLICY;
        }

        if (IsRrasConfigured())
        {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT);
        }
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {

        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (S_OK == hr)
        {
            if (FALSE == hnProps.fCanBeIcsPrivate || TRUE == hnProps.fIcsPrivate)
            {
                hr = E_UNEXPECTED;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Backup current address information
            //

            hr = BackupIpConfiguration();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // if we are in ICS Upgrade, we don't need
            // to setup the private address because dhcp client won't be running in GUI Mode Setup
            // and the private tcpip addresses should be upgraded as is.
            //    
            HANDLE hIcsUpgradeEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, c_wszIcsUpgradeEventName );
                 
            if ( NULL != hIcsUpgradeEvent )
            {
                CloseHandle( hIcsUpgradeEvent );
            }
            else
            {

                //
                // Setup addressing for private usage
                //

                hr = SetupConnectionAsPrivateLan();
            }
        }

        if (S_OK == hr)
        {
            //
            // Set the ICS Public property to true
            //

            hr = SetBooleanValue(
                    pwcoProperties,
                    c_wszIsIcsPrivate,
                    TRUE
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //

            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create the new object
        //

        CComObject<CHNIcsPrivateConn> *pIcsConn;
        hr = CComObject<CHNIcsPrivateConn>::CreateInstance(&pIcsConn);

        if (SUCCEEDED(hr))
        {
            pIcsConn->AddRef();

            hr = pIcsConn->InitializeFull(
                    m_piwsHomenet,
                    m_bstrConnection,
                    m_bstrProperties,
                    m_fLanConnection
                    );

            if (SUCCEEDED(hr))
            {
                hr = pIcsConn->QueryInterface(
                        IID_PPV_ARG(IHNetIcsPrivateConnection, ppIcsPrivateConn)
                        );
            }

            pIcsConn->Release();
        }
    }
    else
    {
        //
        // Restore backup address information
        //

        RestoreIpConfiguration();
    }

    if (S_OK == hr)
    {
        //
        // Make sure the service is started
        //

        DWORD dwError = StartOrUpdateService();
        if (NO_ERROR != dwError)
        {
            (*ppIcsPrivateConn)->RemoveFromIcs();
            (*ppIcsPrivateConn)->Release();
            *ppIcsPrivateConn = NULL;
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RefreshNetConnectionsUI();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::EnumPortMappings(
    BOOLEAN fEnabledOnly,
    IEnumHNetPortMappingBindings **ppEnum
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    LPWSTR wszWhere;
    IEnumWbemClassObject *pwcoEnum;

    if (NULL != ppEnum)
    {
        *ppEnum = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr && FALSE == fEnabledOnly)
    {
        //
        // Make sure that we have port mapping binding instances for
        // all of the port mapping protocols. If we're only enumerating
        // enabled protocols, then there's no need for us to create
        // anything.
        //

        hr = CreatePortMappingBindings();
    }

    if (S_OK == hr)
    {
        hr = BuildEscapedQuotedEqualsString(
                &wszWhere,
                c_wszConnection,
                m_bstrConnection
                );

        if (S_OK == hr && fEnabledOnly)
        {
            LPWSTR wsz;

            //
            // Add "AND Enabled != FALSE"
            //

            hr = BuildAndString(
                    &wsz,
                    wszWhere,
                    L"Enabled != FALSE"
                    );

            delete [] wszWhere;

            if (S_OK == hr)
            {
                wszWhere = wsz;
            }
        }
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wszWhere
                );

        delete [] wszWhere;
    }

    if (S_OK == hr)
    {
        //
        // Execute the query and build the enum wrapper
        //

        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        CComObject<CEnumHNetPortMappingBindings> *pEnum;

        hr = CComObject<CEnumHNetPortMappingBindings>::CreateInstance(&pEnum);

        if (S_OK == hr)
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (S_OK == hr)
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetPortMappingBindings, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}


STDMETHODIMP
CHNetConn::GetBindingForPortMappingProtocol(
    IHNetPortMappingProtocol *pProtocol,
    IHNetPortMappingBinding **ppBinding
    )

{
    HRESULT hr = S_OK;
    BSTR bstrConPath;
    BSTR bstrProtPath;
    IWbemClassObject *pwcoInstance;
    USHORT usPublicPort;

    if (NULL == pProtocol)
    {
        hr = E_INVALIDARG;
    }
    else if (NULL == ppBinding)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppBinding = NULL;
    }

    if (S_OK == hr)
    {
        hr = pProtocol->GetPort(&usPublicPort);
    }

    if (S_OK == hr)
    {
        IHNetPrivate *pHNetPrivate;

        //
        // Use our private interface to get the path to the
        // protocol object
        //

        hr = pProtocol->QueryInterface(
                IID_PPV_ARG(IHNetPrivate, &pHNetPrivate)
                );

        if (S_OK == hr)
        {
            hr = pHNetPrivate->GetObjectPath(&bstrProtPath);
            pHNetPrivate->Release();
        }
    }

    //
    // Retrieve the binding instance for the protocol. If
    // it doesn't yet exist, this routine will create it.
    //

    if (S_OK == hr)
    {
        hr = GetPortMappingBindingInstance(
                m_piwsHomenet,
                m_bstrWQL,
                m_bstrConnection,
                bstrProtPath,
                usPublicPort,
                &pwcoInstance
                );

        SysFreeString(bstrProtPath);
    }


    if (S_OK == hr)
    {
        CComObject<CHNetPortMappingBinding> *pBinding;

        hr = CComObject<CHNetPortMappingBinding>::CreateInstance(&pBinding);

        if (S_OK == hr)
        {
            pBinding->AddRef();

            hr = pBinding->Initialize(m_piwsHomenet, pwcoInstance);

            if (S_OK == hr)
            {
                hr = pBinding->QueryInterface(
                        IID_PPV_ARG(IHNetPortMappingBinding, ppBinding)
                        );
            }

            pBinding->Release();
        }

        pwcoInstance->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::GetIcmpSettings(
    HNET_FW_ICMP_SETTINGS **ppSettings
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoSettings;

    if (NULL != ppSettings)
    {
        //
        // Allocate output structure
        //

        *ppSettings = reinterpret_cast<HNET_FW_ICMP_SETTINGS*>(
                        CoTaskMemAlloc(sizeof(HNET_FW_ICMP_SETTINGS))
                        );

        if (NULL == *ppSettings)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Retrieve the ICMP setting block for this connection
    //

    if (S_OK == hr)
    {
        hr = GetIcmpSettingsInstance(&pwcoSettings);
    }

    if (S_OK == hr)
    {
        //
        // Copy settings instance to struct
        //

        hr = CopyIcmpSettingsInstanceToStruct(
                pwcoSettings,
                *ppSettings
                );

        pwcoSettings->Release();
    }

    if (FAILED(hr) && NULL != *ppSettings)
    {
        CoTaskMemFree(*ppSettings);
        *ppSettings = NULL;
    }

    return hr;
}

STDMETHODIMP
CHNetConn::SetIcmpSettings(
    HNET_FW_ICMP_SETTINGS *pSettings
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fNewInstance = FALSE;
    VARIANT vt;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoSettings = NULL;
    BSTR bstr;

    if (NULL == pSettings)
    {
        hr = E_INVALIDARG;
    }

    //
    // Retrieve the ICMP setting block for this connection
    //

    if (S_OK == hr)
    {
        hr = GetIcmpSettingsInstance(&pwcoSettings);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Check to see if we need a new settings instace (i.e.,
        // the name of this instance is "Default"
        //

        hr = pwcoSettings->Get(
                c_wszName,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            if (0 == wcscmp(V_BSTR(&vt), c_wszDefault))
            {
                //
                // Need to create new settings block
                //

                fNewInstance = TRUE;
                pwcoSettings->Release();
                pwcoSettings = NULL;
            }

            VariantClear(&vt);
        }
        else
        {
            pwcoSettings->Release();
            pwcoSettings = NULL;
        }
    }

    if (WBEM_S_NO_ERROR == hr && TRUE == fNewInstance)
    {
        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetFwIcmpSettings,
                &pwcoSettings
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = CopyStructToIcmpSettingsInstance(pSettings, pwcoSettings);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        IWbemCallResult *pResult;

        //
        // Write the instance to the store
        //

        pResult = NULL;
        hr = m_piwsHomenet->PutInstance(
                pwcoSettings,
                WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pResult
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // We need to call GetResultString no matter what so that we
            // can get the proper error code if the put failed. However,
            // we only need to keep the path if this is a new instance,
            // as in that situation we need the path below to create the
            // new association object.
            //

            hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
            pResult->Release();

            if (FALSE == fNewInstance)
            {
                SysFreeString(bstr);
                bstr = NULL;
            }
        }
    }

    if (WBEM_S_NO_ERROR == hr && TRUE == fNewInstance)
    {
        BSTR bstrQuery;
        LPWSTR wsz;

        //
        // Delete the old association object, if any
        //

        hr = BuildEscapedQuotedEqualsString(
                &wsz,
                c_wszConnection,
                m_bstrConnection
                );

        if (S_OK == hr)
        {

            //
            // Query for the object associating the connection to
            // the ICMP settings block
            //

            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnectionIcmpSetting,
                    wsz
                    );

            delete [] wsz;

            if (S_OK == hr)
            {
                pwcoEnum = NULL;
                hr = m_piwsHomenet->ExecQuery(
                        m_bstrWQL,
                        bstrQuery,
                        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                        NULL,
                        &pwcoEnum
                        );

                SysFreeString(bstrQuery);
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            ULONG ulCount;
            IWbemClassObject *pwcoAssoc;

            pwcoAssoc = NULL;
            hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoAssoc,
                &ulCount
                );

            //
            // Enum should be empty at this point
            //

            ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
            pwcoEnum->Release();

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // Delete old association object
                //

                DeleteWmiInstance(m_piwsHomenet, pwcoAssoc);
                pwcoAssoc->Release();
            }
        }

        //
        // Create new association
        //

        hr = CreateIcmpSettingsAssociation(bstr);
        SysFreeString(bstr);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Notify service of configuration change
        //

        UpdateService(IPNATHLP_CONTROL_UPDATE_CONNECTION);
    }

    if (NULL != pwcoSettings)
    {
        pwcoSettings->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetConn::ShowAutoconfigBalloon(
    BOOLEAN *pfShowBalloon
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fShowBalloon = FALSE;
    BSTR bstrQuery;
    LPWSTR wszWhere;
    IEnumWbemClassObject *pwcoEnum;

    if (NULL != pfShowBalloon)
    {
        *pfShowBalloon = FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Autoconfig balloon is never shown for a RAS connection
    //

    if (!m_fLanConnection)
    {
        hr = E_UNEXPECTED;
    }

    //
    // Attempt to locate the HNet_ConnectionAutoconfig block
    // for this connection
    //

    if (S_OK == hr)
    {
        //
        // Build query string:
        //
        // SELECT * FROM HNet_ConnectionAutoconfig WHERE Connection = [this]
        //

        hr = BuildEscapedQuotedEqualsString(
                &wszWhere,
                c_wszConnection,
                m_bstrConnection
                );

        if (S_OK == hr)
        {
            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnectionAutoconfig,
                    wszWhere
                    );

            delete [] wszWhere;

        }
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;
        IWbemClassObject *pwcoInstance;

        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
            WBEM_INFINITE,
            1,
            &pwcoInstance,
            &ulCount
            );

        //
        // Enum should be empty at this point
        //

        ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
        pwcoEnum->Release();

        if (WBEM_S_NO_ERROR == hr && 1 == ulCount)
        {
            //
            // Autoconfig block already exists
            //

            fShowBalloon = FALSE;
            pwcoInstance->Release();
        }
        else
        {
            //
            // Block doesn't exist -- create it now.
            //

            fShowBalloon = TRUE;

            hr = SpawnNewInstance(
                    m_piwsHomenet,
                    c_wszHnetConnectionAutoconfig,
                    &pwcoInstance
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                VARIANT vt;
                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = m_bstrConnection;

                hr = pwcoInstance->Put(
                        c_wszConnection,
                        0,
                        &vt,
                        NULL
                        );

                //
                // We don't clear the variant as we did not
                // copy m_bstrConnection.
                //

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = m_piwsHomenet->PutInstance(
                            pwcoInstance,
                            WBEM_FLAG_CREATE_ONLY,
                            NULL,
                            NULL
                            );
                }

                pwcoInstance->Release();
            }
        }
    }

    //
    // If we think that we should show the balloon, make sure
    // that the connection isn't:
    // 1. ICS Public
    // 2. ICS Private
    // 3. Firewalled
    // 4. A bridge
    // 5. Part of a bridge
    //
    // If any of the above are true, we must have seen the connection
    // before, but just not in a way that would have caused us to
    // note it in it's autoconfig settings.
    //

    if (fShowBalloon)
    {
        IWbemClassObject *pwcoProperties;
        HNET_CONN_PROPERTIES hnProps;

        hr = GetConnectionPropertiesObject(&pwcoProperties);

        if (S_OK == hr)
        {
            hr = InternalGetProperties(pwcoProperties, &hnProps);
            pwcoProperties->Release();
        }

        if (S_OK == hr)
        {
            if (hnProps.fFirewalled
                || hnProps.fIcsPublic
                || hnProps.fIcsPrivate
                || hnProps.fBridge
                || hnProps.fPartOfBridge)
            {
                fShowBalloon = FALSE;
            }
        }
    }

    if (S_OK == hr)
    {
        *pfShowBalloon = fShowBalloon;
    }

    return hr;
}

STDMETHODIMP
CHNetConn::DeleteRasConnectionEntry()

{
    HRESULT hr = S_OK;
    HNET_CONN_PROPERTIES hnProps;
    IHNetFirewalledConnection *pHNetFwConnection;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    IWbemClassObject *pwcoProperties;
    ULONG ulPublic;
    ULONG ulPrivate;
    BSTR bstr;

    if (m_fLanConnection)
    {
        hr = E_UNEXPECTED;
    }
    
    if (SUCCEEDED(hr))
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (SUCCEEDED(hr))
    {
        hr = InternalGetProperties(pwcoProperties, &hnProps);

        if (SUCCEEDED(hr))
        {
            if (hnProps.fIcsPublic)
            {
                CComObject<CHNetCfgMgrChild> *pCfgMgr;
                hr = CComObject<CHNetCfgMgrChild>::CreateInstance(&pCfgMgr); 
                
                if (SUCCEEDED(hr))
                {
                    pCfgMgr->AddRef();    
                    hr = pCfgMgr->Initialize(m_piwsHomenet);

                    if (SUCCEEDED(hr))
                    {
                        hr = pCfgMgr->DisableIcs(&ulPublic, &ulPrivate);
                    }

                    pCfgMgr->Release();
                }
            }

            //
            // If an error occured disabling sharing we'll still
            // try to disable firewalling.
            //

            if (hnProps.fFirewalled)
            {
                hr = GetControlInterface(
                        IID_PPV_ARG(
                            IHNetFirewalledConnection,
                            &pHNetFwConnection
                            )
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pHNetFwConnection->Unfirewall();
                    pHNetFwConnection->Release();
                }
            }
        }

        pwcoProperties->Release();

        //
        // Delete the entries relating to this connection. We'll try
        // to do this even if any of the above failed. We ignore any
        // errors that occur during the deletion prcoess (i.e., from
        // Delete[Wmi]Instance).
        //

        hr = GetIcmpSettingsInstance(&pwcoInstance);

        if (SUCCEEDED(hr))
        {
            //
            // We only want to delete this block if it's
            // not the default.
            //

            hr = GetWmiPathFromObject(pwcoInstance, &bstr);

            if (SUCCEEDED(hr))
            {
                if (0 != _wcsicmp(bstr, c_wszDefaultIcmpSettingsPath))
                {
                    m_piwsHomenet->DeleteInstance(
                        bstr,
                        0,
                        NULL,
                        NULL
                        );
                }

                SysFreeString(bstr);
            }

            pwcoInstance->Release();
        }

        //
        // Now find all object that refer to our conection object.
        //

        hr = BuildReferencesQueryBstr(
                &bstr,
                m_bstrConnection,
                NULL
                );

        if (SUCCEEDED(hr))
        {
            pwcoEnum = NULL;
            hr = m_piwsHomenet->ExecQuery(
                    m_bstrWQL,
                    bstr,
                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                    NULL,
                    &pwcoEnum
                    );

            SysFreeString(bstr);

            if (SUCCEEDED(hr))
            {
                ULONG ulCount;
                
                do
                {
                    pwcoInstance = NULL;
                    hr = pwcoEnum->Next(
                            WBEM_INFINITE,
                            1,
                            &pwcoInstance,
                            &ulCount
                            );

                    if (S_OK == hr && 1 == ulCount)
                    {
                        DeleteWmiInstance(
                            m_piwsHomenet,
                            pwcoInstance
                            );

                        pwcoInstance->Release();
                    }
                }
                while (S_OK == hr && 1 == ulCount);

                pwcoEnum->Release();
                hr = S_OK;
            }
            
        }

        //
        // Finally, delete the connection object. (The connection
        // properties object will have been deleted during the
        // references set.)
        //

        hr = m_piwsHomenet->DeleteInstance(
                m_bstrConnection,
                0,
                NULL,
                NULL
                );        
    }

    return hr;
}


//
// Protected methods
//

HRESULT
CHNetConn::GetIcmpSettingsInstance(
    IWbemClassObject **ppwcoSettings
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    IEnumWbemClassObject *pwcoEnum;
    ULONG ulCount;


    _ASSERT(NULL != ppwcoSettings);

    hr = BuildAssociatorsQueryBstr(
            &bstrQuery,
            m_bstrConnection,
            c_wszHnetConnectionIcmpSetting
            );

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get the settings instance from the enum
        //

        *ppwcoSettings = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                ppwcoSettings,
                &ulCount
                );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // Normalize return value
            //

            hr = S_OK;
        }
        else
        {
            //
            // Settings block not found -- use default settings
            //

            bstrQuery = SysAllocString(c_wszDefaultIcmpSettingsPath);

            if (NULL != bstrQuery)
            {
                hr = GetWmiObjectFromPath(
                        m_piwsHomenet,
                        bstrQuery,
                        ppwcoSettings
                        );

                SysFreeString(bstrQuery);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        //
        // Enum should be empty at this point
        //

        ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
        pwcoEnum->Release();
    }

    return hr;
}

HRESULT
CHNetConn::CopyIcmpSettingsInstanceToStruct(
    IWbemClassObject *pwcoSettings,
    HNET_FW_ICMP_SETTINGS *pSettings
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL != pwcoSettings);
    _ASSERT(NULL != pSettings);

    hr = GetBooleanValue(
            pwcoSettings,
            c_wszAllowOutboundDestinationUnreachable,
            &pSettings->fAllowOutboundDestinationUnreachable
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundSourceQuench,
                &pSettings->fAllowOutboundSourceQuench
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowRedirect,
                &pSettings->fAllowRedirect
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundEchoRequest,
                &pSettings->fAllowInboundEchoRequest
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundRouterRequest,
                &pSettings->fAllowInboundRouterRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundTimeExceeded,
                &pSettings->fAllowOutboundTimeExceeded
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundParameterProblem,
                &pSettings->fAllowOutboundParameterProblem
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundTimestampRequest,
                &pSettings->fAllowInboundTimestampRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundMaskRequest,
                &pSettings->fAllowInboundMaskRequest
                );
    }

    return hr;
}

HRESULT
CHNetConn::CopyStructToIcmpSettingsInstance(
    HNET_FW_ICMP_SETTINGS *pSettings,
    IWbemClassObject *pwcoSettings
    )

{
    HRESULT hr = S_OK;

    _ASSERT(NULL != pSettings);
    _ASSERT(NULL != pwcoSettings);

    hr = SetBooleanValue(
            pwcoSettings,
            c_wszAllowOutboundDestinationUnreachable,
            pSettings->fAllowOutboundDestinationUnreachable
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundSourceQuench,
                pSettings->fAllowOutboundSourceQuench
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowRedirect,
                pSettings->fAllowRedirect
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundEchoRequest,
                pSettings->fAllowInboundEchoRequest
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundRouterRequest,
                pSettings->fAllowInboundRouterRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundTimeExceeded,
                pSettings->fAllowOutboundTimeExceeded
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowOutboundParameterProblem,
                pSettings->fAllowOutboundParameterProblem
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundTimestampRequest,
                pSettings->fAllowInboundTimestampRequest
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoSettings,
                c_wszAllowInboundMaskRequest,
                pSettings->fAllowInboundMaskRequest
                );
    }

    return hr;
}

HRESULT
CHNetConn::CreatePortMappingBindings()

{
    HRESULT hr = S_OK;
    BSTR bstr;
    IEnumWbemClassObject *pwcoEnumProtocols;
    IWbemClassObject *pwcoInstance;
    VARIANT vt;

    //
    // Get the enumeration of all protocol instances
    //

    bstr = SysAllocString(c_wszHnetPortMappingProtocol);

    if (NULL != bstr)
    {
        pwcoEnumProtocols = NULL;
        hr = m_piwsHomenet->CreateInstanceEnum(
                bstr,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnumProtocols
                );

        SysFreeString(bstr);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;

        //
        // Loop through the enumeration, checking to see if the desired binding
        // exists
        //

        do
        {
            pwcoInstance = NULL;
            hr = pwcoEnumProtocols->Next(
                    WBEM_INFINITE,
                    1,
                    &pwcoInstance,
                    &ulCount
                    );

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                hr = pwcoInstance->Get(
                        c_wszPort,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
                
                if (WBEM_S_NO_ERROR == hr)
                {
                    ASSERT(VT_I4 == V_VT(&vt));
                    
                    hr = GetWmiPathFromObject(pwcoInstance, &bstr);
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    IWbemClassObject *pwcoBinding;

                    hr = GetPortMappingBindingInstance(
                            m_piwsHomenet,
                            m_bstrWQL,
                            m_bstrConnection,
                            bstr,
                            static_cast<USHORT>(V_I4(&vt)),
                            &pwcoBinding
                            );

                    SysFreeString(bstr);

                    if (S_OK == hr)
                    {
                        pwcoBinding->Release();
                    }
                    else if (WBEM_E_NOT_FOUND == hr)
                    {
                        //
                        // This can occur if the protocol instance is
                        // deleted after we retrieved it from the enumeration
                        // but before we created the binding instance. It's
                        // OK to continue in this situation.
                        //
                        
                        hr = S_OK;
                    }
                }

                pwcoInstance->Release();
            }

        } while (SUCCEEDED(hr) && 1 == ulCount);

        pwcoEnumProtocols->Release();
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

HRESULT
CHNetConn::InternalGetProperties(
    IWbemClassObject *pwcoProperties,
    HNET_CONN_PROPERTIES *pProperties
    )

{
    BOOLEAN fCanBeBoundToBridge = FALSE;
    HRESULT hr = S_OK;

    _ASSERT(NULL != pwcoProperties);
    _ASSERT(NULL != pProperties);

    pProperties->fLanConnection = m_fLanConnection;

    if (IsServiceRunning(c_wszSharedAccess))
    {
        hr = GetBooleanValue(
                pwcoProperties,
                c_wszIsFirewalled,
                &pProperties->fFirewalled
                );
    }
    else
    {
        //
        // If the SharedAccess service is not running (or in the process
        // of starting up) we don't want to report this connection as
        // being firewalled. This is to prevent the confusion that could
        // result if the UI indicates the firewall is active, when in
        // reality it's not there providing protection.
        //

        pProperties->fFirewalled = FALSE;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPublic,
                &pProperties->fIcsPublic
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPrivate,
                &pProperties->fIcsPrivate
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        if( m_fLanConnection )
        {
            //
            // Figure out NetCfg-based properties
            //
    
            INetCfg                 *pnetcfg;
    
            hr = CoCreateInstance(
                    CLSID_CNetCfg,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(INetCfg, &pnetcfg)
                    );
    
            if (S_OK == hr)
            {
                hr = pnetcfg->Initialize( NULL );
    
                if( S_OK == hr )
                {
                    GUID                    *pguid;
                    INetCfgComponent        *pncfgcomp;
    
                    hr = GetGuidInternal(&pguid);
    
                    if(S_OK == hr)
                    {
                        // Get the NetCfg component that corresponds to us
                        hr = FindAdapterByGUID( pnetcfg, pguid, &pncfgcomp );
    
                        if(S_OK == hr)
                        {
                            LPWSTR              pszwId;
    
                            pncfgcomp->GetId( &pszwId );
    
                            if(S_OK == hr)
                            {
                                pProperties->fBridge = (BOOLEAN)(_wcsicmp(pszwId, c_wszSBridgeMPID) == 0);
                                CoTaskMemFree(pszwId);
                                
                                if( pProperties->fBridge )
                                {
                                    // This adapter is the bridge. It can't possibly also be a bridge
                                    // member.
                                    pProperties->fPartOfBridge = FALSE;
                                }
                                else
                                {
                                    //
                                    // This adapter is not the bridge. Check if it's part of a bridge.
                                    //
                                    INetCfgComponent    *pnetcfgcompBridgeProtocol;
        
                                    // Find the bridge protocol component
                                    hr = pnetcfg->FindComponent( c_wszSBridgeSID, &pnetcfgcompBridgeProtocol );
        
                                    if(S_OK == hr)
                                    {
                                        INetCfgComponentBindings    *pnetcfgProtocolBindings;
        
                                        // Get the ComponentBindings interface for the protocol component
                                        hr = pnetcfgcompBridgeProtocol->QueryInterface(
                                                IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgProtocolBindings)
                                                );
        
                                        if(S_OK == hr)
                                        {
                                            hr = pnetcfgProtocolBindings->IsBoundTo(pncfgcomp);
        
                                            if(S_OK == hr)
                                            {
                                                // The bridge protocol is bound to this adapter
                                                pProperties->fPartOfBridge = TRUE;
                                            }
                                            else if(S_FALSE == hr)
                                            {
                                                // The bridge protocol is not bound to this adapter
                                                pProperties->fPartOfBridge = FALSE;

                                                //
                                                // Also need to check if it's even possible to bind
                                                // the bridge protocol to this adapter.
                                                //

                                                hr = pnetcfgProtocolBindings->IsBindableTo(pncfgcomp);
                                                fCanBeBoundToBridge = (S_OK == hr);
        
                                                // Reset to success
                                                hr = S_OK;
                                            }
                                            // else an error occured
        
                                            pnetcfgProtocolBindings->Release();
                                        }
        
                                        pnetcfgcompBridgeProtocol->Release();
                                    }
                                    else
                                    {
                                        // This adapter can't be bridged if there's no bridge protocol
                                        // in the system
                                        pProperties->fPartOfBridge = FALSE;
        
                                        // Reset to success
                                        hr = S_OK;
                                    }
                                }
                            }
    
                            pncfgcomp->Release();
                        }
                    }
    
                    pnetcfg->Uninitialize();
                }
    
                pnetcfg->Release();
            }
        } // if m_fLanConnection
        else
        {
            // We're not a LAN connection. We can never be a bridge or a bridge member.
            pProperties->fBridge = FALSE;
            pProperties->fPartOfBridge = FALSE;
        }
    }

    if(S_OK == hr)
    {
        //
        // Calculated properties
        //

        pProperties->fCanBeFirewalled =
            !pProperties->fPartOfBridge
            && !pProperties->fBridge
            && !pProperties->fIcsPrivate;

        pProperties->fCanBeIcsPublic =
            !pProperties->fBridge
            && !pProperties->fPartOfBridge
            && !pProperties->fIcsPrivate;

        pProperties->fCanBeIcsPrivate =
            m_fLanConnection
            && !pProperties->fIcsPublic
            && !pProperties->fFirewalled
            && !pProperties->fPartOfBridge;

        pProperties->fCanBeBridged =
            m_fLanConnection
            && fCanBeBoundToBridge
            && !pProperties->fIcsPublic
            && !pProperties->fIcsPrivate
            && !pProperties->fFirewalled
            && !pProperties->fBridge;
    }

    return hr;
}

HRESULT
CHNetConn::SetupConnectionAsPrivateLan()

{
    HRESULT hr;
    GUID *pGuid;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    ULONG Error;
    DWORD dwAddress;
    DWORD dwMask;
    ULONG i;
    PMIB_IPADDRTABLE Table;


    ZeroMemory(&UnicodeString, sizeof(UnicodeString));
    ZeroMemory(&AnsiString, sizeof(AnsiString));

    hr = GetGuidInternal(&pGuid);

    if (SUCCEEDED(hr))
    {
        hr = RtlStringFromGUID(*pGuid, &UnicodeString);

        if (SUCCEEDED(hr))
        {
            hr = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Obtain the address and mask for the private network
        //

        hr = ReadDhcpScopeSettings(&dwAddress, &dwMask);
    }

    if (SUCCEEDED(hr))
    {

        //
        // Determine whether some LAN adapter other than the private LAN
        // is already using an address in the private network scope.
        // In the process, make sure that the private LAN has only one
        // IP address (otherwise, 'SetAdapterIpAddress' fails.)
        //

        Error =
            AllocateAndGetIpAddrTableFromStack(
                &Table,
                FALSE,
                GetProcessHeap(),
                0
                );

        if (ERROR_SUCCESS == Error)
        {
            ULONG Index = 0;
            ULONG Count;

            hr = MapGuidStringToAdapterIndex(UnicodeString.Buffer, &Index);

            if (SUCCEEDED(hr))
            {

                for (i = 0, Count = 0; i < Table->dwNumEntries; i++)
                {
                    if (Index == Table->table[i].dwIndex)
                    {
                        ++Count;
                    }
                    else if ((Table->table[i].dwAddr & dwMask)
                              == (dwAddress & dwMask))
                    {
                        //
                        // It appears that some other LAN adapter has an
                        // address in the proposed scope.
                        //
                        // This may happen when multiple netcards go into
                        // autonet mode or when the RAS server is handing
                        // out autonet addresses.
                        //
                        // Therefore, if we're using the autonet scope,
                        // allow this behavior; otherwise prohibit it.
                        //

                        if ((dwAddress & dwMask) != 0x0000fea9)
                        {
                            break;
                        }
                    }
                }

                if (i < Table->dwNumEntries)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_ADDRESS_EXISTS);
                }
                else if (Count > 1)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_MULTIPLE_ADDRESSES);
                }
            }

            HeapFree(GetProcessHeap(), 0, Table);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(Error);
        }
    }

    //
    // Set the predefined static IP address for the private LAN.
    //

    if (SUCCEEDED(hr))
    {
        Error =
            SetAdapterIpAddress(
                AnsiString.Buffer,
                FALSE,
                dwAddress,
                dwMask,
                0
                );

        if (ERROR_SUCCESS != Error)
        {
            if (Error == ERROR_TOO_MANY_NAMES)
            {
                Error = ERROR_SHARING_MULTIPLE_ADDRESSES;
            }
            else if (Error == ERROR_DUP_NAME)
            {
                Error = ERROR_SHARING_HOST_ADDRESS_CONFLICT;
            }
            else
            {
                //
                // Query the state of the connection.
                // If it is disconnected, convert the error code
                // to something more informative.
                //

                UNICODE_STRING DeviceString;
                NIC_STATISTICS NdisStatistics;
                LPWSTR pwsz;

                //
                // Build a buffer large enough for the device string
                //

                pwsz = new WCHAR[wcslen(c_wszDevice) + wcslen(UnicodeString.Buffer) + 1];
                if (NULL != pwsz)
                {
                    swprintf(pwsz, L"%s%s", c_wszDevice, UnicodeString.Buffer);
                    RtlInitUnicodeString(&DeviceString, pwsz);
                    NdisStatistics.Size = sizeof(NdisStatistics);
                    NdisQueryStatistics(&DeviceString, &NdisStatistics);
                    delete [] pwsz;

                    if (NdisStatistics.DeviceState != DEVICE_STATE_CONNECTED)
                    {
                        Error = ERROR_SHARING_NO_PRIVATE_LAN;
                    }
                    else if  (NdisStatistics.MediaState == MEDIA_STATE_UNKNOWN)
                    {
                        Error = ERROR_SHARING_HOST_ADDRESS_CONFLICT;
                    }
                    else if (NdisStatistics.MediaState == MEDIA_STATE_DISCONNECTED)
                    {
                        //
                        // The adapter is connected but is in a media disconnect
                        // state. When this happens the correct IP address will
                        // be there when the adapter is reconnected, so ignore
                        // the error.
                        //

                        Error = ERROR_SUCCESS;
                    }
                }
            }

            hr = HRESULT_FROM_WIN32(Error);
        }
    }

    //
    // As we zeroed out the string structure above, it's safe to call
    // the free routines, even if we never actually allocated anything.
    //

    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeAnsiString(&AnsiString);

    return hr;
}

HRESULT
CHNetConn::BackupIpConfiguration()

{
    HRESULT hr = S_OK;
    HANDLE Key;
    IWbemClassObject *pwcoInstance = NULL;
    VARIANT vt;
    PKEY_VALUE_PARTIAL_INFORMATION pInformation;

    //
    // Spawn a new HNet_BackupIpConfiguration instance
    //

    hr = SpawnNewInstance(
            m_piwsHomenet,
            c_wszBackupIpConfiguration,
            &pwcoInstance
            );

    if (SUCCEEDED(hr))
    {
        //
        // Write connection property into instance
        //

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = m_bstrConnection;

        hr = pwcoInstance->Put(
                c_wszConnection,
                0,
                &vt,
                NULL
                );

        VariantInit(&vt);
    }

    //
    // Open the registry key that stores the IP configuration
    // for this connection
    //

    if (SUCCEEDED(hr))
    {
        hr = OpenIpConfigurationRegKey(KEY_READ, &Key);
    }

    //
    // Read each part of the configuration, and write it to
    // the settings instance
    //

    if (SUCCEEDED(hr))
    {
        hr = QueryRegValueKey(Key, c_wszIPAddress, &pInformation);

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_MULTI_SZ == pInformation->Type);

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocStringLen(
                            reinterpret_cast<OLECHAR*>(pInformation->Data),
                            pInformation->DataLength / sizeof(OLECHAR)
                            );

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoInstance->Put(
                        c_wszIPAddress,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            HeapFree(GetProcessHeap(), 0, pInformation);
        }

        if (SUCCEEDED(hr))
        {
            hr = QueryRegValueKey(Key, c_wszSubnetMask, &pInformation);
        }

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_MULTI_SZ == pInformation->Type);

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocStringLen(
                            reinterpret_cast<OLECHAR*>(pInformation->Data),
                            pInformation->DataLength / sizeof(OLECHAR)
                            );

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoInstance->Put(
                        c_wszSubnetMask,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            HeapFree(GetProcessHeap(), 0, pInformation);
        }

        if (SUCCEEDED(hr))
        {
            hr = QueryRegValueKey(Key, c_wszDefaultGateway, &pInformation);
        }

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_MULTI_SZ == pInformation->Type);

            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocStringLen(
                            reinterpret_cast<OLECHAR*>(pInformation->Data),
                            pInformation->DataLength / sizeof(OLECHAR)
                            );

            if (NULL != V_BSTR(&vt))
            {
                hr = pwcoInstance->Put(
                        c_wszDefaultGateway,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            HeapFree(GetProcessHeap(), 0, pInformation);
        }


        if (SUCCEEDED(hr))
        {
            hr = QueryRegValueKey(Key, c_wszEnableDHCP, &pInformation);
        }

        if (SUCCEEDED(hr))
        {
            _ASSERT(REG_DWORD == pInformation->Type);
            _ASSERT(sizeof(DWORD) == pInformation->DataLength);

            V_VT(&vt) = VT_I4;
            V_I4(&vt) = *(reinterpret_cast<DWORD*>(pInformation->Data));

            hr = pwcoInstance->Put(
                    c_wszEnableDHCP,
                    0,
                    &vt,
                    NULL
                    );

            HeapFree(GetProcessHeap(), 0, pInformation);
        }

        NtClose(Key);
    };

    //
    // Write the settings to the store
    //

    if (SUCCEEDED(hr))
    {
        hr = m_piwsHomenet->PutInstance(
                pwcoInstance,
                WBEM_FLAG_CREATE_OR_UPDATE,
                NULL,
                NULL
                );
    }

    if (NULL != pwcoInstance)
    {
        pwcoInstance->Release();
    }

    return hr;
}

HRESULT
CHNetConn::RestoreIpConfiguration()

{
    HRESULT hr;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoSettings;
    BSTR bstr;
    LPWSTR wszAddress;
    VARIANT vt;
    LPWSTR wsz;
    UNICODE_STRING UnicodeString;
    HANDLE hKey = NULL;
    BOOLEAN fDhcpEnabled;
    ULONG ulLength;
    ULONG ulAddress;
    ULONG ulMask;

    //
    // Open the registry key
    //

    hr = OpenIpConfigurationRegKey(KEY_ALL_ACCESS, &hKey);

    //
    // Get the backup configuration block for this connection
    //
    
    if (S_OK == hr)
    {
        hr = BuildEscapedQuotedEqualsString(
                &wsz,
                c_wszConnection,
                m_bstrConnection
                );
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszBackupIpConfiguration,
                wsz
                );

        delete [] wsz;
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstr);
    }

    if (S_OK == hr)
    {
        ULONG ulCount;

        pwcoSettings = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoSettings, &ulCount);

        //
        // Even if we're not able to obtain backup settings we continue
        // to operate. By setting pwcoSettings to NULL we indidcate that
        // the default DHCP configuration should be used. (A failure for
        // ExecQuery indicates a much more serious problem, so we don't
        // try to continue if that occurs.)
        //

        if (FAILED(hr) || 1 != ulCount)
        {
            pwcoSettings = NULL;
        }

        hr = S_OK;

        ValidateFinishedWCOEnum(m_piwsHomenet, pwcoEnum);
        pwcoEnum->Release();
    }

    //
    // Write backup values to registry -- start by getting the
    // old IP address
    //

    if (S_OK == hr)
    {
        if (NULL != pwcoSettings) 
        {
            hr = pwcoSettings->Get(
                    c_wszIPAddress,
                    0,
                    &vt,
                    NULL,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                ULONG ulDhcpAddress;
                ULONG ulDhcpMask;

                _ASSERT(VT_BSTR == V_VT(&vt));

                //
                // Check to see if the stored backup address is the
                // same as our default DHCP scope -- if so, use
                // the default DHCP configuration.
                //

                hr = ReadDhcpScopeSettings(&ulDhcpAddress, &ulDhcpMask);

                if (S_OK == hr)
                {
                    ulAddress =
                        RtlUlongByteSwap(
                            IpPszToHostAddr(V_BSTR(&vt))
                            );

                    if (ulAddress == ulDhcpAddress
                        || static_cast<DWORD>(-1) == ulAddress)
                    {
                        //
                        // Use the default configuration.
                        //

                        DeleteWmiInstance(m_piwsHomenet, pwcoSettings);
                        pwcoSettings->Release();
                        pwcoSettings = NULL;
                        
                        VariantClear(&vt);
                        V_VT(&vt) = VT_BSTR;
                        V_BSTR(&vt) = SysAllocString(c_wszZeroIpAddress);
                        if (NULL == V_BSTR(&vt))
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            } 
        }
        else
        {
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(c_wszZeroIpAddress);
            if (NULL == V_BSTR(&vt))
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // REG_MULTI_SZ is double-null terminated; need to copy
            // the returned string into a larger buffer to add the
            // nulls.
            //
            // The length computation here is correct; SysStringByteLen
            // gives the number of bytes, not WCHARs. The 2 * sizeof(WCHAR)
            // is for the double NULL at the end. (SysStringByteLen also
            // doesn't include the terminating NULL.)
            //

            ulLength = SysStringByteLen(V_BSTR(&vt)) + 2 * sizeof(WCHAR);
            wszAddress =
                reinterpret_cast<LPWSTR>(
                        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength)
                        );

            if (NULL != wszAddress)
            {
                RtlCopyMemory(wszAddress, V_BSTR(&vt), ulLength - 2 * sizeof(WCHAR));

                RtlInitUnicodeString(&UnicodeString, c_wszIPAddress);
                hr = NtSetValueKey(
                        hKey,
                        &UnicodeString,
                        0,
                        REG_MULTI_SZ,
                        reinterpret_cast<PVOID>(wszAddress),
                        ulLength
                        );
                        
                HeapFree(GetProcessHeap(), 0, wszAddress);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            VariantClear(&vt);
        }

        //
        // DHCP settings
        //

        if (SUCCEEDED(hr))
        {
            if (NULL != pwcoSettings)
            {
                hr = pwcoSettings->Get(
                        c_wszEnableDHCP,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
            }
            else
            {
                V_VT(&vt) = VT_I4;
                V_I4(&vt) = 1;
                hr = WBEM_S_NO_ERROR;
            }
        }

        //
        // Subnet mask
        //

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_I4 == V_VT(&vt));

            RtlInitUnicodeString(&UnicodeString, c_wszEnableDHCP);

            hr = NtSetValueKey(
                    hKey,
                    &UnicodeString,
                    0,
                    REG_DWORD,
                    reinterpret_cast<PVOID>(&(V_I4(&vt))),
                    sizeof(V_I4(&vt))
                    );

            fDhcpEnabled = 1 == V_I4(&vt);
            VariantClear(&vt);
        }

        if (SUCCEEDED(hr))
        {
            if (NULL != pwcoSettings)
            {
                hr = pwcoSettings->Get(
                        c_wszSubnetMask,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
            }
            else
            {
                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(c_wszZeroIpAddress);
                if (NULL != V_BSTR(&vt))
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            LPWSTR wszMask;
            
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // REG_MULTI_SZ is double-null terminated; need to copy
            // the returned string into a larger buffer to add the
            // nulls.
            //
            // The length computation here is correct; SysStringByteLen
            // gives the number of bytes, not WCHARs. The 2 * sizeof(WCHAR)
            // is for the double NULL at the end. (SysStringByteLen also
            // doesn't include the terminating NULL.)
            //

            ulLength = SysStringByteLen(V_BSTR(&vt)) + 2 * sizeof(WCHAR);
            wszMask =
                reinterpret_cast<LPWSTR>(
                        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength)
                        );

            if (NULL != wszMask)
            {
                RtlCopyMemory(wszMask, V_BSTR(&vt), ulLength - 2 * sizeof(WCHAR));

                RtlInitUnicodeString(&UnicodeString, c_wszSubnetMask);
                hr = NtSetValueKey(
                        hKey,
                        &UnicodeString,
                        0,
                        REG_MULTI_SZ,
                        reinterpret_cast<PVOID>(wszMask),
                        ulLength
                        );

                if (!fDhcpEnabled)
                {
                    ulMask =
                        RtlUlongByteSwap(
                            IpPszToHostAddr(wszMask)
                            );
                }
                
                HeapFree(GetProcessHeap(), 0, wszMask);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            VariantClear(&vt);
        }

        //
        // Default gateway
        //

        if (SUCCEEDED(hr))
        {
            if (NULL != pwcoSettings)
            {
                hr = pwcoSettings->Get(
                        c_wszDefaultGateway,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );
            }
            else
            {
                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(L"");
                if (NULL != V_BSTR(&vt))
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // REG_MULTI_SZ is double-null terminated; need to copy
            // the returned string into a larger buffer to add the
            // nulls.
            //
            // The length computation here is correct; SysStringByteLen
            // gives the number of bytes, not WCHARs. The 2 * sizeof(WCHAR)
            // is for the double NULL at the end. (SysStringByteLen also
            // doesn't include the terminating NULL.)
            //

            ulLength = SysStringByteLen(V_BSTR(&vt)) + 2 * sizeof(WCHAR);
            wsz =
                reinterpret_cast<LPWSTR>(
                        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength)
                        );

            if (NULL != wsz)
            {
                RtlCopyMemory(wsz, V_BSTR(&vt), ulLength - 2 * sizeof(WCHAR));

                RtlInitUnicodeString(&UnicodeString, c_wszDefaultGateway);
                hr = NtSetValueKey(
                        hKey,
                        &UnicodeString,
                        0,
                        REG_MULTI_SZ,
                        reinterpret_cast<PVOID>(wsz),
                        ulLength
                        );

                HeapFree(GetProcessHeap(), 0, wsz);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            VariantClear(&vt);
        }

        //
        // Delete the backup instance
        //

        if (NULL != pwcoSettings)
        {
            DeleteWmiInstance(m_piwsHomenet, pwcoSettings);
            pwcoSettings->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        GUID *pGuid;
        LPWSTR wszGuid;
        ULONG ulError;

        //
        // Notify the stack that the IP settings have changed
        //

        hr = GetGuidInternal(&pGuid);
        if (S_OK == hr)
        {
            hr = StringFromCLSID(*pGuid, &wszGuid);
        }

        if (S_OK == hr)
        {
            if (fDhcpEnabled)
            {
                ulError = DhcpNotifyConfigChange(
                            NULL,
                            wszGuid,
                            FALSE,
                            0,
                            0,
                            0,
                            DhcpEnable
                            );

                if (NO_ERROR != ulError)
                {
                    hr = HRESULT_FROM_WIN32(ulError);
                }
            }
            else
            {
                UNICODE_STRING BindList;
                UNICODE_STRING LowerComponent;
                IP_PNP_RECONFIG_REQUEST Request;
                UNICODE_STRING UpperComponent;
                        
                if ((ULONG)-1 != ulMask)
                {
                    //
                    // First delete the old (static) IP address
                    //

                    DhcpNotifyConfigChange(
                        NULL,
                        wszGuid,
                        TRUE,
                        0,
                        0,
                        0,
                        IgnoreFlag
                        );

                    //
                    // Now set the new address
                    //
                    
                    ulError =
                        DhcpNotifyConfigChange(
                            NULL,
                            wszGuid,
                            TRUE,
                            0,
                            ulAddress,
                            ulMask,
                            DhcpDisable
                            );

                    if (NO_ERROR != ulError)
                    {
                        hr = HRESULT_FROM_WIN32(ulError);
                    }
                }
                else
                {
                    hr = E_FAIL;
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Instruct the stack to pickup the
                    // new default gateway
                    //
                    
                    RtlInitUnicodeString(&BindList, L"");
                    RtlInitUnicodeString(&LowerComponent, L"");
                    RtlInitUnicodeString(&UpperComponent, L"Tcpip");
                    ZeroMemory(&Request, sizeof(Request));
                    Request.version = IP_PNP_RECONFIG_VERSION;
                    Request.gatewayListUpdate = TRUE;
                    Request.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE;
                    NdisHandlePnPEvent(
                        NDIS,
                        RECONFIGURE,
                        &LowerComponent,
                        &UpperComponent,
                        &BindList,
                        &Request,
                        sizeof(Request)
                        );
                }
            }

            CoTaskMemFree(wszGuid);
        }
    }

    if (NULL != hKey)
    {
        NtClose(hKey);
    }

    return hr;
}

HRESULT
CHNetConn::OpenIpConfigurationRegKey(
    ACCESS_MASK DesiredAccess,
    HANDLE *phKey
    )

{
    HRESULT hr;
    LPWSTR KeyName;
    ULONG KeyNameLength;
    GUID *pGuid;
    LPWSTR wszGuid;

    hr = GetGuidInternal(&pGuid);

    if (SUCCEEDED(hr))
    {
        hr = StringFromCLSID(*pGuid, &wszGuid);
    }

    if (SUCCEEDED(hr))
    {
        KeyNameLength =
            wcslen(c_wszTcpipParametersKey) + 1 +
            wcslen(c_wszInterfaces) + 1 +
            wcslen(wszGuid) + 2;

        KeyName = new OLECHAR[KeyNameLength];
        if (NULL != KeyName)
        {
            swprintf(
                KeyName,
                L"%ls\\%ls\\%ls",
                c_wszTcpipParametersKey,
                c_wszInterfaces,
                wszGuid
                );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(wszGuid);
    }

    if (SUCCEEDED(hr))
    {
        hr = OpenRegKey(phKey, DesiredAccess, KeyName);
        delete [] KeyName;
    }

    return hr;
}

HRESULT
CHNetConn::GetGuidInternal(
    GUID **ppGuid
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != ppGuid);

    Lock();

    if (NULL == m_pGuid)
    {
        //
        // Our guid hasn't been retrieved yet -- do it now.
        //

        m_pGuid = reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

        if (NULL == m_pGuid)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            IWbemClassObject *pwcoConnection;

            hr = GetConnectionObject(&pwcoConnection);

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Get our guid property
                //

                hr = pwcoConnection->Get(
                        c_wszGuid,
                        0,
                        &vt,
                        NULL,
                        NULL
                        );

                pwcoConnection->Release();
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // Convert the string to a guid.
            //

            hr = CLSIDFromString(V_BSTR(&vt), m_pGuid);
            VariantClear(&vt);
        }

        if (FAILED(hr) && NULL != m_pGuid)
        {
            CoTaskMemFree(m_pGuid);
            m_pGuid = NULL;
        }
    }

    if (S_OK == hr)
    {
        *ppGuid = m_pGuid;
    }

    Unlock();

    return hr;
}

HRESULT
CHNetConn::GetConnectionObject(
    IWbemClassObject **ppwcoConnection
    )

{
    _ASSERT(NULL != ppwcoConnection);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrConnection,
                ppwcoConnection
                );
}

HRESULT
CHNetConn::GetConnectionPropertiesObject(
    IWbemClassObject **ppwcoProperties
    )

{
    _ASSERT(NULL != ppwcoProperties);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrProperties,
                ppwcoProperties
                );
}

BOOLEAN
CHNetConn::ProhibitedByPolicy(
    DWORD dwPerm
    )

{
    HRESULT hr = S_OK;
    BOOLEAN fProhibited = FALSE;

    if (NULL == m_pNetConnUiUtil)
    {
        Lock();

        if (NULL == m_pNetConnUiUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionUiUtilities,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(INetConnectionUiUtilities, &m_pNetConnUiUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        fProhibited = !m_pNetConnUiUtil->UserHasPermission(dwPerm);
    }

    return fProhibited;
}

HRESULT
CHNetConn::UpdateNetman()

{
    HRESULT hr = S_OK;

    if (NULL == m_pNetConnHNetUtil)
    {
        Lock();

        if (NULL == m_pNetConnHNetUtil)
        {
            hr = CoCreateInstance(
                    CLSID_NetConnectionHNetUtil,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(INetConnectionHNetUtil, &m_pNetConnHNetUtil)
                    );
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pNetConnHNetUtil->NotifyUpdate();
    }

    return hr;
}


HRESULT
CHNetConn::CreateIcmpSettingsAssociation(
    BSTR bstrIcmpSettingsPath
    )

{
    HRESULT hr;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;

    _ASSERT(NULL != bstrIcmpSettingsPath);

    //
    // Spawn a new instance of the association class
    //

    pwcoInstance = NULL;
    hr = SpawnNewInstance(
            m_piwsHomenet,
            c_wszHnetConnectionIcmpSetting,
            &pwcoInstance
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Set connection property
        //

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = m_bstrConnection;
        hr = pwcoInstance->Put(
                c_wszConnection,
                0,
                &vt,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Point the association to the settings block
        //

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = bstrIcmpSettingsPath;
        hr = pwcoInstance->Put(
                c_wszIcmpSettings,
                0,
                &vt,
                NULL
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Save the object to the store
        //

        hr = m_piwsHomenet->PutInstance(
                pwcoInstance,
                WBEM_FLAG_CREATE_OR_UPDATE,
                NULL,
                NULL
                );
    }

    return hr;
}

HRESULT
CHNetConn::GetRasConnectionName(
    OLECHAR **ppszwConnectionName
    )

{
    HRESULT hr;
    GUID *pGuid;
    OLECHAR *pszwPath;
    RASENUMENTRYDETAILS *rgEntryDetails;
    DWORD cBytes;
    DWORD cEntries;
    DWORD dwError;
    

    _ASSERT(NULL != ppszwConnectionName);
    _ASSERT(FALSE == m_fLanConnection);

    hr = GetGuidInternal(&pGuid);

    if (S_OK == hr)
    {
        hr = GetRasPhonebookPath(&pszwPath);
    }

    if (S_OK == hr)
    {
        //
        // Start with a buffer large enough to hold 5 entries.
        //

        cBytes = 5 * sizeof(RASENUMENTRYDETAILS);
        rgEntryDetails =
            reinterpret_cast<RASENUMENTRYDETAILS *>(
                CoTaskMemAlloc(cBytes)
                );

        if (NULL != rgEntryDetails)
        {
            //
            // Try to obtain the entry details
            //
            
            rgEntryDetails[0].dwSize = sizeof(RASENUMENTRYDETAILS);
            dwError =
                DwEnumEntryDetails(
                    pszwPath,
                    rgEntryDetails,
                    &cBytes,
                    &cEntries
                    );

            if (ERROR_BUFFER_TOO_SMALL == dwError)
            {
                //
                // Try again with a larger buffer
                //

                CoTaskMemFree(rgEntryDetails);
                rgEntryDetails =
                    reinterpret_cast<RASENUMENTRYDETAILS *>(
                        CoTaskMemAlloc(cBytes)
                        );

                if (NULL != rgEntryDetails)
                {
                    rgEntryDetails[0].dwSize = sizeof(RASENUMENTRYDETAILS);
                    dwError =
                        DwEnumEntryDetails(
                            pszwPath,
                            rgEntryDetails,
                            &cBytes,
                            &cEntries
                            );

                    if (ERROR_SUCCESS != dwError)
                    {
                        CoTaskMemFree(rgEntryDetails);
                        hr = HRESULT_FROM_WIN32(dwError);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else if (ERROR_SUCCESS != dwError)
            {
                CoTaskMemFree(rgEntryDetails);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(pszwPath);
    }

    if (S_OK == hr)
    {
        DWORD i;
        
        //
        // Locate the correct entry in the returned array
        //

        for (i = 0; i < cEntries; i++)
        {
            if (IsEqualGUID(rgEntryDetails[i].guidId, *pGuid))
            {
                //
                // We've located the correct entry. Allocate the
                // output buffer and copy over the name.
                //

                *ppszwConnectionName =
                    reinterpret_cast<OLECHAR *>(
                        CoTaskMemAlloc(
                            sizeof(OLECHAR)
                            * (wcslen(rgEntryDetails[i].szEntryName) + 1)
                            )
                        );

                if (NULL != *ppszwConnectionName)
                {
                    wcscpy(
                        *ppszwConnectionName,
                        rgEntryDetails[i].szEntryName
                        );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                break;
            }
        }

        if (i == cEntries)
        {
            //
            // Connection not found
            //

            hr = E_FAIL;
        }
        
        CoTaskMemFree(rgEntryDetails);
    }

    return hr;
}

HRESULT
CHNetConn::RefreshNetConnectionsUI(
    VOID
    )

{
    HRESULT hr = S_OK;
    INetConnection *pNetConnection;

    //
    // Make sure the UI refresh object exists
    //

    if (NULL == m_pNetConnRefresh)
    {
        Lock();

        if (NULL == m_pNetConnRefresh)
        {
            hr = CoCreateInstance(
                    CLSID_ConnectionManager,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA | CLSCTX_NO_CODE_DOWNLOAD,
                    IID_PPV_ARG(INetConnectionRefresh, &m_pNetConnRefresh)
                    );

            if (SUCCEEDED(hr))
            {
                SetProxyBlanket(m_pNetConnRefresh);
            }
        }

        Unlock();
    }

    if (SUCCEEDED(hr))
    {
        hr = GetINetConnection(&pNetConnection);

        if (SUCCEEDED(hr))
        {
            hr = m_pNetConnRefresh->ConnectionModified(pNetConnection);
            pNetConnection->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnicsprv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P R V . C P P
//
//  Contents:   CHNIcsPrivateConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetIcsPrivateConnection methods
//

STDMETHODIMP
CHNIcsPrivateConn::RemoveFromIcs()

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {

        //
        // Change our IsIcsPrivate property to false
        //
        hr = SetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPrivate,
                FALSE
                );
                
        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //
            
            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        HRESULT hr2;
        
        //
        // Stop or send an update to the homenet service. We don't
        // propagate an error here, as the store correctly reflects
        // the unfirewalled state.
        //

        hr2 = UpdateOrStopService(
                m_piwsHomenet,
                m_bstrWQL,
                IPNATHLP_CONTROL_UPDATE_CONNECTION
                );
                
        RefreshNetConnectionsUI();
        _ASSERT(SUCCEEDED(hr2));
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Reconfig interface from backup settings
        //
        
        RestoreIpConfiguration();
    }



    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnfwconn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N F W C O N N . C P P
//
//  Contents:   CHNFWConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetFirewalledConnection methods
//

STDMETHODIMP
CHNFWConn::Unfirewall()

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Change our IsFirewalled property to false
        //
        

        hr = SetBooleanValue(
                pwcoProperties,
                c_wszIsFirewalled,
                FALSE
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //
            
            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        HRESULT hr2;
        
        //
        // Stop or send an update to the homenet service. We don't
        // propagate an error here, as the store correctly reflects
        // the unfirewalled state. Success is asserted on debug builds.
        //

        hr2 = UpdateOrStopService(
                m_piwsHomenet,
                m_bstrWQL,
                IPNATHLP_CONTROL_UPDATE_CONNECTION
                );
                
        RefreshNetConnectionsUI();
        _ASSERT(SUCCEEDED(hr2));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnicspub.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P U B . C P P
//
//  Contents:   CHNIcsPublicConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetIcsPublicConnection methods
//

STDMETHODIMP
CHNIcsPublicConn::Unshare()

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProperties;

    if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        hr = GetConnectionPropertiesObject(&pwcoProperties);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Change our IsIcsPublic property to false
        //
        
        hr = SetBooleanValue(
                pwcoProperties,
                c_wszIsIcsPublic,
                FALSE
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProperties,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Inform netman that something changed. Error doesn't matter.
            //
            
            UpdateNetman();
        }

        pwcoProperties->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        HRESULT hr2;
        
        //
        // Stop or send an update to the homenet service. We don't
        // propagate an error here, as the store correctly reflects
        // the unfirewalled state. Success is asserted on debug builds.
        //

        hr2 = UpdateOrStopService(
                m_piwsHomenet,
                m_bstrWQL,
                IPNATHLP_CONTROL_UPDATE_CONNECTION
                );
                
        RefreshNetConnectionsUI();
        _ASSERT(SUCCEEDED(hr2));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnprtmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . C P P 
//
//  Contents:   CHNetPortMappingProtocol implementation
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// Atl methods
//

HRESULT
CHNetPortMappingProtocol::FinalConstruct()

{
    HRESULT hr = S_OK;

    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT
CHNetPortMappingProtocol::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrProtocol) SysFreeString(m_bstrProtocol);
    if (m_bstrWQL) SysFreeString(m_bstrWQL);
    
    return S_OK;
}

//
// Object initialization
//

HRESULT
CHNetPortMappingProtocol::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    
    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrProtocol);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoInstance);

    //
    // Read and cache our builtin value
    //

    hr = GetBooleanValue(
            pwcoInstance,
            c_wszBuiltIn,
            &m_fBuiltIn
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = GetWmiPathFromObject(pwcoInstance, &m_bstrProtocol);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        m_piwsHomenet = piwsNamespace;
        m_piwsHomenet->AddRef();
    }

    return hr;
}

//
// IHNetPortMappingProtocol methods
//


STDMETHODIMP
CHNetPortMappingProtocol::GetName(
    OLECHAR **ppszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == ppszwName)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszwName = NULL;
        
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Read the name property from our instance
        //

        hr = pwcoProtocol->Get(
                c_wszName,
                NULL,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        if (m_fBuiltIn)
        {
            UINT uiId;
            
            //
            // Attempt to convert the retrieved name to a resource
            // ID. (For localization purposes the names for builtin
            // protocols are stored as resources instead of directly
            // w/in the store.)
            //

            uiId = static_cast<UINT>(_wtoi(V_BSTR(&vt)));

            if (0 != uiId)
            {
                WCHAR wszBuffer[256];
                int iLength;

                iLength =
                    LoadString(
                        _Module.GetResourceInstance(),
                        uiId,
                        wszBuffer,
                        sizeof(wszBuffer) / sizeof(WCHAR)
                        );

                if (0 != iLength)
                {
                    //
                    // We were able to map the name to a resource. Allocate
                    // the output buffer and copy over the resource string.
                    //

                    *ppszwName =
                        reinterpret_cast<OLECHAR*>(
                            CoTaskMemAlloc((iLength + 1) * sizeof(OLECHAR))
                            );

                    if (NULL != *ppszwName)
                    {
                        wcscpy(*ppszwName, wszBuffer);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }

        if (WBEM_S_NO_ERROR == hr && NULL == *ppszwName)
        {
            //
            // This isn't a builtin protocol, or we weren't able to map
            // the stored "name" to a resource. Allocate the output
            // buffer and copy over the retrieved BSTR.
            //

            *ppszwName = reinterpret_cast<OLECHAR*>(
                            CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                           * sizeof(OLECHAR))
                            );

            if (NULL != *ppszwName)
            {
                wcscpy(*ppszwName, V_BSTR(&vt));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        VariantClear(&vt);
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingProtocol::SetName(
    OLECHAR *pszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        return E_ACCESSDENIED;
    }
    else if (NULL == pszwName)
    {
        return E_INVALIDARG;
    }

    // bug 555896:  should limit the length of untrusted input string
    // to some reasonable size.  Am using INTERNET_MAX_HOST_NAME_LENGTH
    // (somewhat arbitrarily), which is 256.

    WCHAR szwName[INTERNET_MAX_HOST_NAME_LENGTH];
    StringCchCopyW (szwName, INTERNET_MAX_HOST_NAME_LENGTH, pszwName);

    hr = GetProtocolObject(&pwcoProtocol);

    if (S_OK == hr)
    {
        //
        // Wrap the passed-in string in a BSTR and a variant
        //

        VariantInit(&vt);
        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = SysAllocString(szwName);
        if (NULL == V_BSTR(&vt))
        {
            hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr)
        {
            //
            // Set the property on the instance
            //

            hr = pwcoProtocol->Put(
                    c_wszName,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetIPProtocol(
    UCHAR *pucProtocol
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pucProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszIPProtocol,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_UI1 == V_VT(&vt));

        *pucProtocol = V_UI1(&vt);
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::SetIPProtocol(
    UCHAR ucProtocol
    )

{
    BOOLEAN fProtocolChanged = TRUE;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == ucProtocol)
    {
        hr = E_INVALIDARG;
    }

    if (S_OK == hr)
    {
        UCHAR ucOldProtocol;

        hr = GetIPProtocol(&ucOldProtocol);
        if (S_OK == hr && ucProtocol == ucOldProtocol)
        {
            fProtocolChanged = FALSE;
        }
    }


    if (S_OK == hr && fProtocolChanged)
    {
        USHORT usPort;
        
        //
        // Make sure that this won't result in a duplicate
        //

        hr = GetPort(&usPort);

        if (S_OK == hr)
        {
            if (PortMappingProtocolExists(
                    m_piwsHomenet,
                    m_bstrWQL,
                    usPort,
                    ucProtocol
                    ))
            {
                //
                // This change would result in a duplicate
                //

                hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            }                    
        }

        if (S_OK == hr)
        {
            hr = GetProtocolObject(&pwcoProtocol);
        }

        if (S_OK == hr)
        {
            VariantInit(&vt);
            V_VT(&vt) = VT_UI1;
            V_UI1(&vt) = ucProtocol;

            hr = pwcoProtocol->Put(
                    c_wszIPProtocol,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoProtocol,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );         
            }

            pwcoProtocol->Release();
        }

        if (S_OK == hr)
        {
            //
            // Update SharedAccess of the change
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetPort(
    USHORT *pusPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pusPort)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszPort,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // WMI uses V_I4 for it's uint16 type
        //
        
        _ASSERT(VT_I4 == V_VT(&vt));

        *pusPort = static_cast<USHORT>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::SetPort(
    USHORT usPort
    )

{
    BOOLEAN fPortChanged = TRUE;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == usPort)
    {
        hr = E_INVALIDARG;
    }

    if (S_OK == hr)
    {
        USHORT usOldPort;
        
        //
        // Check if the new value is the same as the old
        //

        hr = GetPort(&usOldPort);
        if (S_OK == hr && usPort == usOldPort)
        {
            fPortChanged = FALSE;
        }
    }

    if (S_OK == hr && fPortChanged)
    {
        UCHAR ucIPProtocol;
        
        //
        // Make sure that this won't result in a duplicate
        //

        hr = GetIPProtocol(&ucIPProtocol);

        if (S_OK == hr)
        {
            if (PortMappingProtocolExists(
                    m_piwsHomenet,
                    m_bstrWQL,
                    usPort,
                    ucIPProtocol
                    ))
            {
                //
                // This change would result in a duplicate
                //

                hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            }                    
        }

        if (S_OK == hr)
        {
            hr = GetProtocolObject(&pwcoProtocol);
        }
        
        if (S_OK == hr)
        {
            //
            // WMI uses V_I4 for it's uint16 type
            //
            
            VariantInit(&vt);
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = usPort;

            hr = pwcoProtocol->Put(
                    c_wszPort,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoProtocol,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoProtocol->Release();
        }

        if (S_OK == hr)
        {
            //
            // Update SharedAccess of the change
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetBuiltIn(
    BOOLEAN *pfBuiltIn
    )

{
    HRESULT hr = S_OK;

    if (NULL != pfBuiltIn)
    {
        *pfBuiltIn = m_fBuiltIn;
    }
    else
    {
        hr = E_POINTER;
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingProtocol::Delete()

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    BSTR bstrQuery = NULL;
    ULONG ulCount;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't delete builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else
    {
        LPWSTR pwsz;
        
        //
        // Query for all HNet_ConnectionPortMapping instances
        // that refer to this protocol -- i.e.,
        //
        // SELECT * FROM HNet_ConnectionPortMapping2 WHERE PROTOCOL = m_bstrProtocol
        //
        // We can't use a references query here since once we delete the
        // protocol object that query won't return any results...
        //

        hr = BuildEscapedQuotedEqualsString(
                &pwsz,
                c_wszProtocol,
                m_bstrProtocol
                );

        if (S_OK == hr)
        {
            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnectionPortMapping,
                    pwsz
                    );

            delete [] pwsz;
        }
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        m_piwsHomenet->ExecQuery(
            m_bstrWQL,
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &pwcoEnum
            );

        //
        // The query BSTR will be used again below
        //
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Loop through the enumeration, making sure that each entry
        // is disabled
        //

        do
        {
            pwcoInstance = NULL;
            hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulCount
                );

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                HRESULT hr2;
                CComObject<CHNetPortMappingBinding> *pBinding;
                
                //
                // Convert this to an actual CHNetPortMappingBinding so
                // that we can disable it and generate the change
                // notification for SharedAccess.
                //

                hr2 = CComObject<CHNetPortMappingBinding>::CreateInstance(&pBinding);
                if (SUCCEEDED(hr2))
                {
                    pBinding->AddRef();

                    hr2 = pBinding->Initialize(m_piwsHomenet, pwcoInstance);
                    if (SUCCEEDED(hr))
                    {
                        hr2 = pBinding->SetEnabled(FALSE);
                    }

                    pBinding->Release();
                }
                
                pwcoInstance->Release();
            }
        }
        while (SUCCEEDED(hr) && 1 == ulCount);

        pwcoEnum->Release();
        hr = WBEM_S_NO_ERROR;
    }


    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Delete the protocol instance
        //
        
        hr = m_piwsHomenet->DeleteInstance(
                m_bstrProtocol,
                0,
                NULL,
                NULL
                );

    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Now that the protocol instance is gone enumerate and
        // delete the bindings that refer to this instance. This
        // needs to happen after the protocol instance is gone to
        // prevent the instance from being recreated after we
        // delete it here.
        //

        pwcoEnum = NULL;
        m_piwsHomenet->ExecQuery(
            m_bstrWQL,
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &pwcoEnum
            );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        do
        {
            pwcoInstance = NULL;
            hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulCount
                );

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                DeleteWmiInstance(m_piwsHomenet, pwcoInstance);
                pwcoInstance->Release();
            }
        }
        while (SUCCEEDED(hr) && 1 == ulCount);

        pwcoEnum->Release();
        hr = WBEM_S_NO_ERROR;
    }

    if ( WBEM_S_NO_ERROR == hr )
    {
         SendPortMappingListChangeNotification();
    }

    //
    // bstrQuery is initialized to NULL at start, and SysFreeString
    // can deal w/ NULL input, so it's safe to call this even on
    // an error path.
    //

    SysFreeString(bstrQuery);

    return hr;
}

STDMETHODIMP
CHNetPortMappingProtocol::GetGuid(
    GUID **ppGuid
    )

{
    HRESULT hr;
    IWbemClassObject *pwcoInstance;
    VARIANT vt;

    if (NULL != ppGuid)
    {
        *ppGuid = reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

        if (NULL != *ppGuid)
        {
            hr = GetProtocolObject(&pwcoInstance);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoInstance->Get(
                c_wszId,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            ASSERT(VT_BSTR == V_VT(&vt));

            hr = CLSIDFromString(V_BSTR(&vt), *ppGuid);
            VariantClear(&vt);
        }

        pwcoInstance->Release();                
    }

    if (FAILED(hr) && NULL != ppGuid && NULL != *ppGuid)
    {
        CoTaskMemFree(*ppGuid);
        *ppGuid = NULL;
    }

    return hr;
    
}

//
// IHNetPrivate methods
//

STDMETHODIMP
CHNetPortMappingProtocol::GetObjectPath(
    BSTR *pbstrPath
    )

{
    HRESULT hr = S_OK;

    if (NULL != pbstrPath)
    {
        _ASSERT(m_bstrProtocol != NULL);

        *pbstrPath = SysAllocString(m_bstrProtocol);
        if (NULL == *pbstrPath)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

//
// Private methods
//

HRESULT
CHNetPortMappingProtocol::GetProtocolObject(
    IWbemClassObject **ppwcoInstance
    )

{
    _ASSERT(NULL != ppwcoInstance);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrProtocol,
                ppwcoInstance
                );
}

HRESULT
CHNetPortMappingProtocol::SendUpdateNotification()

{
    HRESULT hr = S_OK;
    IEnumHNetPortMappingBindings *pEnum;
    GUID *pProtocolGuid = NULL;
    ISharedAccessUpdate *pUpdate;

    if (IsServiceRunning(c_wszSharedAccess))
    {
        hr = GetGuid(&pProtocolGuid);
        
        //
        // Get the enumeration of enabled port mapping
        // bindings for this protocol
        //

        if (SUCCEEDED(hr))
        {
            hr = GetEnabledBindingEnumeration(&pEnum);
        }

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(
                    CLSID_SAUpdate,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(ISharedAccessUpdate, &pUpdate)
                    );

            if (SUCCEEDED(hr))
            {
                IHNetPortMappingBinding *pBinding;
                IHNetConnection *pConnection;
                GUID *pConnectionGuid;
                ULONG ulCount;
                
                do
                {
                    hr = pEnum->Next(1, &pBinding, &ulCount);
                    if (SUCCEEDED(hr) && 1 == ulCount)
                    {
                        hr = pBinding->GetConnection(&pConnection);
                        pBinding->Release();

                        if (SUCCEEDED(hr))
                        {
                            hr = pConnection->GetGuid(&pConnectionGuid);
                            pConnection->Release();
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = pUpdate->ConnectionPortMappingChanged(
                                    pConnectionGuid,
                                    pProtocolGuid,
                                    TRUE
                                    );
                            CoTaskMemFree(pConnectionGuid);
                        }
                    }
                }
                while (SUCCEEDED(hr) && 1 == ulCount);

                pUpdate->Release();
            }

            pEnum->Release();
        }
    }

    if (NULL != pProtocolGuid)
    {
        CoTaskMemFree(pProtocolGuid);
    }

    return hr;
}

HRESULT
CHNetPortMappingProtocol::GetEnabledBindingEnumeration(
    IEnumHNetPortMappingBindings **ppEnum
    )

{
    BSTR bstr;
    HRESULT hr = S_OK;
    OLECHAR *pwsz;
    OLECHAR *pwszWhere;
    
    _ASSERT(NULL != ppEnum);

    //
    // Generate the query string
    //

    hr = BuildEscapedQuotedEqualsString(
            &pwsz,
            c_wszProtocol,
            m_bstrProtocol
            );

    if (S_OK == hr)
    {
        hr = BuildAndString(
                &pwszWhere,
                pwsz,
                L"Enabled != FALSE"
                );
        
        delete [] pwsz;
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                pwszWhere
                );

        delete [] pwszWhere;
    }

    //
    // Execute the query and build the enumerator
    //

    if (S_OK == hr)
    {
        IEnumWbemClassObject *pwcoEnum = NULL;

        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );
        
        SysFreeString(bstr);

        if (WBEM_S_NO_ERROR == hr)
        {
            CComObject<CEnumHNetPortMappingBindings> *pEnum;
            hr = CComObject<CEnumHNetPortMappingBindings>::CreateInstance(&pEnum);

            if (S_OK == hr)
            {
                pEnum->AddRef();
                hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

                if (S_OK == hr)
                {
                    hr = pEnum->QueryInterface(
                            IID_PPV_ARG(IEnumHNetPortMappingBindings, ppEnum)
                            );
                }

                pEnum->Release();
            }

            pwcoEnum->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wbemidl.h>
#include <rasuip.h>
#include <raserror.h>
#include <netcon.h>
#include <netconp.h>
#include <wininet.h>
#include <routprot.h>
#include <rasapip.h>

#define _PNP_POWER_
#include <ndispnp.h>
#include <ntddip.h>
#include <ipinfo.h>
#include <iphlpapi.h>

extern "C" {
#include <iphlpstk.h>
#include <dhcpcapi.h>
}

#include <ipnathlp.h>
#include <netcfgx.h>
#include <netcfgn.h>
#include <devguid.h>
#include <saupdate.h>

#include "hncbase.h"
#include "hncdbg.h"
#include "hnetcfg.h"
#include "hncstrs.h"
#include "hncutil.h"
#include "hncres.h"
#include "hncenum.h"
#include "hncaenum.h"
#include "hnappprt.h"
#include "hnprtmap.h"
#include "hnprtbnd.h"
#include "hnetconn.h"
#include "hnbridge.h"
#include "hnbrgcon.h"
#include "hnicspub.h"
#include "hnicsprv.h"
#include "hnfwconn.h"
#include "hncfgmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnprtbnd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . H
//
//  Contents:   CHNetPortMappingBinding implementation
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// Atl methods
//

HRESULT
CHNetPortMappingBinding::FinalConstruct()

{
    HRESULT hr = S_OK;
    
    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT
CHNetPortMappingBinding::FinalRelease()

{
    if (m_bstrWQL) SysFreeString(m_bstrWQL);
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrBinding) SysFreeString(m_bstrBinding);
    
    return S_OK;
}

//
// Object initialization
//

HRESULT
CHNetPortMappingBinding::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    
    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrBinding);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoInstance);

    m_piwsHomenet = piwsNamespace;
    m_piwsHomenet->AddRef();

    hr = GetWmiPathFromObject(pwcoInstance, &m_bstrBinding);

    return hr;
}

//
// IHNetPortMappingBinding methods
//

STDMETHODIMP
CHNetPortMappingBinding::GetConnection(
    IHNetConnection **ppConnection
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;
    IWbemClassObject *pwcoBinding;

    if (NULL == ppConnection)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppConnection = NULL;
        
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        //
        // Read our protocol reference
        //

        hr = pwcoBinding->Get(
                c_wszConnection,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Get the IWbemClassObject
        //

        hr = GetWmiObjectFromPath(
                m_piwsHomenet,
                V_BSTR(&vt),
                &pwcoInstance
                );

        VariantClear(&vt);
    }

    if (S_OK == hr)
    {
        //
        // Create the object for the instance
        //

        CComObject<CHNetConn> *pConnection;

        hr = CComObject<CHNetConn>::CreateInstance(&pConnection);

        if (SUCCEEDED(hr))
        {
            pConnection->AddRef();
            
            hr = pConnection->InitializeFromConnection(m_piwsHomenet, pwcoInstance);

            if (SUCCEEDED(hr))
            {
                hr = pConnection->QueryInterface(
                        IID_PPV_ARG(IHNetConnection, ppConnection)
                        );
            }

            pConnection->Release();
        }

        pwcoInstance->Release();
    }

    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::GetProtocol(
    IHNetPortMappingProtocol **ppProtocol
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;
    IWbemClassObject *pwcoBinding;

    if (NULL == ppProtocol)
    {
        hr = E_POINTER;
    }
    else
    {

        *ppProtocol = NULL;
        
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        //
        // Read our protocol reference
        //

        hr = pwcoBinding->Get(
                c_wszProtocol,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_BSTR == V_VT(&vt));

            //
            // Get the IWbemClassObject for the protocol.
            //

            hr = GetWmiObjectFromPath(
                    m_piwsHomenet,
                    V_BSTR(&vt),
                    &pwcoInstance
                    );

            VariantClear(&vt);
            
            if (S_OK == hr)
            {
                //
                // Create the object for the instance
                //

                CComObject<CHNetPortMappingProtocol> *pProt;

                hr = CComObject<CHNetPortMappingProtocol>::CreateInstance(&pProt);

                if (SUCCEEDED(hr))
                {
                    pProt->AddRef();
                    
                    hr = pProt->Initialize(m_piwsHomenet, pwcoInstance);

                    if (SUCCEEDED(hr))
                    {
                        hr = pProt->QueryInterface(
                                IID_PPV_ARG(IHNetPortMappingProtocol, ppProtocol)
                                );
                    }

                    pProt->Release();
                }

                pwcoInstance->Release();
            }
            else if (WBEM_E_NOT_FOUND == hr)
            {
                //
                // The protocol object we refer to doesn't exist --
                // the store is in an invalid state. Delete our
                // binding instance and return the error to the
                // caller.
                //

                DeleteWmiInstance(m_piwsHomenet, pwcoBinding);
            }
        }

        pwcoBinding->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetEnabled(
    BOOLEAN *pfEnabled
    )
    
{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;

    if (NULL == pfEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        hr = GetBooleanValue(
                pwcoBinding,
                c_wszEnabled,
                pfEnabled
                );

        pwcoBinding->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::SetEnabled(
    BOOLEAN fEnable
    )
    
{
    BOOLEAN fOldEnabled;
    HRESULT hr;
    IWbemClassObject *pwcoBinding;

    hr = GetEnabled(&fOldEnabled);

    if (S_OK == hr && fOldEnabled != fEnable)
    {
        hr = GetBindingObject(&pwcoBinding);

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = SetBooleanValue(
                    pwcoBinding,
                    c_wszEnabled,
                    fEnable
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetCurrentMethod(
    BOOLEAN *pfUseName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;

    if (NULL == pfUseName)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        hr = GetBooleanValue(
                pwcoBinding,
                c_wszNameActive,
                pfUseName
                );

        pwcoBinding->Release();
    }

    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::GetTargetComputerName(
    OLECHAR **ppszwName
    )
    
{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    BOOLEAN fNameActive;
    VARIANT vt;

    if (NULL == ppszwName)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszwName = NULL;
        
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {
        //
        // Check to see if the name is valid
        //

        hr = GetCurrentMethod(&fNameActive);

        if (S_OK == hr && FALSE == fNameActive)
        {
            hr = E_UNEXPECTED;
        }

        if (S_OK == hr)
        {
            *ppszwName = NULL;

            //
            // Read the name property from our instance
            //

            hr = pwcoBinding->Get(
                    c_wszTargetName,
                    NULL,
                    &vt,
                    NULL,
                    NULL
                    ); 
        }

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Allocate memory for the return string
        //

        *ppszwName = reinterpret_cast<OLECHAR*>(
                        CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                       * sizeof(OLECHAR))
                        );

        if (NULL != *ppszwName)
        {
            wcscpy(*ppszwName, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        VariantClear(&vt);
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::SetTargetComputerName(
    OLECHAR *pszwName
    )
    
{
    BOOLEAN fNameChanged = TRUE;
    BOOLEAN fNameWasActive;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    VARIANT vt;

    if (NULL == pszwName)
    {
        return E_INVALIDARG;
    }

    // bug 555896:  should limit the length of untrusted input string
    // to DNS name length.

    WCHAR szwName[INTERNET_MAX_HOST_NAME_LENGTH];
    StringCchCopyW (szwName, INTERNET_MAX_HOST_NAME_LENGTH, pszwName);

    //
    // Check to see if we actually need to do any work. This
    // will be the case if:
    // 1) Our name wasn't active to start with, or
    // 2) The new name is different than the old.
    //
    
    hr = GetCurrentMethod(&fNameWasActive);

    if (S_OK == hr)
    {
        if (fNameWasActive)
        {
            OLECHAR *pszwOldName;

            hr = GetTargetComputerName(&pszwOldName);

            if (S_OK == hr)
            {
                fNameChanged = 0 != _wcsicmp(pszwOldName, szwName);
                CoTaskMemFree(pszwOldName);
            }
        }
    }

    if (S_OK == hr && fNameChanged)
    {
        hr = GetBindingObject(&pwcoBinding);

        if (S_OK == hr)
        {
            //
            // Wrap the passed-in string in a BSTR and a variant
            //

            VariantInit(&vt);
            V_VT(&vt) = VT_BSTR;
            V_BSTR(&vt) = SysAllocString(szwName);
            if (NULL == V_BSTR(&vt))
            {
                hr = E_OUTOFMEMORY;
            }

            if (S_OK == hr)
            {
                //
                // Set the property on the instance
                //

                hr = pwcoBinding->Put(
                        c_wszTargetName,
                        0,
                        &vt,
                        NULL
                        );

                VariantClear(&vt);
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Set that our name is now active
                //

                hr = SetBooleanValue(
                        pwcoBinding,
                        c_wszNameActive,
                        TRUE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                ULONG ulAddress;
                
                //
                // Generate an address to use as our target. We must always
                // regenerate the address when our name changes, as there
                // might be another entry with our new name that already has
                // a reserved address
                //

                hr = GenerateTargetAddress(szwName, &ulAddress);

                if (SUCCEEDED(hr))
                {
                    V_VT(&vt) = VT_I4;
                    V_I4(&vt) = ulAddress;

                    hr = pwcoBinding->Put(
                            c_wszTargetIPAddress,
                            0,
                            &vt,
                            NULL
                            );
                }
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetTargetComputerAddress(
    ULONG *pulAddress
    )
    
{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    VARIANT vt;

    if (NULL == pulAddress)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    //
    // We don't check to see what the current method is, as if the
    // name is valid, we would have generated an address to use
    // as the target
    //
    
    if (S_OK == hr)
    {   
        hr = pwcoBinding->Get(
                c_wszTargetIPAddress,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_I4 == V_VT(&vt));

        *pulAddress = static_cast<ULONG>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;

}

STDMETHODIMP
CHNetPortMappingBinding::SetTargetComputerAddress(
    ULONG ulAddress
    )
    
{
    BOOLEAN fNameWasActive;
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    ULONG ulOldAddress;
    VARIANT vt;

    if (0 == ulAddress)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetTargetComputerAddress(&ulOldAddress);

        if (S_OK == hr)
        {
            hr = GetCurrentMethod(&fNameWasActive);
        }
    }

    //
    // If the new address is the same as the old address, and
    // we were previously using the address as the target (as
    // opposed to the name) we can skip the rest of the work.
    //

    if (S_OK == hr
        && (ulAddress != ulOldAddress || fNameWasActive))
    {
        hr = GetBindingObject(&pwcoBinding);
        
        if (S_OK == hr)
        {
            VariantInit(&vt);
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = ulAddress;

            hr = pwcoBinding->Put(
                    c_wszTargetIPAddress,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Set that our name is no longer active
                //

                hr = SetBooleanValue(
                        pwcoBinding,
                        c_wszNameActive,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }

    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::GetTargetPort(
    USHORT *pusPort
    )

{
    HRESULT hr;
    IWbemClassObject *pwcoBinding;
    VARIANT vt;

    if (NULL == pusPort)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetBindingObject(&pwcoBinding);
    }

    if (S_OK == hr)
    {   
        hr = pwcoBinding->Get(
                c_wszTargetPort,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoBinding->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_I4 == V_VT(&vt));

        *pusPort = static_cast<USHORT>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetPortMappingBinding::SetTargetPort(
    USHORT usPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoBinding;
    USHORT usOldPort;
    VARIANT vt;

    if (0 == usPort)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetTargetPort(&usOldPort);
    }

    if (S_OK == hr && usPort != usOldPort)
    {
        hr = GetBindingObject(&pwcoBinding);
        
        if (S_OK == hr)
        {
            VariantInit(&vt);
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = usPort;

            hr = pwcoBinding->Put(
                    c_wszTargetPort,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //

                hr = m_piwsHomenet->PutInstance(
                        pwcoBinding,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }

            pwcoBinding->Release();
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            SendUpdateNotification();
        }
    }

    return hr;
}

//
// Private methods
//

HRESULT
CHNetPortMappingBinding::GenerateTargetAddress(
    LPCWSTR pszwTargetName,
    ULONG *pulAddress
    )

{
    HRESULT hr;
    ULONG ulAddress = 0;
    BSTR bstrQuery;
    LPWSTR wszNameClause;
    LPWSTR wszWhereClause;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    ULONG ulCount;
    VARIANT vt;

    _ASSERT(NULL != pszwTargetName);
    _ASSERT(NULL != pulAddress);

    *pulAddress = 0;

    //
    // Check to see if there any other bindings w/ the same
    // name that have a valid address
    //
    // SELECT * FROM HNet_ConnectionPortMapping where
    //   TargetName = (our name) AND
    //   NameActive != FALSE AND
    //   TargetIPAddress != 0
    //

     hr = BuildQuotedEqualsString(
            &wszNameClause,
            c_wszTargetName,
            pszwTargetName
            );

    if (S_OK == hr)
    {
        hr = BuildAndString(
                &wszWhereClause,
                wszNameClause,
                L"NameActive != FALSE AND TargetIPAddress != 0"
                );

        delete [] wszNameClause;
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wszWhereClause
                );

        delete [] wszWhereClause;
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        pwcoInstance = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoInstance, &ulCount);

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // We got one. Return the address from this instance
            //

            hr = pwcoInstance->Get(
                    c_wszTargetIPAddress,
                    0,
                    &vt,
                    NULL,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                _ASSERT(VT_I4 == V_VT(&vt));

                ulAddress = static_cast<ULONG>(V_I4(&vt));
            }

            pwcoInstance->Release();
        }
        else
        {
            hr = S_OK;
        }

        pwcoEnum->Release();
    }

    if (SUCCEEDED(hr) && 0 == ulAddress)
    {
        DWORD dwScopeAddress;
        DWORD dwScopeMask;
        ULONG ulScopeLength;
        ULONG ulIndex;
        WCHAR wszBuffer[128];
        
        //
        // No other binding using the same name was found. Generate
        // a new target address now
        //

        ReadDhcpScopeSettings(&dwScopeAddress, &dwScopeMask);
        ulScopeLength = NTOHL(~dwScopeMask);

        for (ulIndex = 1; ulIndex < ulScopeLength - 1; ulIndex++)
        {
            ulAddress = (dwScopeAddress & dwScopeMask) | NTOHL(ulIndex);
            if (ulAddress == dwScopeAddress) { continue; }

            //
            // Check to see if this address is already in use
            //

            _snwprintf(
                wszBuffer,
                ARRAYSIZE(wszBuffer),
                L"SELECT * FROM HNet_ConnectionPortMapping2 WHERE TargetIPAddress = %u",
                ulAddress
                );

            bstrQuery = SysAllocString(wszBuffer);

            if (NULL != bstrQuery)
            {
                pwcoEnum = NULL;
                hr = m_piwsHomenet->ExecQuery(
                        m_bstrWQL,
                        bstrQuery,
                        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                        NULL,
                        &pwcoEnum
                        );

                SysFreeString(bstrQuery);

                if (WBEM_S_NO_ERROR == hr)
                {
                    
                    pwcoInstance = NULL;
                    hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoInstance, &ulCount);

                    if (SUCCEEDED(hr))
                    {
                        if (0 == ulCount)
                        {
                            //
                            // This address isn't in use.
                            //

                            pwcoEnum->Release();
                            hr = S_OK;
                            break;
                        }
                        else
                        {
                            //
                            // Address already in use
                            //

                            pwcoInstance->Release();
                        }

                        pwcoEnum->Release();
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                break;
            }
        }
    }

    if (SUCCEEDED(hr) && 0 != ulAddress)
    {
        *pulAddress = ulAddress;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CHNetPortMappingBinding::GetBindingObject(
    IWbemClassObject **ppwcoInstance
    )

{
    _ASSERT(NULL != ppwcoInstance);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrBinding,
                ppwcoInstance
                );
}

HRESULT
CHNetPortMappingBinding::SendUpdateNotification()

{
    HRESULT hr = S_OK;
    IHNetConnection *pConnection;
    GUID *pConnectionGuid = NULL;
    IHNetPortMappingProtocol *pProtocol;
    GUID *pProtocolGuid = NULL;
    ISharedAccessUpdate *pUpdate;

    if (IsServiceRunning(c_wszSharedAccess))
    {
        hr = GetConnection(&pConnection);

        if (SUCCEEDED(hr))
        {
            hr = pConnection->GetGuid(&pConnectionGuid);
            pConnection->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = GetProtocol(&pProtocol);
        }

        if (SUCCEEDED(hr))
        {
            hr = pProtocol->GetGuid(&pProtocolGuid);
            pProtocol->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(
                    CLSID_SAUpdate,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                    IID_PPV_ARG(ISharedAccessUpdate, &pUpdate)
                    );

            if (SUCCEEDED(hr))
            {
                hr = pUpdate->ConnectionPortMappingChanged(
                        pConnectionGuid,
                        pProtocolGuid,
                        FALSE
                        );
                pUpdate->Release();
            }       
        }
    }

    if (NULL != pConnectionGuid)
    {
        CoTaskMemFree(pConnectionGuid);
    }

    if (NULL != pProtocolGuid)
    {
        CoTaskMemFree(pProtocolGuid);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\algsetup.h ===
// AlgSetup.h : Declaration of the CAlgSetup

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CAlgSetup
//
class ATL_NO_VTABLE CAlgSetup : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAlgSetup, &CLSID_AlgSetup>,
	public IDispatchImpl<IAlgSetup, &IID_IAlgSetup, &LIBID_NETCONLib>
{
public:
    DECLARE_REGISTRY(CAlgSetup, TEXT("Alg.AlgSetup.1"), TEXT("Alg.AlgSetup"), -1, THREADFLAGS_BOTH)

    DECLARE_NOT_AGGREGATABLE(CAlgSetup)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAlgSetup)
        COM_INTERFACE_ENTRY(IAlgSetup)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
    
//
// IAlgSetup
//
public:
	
	STDMETHODIMP Add(
        IN  BSTR    pszProgID, 
        IN  BSTR    pszPublisher, 
        IN  BSTR    pszProduct, 
        IN  BSTR    pszVersion, 
        IN  short   nProtocol,
        IN  BSTR    pszPorts
        );

    STDMETHODIMP Remove(
        IN  BSTR    pszProgID
        );



private:

    bool
    ArePortsAlreadyAssign(
        IN  LPCTSTR     pszPort,
        OUT BSTR*       pszOverlapping
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( alg_private )
EXTERN_PROXY_FILE( saupdate )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( alg_private ),
  REFERENCE_PROXY_FILE( saupdate ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

//#pragma comment(lib, "rpcndr.lib")
//#pragma comment(lib, "rpcns4.lib")
//#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    return TRUE;
}

STDAPI
PrxDllCanUnloadNow ()
{
    return S_OK;
}

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI
PrxDllRegisterServer ()
{
    return S_OK;
}

STDAPI
PrxDllUnregisterServer ()
{
    return S_OK;
}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\algsetup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Microsoft
//
// AlgSetup.cpp : Implementation of CAlgSetup
//
// JPDup    2001.01.01
//

//#include "pch.h"
#pragma hdrstop

#include "resource.h"   
#include "htmlhelp.h"
#include "sautil.h"

/////////////////////////////////////////////////////////////////////////////
// CConfirmation
//
class CConfirmation : public CDialogImpl<CConfirmation>
{
public:
    CConfirmation(
        LPCTSTR pszPublisher, 
        LPCTSTR pszProduct, 
        LPCTSTR pszPorts
    )
    {
        m_pszCompany = pszPublisher;
        m_pszProduct = pszProduct;
        m_pszPorts   = pszPorts;
        
    }
    
    ~CConfirmation()
    {
    }
    
    enum { IDD = IDD_CONFIRMATION };

    BEGIN_MSG_MAP(CConfirmation)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    END_MSG_MAP()
    
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SetDlgItemText(IDC_EDIT_COMPANY, m_pszCompany);
        SetDlgItemText(IDC_EDIT_PRODUCT, m_pszProduct);
        SetDlgItemText(IDC_EDIT_PORTS,   m_pszPorts);
        
        return 1;  // Let the system set the focus
    }
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }
    
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
                
        if ( CID_SA_ST_ICFLink == wParam )
        {
            UINT nCode = ((NMHDR* )lParam)->code;

            if ( NM_CLICK == nCode || NM_RETURN == nCode )
            {        

                // one help topic per SKU, 
                
                LPWSTR pszHelpTopic = NULL;
                
                OSVERSIONINFOEXW verInfo = {0};
                ULONGLONG ConditionMask = 0;
                
                verInfo.dwOSVersionInfoSize = sizeof(verInfo);
                verInfo.wProductType = VER_NT_WORKSTATION;
                verInfo.wSuiteMask = VER_SUITE_PERSONAL;
                
                VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);
                if ( 0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask) )
                {
                    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
                    if ( 0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE | VER_SUITENAME, ConditionMask) )
                    {
                        // personal
                        pszHelpTopic = TEXT("netcfg.chm::/hnw_plugin_using.htm");
                    }
                    else
                    {
                        // pro
                        pszHelpTopic = TEXT("netcfg.chm::/hnw_plugin_using.htm");
                    }
                }
                else
                {
                    // server
                    pszHelpTopic = TEXT("netcfg.chm::/hnw_plugin_using.htm");
                    
                }
                
                HtmlHelp(NULL, pszHelpTopic, HH_DISPLAY_TOPIC, 0);
                
                return 0;   
            }
        }

        return 1;
    }


    ULONG_PTR m_nSHFusion;   
    
    LPCTSTR  m_pszCompany;
    LPCTSTR  m_pszProduct;
    LPCTSTR  m_pszPorts;
};





/////////////////////////////////////////////////////////////////////////////
// CDlgInstallError
class CDlgInstallError : public CDialogImpl<CDlgInstallError>
{
public:
    CDlgInstallError(
        LONG nLastError
        )
    {
        m_nLastError = nLastError;
        //SHActivateContext(&m_nSHFusion);
    }

    ~CDlgInstallError()
    {
       //SHDeactivateContext(m_nSHFusion);        
    }

    enum { IDD = IDD_INSTALLERROR };

BEGIN_MSG_MAP(CDlgInstallError)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LPVOID lpMsgBuf;

        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            m_nLastError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
            );

        SetDlgItemInt(IDC_EDIT_LASTERROR_CODE, m_nLastError, false);
        SetDlgItemText(IDC_EDIT_LASTERROR, (LPCTSTR)lpMsgBuf);

        // Free the buffer.
        LocalFree( lpMsgBuf );

        return 1;  // Let the system set the focus
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

//
// Properties
//
private:

    ULONG_PTR   m_nSHFusion;   
    LONG        m_nLastError;
   
};






//
//
//
STDMETHODIMP 
CAlgSetup::Add(
    BSTR    pszProgID, 
    BSTR    pszPublisher, 
    BSTR    pszProduct, 
    BSTR    pszVersion, 
    short   nProtocol,
    BSTR    pszPorts 
    )
{
    USES_CONVERSION;
    LONG lRet;

    //
    // Open the main ALG hive
    //
    CRegKey RegKeyISV;
    lRet = RegKeyISV.Create(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\ALG"));

    if ( ERROR_SUCCESS != lRet )
    {
        //
        // The OS is not setup correctly
        // ALG hive should have been present.
        //
        return HRESULT_FROM_WIN32(lRet);
    }


    lRet = RegKeyISV.Create(RegKeyISV, TEXT("ISV"));
    if ( ERROR_SUCCESS != lRet )
    {
        //
        // Weird we are able to create/open the parent hive but not the ISV hive
        // 
        return HRESULT_FROM_WIN32(lRet);
    }


    
    //
    // Will attempt to Open/Create the ALG hive key to see if the user has ADMINI rights
    // if not then we will reject the install no need to confirm the install since he can't write to the registry
    //
    CRegKey KeyThisAlgModule;
    lRet = KeyThisAlgModule.Create(RegKeyISV, OLE2T(pszProgID));

    if ( ERROR_SUCCESS != lRet )
    {

        CDlgInstallError DlgInstallError(lRet);
        DlgInstallError.DoModal();
        return HRESULT_FROM_WIN32(lRet);
    }


    
    //
    //
    // Confirm that the ALG of the company/product is wanted by the user
    //
    //
    HANDLE hActivationContext;
    ULONG_PTR ulCookie;

    HRESULT hrLuna = ActivateLuna(&hActivationContext, &ulCookie);
    
    INITCOMMONCONTROLSEX CommonControlsEx;
    CommonControlsEx.dwSize = sizeof(CommonControlsEx);
    CommonControlsEx.dwICC = ICC_LINK_CLASS;

    if(InitCommonControlsEx(&CommonControlsEx))
    {
        
        CConfirmation DlgConfirm(
            OLE2T(pszPublisher), 
            OLE2T(pszProduct), 
            OLE2T(pszPorts)
            );
        
        if ( DlgConfirm.DoModal() != IDOK )
        {
            RegKeyISV.DeleteSubKey(OLE2T(pszProgID)); // Roll back created/test key
            return S_FALSE;
        }
    }
    
    if(SUCCEEDED(hrLuna))
    {
        DeactivateLuna(hActivationContext, ulCookie);
    }

    //
    // Write the news ALG plugin
    //
    KeyThisAlgModule.SetValue( OLE2T(pszPublisher),    TEXT("Publisher") );
    KeyThisAlgModule.SetValue( OLE2T(pszProduct),      TEXT("Product") );
    KeyThisAlgModule.SetValue( OLE2T(pszVersion),      TEXT("Version") );

    KeyThisAlgModule.SetValue( nProtocol,              TEXT("Protocol") );
    KeyThisAlgModule.SetValue( OLE2T(pszPorts),        TEXT("Ports") );


    // This will trigger the ALG.exe to refresh his load ALG modules
    RegKeyISV.SetValue(L"Enable", OLE2T(pszProgID) );     



    //
    // Add this ALG Module to the uninstall registry key in order to appear in the "Add/Remove Program"
    //
    CRegKey RegKeyUninstall;
    RegKeyUninstall.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
    RegKeyUninstall.Create(RegKeyUninstall, OLE2T(pszProgID));

    TCHAR szDisplayName[256];
    wsprintf(
        szDisplayName, 
        TEXT("Firewall Plugin Module from %s for %s version %s"), 
        OLE2T(pszPublisher), 
        OLE2T(pszProduct),
        OLE2T(pszVersion)
        );

    RegKeyUninstall.SetValue( szDisplayName, TEXT("DisplayName"));


    
    //
    // Setup the Add/Remove Program registry information in order to have the ALG be removed from the system
    //
    TCHAR szRunCommand[256];
    wsprintf(
        szRunCommand, 
        TEXT("RunDll32 %%SystemRoot%%\\system32\\hnetcfg.dll,AlgUninstall %s"), 
        OLE2T(pszProgID)
        );

    lRet = RegSetValueEx(
        RegKeyUninstall,            // handle to key
        TEXT("UninstallString"),    // value name
        0,                          // reserved
        REG_EXPAND_SZ,              // value type
        (const BYTE*)szRunCommand,               // value data
        (lstrlen(szRunCommand)+1)*sizeof(TCHAR)      // size of value data
        );

    //RegKeyUninstall.SetValue(szRunCommand, TEXT("UninstallString"));

    return S_OK;
}


//
//
//
STDMETHODIMP 
CAlgSetup::Remove(
    BSTR    pszProgID
    )
{
    USES_CONVERSION;


    TCHAR szRegPath[MAX_PATH];
    wsprintf(szRegPath,TEXT("SOFTWARE\\Microsoft\\ALG\\ISV"), OLE2T(pszProgID));


    CRegKey KeyAlgISV;


    //
    // Open the ISV hive
    //
    LONG lRet = KeyAlgISV.Open(HKEY_LOCAL_MACHINE, szRegPath);

    if ( ERROR_SUCCESS != lRet )
    {

        CDlgInstallError DlgInstallError(lRet);
        DlgInstallError.DoModal();

        return HRESULT_FROM_WIN32(lRet);
    }


    //
    // Remove the ALG plugin key
    //
    lRet = KeyAlgISV.DeleteSubKey(OLE2T(pszProgID));

    if ( ERROR_SUCCESS != lRet && lRet != ERROR_FILE_NOT_FOUND )
    {
        CDlgInstallError DlgInstallError(lRet);
        DlgInstallError.DoModal();

        return HRESULT_FROM_WIN32(lRet);
    }


    // This will trigger the ALG.exe to refresh his load ALG modules
    KeyAlgISV.DeleteValue(OLE2T(pszProgID) );     


    //
    // Remove from the Add/Remove Uninstall reg key
    //
    CRegKey RegKeyUninstall;
    RegKeyUninstall.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
    RegKeyUninstall.DeleteSubKey(OLE2T(pszProgID));


    return S_OK;
}



#define SIZE_PORTS  (ALG_SETUP_PORTS_LIST_BYTE_SIZE/sizeof(TCHAR))


//
//
//
bool
IsPortAlreadyAssign(
    IN  LPCTSTR     pszPort
    )
{

    CRegKey RegKeyISV;

    LRESULT lRet = RegKeyISV.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\ALG\\ISV"), KEY_READ);


    DWORD dwIndex=0;
    TCHAR szAlgModuleProgID[256];
    DWORD dwKeyNameSize;
    LONG  nRet;


    bool bPortAlreadyAssign=false;

    
    TCHAR* szPorts = new TCHAR[SIZE_PORTS];

    do
    {
        dwKeyNameSize = 256;

        nRet = RegEnumKeyEx(
            RegKeyISV.m_hKey,       // handle to key to enumerate
            dwIndex,                // subkey index
            szAlgModuleProgID,      // subkey name
            &dwKeyNameSize,         // size of subkey buffer
            NULL,                   // reserved
            NULL,                   // class string buffer
            NULL,                   // size of class string buffer
            NULL                    // last write time
            );

        dwIndex++; 

        if ( ERROR_NO_MORE_ITEMS == nRet )
            break;  // All items are enumerated we are done here


        if ( ERROR_SUCCESS == nRet )
        {
            CRegKey KeyALG;
            nRet = KeyALG.Open(RegKeyISV, szAlgModuleProgID, KEY_READ);

            if ( ERROR_SUCCESS == nRet )
            {
                //
                // str search to see if the port is in the ports list string
                // example is 21 is in   "39, 999, 21, 45"
                //
                
                ULONG nSizeOfPortsList = SIZE_PORTS;

                nRet = KeyALG.QueryValue(szPorts, TEXT("Ports"), &nSizeOfPortsList);

                if ( ERROR_SUCCESS == nRet )
                {
                    if ( wcsstr(szPorts, pszPort) != NULL )
                    {
                        bPortAlreadyAssign = true;
                    }
                 
                }
            }
        }
    } while ( ERROR_SUCCESS == nRet && bPortAlreadyAssign==false);

    delete szPorts;

    return bPortAlreadyAssign;
}








//
//
// This
//
void CALLBACK
AlgUninstall(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    CComObject<CAlgSetup>*   pAlgSetup;
    HRESULT hr = CComObject<CAlgSetup>::CreateInstance(&pAlgSetup);

    if ( SUCCEEDED(hr) )
    {
        TCHAR szConfirmRemove[512];
        TCHAR szTitle[512];


        LoadString(_Module.GetResourceInstance(), IDS_ADD_REMOVE,             szTitle, 512);
        LoadString(_Module.GetResourceInstance(), IDS_REMOVE_ALG_PLUGIN,      szConfirmRemove, 512);

        int nRet = MessageBox(
            GetFocus(), 
            szConfirmRemove, 
            szTitle, 
            MB_YESNO|MB_ICONQUESTION 
            );

        if ( IDYES == nRet )
        {
            CComBSTR    bstrAlgToRemove;
            bstrAlgToRemove = lpszCmdLine;

            pAlgSetup->Remove(bstrAlgToRemove);
        }
  
        delete pAlgSetup;  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\alg_private_p_stub.c ===
#include "alg_private_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\fwpages.h ===
#pragma once
#include <hnetcfg.h>


typedef struct tagCFirewallLoggingDialog
{
    IHNetFirewallSettings* pFirewallSettings;
    HNET_FW_LOGGING_SETTINGS* pSettings;

} CFirewallLoggingDialog;

typedef struct tagCICMPSettingsDialog
{
    IHNetConnection* pConnection;
    HNET_FW_ICMP_SETTINGS* pSettings;
} CICMPSettingsDialog;

HRESULT CFirewallLoggingDialog_Init(CFirewallLoggingDialog* pThis, IHNetCfgMgr* pHomenetConfigManager);
HRESULT CFirewallLoggingDialog_FinalRelease(CFirewallLoggingDialog* pThis);
INT_PTR CALLBACK CFirewallLoggingDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam);

HRESULT CICMPSettingsDialog_Init(CICMPSettingsDialog* pThis, IHNetConnection* pHomenetConnection);
HRESULT CICMPSettingsDialog_FinalRelease(CICMPSettingsDialog* pThis);
INT_PTR CALLBACK CICMPSettingsDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\fwpages.cpp ===
#include "pch.h"
#pragma hdrstop

#include "sautil.h"
#include "resource.h"

#include "fwpages.h"
#include <stddef.h>
#include <commdlg.h>

#define DEFAULT_FIREWALL_LOGFILE_SIZE 4096
#define DEFAULT_FIREWALL_LOGFILE_PATH TEXT("\\pfirewall.log")

extern LVXDRAWINFO*
SasLvxCallback(
    HWND hwndLv,
    DWORD dwItem );

static DWORD g_adwFirewallLoggingHelp[] =
{
    CID_FL_CB_LogDroppedInbound, HID_FL_CB_LogDroppedInbound,
    CID_FL_CB_LogOutboundConnections, HID_FL_CB_LogOutboundConnections,
    CID_FL_EB_Filename, HID_FL_EB_Filename,
    CID_FL_PB_Browse, HID_FL_PB_Browse,
    CID_FL_EB_Filesize, HID_FL_EB_Filesize,
    CID_FL_PB_RestoreDefaults, HID_FL_PB_RestoreDefaults,
    0, 0
};

static DWORD g_adwICMPHelp[] =
{
    CID_IC_LV_Settings, HID_IC_LV_Settings,
    CID_IC_ST_Description, HID_IC_ST_Description,
    0, 0
};

typedef struct tagICMPEntry
{
    UINT uiStringID;
    UINT uiDescID;
    size_t Offset;
} ICMPEntry;

static ICMPEntry g_ICMPEntries[] =
{
    {SID_ICMP_IECHO, SID_ICMP_IECHO_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundEchoRequest)},  
    {SID_ICMP_ITIME, SID_ICMP_ITIME_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundTimestampRequest)},  
    {SID_ICMP_IMASK, SID_ICMP_IMASK_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundMaskRequest)},  
    {SID_ICMP_IROUT, SID_ICMP_IROUT_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowInboundRouterRequest)},  
    {SID_ICMP_ODEST, SID_ICMP_ODEST_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundDestinationUnreachable)},  
    {SID_ICMP_OQNCH, SID_ICMP_OQNCH_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundSourceQuench)},  
    {SID_ICMP_OPRAM, SID_ICMP_OPRAM_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundParameterProblem)},  
    {SID_ICMP_OTIME, SID_ICMP_OTIME_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowOutboundTimeExceeded)},  
    {SID_ICMP_XRDRT, SID_ICMP_XRDRT_DESC, offsetof(HNET_FW_ICMP_SETTINGS, fAllowRedirect)},
    {0, 0},
};


HRESULT CFirewallLoggingDialog_GetDefaultLogfilePath(LPTSTR* ppszLogFilePath);
HRESULT CFirewallLoggingDialog_RestoreDefaults(HWND hwnd);
HRESULT CFirewallLoggingDialog_Apply(CFirewallLoggingDialog* pThis, HWND hWindow);
HRESULT CFirewallLoggingDialog_BrowseForLogfileName(HWND hWindow);

HRESULT CICMPSettingsDialog_Apply(CICMPSettingsDialog* pThis, HWND hWindow);
HRESULT CICMPSettingsDialog_ShowDescriptionText(HWND hwnd, INT nIndex);

INT_PTR CALLBACK CFirewallLoggingDialog_StaticDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam )

    // Called to handle messages for the 'Firewall Logging' page.
    //
{
    HRESULT hr = S_OK;
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            PROPSHEETPAGE* pPropertySheetPage = (PROPSHEETPAGE*) lparam;
            CFirewallLoggingDialog* pFirewallLoggingDialog = (CFirewallLoggingDialog*) pPropertySheetPage->lParam;
            HNET_FW_LOGGING_SETTINGS* pSettings = pFirewallLoggingDialog->pSettings;

            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pFirewallLoggingDialog);
            
            // Ignore if this fails, we're better off without it than killing the whole page
            CreateUpDownControl(WS_CHILD | WS_VISIBLE | WS_BORDER | UDS_SETBUDDYINT
                | UDS_ALIGNRIGHT | UDS_NOTHOUSANDS | UDS_ARROWKEYS, 0, 0, 0, 0, hwnd, -1, g_hinstDll, GetDlgItem(hwnd, CID_FL_EB_Filesize), UD_MAXVAL, 0, 0);

            if(NULL != pSettings)
            {
                SetDlgItemText(hwnd, CID_FL_EB_Filename, pSettings->pszwPath);
                SetDlgItemInt(hwnd, CID_FL_EB_Filesize, (UINT) (pSettings->ulMaxFileSize / 1024), FALSE); // REVIEW safe cast?
                CheckDlgButton(hwnd, CID_FL_CB_LogOutboundConnections, pSettings->fLogConnections ? BST_CHECKED : BST_UNCHECKED);
                CheckDlgButton(hwnd, CID_FL_CB_LogDroppedInbound, pSettings->fLogDroppedPackets ? BST_CHECKED : BST_UNCHECKED);
            }
            else
            {
                CFirewallLoggingDialog_RestoreDefaults(hwnd);                
            }


            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp(g_adwFirewallLoggingHelp, hwnd, unMsg, wparam, lparam);
            break;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wparam))
            {
            
            case CID_FL_PB_Browse:
                CFirewallLoggingDialog_BrowseForLogfileName(hwnd);
                break;
            
            case CID_FL_PB_RestoreDefaults:
                CFirewallLoggingDialog_RestoreDefaults(hwnd);
                break;

            }
            break;
        }
        
        case WM_NOTIFY:
        {
            switch (((NMHDR*)lparam)->code)
            {
            case PSN_KILLACTIVE:
                {
                    BOOL bTranslated;
                    UINT uiLogFileSize = GetDlgItemInt(hwnd, CID_FL_EB_Filesize, &bTranslated, FALSE);
                    if(TRUE == bTranslated)
                    {
                        if(UD_MAXVAL < uiLogFileSize || 1 > uiLogFileSize)
                        {

                            MsgDlg(hwnd, SID_FwbInvalidSize, NULL);
                            hr = E_UNEXPECTED;
                        }

                    }
                    else
                    {
                        MsgDlg(hwnd, SID_FwbInvalidSize, NULL);
                        hr = E_FAIL;
                    }

                    if(SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
                        
                    }

                    return TRUE;
                }
            
            case PSN_APPLY:
                {
                    CFirewallLoggingDialog* pFirewallLoggingDialog;
                    pFirewallLoggingDialog = (CFirewallLoggingDialog*) GetWindowLongPtr(hwnd, DWLP_USER);
                    hr = CFirewallLoggingDialog_Apply(pFirewallLoggingDialog, hwnd);
                    if(SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
                        
                    }

                    return TRUE;
                }

            }
            break;
        }
    }

    return FALSE;
}

HRESULT CFirewallLoggingDialog_RestoreDefaults(HWND hwnd)
{
    HRESULT hr;
    LPTSTR pszLogFilePath;
    hr = CFirewallLoggingDialog_GetDefaultLogfilePath(&pszLogFilePath);
    if(SUCCEEDED(hr))
    {
        SetDlgItemText(hwnd, CID_FL_EB_Filename, pszLogFilePath);
        CoTaskMemFree(pszLogFilePath);
    }

    SetDlgItemInt(hwnd, CID_FL_EB_Filesize, DEFAULT_FIREWALL_LOGFILE_SIZE, FALSE);
    CheckDlgButton(hwnd, CID_FL_CB_LogOutboundConnections, BST_UNCHECKED);
    CheckDlgButton(hwnd, CID_FL_CB_LogDroppedInbound, BST_UNCHECKED);

    return hr;
}

HRESULT CFirewallLoggingDialog_Init(CFirewallLoggingDialog* pThis, IHNetCfgMgr* pHomenetConfigManager)
{
    HRESULT hr;
    
    hr = pHomenetConfigManager->QueryInterface (IID_IHNetFirewallSettings, 
                                    (void**)&pThis->pFirewallSettings);
    if(SUCCEEDED(hr))
    {
        hr = pThis->pFirewallSettings->GetFirewallLoggingSettings (&pThis->pSettings);
        if(HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND) == hr)
        {
            ASSERT(NULL == pThis->pSettings);
            hr = S_OK;
        }

        if(FAILED(hr))
        {
            pThis->pFirewallSettings->Release();
            pThis->pFirewallSettings = NULL;
        }
    }

    return hr;
}

HRESULT CFirewallLoggingDialog_FinalRelease(CFirewallLoggingDialog* pThis)
{
    pThis->pFirewallSettings->Release();
    if(NULL != pThis->pSettings)
    {
        if(NULL != pThis->pSettings->pszwPath)
        {
            CoTaskMemFree(pThis->pSettings->pszwPath);
        }                        

    }
    return S_OK;
}


HRESULT CFirewallLoggingDialog_GetDefaultLogfilePath(LPTSTR* ppszLogfilePath)
{
    HRESULT hr = S_OK;
    LPTSTR pszAppendPath = DEFAULT_FIREWALL_LOGFILE_PATH;
    LPTSTR pszLogfilePath;
    UINT uiPathLength, uiLength;

    ASSERT(NULL != ppszLogfilePath);

    uiPathLength = GetWindowsDirectory(NULL, 0);
    if(0 != uiPathLength)
    {
        uiPathLength += lstrlen(pszAppendPath) + 1;
        pszLogfilePath = (LPTSTR) CoTaskMemAlloc((ULONG) (uiPathLength * sizeof(TCHAR)));
        if(NULL != pszLogfilePath)
        {
            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            uiLength = GetWindowsDirectory(pszLogfilePath, uiPathLength);
            if(0 != uiLength)
            {
                // REVIEW if the size of the windir somehow changes then we have problems, but this can't happen right?
                //
                lstrcpyn(
                    pszLogfilePath + uiLength,
                    TEXT('\\') == pszLogfilePath[uiLength - 1] ?
                        pszAppendPath + 1 : pszAppendPath,
                    uiPathLength - uiLength);
                *ppszLogfilePath = pszLogfilePath;
            }
            else
            {
                hr = E_FAIL;
            }

            if(FAILED(hr))
            {
                CoTaskMemFree(pszLogfilePath);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CFirewallLoggingDialog_Apply(CFirewallLoggingDialog* pThis, HWND hWindow)
{
    HRESULT hr = S_OK;
    HNET_FW_LOGGING_SETTINGS NewSettings;
    BOOL bTranslated;
    UINT uiLogFileSize;
    UINT uiSizeNeeded;

    NewSettings.fLogDroppedPackets = BST_CHECKED == IsDlgButtonChecked(hWindow, CID_FL_CB_LogDroppedInbound);
    NewSettings.fLogConnections = BST_CHECKED == IsDlgButtonChecked(hWindow, CID_FL_CB_LogOutboundConnections);
    NewSettings.pszwPath = NULL;

    if(SUCCEEDED(hr))
    {
        uiSizeNeeded = Edit_GetTextLength(GetDlgItem(hWindow, CID_FL_EB_Filename)) + 1;
        if(0 != uiSizeNeeded)
        {
            NewSettings.pszwPath = (LPWSTR) CoTaskMemAlloc((ULONG) (uiSizeNeeded * sizeof(TCHAR)));
            if(NULL != NewSettings.pszwPath)
            {
                uiSizeNeeded = GetDlgItemText(hWindow, CID_FL_EB_Filename, NewSettings.pszwPath, uiSizeNeeded);
                if(0 == uiSizeNeeded)
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_UNEXPECTED; // invalid param, empty filename
        }
        
    }
    
    if(SUCCEEDED(hr))
    {
        uiLogFileSize = GetDlgItemInt(hWindow, CID_FL_EB_Filesize, &bTranslated, FALSE);
        if(TRUE == bTranslated)
        {
            NewSettings.ulMaxFileSize = 1024 * (ULONG) uiLogFileSize;
        }
        else
        {
            hr = E_UNEXPECTED; // invalid param
        }
    }
    
    if(SUCCEEDED(hr))
    {
        BOOL bDirty = TRUE;

        if(NULL != pThis->pSettings) // we may not have gotten one on GetFirewallLoggingSettings
        {
            bDirty = FALSE;
            bDirty |= NewSettings.fLogDroppedPackets != pThis->pSettings->fLogDroppedPackets;
            bDirty |= NewSettings.fLogConnections != pThis->pSettings->fLogConnections;
            bDirty |= NewSettings.ulMaxFileSize != pThis->pSettings->ulMaxFileSize;
            bDirty |= 0 != lstrcmp(NewSettings.pszwPath, pThis->pSettings->pszwPath);
        }

        if(TRUE == bDirty)
        {
            hr = pThis->pFirewallSettings->SetFirewallLoggingSettings (&NewSettings);
        }
    }

    if(NULL != NewSettings.pszwPath)
    {
        CoTaskMemFree(NewSettings.pszwPath);
    }

    return hr;
}

HRESULT CFirewallLoggingDialog_BrowseForLogfileName(HWND hWindow)
{
    HRESULT hr = S_OK;

    OPENFILENAME ofn;
    TCHAR* pszFilterDesc;
    TCHAR* pszFilter;
    TCHAR* pszDefExt;
    TCHAR* pszTitle;
    TCHAR szBuf[ MAX_PATH + 1 ] = L"";
    TCHAR szDir[ MAX_PATH + 1] = L"";

    // Fill in FileOpen dialog parameter buffer.
    //
    
    // if any of these fail just let them be null
    pszFilterDesc = PszFromId( g_hinstDll, SID_FwbFilterDesc );
    pszTitle = PszFromId( g_hinstDll, SID_FwbTitle );
    pszDefExt = PszFromId( g_hinstDll, SID_FwbDefExt );

    // if this fails we will have a null path, so the open dialog should open at the root
    if(0 != GetDlgItemText(hWindow, CID_FL_EB_Filename, szDir, sizeof(szDir) / sizeof(TCHAR)))
    {
        // lose the file name
        LPWSTR pszLastSlash = wcsrchr(szDir, L'\\');
        if(NULL != pszLastSlash)
        {
            *pszLastSlash = L'\0';
        }
    }
    
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = GetParent( hWindow );
    ofn.hInstance = g_hinstDll;
    ofn.lpstrFilter = pszFilterDesc;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szBuf;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrTitle = pszTitle;
    ofn.lpstrDefExt = pszDefExt;
    ofn.Flags = 0;

    if (GetOpenFileName (&ofn))
    {
        SetWindowText( GetDlgItem(hWindow, CID_FL_EB_Filename), ofn.lpstrFile );
    }

    Free0(pszTitle);
    Free0(pszDefExt);
    Free0(pszFilterDesc);

    return S_OK;
}

INT_PTR CALLBACK CICMPSettingsDialog_StaticDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam )

    // Called to handle messages for the 'ICMP' page.
    //
{
    HRESULT hr;
    // Give the extended list-control a chance to look at all messages first.
    //
    if (ListView_OwnerHandler(hwnd, unMsg, wparam, lparam, SasLvxCallback))
    {
        return TRUE;
    }
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            UINT i = 0;
            UINT uiEntry = 0;
            LVITEM lvi;
            HWND hListView;

            PROPSHEETPAGE* pPropertySheetPage = (PROPSHEETPAGE*) lparam;
            CICMPSettingsDialog* pICMPSettingsDialog = (CICMPSettingsDialog*) pPropertySheetPage->lParam;
            HNET_FW_ICMP_SETTINGS* pSettings = pICMPSettingsDialog->pSettings;
            ASSERT(NULL != pSettings);

            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pICMPSettingsDialog);
            
            hListView = GetDlgItem(hwnd, CID_IC_LV_Settings);
            ASSERT(NULL != hListView);

            ListView_InstallChecks(hListView, g_hinstDll);
            ListView_InsertSingleAutoWidthColumn(hListView);
            
            while(0 != g_ICMPEntries[uiEntry].uiStringID)
            {
                LPTSTR pszText = PszFromId(g_hinstDll, g_ICMPEntries[uiEntry].uiStringID);
                if(NULL != pszText)
                {
                
                    ZeroMemory(&lvi, sizeof(lvi));
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    lvi.iItem = i + 1; // add to end
                    lvi.lParam = (LPARAM) g_ICMPEntries[uiEntry].Offset;
                    lvi.pszText = pszText;
                    lvi.cchTextMax = lstrlen(pszText) + 1;
                    
                    i = ListView_InsertItem(hListView, &lvi);
                    if (i != -1)
                    {
                        ListView_SetCheck(hListView, i, (BOOLEAN)*((BYTE*)pSettings + g_ICMPEntries[uiEntry].Offset)); // REVIEW 64bit safe?
                    }
                    Free(pszText);
                }
                uiEntry++;
            }
            ListView_SetItemState(hListView, 0, LVIS_SELECTED, LVIS_SELECTED);
            CICMPSettingsDialog_ShowDescriptionText(hwnd, 0);

            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp(g_adwICMPHelp, hwnd, unMsg, wparam, lparam);
            break;
        }

        case WM_COMMAND:
        {
            break;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR*)lparam)->code)
            {
                case PSN_APPLY:
                {
                    CICMPSettingsDialog* pICMPSettingsDialog;
                    pICMPSettingsDialog = (CICMPSettingsDialog*) GetWindowLongPtr(hwnd, DWLP_USER);
                    hr = CICMPSettingsDialog_Apply(pICMPSettingsDialog, hwnd);
                    if(SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
                        
                    }

                    return TRUE;
                }

                case LVXN_SETCHECK:
                {
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    INT nSelectedItem;
                    LPNMLISTVIEW ListViewInfo = (LPNMLISTVIEW) lparam;
                    if(-1 != ListViewInfo->iItem && LVIS_SELECTED & ListViewInfo->uNewState)
                    {
                        CICMPSettingsDialog_ShowDescriptionText(hwnd, ListViewInfo->iItem);
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

HRESULT CICMPSettingsDialog_Init(CICMPSettingsDialog* pThis, IHNetConnection* pHomenetConnection)
{
    HRESULT hr;
    
    pThis->pConnection = pHomenetConnection;
    pHomenetConnection->AddRef();
    
    hr = pHomenetConnection->GetIcmpSettings (&pThis->pSettings);
    if(FAILED(hr))
    {
        pHomenetConnection->Release();
    }
    return hr;

}

HRESULT CICMPSettingsDialog_FinalRelease(CICMPSettingsDialog* pThis)
{
    ASSERT(pThis->pConnection);
    pThis->pConnection->Release();
    
    ASSERT(pThis->pSettings);
    CoTaskMemFree(pThis->pSettings);
    return S_OK;
}

HRESULT CICMPSettingsDialog_Apply(CICMPSettingsDialog* pThis, HWND hWindow)
{
    HRESULT hr = S_OK;
    HNET_FW_ICMP_SETTINGS NewSettings;
    BOOL bDirty = FALSE;
    HWND hListView;
    LVITEM lvi;
    int nItemCount;

    hListView = GetDlgItem(hWindow, CID_IC_LV_Settings);
    ASSERT(NULL != hListView);

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;

    nItemCount = ListView_GetItemCount(hListView);
    while(0 < nItemCount--)
    {
        BOOLEAN bChecked = (BOOLEAN) ListView_GetCheck(hListView, nItemCount); // REVIEW can this error?
        lvi.iItem = nItemCount;

        if(TRUE == ListView_GetItem(hListView, &lvi))
        {
            (BOOLEAN)*((BYTE*)&NewSettings + lvi.lParam) = bChecked;
            if(bChecked != (BOOLEAN)*((BYTE*)(pThis->pSettings) + lvi.lParam)) // REVIEW 64bit safe?
            {
                bDirty = TRUE;
            }
        }
    }
    
    if(bDirty)
    {
        hr = pThis->pConnection->SetIcmpSettings (&NewSettings);
    }


    return hr;
}

HRESULT CICMPSettingsDialog_ShowDescriptionText(HWND hwnd, INT nIndex)
{
    
    LPWSTR pszDescription = PszFromId(g_hinstDll, g_ICMPEntries[nIndex].uiDescID);
    if(NULL != pszDescription)
    {
        SetDlgItemText(hwnd, CID_IC_ST_Description, pszDescription);
        Free(pszDescription);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hnapien.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I E N . C P P
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop


/*++

  CNetSharingManager::EnumEveryConnections

Routine Description:

	Return an IEnumNetEveryConnection interface used to enumerate all of
	the contained INetConnections configured as a public adapter

Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_EnumEveryConnection(
    INetSharingEveryConnectionCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingEveryConnection * pENEC = NULL;
    // idea:  use existing code below to fill out pENPC,
    // then convert to collection

	HRESULT hr = S_OK;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
    	*ppColl = NULL;
		hr      = E_ACCESSDENIED;
	}
	else
	{
    	*ppColl = NULL;
        
		INetConnectionManager* pManager = NULL;
        
		hr = CoCreateInstance( CLSID_ConnectionManager,
        					   NULL,
                               CLSCTX_ALL,
                               IID_PPV_ARG(INetConnectionManager, &pManager) );
                               
        if ( SUCCEEDED(hr) )
        {
		    IEnumNetConnection* pNetEnum = NULL;
			
	        SetProxyBlanket(pManager);

	        hr = pManager->EnumConnections(NCME_DEFAULT, &pNetEnum);
            
            if ( SUCCEEDED(hr) )
            {
		        CComObject<CSharingManagerEnumEveryConnection>* pEnum;

		        hr = CComObject<CSharingManagerEnumEveryConnection>::CreateInstance(&pEnum);

		        if ( SUCCEEDED(hr) )
	            {
		            pEnum->AddRef();

		            hr = pEnum->Initialize( pNetEnum, ICSSC_DEFAULT );

		            if ( SUCCEEDED(hr) )
	    	        {
		                hr = pEnum->QueryInterface(
		                        IID_PPV_ARG(IEnumNetSharingEveryConnection, &pENEC)
		                        );
					}

		            ReleaseObj(pEnum);
	            }
            
            	ReleaseObj(pNetEnum);
            }
         
         	ReleaseObj(pManager);   
    	}
    }
    
    // create collection:
    if (pENEC) {
        if (hr == S_OK) {
            CComObject<CNetSharingEveryConnectionCollection>* pNECC = NULL;
            hr = CComObject<CNetSharingEveryConnectionCollection>::CreateInstance (&pNECC);
            if (pNECC) {
                pNECC->AddRef();
                pNECC->Initialize (pENEC);
                hr = pNECC->QueryInterface (__uuidof(INetSharingEveryConnectionCollection), (void**)ppColl);
                pNECC->Release();
            }
        }
        pENEC->Release();
    }

    return hr;

    HNET_OEM_API_LEAVE
}

/*++

  CNetSharingManager::EnumPublicConnections

Routine Description:

	Return an IEnumNetPublicConnection interface used to enumerate all of
	the contained INetConnections configured as a public adapter

Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_EnumPublicConnections(
    SHARINGCONNECTION_ENUM_FLAGS Flags,
//  IEnumNetPublicConnection**   ppEnum
    INetSharingPublicConnectionCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingPublicConnection * pENPC = NULL;
    // idea:  use existing code below to fill out pENPC,
    // then convert to collection

	HRESULT hr = S_OK;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
		hr = E_ACCESSDENIED;
	}
	else
	{
		IEnumHNetIcsPublicConnections* pHNetEnum;

		hr = m_pIcsSettings->EnumIcsPublicConnections( &pHNetEnum );

		if ( SUCCEEDED(hr) )
		{
	        CComObject<CSharingManagerEnumPublicConnection>* pEnum;

	        hr = CComObject<CSharingManagerEnumPublicConnection>::CreateInstance(&pEnum);

	        if ( SUCCEEDED(hr) )
	        {
	            pEnum->AddRef();

	            hr = pEnum->Initialize( pHNetEnum, Flags );

	            if ( SUCCEEDED(hr) )
    	        {
	                hr = pEnum->QueryInterface(
	                        IID_PPV_ARG(IEnumNetSharingPublicConnection, &pENPC)
	                        );
				}

	            ReleaseObj(pEnum);
			}

			ReleaseObj(pHNetEnum);
        }
	}
    
    // create collection:
    if (pENPC) {
        if (hr == S_OK) {
            CComObject<CNetSharingPublicConnectionCollection>* pNPCC = NULL;
            hr = CComObject<CNetSharingPublicConnectionCollection>::CreateInstance (&pNPCC);
            if (pNPCC) {
                pNPCC->AddRef();
                pNPCC->Initialize (pENPC);
                hr = pNPCC->QueryInterface (__uuidof(INetSharingPublicConnectionCollection), (void**)ppColl);
                pNPCC->Release();
            }
        }
        pENPC->Release();
    }

	return hr;

    HNET_OEM_API_LEAVE
}


/*++

  CNetSharingManager::EnumPrivateConnections

Routine Description:

	Return an IEnumNetPrivateConnection interface used to enumerate all of
	the contained INetConnections configured as a private adapter

Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_EnumPrivateConnections(
    SHARINGCONNECTION_ENUM_FLAGS Flags,
//  IEnumNetPrivateConnection**  ppEnum)
    INetSharingPrivateConnectionCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingPrivateConnection * pENPC = NULL;
    // idea:  use existing code below to fill out pENPC,
    // then convert to collection

	HRESULT hr = S_OK;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
		hr = E_ACCESSDENIED;
	}
	else
	{
		IEnumHNetIcsPrivateConnections* pHNetEnum;

		hr = m_pIcsSettings->EnumIcsPrivateConnections( &pHNetEnum );

		if ( SUCCEEDED(hr) )
		{
	        CComObject<CSharingManagerEnumPrivateConnection>* pEnum;

	        hr = CComObject<CSharingManagerEnumPrivateConnection>::CreateInstance(&pEnum);

	        if ( SUCCEEDED(hr) )
	        {
	            pEnum->AddRef();

	            hr = pEnum->Initialize( pHNetEnum, Flags );

	            if ( SUCCEEDED(hr) )
    	        {
	                hr = pEnum->QueryInterface(
	                        IID_PPV_ARG(IEnumNetSharingPrivateConnection, &pENPC)
	                        );
				}

	            ReleaseObj(pEnum);
			}

			ReleaseObj(pHNetEnum);
        }
	}

    // create collection:
    if (pENPC) {
        if (hr == S_OK) {
            CComObject<CNetSharingPrivateConnectionCollection>* pNPCC = NULL;
            hr = CComObject<CNetSharingPrivateConnectionCollection>::CreateInstance (&pNPCC);
            if (pNPCC) {
                pNPCC->AddRef();
                pNPCC->Initialize (pENPC);
                hr = pNPCC->QueryInterface (__uuidof(INetSharingPrivateConnectionCollection), (void**)ppColl);
                pNPCC->Release();
            }
        }
        pENPC->Release();
    }

	return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::get_EnumPortMappings(
    SHARINGCONNECTION_ENUM_FLAGS Flags,
//  IEnumSharingPortMapping**     ppEnum)
    INetSharingPortMappingCollection** ppColl)
{
    HNET_OEM_API_ENTER

    IEnumNetSharingPortMapping * pESPM = NULL;
    // idea:  use existing code below to fill out pESPM,
    // then convert to collection
	HRESULT hr = S_OK;

	IHNetProtocolSettings *pProtocolSettings;

	if ( NULL == ppColl )
	{
		hr = E_POINTER;
	}
	else if ( !IsSecureContext() )
	{
		hr = E_ACCESSDENIED;
	}
	else if ( NULL == m_pHNetConnection )
	{
		hr = E_UNEXPECTED;
	}
	else
	{
	    IEnumHNetPortMappingBindings *pHNetEnum;

		hr = m_pHNetConnection->EnumPortMappings( Flags & ICSSC_ENABLED, &pHNetEnum );

		if ( SUCCEEDED(hr) )
		{
			CComObject<CSharingManagerEnumPortMapping>* pEnum;

			hr = CComObject<CSharingManagerEnumPortMapping>::CreateInstance(&pEnum);

			if ( SUCCEEDED(hr) )
			{
				pEnum->AddRef();

				hr = pEnum->Initialize( pHNetEnum, Flags );

				if ( SUCCEEDED(hr) )
				{
	                hr = pEnum->QueryInterface(
	                        IID_PPV_ARG(IEnumNetSharingPortMapping, &pESPM)
	                        );
				}

				ReleaseObj(pEnum);
			}

			ReleaseObj(pHNetEnum);
		}
	}

    // create collection:
    if (pESPM) {
        if (hr == S_OK) {
            CComObject<CNetSharingPortMappingCollection>* pNPCC = NULL;
            hr = CComObject<CNetSharingPortMappingCollection>::CreateInstance (&pNPCC);
            if (pNPCC) {
                pNPCC->AddRef();
                pNPCC->Initialize (pESPM);
                hr = pNPCC->QueryInterface (__uuidof(INetSharingPortMappingCollection), (void**)ppColl);
                pNPCC->Release();
            }
        }
        pESPM->Release();
    }

	return hr;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for hnetcfg.dll
//
//  Notes:
//
//  Author:     jonburs   22 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif





// extern
extern void SetSAUIhInstance (HINSTANCE hInstance); // in saui.cpp

// Global
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPNAT, CUPnPNAT)
    OBJECT_ENTRY(CLSID_HNetCfgMgr, CHNetCfgMgr)
    OBJECT_ENTRY(CLSID_NetSharingManager, CNetSharingManager)
    OBJECT_ENTRY(CLSID_AlgSetup, CAlgSetup)
END_OBJECT_MAP()

HRESULT
CompileMof(
    );


//+---------------------------------------------------------------------------
// DLL Entry Point
//

EXTERN_C
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID pvReserved
    )
{
    if ( !PrxDllMain(hInstance, dwReason, pvReserved) )
    {
        return FALSE;
    }


    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ::DisableThreadLibraryCalls(hInstance);
        
        _Module.Init(ObjectMap, hInstance, &LIBID_NETCONLib);
        
        InitializeOemApi( hInstance );
        SetSAUIhInstance (hInstance);
        EnableOEMExceptionHandling();
        EnableNATExceptionHandling();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        ReleaseOemApi();
        DisableOEMExceptionHandling();
        DisableNATExceptionHandling();
    } else if (dwReason == DLL_THREAD_ATTACH) {
        EnableOEMExceptionHandling();
        EnableNATExceptionHandling();
    } else if (dwReason == DLL_THREAD_DETACH) {
        DisableOEMExceptionHandling();
        DisableNATExceptionHandling();
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(VOID)
{
    if ( PrxDllCanUnloadNow() != S_OK )
    {
        return S_FALSE;
    }
    
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
    
    return _Module.GetClassObject(rclsid, riid, ppv);
}

static BOOL IsAllowedOS (void)
{   // (mostly cut-n-pasted from ...\net\config\common\ncbase\ncperms.cpp)
    
#ifndef _WIN64  // On IA64, all homenet technologies are unavailable.
    // Look for the enterprise SKUs
    OSVERSIONINFOEXW verInfo    = {0};
    ULONGLONG ConditionMask     = 0;
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wSuiteMask = VER_SUITE_DATACENTER | 
                         VER_SUITE_BACKOFFICE | 
                         VER_SUITE_SMALLBUSINESS_RESTRICTED |
                         VER_SUITE_SMALLBUSINESS |
                         VER_SUITE_BLADE;

    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);

    if(VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask))
        return FALSE;
    return TRUE;
#else
    return FALSE;
#endif
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer()
{
    HRESULT hr = PrxDllRegisterServer();
    
    if ( FAILED(hr) )
        return hr;

/*  replaced with code below
    hr = _Module.RegisterServer(TRUE);
*/
    // don't register NetSharingManager on DTC, SBS, WebBlade SKUs.
    hr = _Module.RegisterServer(TRUE, &CLSID_UPnPNAT);
    if (SUCCEEDED(hr))
        hr = _Module.RegisterServer(TRUE, &CLSID_HNetCfgMgr);
    if (SUCCEEDED(hr))
        hr = _Module.RegisterServer(TRUE, &CLSID_AlgSetup);

    if (SUCCEEDED(hr))
        if (IsAllowedOS())
            hr = _Module.RegisterServer(TRUE, &CLSID_NetSharingManager);

    if (SUCCEEDED(hr))  // register second typelib
        hr = _Module.RegisterTypeLib (_T("\\2"));

    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer()
{
    PrxDllUnregisterServer();
    
    _Module.UnregisterServer(TRUE);
    _Module.UnRegisterTypeLib (_T("\\2"));
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hnapiprp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I P R P . C P P
//
//  Contents:   OEM API
//
//  Notes:      Props (IDispatch wrappers)
//
//  Author:     bhanlon 17 Jan 2001
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
// CNetSharingPortMappingProps
STDMETHODIMP CNetSharingPortMappingProps::get_Name           (BSTR  * pbstrName)
{   // can't validate m_IPM
    HNET_OEM_API_ENTER

    _ASSERT (pbstrName);
    if (!pbstrName)
        return E_POINTER;

    *pbstrName = SysAllocString (m_IPM.pszwName);
    if (!*pbstrName)
        return E_OUTOFMEMORY;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_IPProtocol     (UCHAR * pucIPProt)
{
    HNET_OEM_API_ENTER

    _ASSERT (pucIPProt);
    if (!pucIPProt)
        return E_POINTER;

    *pucIPProt = m_IPM.ucIPProtocol;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_ExternalPort   (long * pusPort)
{
    HNET_OEM_API_ENTER

    _ASSERT (pusPort);
    if (!pusPort)
        return E_POINTER;

    *pusPort = m_IPM.usExternalPort;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_InternalPort   (long * pusPort)
{
    HNET_OEM_API_ENTER

    _ASSERT (pusPort);
    if (!pusPort)
        return E_POINTER;

    *pusPort = m_IPM.usInternalPort;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_Options        (long * pdwOptions)
{
    HNET_OEM_API_ENTER

    _ASSERT (pdwOptions);
    if (!pdwOptions)
        return E_POINTER;

    *pdwOptions = m_IPM.dwOptions;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_TargetName     (BSTR  * pbstrTargetName)
{
    HNET_OEM_API_ENTER

    _ASSERT (pbstrTargetName);
    if (!pbstrTargetName)
        return E_POINTER;

    *pbstrTargetName = SysAllocString (m_IPM.pszwTargetName);
    if (!*pbstrTargetName)
        return E_OUTOFMEMORY;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_TargetIPAddress(BSTR  * pbstrTargetIPAddress)
{
    HNET_OEM_API_ENTER

    _ASSERT (pbstrTargetIPAddress);
    if (!pbstrTargetIPAddress)
        return E_POINTER;

    *pbstrTargetIPAddress = SysAllocString (m_IPM.pszwTargetIPAddress);
    if (!*pbstrTargetIPAddress)
        return E_OUTOFMEMORY;
    return S_OK;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingPortMappingProps::get_Enabled (VARIANT_BOOL * pbool)
{
    HNET_OEM_API_ENTER

    _ASSERT (pbool);
    if (!pbool)
        return E_POINTER;

    *pbool = m_IPM.bEnabled;
    return S_OK;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hncapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C A P I . C P P
//
//  Contents:   Routines exported from HNetCfg.dll
//
//  Notes:
//
//  Author:     jonburs 20 June 2000
//
//  History:    billi   09 July 2000 - added HNet[Get|Set]ShareAndBridgeSettings
//                                     and supporting static functions
//              billi   14 Sep  2000 - added timeout work around for bridge creation
//                                     and SharePrivate.  This work to be removed
//                                     by Whistler Beta 2 due to DHCP fix.
//              billi   27 Dec  2000 - added HNW logging strings
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <lmcons.h>
#include <lmapibuf.h>
#include <ndispnp.h>
#include <raserror.h>
#include <winsock2.h>
#include <iphlpapi.h>     // ip helper 
#include <netconp.h>

extern "C" {              // make it work in C++
#include <dhcpcsdk.h>     // dhcp client options api
#include "powrprof.h"
}


const DWORD MAX_DISABLE_EVENT_TIMEOUT = 0xFFFF;

#define SECONDS_TO_WAIT_FOR_BRIDGE 20
#define SECONDS_TO_WAIT_FOR_DHCP   20
#define INITIAL_BUFFER_SIZE        256

extern HINSTANCE g_hOemInstance;

typedef struct _HNET_DELETE_RAS_PARAMS
{
    GUID Guid;
    HMODULE hModule;
} HNET_DELETE_RAS_PARAMS, *PHNET_DELETE_RAS_PARAMS;



VOID
HNetFreeFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS *pSettings
    )

/*++

Routine Description:

    Frees the memory used by a an HNET_FW_LOGGING_SETTINGS structure. This
    routine should only be used for structures obtained from
    IHNetFirewallSettings::GetFirewallLoggingSettings.


Arguments:

    pSettings - pointer to the structure to free. This pointer should not be
                NULL.

Return Value:

    None.

--*/

{
    if (NULL != pSettings)
    {
        if (NULL != pSettings->pszwPath)
        {
            CoTaskMemFree(pSettings->pszwPath);
        }

        CoTaskMemFree(pSettings);
    }
    else
    {
        _ASSERT(FALSE);
    }
}


DWORD
WINAPI
HNetDeleteRasConnectionWorker(
    VOID *pVoid
    )

/*++

Routine Description:

    Work item to perform the actual cleanup of a deleted
    RAS connection.

Arguments:

    pVoid - HNET_DELETE_RAS_PARAMS

Return Value:

    DWORD
    
--*/

{
    BOOL fComInitialized = FALSE;
    HRESULT hr;
    IHNetCfgMgr *pHNetCfgMgr;
    IHNetConnection *pHNetConnection;
    PHNET_DELETE_RAS_PARAMS pParams;

    _ASSERT(NULL != pVoid);
    pParams = reinterpret_cast<PHNET_DELETE_RAS_PARAMS>(pVoid);

    //
    // Make sure COM is initialized on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        fComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }

    //
    // Create the config manager
    //

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
                CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_SERVER,
                IID_PPV_ARG(IHNetCfgMgr, &pHNetCfgMgr)
                );
    }

    //
    // Try to obtain the IHNetConnection for the guid
    //

    if (SUCCEEDED(hr))
    {
        hr = pHNetCfgMgr->GetIHNetConnectionForGuid(
                &pParams->Guid,
                FALSE,
                FALSE,
                &pHNetConnection
                );

        if (SUCCEEDED(hr))
        {
            //
            // Ask the connection to delete itself
            //

            hr = pHNetConnection->DeleteRasConnectionEntry();
            pHNetConnection->Release();
        }

        pHNetCfgMgr->Release();
    }

    //
    // Uninitialize COM, if necessary
    //

    if (TRUE == fComInitialized)
    {
        CoUninitialize();
    }

    //
    // Free the params and exit thread.
    //

    HMODULE hModule = pParams->hModule;
    HeapFree(GetProcessHeap(), 0, pParams);
    FreeLibraryAndExitThread(hModule, ERROR_SUCCESS);

    return ERROR_SUCCESS;
} // HNetDeleteRasConnectionWorker


VOID
WINAPI
HNetDeleteRasConnection(
    GUID *pGuid
    )

/*++

Routine Description:

    Called by rasapi32 when a RAS connection is being deleted. The
    actual work is performed on a separate thread.

Arguments:

    pGuid - the GUID of the connection to delete

Return Value:

    None.
    
--*/

{
    HANDLE hThread;
    PHNET_DELETE_RAS_PARAMS pParams = NULL;

    do
    {
        if (NULL == pGuid)
        {
            break;
        }

        //
        // Setup the work item paramters
        //

        pParams =
            reinterpret_cast<PHNET_DELETE_RAS_PARAMS>(
                HeapAlloc(GetProcessHeap(), 0, sizeof(*pParams))
                );

        if (NULL == pParams)
        {
            break;
        }

        //
        // We need to add a reference to hnetcfg to guarantee that the
        // dll won't be unloaded before the worker finishes execution.
        //

        pParams->hModule = LoadLibraryW(L"hnetcfg");

        if (NULL == pParams->hModule)
        {
            break;
        }

        CopyMemory(&pParams->Guid, pGuid, sizeof(*pGuid));

        //
        // Create the worker thread. (We can't use QueueUserWorkItem
        // due to a possible race condition w/r/t unloading the
        // library and returning from the work item).
        //

        hThread =
            CreateThread(
                NULL,
                0,
                HNetDeleteRasConnectionWorker,
                pParams,
                0,
                NULL
                );

        if (NULL == hThread)
        {
            break;
        }

        CloseHandle(hThread);

        return;
        
    } while (FALSE);


    //
    // Failure path cleanup
    //

    if (NULL != pParams)
    {
        if (NULL != pParams->hModule)
        {
            FreeLibrary(pParams->hModule);
        }

        HeapFree(GetProcessHeap(), 0, pParams);
    }
    
} // HNetDeleteRasConnection



#if DBG

WCHAR tcDbgPrtBuf[ BUF_SIZE + 1 ] = _T("");

void inline rawdebugprintf( wchar_t *buf )
{
    _sntprintf( tcDbgPrtBuf, BUF_SIZE, buf );

    tcDbgPrtBuf[BUF_SIZE] = _T('\0');

    OutputDebugString(tcDbgPrtBuf);

    return;
}


void inline debugprintf( wchar_t *preamble, wchar_t *buf )
{
    OutputDebugString( _T("HNET: ") );

    OutputDebugString( preamble );

    OutputDebugString( buf );

    OutputDebugString( _T("\r\n") );

    return;
}

void inline debugretprintf( wchar_t *msg, HRESULT hResult )
{
    _sntprintf( tcDbgPrtBuf, BUF_SIZE, _T("HNET: %s = %x\r\n"), msg, hResult );

    tcDbgPrtBuf[BUF_SIZE] = _T('\0');

    OutputDebugString( tcDbgPrtBuf );

    return;
}

#define TRACE_ENTER(x)      debugprintf( _T("==> "), _T(x) );

#define TRACE_LEAVE(x,y)    debugretprintf( _T("<== ")_T(x), y );

#else

#define rawdebugprintf(x)
#define debugprintf(x,y)
#define debugretprintf(x,y)
#define TRACE_ENTER(x)
#define TRACE_LEAVE(x,y)

#endif



HRESULT
UpdateHnwLog(
    IN LPHNWCALLBACK lpHnwCallback,
    IN LPARAM        lpContext,
    IN UINT          uID,
    IN LPCWSTR       lpczwValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr = S_OK;

    if ( NULL == lpHnwCallback )
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        LPWSTR lpFormat = new WCHAR[ NOTIFYFORMATBUFFERSIZE ];
        
        if ( NULL != lpFormat )
        {
            if ( LoadString( g_hOemInstance,            // handle to resource module
                             uID,                       // resource identifier
                             lpFormat,                  // resource buffer
                             NOTIFYFORMATBUFFERSIZE-1 ) // size of buffer
                             == 0 )
            {
                hr = HrFromLastWin32Error();
            }
            else
            {
                if ( NULL != lpczwValue )
                {
                    LPWSTR lpBuffer = new WCHAR[ HNWCALLBACKBUFFERSIZE ];
                    
                       if ( NULL != lpBuffer )
                    {
                        _snwprintf( lpBuffer, HNWCALLBACKBUFFERSIZE-1, lpFormat, lpczwValue );
        
                        (*lpHnwCallback)( lpBuffer, lpContext );
                        
                        delete [] lpBuffer;
                    }
                    else
                       {
                        (*lpHnwCallback)( lpFormat, lpContext );
                        
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    (*lpHnwCallback)( lpFormat, lpContext );
                }
            }

            delete [] lpFormat;
         }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID,
    IN  DWORD         dwValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    WCHAR pzwValue[ 32 ];
    
    _snwprintf( pzwValue, 32, L"%lx", dwValue );
    
    return UpdateHnwLog( lpHnwCallback, lpContext, uID, pzwValue );
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID,
    IN  int           iValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    WCHAR pzwValue[ 32 ];
    
    _snwprintf( pzwValue, 32, L"%x", iValue );
    
    return UpdateHnwLog( lpHnwCallback, lpContext, uID, pzwValue );
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    return UpdateHnwLog( lpHnwCallback, lpContext, uID, NULL );
}



HRESULT
UpdateHnwLog(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext,
    IN  UINT          uID,
    IN  LPCSTR        lpczValue
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr     = E_FAIL;
    int     iChars = 0;
    
    iChars = MultiByteToWideChar( CP_THREAD_ACP, 0, lpczValue, -1, NULL, 0 );
    
    if ( 0 != iChars )
    {
        LPWSTR lpWideStr = new WCHAR[ iChars + 1 ];
        
        if ( NULL != lpWideStr )
        {
            if ( !MultiByteToWideChar( CP_THREAD_ACP, 0, lpczValue, -1, lpWideStr, iChars ) )
            {
                hr = UpdateHnwLog( lpHnwCallback, lpContext, uID, lpWideStr );
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
            delete[] lpWideStr;
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }
    
    return hr;
}



HRESULT
CheckNetCfgWriteLock( 
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT   hr;
    INetCfg  *pnetcfg = NULL;

    TRACE_ENTER("CheckNetCfgWriteLock");

    hr = CoCreateInstance( CLSID_CNetCfg, NULL, CLSCTX_SERVER, IID_PPV_ARG(INetCfg, &pnetcfg ) );

    if ( SUCCEEDED(hr) )
    {
        INetCfgLock *pncfglock = NULL;

        // Get the lock interface
        
        hr = pnetcfg->QueryInterface( IID_PPV_ARG(INetCfgLock, &pncfglock) );

        if ( SUCCEEDED(hr) )
        {
            // Get the NetCfg lock
            
            hr = pncfglock->AcquireWriteLock( 5, L"HNetCfg", NULL );
            
            if ( SUCCEEDED(hr) )
            {
                pncfglock->ReleaseWriteLock();
            }
            else
            {
            }
            
            pncfglock->Release();
        }
        else
        {
        }
        
        pnetcfg->Release();
    }
    else
    {
    }

    TRACE_LEAVE("CheckNetCfgWriteLock", hr);
    
    return hr;
}



HRESULT
ArpForConflictingDhcpAddress(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr      = S_OK;
    WSADATA wsaData;
    int     iWsaErr;

    TRACE_ENTER("ArpForConflictingDhcpAddress");

    iWsaErr = WSAStartup( 0x202, &wsaData );

    if ( 0 != iWsaErr )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_INTERNET, iWsaErr );

        UpdateHnwLog( lpHnwCallback, lpContext, IDS_WSAERRORDURINGDETECTION, iWsaErr );
    }
    else
    {
        // Obtain required ICS server address

        ULONG TargetAddress, TargetMask;
        
        hr = ReadDhcpScopeSettings( &TargetAddress, &TargetMask );

        if ( SUCCEEDED(hr) )
        {
            // Retrieve the best interface for the target IP address,
            // and also perform a UDP-connect to determine the 'closest'
            // local IP address to the target IP address.
            
            ULONG InterfaceIndex;

            if ( GetBestInterface( TargetAddress, &InterfaceIndex ) != NO_ERROR )
            {
                int         Length;
                SOCKADDR_IN SockAddrIn;
                SOCKET      Socket;

                SockAddrIn.sin_family      = AF_INET;
                SockAddrIn.sin_port        = 0;
                SockAddrIn.sin_addr.s_addr = TargetAddress;

                Socket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
                
                if ( INVALID_SOCKET != Socket )
                {
                    iWsaErr = connect( Socket, (PSOCKADDR)&SockAddrIn, sizeof(SockAddrIn) );
                    
                    if ( NO_ERROR == iWsaErr )
                    {
                        iWsaErr = getsockname( Socket, ( PSOCKADDR)&SockAddrIn, &Length );
                    }
                }
                else
                {
                    iWsaErr = SOCKET_ERROR;
                }
            
                if ( NO_ERROR != iWsaErr )
                {
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_INTERNET, iWsaErr );

                    UpdateHnwLog( lpHnwCallback, lpContext, IDS_WSAERRORDURINGDETECTION, iWsaErr );
                }
                else
                {
                    // Make sure the target IP address isn't already cached,
                    // by removing it from the ARP cache if present using the interface index
                    // determined above.
                    
                    MIB_IPNETROW IpNetRow;
                    DWORD        dwError;
                    CHAR         HardwareAddress[6];
                    ULONG        HardwareAddressLength;
                    ULONG        SourceAddress;

                    SourceAddress = SockAddrIn.sin_addr.s_addr;
                    
                    ZeroMemory( &IpNetRow, sizeof(IpNetRow) );
                    IpNetRow.dwIndex       = InterfaceIndex;
                    IpNetRow.dwPhysAddrLen = 6;
                    IpNetRow.dwAddr        = TargetAddress;
                    IpNetRow.dwType        = MIB_IPNET_TYPE_INVALID;

                    DeleteIpNetEntry( &IpNetRow );

                    dwError = SendARP( TargetAddress,               // destination IP address
                                       SourceAddress,               // IP address of sender
                                       (PULONG)HardwareAddress,     // returned physical address
                                       &HardwareAddressLength       // length of returned physical addr.
                            );

                    if ( NO_ERROR == dwError )
                    {
                        TargetAddress = inet_addr( HardwareAddress );
                        
                        if ( TargetAddress != SourceAddress )
                        {
                            hr = E_ICSADDRESSCONFLICT;
    
                            UpdateHnwLog( lpHnwCallback, 
                                          lpContext, 
                                          IDS_ICSADDRESSCONFLICTDETECTED, 
                                          HardwareAddress );
                        }
                        else
                        {
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_INTERNET, dwError );
                        
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_SENDARPERRORDURINGDETECTION, dwError );
                    }
                }                
            }
        }
    }

    TRACE_LEAVE("ArpForConflictingDhcpAddress", hr);

    return hr;
}



HRESULT
ObtainIcsErrorConditions(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr;

    TRACE_ENTER("ObtainIcsErrorConditions");
    
    hr = ArpForConflictingDhcpAddress( lpHnwCallback, lpContext );
    
    if ( SUCCEEDED(hr) )
    {
        hr = CheckNetCfgWriteLock( lpHnwCallback, lpContext );
        
        if ( SUCCEEDED(hr) )
        {
            // Create Homenet Configuration Manager COM Instance

            IHNetCfgMgr* pCfgMgr;

            hr = CoCreateInstance( CLSID_HNetCfgMgr, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_PPV_ARG(IHNetCfgMgr, &pCfgMgr) );
                                   
            if ( SUCCEEDED(hr) )
            {
                pCfgMgr->Release();
            }
            else
            {
                UpdateHnwLog( lpHnwCallback, lpContext, IDS_SHARINGCONFIGURATIONUNAVAIL );
            }
        }
    }
    
    TRACE_LEAVE("ObtainIcsErrorConditions", hr);

    return hr;
}


HRESULT
HRGetConnectionAdapterName( 
    INetConnection *pNetConnection,
    LPWSTR         *ppzwAdapterName 
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr;

    TRACE_ENTER("HRGetConnectionAdapterName");

    if ( NULL == pNetConnection )
    {
        hr = E_INVALIDARG;
    }
    else if ( NULL == ppzwAdapterName )
    {
        hr = E_POINTER;
    }
    else
    {
        NETCON_PROPERTIES* pProps;

        *ppzwAdapterName = NULL;

        hr = pNetConnection->GetProperties(&pProps);

        if ( SUCCEEDED( hr ) )
        {
            *ppzwAdapterName = new WCHAR[ wcslen( pProps->pszwDeviceName ) + 1 ];
            
            if ( NULL != *ppzwAdapterName )
            {
                wcscpy( *ppzwAdapterName, pProps->pszwDeviceName );

                debugprintf( _T("\t"), *ppzwAdapterName );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            NcFreeNetconProperties( pProps );
        }
    }

    TRACE_LEAVE("HRGetConnectionAdapterName", hr);

    return hr;
}



HRESULT
GetIcsPublicConnection( 
    IN  CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    OUT INetConnection     **ppNetPublicConnection,
    OUT BOOLEAN             *pbSharePublicConnection OPTIONAL,
    OUT BOOLEAN             *pbFirewallPublicConnection OPTIONAL
    )
/*++

Routine Description:


Arguments:


Return Value:

    hResult

--*/
{
    HRESULT hr;

    TRACE_ENTER("GetIcsPublicConnection");

    CComPtr<IHNetIcsSettings> spIHNetIcsSettings;

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppNetPublicConnection );

    if ( NULL == ppNetPublicConnection )
    {
        hr = E_POINTER;
    }
    else if ( spIHNetCfgMgr == NULL )
    {
        hr = E_INVALIDARG;

        *ppNetPublicConnection = NULL;
    }
    else
    {
        // initialize arguments

        *ppNetPublicConnection = NULL;

        if ( NULL != pbSharePublicConnection )
            *pbSharePublicConnection    = FALSE;

        if ( NULL != pbFirewallPublicConnection )
            *pbFirewallPublicConnection = FALSE;

        // Obtain interface pointer
        
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetIcsSettings, &spIHNetIcsSettings ) );

        if ( SUCCEEDED(hr) )
        {
            hr = S_OK;
        }
    }

    if ( S_OK == hr )
    {
        CComPtr<IEnumHNetIcsPublicConnections> spehiPublic;

        if ( ( hr = spIHNetIcsSettings->EnumIcsPublicConnections( &spehiPublic ) ) == S_OK )
        {
            CComPtr<IHNetIcsPublicConnection> spIHNetIcsPublic;

            // obtain only the first IHNetIcsPublicConnetion

            if ( ( hr = spehiPublic->Next( 1, &spIHNetIcsPublic, NULL ) ) == S_OK )
            {
                // obtain pointer to IID_IHNetConnection interface of object
                
                CComPtr<IHNetConnection> spIHNetPublic;

                hr = spIHNetIcsPublic->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNetPublic ) );
                
                _ASSERT( SUCCEEDED(hr) );
                
                if ( SUCCEEDED(hr) )
                {
                    // The reference count will be decremented by the caller
                    // if necessary.  Notice we are using the caller's pointer
                    // variable.
                
                    hr = spIHNetPublic->GetINetConnection( ppNetPublicConnection );

                    if ( SUCCEEDED(hr) )
                    {
                        HNET_CONN_PROPERTIES *phncProperties;

                        hr = spIHNetPublic->GetProperties( &phncProperties );

                        if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )
                        {
                            if ( NULL != pbSharePublicConnection )
                                *pbSharePublicConnection = phncProperties->fIcsPublic;
                                
                            if ( NULL != pbFirewallPublicConnection )
                                *pbFirewallPublicConnection = phncProperties->fFirewalled;

                            CoTaskMemFree( phncProperties );
                    
                        }   //if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )

                        if ( FAILED(hr) )
                        {
                            (*ppNetPublicConnection)->Release();

                            *ppNetPublicConnection = NULL;
                        }
                    
                    }   // if ( SUCCEEDED(hr) )
                
                }   // if ( SUCCEEDED(hr) )
            
            }   // if ( ( hr = pehiPublic->Next( 1, &sphicPublic, NULL ) ) == S_OK )

        }   // if ( ( hr = pIHNetCfgMgr->EnumIcsPublicConnections( &pehiPublic ) ) == S_OK )
    }

    TRACE_LEAVE("GetIcsPublicConnection", hr);

    return hr;
}



HRESULT
GetIcsPrivateConnections( 
    IN  CComPtr<IHNetCfgMgr>   spIHNetCfgMgr,
    OUT INetConnection      ***ppNetPrivateConnection
    )

/*++

Routine Description:

    Obtain the private connections enumerator and loop
    through enumeration twice.  Set the required array
    length during the first enumeration.  If the parameter
    array is big enough initialize it during the second
    enumeration.

Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;
    ULONG   ulArrayLength, ulListLength, uIndex;
    BOOLEAN bBufferAllocated;

    CComPtr<IHNetIcsSettings>                 spIHNetIcsSettings;
    IHNetIcsPrivateConnection                *pIHNetIcsPrivate;
    IHNetIcsPrivateConnection               **ppIHNetIPList;
    CComPtr<IEnumHNetIcsPrivateConnections>   spehiPrivate;

    TRACE_ENTER("GetIcsPrivateConnections");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppNetPrivateConnection );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == ppNetPrivateConnection )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // initialize local vars

        ulArrayLength    = 0L;
        ulListLength     = 0L;
        bBufferAllocated = FALSE;

        // Obtain interface pointer
        
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetIcsSettings, &spIHNetIcsSettings ) );

        if ( SUCCEEDED(hr) )
        {
            hr = S_OK;
        }

    }   // else

    if ( S_OK == hr )   
    {
        if ( ( hr = spIHNetIcsSettings->EnumIcsPrivateConnections( &spehiPrivate ) ) == S_OK )
        {
            while ( spehiPrivate->Next( 1, &pIHNetIcsPrivate, NULL ) == S_OK )
            {
                ulArrayLength++;
                pIHNetIcsPrivate->Release();
            }

            // releasing the enumeration interface now so we can re-initialize it later

            spehiPrivate = NULL;
            
        }   // if ( ( hr = spIHNetIcsSettings->EnumIcsPublicConnections( &pehiPublic ) ) == S_OK )

    }   // if ( S_OK == hr )

    if ( S_OK == hr )   
    {
        if ( ( hr = spIHNetIcsSettings->EnumIcsPrivateConnections( &spehiPrivate ) ) == S_OK )
        {
            hr = spehiPrivate->Next( ulArrayLength, &pIHNetIcsPrivate, &ulListLength );

            if ( S_OK == hr )
            {
                // Allocate array of INetConnection pointers.  There will
                // be on extra pointer element for the NULL pointer at the
                // end of the array.  We allocate this buffer with 
                // NetApiBufferAllocate so the buffer must be released using
                // NetApiBufferFree.

                NET_API_STATUS nErr;
                LPVOID         lpvBuffer;
            
                ++ulArrayLength;

                nErr = NetApiBufferAllocate( ulArrayLength * sizeof(INetConnection *), 
                                         (LPVOID *)ppNetPrivateConnection );

                if ( NERR_Success == nErr )
                {
                    bBufferAllocated = TRUE;

                    for ( uIndex = 0L; uIndex < ulArrayLength; uIndex++ )
                    {
                        (*ppNetPrivateConnection)[uIndex] = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;

                    // must release IHNetIcsPrivateConnection instances

                    ppIHNetIPList = &pIHNetIcsPrivate;

                    for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
                    {
                        ppIHNetIPList[uIndex]->Release();
                    }
                }

            }   // if ( S_OK == hr )

            // done with enumeration interface pointer so we explicitly release it

            spehiPrivate = NULL;
            
        }   // if ( ( hr = spIHNetIcsSettings->EnumIcsPublicConnections( &pehiPublic ) ) == S_OK )

    }   // if ( S_OK == hr )


    if ( S_OK == hr )
    {
        ppIHNetIPList = &pIHNetIcsPrivate;

        for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
        {
            if ( uIndex < ulArrayLength - 1 )
            {
                CComPtr<IHNetConnection> spIHNetPrivate;

                hr = ppIHNetIPList[uIndex]->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNetPrivate ) );
                _ASSERT( SUCCEEDED(hr) );

                if ( SUCCEEDED(hr) )
                {
                    // We allow the caller to invoke Release for (*ppNetPrivateConnection)[uIndex]

                    hr = spIHNetPrivate->GetINetConnection( &((*ppNetPrivateConnection)[uIndex]) );
                    _ASSERT( SUCCEEDED(hr) );
                }
                
            }   // if ( uIndex < uiArrayLength - 1 )

            ppIHNetIPList[uIndex]->Release();

        }   // for ( uIndex = 0L; ...

    }   // if ( S_OK == hr )

    if ( !SUCCEEDED(hr) )
    {
        // If we fail after allocating the buffer then we need release
        // references and buffer

        if ( bBufferAllocated )
        {
            for ( uIndex = 0L; uIndex < ulArrayLength; uIndex++ )
            {
                if ( NULL != (*ppNetPrivateConnection)[uIndex] )
                {
                    (*ppNetPrivateConnection)[uIndex]->Release();
                }
            }

            NetApiBufferFree( *ppNetPrivateConnection );
        }
    }
        
    TRACE_LEAVE("GetIcsPrivateConnections", hr);

    return hr;
}



HRESULT
GetBridge(
    IN  CComPtr<IHNetCfgMgr>   spIHNetCfgMgr,
    OUT IHNetBridge          **ppBridge 
    )

/*++

Routine Description:

    Obtain the bridge enumerator and loop through enumeration.

Arguments:


Return Value:

--*/

{
    HRESULT hr = E_INVALIDARG;

    TRACE_ENTER("GetBridge");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppBridge );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == ppBridge )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;
        
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetBridgeSettings, &spIHNetBridgeSettings ) );

        if ( SUCCEEDED(hr) )
        {
            CComPtr<IEnumHNetBridges> spBridgeEnum;

            hr = spIHNetBridgeSettings->EnumBridges( &spBridgeEnum );

            if ( SUCCEEDED(hr) )
            {
                hr = spBridgeEnum->Next( 1, ppBridge, NULL );
                
                if ( S_FALSE == hr )
                {
                    hr = E_FAIL;
                }

                // We allow the caller to invoke Release for *ppBridge
            }

        }   // if ( SUCCEEDED(hr) )

    }   // else

    TRACE_LEAVE("GetBridge", hr);

    return hr;
}



HRESULT
GetBridgedConnections(
    IN  CComPtr<IHNetCfgMgr>   spIHNetCfgMgr,
    OUT INetConnection      ***ppNetPrivateConnection
    )

/*++

Routine Description:

    Obtain the bridge connections enumerator and loop
    through enumeration twice.  Set the required array
    length during the first enumeration.  If the parameter
    array is big enough initialize it during the second
    enumeration.

Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;
    ULONG   ulArrayLength, ulListLength, uIndex;

    CComPtr<IHNetBridge>                  spBridge;
    CComPtr<IEnumHNetBridgedConnections>  spEnum;
    IHNetBridgedConnection               *pIHNetBridged;
    IHNetBridgedConnection              **ppIHNetBridgeList;

    TRACE_ENTER("GetBridgedConnections");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != ppNetPrivateConnection );

    if ( NULL == ppNetPrivateConnection )
    {
        hr = E_POINTER;
    }
    else if ( spIHNetCfgMgr == NULL )
    {
        hr = E_INVALIDARG;

        *ppNetPrivateConnection = NULL;
    }
    else
    {
        // initialize arguments

        *ppNetPrivateConnection = NULL;
        ulArrayLength           = 0L;
        ulListLength            = 0L;

        // Obtain bridge interface pointer
        
        hr = GetBridge( spIHNetCfgMgr, &spBridge );

    }   // else

    if ( S_OK == hr )
    {
        if ( ( hr = spBridge->EnumMembers( &spEnum ) ) == S_OK )
        {
            while ( spEnum->Next( 1, &pIHNetBridged, NULL ) == S_OK )
            {
                ulArrayLength++;
                pIHNetBridged->Release();
            }

            // releasing the enumeration interface instance so we can re-initialize it later

            spEnum = NULL;
        
        }   // if ( ( hr = spBridge->EnumMembers( &spEnum ) ) == S_OK )

    }   // if ( S_OK == hr )


    if ( S_OK == hr )   
    {
        if ( ( hr = spBridge->EnumMembers( &spEnum ) ) == S_OK )
        {
            hr = spEnum->Next( ulArrayLength, &pIHNetBridged, &ulListLength );

            if ( S_OK == hr )
            {
                // Allocate array of INetConnection pointers.  There will
                // be on extra pointer element for the NULL pointer at the
                // end of the array.  We allocate this buffer with 
                // NetApiBufferAllocate so the buffer must be released using
                // NetApiBufferFree.

                NET_API_STATUS nErr;
            
                ++ulArrayLength;
            
                nErr = NetApiBufferAllocate( ulArrayLength*sizeof(INetConnection *), 
                                             (LPVOID *)ppNetPrivateConnection );

                if ( NERR_Success == nErr )
                {
                    for ( uIndex = 0L; uIndex < ulArrayLength; uIndex++ )
                    {
                        (*ppNetPrivateConnection)[uIndex] = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;

                    // must release IHNetIcsPrivateConnection instances
                    
                    ppIHNetBridgeList = &pIHNetBridged;
                    
                    for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
                    {
                        ppIHNetBridgeList[uIndex]->Release();
                    }
                
                }   // else

            }   // if ( S_OK == hr )

            // releasing enumeration interface instance

            spEnum = NULL;

        }   // if ( ( hr = pBridge->EnumMembers( &spEnum ) ) == S_OK )

    }   // if ( S_OK == hr )    

    if ( S_OK == hr )
    {
        ppIHNetBridgeList = &pIHNetBridged;

        for ( uIndex = 0L; uIndex < ulListLength; uIndex++ )
        {
            if ( uIndex < ulArrayLength - 1 )
            {
                CComPtr<IHNetConnection> spIHNetPrivate;

                hr = ppIHNetBridgeList[uIndex]->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNetPrivate ) );
                _ASSERT( SUCCEEDED(hr) );

                if ( SUCCEEDED(hr) )
                {
                    // We allow the caller to invoke Release for (*ppNetPrivateConnection)[uIndex]

                    hr = spIHNetPrivate->GetINetConnection( &((*ppNetPrivateConnection)[uIndex]) );
                    _ASSERT( SUCCEEDED(hr) );
                }
                
            }   // if ( uIndex < uiArrayLength - 1 )

            ppIHNetBridgeList[uIndex]->Release();

        }   // for ( uIndex = 0L; ...

    }   // if ( S_OK == hr )
            
    TRACE_LEAVE("GetBridgedConnections", hr);

    return hr;
}



HRESULT
SetIcsPublicConnection(
    IN CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    IN INetConnection      *pNetPublicConnection,
    IN BOOLEAN              bSharePublicConnection,
    IN BOOLEAN              bFirewallPublicConnection,
    IN  LPHNWCALLBACK       lpHnwCallback,
    IN  LPARAM              lpContext
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;

    TRACE_ENTER("SetIcsPublicConnection");

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != pNetPublicConnection );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == pNetPublicConnection )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        INetConnectionRefresh* pNetConnectionRefresh;

        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
        if( SUCCEEDED(hr) )
        {
            _ASSERT( pNetConnectionRefresh );

            pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

            OLECHAR *strAdapter = L"Adapter";
            OLECHAR *strName    = strAdapter;

            CComPtr<IHNetConnection> spHNetConnection;

            hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( pNetPublicConnection, 
                                                &spHNetConnection );
            if ( S_OK == hr )
            {
                if ( HRGetConnectionAdapterName( pNetPublicConnection, &strName ) != S_OK )
                {
                    strName = strAdapter;
                }

                if ( bSharePublicConnection )
                {
                    CComPtr<IHNetIcsPublicConnection> spIcsPublicConn;

                    hr = spHNetConnection->SharePublic( &spIcsPublicConn );

                    if ( SUCCEEDED(hr) )
                    {
                        // Instantiating the IHNetIcsPublicConnection pointer with
                        // SharePublic results in updating our WMI store with 
                        // the new sharing properties for this connection.  This
                        // is our only goal at this time.

                        //
                        // set the power scheme!
                        //

                        if (!SetActivePwrScheme(3, NULL, NULL)) {
                            debugprintf( _T("Unable to set power scheme to always on\n"), strName);
                        }

                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPUBLICCONNECTIONCREATED, strName );

                        spIcsPublicConn.Release();

                        debugprintf( _T("\t"), strName );
                    }
                    else
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPUBLICCONNECTIONFAILED, strName );
                    }
                    
                }   //  if ( bSharePublicConnection )

                if ( SUCCEEDED(hr) && bFirewallPublicConnection )
                {
                    CComPtr<IHNetFirewalledConnection> spFirewalledConn;

                    hr = spHNetConnection->Firewall( &spFirewalledConn );

                    if ( SUCCEEDED(hr) )
                    {
                        // Instantiating the IHNetFirewalledConnection pointer with
                        // SharePublic results in updating our WMI store with 
                        // the new firewall properties for this connection.  This
                        // is our only goal at this time.

                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_FIREWALLCONNECTION, strName );

                        spFirewalledConn.Release();
                    }
                    else
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_FIREWALLCONNECTIONFAILED, strName );
                    }
                    
                }   //  if ( SUCCEEDED(hr) && bFirewallPublicConnection )

            }   // if ( S_OK == hr )
            else
            {
                UpdateHnwLog( lpHnwCallback, lpContext, IDS_SHARINGCFGFORADAPTERUNAVAIL, strName );
            }

            if ( strName != strAdapter )
            {
                delete strName;
            }

            pNetConnectionRefresh->DisableEvents( FALSE, 0L );
            pNetConnectionRefresh->Release();

        }    //    if( SUCCEEDED(hr) )

    }   // else

    TRACE_LEAVE("SetIcsPublicConnection", hr);

    return hr;
}



HRESULT WaitForConnectionToInitialize( 
    IN CComPtr<IHNetConnection> spIHNC,
    IN ULONG                    ulSeconds,
    IN BOOLEAN                  bIsBridge
    )
{
    HRESULT         hr;
    GUID           *pGuid;
    UNICODE_STRING  UnicodeString;

    TRACE_ENTER("WaitForConnectionToInitialize");

    ZeroMemory( &UnicodeString, sizeof(UnicodeString) );

    hr = spIHNC->GetGuid( &pGuid );
    
    if ( SUCCEEDED(hr) )
    {
        NTSTATUS Status = RtlStringFromGUID( *pGuid, &UnicodeString );
        
        hr = ( STATUS_SUCCESS == Status ) ? S_OK : E_FAIL;
        
        CoTaskMemFree( pGuid );
    }

    pGuid = NULL;

#ifdef WAIT_FOR_MEDIA_STATUS_CONNECTED

    if ( SUCCEEDED(hr) && bIsBridge )
    {
        // Query the state of the connection.  Try to wait for the 
        // bridge to build the spanning tree and report media state connected.

        LPWSTR  pwsz;

        // Build a buffer large enough for the device string

        pwsz = new WCHAR[ sizeof(c_wszDevice)/sizeof(WCHAR) + UnicodeString.Length/sizeof(WCHAR) + 1 ];

        if ( NULL != pwsz )
        {
            UNICODE_STRING  DeviceString;
            NIC_STATISTICS  NdisStatistics;
            ULONG           ulTimeout;

            swprintf( pwsz, L"%s%s", c_wszDevice, UnicodeString.Buffer );

            ulTimeout = SECONDS_TO_WAIT_FOR_BRIDGE;
            RtlInitUnicodeString( &DeviceString, pwsz );

            do
            {
                ZeroMemory( &NdisStatistics, sizeof(NdisStatistics) );
                NdisStatistics.Size = sizeof(NdisStatistics);
                NdisQueryStatistics( &DeviceString, &NdisStatistics );
        
                if ( NdisStatistics.MediaState == MEDIA_STATE_UNKNOWN )
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_HOST_ADDRESS_CONFLICT);
                } 
                else if ( NdisStatistics.DeviceState != DEVICE_STATE_CONNECTED ||
                          NdisStatistics.MediaState != MEDIA_STATE_CONNECTED )
                {
                    hr = HRESULT_FROM_WIN32(ERROR_SHARING_NO_PRIVATE_LAN);
                }
                else
                {
                    // AHA! Bridge initialized!

                    hr = S_OK;
                    break;
                }

                debugretprintf( pwsz, hr );

                Sleep( 1000 );
            }
            while ( ulTimeout-- );

            delete [] pwsz;
    
        }   //  if ( NULL != pwsz )

    }   //  if ( SUCCEEDED(hr) && bIsBridge )

#endif

    
    if ( SUCCEEDED(hr) )
    {
        DWORD  dwResult;
        DWORD  dwVersion;                           // version of the DHCP Client Options API reported

        hr       = HRESULT_FROM_WIN32(ERROR_SHARING_NO_PRIVATE_LAN);
        dwResult = DhcpCApiInitialize( &dwVersion );

        if ( ERROR_SUCCESS == dwResult )
        {
            DHCPCAPI_PARAMS       requests[1]  = { {0, OPTION_SUBNET_MASK, FALSE, NULL, 0} };   // subnet mask
            DHCPCAPI_PARAMS_ARRAY sendarray    = { 0, NULL };           // we aren't sending anything
            DHCPCAPI_PARAMS_ARRAY requestarray = { 1, requests };       // we are requesting 2 items

            while ( --ulSeconds )
            {
                DWORD   dwSize = INITIAL_BUFFER_SIZE;                       // size of buffer for options
                LPBYTE  buffer = NULL;                                      // buffer for options  
                IN_ADDR addr;                                               // address in return code

                do
                {
                    if ( NULL != buffer )
                    {
                        LocalFree( buffer );
                    }

                    buffer = (LPBYTE) LocalAlloc( LPTR, dwSize );               // allocate the buffer

                    if ( NULL == buffer )
                    {
                        break;
                    }

                    // make the request on the adapter

                    dwResult = DhcpRequestParams( DHCPCAPI_REQUEST_SYNCHRONOUS, 
                                                  NULL, 
                                                  UnicodeString.Buffer,
                                                  NULL, 
                                                  sendarray, 
                                                  requestarray, 
                                                  buffer, 
                                                  &dwSize, 
                                                  NULL );
                }
                while ( ERROR_MORE_DATA == dwResult );

                if ( NULL != buffer )
                {
                    LocalFree( buffer );
                }

                if ( ERROR_SUCCESS == dwResult )
                {
                    hr = S_OK;
                    break;
                }

                // wait for dhcp to pick up connection

                debugretprintf( UnicodeString.Buffer, hr );

                Sleep( 1000 );

            }   //  while ( --ulSeconds )

            DhcpCApiCleanup();

        }   //  if ( 0 == dwResult )

    }   //  if ( SUCCEEDED(hr) )
    
   	RtlFreeUnicodeString( &UnicodeString );

    TRACE_LEAVE("WaitForConnectionToInitialize", hr);

    return hr;
}



HRESULT
SetIcsPrivateConnections(
    IN  CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    IN  INetConnection      *pNetPrivateConnection[],
    IN  BOOLEAN              bSharePublicConnection,
    IN  LPHNWCALLBACK        lpHnwCallback,
    IN  LPARAM               lpContext,
    OUT INetConnection     **pNetPrivateInterface
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;

    TRACE_ENTER("SetIcsPrivateConnections");

    CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;
    INetConnectionRefresh*       pNetConnectionRefresh = NULL;

    _ASSERT( spIHNetCfgMgr != NULL );
    _ASSERT( NULL != pNetPrivateConnection );

    if ( spIHNetCfgMgr == NULL )
    {
        hr = E_POINTER;
    }
    else if ( NULL == pNetPrivateConnection )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = spIHNetCfgMgr->QueryInterface( IID_PPV_ARG( IHNetBridgeSettings, &spIHNetBridgeSettings ) );
    }
    
    if ( SUCCEEDED(hr) )
    {
        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
        
        if( SUCCEEDED(hr) )
        {
            _ASSERT( pNetConnectionRefresh );
            pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );
        }
        else
        {
            pNetConnectionRefresh = NULL;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        CComPtr<IHNetConnection> spIHNC;
        INetConnection         **ppNC;
        ULONG                    uIndex;
        BOOLEAN                  bIsBridge;
        INetCfg                 *pnetcfg = NULL;
        INetCfgLock             *pncfglock = NULL;

        ppNC      = pNetPrivateConnection;
        bIsBridge = FALSE;

        for ( uIndex=0L; NULL != *ppNC; ppNC++ )
        {
            _ASSERT( !IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) );

            if ( IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) )
            {
                hr = E_POINTER;
                break;
            }
            else
            {
#if DBG
                LPWSTR  lpzwAdapterName;
                HRESULT hrGetName;
                
                hrGetName = HRGetConnectionAdapterName( *ppNC, &lpzwAdapterName );

                if ( SUCCEEDED( hrGetName ) )
                {
                    debugprintf( _T("\t"), lpzwAdapterName );

                    delete lpzwAdapterName;
                }
#endif
                // We only count this as a valid connection for valid pointers

                uIndex++;
            }

        }   //  if ( SUCCEEDED(hr) )


        if ( SUCCEEDED(hr) )
        {
            HRESULT hrWrite;
        
            hrWrite = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );
        
            if ( 1 < uIndex )
            {
                CComPtr<IHNetBridge> spHNetBridge;

                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetBridgeSettings->CreateBridge( &spHNetBridge, pnetcfg );

                if ( S_OK == hr )
                {
                    ULONG uCount;
                    
                    ppNC = pNetPrivateConnection;
                    
                    for ( uCount=0L; (NULL != *ppNC) && (uCount < uIndex); uCount++, ppNC++ )
                    {
                        pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                        hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( *ppNC, &spIHNC );

                        if ( SUCCEEDED(hr) )
                        {
                            CComPtr<IHNetBridgedConnection> spBridgedConn;

                            hr = spHNetBridge->AddMember( spIHNC, &spBridgedConn, pnetcfg );

                            if ( S_OK == hr )
                            {
                                // Instantiating the IHNetBridgeConnection pointer with
                                // SharePublic results in updating our WMI store with 
                                // the new bridge properties for this connection.  This
                                // is our only goal at this time.

                                spBridgedConn.Release();
                            }
                            else
                            {
                                debugretprintf( _T("AddMember FAILED with "), hr );
                            }

                            // We no longer need this IHNetConnection reference
                            // so we NULL the smart pointer to release it.
                            
                            spIHNC = NULL;
                        }

                    }   // for ( uCount=0L; ...

                    hr = spHNetBridge->QueryInterface( IID_PPV_ARG( IHNetConnection, &spIHNC ) );
                    _ASSERT( SUCCEEDED(hr) );

                    if ( SUCCEEDED(hr) )
                    {
                        bIsBridge = TRUE;

                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWBRIDGECREATED );
                    }
                    else
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWBRIDGEFAILED );
                    }
                
                }   // if ( SUCCEEDED(hr) )
            
            }   // if ( 1 < uIndex )

            else if ( 1 == uIndex )
            {
                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( pNetPrivateConnection[0], &spIHNC );
                _ASSERT( SUCCEEDED(hr) );
            }
            else
            {
                // We don't have ANY private connections so we null out
                // this pointer to make sure we don't try to use it.

                spIHNC = NULL;
            }

            if ( SUCCEEDED(hrWrite) )
            {
                UninitializeNetCfgForWrite( pnetcfg, pncfglock );
            }
            
        }   //  if ( SUCCEEDED(hr) )
        else
        {
            // Some previous error condition occurred and we need to 
            // null out this pointer to make sure we don't try to use it.

            spIHNC = NULL;
        }


        if ( bSharePublicConnection && SUCCEEDED(hr) && ( spIHNC != NULL ) )
        {
            OLECHAR *strAdapter = _T("Adapter");
            OLECHAR *strName    = strAdapter;

            CComPtr<IHNetIcsPrivateConnection> spIcsPrivateConn;

            // Get name of private connection candidate

            if ( spIHNC != NULL )
            {
                if ( S_OK != spIHNC->GetName( &strName )  )
                {
                    strName = strAdapter;
                }
            }

            // Wait for connection to finish initialization and share it
                
            if ( SUCCEEDED(hr) )
            {
                // if we are in ICS Upgrade, don't wait for dhcp
                // service because it won't be running during GUI Mode Setup.
                
                HANDLE hIcsUpgradeEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, c_wszIcsUpgradeEventName );
                
                if ( NULL != hIcsUpgradeEvent )
                {
                    CloseHandle( hIcsUpgradeEvent );
                }
                else
                {
                    // We are running normally with dhcp so we must wait
                    // for dhcp to pick up the new bridge interface
                
                    pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                    hr = WaitForConnectionToInitialize( spIHNC, SECONDS_TO_WAIT_FOR_DHCP, bIsBridge );
                    
                    if ( HRESULT_FROM_WIN32(ERROR_SHARING_NO_PRIVATE_LAN) == hr )
                    {
                    	// If WaitForConnectionToInitialize can't get statistics then try
                        // SharePrivate anyway.
                    
                    	hr = S_OK;
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                    hr = spIHNC->SharePrivate( &spIcsPrivateConn );
                }
            }

            if ( SUCCEEDED(hr) )
            {
                // We are only configuring the connection

                // Instantiating the IHNetIcsPrivateConnection pointer with
                // SharePublic results in updating our WMI store with 
                // the new private connection properties for this connection.  
                
                // Obtain Interface pointer to private connection if requested

                if ( NULL != pNetPrivateInterface )
                {
                    spIHNC->GetINetConnection( pNetPrivateInterface );
                }

                UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPRIVATECONNECTIONCREATED, strName );

                spIcsPrivateConn.Release();

                debugprintf( _T("SharePrivate: "), strName );
            }
            else
            {
                UpdateHnwLog( lpHnwCallback, lpContext, IDS_NEWPRIVATECONNECTIONFAILED, strName );

                debugretprintf( _T("SharePrivate FAILED with "), hr );
            }

            if ( strName != strAdapter )
            {
                CoTaskMemFree( strName );
            }

        }   // if ( SUCCEEDED(hr) && ( spIHNC != NULL ) )

        // We no longer need this IHNetConnection reference so we NULL the smart
        // pointer to release it.  If the smart pointer is all ready NULL then
        // no release or AV will occur.  We do this here because the smart pointer 
        // may be valid even though we did not enter the preceeding block.

        spIHNC = NULL;

    }   // if ( SUCCEEDED(hr) )


    if ( pNetConnectionRefresh )
    {
        pNetConnectionRefresh->DisableEvents( FALSE, 0L );
        pNetConnectionRefresh->Release();
    }

    TRACE_LEAVE("SetIcsPrivateConnections", hr);

    return hr;
}



HRESULT
DisableEverything(
    IN CComPtr<IHNetCfgMgr> spIHNetCfgMgr,
    IN  INetConnection     *pNetPublicConnection,
    IN  INetConnection     *pNetPrivateConnection[],
    IN  LPHNWCALLBACK       lpHnwCallback,
    IN  LPARAM              lpContext
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT                hr;
    INetConnectionRefresh* pNetConnectionRefresh;

    TRACE_ENTER("DisableEverything");

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
    
    if( SUCCEEDED(hr) )
    {
        ULONG ulConnections;

        pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

        if ( pNetPublicConnection )
        {
            IHNetConnection* pHNetPublicConnection;

            hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( pNetPublicConnection, 
            &pHNetPublicConnection );
            if ( S_OK == hr )
            {
                IHNetFirewalledConnection* pPublicConnectionFirewall;

                hr = pHNetPublicConnection->GetControlInterface( IID_IHNetFirewalledConnection,
                                                                 (void**)&pPublicConnectionFirewall );
                if ( SUCCEEDED(hr) )
                {
                    hr = pPublicConnectionFirewall->Unfirewall();
                    pPublicConnectionFirewall->Release();
                    pPublicConnectionFirewall = NULL;

                    if ( FAILED(hr) ) 
                    {
                        UpdateHnwLog( lpHnwCallback, lpContext, IDS_DISABLEFIREWALLFAIL, hr );
                    }
                }

                pHNetPublicConnection->Release();
                pHNetPublicConnection = NULL;
            }
        }

        if ( pNetPrivateConnection && pNetPrivateConnection[0] )
        {
            INetConnection** ppNC = pNetPrivateConnection;
            
            while ( *ppNC )
            {
                IHNetConnection* pHNetPrivateConnection;

                _ASSERT( !IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) );

                if ( IsBadReadPtr( *ppNC, sizeof( *ppNC ) ) )
                {
                    hr = E_POINTER;
                    break;
                }

                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( *ppNC, 
                                                                         &pHNetPrivateConnection );
                if ( S_OK == hr )
                {
                    IHNetFirewalledConnection* pPrivateConnectionFirewall;
                
                    hr = pHNetPrivateConnection->GetControlInterface( IID_IHNetFirewalledConnection,
                                                                     (void**)&pPrivateConnectionFirewall );
                    if ( SUCCEEDED(hr) )
                    {
                        pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                        hr = pPrivateConnectionFirewall->Unfirewall();
                        pPrivateConnectionFirewall->Release();
                        pPrivateConnectionFirewall = NULL;

                        if ( FAILED(hr) ) 
                        {
                            UpdateHnwLog( lpHnwCallback, lpContext, IDS_DISABLEFIREWALLFAIL, hr );
                        }
                    }
                
                    pHNetPrivateConnection->Release();
                    pHNetPrivateConnection = NULL;
                    
                }    //    if ( S_OK == hr )
            
                ppNC++;
                
            }    // while ( ppNC )
            
        }    //    if ( pNetPrivateConnection && pNetPrivateConnection[0] )

        {
            CComQIPtr<IHNetBridgeSettings> spIHNetBridge = spIHNetCfgMgr;

            if ( spIHNetBridge != NULL )
            {
                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetBridge->DestroyAllBridges( &ulConnections );

                if ( FAILED(hr) ) 
                {
                    UpdateHnwLog( lpHnwCallback, lpContext, IDS_DESTROYBRIDGEFAIL, hr );
                }
            }
        }

        {
            CComQIPtr<IHNetIcsSettings> spIHNetIcs = spIHNetCfgMgr;

            if ( spIHNetIcs != NULL )
            {
                ULONG ulPrivateConnections;

                pNetConnectionRefresh->DisableEvents( TRUE, MAX_DISABLE_EVENT_TIMEOUT );

                hr = spIHNetIcs->DisableIcs( &ulConnections, &ulPrivateConnections );

                if ( FAILED(hr) ) 
                {
                    UpdateHnwLog( lpHnwCallback, lpContext, IDS_DISABLEICS, hr );
                }
            }
        }

        pNetConnectionRefresh->DisableEvents( FALSE, 0L );
        pNetConnectionRefresh->Release();
    }

    TRACE_LEAVE("DisableEverything", hr);

    return hr;
}



extern
HRESULT APIENTRY
HNetSetShareAndBridgeSettings(
    IN  INetConnection          *pNetPublicConnection,
    IN  INetConnection          *pNetPrivateConnection[],
    IN  BOOLEAN                  bSharePublicConnection,
    IN  BOOLEAN                  bFirewallPublicConnection,
    IN  LPHNWCALLBACK            lpHnwCallback,
    IN  LPARAM                   lpContext,
    OUT INetConnection         **pNetPrivateInterface
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    TRACE_ENTER("HNetSetShareAndBridgeSettings");

    HRESULT hr;

    // Initialize returned interface pointer if necessary

    if ( NULL != pNetPrivateInterface )
    {
        *pNetPrivateInterface = NULL;
    }

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.

    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    hr = spIHNetCfgMgr.CoCreateInstance( CLSID_HNetCfgMgr );

    if ( SUCCEEDED(hr) )
    {
        DisableEverything( spIHNetCfgMgr, 
                           pNetPublicConnection, 
                           pNetPrivateConnection, 
                           lpHnwCallback, 
                           lpContext );

        if ( NULL != pNetPublicConnection )
        {
            hr = SetIcsPublicConnection( spIHNetCfgMgr, 
                                         pNetPublicConnection, 
                                         bSharePublicConnection, 
                                         bFirewallPublicConnection,
                                         lpHnwCallback,
                                         lpContext );
        }

        if ( ( NULL != pNetPrivateConnection ) && ( NULL != pNetPrivateConnection[0] ) && SUCCEEDED(hr) )
        {
            hr = SetIcsPrivateConnections( spIHNetCfgMgr, 
                                           pNetPrivateConnection, 
                                           bSharePublicConnection,
                                           lpHnwCallback,
                                           lpContext,
                                           pNetPrivateInterface );
        }

        if ( FAILED(hr) )
        {
            DisableEverything( spIHNetCfgMgr, 
                               pNetPublicConnection, 
                               pNetPrivateConnection, 
                               lpHnwCallback, 
                               lpContext );
        }
    }
    else
    {
        UpdateHnwLog( lpHnwCallback, lpContext, IDS_SHARINGCONFIGURATIONUNAVAIL );
    }

    TRACE_LEAVE("HNetSetShareAndBridgeSettings", hr);

    return hr;
}



extern
HRESULT APIENTRY
HNetGetShareAndBridgeSettings(
    OUT INetConnection  **ppNetPublicConnection,
    OUT INetConnection ***ppNetPrivateConnection,
    OUT BOOLEAN          *pbSharePublicConnection,
    OUT BOOLEAN          *pbFirewallPublicConnection
    )

/*++

Routine Description:



Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr;

    TRACE_ENTER("HNetGetShareAndBridgeSettings");

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.

    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    *ppNetPublicConnection      = NULL;
    *ppNetPrivateConnection     = NULL;
    *pbSharePublicConnection    = FALSE;
    *pbFirewallPublicConnection = FALSE;

    hr = spIHNetCfgMgr.CoCreateInstance( CLSID_HNetCfgMgr );

    if ( SUCCEEDED(hr) )
    {
        if ( NULL != ppNetPublicConnection )
        {
            hr = GetIcsPublicConnection( spIHNetCfgMgr,
                                         ppNetPublicConnection,
                                         pbSharePublicConnection,
                                         pbFirewallPublicConnection );
        }

        if ( NULL != ppNetPrivateConnection )
        {
            hr = GetIcsPrivateConnections( spIHNetCfgMgr, ppNetPrivateConnection );

            if ( S_OK == hr )
            {
                CComPtr<IHNetConnection>   spIHNetConnection;
                INetConnection           **ppINetCon;

                // Check first private connection to see if it is the bridge
                
                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( (*ppNetPrivateConnection)[0], 
                                                                         &spIHNetConnection );
                _ASSERT( SUCCEEDED(hr) );

                if ( SUCCEEDED(hr) )
                {
                    HNET_CONN_PROPERTIES *phncProperties;

                    hr = spIHNetConnection->GetProperties( &phncProperties );

                    if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )
                    {
                        if ( phncProperties->fBridge )
                        {
                            // If Bridge, then release the private connection instances
                            // and get the list of bridged connections

                            for ( ppINetCon = *ppNetPrivateConnection; NULL != *ppINetCon; ppINetCon++ )
                            {
                                (*ppINetCon)->Release();
                                *ppINetCon = NULL;
                            }

                            NetApiBufferFree( *ppNetPrivateConnection );

                            *ppNetPrivateConnection = NULL;

                            hr = GetBridgedConnections( spIHNetCfgMgr, ppNetPrivateConnection );

                        }   // if ( phncProperties->fBridge )

                        CoTaskMemFree( phncProperties );

                    }   // if ( SUCCEEDED(hr) && ( NULL != phncProperties ) )

                }   // if ( SUCCEEDED(hr)

                // What if we fail along this path?  Then we need to release
                // any private connection interface pointer held.

                if ( FAILED(hr) && ( NULL != ppNetPrivateConnection ) )
                {
                    for ( ppINetCon = *ppNetPrivateConnection; NULL != *ppINetCon; ppINetCon++ )
                    {
                        (*ppINetCon)->Release();
                    }

                    NetApiBufferFree( *ppNetPrivateConnection );

                    *ppNetPrivateConnection = NULL;
                }

            }   // if ( S_OK == hr )
        
        }   // if ( NULL != ppNetPrivateConnection )

        // If we fail along the way then we need to release the public interface
        // and NULL the pointer so that it won't be used.

        if ( FAILED(hr) && ( NULL != ppNetPublicConnection ) )
        {
            (*ppNetPublicConnection)->Release();

            *ppNetPublicConnection = NULL;
        }

    }   // if ( SUCCEEDED(hr) )
    
    TRACE_LEAVE("HNetGetShareAndBridgeSettings", hr);

    return hr;
}


HRESULT DisablePersonalFirewallOnAll()
/*++

Routine Description:

    Disable firewall on all connections

Arguments:


Return Value:

    hResult

--*/

{
    HRESULT hr = S_OK;
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;
    
    TRACE_ENTER("DisablePersonalFirewallOnAll");
    
    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
        NULL, 
        CLSCTX_ALL,
        IID_PPV_ARG(IHNetCfgMgr, &spIHNetCfgMgr));

    if (SUCCEEDED(hr))
    {
        CComQIPtr<IHNetFirewallSettings> spIHNetFirewall = spIHNetCfgMgr;
        
        if ( NULL != spIHNetFirewall.p )
        {
            ULONG   ulConnections = 0;
            hr = spIHNetFirewall->DisableAllFirewalling( &ulConnections );
        }
        else
        {
            hr = E_FAIL;
        }
    }
    

    TRACE_LEAVE("DisablePersonalFirewallOnAll", hr);
    
    return hr;
        
}

HRESULT EnablePersonalFirewallOnAll()
/*++

Routine Description:
    Enable firewall on all connections that can be firewalled


Arguments:


Return Value:

    hResult

--*/

{
    HRESULT         hr      = S_OK;
    HRESULT         hrTemp  = S_OK;
    ULONG           ulCount = 0;

    CComPtr<IEnumNetConnection> spEnum; 
    
    // Get the net connection manager
    CComPtr<INetConnectionManager> spConnMan;
    CComPtr<INetConnection> spConn;

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    TRACE_ENTER("EnablePersonalFirewallOnAll");

    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
        NULL, 
        CLSCTX_ALL,
        IID_PPV_ARG(IHNetCfgMgr, &spIHNetCfgMgr));
    
    if (FAILED(hr))
    {
        goto End;
    }
    
    //disable any previous firewall settings otherwise enabling
    //firewall on the same connection twice will return errors
    //We will continue do the enable firewall if this step fails    
    DisablePersonalFirewallOnAll();

    hr = CoCreateInstance(CLSID_ConnectionManager, 
                        NULL,
                        CLSCTX_ALL,
                        IID_PPV_ARG(INetConnectionManager, &spConnMan));

    if (FAILED(hr))
    {
        goto End;
    }

    
    // Get the enumeration of connections
    SetProxyBlanket(spConnMan);
    
    hr = spConnMan->EnumConnections(NCME_DEFAULT, &spEnum);
    if (FAILED(hr))
    {
        goto End;
    }

    SetProxyBlanket(spEnum);
    
    
    hr = spEnum->Reset();
    if (FAILED(hr))
    {
        goto End;
    } 
    
    do
    {
        NETCON_PROPERTIES* pProps = NULL;
        
        //release any previous ref count we hold
        spConn = NULL;

        hr = spEnum->Next(1, &spConn, &ulCount);
        if (FAILED(hr) || 1 != ulCount)
        {
            break;
        }

        SetProxyBlanket(spConn);
        
        hr = spConn->GetProperties(&pProps);
        if (FAILED(hr) || NULL == pProps)
        {
            continue;
        }

        //ICF is available only for certain types of connections
        if (NCM_PHONE == pProps->MediaType ||
            NCM_ISDN == pProps->MediaType  ||
            NCM_PPPOE == pProps->MediaType ||
            NCM_LAN == pProps->MediaType ||
            NCM_TUNNEL == pProps->MediaType )
        {
            CComPtr<IHNetConnection> spHNetConnection;
            //release the ref count if we are holding one
            spHNetConnection = NULL;
            hrTemp = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( 
                spConn, 
                &spHNetConnection );
            
            if (SUCCEEDED(hr))
            {
                hr = hrTemp;
            }
    
            if (SUCCEEDED(hrTemp))
            {
                //check whether the connect can be firewalled
                HNET_CONN_PROPERTIES *phncProperties = NULL;
                
                hrTemp = spHNetConnection->GetProperties( &phncProperties );
                if (SUCCEEDED(hrTemp) && NULL != phncProperties)
                {
                    if (phncProperties->fCanBeFirewalled)
                    {
                        CComPtr<IHNetFirewalledConnection> spFirewalledConn;
                        
                        //turn on the firewall
                        hrTemp = spHNetConnection->Firewall( &spFirewalledConn );
                    }
                    CoTaskMemFree(phncProperties);
                }

                if (SUCCEEDED(hr))
                {
                    hr = hrTemp;
                }
            }
        }   
        NcFreeNetconProperties(pProps);
        
    } while (SUCCEEDED(hr) && 1 == ulCount);

End:
    TRACE_LEAVE("EnablePersonalFirewallOnAll", hr);
    
    //normalize hr because we used IEnum
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }
    return hr;
}

extern "C"
BOOL 
WINAPI
WinBomConfigureHomeNet(
                LPCTSTR lpszUnattend, 
                LPCTSTR lpszSection
                )
/*++

Routine Description:
        Reads home networking settings from the specified unattend file and saves 
        those in current system that is already setup and running.



Arguments:
        lpszUnattend [IN] Points to a string buffer which contains the full path 
                          to the unattend file (winbom.ini in this case) with all 
                          the home network settings.
        
        lpszSection  [IN] Points to a string buffer which contains the name of 
                          the section which contains all the home network settings 
                          in the unattend file specified above.


Return Value:
        Returns TRUE if the settings were successfully read and saved to the system.  
        Otherwise returns FALSE to indicate something failed.

--*/

{
    if (NULL == lpszSection || NULL == lpszUnattend)
        return FALSE;

    BOOL fRet = TRUE;
    WCHAR szBuf[256] = {0};
    DWORD dwRet = 0;
    dwRet = GetPrivateProfileString(lpszSection,
                        c_szEnableFirewall,
                        _T(""),
                        szBuf,
                        sizeof(szBuf)/sizeof(szBuf[0]),
                        lpszUnattend);

    if (dwRet) 
    {
        if (0 == lstrcmpi(szBuf, c_szYes))
        {
            fRet = SUCCEEDED(EnablePersonalFirewallOnAll());
        }
        else if (0 == lstrcmpi(szBuf, c_szNo))
        {
            fRet = SUCCEEDED(DisablePersonalFirewallOnAll());
        }
    }
    else
    {
        //if there is no EnableFirewall there, we should treat this
        //as a success
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hnapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I . C P P
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <winsock2.h>

void __cdecl hnet_oem_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp )
{
   throw HNet_Oem_SEH_Exception( uSECode );
}
void EnableOEMExceptionHandling()
{
   _set_se_translator (hnet_oem_trans_func);
}
void DisableOEMExceptionHandling()
{
   _set_se_translator(NULL);
}

HRESULT
InternalGetSharingEnabled( 
    IHNetConnection*       pHNetConnection,
    BOOLEAN*               pbEnabled,
    SHARINGCONNECTIONTYPE* pType
    )
/*++

  InternalGetSharingEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HRESULT               hr;
    HNET_CONN_PROPERTIES* pProps;

    if ( NULL == pHNetConnection )
    {
        hr = E_INVALIDARG;
    }
    else if ( ( NULL == pbEnabled ) || ( NULL == pType ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;
        *pType     = ICSSHARINGTYPE_PUBLIC;

        hr = pHNetConnection->GetProperties( &pProps );

        if ( SUCCEEDED(hr) )
        {
            if ( pProps->fIcsPublic )
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PUBLIC;
            }
            else if ( pProps->fIcsPrivate )
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PRIVATE;
            }

            CoTaskMemFree( pProps );
        }
    }

    return hr;
}


HRESULT
InternalIsShareTypeEnabled( 
    SHARINGCONNECTIONTYPE Type,
    BOOLEAN*              pbEnabled
    )
/*++

  InternalGetShareTypeEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HRESULT hr;

    if ( NULL == pbEnabled )
    {
        hr = E_POINTER;
    }
    else 
    {
        IHNetIcsSettings* pIcsSettings;

        *pbEnabled = FALSE;

        hr = _ObtainIcsSettingsObj( &pIcsSettings );
        
        if ( SUCCEEDED(hr) )
        {
            switch( Type )
            {
            case  ICSSHARINGTYPE_PUBLIC:
                {
                    IEnumHNetIcsPublicConnections* pHNetEnumPub;

                       hr = pIcsSettings->EnumIcsPublicConnections( &pHNetEnumPub );

                    if ( SUCCEEDED(hr) )
                    {
                        IHNetIcsPublicConnection *pIHNetIcsPublic;

                        if ( pHNetEnumPub->Next( 1, &pIHNetIcsPublic, NULL ) == S_OK )
                        {
                            *pbEnabled = TRUE;

                            ReleaseObj( pIHNetIcsPublic );
                        }

                        ReleaseObj( pHNetEnumPub );
                    }
                }
                break;
    
            case ICSSHARINGTYPE_PRIVATE:
                {
                    IEnumHNetIcsPrivateConnections* pHNetEnumPrv;

                    hr = pIcsSettings->EnumIcsPrivateConnections( &pHNetEnumPrv );

                    if ( SUCCEEDED(hr) )
                    {
                        IHNetIcsPrivateConnection *pIHNetIcsPrivate;
                    
                        if ( pHNetEnumPrv->Next( 1, &pIHNetIcsPrivate, NULL ) == S_OK )
                        {
                            *pbEnabled = TRUE;

                            ReleaseObj( pIHNetIcsPrivate );
                        }

                        ReleaseObj( pHNetEnumPrv );
                    }
                }
                break;
            
            default:
                 hr = E_UNEXPECTED;
                break;

            }    //    switch( Type )
            
            ReleaseObj( pIcsSettings );

        }    //    if ( SUCCEEDED(hr) )

    }    //    if ( NULL == pbEnabled )

    return hr;
}


STDMETHODIMP
CNetSharingConfiguration::GetSharingEnabled(
    BOOLEAN*               pbEnabled,
    SHARINGCONNECTIONTYPE* pType )
/*++

  CNetSharingConfiguration::GetSharingEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT hr = S_OK;

    if ( ( NULL == pbEnabled ) || ( NULL == pType ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;
        *pType     = ICSSHARINGTYPE_PUBLIC;

        BOOLEAN bBridged = FALSE;

        hr = InternalGetSharingEnabled( m_pHNetConnection, pbEnabled, pType );
    }

    return hr;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP CNetSharingConfiguration::get_SharingEnabled (VARIANT_BOOL* pbEnabled)
{
    HNET_OEM_API_ENTER

    SHARINGCONNECTIONTYPE Type;
    BOOLEAN bEnabled = FALSE;
    HRESULT hr = GetSharingEnabled (&bEnabled, &Type);
    if (SUCCEEDED(hr))
        *pbEnabled = bEnabled ? VARIANT_TRUE : VARIANT_FALSE;
    return hr;

    HNET_OEM_API_LEAVE
}
STDMETHODIMP CNetSharingConfiguration::get_SharingConnectionType(SHARINGCONNECTIONTYPE* pType)
{
    HNET_OEM_API_ENTER

    BOOLEAN bEnabled;
    return GetSharingEnabled (&bEnabled, pType);

    HNET_OEM_API_LEAVE
}

STDMETHODIMP
CNetSharingConfiguration::DisableSharing()
/*++

  CNetSharingConfiguration::DisableSharing

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        SHARINGCONNECTIONTYPE Type;
        
        hr = InternalGetSharingEnabled( m_pHNetConnection, &bEnabled, &Type );
        
        if ( SUCCEEDED(hr) && bEnabled ) 
        {
            switch( Type )
            {
            case ICSSHARINGTYPE_PUBLIC:
                {
                    IHNetIcsPublicConnection* pPublicConnection;

                    hr = m_pHNetConnection->GetControlInterface( 
                                __uuidof(IHNetIcsPublicConnection), 
                                reinterpret_cast<void**>(&pPublicConnection) );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pPublicConnection->Unshare();

                        ReleaseObj(pPublicConnection);
                    }
                }
                break;

            case ICSSHARINGTYPE_PRIVATE:
                {
                    IHNetIcsPrivateConnection* pPrivateConnection;

                    hr = m_pHNetConnection->GetControlInterface( 
                                __uuidof(IHNetIcsPrivateConnection), 
                                reinterpret_cast<void**>(&pPrivateConnection) );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pPrivateConnection->RemoveFromIcs();

                        ReleaseObj(pPrivateConnection);
                    }
                }
                break;

            default:
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::EnableSharing(
    SHARINGCONNECTIONTYPE  Type 
    )
/*++

  CNetSharingConfiguration::EnableSharing

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        SHARINGCONNECTIONTYPE existingType;

        hr = InternalGetSharingEnabled( m_pHNetConnection, &bEnabled, &existingType );

        // If all ready sharing the connection at the specified type then
        // return hresult.
        
        if ( SUCCEEDED(hr) && ( !bEnabled || (existingType != Type) ) )
        {
            BOOLEAN bTypeEnabled = FALSE;

            hr = InternalIsShareTypeEnabled( Type, &bTypeEnabled );

            // If we have another adapter all ready shared at the specified type
            // then return error

            if ( SUCCEEDED(hr) && bTypeEnabled )
            {
                hr = E_ANOTHERADAPTERSHARED;
            }
            else
            {
                if ( bEnabled )
                {
                    DisableSharing();
                }

                switch( Type )
                {
                case ICSSHARINGTYPE_PUBLIC:
                    {
                        IHNetIcsPublicConnection* pPublicConnection;

                        hr = m_pHNetConnection->SharePublic( &pPublicConnection );

                        if ( SUCCEEDED(hr) )
                        {
                            ReleaseObj( pPublicConnection );
                        }
                    }
                    break;

                case ICSSHARINGTYPE_PRIVATE:
                    {
                        IHNetIcsPrivateConnection* pPrivateConnection;

                        hr = m_pHNetConnection->SharePrivate( &pPrivateConnection );

                        if ( SUCCEEDED(hr) )
                        {
                            ReleaseObj(pPrivateConnection);
                        }
                    }
                    break;

                default:
                    hr = E_UNEXPECTED;

                }    //    switch( Type )

            }    //    if ( SUCCEEDED(hr) && !bEnabled )

        }    //    if ( SUCCEEDED(hr) && ( !bEnabled || (existingType != Type) )

    }    //    if ( !IsNotifyApproved() )

    return hr;

    HNET_OEM_API_LEAVE
}


HRESULT
InternalGetFirewallEnabled( 
    IHNetConnection*       pHNetConnection,
    BOOLEAN*               pbEnabled
    )
/*++

  InternalGetFirewallEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HRESULT               hr;
    HNET_CONN_PROPERTIES* pProps;

    if ( NULL == pHNetConnection )
    {
        hr = E_INVALIDARG;
    }
    else if ( NULL == pbEnabled )
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;

        hr = pHNetConnection->GetProperties( &pProps );

        if ( SUCCEEDED(hr) )
        {
            if ( pProps->fFirewalled )
            {
                *pbEnabled = TRUE;
            }

            CoTaskMemFree( pProps );
        }
    }

    return hr;
}


STDMETHODIMP
CNetSharingConfiguration::get_InternetFirewallEnabled(
    VARIANT_BOOL *pbEnabled )
/*++

  CNetSharingConfiguration::GetInternetFirewallEnabled

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT hr = S_OK;

    if ( NULL == pbEnabled )
    {
        hr = E_POINTER;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;
        hr = InternalGetFirewallEnabled( m_pHNetConnection, &bEnabled );
        *pbEnabled = bEnabled ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::DisableInternetFirewall()
/*++

  CNetSharingConfiguration::DisableInternetFirewall

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        hr = InternalGetFirewallEnabled( m_pHNetConnection, &bEnabled );
        
        if ( SUCCEEDED(hr) && bEnabled ) 
        {
            IHNetFirewalledConnection* pFirewallConnection;

            hr = m_pHNetConnection->GetControlInterface( 
                        __uuidof(IHNetFirewalledConnection), 
                        reinterpret_cast<void**>(&pFirewallConnection) );

            if ( SUCCEEDED(hr) )
            {
                hr = pFirewallConnection->Unfirewall();

                ReleaseObj(pFirewallConnection);
            }
        }
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingConfiguration::EnableInternetFirewall()
/*++

  CNetSharingConfiguration::EnableInternetFirewall

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT    hr;

    if ( !IsNotifyApproved() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BOOLEAN bEnabled = FALSE;

        hr = InternalGetFirewallEnabled( m_pHNetConnection, &bEnabled );
        
        if ( SUCCEEDED(hr) && !bEnabled ) 
        {
            IHNetFirewalledConnection* pFirewalledConnection;

            hr = m_pHNetConnection->Firewall( &pFirewalledConnection );

            if ( SUCCEEDED(hr) )
            {
                ReleaseObj( pFirewalledConnection );
            }
        }
    }

    return hr;

    HNET_OEM_API_LEAVE
}

STDMETHODIMP
CNetSharingConfiguration::AddPortMapping(
    OLECHAR*                 pszwName,
    UCHAR                    ucIPProtocol,
    USHORT                   usExternalPort,
    USHORT                   usInternalPort,
    DWORD                     dwOptions,
    OLECHAR*                 pszwTargetNameOrIPAddress,
    ICS_TARGETTYPE           eTargetType,
    INetSharingPortMapping** ppMapping )
/*++

  CNetSharingConfiguration::AddPortMapping

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    OLECHAR* pszwTargetName      = NULL;
    OLECHAR* pszwTargetIPAddress = NULL;
    if      (eTargetType == ICSTT_NAME)         pszwTargetName      = pszwTargetNameOrIPAddress;
    else if (eTargetType == ICSTT_IPADDRESS)    pszwTargetIPAddress = pszwTargetNameOrIPAddress;
    else
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if ( NULL == ppMapping )
    {
        hr = E_POINTER;
    }
    else if ( ( NULL == pszwName ) ||
              ( 0 == ucIPProtocol ) ||
              ( 0 == usInternalPort) || // should I allow this, implying internal == external?
              ( 0 == usExternalPort ) )
    {
        hr = E_INVALIDARG;
    }
    else if ( ( NULL == pszwTargetName ) &&
              ( NULL == pszwTargetIPAddress ) )
    {
        hr = E_INVALIDARG;
    }
    else if ( !IsSecureContext() )
    {
        hr = E_ACCESSDENIED;
    }
    else if ( NULL == m_pSettings )
    {
        hr = E_UNEXPECTED;
    }

    if ( SUCCEEDED(hr) )
    {
        *ppMapping = NULL;

        CComObject<CNetSharingPortMapping>* pNewMap;

        hr = CComObject<CNetSharingPortMapping>::CreateInstance( &pNewMap );

        if ( SUCCEEDED(hr) )
        {
            pNewMap->AddRef();

            IHNetPortMappingProtocol* pNewProtocol = NULL;

            // first, find existing IHNetPortMappingProtocol interface
            CComPtr<IEnumHNetPortMappingProtocols> spEnumProtocols = NULL;
            m_pSettings->EnumPortMappingProtocols (&spEnumProtocols);
            if (spEnumProtocols) {
                CComPtr<IHNetPortMappingProtocol> spHNetPortMappingProtocol = NULL;
                while (S_OK == spEnumProtocols->Next (1, &spHNetPortMappingProtocol, NULL)) {
                    UCHAR ucProtocol = 0;
                    spHNetPortMappingProtocol->GetIPProtocol (&ucProtocol);
                    USHORT usPort = 0;
                    spHNetPortMappingProtocol->GetPort (&usPort);

                    if ((ucProtocol    == ucIPProtocol) &&
                        (ntohs(usPort) == usExternalPort)) {
#if DBG
                        OLECHAR * szwName = NULL;
                        spHNetPortMappingProtocol->GetName (&szwName);
                        if (szwName) {
                            _ASSERT (!wcscmp (szwName, pszwName));
                            CoTaskMemFree (szwName);
                        }
#endif
                        pNewProtocol = spHNetPortMappingProtocol.Detach();
                        break;
                    }
                    spHNetPortMappingProtocol = NULL;
                }
            }

            if (pNewProtocol == NULL) {
                hr = m_pSettings->CreatePortMappingProtocol(
                            pszwName,
                            ucIPProtocol,
                            htons (usExternalPort),
                            &pNewProtocol );
            }

            if ( SUCCEEDED(hr) )
            {
                IHNetPortMappingBinding *pNewBinding;

                hr = m_pHNetConnection->GetBindingForPortMappingProtocol( 
                            pNewProtocol, 
                            &pNewBinding );

                if ( SUCCEEDED(hr) )
                {
                    if ( NULL == pszwTargetName )
                    {
                        ULONG ulAddress = IpPszToHostAddr( pszwTargetIPAddress );
                        ulAddress = htonl (ulAddress);
                        hr = pNewBinding->SetTargetComputerAddress( ulAddress );
                    }
                    else
                    {
                        hr = pNewBinding->SetTargetComputerName( pszwTargetName );
                    }

                    if ( SUCCEEDED(hr ) )
                    {
                        hr = pNewBinding->SetTargetPort (htons (usInternalPort));
                    }

                    if ( SUCCEEDED(hr ) )
                    {
                        pNewMap->Initialize( pNewBinding );

                        *ppMapping = pNewMap;

                        (*ppMapping)->AddRef();
                    }

                    ReleaseObj( pNewBinding );
                }

                ReleaseObj( pNewProtocol );
            }

            ReleaseObj(pNewMap);
        }
    }
    
    return hr;

    HNET_OEM_API_LEAVE
}

/*++

  CNetSharingConfiguration::RemovePortMapping

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
STDMETHODIMP
CNetSharingConfiguration::RemovePortMapping( 
    INetSharingPortMapping*  pMapping 
    )
{
    HNET_OEM_API_ENTER

    HRESULT hr;

    if ( NULL == pMapping )
    {
        hr = E_INVALIDARG;
    }
    else if ( !IsSecureContext() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = pMapping->Delete();
    }

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingPortMapping::get_Properties (INetSharingPortMappingProps ** ppNSPMP)
//    ICS_PORTMAPPING** ppProps)
/*++

  CNetSharingPortMapping::get_Properties

Routine Description:


Arguments:

    ppProps

Return Value:

    none

--*/
{
    // idea: use existing code to fill out ICS_PORTMAPPING,
    // then convert to INetSharingPortMappingProps

    HNET_OEM_API_ENTER

    ICS_PORTMAPPING * pProps = NULL;
    ICS_PORTMAPPING** ppProps = &pProps;

    HRESULT hr;

#define Props (*ppProps)

    if ( NULL == ppNSPMP )
    {
        hr = E_POINTER;
    }
    else if ( !IsSecureContext() )
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        Props = reinterpret_cast<ICS_PORTMAPPING*>(CoTaskMemAlloc(sizeof(ICS_PORTMAPPING)));

        if ( NULL == Props )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            HRESULT hrName, hrAddr;
            ULONG   ulAddress = 0L;

            ZeroMemory( Props, sizeof(ICS_PORTMAPPING) );
            
            hrName = _IProtocol()->GetTargetComputerName( &(Props->pszwTargetName) );

            hrAddr = _IProtocol()->GetTargetComputerAddress( &ulAddress );
    
            if ( SUCCEEDED(hrAddr) )
            {
                hrAddr = HostAddrToIpPsz( ulAddress, &(Props->pszwTargetIPAddress) );
            }

            if ( SUCCEEDED(hrName) || SUCCEEDED(hrAddr) )
            {
                IHNetPortMappingProtocol *pProtocol = NULL;

                hr = _IProtocol()->GetProtocol( &pProtocol );

                if ( SUCCEEDED(hr) )
                {
                    hr = pProtocol->GetName( &(Props->pszwName) );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pProtocol->GetIPProtocol( &(Props->ucIPProtocol) );
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        hr = pProtocol->GetPort( &(Props->usExternalPort) );
                    }

                    ReleaseObj(pProtocol);
                }
            } else  // actually, either error will do.
                hr = hrName; // ? hrName : hrAddr;

            if (SUCCEEDED(hr)) {

                // distinguish between TargetComputerName and TargetIPAddress
                if (Props->pszwTargetIPAddress && Props->pszwTargetName) {
                    BOOLEAN fUseName;
                    HRESULT hr1 = _IProtocol()->GetCurrentMethod (&fUseName);
                    if (fUseName) {
                        CoTaskMemFree( Props->pszwTargetIPAddress );
                        Props->pszwTargetIPAddress = NULL;
                    } else {
                        CoTaskMemFree( Props->pszwTargetName );
                        Props->pszwTargetName = NULL;
                    }
                }

                // lastly, get enabled bit
                BOOLEAN b = FALSE;
                hr = _IProtocol()->GetEnabled (&b);
                Props->bEnabled = b == TRUE ? VARIANT_TRUE : VARIANT_FALSE;
            }

            if (SUCCEEDED(hr))
            {
                hr = _IProtocol()->GetTargetPort ( &(Props->usInternalPort) );
            }

            if ( FAILED(hr) )
            {
                if ( Props->pszwName )
                    CoTaskMemFree( Props->pszwName );

                if ( Props->pszwTargetIPAddress )
                    CoTaskMemFree( Props->pszwTargetIPAddress );

                if ( Props->pszwTargetName )
                    CoTaskMemFree( Props->pszwTargetName );

                CoTaskMemFree( Props );

                Props = NULL;
            }
        }
    }

    if (Props) {
        // convert to INetSharingPortMappingProps **ppNSPMP
        CComObject<CNetSharingPortMappingProps>* pNSPMP = NULL;
        hr = CComObject<CNetSharingPortMappingProps>::CreateInstance (&pNSPMP);
        if (pNSPMP) {
            pNSPMP->AddRef();
            // adjust byte order
            Props->usExternalPort = ntohs (Props->usExternalPort);
            Props->usInternalPort = ntohs (Props->usInternalPort);
            hr = pNSPMP->SetRawData (Props);
            if (hr == S_OK)
                hr = pNSPMP->QueryInterface (__uuidof(INetSharingPortMappingProps), (void**)ppNSPMP);
            pNSPMP->Release();
        }
        if (Props->pszwName)
            CoTaskMemFree (Props->pszwName);
        if (Props->pszwTargetIPAddress)
            CoTaskMemFree (Props->pszwTargetIPAddress);
        if (Props->pszwTargetName)
            CoTaskMemFree (Props->pszwTargetName);
        CoTaskMemFree (Props);
    }

#undef Props                

    return hr;

    HNET_OEM_API_LEAVE
}


STDMETHODIMP
CNetSharingPortMapping::Delete()
/*++

  CNetSharingPortMapping::Delete

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    HNET_OEM_API_ENTER

    HRESULT hr;

    Disable();  // if we can't delete it, at least disable it.
    // TODO: should I do this only if the Delete call below returns E_ACCESSDENIED?

    if ( _IProtocol() )
    {
        IHNetPortMappingProtocol* pPortMappingProtocol;

        hr = _IProtocol()->GetProtocol( &pPortMappingProtocol );

        if SUCCEEDED(hr)
        {
            pPortMappingProtocol->Delete();

            EnterCriticalSection( _CriticalSection() );

            _IProtocol( NULL );        

            LeaveCriticalSection( _CriticalSection() );

            ReleaseObj( pPortMappingProtocol );
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hnapimgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P I M G R. C P P
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <sddl.h>
#include <wchar.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

HINSTANCE  g_hOemInstance       = NULL;
BOOLEAN    g_fOemNotifyUser     = TRUE;
BOOLEAN    g_fSavedNotifyState  = FALSE;


BOOLEAN IsSecureContext()
/*++

	IsSecureContext

Routine Description:

    This routine checks if the current user belongs to an Administrator Group.

Arguments:

	none

Return Value:

	TRUE  = Current process does belong to an Administrator group
	FALSE = Current process does Not belong to an Administrator group

--*/
{
	PSID						psidAdministrators;

	BOOL                        bIsAdministrator = FALSE;
	SID_IDENTIFIER_AUTHORITY	siaNtAuthority   = SECURITY_NT_AUTHORITY;

	BOOL bResult = AllocateAndInitializeSid( &siaNtAuthority, 2,
						SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
						0, 0, 0, 0, 0, 0, &psidAdministrators );

	_ASSERT( bResult );

	if ( bResult ) 
	{
		bResult = CheckTokenMembership( NULL, psidAdministrators, &bIsAdministrator );
		_ASSERT( bResult );

		FreeSid( psidAdministrators );
	}

	return (BOOLEAN)bIsAdministrator;
}

/*++

	CenterWindow

Routine Description:


Arguments:

	none

Return Value:

	none

--*/

BOOLEAN
CenterDialog( 
	HWND	hwndDlg		// handle to dialog box
	)
{
	RECT rcDlg, rcDesktop;
	HWND hwndDesktop;

    hwndDesktop = GetDesktopWindow();

    if ( GetWindowRect( hwndDlg, &rcDlg ) && GetWindowRect( hwndDesktop, &rcDesktop ) )
	{
		RECT rcCenter;

		// Create a rectangle in the middle of the screen

		rcDesktop.right  -= rcDesktop.left;
		rcDlg.right      -= rcDlg.left;

		rcDesktop.bottom -= rcDesktop.top;
		rcDlg.bottom     -= rcDlg.top;

		if ( rcDesktop.right > rcDlg.right )
		{
		    rcCenter.left  = rcDesktop.left + ((rcDesktop.right - rcDlg.right) / 2);
		    rcCenter.right = rcCenter.left + rcDlg.right;
		}
		else
		{
			rcCenter.left  = rcDesktop.left;
			rcCenter.right = rcDesktop.right;
		}

		if ( rcDesktop.bottom > rcDlg.bottom )
		{
		    rcCenter.top    = rcDesktop.top  + ((rcDesktop.bottom - rcDlg.bottom) / 2);
		    rcCenter.bottom = rcCenter.top  + rcDlg.bottom;
		}
		else
		{
		    rcCenter.top    = rcDesktop.top;
		    rcCenter.bottom = rcDesktop.bottom;
		}

	    return (BOOLEAN)SetWindowPos( hwndDlg, NULL, 
					    			  rcCenter.left, rcCenter.top, 0, 0,
						              SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER );
	}

	return FALSE;
}

INT_PTR CALLBACK OemNotifyDialogProc(
	HWND    hwndDlg,  // handle to dialog box
	UINT    uMsg,     // message
	WPARAM  wParam,   // first message parameter
	LPARAM  lParam    // second message parameter
)
/*++

	OemNotifyDialogProc

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{

    switch ( uMsg ) 
    { 
	case WM_INITDIALOG:
		if ( CenterDialog( hwndDlg ) )
		{
			LPTSTR lpszFmt = new TCHAR[ NOTIFYFORMATBUFFERSIZE ];

			if ( NULL != lpszFmt )
			{
				if ( LoadString( g_hOemInstance, 
								 IDS_SECURITYNOTIFICATIONTEXT,
								 lpszFmt,
								 NOTIFYFORMATBUFFERSIZE ) > 0 )
				{
                    TCHAR lpszCmdLine[MAX_PATH*2+1] = {0};
                    GetModuleFileName (NULL, lpszCmdLine, MAX_PATH*2);

                    size_t cchDest = lstrlen(lpszCmdLine)*2 + lstrlen(lpszFmt) + 2;
					LPTSTR lpszMsg = new TCHAR[cchDest];

					if ( NULL != lpszMsg )
					{
                        StringCchPrintf (lpszMsg, cchDest, lpszFmt, lpszCmdLine, lpszCmdLine);

						SetDlgItemText( hwndDlg, IDC_TXT_NOTIFICATION, lpszMsg );

						delete[] lpszMsg;
					}
				}

				delete[] lpszFmt;
			}
						
		}
		break;

	case WM_COMMAND: 
        switch ( LOWORD(wParam) ) 
        { 
        case IDOK: 
            // Fall through. 

        case IDCANCEL: 

			if ( IsDlgButtonChecked( hwndDlg, IDC_CHK_DISABLESHARESECURITYWARN )
					== BST_CHECKED )
			{
				g_fOemNotifyUser = FALSE;
			}

            EndDialog( hwndDlg, wParam ); 
            return TRUE; 
        } 
		break;
    }

	return FALSE;
}


BOOLEAN IsNotifyApproved()
/*++

	IsNotifyApproved

Routine Description:

	IsSecureContext, g_fOemNotifyUser, g_fSavedNotifyState,	DialogBox determine the 
	value returned.  IsSecureContext MUST be TRUE to return TRUE.  g_fSavedNotifyState
	holds the value returned by DialogBox on the previous call.

Arguments:

	none

Return Value:

	TRUE
	FALSE

--*/
{
	BOOLEAN bApproved = FALSE;

	if ( IsSecureContext() )
	{
		if ( g_fOemNotifyUser )
		{
		    g_fSavedNotifyState = ( DialogBox( g_hOemInstance, 
    								    	   MAKEINTRESOURCE(IDD_SecurityNotification), 
    					        	 		   NULL, 
    					        	 		   OemNotifyDialogProc ) == IDOK ) ?

						TRUE : FALSE;
                        
			g_fOemNotifyUser = FALSE;
		}

		bApproved = g_fSavedNotifyState;
	}

	return bApproved;
}


HRESULT InitializeOemApi( 
	HINSTANCE hInstance 
	)
/*++

	InitializedOemApi 

Routine Description:


Arguments:

	none

Return Value:

	HRESULT

--*/
{
	g_hOemInstance       = hInstance;
	g_fOemNotifyUser     = TRUE;
	g_fSavedNotifyState  = FALSE;
	
	return S_OK;
}


HRESULT ReleaseOemApi()
/*++

	ReleaseOemApi

Routine Description:


Arguments:

	none

Return Value:

	HRESULT

--*/
{
	g_hOemInstance = NULL;

	return S_OK;
}


static HRESULT
_ObtainCfgMgrObj(
	IHNetCfgMgr** ppHNetCfgMgr)
/*++

  _ObtainCfgMgrObj

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
	HRESULT hr = S_OK;

	if ( NULL == ppHNetCfgMgr )
	{
		hr = E_POINTER;
	}
	else 
	{
		hr = CoCreateInstance(
				CLSID_HNetCfgMgr,
				NULL,
				CLSCTX_INPROC_SERVER,
	            IID_PPV_ARG(IHNetCfgMgr, ppHNetCfgMgr)
				);

        _ASSERT(NULL != *ppHNetCfgMgr);
	}

    return hr;
}


/*++

	_ObtainIcsSettingsObj

Routine Description:


Arguments:

	ppIcs -

Return Value:

	HRESULT

--*/
HRESULT 
_ObtainIcsSettingsObj( IHNetIcsSettings** ppIcsSettings )
{
	HRESULT        hr;
	IHNetCfgMgr*   pCfgMgr;

	hr = _ObtainCfgMgrObj( &pCfgMgr );
	
    if ( SUCCEEDED(hr) )
	{
		// Obtain interface pointer to the ICS Settings and enumerator for
		// public connections

		hr = pCfgMgr->QueryInterface( 
				IID_PPV_ARG(IHNetIcsSettings, ppIcsSettings) );

		ReleaseObj( pCfgMgr );
	}

	return hr;
}


HRESULT
CNetSharingConfiguration::Initialize(
	INetConnection *pNetConnection 

	)
/*++

  CNetSharingConfiguration::Initialize

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
	HRESULT        hr;
	IHNetCfgMgr*   pCfgMgr;

	hr = _ObtainCfgMgrObj( &pCfgMgr );

	if ( SUCCEEDED(hr) )
	{
		IHNetConnection* pHNetConnection;	

		hr = pCfgMgr->GetIHNetConnectionForINetConnection( pNetConnection, &pHNetConnection );

		if ( SUCCEEDED(hr) )
		{
			IHNetProtocolSettings* pSettings;

			hr = pCfgMgr->QueryInterface( 
					IID_PPV_ARG(IHNetProtocolSettings, &pSettings) );
			_ASSERT( SUCCEEDED(hr) );

			if ( SUCCEEDED(hr) )
			{
				EnterCriticalSection(&m_csSharingConfiguration);

				ReleaseObj(m_pHNetConnection);
				m_pHNetConnection = pHNetConnection;
				m_pHNetConnection->AddRef();

				ReleaseObj(m_pSettings);
				m_pSettings = pSettings;
				m_pSettings->AddRef();

				LeaveCriticalSection(&m_csSharingConfiguration);

				ReleaseObj(pSettings);
			}

			ReleaseObj(pHNetConnection);
		}

		ReleaseObj(pCfgMgr);
	}
	
	return hr;
}


/*++

  CNetSharingManager::GetSharingInstalled

Routine Description:


Arguments:

	none

Return Value:

	none

--*/

STDMETHODIMP
CNetSharingManager::get_SharingInstalled( 
	VARIANT_BOOL *pbInstalled )
{
    HNET_OEM_API_ENTER

	HRESULT hr = S_OK;

	if ( NULL == pbInstalled )
	{
		hr = E_POINTER;
	}
	else
	{
        BOOLEAN bInstalled = FALSE;

	    SC_HANDLE ScmHandle;
	    SC_HANDLE ServiceHandle;

	    // Connect to the service control manager

	    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	    if ( ScmHandle )
		{
	        // Open the shared access service

	        ServiceHandle = OpenService( ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS );

	        if ( ServiceHandle )
			{
				bInstalled = TRUE;

				CloseServiceHandle(ServiceHandle);
			}

		    CloseServiceHandle(ScmHandle);
		}

		*pbInstalled = bInstalled ? VARIANT_TRUE : VARIANT_FALSE;

	}

	return hr;

    HNET_OEM_API_LEAVE
}

/*++

  CNetSharingManager::GetINetSharingConfigurationForINetConnection

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
STDMETHODIMP
CNetSharingManager::get_INetSharingConfigurationForINetConnection(
    INetConnection*            pNetConnection,
    INetSharingConfiguration** ppNetSharingConfiguration
    )
{
    HNET_OEM_API_ENTER

	HRESULT hr;

	if ( NULL == ppNetSharingConfiguration )
	{
		hr = E_POINTER;
	}
	else if ( NULL == pNetConnection )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		CComObject<CNetSharingConfiguration>* pNetConfig;

		hr = CComObject<CNetSharingConfiguration>::CreateInstance(&pNetConfig);

		if ( SUCCEEDED(hr) )
		{
			pNetConfig->AddRef();

			hr = pNetConfig->Initialize(pNetConnection);

			if ( SUCCEEDED(hr) )
			{
				hr = pNetConfig->QueryInterface( 
						IID_PPV_ARG( INetSharingConfiguration, ppNetSharingConfiguration ) );
			}

			ReleaseObj(pNetConfig);
		}
	}

	return hr;

    HNET_OEM_API_LEAVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hnprivate_i_stub.c ===
#include "hnprivate_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <initguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\saupdate_p_stub.c ===
#include "saupdate_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlwin.h>
#include <commctrl.h>    // added to "Fusionized"
#include <windowsx.h>
#include <raserror.h>
#include <rasuip.h>
#include <wbemidl.h>
#include <netcon.h>
#include <netconp.h>
#include <devguid.h>
#include <iphlpapi.h>
#include <ipnathlp.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <saupdate.h>

#include "hncbase.h"
#include "hncdbg.h"
#include "hnetcfg.h"
#include "hncres.h"
#include "hncstrs.h"
#include "hncutil.h"

#include "hncenum.h"
#include "hncaenum.h"
#include "hnappprt.h"
#include "hnprtmap.h"
#include "hnprtbnd.h"
#include "hnetconn.h"
#include "hnbridge.h"
#include "hnbrgcon.h"
#include "hnicspub.h"
#include "hnicsprv.h"
#include "hnfwconn.h"
#include "hncfgmgr.h"
#include "hnapi.h"

#include <NATUPnP.h>
#include "UPnPNAT.h"
#include "AlgSetup.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hncutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C U T I L . C P P
//
//  Contents:   Home Networking Configuration Utility Routines
//
//  Notes:
//
//  Author:     jonburs 27 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// MPRAPI.DLL import prototypes
//

typedef DWORD
(APIENTRY* PMPRCONFIGBUFFERFREE)(
    LPVOID
    );

typedef DWORD
(APIENTRY* PMPRCONFIGSERVERCONNECT)(
    LPWSTR,
    PHANDLE
    );

typedef VOID
(APIENTRY* PMPRCONFIGSERVERDISCONNECT)(
    HANDLE
    );

typedef DWORD
(APIENTRY* PMPRCONFIGTRANSPORTGETHANDLE)(
    HANDLE,
    DWORD,
    PHANDLE
    );

typedef DWORD
(APIENTRY* PMPRCONFIGTRANSPORTGETINFO)(
    HANDLE,
    HANDLE,
    LPBYTE*,
    LPDWORD,
    LPBYTE*,
    LPDWORD,
    LPWSTR*
    );

typedef DWORD
(APIENTRY* PMPRINFOBLOCKFIND)(
    LPVOID,
    DWORD,
    LPDWORD,
    LPDWORD,
    LPBYTE*
    );

//
// The size of the stack buffer to use for building queries. If the
// query exceeeds this length, the working buffer will be allocated from
// the heap
//

const ULONG c_cchQueryBuffer = 256;


HRESULT
HrFromLastWin32Error ()
//+---------------------------------------------------------------------------
//
//  Function:   HrFromLastWin32Error
//
//  Purpose:    Converts the GetLastError() Win32 call into a proper HRESULT.
//
//  Arguments:
//      (none)
//
//  Returns:    Converted HRESULT value.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      This is not inline as it actually generates quite a bit of
//              code.
//              If GetLastError returns an error that looks like a SetupApi
//              error, this function will convert the error to an HRESULT
//              with FACILITY_SETUP instead of FACILITY_WIN32
//
{
    DWORD dwError = GetLastError();
    HRESULT hr;

    // This test is testing SetupApi errors only (this is
    // temporary because the new HRESULT_FROM_SETUPAPI macro will
    // do the entire conversion)
    if (dwError & (APPLICATION_ERROR_MASK | ERROR_SEVERITY_ERROR))
    {
        hr = HRESULT_FROM_SETUPAPI(dwError);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }
    return hr;
}


BOOLEAN
ApplicationProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usOutgoingPort,
    UCHAR ucOutgoingIPProtocol
    )

/*++

Routine Description:

    Checks if an application protocol already exists that has the
    specified outgoing protocol and port.


Arguments:

    piwsNamespace - the namespace to use

    bstrWQL - a BSTR containing "WQL"

    ucOutgoingProtocol - the protocol number to check for

    usOutgoingPort - the port to check for

Return Value:

    BOOLEAN -- TRUE if the application protocol exists; FALSE otherwise

--*/

{
    BSTR bstr;
    BOOLEAN fDuplicate = FALSE;
    HRESULT hr = S_OK;
    int iBytes;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    ULONG ulObjs;
    OLECHAR wszWhereClause[c_cchQueryBuffer + 1];

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);
    _ASSERT(0 == wcscmp(bstrWQL, L"WQL"));

    //
    // Build the query string
    //

    iBytes = _snwprintf(
                wszWhereClause,
                c_cchQueryBuffer,
                c_wszApplicationProtocolQueryFormat,
                usOutgoingPort,
                ucOutgoingIPProtocol
                );

    if (iBytes >= 0)
    {
        //
        // String fit into buffer; make sure it's null terminated
        //

        wszWhereClause[c_cchQueryBuffer] = L'\0';
    }
    else
    {
        //
        // For some reason the string didn't fit into the buffer...
        //

        hr = E_UNEXPECTED;
        _ASSERT(FALSE);
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszHnetApplicationProtocol,
                wszWhereClause
                );
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstr);
    }

    if (S_OK == hr)
    {
        //
        // Attempt to retrieve an item from the enum. If we're successful,
        // this is a duplicate protocol.
        //

        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulObjs
                );

        if (SUCCEEDED(hr) && 1 == ulObjs)
        {
            //
            // It's a duplicate
            //

            fDuplicate = TRUE;
            pwcoInstance->Release();
        }

        pwcoEnum->Release();
    }

    return fDuplicate;
} // ApplicationProtocolExists



HRESULT
BuildAndString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft AND pwszRight


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the AND clause

    pwszRight - right side of the AND clause

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // length(left) + space + AND + space + length(right) + null
    //

    cch = wcslen(pwszLeft) + wcslen(pwszRight) + 6;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s AND %s",
            pwszLeft,
            pwszRight
            );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



HRESULT
BuildAssociatorsQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszAssocClass
    )

/*++

Routine Description:

    Builds a WQL references query and places it into a BSTR. The returned
    query is

    ASSOCIATORS OF {wszProperties} WHERE AssocClass = pwszAssocClass


Arguments:

    pBstr - receives the built query. The caller is responsible for calling
        SysFreeString on this variable. Receives NULL on failure.

    pwszObjectPath - path of the object to find the references of

    pwszAssocClass - the associator class

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszQuery = NULL;

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszAssociatorsOf) == c_cchAssociatorsOf);
    _ASSERT(wcslen(c_wszWhereAssocClass) == c_cchWhereAssocClass);

    //
    // All necessary spaces are embedded in the string constants
    //

    ULONG cchLength = c_cchAssociatorsOf + c_cchWhereAssocClass;

    _ASSERT(pwszObjectPath);
    _ASSERT(pwszAssocClass);
    _ASSERT(pBstr);

    *pBstr = NULL;

    //
    // Determine the length of the query string
    //

    cchLength += wcslen(pwszObjectPath);
    cchLength += wcslen(pwszAssocClass);

    //
    // If the query string is longer than our stack buffer, we need
    // to allocate a buffer off of the heap.
    //

    if (cchLength <= c_cchQueryBuffer)
    {
        //
        // The buffer is large enough. (Note that since the buffer on the
        // stack is one greater than the constant, the terminator is accounted
        // for.) Point our working pointer to the stack buffer.
        //

        pwszQuery = wszBuffer;
    }
    else
    {
        //
        // Allocate a sufficient buffer from the heap. The +1 is for the
        // terminating nul
        //

        pwszQuery = new OLECHAR[cchLength + 1];

        if (NULL == pwszQuery)
        {
            hr = E_OUTOFMEMORY;
            pwszQuery = wszBuffer;
        }
    }

    if (S_OK == hr)
    {
        //
        // Build the actual query string
        //

        swprintf(
            pwszQuery,
            L"%s%s%s%s",
            c_wszAssociatorsOf,
            pwszObjectPath,
            c_wszWhereAssocClass,
            pwszAssocClass
            );

        *pBstr = SysAllocString(pwszQuery);
        if (NULL == *pBstr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszQuery)
    {
        delete [] pwszQuery;
    }

    return hr;
}


HRESULT
BuildEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft = pwszRight


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the equals clause

    pwszRight - right side of the equals clause

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // length(left) + space + = + space + length(right) + null
    //

    cch = wcslen(pwszLeft) + wcslen(pwszRight) + 4;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s = %s",
            pwszLeft,
            pwszRight
            );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
BuildEscapedQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft = "pwszRight"

    after escaping pwszRight -- replace \ w/ \\ and " with \"


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the equals clause

    pwszRight - right side of the equals clause. This will be escaped, and then
                wrapped in quotes

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;
    LPWSTR wszEscaped;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // Escape string
    //

    wszEscaped = EscapeString(pwszRight);
    if (NULL == wszEscaped)
    {
        return E_OUTOFMEMORY;
    }

    //
    // length(left) + space + = + space + " + length(right) + " + null
    //

    cch = wcslen(pwszLeft) + wcslen(wszEscaped) + 6;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s = \"%s\"",
            pwszLeft,
            wszEscaped
            );

        delete [] wszEscaped;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
BuildQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    )

/*++

Routine Description:

    Builds the following string:

    pwszLeft = "pwszRight"


Arguments:

    ppwsz - receives the built string. The caller is responsible for calling
        delete[] on this variable. Receives NULL on failure.

    pwszLeft - left side of the equals clause

    pwszRight - right side of the equals clause. This will be wrapped in
                quotes

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG cch;
    LPWSTR wsz;

    _ASSERT(NULL != ppwsz);
    _ASSERT(NULL != pwszLeft);
    _ASSERT(NULL != pwszRight);

    //
    // length(left) + space + = + space + " + length(right) + " + null
    //

    cch = wcslen(pwszLeft) + wcslen(pwszRight) + 6;
    *ppwsz = new OLECHAR[cch];

    if (NULL != *ppwsz)
    {
        swprintf(
            *ppwsz,
            L"%s = \"%s\"",
            pwszLeft,
            pwszRight
            );

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



HRESULT
BuildReferencesQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszTargetClass
    )

/*++

Routine Description:

    Builds a WQL references query and places it into a BSTR. The returned
    query is

    REFERENCES OF {pwszObjectPath} WHERE ResultClass = pwszTargetClass

    if pwszTargetClass is not NULL, and

    REFERENCES OF {pwszObjectPath}

    otherwise


Arguments:

    pBstr - receives the built query. The caller is responsible for calling
        SysFreeString on this variable. Receives NULL on failure.

    pwszObjectPath - path of the object to find the references of

    pwszTargetClass - the class of references desired. May be NULL.

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszQuery = NULL;

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszReferencesOf) == c_cchReferencesOf);
    _ASSERT(wcslen(c_wszWhereResultClass) == c_cchWhereResultClass);

    //
    // All necessary spaces are embedded in the string constants
    //

    ULONG cchLength = c_cchReferencesOf + c_cchWhereResultClass;

    _ASSERT(pwszObjectPath);
    _ASSERT(pBstr);

    *pBstr = NULL;

    //
    // Determine the length of the query string
    //

    cchLength += wcslen(pwszObjectPath);
    if (NULL != pwszTargetClass)
    {
        cchLength += wcslen(pwszTargetClass);
    }

    //
    // If the query string is longer than our stack buffer, we need
    // to allocate a buffer off of the heap.
    //

    if (cchLength <= c_cchQueryBuffer)
    {
        //
        // The buffer is large enough. (Note that since the buffer on the
        // stack is one greater than the constant, the terminator is accounted
        // for.) Point our working pointer to the stack buffer.
        //

        pwszQuery = wszBuffer;
    }
    else
    {
        //
        // Allocate a sufficient buffer from the heap. The +1 is for the
        // terminating nul
        //

        pwszQuery = new OLECHAR[cchLength + 1];

        if (NULL == pwszQuery)
        {
            hr = E_OUTOFMEMORY;
            pwszQuery = wszBuffer;
        }
    }

    if (S_OK == hr)
    {
        //
        // Build the actual query string
        //

        if (NULL != pwszTargetClass)
        {
            swprintf(
                pwszQuery,
                L"%s%s%s%s",
                c_wszReferencesOf,
                pwszObjectPath,
                c_wszWhereResultClass,
                pwszTargetClass
                );
        }
        else
        {
            swprintf(
                pwszQuery,
                L"%s%s}",
                c_wszReferencesOf,
                pwszObjectPath
                );
        }

        *pBstr = SysAllocString(pwszQuery);
        if (NULL == *pBstr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszQuery)
    {
        delete [] pwszQuery;
    }

    return hr;
}


HRESULT
BuildSelectQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszProperties,
    LPCWSTR pwszFromClause,
    LPCWSTR pwszWhereClause
    )

/*++

Routine Description:

    Builds a WQL select query and places it into a BSTR. The returned
    query is

    SELECT wszProperties FROM wszFromClause [WHERE wszWhereClause]


Arguments:

    pBstr - receives the built query. The caller is responsible for calling
        SysFreeString on this variable. Receives NULL on failure.

    pwszProperties - the properties the query should return

    pwszFromClause - the class the returned objects should be from

    pwszWhereClause - the constraints that the returned object must meet. If
        NULL, the query will not have a where clause.

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszQuery = NULL;

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszSelect) == c_cchSelect);
    _ASSERT(wcslen(c_wszFrom) == c_cchFrom);
    _ASSERT(wcslen(c_wszWhere) == c_cchWhere);

    //
    // SELECT + 2 spaces (around properties) + FROM + space
    //

    ULONG cchLength = c_cchSelect + 2 + c_cchFrom + 1;

    _ASSERT(pwszProperties);
    _ASSERT(pwszFromClause);
    _ASSERT(pBstr);

    *pBstr = NULL;

    //
    // Determine the length of the query string
    //

    cchLength += wcslen(pwszProperties);
    cchLength += wcslen(pwszFromClause);
    if (pwszWhereClause)
    {
        //
        // space + WHERE + space
        //
        cchLength += 2 + c_cchWhere;
        cchLength += wcslen(pwszWhereClause);
    }

    //
    // If the query string is longer than our stack buffer, we need
    // to allocate a buffer off of the heap.
    //

    if (cchLength <= c_cchQueryBuffer)
    {
        //
        // The buffer is large enough. (Note that since the buffer on the
        // stack is one greater than the constant, the terminator is accounted
        // for.) Point our working pointer to the stack buffer.
        //

        pwszQuery = wszBuffer;
    }
    else
    {
        //
        // Allocate a sufficient buffer from the heap. The +1 is for the
        // terminating nul
        //

        pwszQuery = new OLECHAR[cchLength + 1];

        if (NULL == pwszQuery)
        {
            hr = E_OUTOFMEMORY;
            pwszQuery = wszBuffer;
        }
    }

    if (S_OK == hr)
    {
        //
        // Build the actual query string
        //

        if (pwszWhereClause)
        {
            swprintf(
                pwszQuery,
                L"%s %s %s %s %s %s",
                c_wszSelect,
                pwszProperties,
                c_wszFrom,
                pwszFromClause,
                c_wszWhere,
                pwszWhereClause
                );
        }
        else
        {
            swprintf(
                pwszQuery,
                L"%s %s %s %s",
                c_wszSelect,
                pwszProperties,
                c_wszFrom,
                pwszFromClause
                );
        }

        *pBstr = SysAllocString(pwszQuery);
        if (NULL == *pBstr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszQuery)
    {
        delete [] pwszQuery;
    }

    return hr;
}


BOOLEAN
ConnectionIsBoundToTcp(
    PIP_INTERFACE_INFO pIpInfoTable,
    GUID *pConnectionGuid
    )

/*++

Routine Description:

    Determines if a LAN connection is bound to TCP/IP. For the purposes of
    this routine, "bound to TCP/IP" is defines as there exists an IP
    adapter index for the connection.

Arguments:

    pIpInfoTable - the IP interface table, obtained from a call to
                   GetInterfaceInfo

    pConnectionGuid - a pointer to the guid for the connection

Return Value:

    BOOLEAN - TRUE if the connection is bound to TCP/IP; FALSE otherwise.
              FALSE will be returned if an error occurs

--*/

{
    BOOLEAN fIsBound = FALSE;
    LPOLESTR pszGuid;
    HRESULT hr;
    ULONG cchGuid;
    ULONG cchName;
    PWCHAR pwchName;
    LONG l;

    _ASSERT(NULL != pIpInfoTable);
    _ASSERT(NULL != pConnectionGuid);

    //
    // Convert the guid to a string
    //

    hr = StringFromCLSID(*pConnectionGuid, &pszGuid);

    if (SUCCEEDED(hr))
    {
        cchGuid = wcslen(pszGuid);

        //
        // Walk the table, searching for the corresponding adapter
        //

        for (l = 0; l < pIpInfoTable->NumAdapters; l++)
        {
            cchName = wcslen(pIpInfoTable->Adapter[l].Name);

            if (cchName < cchGuid) { continue; }
            pwchName = pIpInfoTable->Adapter[l].Name + (cchName - cchGuid);
            if (0 == _wcsicmp(pszGuid, pwchName))
            {
                fIsBound = TRUE;
                break;
            }
        }

        CoTaskMemFree(pszGuid);
    }


    return fIsBound;
} // ConnectionIsBoundToTcp


HRESULT
ConvertResponseRangeArrayToInstanceSafearray(
    IWbemServices *piwsNamespace,
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponses[],
    SAFEARRAY **ppsa
    )

/*++

Routine Description:

    Converts an array of HNET_RESPONSE_RANGE structures into a
    safearray of IUnknows that represent WMI instances of
    those response ranges.

Arguments:

    piwsNamespace - the namespace to use

    uscResponses - the count of responses

    rgResponses - the response range structures

    ppsa - receives a pointer to the safearrays

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    SAFEARRAY *psa;
    BSTR bstrPath;
    SAFEARRAYBOUND rgsabound[1];
    IWbemClassObject *pwcoClass = NULL;
    IWbemClassObject *pwcoInstance;
    IUnknown *pUnk;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(0 != uscResponses);
    _ASSERT(NULL != rgResponses);
    _ASSERT(NULL != ppsa);

    bstrPath = SysAllocString(c_wszHnetResponseRange);
    if (NULL == bstrPath)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {

        //
        // Get the class for HNet_ResponseRange
        //

        pwcoClass = NULL;
        hr = piwsNamespace->GetObject(
                bstrPath,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pwcoClass,
                NULL
                );

        SysFreeString(bstrPath);
    }


    if (S_OK == hr)
    {
        //
        // Create the array to hold the response range instances
        //

        rgsabound[0].lLbound = 0;
        rgsabound[0].cElements = uscResponses;

        psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
        if (NULL == psa)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        //
        // Process the passed in response ranges
        //

        for (USHORT i = 0; i < uscResponses; i++)
        {
            //
            // First, create an HNet_ResponseRange instance
            // for the entry
            //

            pwcoInstance = NULL;
            hr = pwcoClass->SpawnInstance(0, &pwcoInstance);

            if (WBEM_S_NO_ERROR != hr)
            {
                break;
            }

            //
            // Populate that instance
            //

            hr = CopyStructToResponseInstance(
                    &rgResponses[i],
                    pwcoInstance
                    );

            if (FAILED(hr))
            {
                pwcoInstance->Release();
                break;
            }

            //
            // Get the IUnknown for the instance and put it
            // in the array
            //

            hr = pwcoInstance->QueryInterface(
                    IID_PPV_ARG(IUnknown, &pUnk)
                    );

            _ASSERT(S_OK == hr);

            LONG lIndex = i;
            hr = SafeArrayPutElement(
                    psa,
                    &lIndex,
                    pUnk
                    );

            pUnk->Release();
            pwcoInstance->Release();

            if (FAILED(hr))
            {
                SafeArrayDestroy(psa);
                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppsa = psa;
        hr = S_OK;
    }

    if (pwcoClass) pwcoClass->Release();

    return hr;
}


HRESULT
CopyResponseInstanceToStruct(
    IWbemClassObject *pwcoInstance,
    HNET_RESPONSE_RANGE *pResponse
    )

/*++

Routine Description:

    Converts an instance of an HNet_ResponseRange into the
    corresponding HNET_RESPONSE_RANGE

Arguments:

    pwcoInstance - the HNet_ResponseRange instance

    pResponse - the HNET_RESPONSE_RANGE to fill

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pResponse);

    hr = pwcoInstance->Get(
            c_wszIPProtocol,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_UI1 == V_VT(&vt));

        pResponse->ucIPProtocol = V_UI1(&vt);
        VariantClear(&vt);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoInstance->Get(
                c_wszStartPort,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // WMI returns uint16 properties as VT_I4
            //

            _ASSERT(VT_I4 == V_VT(&vt));

            pResponse->usStartPort = static_cast<USHORT>(V_I4(&vt));
            VariantClear(&vt);
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoInstance->Get(
                c_wszEndPort,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // WMI returns uint16 properties as VT_I4
            //

            _ASSERT(VT_I4 == V_VT(&vt));

            pResponse->usEndPort = static_cast<USHORT>(V_I4(&vt));
            VariantClear(&vt);
        }
    }

    return hr;
}


HRESULT
CopyStructToResponseInstance(
    HNET_RESPONSE_RANGE *pResponse,
    IWbemClassObject *pwcoInstance
    )

/*++

Routine Description:

    Converts an instance of an HNet_ResponseRange into the
    corresponding HNET_RESPONSE_RANGE

Arguments:

    pResponse - the HNET_RESPONSE_RANGE to fill

    pwcoInstance - the HNet_ResponseRange instance to create


Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pResponse);
    _ASSERT(NULL != pwcoInstance);

    VariantInit(&vt);
    V_VT(&vt) = VT_UI1;
    V_UI1(&vt) = pResponse->ucIPProtocol;

    hr = pwcoInstance->Put(
            c_wszIPProtocol,
            0,
            &vt,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        V_VT(&vt) = VT_I4;
        V_I4(&vt) = pResponse->usStartPort;

        hr = pwcoInstance->Put(
            c_wszStartPort,
            0,
            &vt,
            NULL
            );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        V_I4(&vt) = pResponse->usEndPort;

        hr = pwcoInstance->Put(
            c_wszEndPort,
            0,
            &vt,
            NULL
            );
    }

    return hr;

}


HRESULT
DeleteWmiInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

/*++

Routine Description:

    Deletes an object instance from the WMI repository.

Arguments:

    piwsNamespace - the namespace the object is in

    pwcoInstance - the class object interface for the instance

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR bstr;

    _ASSERT(piwsNamespace);
    _ASSERT(pwcoInstance);

    hr = GetWmiPathFromObject(pwcoInstance, &bstr);

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = piwsNamespace->DeleteInstance(
                bstr,
                0,
                NULL,
                NULL
                );

        SysFreeString(bstr);
    }

    return hr;
}


LPWSTR
EscapeString(
    LPCWSTR pwsz
    )

{
    ULONG ulCount = 0;
    LPWSTR wsz;
    LPWSTR wszReturn;

    wsz = const_cast<LPWSTR>(pwsz);

    while (NULL != *wsz)
    {
        if (L'\\' == *wsz || L'\"' == *wsz)
        {
            //
            // Need an extra character
            //

            ulCount += 1;
        }

        wsz += 1;
        ulCount += 1;
    }

    //
    // Allocate new string buffer
    //

    wszReturn = new OLECHAR[ulCount + 1];
    if (NULL == wszReturn)
    {
        return wszReturn;
    }

    //
    // Copy string over
    //

    wsz = wszReturn;

    while (NULL != *pwsz)
    {
        if (L'\\' == *pwsz || L'\"' == *pwsz)
        {
            *wsz++ = L'\\';
        }

        *wsz++ = *pwsz++;
    }

    //
    // Make sure everything is properly null terminated
    //

    *wsz = L'';

    return wszReturn;
}


HRESULT
InitializeNetCfgForWrite(
    OUT INetCfg             **ppnetcfg,
    OUT INetCfgLock         **ppncfglock
    )

/*++

Routine Description:

    Initializes NetCfg for writing. If this function succeeds, the
    caller must call UninitializeNetCfgForWrite() with the two
    returned interface pointers when done.

Arguments:

    ppnetcfg                Receives an initialized INetCfg interface.

    ppnetcfglock            Receives an acquires INetCfgLock interface.

Return Value:

    Status of the operation

--*/

{
    HRESULT         hr = S_OK;

    *ppnetcfg = NULL;
    *ppncfglock = NULL;

    // Open our own NetCfg context
    hr = CoCreateInstance(
            CLSID_CNetCfg,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
            IID_PPV_ARG(INetCfg, ppnetcfg)
            );

    if ( SUCCEEDED(hr) )
    {
        //
        // Get the lock interface
        //
        hr = (*ppnetcfg)->QueryInterface(
                IID_PPV_ARG(INetCfgLock, ppncfglock)
                );

        if ( SUCCEEDED(hr) )
        {
            //
            // Get the NetCfg lock
            //
            hr = (*ppncfglock)->AcquireWriteLock(
                    5,
                    L"HNetCfg",
                    NULL
                    );

            //
            // S_FALSE is actually failure; it means NetCfg timed out
            // trying to acquire the write lock
            //
            if( S_FALSE == hr )
            {
                // Turn into an error that will make sense up the call chain
                hr = NETCFG_E_NO_WRITE_LOCK;
            }

            if ( SUCCEEDED(hr) )
            {
                //
                // Must initialize NetCfg inside the lock
                //
                hr = (*ppnetcfg)->Initialize( NULL );

                if( FAILED(hr) )
                {
                    (*ppncfglock)->ReleaseWriteLock();
                }
            }

            if( FAILED(hr) )
            {
                (*ppncfglock)->Release();
                *ppncfglock = NULL;
            }
        }

        if( FAILED(hr) )
        {
            (*ppnetcfg)->Release();
            *ppnetcfg = NULL;
        }
    }

    return hr;
}



void
UninitializeNetCfgForWrite(
    IN INetCfg              *pnetcfg,
    IN INetCfgLock          *pncfglock
    )

/*++

Routine Description:

    Uninitializes a NetCfg context created with InitializeNetCfgForWrite()

Arguments:

    pnetcfg                 An INetCfg instance created by InitializeNetCfgForWrite()

    pncfglock               An INetCfgLock instance created by InitializeNetCfgForWrite()

Return Value:

    Status of the operation

--*/

{
    _ASSERT( (NULL != pnetcfg) && (NULL != pncfglock) );

    pnetcfg->Uninitialize();
    pncfglock->ReleaseWriteLock();
    pncfglock->Release();
    pnetcfg->Release();
}


HRESULT
FindAdapterByGUID(
    IN INetCfg              *pnetcfg,
    IN GUID                 *pguid,
    OUT INetCfgComponent    **ppncfgcomp
    )

/*++

Routine Description:

    Retrieves an INetCfgComponent interface, if any, that corresponds
    to the given device GUID. The GUID must correspond to a networking
    component of class NET (i.e., a miniport).

    E_FAIL is returned if the given GUID is not located.

Arguments:

    pnetcfg                 An instance of INetCfg which has already had
                            its Initialize() method called

    pguid                   The GUID to search for

    ppncfgcomp              Receives the resulting INetCfgComponent interface
                            pointer.

Return Value:

    Status of the operation

--*/

{
    HRESULT                 hr = S_OK;
    GUID                    guidDevClass = GUID_DEVCLASS_NET;
    IEnumNetCfgComponent    *penumncfgcomp;
    INetCfgComponent        *pnetcfgcomp;
    ULONG                   ulCount;
    BOOLEAN                 fFound = FALSE;

    //
    // Get the list of NET (adapter) devices
    //
    hr = pnetcfg->EnumComponents( &guidDevClass, &penumncfgcomp );

    if (S_OK == hr)
    {
        //
        // Search for the designated adapter by GUID
        //
        while ( (FALSE == fFound) &&
                (S_OK == penumncfgcomp->Next(1, &pnetcfgcomp, &ulCount) ) )
        {
            GUID            guidThis;

            hr = pnetcfgcomp->GetInstanceGuid( &guidThis );

            if ( (S_OK == hr) && (InlineIsEqualGUID(guidThis,*pguid)) )
            {
                fFound = TRUE;
            }
            else
            {
                pnetcfgcomp->Release();
            }
        }
        penumncfgcomp->Release();
    }

    if (fFound)
    {
        *ppncfgcomp = pnetcfgcomp;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT
FindINetConnectionByGuid(
    GUID *pGuid,
    INetConnection **ppNetCon
    )

/*++

Routine Description:

    Retrieves the INetConnection that corresponds to the given GUID.

Arguments:

    pGuid - the guid of the connection

    ppNetCon - receives the interface

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    INetConnectionManager *pManager;
    IEnumNetConnection *pEnum;
    INetConnection *pConn;

    _ASSERT(NULL != pGuid);
    _ASSERT(NULL != ppNetCon);

    //
    // Get the net connections manager
    //

    hr = CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
            IID_PPV_ARG(INetConnectionManager, &pManager)
            );

    if (S_OK == hr)
    {
        //
        // Get the enumeration of connections
        //

        SetProxyBlanket(pManager);

        hr = pManager->EnumConnections(NCME_DEFAULT, &pEnum);

        pManager->Release();
    }

    if (S_OK == hr)
    {
        //
        // Search for the connection with the correct guid
        //

        ULONG ulCount;
        BOOLEAN fFound = FALSE;

        SetProxyBlanket(pEnum);

        do
        {
            NETCON_PROPERTIES *pProps;

            hr = pEnum->Next(1, &pConn, &ulCount);
            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                SetProxyBlanket(pConn);

                hr = pConn->GetProperties(&pProps);
                if (S_OK == hr)
                {
                    if (IsEqualGUID(pProps->guidId, *pGuid))
                    {
                        fFound = TRUE;
                        *ppNetCon = pConn;
                        (*ppNetCon)->AddRef();
                    }

                    NcFreeNetconProperties(pProps);
                }

                pConn->Release();
            }
        }
        while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

        //
        // Normalize hr
        //

        hr = (fFound ? S_OK : E_FAIL);

        pEnum->Release();
    }

    return hr;
}

HRESULT
GetBridgeConnection(
    IN IWbemServices       *piwsHomenet,
    OUT IHNetBridge       **pphnetBridge
    )
{
    INetCfg                 *pnetcfg;
    HRESULT                 hr;

    if( NULL != pphnetBridge )
    {
        *pphnetBridge = NULL;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                IID_PPV_ARG(INetCfg, &pnetcfg));

        if( S_OK == hr )
        {
            hr = pnetcfg->Initialize( NULL );

            if( S_OK == hr )
            {
                INetCfgComponent    *pnetcfgcompBridge;

                hr = pnetcfg->FindComponent( c_wszSBridgeMPID, &pnetcfgcompBridge );

                if( S_OK == hr )
                {
                    hr = GetIHNetConnectionForNetCfgComponent(
                            piwsHomenet,
                            pnetcfgcompBridge,
                            TRUE,
                            IID_PPV_ARG(IHNetBridge, pphnetBridge)
                            );

                    pnetcfgcompBridge->Release();
                }

                pnetcfg->Uninitialize();
            }

            pnetcfg->Release();
        }
    }
    else
    {
        hr = E_POINTER;
    }

    // S_FALSE tends to get mishandled; return E_FAIL to signal the absence of a bridge.
    if( S_FALSE == hr )
    {
        return E_FAIL;
    }

    return hr;
}

HRESULT
GetIHNetConnectionForNetCfgComponent(
    IN IWbemServices        *piwsHomenet,
    IN INetCfgComponent     *pnetcfgcomp,
    IN BOOLEAN               fLanConnection,
    IN REFIID                iid,
    OUT PVOID               *ppv
    )
{
    HRESULT                         hr;

    if( NULL != ppv )
    {
        CComObject<CHNetCfgMgrChild>    *pHNCfgMgrChild;

        *ppv = NULL;
        hr = CComObject<CHNetCfgMgrChild>::CreateInstance(&pHNCfgMgrChild);

        if (SUCCEEDED(hr))
        {
            pHNCfgMgrChild->AddRef();
            hr = pHNCfgMgrChild->Initialize(piwsHomenet);

            if (SUCCEEDED(hr))
            {
                GUID                guid;

                hr = pnetcfgcomp->GetInstanceGuid( &guid );

                if( S_OK == hr )
                {
                    IHNetConnection     *phnetcon;

                    hr = pHNCfgMgrChild->GetIHNetConnectionForGuid( &guid, fLanConnection, TRUE, &phnetcon );

                    if( S_OK == hr )
                    {
                        hr = phnetcon->GetControlInterface( iid, ppv );
                        phnetcon->Release();
                    }
                }
            }

            pHNCfgMgrChild->Release();
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
BindOnlyToBridge(
    IN INetCfgComponent     *pnetcfgcomp
    )

/*++

Routine Description:

    Alters the bindings for the given INetCfgComponent so it is bound only
    to the bridge protocol
    
    c_pwszBridgeBindExceptions is a list of exceptions; if a binding path
    involves a component listed in c_pwszBridgeBindExceptions, the path
    will not be altered.

Arguments:

    pnetcfgcomp     The component whose bindings we wish to alter

Return Value:

    standard HRESULT

--*/


{
    BOOLEAN                     fBoundToBridge = FALSE;
    HRESULT                     hr = S_OK;
    INetCfgComponentBindings    *pnetcfgBindings;

    //
    // Retrieve the ComponentBindings interface
    //
    hr = pnetcfgcomp->QueryInterface(
            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgBindings)
            );

    if (S_OK == hr)
    {
        IEnumNetCfgBindingPath  *penumPaths;

        //
        // Get the list of binding paths for this component
        //
        hr = pnetcfgBindings->EnumBindingPaths(
                EBP_ABOVE,
                &penumPaths
                );

        if (S_OK == hr)
        {
            ULONG               ulCount1, ulCount2;
            INetCfgBindingPath  *pnetcfgPath;

            while( (S_OK == penumPaths->Next(1, &pnetcfgPath, &ulCount1) ) )
            {
                INetCfgComponent        *pnetcfgOwner;

                //
                // Get the owner of this path
                //
                hr = pnetcfgPath->GetOwner( &pnetcfgOwner );

                if (S_OK == hr)
                {
                    INetCfgComponentBindings    *pnetcfgOwnerBindings;

                    hr = pnetcfgOwner->QueryInterface(
                            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgOwnerBindings)
                            );

                    if (S_OK == hr)
                    {
                        LPWSTR              lpwstrId;

                        hr = pnetcfgOwner->GetId( &lpwstrId );

                        if (S_OK == hr)
                        {
                            BOOLEAN         bIsBridge;

                            bIsBridge = ( _wcsicmp(lpwstrId, c_wszSBridgeSID) == 0 );

                            if( bIsBridge )
                            {
                                // This is the bridge component. Activate this binding path
                                hr = pnetcfgOwnerBindings->BindTo(pnetcfgcomp);
                                fBoundToBridge = (S_OK == hr);
                            }
                            else
                            {
                                // Check if this is one of the bind exceptions
                                BOOLEAN     bIsException = FALSE;
                                const WCHAR **ppwszException = c_pwszBridgeBindExceptions;

                                while( NULL != *ppwszException )
                                {
                                    bIsException = ( _wcsicmp(lpwstrId, *ppwszException) == 0 );

                                    if( bIsException )
                                    {
                                        break;
                                    }
                                    
                                    ppwszException++;
                                }

                                if( !bIsException )
                                {
                                    hr = pnetcfgOwnerBindings->UnbindFrom(pnetcfgcomp);
                                }
                                // else this is an exception; leave the bind path as-is.
                            }

                            CoTaskMemFree(lpwstrId);
                        }

                        pnetcfgOwnerBindings->Release();
                    }

                    pnetcfgOwner->Release();
                }

                pnetcfgPath->Release();
            }

            penumPaths->Release();
        }

        pnetcfgBindings->Release();
    }

    if (S_OK == hr && !fBoundToBridge)
    {
        //
        // We didn't found a binding path between this component and
        // the bridge protocol. This should never occur -- such
        // components should not have shown up as bridgeable. Return
        // and error and fire an assert.
        //

        _ASSERT(FALSE);
        hr = E_FAIL;
    }

    return hr;
}


HRESULT
GetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN *pfBoolean
    )

/*++

Routine Description:

    Retrieves a boolean property from a Wbem object.

Arguments:

    pwcoInstance - the object to get the property from

    pwszProperty - the property to retrieve

    pfBoolean - received the property value

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pwszProperty);
    _ASSERT(NULL != pfBoolean);

    hr = pwcoInstance->Get(
            pwszProperty,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BOOL == V_VT(&vt) || VT_NULL == V_VT(&vt));

        if (VT_BOOL == V_VT(&vt))
        {
            *pfBoolean = VARIANT_TRUE == V_BOOL(&vt);
        }
        else
        {
            //
            // No value for this member was ever written to the store.
            // Return FALSE, and set that value in the store. We don't
            // pass along the error, if one occurs
            //

            *pfBoolean = FALSE;
            SetBooleanValue(
                pwcoInstance,
                pwszProperty,
                FALSE
                );
        }

        VariantClear(&vt);
    }

    return hr;
}


HRESULT
GetConnectionInstanceByGuid(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection
    )

/*++

Routine Description:

    Retrieves the HNet_Connection instance for a INetConnection guid

Arguments:

    piwsNamespace - WMI namespace

    bstrWQL - a BSTR that corresponds to "WQL"

    pGuid - the guid of the INetConnection (i.e., guidId in its properties)

    ppwcoConnection - receives the HNet_Connection instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    LPWSTR wsz;
    BSTR bstrQuery;
    LPOLESTR wszGuid;
    IEnumWbemClassObject *pwcoEnum;

    //
    // Convert the guid to a string
    //

    hr = StringFromCLSID(*pGuid, &wszGuid);

    if (S_OK == hr)
    {
        //
        // Find the connection w/ name equal to that string
        //

        hr = BuildQuotedEqualsString(
                &wsz,
                c_wszGuid,
                wszGuid
                );

        CoTaskMemFree(wszGuid);

        if (S_OK == hr)
        {
            hr = BuildSelectQueryBstr(
                    &bstrQuery,
                    c_wszStar,
                    c_wszHnetConnection,
                    wsz
                    );

            delete [] wsz;
        }

        if (S_OK == hr)
        {
            pwcoEnum = NULL;
            hr = piwsNamespace->ExecQuery(
                    bstrWQL,
                    bstrQuery,
                    WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                    NULL,
                    &pwcoEnum
                    );

            SysFreeString(bstrQuery);
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;

        //
        // Get the instance out of the enum
        //

        *ppwcoConnection = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                ppwcoConnection,
                &ulCount
                );

        if (SUCCEEDED(hr) && 1 != ulCount)
        {
            hr = E_FAIL;
        }

        ValidateFinishedWCOEnum(piwsNamespace, pwcoEnum);
        pwcoEnum->Release();
    }

    return hr;
}


HRESULT
GetConnAndPropInstancesByGuid(
    IWbemServices *piwsNamespace,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

/*++

Routine Description:

    Retrieves the HNet_Connection and HNet_ConnectionProperties instances
    for a INetConnection guid

Arguments:

    piwsNamespace - WMI namespace

    pGuid - the guid of the INetConnection (i.e., guidId in its properties)

    ppwcoConnection - receives the HNet_Connection instance

    ppwcoProperties - receives the HNet_ConnectionProperties instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR bstrWQL = NULL;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pGuid);
    _ASSERT(NULL != ppwcoConnection);
    _ASSERT(NULL != ppwcoProperties);


    bstrWQL = SysAllocString(c_wszWQL);
    if (NULL != bstrWQL)
    {
        hr = GetConnectionInstanceByGuid(
                piwsNamespace,
                bstrWQL,
                pGuid,
                ppwcoConnection
                );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = GetPropInstanceFromConnInstance(
                piwsNamespace,
                *ppwcoConnection,
                ppwcoProperties
                );

        if (FAILED(hr))
        {
            (*ppwcoConnection)->Release();
            *ppwcoConnection = NULL;
        }
    }

    if (NULL != bstrWQL)
    {
        SysFreeString(bstrWQL);
    }

    return hr;
}


HRESULT
GetConnAndPropInstancesForHNC(
    IWbemServices *piwsNamespace,
    IHNetConnection *pConn,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

/*++

Routine Description:

    Retrieves the HNet_Connection and HNet_ConnectionProperties instances
    for an IHNetConnection.

Arguments:

    piwsNamespace - WMI namespace

    pConn - the IHNetConnection

    ppwcoConnection - receives the HNet_Connection instance

    ppwcoProperties - receives the HNet_ConnectionProperties instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    GUID *pGuid;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pConn);
    _ASSERT(NULL != ppwcoConnection);
    _ASSERT(NULL != ppwcoProperties);

    //
    // Find the items by GUID
    //

    hr = pConn->GetGuid(&pGuid);

    if (S_OK == hr)
    {
        hr = GetConnAndPropInstancesByGuid(
                piwsNamespace,
                pGuid,
                ppwcoConnection,
                ppwcoProperties
                );

        CoTaskMemFree(pGuid);
    }

    return hr;
}


HRESULT
GetPhonebookPathFromRasNetcon(
    INetConnection *pConn,
    LPWSTR *ppwstr
    )

/*++

Routine Description:

    Retrieves the phonebook path for an INetConnection that represents
    a RAS connection

Arguments:

    INetConnection - the RAS connection

    ppwstr - receives the phonebook path. The caller must call CoTaskMemFree for
             this pointer on success. On failure, the pointer receives NULL.


Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    INetRasConnection *pRasConn;
    RASCON_INFO RasConInfo;

    _ASSERT(NULL != pConn);
    _ASSERT(NULL != ppwstr);

    *ppwstr = NULL;

    //
    // QI for the INetRasConnection
    //

    hr = pConn->QueryInterface(
            IID_PPV_ARG(INetRasConnection, &pRasConn)
            );

    if (SUCCEEDED(hr))
    {
        //
        // Get the connection information
        //

        hr = pRasConn->GetRasConnectionInfo(&RasConInfo);

        if (SUCCEEDED(hr))
        {
            *ppwstr = RasConInfo.pszwPbkFile;

            //
            // Free the name pointer. The caller is responsible for
            // freeing the path pointer
            //

            CoTaskMemFree(RasConInfo.pszwEntryName);
        }

        pRasConn->Release();
    }

    return hr;
}


HRESULT
GetPortMappingBindingInstance(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    BSTR bstrConnectionPath,
    BSTR bstrProtocolPath,
    USHORT usPublicPort,
    IWbemClassObject **ppInstance
    )

/*++

Routine Description:

    Given the path to an HNet_Connection instance and and
    HNet_PortMappingProtocol instance, checks to see if a
    corresponding HNet_ConnectionPortMapping exists. If it
    doesn't, the instance is created. The HNet_ConnectionPortMapping
    instance -- existing or newly created -- is returned and must
    be released by the caller.

Arguments:

    piwsNamespace - the namespace to use

    bstrWQL - a BSTR containing the string "WQL"

    bstrConnectionPath - path to the HNet_Connection instance

    bstrProtocolPath - path to the HNet_PortMappingProtocol instance

    usPublicPort - the port of the port mapping protocol

    ppInstance - receives the HNet_ConnectionPortMapping instance

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    BSTR bstrQuery;
    BSTR bstr;
    LPWSTR wsz;
    LPWSTR wszConClause;
    LPWSTR wszProtClause;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);
    _ASSERT(NULL != bstrConnectionPath);
    _ASSERT(NULL != bstrProtocolPath);
    _ASSERT(NULL != ppInstance);

    //
    // Connection = "bstrConnectionPath" AND Protocol = "bstrProtocolPath"
    //

    hr = BuildEscapedQuotedEqualsString(
            &wszConClause,
            c_wszConnection,
            bstrConnectionPath
            );

    if (S_OK == hr)
    {
        hr = BuildEscapedQuotedEqualsString(
                &wszProtClause,
                c_wszProtocol,
                bstrProtocolPath
                );

        if (S_OK == hr)
        {
            hr = BuildAndString(
                    &wsz,
                    wszConClause,
                    wszProtClause
                    );

            delete [] wszProtClause;
        }

        delete [] wszConClause;
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wsz
                );

        delete [] wsz;
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;

        *ppInstance = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, ppInstance, &ulCount);

        if (FAILED(hr) || 1 != ulCount)
        {
            //
            // Instance does not exist -- create now. However, first make
            // sure that the protocol instance bstrProtocolPath refers to
            // actually exists.
            //

            hr = GetWmiObjectFromPath(
                    piwsNamespace,
                    bstrProtocolPath,
                    ppInstance
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // The protocol object exists -- release it and
                // continue with creating the new binding object.
                //

                (*ppInstance)->Release();
                *ppInstance = NULL;

                hr = SpawnNewInstance(
                        piwsNamespace,
                        c_wszHnetConnectionPortMapping,
                        ppInstance
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                VARIANT vt;

                //
                // Fill out new instance information
                //

                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = bstrConnectionPath;

                hr = (*ppInstance)->Put(
                        c_wszConnection,
                        0,
                        &vt,
                        NULL
                        );

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_BSTR(&vt) = bstrProtocolPath;

                    hr = (*ppInstance)->Put(
                            c_wszProtocol,
                            0,
                            &vt,
                            NULL
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = SetBooleanValue(
                            *ppInstance,
                            c_wszEnabled,
                            FALSE
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = SetBooleanValue(
                            *ppInstance,
                            c_wszNameActive,
                            FALSE
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_VT(&vt) = VT_I4;
                    V_I4(&vt) = 0;

                    hr = (*ppInstance)->Put(
                            c_wszTargetIPAddress,
                            0,
                            &vt,
                            NULL
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_VT(&vt) = VT_BSTR;
                    V_BSTR(&vt) = SysAllocString(L" ");

                    if (NULL != V_BSTR(&vt))
                    {
                        hr = (*ppInstance)->Put(
                                c_wszTargetName,
                                0,
                                &vt,
                                NULL
                                );

                        VariantClear(&vt);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    V_VT(&vt) = VT_I4;
                    V_I4(&vt) = usPublicPort;

                    hr = (*ppInstance)->Put(
                            c_wszTargetPort,
                            0,
                            &vt,
                            NULL
                            );
                }

                if (WBEM_S_NO_ERROR == hr)
                {
                    IWbemCallResult *pResult;

                    //
                    // Write new instance to the store
                    //

                    pResult = NULL;
                    hr = piwsNamespace->PutInstance(
                            *ppInstance,
                            WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL,
                            &pResult
                            );

                    if (WBEM_S_NO_ERROR == hr)
                    {
                        //
                        // Release the object, get the path from the result,
                        // and re-retrieve the object from the path
                        //

                        (*ppInstance)->Release();
                        *ppInstance = NULL;

                        hr = pResult->GetResultString(WBEM_INFINITE, &bstr);
                        if (WBEM_S_NO_ERROR == hr)
                        {
                            hr = GetWmiObjectFromPath(
                                    piwsNamespace,
                                    bstr,
                                    ppInstance
                                    );

                            SysFreeString(bstr);
                        }

                        pResult->Release();
                    }
                }
            }
        }
        else
        {
            //
            // Normalize enum hresult
            //

            hr = S_OK;
        }

        ValidateFinishedWCOEnum(piwsNamespace, pwcoEnum);
        pwcoEnum->Release();
    }

    return hr;
}




HRESULT
GetPropInstanceFromConnInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection,
    IWbemClassObject **ppwcoProperties
    )

/*++

Routine Description:

    Retrieves the HNet_ConnectionProperties instance associated with
    an HNet_Connection.

Arguments:

    piwsNamespace - WMI namespace

    bstrWQL - a BSTR that corresponds to "WQL"

    pwcoConnection - the HNet_Connection instance

    ppwcoProperties - receives the HNet_ConnectionProperties instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    OLECHAR wszBuffer[c_cchQueryBuffer + 1];
    OLECHAR *pwszPath = NULL;
    BSTR bstrPath;
    VARIANT vt;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoConnection);
    _ASSERT(NULL != ppwcoProperties);

    //
    // On debug builds, verify that our precomputed string lengths
    // match the actual lengths
    //

    _ASSERT(wcslen(c_wszConnectionPropertiesPathFormat) == c_cchConnectionPropertiesPathFormat);


    //
    // Get the guid for the connection
    //

    hr = pwcoConnection->Get(
            c_wszGuid,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Determine how much space we need for the path and decide
        // if we need to allocate a heap buffer.
        //

        ULONG cchLength =
            c_cchConnectionPropertiesPathFormat + SysStringLen(V_BSTR(&vt)) + 1;

        if (cchLength <= c_cchQueryBuffer)
        {
            //
            // The buffer is large enough. (Note that since the buffer on the
            // stack is one greater than the constant, the terminator is accounted
            // for.) Point our working pointer to the stack buffer.
            //

            pwszPath = wszBuffer;
        }
        else
        {
            //
            // Allocate a sufficient buffer from the heap. The +1 is for the
            // terminating nul
            //

            pwszPath = new OLECHAR[cchLength + 1];

            if (NULL == pwszPath)
            {
                hr = E_OUTOFMEMORY;
                pwszPath = wszBuffer;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Build the path string
            //

            int iBytes =
                _snwprintf(
                    pwszPath,
                    cchLength,
                    c_wszConnectionPropertiesPathFormat,
                    V_BSTR(&vt)
                    );

            _ASSERT(iBytes >= 0);

            //
            // Convert that to a BSTR
            //

            bstrPath = SysAllocString(pwszPath);
            if (NULL != bstrPath)
            {
                hr = GetWmiObjectFromPath(
                        piwsNamespace,
                        bstrPath,
                        ppwcoProperties
                        );
                
                SysFreeString(bstrPath);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        VariantClear(&vt);
    }

    //
    // Free the query buffer, if necessary
    //

    if (wszBuffer != pwszPath)
    {
        delete [] pwszPath;
    }

    return hr;
}


HRESULT
GetWmiObjectFromPath(
    IWbemServices *piwsNamespace,
    BSTR bstrPath,
    IWbemClassObject **ppwcoInstance
    )

/*++

Routine Description:

    Retrieves the IWbemClassObject corresponding to an object path.

Arguments:

    piwsNamespace - the WMI namespace the object lives in

    bstrPath - the path to the object

    ppwcoInstance - receives the object instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrPath);
    _ASSERT(NULL != ppwcoInstance);

    *ppwcoInstance = NULL;
    hr = piwsNamespace->GetObject(
            bstrPath,
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            ppwcoInstance,
            NULL
            );

    return hr;
}


HRESULT
GetWmiPathFromObject(
    IWbemClassObject *pwcoInstance,
    BSTR *pbstrPath
    )

/*++

Routine Description:

    Retrieves the object path corresponding to an IWbemClassObject instance.

Arguments:

    pwcoInstance - the object instance to retrieve the path of

    pbstrPath - receives the path to the object

Return Value:

    standard HRESULT

--*/
{
    HRESULT hr;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pbstrPath);

    hr = pwcoInstance->Get(
            c_wsz__Path,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        *pbstrPath = V_BSTR(&vt);

        //
        // BSTR ownership transferred to caller
        //
    }

    return hr;
}


HRESULT
HostAddrToIpPsz(
        DWORD   dwAddress,
    LPWSTR* ppszwNewStr
    )

        // Converts IP Address from host by order to string

{
        HRESULT hr = S_OK;
        LPWSTR  pszwStr;

        *ppszwNewStr = NULL;

        pszwStr = reinterpret_cast<LPWSTR>(CoTaskMemAlloc(sizeof(WCHAR) * 16));

        if ( NULL == pszwStr )
        {
                hr = E_OUTOFMEMORY;
        }
        else
        {
                swprintf( pszwStr,
                                  TEXT("%u.%u.%u.%u"),
                                  (dwAddress&0xff),
                                  ((dwAddress>>8)&0x0ff),
                                  ((dwAddress>>16)&0x0ff),
                                  ((dwAddress>>24)&0x0ff) );

                *ppszwNewStr = pszwStr;
        }

        return hr;
}


DWORD
IpPszToHostAddr(
    LPCWSTR cp
    )

    // Converts an IP address represented as a string to
    // host byte order.
    //
{
    DWORD val, base, n;
    TCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == TEXT('0'))
        base = 8, cp++;
    if (*cp == TEXT('x') || *cp == TEXT('X'))
        base = 16, cp++;
    while (c = *cp)
    {
        if ((c >= TEXT('0')) && (c <= TEXT('9')))
        {
            val = (val * base) + (c - TEXT('0'));
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= TEXT('0')) && (c <= TEXT('9'))) ||
              ((c >= TEXT('A')) && (c <= TEXT('F'))) ||
              ((c >= TEXT('a')) && (c <= TEXT('f'))) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= TEXT('a')) && (c <= TEXT('f')))
                            ? TEXT('a')
                            : TEXT('A') ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == TEXT('.'))
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
            return (DWORD) -1;
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != TEXT(' ')))
        return 0xffffffff;

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD) (pp - parts);
    switch (n)
    {
    case 1:             // a -- 32 bits
        val = parts[0];
        break;

    case 2:             // a.b -- 8.24 bits
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:             // a.b.c -- 8.8.16 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
            (parts[2] & 0xffff);
        break;

    case 4:             // a.b.c.d -- 8.8.8.8 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        return 0xffffffff;
    }

    return val;
}


BOOLEAN
IsRrasConfigured()

/*++

Routine Description:

    This routine is invoked to determine whether Routing and Remote Access
    is configured.

Arguments:

    None.

Return Value:

    TRUE if RRAS is configured, FALSE otherwise.

--*/

{
    DWORD dwType;
    DWORD dwValue;
    DWORD dwValueSize;
    BOOLEAN fRrasConfigured = FALSE;
    HKEY hKey;
    LONG lError;

    lError =
        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            c_wszRrasConfigurationPath,
            0,
            KEY_READ,
            &hKey
            );

    if (ERROR_SUCCESS == lError)
    {
        dwValueSize = sizeof(dwValue);
        lError = 
            RegQueryValueEx(
                hKey,
                c_wszRrasConfigurationValue,
                NULL,
                &dwType,
                reinterpret_cast<LPBYTE>(&dwValue),
                &dwValueSize
                );

        fRrasConfigured = (ERROR_SUCCESS == lError
                           && REG_DWORD == dwType
                           && 0 != dwValue);

        RegCloseKey(hKey);
    }

    return fRrasConfigured;
} // IsRrasConfigured


BOOLEAN
IsServiceRunning(
    LPCWSTR pwszServiceName
    )

/*++

Routine Description:

    Determines if a service is in a running state.

Arguments:

    pwszServiceName - the service to check

Return Value:

    TRUE if the service is in the running or start_pending state,
    FALSE otherwise

--*/

{
    BOOLEAN fServiceRunning = FALSE;
    SC_HANDLE hScm;
    SC_HANDLE hService;
    SERVICE_STATUS Status;

    hScm = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, GENERIC_READ);
    if (NULL != hScm)
    {
        hService = OpenService(hScm, pwszServiceName, GENERIC_READ);
        if (NULL != hService)
        {
            if (QueryServiceStatus(hService, &Status))
            {
                fServiceRunning =
                    (SERVICE_RUNNING == Status.dwCurrentState
                     || SERVICE_START_PENDING == Status.dwCurrentState);
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hScm);
    }

    return fServiceRunning;
} // IsServiceRunning


HRESULT
MapGuidStringToAdapterIndex(
    LPCWSTR pwszGuid,
    ULONG *pulIndex
    )

/*++

Routine Description:

    This routine is called to match the GUID in the given string to
    an adapter in the list returned by calling GetInterfaceInfo.

Arguments:

    pwszGuid - identifies the GUID of the adapter to be found. The GUID string
               must be in the format returned by RtlGuidToUnicodeString

    pulIndex - receives the index of the adapter

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    ULONG ulError;
    ULONG i;
    ULONG GuidLength;
    PIP_INTERFACE_INFO Info;
    PWCHAR Name;
    ULONG NameLength;
    ULONG Size;

    _ASSERT(NULL != pwszGuid);
    _ASSERT(NULL != pulIndex);

    Size = 0;
    GuidLength = wcslen(pwszGuid);

    ulError = GetInterfaceInfo(NULL, &Size);
    if (ERROR_INSUFFICIENT_BUFFER == ulError)
    {
        Info = new IP_INTERFACE_INFO[Size];
        if (NULL != Info)
        {
            ulError = GetInterfaceInfo(Info, &Size);
            if (NO_ERROR == ulError)
            {
                for (i = 0; i < (ULONG)Info->NumAdapters; i++)
                {
                    NameLength = wcslen(Info->Adapter[i].Name);
                    if (NameLength < GuidLength) { continue; }

                    Name = Info->Adapter[i].Name + (NameLength - GuidLength);
                    if (_wcsicmp(pwszGuid, Name) == 0)
                    {
                        *pulIndex = Info->Adapter[i].Index;
                        break;
                    }
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ulError);
            }

            delete [] Info;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ulError);
    }

    return hr;
}


HRESULT
OpenRegKey(
    PHANDLE Key,
    ACCESS_MASK DesiredAccess,
    PCWSTR Name
    )

/*++

Routine Description:

    This routine is invoked to open a given registry key.

Arguments:

    Key - receives the opened key

    DesiredAccess - specifies the requested access

    Name - specifies the key to be opened

Return Value:

    HRESULT - NT status code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    RtlInitUnicodeString(&UnicodeString, Name);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    return NtOpenKey(Key, DesiredAccess, &ObjectAttributes);
} // OpenRegKey


BOOLEAN
PortMappingProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usPort,
    UCHAR ucIPProtocol
    )

/*++

Routine Description:

    Checks if an port mapping protocol already exists that has the
    specified protocol and port.


Arguments:

    piwsNamespace - the namespace to use

    bstrWQL - a BSTR containing "WQL"

    ucProtocol - the protocol number to check for

    usPort - the port to check for

Return Value:

    BOOLEAN -- TRUE if the port mapping protocol exists; FALSE otherwise

--*/

{
    BSTR bstr;
    BOOLEAN fDuplicate = FALSE;
    HRESULT hr = S_OK;
    int iBytes;
    IEnumWbemClassObject *pwcoEnum;
    IWbemClassObject *pwcoInstance;
    ULONG ulObjs;
    OLECHAR wszWhereClause[c_cchQueryBuffer + 1];

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);
    _ASSERT(0 == wcscmp(bstrWQL, L"WQL"));

    //
    // Build the query string
    //

    iBytes = _snwprintf(
                wszWhereClause,
                c_cchQueryBuffer,
                c_wszPortMappingProtocolQueryFormat,
                usPort,
                ucIPProtocol
                );

    if (iBytes >= 0)
    {
        //
        // String fit into buffer; make sure it's null terminated
        //

        wszWhereClause[c_cchQueryBuffer] = L'\0';
    }
    else
    {
        //
        // For some reason the string didn't fit into the buffer...
        //

        hr = E_UNEXPECTED;
        _ASSERT(FALSE);
    }

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstr,
                c_wszStar,
                c_wszHnetPortMappingProtocol,
                wszWhereClause
                );
    }

    if (S_OK == hr)
    {
        //
        // Execute the query
        //

        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstr,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstr);
    }

    if (S_OK == hr)
    {
        //
        // Attempt to retrieve an item from the enum. If we're successful,
        // this is a duplicate protocol.
        //

        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                &pwcoInstance,
                &ulObjs
                );

        if (SUCCEEDED(hr) && 1 == ulObjs)
        {
            //
            // It's a duplicate
            //

            fDuplicate = TRUE;
            pwcoInstance->Release();
        }

        pwcoEnum->Release();
    }

    return fDuplicate;
} // PortMappingProtocolExists


HRESULT
QueryRegValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    )

/*++

Routine Description:

    This routine is called to obtain the value of a registry key.

Arguments:

    Key - the key to be queried

    ValueName - the value to be queried

    Information - receives a pointer to the information read. On success,
                  the caller must HeapFree this pointer

Return Value:

    HRESULT - NT status code.

--*/

{
    UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    ULONG InformationLength;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString(&UnicodeString, ValueName);

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    InformationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    //
    // Read the value's size
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        *Information = NULL;
        return status;
    }

    //
    // Allocate space for the value's size
    //

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION) HeapAlloc(
                                                        GetProcessHeap(),
                                                        0,
                                                        InformationLength+2
                                                        );
    if (!*Information) { return STATUS_NO_MEMORY; }

    //
    // Read the value's data
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );
    if (!NT_SUCCESS(status))
    {
        HeapFree(GetProcessHeap(), 0, *Information);
        *Information = NULL;
    }

    return status;

} // QueryRegValueKey

HRESULT
ReadDhcpScopeSettings(
    DWORD *pdwScopeAddress,
    DWORD *pdwScopeMask
    )

{
    _ASSERT(NULL != pdwScopeAddress);
    _ASSERT(NULL != pdwScopeMask);

    //
    // This routine never fails. Set default address/mask
    // (192.168.0.1/255.255.255.255, in network order)
    //

    *pdwScopeAddress = 0x0100a8c0;
    *pdwScopeMask = 0x00ffffff;

    //
    // $$TODO: Check to see if these values are overiddent
    // through a registry entry
    //

    return S_OK;
}


HRESULT
RetrieveSingleInstance(
    IWbemServices *piwsNamespace,
    const OLECHAR *pwszClass,
    BOOLEAN fCreate,
    IWbemClassObject **ppwcoInstance
    )

/*++

Routine Description:

    Retrieves a single instance of a class from the WMI store. If there
    are more than one instance, every instance after the first is deleted,
    and an assertion is raised. If there are no instances, one is optionally
    created.

Arguments:

    piwsNamespace - WMI namespace

    pwszClass - the class to retrieve the instance of

    fCreate - create an instance if one does not already exist

    ppwcoInstance - receive the instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum = NULL;
    BSTR bstrClass = NULL;
    ULONG ulCount = 0;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwszClass);
    _ASSERT(NULL != ppwcoInstance);

    //
    // Allocate the BSTR for the class name
    //

    bstrClass = SysAllocString(pwszClass);
    if (NULL == bstrClass)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Query the WMI store for instances of the class
    //

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = piwsNamespace->CreateInstanceEnum(
            bstrClass,
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pwcoEnum
            );

        SysFreeString(bstrClass);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Attempt to retrieve an actual instance from the enumeration.
        // Even if there are zero instances, WMI considers returning a
        // zero-element enumerator success.
        //

        *ppwcoInstance = NULL;
        hr = pwcoEnum->Next(
                WBEM_INFINITE,
                1,
                ppwcoInstance,
                &ulCount
                );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // Normalize return value
            //

            hr = S_OK;

            //
            // Validate that enumeration is now empty
            //

            ValidateFinishedWCOEnum(piwsNamespace, pwcoEnum);

        }
        else
        {
            if (WBEM_S_FALSE == hr)
            {
                //
                // No items in enumeration.
                //

                if (fCreate)
                {
                    //
                    // Create a new object instance
                    //

                    hr = SpawnNewInstance(
                            piwsNamespace,
                            pwszClass,
                            ppwcoInstance
                            );
                }
                else
                {
                    //
                    // Change this to an error code. This
                    // is deliberately not a WBEM error code.
                    //

                    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND);
                }
            }
        }

        pwcoEnum->Release();
    }

    return hr;
}


HRESULT
SetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN fBoolean
    )

/*++

Routine Description:

    Retrieves a boolean property from a Wbem object.

Arguments:

    pwcoInstance - the object to get the property from

    pwszProperty - the property to retrieve

    pfBoolean - received the property value

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(NULL != pwcoInstance);
    _ASSERT(NULL != pwszProperty);

    VariantInit(&vt);
    V_VT(&vt) = VT_BOOL;
    V_BOOL(&vt) = (fBoolean ? VARIANT_TRUE : VARIANT_FALSE);

    hr = pwcoInstance->Put(
            pwszProperty,
            0,
            &vt,
            NULL
            );

    return hr;
}


VOID
SetProxyBlanket(
    IUnknown *pUnk
    )

/*++

Routine Description:

    Sets the standard COM security settings on the proxy for an
    object.

Arguments:

    pUnk - the object to set the proxy blanket on

Return Value:

    None. Even if the CoSetProxyBlanket calls fail, pUnk remains
    in a usable state. Failure is expected in certain contexts, such
    as when, for example, we're being called w/in the netman process --
    in this case, we have direct pointers to the netman objects, instead
    of going through a proxy.

--*/

{
    HRESULT hr;

    _ASSERT(pUnk);

    hr = CoSetProxyBlanket(
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE
            );

    if (SUCCEEDED(hr))
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket(
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE
                    );

            pUnkSet->Release();
        }
    }
}


HRESULT
SpawnNewInstance(
    IWbemServices *piwsNamespace,
    LPCWSTR wszClass,
    IWbemClassObject **ppwcoInstance
    )

/*++

Routine Description:

    Creates a new instance of a class

Arguments:

    piwsNamespace - the namespace the class is in

    wszClass - the class to create the instance of

    ppwcoInstance -- receives the created instance

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr;
    BSTR bstr;
    IWbemClassObject *pwcoClass;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != wszClass);
    _ASSERT(NULL != ppwcoInstance);

    *ppwcoInstance = NULL;

    bstr = SysAllocString(wszClass);
    if (NULL != bstr)
    {
        pwcoClass = NULL;
        hr = piwsNamespace->GetObject(
                bstr,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pwcoClass,
                NULL
                );

        SysFreeString(bstr);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = pwcoClass->SpawnInstance(0, ppwcoInstance);
        pwcoClass->Release();
    }

    return hr;
}


DWORD
StartOrUpdateService(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to start the SharedAccess service. It will
    also mark the service as auto-start. If the service is already running,
    it will send a IPNATHLP_CONTROL_UPDATE_CONNECTION notification

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;
    ULONG Timeout;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return GetLastError(); }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Mark it as auto-start
        //

        ChangeServiceConfig(
            ServiceHandle,
            SERVICE_NO_CHANGE,
            SERVICE_AUTO_START,
            SERVICE_NO_CHANGE,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

        // if we are in ICS Upgrade, don't start the SharedAccess service because the
        // service may have problem in starting up during GUI Mode Setup.
        HANDLE hIcsUpgradeEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, c_wszIcsUpgradeEventName);
        if (NULL != hIcsUpgradeEvent)
        {
            CloseHandle(hIcsUpgradeEvent);
            Error = NO_ERROR;
            break;
        }

        //
        // Attempt to start the service
        //

        if (!StartService(ServiceHandle, 0, NULL)) {
            Error = GetLastError();
            if (Error == ERROR_SERVICE_ALREADY_RUNNING)
            {
                //
                // Send control notification
                //

                Error = NO_ERROR;

                if (!ControlService(
                        ServiceHandle,
                        IPNATHLP_CONTROL_UPDATE_CONNECTION,
                        &ServiceStatus
                        ))
                {
                    Error = GetLastError();
                }
            }
            break;
        }

        //
        // Wait for the service to start
        //

        Timeout = 50;
        Error = ERROR_CAN_NOT_COMPLETE;

        do {

            //
            // Query the service's state
            //

            if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                Error = GetLastError(); break;
            }

            //
            // See if the service has started
            //

            if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                Error = NO_ERROR; break;
            } else if (ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
                       ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                break;
            }

            //
            // Wait a little longer
            //

            Sleep(1000);

        } while(Timeout--);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

    return Error;
}


VOID
StopService(
    VOID
    )

/*++

Routine Description:

    Stops the SharedAccess service, and marks it as demand start.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return; }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Mark it as demand-start
        //

        ChangeServiceConfig(
            ServiceHandle,
            SERVICE_NO_CHANGE,
            SERVICE_DEMAND_START,
            SERVICE_NO_CHANGE,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

        //
        // Attempt to stop the service
        //

        ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

}


HRESULT
UpdateOrStopService(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    DWORD dwControlCode
    )

/*++

Routine Description:

    Checks to see if there are any firewalled or ICS connections. If so,
    an update request is sent to the SharedAccess service; if not, the
    service is stopped

Arguments:

    piwsNamespace - WMI namespace

    bstrWQL - a BSTR that corresponds to "WQL"

    dwControlCode - the kind of update to send

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != bstrWQL);

    //
    // See if we have any connections that are marked as
    // * ICS public
    // * ICS private
    // * firewalled
    //
    // (We don't care about bridged connections, as the SharedAccess service
    // doesn't have anything to do with the bridge.)
    //

    bstrQuery = SysAllocString(c_wszServiceCheckQuery);
    if (NULL != bstrQuery)
    {
        pwcoEnum = NULL;
        hr = piwsNamespace->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;
        IWbemClassObject *pwcoObj;

        //
        // Check to see if the query returned anything
        //

        pwcoObj = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoObj, &ulCount);

        if (SUCCEEDED(hr))
        {
            if (1 == ulCount)
            {
                //
                // Object retrieved -- need to update service
                //

                pwcoObj->Release();
                UpdateService(dwControlCode);
            }
            else
            {
                //
                // No object retrieved -- stop service
                //

                StopService();
            }
        }

        pwcoEnum->Release();
    }

    return hr;
}


VOID
UpdateService(
    DWORD dwControlCode
    )

/*++

Routine Description:

    Sends a control code to the SharedAccess service

Arguments:

    dwControlCode - the code to send

Return Value:

    none.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return; }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_wszSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Send the control notification
        //

        ControlService(ServiceHandle, dwControlCode, &ServiceStatus);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

}


VOID
ValidateFinishedWCOEnum(
    IWbemServices *piwsNamespace,
    IEnumWbemClassObject *pwcoEnum
    )

/*++

Routine Description:

    Checks to see that a WCO enumerator is finished (i.e., all objects
    have been retrieved). If the enumerator is not finished, any object
    instances that are retrieved will be deleted, and an assertion will
    be raised on checked builds.

Arguments:

    piwsNamespace - the namespace the enumeration is from

    pwcoEnum - the enumeration to validate

Return Value:

    None.

--*/

{

    HRESULT hr;
    IWbemClassObject *pwcoInstance = NULL;
    ULONG ulCount = 0;

    _ASSERT(piwsNamespace);
    _ASSERT(pwcoEnum);

    do
    {
        pwcoInstance = NULL;
        hr = pwcoEnum->Next(
            WBEM_INFINITE,
            1,
            &pwcoInstance,
            &ulCount
            );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            //
            // We got an unexpected instance.
            //

            _ASSERT(FALSE);

            //
            // Delete the instance. Don't care about return value.
            //

            DeleteWmiInstance(
                piwsNamespace,
                pwcoInstance
                );

            pwcoInstance->Release();
        }
    }
    while (SUCCEEDED(hr) && 1 == ulCount);
}


HRESULT
SendPortMappingListChangeNotification()

{
    HRESULT hr = S_OK;
    ISharedAccessUpdate* pUpdate = NULL;

    if ( IsServiceRunning(c_wszSharedAccess) )
    {
        hr = CoCreateInstance(
                CLSID_SAUpdate,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                IID_PPV_ARG( ISharedAccessUpdate, &pUpdate )
                );

        if ( SUCCEEDED(hr) )
        {
            hr = pUpdate->PortMappingListChanged();

            pUpdate->Release();
        }
    }

    return hr;
}

HRESULT
SignalModifiedConnection(
    GUID                *pGUID
    )
/*++

Routine Description:

    Signals a modification to a network connection (refreshes the UI)

Arguments:

    pGUID               The GUID of the modified connection

Return Value:

    Result of the operation

--*/
{
    HRESULT             hr;
    INetConnection      *pConn;

    hr = FindINetConnectionByGuid( pGUID, &pConn );

    if( SUCCEEDED(hr) )
    {
        INetConnectionRefresh   *pNetConRefresh;

        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA | CLSCTX_NO_CODE_DOWNLOAD,
                IID_PPV_ARG(INetConnectionRefresh, &pNetConRefresh)
                );

        if( SUCCEEDED(hr) )
        {
            SetProxyBlanket(pNetConRefresh);
            hr = pNetConRefresh->ConnectionModified(pConn);
            pNetConRefresh->Release();
        }

        pConn->Release();
    }

    return hr;
}

HRESULT
SignalNewConnection(
    GUID                *pGUID
    )
/*++

Routine Description:

    Signals that a new network connection has been created (refreshes the UI)

Arguments:

    pGUID               The GUID of the new connection

Return Value:

    Result of the operation

--*/
{
    HRESULT             hr;
    INetConnection      *pConn;

    hr = FindINetConnectionByGuid( pGUID, &pConn );

    if( SUCCEEDED(hr) )
    {
        INetConnectionRefresh   *pNetConRefresh;

        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA | CLSCTX_NO_CODE_DOWNLOAD,
                IID_PPV_ARG(INetConnectionRefresh, &pNetConRefresh)
                );

        if( SUCCEEDED(hr) )
        {
            SetProxyBlanket(pNetConRefresh);
            hr = pNetConRefresh->ConnectionAdded(pConn);
            pNetConRefresh->Release();
        }

        pConn->Release();
    }

    return hr;
}

HRESULT
SignalDeletedConnection(
    GUID            *pGUID
    )
/*++

Routine Description:

    Signals that a network connection has been deleted (refreshes the UI)

Arguments:

    pGUID               The GUID of the deleted connection

Return Value:

    Result of the operation

--*/
{
    HRESULT                 hr;
    INetConnectionRefresh   *pNetConRefresh;

    hr = CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA | CLSCTX_NO_CODE_DOWNLOAD,
            IID_PPV_ARG(INetConnectionRefresh, &pNetConRefresh)
            );

    if( SUCCEEDED(hr) )
    {
        hr = pNetConRefresh->ConnectionDeleted(pGUID);
        pNetConRefresh->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\resourc2.h ===
// stuff shared between hnetcfg and icsdclt

// used by lvx stuff
#define IID_Checked           50
#define IID_Unchecked         51
#define IID_DisabledUnchecked 60
#define IID_DisabledChecked   61
#define IID_Connection_ICF_ICS 62

#define PID_SS_SharedAccessServices     559
#define DID_SS_Service                  557
#define PID_SS_PleaseWait               558

#define CID_SS_LV_Services              1560
#define CID_SS_PB_Add                   1561
#define CID_SS_PB_Delete                1562
#define CID_SS_PB_Edit                  1563
#define CID_SS_EB_InternalPort          1551
#define CID_SS_EB_ExternalPort          1553
#define CID_SS_EB_Service               1552
#define CID_SS_PB_Tcp                   1554
#define CID_SS_PB_Udp                   1555
#define CID_SS_EB_Address               1556

#define SID_PopupTitle                  361
#define SID_TypeEntryName               532
#define SID_TypePortNumber              534
#define SID_DuplicatePortNumber         539
#define SID_NoDeleteSelection           541
#define SID_NoModifySelection           543
#define SID_SS_TypeAddress              544
#define SID_OP_GenericPortMappingError  501
#define SID_OP_OurGatewayError          503
#define SID_OP_TheirGatewayError        504
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\hncstrs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C S T R S . C P P
//
//  Contents:   Constant string definitions
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

const OLECHAR c_wszNamespace[] = L"\\\\.\\Root\\Microsoft\\HomeNet";
const OLECHAR c_wszWQL[] = L"WQL";
const OLECHAR c_wszStar[] = L"*";
const OLECHAR c_wszHnetConnection[] = L"HNet_Connection";
const OLECHAR c_wszHnetProperties[] = L"HNet_ConnectionProperties";
const OLECHAR c_wszHnetApplicationProtocol[] = L"HNet_ApplicationProtocol";
const OLECHAR c_wszHnetPortMappingProtocol[] = L"HNet_PortMappingProtocol";
const OLECHAR c_wszHnetConnectionPortMapping[] = L"HNet_ConnectionPortMapping2";
const OLECHAR c_wszHnetFWLoggingSettings[] = L"HNet_FirewallLoggingSettings";
const OLECHAR c_wszHnetIcsSettings[] = L"HNet_IcsSettings";
const OLECHAR c_wszHnetResponseRange[] = L"HNet_ResponseRange";
const OLECHAR c_wszPath[] = L"Path";
const OLECHAR c_wszMaxFileSize[] = L"MaxFileSize";
const OLECHAR c_wszLogDroppedPackets[] = L"LogDroppedPackets";
const OLECHAR c_wszLogConnections[] = L"LogConnections";
const OLECHAR c_wszDhcpEnabled[] = L"DhcpEnabled";
const OLECHAR c_wszDnsEnabled[] = L"DnsEnabled";

const OLECHAR c_wszName[] = L"Name";
const OLECHAR c_wszDeviceName[] = L"DeviceName";
const OLECHAR c_wszEnabled[] = L"Enabled";
const OLECHAR c_wszBuiltIn[] = L"BuiltIn";
const OLECHAR c_wszOutgoingIPProtocol[] = L"OutgoingIPProtocol";
const OLECHAR c_wszOutgoingPort[] = L"OutgoingPort";
const OLECHAR c_wszResponseCount[] = L"ResponseCount";
const OLECHAR c_wszResponseArray[] = L"ResponseArray";
const OLECHAR c_wszIPProtocol[] = L"IPProtocol";
const OLECHAR c_wszStartPort[] = L"StartPort";
const OLECHAR c_wszEndPort[] = L"EndPort";
const OLECHAR c_wszPort[] = L"Port";
const OLECHAR c_wszId[] = L"Id";

const OLECHAR c_wszConnection[] = L"Connection";
const OLECHAR c_wszProtocol[] = L"Protocol";
const OLECHAR c_wszTargetName[] = L"TargetName";
const OLECHAR c_wszTargetIPAddress[] = L"TargetIPAddress";
const OLECHAR c_wszTargetPort[] = L"TargetPort";
const OLECHAR c_wszNameActive[] = L"NameActive";

const OLECHAR c_wszIsLanConnection[] = L"IsLanConnection";
const OLECHAR c_wszIsFirewalled[] = L"IsFirewalled";
const OLECHAR c_wszIsIcsPublic[] = L"IsIcsPublic";
const OLECHAR c_wszIsIcsPrivate[] = L"IsIcsPrivate";
const OLECHAR c_wszIsBridgeMember[] = L"IsBridgeMember";
const OLECHAR c_wszIsBridge[] = L"IsBridge";
const OLECHAR c_wszPhonebookPath[] = L"PhonebookPath";
const OLECHAR c_wszGuid[] = L"Guid";

const OLECHAR c_wszHnetFwIcmpSettings[] = L"HNet_FwIcmpSettings";
const OLECHAR c_wszAllowOutboundDestinationUnreachable[] = L"AllowOutboundDestinationUnreachable";
const OLECHAR c_wszAllowOutboundSourceQuench[] = L"AllowOutboundSourceQuench";
const OLECHAR c_wszAllowRedirect[] = L"AllowRedirect";
const OLECHAR c_wszAllowInboundEchoRequest[] = L"AllowInboundEchoRequest";
const OLECHAR c_wszAllowInboundRouterRequest[] = L"AllowInboundRouterRequest";
const OLECHAR c_wszAllowOutboundTimeExceeded[] = L"AllowOutboundTimeExceeded";
const OLECHAR c_wszAllowOutboundParameterProblem[] = L"AllowOutboundParameterProblem";
const OLECHAR c_wszAllowInboundTimestampRequest[] = L"AllowInboundTimestampRequest";
const OLECHAR c_wszAllowInboundMaskRequest[] = L"AllowInboundMaskRequest";
const OLECHAR c_wszDefault[] = L"Default";
const OLECHAR c_wszDefaultIcmpSettingsPath[] = L"HNet_FwIcmpSettings.Name=\"Default\"";

const OLECHAR c_wszHnetConnectionIcmpSetting[] = L"HNet_ConnectionIcmpSetting";
const OLECHAR c_wszIcmpSettings[] = L"IcmpSettings";

const OLECHAR c_wszHnetBridgeMember[] = L"HNet_BridgeMember";
const OLECHAR c_wszBridge[] = L"Bridge";
const OLECHAR c_wszMember[] = L"Member";

const OLECHAR c_wszSelect[] = L"SELECT";
const OLECHAR c_wszFrom[] = L"FROM";
const OLECHAR c_wszWhere[] = L"WHERE";
const OLECHAR c_wsz__Path[] = L"__Relpath";
const OLECHAR c_wszReferencesOf[] = L"REFERENCES OF {";
const OLECHAR c_wszWhereResultClass[] = L"} WHERE ResultClass = ";
const OLECHAR c_wszAssociatorsOf[] = L"ASSOCIATORS OF {";
const OLECHAR c_wszWhereAssocClass[] = L"} WHERE AssocClass = ";

const OLECHAR c_wszPortMappingProtocolQueryFormat[] = L"Port = %u AND IPProtocol = %u";
const OLECHAR c_wszApplicationProtocolQueryFormat[] = L"OutgoingPort = %u AND OutgoingIPProtocol = %u";
const OLECHAR c_wszConnectionPropertiesPathFormat[] = L"HNet_ConnectionProperties.Connection=\"HNet_Connection.Guid=\\\"%s\\\"\"";

const OLECHAR c_wszBackupIpConfiguration[] = L"HNet_BackupIpConfiguration";
const OLECHAR c_wszEnableDHCP[] = L"EnableDHCP";
const OLECHAR c_wszInterfaces[] = L"Interfaces";
const OLECHAR c_wszIPAddress[] = L"IPAddress";
const OLECHAR c_wszSubnetMask[] = L"SubnetMask";
const OLECHAR c_wszDefaultGateway[] = L"DefaultGateway";
const OLECHAR c_wszTcpipParametersKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip"
    L"\\Parameters";
const OLECHAR c_wszZeroIpAddress[] = L"0.0.0.0";

const OLECHAR c_wszSharedAccess[] = L"SharedAccess";
const OLECHAR c_wszDevice[] = L"\\Device\\";
const OLECHAR c_wszServiceCheckQuery[] =
    L"SELECT * FROM HNet_ConnectionProperties WHERE IsFirewalled != FALSE"
    L" or IsIcsPublic != FALSE or IsIcsPrivate != FALSE";

const OLECHAR c_wszHnetConnectionAutoconfig[] = L"HNet_ConnectionAutoconfig";

// ICS Upgrade named event (has to be the same name in net\config\shell\netsetup\icsupgrd.h)
const OLECHAR c_wszIcsUpgradeEventName[] = L"IcsUpgradeEventName_";

//
// Commonly used string lengths. Generating these at compile time
// saves us a large number of wcslen calls. On debug builds, these
// values are compared with the output of wcslen, and an assertion is
// raised if the values do not match.
//

#define STRING_LENGTH(pwz) \
    (sizeof((pwz)) / sizeof((pwz)[0]) - 1)

const ULONG c_cchSelect = STRING_LENGTH(c_wszSelect);
const ULONG c_cchFrom = STRING_LENGTH(c_wszFrom);
const ULONG c_cchWhere = STRING_LENGTH(c_wszWhere);
const ULONG c_cchReferencesOf = STRING_LENGTH(c_wszReferencesOf);
const ULONG c_cchWhereResultClass = STRING_LENGTH(c_wszWhereResultClass);
const ULONG c_cchAssociatorsOf = STRING_LENGTH(c_wszAssociatorsOf);
const ULONG c_cchWhereAssocClass = STRING_LENGTH(c_wszWhereAssocClass);
const ULONG c_cchConnection = STRING_LENGTH(c_wszConnection);
const ULONG c_cchConnectionPropertiesPathFormat = STRING_LENGTH(c_wszConnectionPropertiesPathFormat);

//
// Bindings-related strings
//

const WCHAR c_wszSBridgeMPID[]              = L"ms_bridgemp";
const WCHAR c_wszSBridgeSID[]               = L"ms_bridge";
const WCHAR *c_pwszBridgeBindExceptions[]   = {
                                                L"ms_ndisuio", // Need NDISUIO for wireless adapters; want the wireless UI
                                                               // even when the adapter is bridged.
                                                NULL
                                              };

//
// String constants used for IsRrasConfigured.
//

const WCHAR c_wszRrasConfigurationPath[] = L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess";
const WCHAR c_wszRrasConfigurationValue[] = L"ConfigurationFlags"; 



//
// Strings that are used in WinBom homenet install
//
const TCHAR c_szEnableFirewall[] = _T("EnableFirewall");
const TCHAR c_szYes[] = _T("Yes");
const TCHAR c_szNo[] = _T("No");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\saui.cpp ===
#include "pch.h"
#pragma hdrstop

#include <shellapi.h>
#include <rasdlg.h>
#include "sautil.h"
#include "resource.h"
#include "beacon.h"
#include "htmlhelp.h"
#include "lm.h"
#include <shlobj.h>

// global(s)
HINSTANCE g_hinstDll;
LPCTSTR g_contextId = NULL;


// external(s)
extern "C" {
    extern BOOL WINAPI LinkWindow_RegisterClass();
}

// static(s)
static DWORD g_adwSaHelp[] =
{
    CID_SA_PB_Shared,       HID_SA_PB_Shared,
    CID_SA_GB_Shared,       -1,
    CID_SA_PB_DemandDial,   HID_SA_PB_DemandDial,
    CID_SA_PB_Settings,     HID_SA_PB_Settings,
    CID_SA_GB_PrivateLan,   -1,
//  CID_SA_ST_PrivateLan,   HID_SA_LB_PrivateLan,
    CID_SA_LB_PrivateLan,   HID_SA_LB_PrivateLan,
    CID_FW_PB_Firewalled,   HID_FW_PB_Firewalled,   
    CID_SA_ST_ICFLink,      HID_SA_ST_ICFLink,      
    CID_SA_EB_PrivateLan,   HID_SA_EB_PrivateLan,   
    CID_SA_PB_Beacon,       HID_SA_PB_Beacon,       
    CID_SA_ST_ICSLink,      HID_SA_ST_ICSLink,
    CID_SA_ST_HNWLink,      HID_SA_ST_HNWLink,
    0, 0
};
static TCHAR g_pszFirewallRegKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetworking\\PersonalFirewall");
static TCHAR g_pszDisableFirewallWarningValue[] = TEXT("ShowDisableFirewallWarning");

// replacement for (private) PBENTRY
typedef struct _BILLSPBENTRY
{
    TCHAR pszPhonebookPath[MAX_PATH];
    TCHAR pszEntryName[RAS_MaxEntryName];
    DWORD dwType;
    GUID  guidId;   // somewhere for pGuid to point
    GUID* pGuid;
    DWORD dwfExcludedProtocols;
} BILLSPBENTRY;

// Phonebook Entry common block.
//
typedef struct _EINFO
{
    // RAS API arguments.
    //
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
//  RASENTRYDLG* pApiArgs;
    HWND hwndOwner; // bhanlon: so that EuHomenetCommit error dialogs work.

    // Set true by property sheet or wizard when changes should be committed
    // before returning from the API.  Does not apply in ShellOwned-mode where
    // the API returns before the property sheet is dismissed.
    //
//    BOOL fCommit;

    // Set if we have been called via RouterEntryDlg.
    //
    BOOL fRouter;

    // Set if fRouter is TRUE and pszRouter refers to a remote machine.
    //
//  BOOL fRemote;

    // Set if pszRouter is an NT4 steelhead machine.  Valid only
    // if fRouter is true.
    //
//  BOOL fNt4Router;

    //Set if pszRouter is an Windows 2000 machine, Valid only if
    // fRouter is true
//  BOOL fW2kRouter;

    // The name of the server in "\\server" form or NULL if none (or if
    // 'fRouter' is not set).
    //
//  TCHAR* pszRouter;

    // Set by the add entry or add interface wizards if user chooses to end
    // the wizard and go edit the properties directly.  When this flag is set
    // the wizard should *not* call EuFree before returning.
    //
//  BOOL fChainPropertySheet;

    // Phonebook settings read from the phonebook file.  All access should be
    // thru 'pFile' as 'file' will only be used in cases where the open
    // phonebook is not passed thru the reserved word hack.
    //
//    PBFILE* pFile;
//    PBFILE file;

    // Global preferences read via phonebook library.  All access should be
    // thru 'pUser' as 'user' will only be used in cases where the preferences
    // are not passed thru the reserved word hack.
    //
//    PBUSER* pUser;
//    PBUSER user;

    // Set if "no user before logon" mode.
    //
//  BOOL fNoUser;

    // Set by the add-entry wizard if the selected port is an X.25 PAD.
    //
//  BOOL fPadSelected;

    // Set if there are multiple devices configured, i.e. if the UI is running
    // in the multiple device mode.  This is implicitly false in VPN and
    // Direct modes.
    //
//  BOOL fMultipleDevices;

    // Link storing the List of PBPHONEs and alternate options for shared
    // phone number mode.  This allows user to change the port/device to
    // another link without losing the phone number he typed.
    //
//    DTLNODE* pSharedNode;

    // The node being edited (still in the list), and the original entry name
    // for use in comparison later.  These are valid in "edit" case only.
    //
//    DTLNODE* pOldNode;
//    TCHAR szOldEntryName[ RAS_MaxEntryName + 1 ];

    // The work entry node containing and a shortcut pointer to the entry
    // inside.
    //
//    DTLNODE* pNode;
//  PBENTRY* pEntry;
    BILLSPBENTRY* pEntry;

    // The master list of configured ports used by EuChangeEntryType to
    // construct an appropriate sub-list of PBLINKs in the work entry node.
    //
//    DTLLIST* pListPorts;

    // The "current" device.  This value is NULL for multilink entries.  It
    // is the device that the entry will use if no change is made.  We compare
    // the current device to the device selected from the general tab to know
    // when it is appropriate to update the phonebook's "preferred" device.
    //
//  TCHAR* pszCurDevice;
//  TCHAR* pszCurPort;

    // Set true if there are no ports of the current entry type configured,
    // not including any bogus "uninstalled" ports added to the link list so
    // the rest of the code can assume there is at least one link.
    //
//  BOOL fNoPortsConfigured;

    // Dial-out user info for router; used by AiWizard.  Used to set interface
    // credentials via MprAdminInterfaceSetCredentials.
    //
//  TCHAR* pszRouterUserName;
//  TCHAR* pszRouterDomain;
//  TCHAR* pszRouterPassword;

    // Dial-in user info for router (optional); used by AiWizard.  Used to
    // create dial-in user account via NetUserAdd; the user name for the
    // account is the interface (phonebook entry) name.
    //
//  BOOL fAddUser;
//  TCHAR* pszRouterDialInPassword;

    // Home networking settings for the entry.
    //
    BOOL fComInitialized;
    IHNetConnection *pHNetConn;
    IHNetCfgMgr *pHNetCfgMgr;
    BOOL fShowHNetPages;
    HRESULT hShowHNetPagesResult;

    // ICS settings for the entry
    //
    IHNetIcsSettings *pIcsSettings;
    BOOL fOtherShared;
    BOOL fShared;
    BOOL fNewShared;
    BOOL fDemandDial;
    BOOL fNewDemandDial;
    BOOL fNewBeaconControl;
    BOOL fResetPrivateAdapter;
    IHNetConnection *pPrivateLanConnection;
    IHNetConnection **rgPrivateConns;
    IHNetIcsPublicConnection *pOldSharedConnection;
    DWORD dwLanCount;
    LONG lxCurrentPrivate;

    // Firewall settings for the entry
    //
    BOOL fFirewalled;
    BOOL fNewFirewalled;

    // AboladeG - security level of the current user.
    // Set true if the user is an administrator/power user.
    // This is required by several pages, both in the wizard
    // and in the property sheet.
    //
    BOOL fIsUserAdminOrPowerUser;

    // Set if strong encryption is supported by NDISWAN, as determined in
    // EuInit.
    //
    BOOL fStrongEncryption;

    // Set whent the VPN "first connect" controls should be read-only, e.g. in
    // the dialer's Properties button is pressed in the middle of a double
    // dial.
    //
//  BOOL fDisableFirstConnect;

    //Used in the IPSec Policy in the Security tab for a VPN connection
    //
//  BOOL fPSKCached;
//  TCHAR szPSK[PWLEN + 1];


    // Flags to track whether to save the default Internet connection
    //
//  BOOL fDefInternetPersonal;
//  BOOL fDefInternetGlobal;

    // Default credentials
    //
//  TCHAR* pszDefUserName;
//  TCHAR* pszDefPassword;
}
EINFO;

// Phonebook Entry property sheet context block.  All property pages refer to
// the single context block is associated with the sheet.
//
typedef struct
_PEINFO
{
    // Common input arguments.
    //
    EINFO* pArgs;

    // Property sheet dialog and property page handles.  'hwndFirstPage' is
    // the handle of the first property page initialized.  This is the page
    // that allocates and frees the context block.
    //
    // Note the "Network" page is missing.  This "NCPA" page, developed
    // separately by ShaunCo, does not use this shared area for page specfic
    // controls, instead returning users selections via the "penettab.h"
    // interface.
    //
    HWND hwndDlg;
//  HWND hwndFirstPage;
//  HWND hwndGe;
//  HWND hwndOe;
//  HWND hwndLo;
    HWND hwndSa;
//  HWND hwndFw;

    // General page.
    //
//  HWND hwndLvDevices;
//  HWND hwndLbDevices;
//  HWND hwndPbUp;
//  HWND hwndPbDown;
//  HWND hwndCbSharedPhoneNumbers;
//  HWND hwndPbConfigureDevice;
//  HWND hwndGbPhoneNumber;
//  HWND hwndStAreaCodes;
//  HWND hwndClbAreaCodes;
//  HWND hwndStCountryCodes;
//  HWND hwndLbCountryCodes;
//  HWND hwndStPhoneNumber;
//  HWND hwndEbPhoneNumber;
//  HWND hwndCbUseDialingRules;
//  HWND hwndPbDialingRules;
//  HWND hwndPbAlternates;
//  HWND hwndCbShowIcon;

//  HWND hwndEbHostName;
//  HWND hwndCbDialAnotherFirst;
//  HWND hwndLbDialAnotherFirst;

//  HWND hwndEbBroadbandService;

    // Options page.
    //
//  HWND hwndCbDisplayProgress;
//  HWND hwndCbPreviewUserPw;
//  HWND hwndCbPreviewDomain;
//  HWND hwndCbPreviewNumber;
//  HWND hwndEbRedialAttempts;
//  HWND hwndLbRedialTimes;
//  HWND hwndLbIdleTimes;
//  HWND hwndCbRedialOnDrop;
//  HWND hwndGbMultipleDevices;
//  HWND hwndLbMultipleDevices;
//  HWND hwndPbConfigureDialing;
//  HWND hwndPbX25;
//  HWND hwndPbTunnel;
//  HWND hwndRbPersistent;  // only for fRouter
//  HWND hwndRbDemandDial;  // only for fRouter

    // Security page.
    //
//  HWND hwndGbSecurityOptions;
//  HWND hwndRbTypicalSecurity;
//  HWND hwndStAuths;
//  HWND hwndLbAuths;
//  HWND hwndCbUseWindowsPw;
//  HWND hwndCbEncryption;
//  HWND hwndRbAdvancedSecurity;
//  HWND hwndStAdvancedText;
//  HWND hwndPbAdvanced;
//  HWND hwndPbIPSec;       //Only for VPN
//  HWND hwndGbScripting;
//  HWND hwndCbRunScript;
//  HWND hwndCbTerminal;
//  HWND hwndLbScripts;
//  HWND hwndPbEdit;
//  HWND hwndPbBrowse;

    // Networking page.
    //
//  HWND hwndLbServerType;
//  HWND hwndPbSettings;
//  HWND hwndLvComponents;
//  HWND hwndPbAdd;
//  HWND hwndPbRemove;
//  HWND hwndPbProperties;
//  HWND hwndDescription;

    // Shared Access page.
    //
    HWND hwndSaPbShared;
    HWND hwndSaGbShared;
    HWND hwndSaGbPrivateLan;
    HWND hwndSaEbPrivateLan;
    HWND hwndSaLbPrivateLan;
    HWND hwndSaSfPrivateLan;
    HWND hwndSaPbDemandDial;
    HWND hwndSaPbFirewalled;

    // Indicates that the informational popup noting that SLIP does not
    // support any authentication settings should appear the next time the
    // Security page is activated.
    //
//  BOOL fShowSlipPopup;

    // The "restore" states of the typical security mode listbox and
    // checkboxes.  Initialized in LoInit and set whenever the controls are
    // disabled.
    //
//  DWORD iLbAuths;
//  BOOL fUseWindowsPw;
//  BOOL fEncryption;

    // MoveUp/MoveDown icons, for enabled/disabled cases.
    //
//  HANDLE hiconUpArr;
//  HANDLE hiconDnArr;
//  HANDLE hiconUpArrDis;
//  HANDLE hiconDnArrDis;

    // The currently displayed link node, i.e. either the node of the selected
    // device or the shared node.  This is a shortcut for GeAlternates, that
    // keeps all the lookup code in GeUpdatePhoneNumberFields.
    //
//    DTLNODE* pCurLinkNode;

    // The currently selected device.  Used to store phone number information
    // for the just unselected device when a new device is selected.
    //
//  INT iDeviceSelected;

    // Complex phone number helper context block, and a flag indicating if the
    // block has been initialized.
    //
//    CUINFO cuinfo;
//  BOOL fCuInfoInitialized;

    // After dial scripting helper context block, and a flag indicating if the
    // block has been initialized.
    //
//    SUINFO suinfo;
//  BOOL fSuInfoInitialized;

    // Flags whether the user authorized a reboot after installing or removing
    // and networking component.
    //
//  BOOL fRebootAlreadyRequested;

    // List of area codes passed CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one from the
    // PBUSER.
    //
//    DTLLIST* pListAreaCodes;

    // Stash/restore values for Options page checkboxes.
    //
//  BOOL fPreviewUserPw;
//  BOOL fPreviewDomain;

    // Set when user changes to "Typical smartcard" security.  This causes the
    // registry based association of EAP per-user information to be discarded,
    // sort of like flushing cached credentials.
    //
//  BOOL fDiscardEapUserData;

    // Set true on the first click of the Typical or Advanced radio button on
    // the security page, false before.  The first click is the one
    // artificially generated in LoInit.  The Advanced click handler uses the
    // information to avoid incorrectly adopting the Typical defaults in the
    // case of Advanced settings.
    //
//  BOOL fAuthRbInitialized;

    // Used by the networking page
    //
//  INetCfg*                        pNetCfg;
//  BOOL                            fInitCom;
//  BOOL                            fReadOnly;  // Netcfg was initialized in
                                                // read-only mode
//  BOOL                            fNonAdmin;  // Run in non-admin mode (406630)
//  BOOL                            fNetCfgLock;// NetCfg needs to be unlocked
                                                // when uninited.
//    SP_CLASSIMAGELIST_DATA          cild;
//  INetConnectionUiUtilities *     pNetConUtilities;
//  IUnknown*                       punkUiInfoCallback;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
//  BOOL fComInitialized;

    // Keep track of whether we have shown this warning, or if it was disabled by the user
    //
    BOOL fShowDisableFirewallWarning;
    
    // r/w memory for indirect propsheet dialog
    LPDLGTEMPLATE lpdt;
}
PEINFO;

// local protos
INT_PTR CALLBACK SaDlgProc (IN HWND hwnd, IN UINT unMsg, IN WPARAM wparam, IN LPARAM lparam);
BOOL SaCommand (IN PEINFO* pInfo, IN WORD wNotification, IN WORD wId, IN HWND hwndCtrl);
BOOL SaInit (IN HWND hwndPage);

// more local protos
PEINFO* PeContext(IN HWND hwndPage);
BOOL SaIsAdapterDHCPEnabled(IN IHNetConnection* pConnection);
INT_PTR CALLBACK SaDisableFirewallWarningDlgProc(IN HWND hwnd, IN UINT unMsg, IN WPARAM wparam, IN LPARAM lparam);
HRESULT PeInit (GUID * pGuid, PEINFO ** ppEI);
DWORD EuInit (IN RASENTRY * pRE, IN TCHAR* pszPhonebook, IN TCHAR* pszEntry, IN RASENTRYDLG* pArgs, IN BOOL fRouter, OUT EINFO** ppInfo, OUT DWORD* pdwOp);
BOOL FIsUserAdminOrPowerUser (void);
void PeTerm (PEINFO * pEI);
VOID EuFree (IN EINFO* pInfo);
BOOL PeApply (IN HWND hwndPage);
BOOL EuCommit(IN EINFO* pInfo);
DWORD EuHomenetCommitSettings(IN EINFO* pInfo);

LRESULT CALLBACK CenterDlgOnOwnerCallWndProc (int code, WPARAM wparam, LPARAM lparam);
TCHAR* PszFromId(IN HINSTANCE hInstance,IN DWORD dwStringId);

HRESULT APIENTRY HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu);

VOID VerifyConnTypeAndCreds(IN PEINFO* pInfo);
DWORD FindEntryCredentials(IN  TCHAR* pszPath, IN  TCHAR* pszEntryName, OUT BOOL* pfUser, OUT BOOL* pfGlobal);

//----------------------------------------------------------------------------
// Shared Access property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
SaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared Access page of the Entry property
    // sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
#if 0
    TRACE4( "SaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            // hang pPEINFO off prop
            PROPSHEETPAGEW * pPSP = (PROPSHEETPAGEW *)lparam;
            SetProp (hwnd, g_contextId, (HANDLE)pPSP->lParam);
            return SaInit( hwnd );
        }

        case WM_NCDESTROY:
        {
            PEINFO* pInfo = PeContext( hwnd );
            if (pInfo)
                PeTerm (pInfo);
            RemoveProp (hwnd, g_contextId);
            GlobalDeleteAtom ((ATOM)g_contextId);
            g_contextId = NULL;
            break;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwSaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return SaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    PeApply (hwnd);
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    PEINFO* pInfo;

                    TRACE("SwKILLACTIVE");
                    pInfo = PeContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }

                    if ( Button_GetCheck( pInfo->hwndSaPbShared )
                        && (!pInfo->pArgs->fShared || (pInfo->pArgs->fResetPrivateAdapter && 0 != pInfo->pArgs->dwLanCount)))
                    {
                        IHNetConnection* pPrivateConn = NULL;

                        if(1 < pInfo->pArgs->dwLanCount) // if the combobox is showing make sure they selected a valid adapter
                        {
                            INT item = ComboBox_GetCurSel( pInfo->hwndSaLbPrivateLan );
                            if (item != CB_ERR)
                            {
                                pPrivateConn = (IHNetConnection*)ComboBox_GetItemData( pInfo->hwndSaLbPrivateLan, item );
                            }
                        }
                        else
                        {
                            pPrivateConn = pInfo->pArgs->rgPrivateConns[0];

                        }

                        if(NULL == pPrivateConn)
                        {
                            MSGARGS msgargs;
                            ASSERT(1 < pInfo->pArgs->dwLanCount);

                            ZeroMemory( &msgargs, sizeof(msgargs) );
                            msgargs.dwFlags = MB_OK | MB_ICONWARNING;
                            MsgDlg( pInfo->hwndDlg, SID_SA_SelectAdapterError, &msgargs );
                            SetWindowLong( hwnd, DWLP_MSGRESULT, PSNRET_INVALID );
                            return TRUE;
                        }

                        if(!pInfo->pArgs->fOtherShared && FALSE == SaIsAdapterDHCPEnabled(pPrivateConn))
                        {
                            // if shared access is being turned on for the first time,
                            // explain its implications.
                            //

                            MSGARGS msgargs;
                            UINT    unId;
                            ZeroMemory( &msgargs, sizeof(msgargs) );
                            msgargs.dwFlags = MB_YESNO | MB_ICONINFORMATION;
                            unId = MsgDlg( pInfo->hwndDlg, SID_EnableSharedAccess, &msgargs );
                            if (unId == IDNO)
                                SetWindowLong( hwnd, DWLP_MSGRESULT, TRUE );
                            else
                                SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                        }
                    }

                    if ( TRUE == pInfo->pArgs->fFirewalled && TRUE == pInfo->fShowDisableFirewallWarning && FALSE == Button_GetCheck( pInfo->hwndSaPbFirewalled ) )
                    {
                        INT_PTR nDialogResult;
                        pInfo->fShowDisableFirewallWarning = FALSE;
                        nDialogResult = DialogBox(g_hinstDll, MAKEINTRESOURCE(DID_SA_DisableFirewallWarning), hwnd, SaDisableFirewallWarningDlgProc);
                        if(-1 != nDialogResult && IDYES != nDialogResult)
                        {
                            Button_SetCheck ( pInfo->hwndSaPbFirewalled, TRUE );
                            SaCommand( pInfo, BN_CLICKED, CID_FW_PB_Firewalled, pInfo->hwndSaPbFirewalled );

                        }
                    }
                    return TRUE;
                }

                case NM_CLICK:
                case NM_RETURN:
                {
                    HWND hPropertySheetWindow = GetParent(hwnd);
                    if(NULL != hPropertySheetWindow)
                    {
                        if(CID_SA_ST_HNWLink == wparam)
                        {
                            ShellExecute(NULL,TEXT("open"),TEXT("rundll32"), TEXT("hnetwiz.dll,HomeNetWizardRunDll"),NULL,SW_SHOW);
                            PostMessage(hPropertySheetWindow, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), (LPARAM) GetDlgItem(hPropertySheetWindow, IDCANCEL));
                        }
                        else if(CID_SA_ST_ICFLink == wparam || CID_SA_ST_ICSLink == wparam)
                        {
                            LPTSTR pszHelpTopic = CID_SA_ST_ICFLink == wparam ? TEXT("netcfg.chm::/hnw_understanding_firewall.htm") : TEXT("netcfg.chm::/Share_conn_overvw.htm");
                            HtmlHelp(NULL, pszHelpTopic, HH_DISPLAY_TOPIC, 0);
                            
                        }
                    }
                    break;
                }
                    
                    
            }
            break;
        }
    }
    
    return FALSE;
}

BOOL
SaCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "SaCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_FW_PB_Firewalled:
        {
            BOOL fFirewalled = Button_GetCheck( pInfo->hwndSaPbFirewalled );
            EnableWindow(
                GetDlgItem( pInfo->hwndSa, CID_SA_PB_Settings ), fFirewalled || Button_GetCheck( pInfo->hwndSaPbShared ));
            return TRUE;
        }

        case CID_SA_PB_Shared:
        {
            BOOL fShared = Button_GetCheck( pInfo->hwndSaPbShared );
            EnableWindow( pInfo->hwndSaPbDemandDial, fShared );
            EnableWindow( GetDlgItem(pInfo->hwndSa, CID_SA_PB_Beacon), fShared );
            EnableWindow(
                GetDlgItem( pInfo->hwndSa, CID_SA_PB_Settings ), fShared || Button_GetCheck( pInfo->hwndSaPbFirewalled ));
            if (fShared && !pInfo->pArgs->fShared)
            {
                MSGARGS msgargs;
                IEnumHNetIcsPublicConnections *pEnum;
                IHNetIcsPublicConnection *pOldIcsConn;
                IHNetConnection *pOldConn;
                LPWSTR pszwOldName = NULL;
                HRESULT hr;
                hr = pInfo->pArgs->pIcsSettings->EnumIcsPublicConnections (&pEnum);
                if (SUCCEEDED(hr))
                {
                    ULONG ulCount;
                    
                    VerifyConnTypeAndCreds(pInfo);

                    hr = pEnum->Next(
                            1,
                            &pOldIcsConn,
                            &ulCount
                            );

                    if (SUCCEEDED(hr) && 1 == ulCount)
                    {
                        hr = pOldIcsConn->QueryInterface(
                                IID_IHNetConnection,
                                (void**)&pOldConn
                                );

                        if (SUCCEEDED(hr))
                        {
                            // Transer pOldIcsConn reference
                            //
                            pInfo->pArgs->fOtherShared = TRUE;
                            pInfo->pArgs->pOldSharedConnection = pOldIcsConn;

                            hr = pOldConn->GetName (&pszwOldName);
                            pOldConn->Release();
                        }
                        else
                        {
                            pOldIcsConn->Release();
                        }
                    }

                    pEnum->Release();
                }

                if (SUCCEEDED(hr) && NULL != pszwOldName)
                {
                    ZeroMemory( &msgargs, sizeof(msgargs) );
                    msgargs.apszArgs[ 0 ] = pszwOldName;
                    msgargs.apszArgs[ 1 ] = pInfo->pArgs->pEntry->pszEntryName;
                    msgargs.dwFlags = MB_OK | MB_ICONINFORMATION;
                    MsgDlg( pInfo->hwndDlg, SID_ChangeSharedConnection, &msgargs );
                    CoTaskMemFree( pszwOldName );
                }
            }
            return TRUE;
        }

        case CID_SA_PB_Settings:
        {
            HNetSharingAndFirewallSettingsDlg(
                pInfo->hwndDlg,
                pInfo->pArgs->pHNetCfgMgr,
                Button_GetCheck( pInfo->hwndSaPbFirewalled ),
                pInfo->pArgs->pHNetConn
                );
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
SaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO* pInfo;
    INetConnectionUiUtilities* pncuu = NULL;
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;

    TRACE( "SaInit" );

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }
    _ASSERT (pInfo->hwndDlg == NULL);
    pInfo->pArgs->hwndOwner = pInfo->hwndDlg = GetParent (hwndPage);
    _ASSERT (pInfo->hwndDlg);

    // Initialize page-specific context information.
    //
    pInfo->hwndSa = hwndPage;
    pInfo->hwndSaPbShared = GetDlgItem( hwndPage, CID_SA_PB_Shared );
    ASSERT( pInfo->hwndSaPbShared );
    pInfo->hwndSaGbShared = GetDlgItem( hwndPage, CID_SA_GB_Shared );
    ASSERT( pInfo->hwndSaGbShared );
    pInfo->hwndSaGbPrivateLan = GetDlgItem( hwndPage, CID_SA_GB_PrivateLan );
    ASSERT( pInfo->hwndSaGbPrivateLan );
    pInfo->hwndSaEbPrivateLan = GetDlgItem( hwndPage, CID_SA_EB_PrivateLan );
    ASSERT( pInfo->hwndSaEbPrivateLan );
    pInfo->hwndSaLbPrivateLan = GetDlgItem( hwndPage, CID_SA_LB_PrivateLan );
    ASSERT( pInfo->hwndSaLbPrivateLan );
    pInfo->hwndSaSfPrivateLan = GetDlgItem( hwndPage, CID_SA_SF_PrivateLan );
    ASSERT( pInfo->hwndSaSfPrivateLan );
    pInfo->hwndSaPbDemandDial = GetDlgItem( hwndPage, CID_SA_PB_DemandDial );
    ASSERT( pInfo->hwndSaPbDemandDial );
    pInfo->hwndSaPbFirewalled = GetDlgItem( hwndPage, CID_FW_PB_Firewalled );
    ASSERT( pInfo->hwndSaPbFirewalled );

    // Initialize checks.
    //

    // Check if ZAW is denying access to the Shared Access UI
    //
    if (FAILED(HrCreateNetConnectionUtilities(&pncuu)))
    {
        ASSERT(NULL == pncuu);
    }

    if(NULL == pncuu || TRUE == pncuu->UserHasPermission (NCPERM_PersonalFirewallConfig))
    {
        HKEY hFirewallKey;
        Button_SetCheck( pInfo->hwndSaPbFirewalled, pInfo->pArgs->fFirewalled );
        SaCommand( pInfo, BN_CLICKED, CID_FW_PB_Firewalled, pInfo->hwndSaPbFirewalled );

        pInfo->fShowDisableFirewallWarning = TRUE;
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, KEY_QUERY_VALUE, &hFirewallKey))
        {
            DWORD dwValue;
            DWORD dwType;
            DWORD dwSize = sizeof(dwValue);
            if(ERROR_SUCCESS == RegQueryValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, NULL, &dwType, (BYTE*)&dwValue, &dwSize))
            {
                if(REG_DWORD == dwType && TRUE == dwValue)
                {
                    pInfo->fShowDisableFirewallWarning = FALSE;
                }
            }
            RegCloseKey(hFirewallKey);
        }

    }
    else
    {
        EnableWindow(pInfo->hwndSaPbFirewalled, FALSE);
    }


    // Initialize the page's appearance.
    // If there are multiple private LAN connections, below the 'shared access'
    // checkbox we display either
    // (a) a drop-list of LAN connections if the connection is not shared, or
    // (b) a disabled edit-control with the current private LAN.
    // This involves moving everything in the 'on-demand dialing' groupbox
    // downward on the page at run-time.
    // To achieve this, we use a hidden static control to tell us the position
    // to which the groupbox should be moved.
    //

    BOOL fPolicyAllowsSharing = TRUE;
    if(NULL != pncuu && FALSE == pncuu->UserHasPermission (NCPERM_ShowSharedAccessUi))
    {
        fPolicyAllowsSharing = FALSE;
    }

    if (pInfo->pArgs->dwLanCount == 0)
    {
        ShowWindow(pInfo->hwndSaGbShared, SW_HIDE);
        ShowWindow(pInfo->hwndSaPbShared, SW_HIDE);
        ShowWindow(pInfo->hwndSaPbDemandDial, SW_HIDE);
        ShowWindow(GetDlgItem(hwndPage, CID_SA_PB_Shared), SW_HIDE);
        ShowWindow(GetDlgItem(hwndPage, CID_SA_ST_ICSLink), SW_HIDE);
        ShowWindow(GetDlgItem(hwndPage, CID_SA_PB_Beacon), SW_HIDE);
    }
    else if(FALSE == fPolicyAllowsSharing)
    {
        // if policy disables ICS just gray the checkbox
        EnableWindow(pInfo->hwndSaPbShared, FALSE);
        EnableWindow(pInfo->hwndSaPbDemandDial, FALSE);
        EnableWindow(GetDlgItem(hwndPage, CID_SA_PB_Beacon), FALSE);
    }
    else if (pInfo->pArgs->dwLanCount > 1)
    {
        INT cy;
        HDWP hdwp;
        DWORD i;
        INT item;
        RECT rc, rcFrame;
        IHNetConnection **rgPrivateConns;
        LPWSTR pszwName;
        HRESULT hr;

        // get the reference-frame and group-box coordinates
        //
        GetWindowRect( pInfo->hwndSaSfPrivateLan, &rcFrame );
        GetWindowRect( pInfo->hwndSaPbDemandDial, &rc );
        cy = rcFrame.top - rc.top;

        // move each control down by the amount in 'cy'
        //
        hdwp = BeginDeferWindowPos(3);

        if(NULL != hdwp)
        {


            GetWindowRect( pInfo->hwndSaPbDemandDial, &rc);
            MapWindowPoints(NULL, hwndPage, (LPPOINT)&rc, 2);
            DeferWindowPos(hdwp, pInfo->hwndSaPbDemandDial, NULL,
                rc.left, rc.top + cy, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

            HWND hBeaconCheck = GetDlgItem(hwndPage, CID_SA_PB_Beacon);
            GetWindowRect( hBeaconCheck, &rc);
            MapWindowPoints(NULL, hwndPage, (LPPOINT)&rc, 2);
            DeferWindowPos(hdwp, hBeaconCheck, NULL,
                rc.left, rc.top + cy, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
            
            HWND hICSLink = GetDlgItem(hwndPage, CID_SA_ST_ICSLink);
            GetWindowRect( hICSLink, &rc);
            MapWindowPoints(NULL, hwndPage, (LPPOINT)&rc, 2);
            DeferWindowPos(hdwp, hICSLink, NULL,
                rc.left, rc.top + cy, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

            EndDeferWindowPos(hdwp);
        }

        // hide the smaller shared-access group box, show the larger version,
        // and display either the drop-list or the edit-control.
        //
        rgPrivateConns = (IHNetConnection **)pInfo->pArgs->rgPrivateConns;
        ShowWindow( pInfo->hwndSaGbShared, SW_HIDE );
        ShowWindow( pInfo->hwndSaGbPrivateLan, SW_SHOW );
        ShowWindow(GetDlgItem(hwndPage, CID_SA_ST_HomeConnection), SW_SHOW);
        EnableWindow(GetDlgItem(hwndPage, CID_SA_ST_HomeConnection), TRUE);

        if (pInfo->pArgs->fShared && !pInfo->pArgs->fResetPrivateAdapter)
        {
            ShowWindow( pInfo->hwndSaEbPrivateLan, SW_SHOW );

            // Fill in name of current private connection
            //

            hr = rgPrivateConns[pInfo->pArgs->lxCurrentPrivate]->GetName (&pszwName);
            if (SUCCEEDED(hr))
            {
                SetWindowText(
                    pInfo->hwndSaEbPrivateLan, pszwName );

                CoTaskMemFree( pszwName );
            }
        }
        else
        {
            ShowWindow( pInfo->hwndSaLbPrivateLan, SW_SHOW );

            // Add the bogus entry to the combobox

            pszwName = PszFromId( g_hinstDll, SID_SA_SelectAdapter );
            ASSERT(pszwName);

            item = ComboBox_AddString( pInfo->hwndSaLbPrivateLan, pszwName );
            if (item != CB_ERR && item != CB_ERRSPACE)
            {
                ComboBox_SetItemData( pInfo->hwndSaLbPrivateLan, item, NULL ); // ensure item data is null for validation purposes
            }

            // fill the combobox with LAN names
            //
            for (i = 0; i < pInfo->pArgs->dwLanCount; i++)
            {
                hr = rgPrivateConns[i]->GetName (&pszwName);
                if (SUCCEEDED(hr))
                {
                    item =
                        ComboBox_AddString(
                            pInfo->hwndSaLbPrivateLan, pszwName );

                    if (item != CB_ERR)
                    {
                        ComboBox_SetItemData(
                            pInfo->hwndSaLbPrivateLan, item, rgPrivateConns[i] );
                    }

                    CoTaskMemFree( pszwName );
                }
            }

            ComboBox_SetCurSel( pInfo->hwndSaLbPrivateLan, 0 );
        }
    }

    if(NULL != pncuu)
    {
        pncuu->Release();
    }

    // Initialize checks.
    //

    BOOL fBeaconControl = TRUE;
    
    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS == dwError) // if this fails we assume it is on, set the box, and commit on apply
    {
        DWORD dwType;
        DWORD dwData = 0;
        DWORD dwSize = sizeof(dwData);
        dwError = RegQueryValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, &dwType, reinterpret_cast<LPBYTE>(&dwData), &dwSize);
        if(ERROR_SUCCESS == dwError && REG_DWORD == dwType && 0 == dwData)
        {
            fBeaconControl = FALSE;
        }
        RegCloseKey(hKey);
    }

    Button_SetCheck( pInfo->hwndSaPbShared, pInfo->pArgs->fShared );
    Button_SetCheck( pInfo->hwndSaPbDemandDial, pInfo->pArgs->fDemandDial );
    Button_SetCheck(GetDlgItem(hwndPage, CID_SA_PB_Beacon), fBeaconControl);

    EnableWindow( pInfo->hwndSaPbDemandDial, pInfo->pArgs->fShared && fPolicyAllowsSharing);
    EnableWindow( GetDlgItem(hwndPage, CID_SA_PB_Beacon), pInfo->pArgs->fShared && fPolicyAllowsSharing );
    EnableWindow( GetDlgItem( pInfo->hwndSa, CID_SA_PB_Settings ), pInfo->pArgs->fShared || pInfo->pArgs->fFirewalled );


    //if the machine is personal or workstation show the HNW link
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    if(0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask))
    {
        
        // but only if not on a domain
        LPWSTR pszNameBuffer;
        NETSETUP_JOIN_STATUS BufferType;
        
        if(NERR_Success == NetGetJoinInformation(NULL, &pszNameBuffer, &BufferType))
        {
            NetApiBufferFree(pszNameBuffer);
            if(NetSetupDomainName != BufferType)
            {
                ShowWindow(GetDlgItem(hwndPage, CID_SA_ST_HNWLink), SW_SHOW);
            }
        }
    }

    //
    // Making sure that Beacon checkbox is enabled only for 
    // Pro and Per Types of the OS.
    //
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);

    if ( 0 == VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask) &&
        ERROR_OLD_WIN_VERSION == GetLastError() )
    {
        ShowWindow(GetDlgItem(hwndPage, CID_SA_PB_Beacon), SW_HIDE);
    }

    return TRUE;
}

INT_PTR CALLBACK
SaDisableFirewallWarningDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch(unMsg)
    {
        case WM_COMMAND:
        {
            switch(LOWORD(wparam))
            {
            case IDYES:
            case IDNO:
                if(BST_CHECKED == IsDlgButtonChecked(hwnd, CID_SA_PB_DisableFirewallWarning))
                {
                    HKEY hFirewallKey;
                    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hFirewallKey, NULL))
                    {
                        DWORD dwValue = TRUE;
                        RegSetValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, 0, REG_DWORD, (CONST BYTE*)&dwValue, sizeof(dwValue));
                        RegCloseKey(hFirewallKey);
                    }
                }

                // fallthru
            case IDCANCEL:
                EndDialog(hwnd, LOWORD(wparam));
                break;

            }
            break;
        }
    }

    return FALSE;
}

BOOL SaIsAdapterDHCPEnabled(IHNetConnection* pConnection)
{
    HRESULT hr;
    BOOL fDHCP = FALSE;
    GUID* pAdapterGuid;
    hr = pConnection->GetGuid (&pAdapterGuid);
    if(SUCCEEDED(hr))
    {
        LPOLESTR pAdapterName;
        hr = StringFromCLSID(*pAdapterGuid, &pAdapterName);
        if(SUCCEEDED(hr))
        {
            SIZE_T Length = wcslen(pAdapterName);
            LPSTR pszAnsiAdapterName = (LPSTR)Malloc(Length + 1);
            if(NULL != pszAnsiAdapterName)
            {
                if(0 != WideCharToMultiByte(CP_ACP, 0, pAdapterName, (int)(Length + 1), pszAnsiAdapterName, (int)(Length + 1), NULL, NULL))
                {
                    HMODULE hIpHelper;
                    hIpHelper = LoadLibrary(L"iphlpapi");
                    if(NULL != hIpHelper)
                    {
                        DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO, PULONG);

                        pGetAdaptersInfo = (DWORD (WINAPI*)(PIP_ADAPTER_INFO, PULONG)) GetProcAddress(hIpHelper, "GetAdaptersInfo");
                        if(NULL != pGetAdaptersInfo)
                        {
                            ULONG ulSize = 0;
                            if(ERROR_BUFFER_OVERFLOW == pGetAdaptersInfo(NULL, &ulSize))
                            {
                                PIP_ADAPTER_INFO pInfo = (PIP_ADAPTER_INFO)Malloc(ulSize);
                                if(NULL != pInfo)
                                {
                                    if(ERROR_SUCCESS == pGetAdaptersInfo(pInfo, &ulSize))
                                    {
                                        PIP_ADAPTER_INFO pAdapterInfo = pInfo;
                                        do
                                        {
                                            if(0 == lstrcmpA(pszAnsiAdapterName, pAdapterInfo->AdapterName))
                                            {
                                                fDHCP = !!pAdapterInfo->DhcpEnabled;
                                                break;
                                            }

                                        } while(NULL != (pAdapterInfo = pAdapterInfo->Next));
                                    }
                                    Free(pInfo);
                                }
                            }
                        }
                        FreeLibrary(hIpHelper);
                    }
                }
                Free(pszAnsiAdapterName);
            }
            CoTaskMemFree(pAdapterName);
        }
        CoTaskMemFree(pAdapterGuid);
    }

    return fDHCP;
}

PEINFO* PeContext (IN HWND hwndPage)
{
    // Retrieve the property sheet context from a property page handle.
    //
//  return (PEINFO* )GetProp( GetParent( hwndPage ), g_contextId );
// now hanging our stuff off our window (since it's not shared)
    return (PEINFO* )GetProp( hwndPage, g_contextId );
}

void PeTerm (PEINFO * pEI)
{
    _ASSERT (pEI);
    _ASSERT (pEI->pArgs);
    _ASSERT (pEI->pArgs->pEntry);

    Free (pEI->pArgs->pEntry); // BILLSPBENTRY
    EuFree (pEI->pArgs);
    if (pEI->lpdt)
        Free (pEI->lpdt);
    Free (pEI);
}

VOID
EuFree(
    IN EINFO* pInfo )

    // Releases 'pInfo' and associated resources.
    //
{
    TCHAR* psz;
//    INTERNALARGS* piargs;

//    piargs = (INTERNALARGS* )pInfo->pApiArgs->reserved;

    // Don't clean up the phonebook and user preferences if they arrived via
    // the secret hack.
    //
//    if (!piargs)
//    {
//        if (pInfo->pFile)
//        {
//            ClosePhonebookFile( pInfo->pFile );
//        }

//        if (pInfo->pUser)
//        {
//            DestroyUserPreferences( pInfo->pUser );
//        }
//    }

//    if (pInfo->pListPorts)
//    {
//        DtlDestroyList( pInfo->pListPorts, DestroyPortNode );
//    }
//    Free(pInfo->pszCurDevice);
//    Free(pInfo->pszCurPort);

//    if (pInfo->pNode)
//    {
//        DestroyEntryNode( pInfo->pNode );
//    }

    // Free router-information
    //
//    Free( pInfo->pszRouter );
//    Free( pInfo->pszRouterUserName );
//    Free( pInfo->pszRouterDomain );

//    if (pInfo->pSharedNode)
//    {
//        DestroyLinkNode( pInfo->pSharedNode );
//    }

//    psz = pInfo->pszRouterPassword;
//    if (psz)
//    {
//        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
//        Free( psz );
//    }

//    psz = pInfo->pszRouterDialInPassword;
//    if (psz)
//    {
//        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
//        Free( psz );
//    }

    // Free credentials stuff
//    Free(pInfo->pszDefUserName);
//    Free(pInfo->pszDefPassword);

    // Free home networking information
    //
    if (pInfo->rgPrivateConns)
    {
        UINT i;

        for (i = 0; i < pInfo->dwLanCount; i++)
        {
            if (pInfo->rgPrivateConns[i])
            {
                pInfo->rgPrivateConns[i]->Release();
            }
        }

        CoTaskMemFree(pInfo->rgPrivateConns);
    }

    if (pInfo->pHNetConn)
    {
        pInfo->pHNetConn->Release();
    }

    if (pInfo->pIcsSettings)
    {
        pInfo->pIcsSettings->Release();
    }

    if (pInfo->pOldSharedConnection)
    {
        pInfo->pOldSharedConnection->Release();
    }

    if (pInfo->pHNetCfgMgr)
    {
        pInfo->pHNetCfgMgr->Release();
    }

    if (pInfo->fComInitialized)
    {
        CoUninitialize();
    }

    Free( pInfo );
}

// helper
HRESULT GetRasEntry (TCHAR * pszPhonebook, TCHAR * pszEntry, RASENTRY ** ppRE)
{
    *ppRE = NULL;

    DWORD dwSize = 0;
    DWORD dwErr  = RasGetEntryProperties (pszPhonebook, pszEntry, NULL, &dwSize, NULL, NULL);
    if (dwErr != ERROR_BUFFER_TOO_SMALL)
        return HRESULT_FROM_WIN32(dwErr);
    _ASSERT (dwSize != 0);

    RASENTRY * pRE = (RASENTRY*)Malloc (dwSize);
    if (!pRE)
        return E_OUTOFMEMORY;

    ZeroMemory (pRE, dwSize);
    pRE->dwSize = sizeof(RASENTRY);
    
    dwErr = RasGetEntryProperties (pszPhonebook, pszEntry, pRE, &dwSize, NULL, NULL);
    if (dwErr) {
        Free (pRE);
        return HRESULT_FROM_WIN32(dwErr);
    }
    *ppRE = pRE;
    return S_OK;
}

// wrapper....
HRESULT PeInit (GUID * pGuid, PEINFO ** ppEI)
{
    _ASSERT (pGuid);
    _ASSERT (ppEI);

    *ppEI = (PEINFO *)Malloc (sizeof(PEINFO));
    if (!*ppEI)
        return E_OUTOFMEMORY;
    ZeroMemory (*ppEI, sizeof(PEINFO));

    CComPtr<IHNetConnection> spHNetConn = NULL;
    CComPtr<IHNetCfgMgr> spHNetCfgMgr = NULL;
    HRESULT hr = CoCreateInstance (CLSID_HNetCfgMgr,
                                   NULL,
                                   CLSCTX_ALL,
                                   __uuidof(IHNetCfgMgr),   // &IID_IHNetCfgMgr,
                                   (void**)&spHNetCfgMgr);
    if (SUCCEEDED(hr)) {
        // Convert the entry to an IHNetConnection
        hr = spHNetCfgMgr->GetIHNetConnectionForGuid (
                            pGuid, FALSE, TRUE, &spHNetConn);
    }
    if (SUCCEEDED(hr)) {
        // the code below assumes UNICODE....
        TCHAR * pszPhonebook = NULL;
        TCHAR * pszEntry = NULL;
        hr = spHNetConn->GetName (&pszEntry);
        if (hr == S_OK)
            hr = spHNetConn->GetRasPhonebookPath (&pszPhonebook);
    
        if (hr == S_OK) {
            // get RASENTRY dwType and guidId fields for code below
            RASENTRY * pRE = NULL;
            hr = GetRasEntry (pszPhonebook, pszEntry, &pRE);
            if (pRE) {
                DWORD dwOp = 0;
                DWORD dwError = EuInit (pRE,
                                        pszPhonebook,
                                        pszEntry,
                                        NULL,       // IN RASENTRYDLG* pArgs,
                                        FALSE,      // IN BOOL fRouter,
                                        &(*ppEI)->pArgs,
                                        &dwOp);
                if (dwError != 0) {
                    _ASSERT (dwOp != 0);
                    _ASSERT (!*ppEI);
                    if (HRESULT_SEVERITY(dwError))
                        hr = dwError;
                    else
                        hr = HRESULT_FROM_WIN32 (dwError);
                } else {
                    _ASSERT (dwOp == 0);
                    _ASSERT (*ppEI);
                }
                Free (pRE);
            }
        }
        if (pszPhonebook)   CoTaskMemFree (pszPhonebook);
        if (pszEntry)       CoTaskMemFree (pszEntry);
    }
    return hr;
}

DWORD
EuInit(
    IN RASENTRY * pRE,
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry,
    IN RASENTRYDLG* pArgs,
    IN BOOL fRouter,
    OUT EINFO** ppInfo,
    OUT DWORD* pdwOp )

    // Allocates '*ppInfo' data for use by the property sheet or wizard.
    // 'PszPhonebook', 'pszEntry', and 'pArgs', are the arguments passed by
    // user to the API.  'FRouter' is set if running in "router mode", clear
    // for the normal "dial-out" mode.  '*pdwOp' is set to the operation code
    // associated with any error.
    //
    // Returns 0 if successful, or an error code.  If non-null '*ppInfo' is
    // returned caller must eventually call EuFree to release the returned
    // block.
    //
{
    DWORD dwErr;
    EINFO* pInfo;
//  INTERNALARGS* piargs;

    *ppInfo = NULL;
    *pdwOp = 0;

    pInfo = (EINFO*)Malloc( sizeof(EINFO) );
    if (!pInfo)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pInfo, sizeof(*pInfo ) );

    /*
        bhanlon: I'm filling out what used to be a PBENTRY with a
        BILLSPBENTRY struct.  This needs to be freed....
    */
    pInfo->pEntry = (BILLSPBENTRY *)Malloc (sizeof(BILLSPBENTRY));
    if (!pInfo->pEntry) {
        Free (pInfo);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    _tcsncpy (pInfo->pEntry->pszEntryName, pszEntry, RAS_MaxEntryName);
    _tcsncpy (pInfo->pEntry->pszPhonebookPath, pszPhonebook, MAX_PATH);
    pInfo->pEntry->pGuid = &pInfo->pEntry->guidId;
    pInfo->pEntry->dwfExcludedProtocols = 0;
    pInfo->pEntry->dwType = pRE->dwType;
    pInfo->pEntry->guidId = pRE->guidId;

    *ppInfo = pInfo;
    pInfo->pszPhonebook = pszPhonebook;
    pInfo->pszEntry = pszEntry;
//  pInfo->pApiArgs = pArgs;
    pInfo->fRouter = fRouter;

//  piargs = (INTERNALARGS *)pArgs->reserved;

//  if (pInfo->fRouter)
//  {
//      LPTSTR pszRouter;
//      DWORD dwVersion;

//      ASSERT(piargs);

//      pszRouter = RemoteGetServerName(piargs->hConnection);

        // pmay: 348623
        //
        // Note that RemoteGetServerName is guarenteed to return
        // NULL for local box, non-NULL for remote
        //
//      pInfo->fRemote = !!pszRouter;

//      if(NULL == pszRouter)
//      {
//          pszRouter = TEXT("");
//      }

//      pInfo->pszRouter = StrDupTFromW(pszRouter);

        // Find out if we're focused on an nt4 router
        // pInfo->fNt4Router = FALSE;
        // IsNt40Machine( pszRouter, &(pInfo->fNt4Router) );

//      dwVersion = ((RAS_RPC *)(piargs->hConnection))->dwVersion;

//      pInfo->fNt4Router = !!(VERSION_40 == dwVersion );
        //Find out if the remote server is a win2k machine
        //
//      pInfo->fW2kRouter = !!(VERSION_50 == dwVersion );
//  }

    // Load the user preferences, or figure out that caller has already loaded
    // them.
    //
//  if (piargs && !piargs->fInvalid)
//  {
//      // We've received user preferences and the "no user" status via the
//      // secret hack.
//      //
//      pInfo->pUser = piargs->pUser;
//      pInfo->fNoUser = piargs->fNoUser;
//      pInfo->pFile = piargs->pFile;
//      pInfo->fDisableFirstConnect = piargs->fDisableFirstConnect;
//  }
//  else
//  {
//      DWORD dwReadPbkFlags = 0;

//      // Read user preferences from registry.
//      //
//      dwErr = g_pGetUserPreferences(
//          (piargs) ? piargs->hConnection : NULL,
//          &pInfo->user,
//          (pInfo->fRouter) ? UPM_Router : UPM_Normal );
//      if (dwErr != 0)
//      {
//          *pdwOp = SID_OP_LoadPrefs;
//          return dwErr;
//      }

//      pInfo->pUser = &pInfo->user;

//      if(pInfo->fRouter)
//      {
//          pInfo->file.hConnection = piargs->hConnection;
//          dwReadPbkFlags |= RPBF_Router;
//      }

//      if(pInfo->fNoUser)
//      {
//          dwReadPbkFlags |= RPBF_NoUser;
//      }

        // Load and parse the phonebook file.
        //
//        dwErr = ReadPhonebookFile(
//            pInfo->pszPhonebook, &pInfo->user, NULL,
//            dwReadPbkFlags,
//            &pInfo->file );
//        if (dwErr != 0)
//        {
//            *pdwOp = SID_OP_LoadPhonebook;
//            return dwErr;
//        }

//        pInfo->pFile = &pInfo->file;
//  }

    // Determine if strong encryption is supported.  Export laws prevent it in
    // some versions of the system.
    //
    {
//      ULONG ulCaps;
//      RAS_NDISWAN_DRIVER_INFO info;
//
//      ZeroMemory( &info, sizeof(info) );
//      ASSERT( g_pRasGetNdiswanDriverCaps );
//      dwErr = g_pRasGetNdiswanDriverCaps(
//          (piargs) ? piargs->hConnection : NULL, &info );
//      if (dwErr == 0)
//      {
//          pInfo->fStrongEncryption =
//              !!(info.DriverCaps & RAS_NDISWAN_128BIT_ENABLED);
//      }
//      else
        {
            pInfo->fStrongEncryption = FALSE;
        }
    }

    // Load the list of ports.
    //
//  dwErr = LoadPortsList2(
//      (piargs) ? piargs->hConnection : NULL,
//      &pInfo->pListPorts,
//      pInfo->fRouter );
//  if (dwErr != 0)
//  {
//      TRACE1( "LoadPortsList=%d", dwErr );
//      *pdwOp = SID_OP_RetrievingData;
//      return dwErr;
//  }

    // Set up work entry node.
    //
//  if (pInfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
//  {
//      DTLNODE* pNodeL;
//      DTLNODE* pNodeP;
//      PBLINK* pLink;
//      PBPORT* pPort;
//       // New entry mode, so 'pNode' set to default settings.
//      //
//      pInfo->pNode = CreateEntryNode( TRUE );
//      if (!pInfo->pNode)
//      {
//          TRACE( "CreateEntryNode failed" );
//          *pdwOp = SID_OP_RetrievingData;
//          return dwErr;
//      }

//      // Store entry within work node stored in context for convenience
//      // elsewhere.
//      //
//      pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
//      ASSERT( pInfo->pEntry );

//      if (pInfo->fRouter)
//      {
            // Set router specific defaults.
            //
//          pInfo->pEntry->dwIpNameSource = ASRC_None;
//          pInfo->pEntry->dwRedialAttempts = 0;

            // Since this is a new entry, setup a proposed entry name.
            // This covers the case when the wizard is not used to
            // create the entry and the property sheet has no way to enter
            // the name.
//          ASSERT( !pInfo->pEntry->pszEntryName );
//          GetDefaultEntryName( pInfo->pFile,
//                               RASET_Phone,
//                               pInfo->fRouter,
//                               &pInfo->pEntry->pszEntryName );

            // Disable MS client and File and Print services by default
            //
//          EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_msclient"),
//              FALSE);
//          EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_server"),
//              FALSE);
//      }

        // Use caller's default name, if any.
        //
//      if (pInfo->pszEntry)
//      {
//          pInfo->pEntry->pszEntryName = StrDup( pInfo->pszEntry );
//      }

        // Set the default entry type to "phone", i.e. modems, ISDN, X.26 etc.
        // This may be changed to "VPN" or  "direct"  by the new entry  wizard
        // after the initial wizard page.
        //
//      EuChangeEntryType( pInfo, RASET_Phone );
//  }
//  else
//  {
//      DTLNODE* pNode;

        // Edit or clone entry mode, so 'pNode' set to entry's current
        // settings.
        //
//      pInfo->pOldNode = EntryNodeFromName(
//          pInfo->pFile->pdtllistEntries, pInfo->pszEntry );

//      if (    !pInfo->pOldNode
//          &&  !pInfo->fRouter)
//      {

//          if(NULL == pInfo->pszPhonebook)
//          {
                //
                // Close the phonebook file we opened above.
                // we will try to find the entry name in the
                // per user phonebook file.
                //
//              ClosePhonebookFile(&pInfo->file);

//              pInfo->pFile = NULL;

                //
                // Attempt to find the file in users profile
                //
//              dwErr = GetPbkAndEntryName(
//                                  NULL,
//                                  pInfo->pszEntry,
//                                  0,
//                                  &pInfo->file,
//                                  &pInfo->pOldNode);

//              if(ERROR_SUCCESS != dwErr)
//              {
//                  *pdwOp = SID_OP_RetrievingData;
//                  return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
//              }

//              pInfo->pFile = &pInfo->file;
//          }
//          else
//          {
//              *pdwOp = SID_OP_RetrievingData;
//              return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
//          }
//      }

//      if(NULL != pInfo->pOldNode)
//      {
//          PBENTRY *pEntry = (PBENTRY *) DtlGetData(pInfo->pOldNode);

            // Before cloning or editing make sure that for dial up
            // connections, share File And Print is disabled.
            //
//          if(     ((RASET_Phone == pEntry->dwType)
//              ||  (RASET_Broadband == pEntry->dwType))
//              &&  (!pEntry->fShareMsFilePrint))
//          {
//              EnableOrDisableNetComponent( pEntry, TEXT("ms_server"),
//                  FALSE);
//          }
//      }

//      if(NULL != pInfo->pOldNode)
//      {
//          if (pInfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry)
//          {
//              pInfo->pNode = CloneEntryNode( pInfo->pOldNode );
//          }
//          else
//          {
//              pInfo->pNode = DuplicateEntryNode( pInfo->pOldNode );
//          }
//      }

//      if (!pInfo->pNode)
//      {
//          TRACE( "DuplicateEntryNode failed" );
//          *pdwOp = SID_OP_RetrievingData;
//          return ERROR_NOT_ENOUGH_MEMORY;
//      }

        // Store entry within work node stored in context for convenience
        // elsewhere.
        //
//      pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );

        // Save original entry name for comparison later.
        //
//      lstrcpyn(
//          pInfo->szOldEntryName,
//          pInfo->pEntry->pszEntryName,
//          RAS_MaxEntryName + 1);

        // For router, want unconfigured ports to show up as "unavailable" so
        // they stand out to user who has been directed to change them.
        //
//      if (pInfo->fRouter)
//      {
//          DTLNODE* pNodeL;
//          PBLINK* pLink;

//          pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//          pLink = (PBLINK* )DtlGetData( pNodeL );

//          if (!pLink->pbport.fConfigured)
//          {
//              Free( pLink->pbport.pszDevice );
//              pLink->pbport.pszDevice = NULL;
//          }
//      }

        // pmay: 277801
        //
        // Remember the "current" device if this entry was last saved
        // as single link.
        //
//      if (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1)
//      {
//          DTLNODE* pNodeL;
//          PBLINK* pLink;

//          pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//          pLink = (PBLINK* )DtlGetData( pNodeL );

//          if (pLink->pbport.pszDevice && pLink->pbport.pszPort)
//          {
//              pInfo->pszCurDevice =
//                  StrDup(pLink->pbport.pszDevice);
//              pInfo->pszCurPort =
//                  StrDup(pLink->pbport.pszPort);
//          }
//      }

        // Append all non-configured ports of the entries type to the list of
        // links.  This is for the convenience of the UI.  The non-configured
        // ports are removed after editing prior to saving.
        //
//      AppendDisabledPorts( pInfo, pInfo->pEntry->dwType );
//  }

    // Set up the phone number storage for shared phone number mode.
    // Initialize it to a copy of the information from the first link which at
    // startup will always be enabled.  Note the Dial case with non-0
    // dwSubEntry is an exception, but in that case the pSharedNode anyway.
    //
//  {
//      DTLNODE* pNode;

//      pInfo->pSharedNode = CreateLinkNode();
//      if (!pInfo->pSharedNode)
//      {
//          *pdwOp = SID_OP_RetrievingData;
//          return ERROR_NOT_ENOUGH_MEMORY;
//      }

//      ASSERT( pInfo->pSharedNode );
//      pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//      ASSERT( pNode );
//      CopyLinkPhoneNumberInfo( pInfo->pSharedNode, pNode );
//  }

    // Load the current shared-access (and firewall) settings
    //
    if (!pInfo->fRouter)
    {
        HRESULT hr;
        HNET_CONN_PROPERTIES *pProps;

        // Make sure COM is initialized on this thread.
        //
        hr = CoInitializeEx(
                NULL,
                COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE
                );

        if (SUCCEEDED(hr))
        {
            pInfo->fComInitialized = TRUE;
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // Create the home networking configuration manager
            //
            hr = CoCreateInstance(
                    CLSID_HNetCfgMgr,
                    NULL,
                    CLSCTX_ALL,
                    __uuidof(IHNetCfgMgr),
                    (void**)&pInfo->pHNetCfgMgr);

        }

        if (SUCCEEDED(hr))
        {
            // Get the IHNetIcsSettings interface
            //

            hr = pInfo->pHNetCfgMgr->QueryInterface(
                    __uuidof(IHNetIcsSettings), (void**)&pInfo->pIcsSettings);
        }

        if (SUCCEEDED(hr))
        {
            // Convert the entry to an IHNetConnection
            //

            hr = pInfo->pHNetCfgMgr->GetIHNetConnectionForGuid(
                    pInfo->pEntry->pGuid, FALSE, TRUE,
                    &pInfo->pHNetConn);
        }

        if (SUCCEEDED(hr))
        {
            // Determine whether this entry is already shared;
            // skip the check for new entries.
            //
            if (pInfo->pEntry->pszEntryName)
            {
                hr = pInfo->pHNetConn->GetProperties (&pProps);
                if (SUCCEEDED(hr))
                {
                    pInfo->fShared = pProps->fIcsPublic;
                    pInfo->fFirewalled = pProps->fFirewalled;
                    CoTaskMemFree(pProps);
                }
            }
            else
            {
                pInfo->fShared = FALSE;
                pInfo->fFirewalled = FALSE;
            }

            pInfo->fNewShared = pInfo->fShared;
            pInfo->fNewFirewalled = pInfo->fFirewalled;
        }

        if (SUCCEEDED(hr))
        {
            // Obtain an array of possible ICS private connections
            //
            hr = pInfo->pIcsSettings->GetPossiblePrivateConnections(
                    pInfo->pHNetConn,
                    &pInfo->dwLanCount,
                    &pInfo->rgPrivateConns,
                    &pInfo->lxCurrentPrivate
                    );

            RasQuerySharedAutoDial(&pInfo->fDemandDial);
            pInfo->fNewDemandDial = pInfo->fDemandDial;
            pInfo->fResetPrivateAdapter =
            pInfo->fShared && -1 == pInfo->lxCurrentPrivate;
        }

        pInfo->hShowHNetPagesResult = hr;

        if(SUCCEEDED(hr))
        {
            pInfo->fShowHNetPages = TRUE;
        }
    }

//  if (pInfo->fRouter)
//  {
//      pInfo->pEntry->dwfExcludedProtocols |= NP_Nbf;
//  }

    // AboladeG - capture the security level of the current user.
    //
    pInfo->fIsUserAdminOrPowerUser = FIsUserAdminOrPowerUser();

    return 0;
}

BOOL
FIsUserAdminOrPowerUser()
{
    SID_IDENTIFIER_AUTHORITY    SidAuth = SECURITY_NT_AUTHORITY;
    PSID                        psid;
    BOOL                        fIsMember = FALSE;
    BOOL                        fRet = FALSE;
    SID                         sidLocalSystem = { 1, 1,
                                    SECURITY_NT_AUTHORITY,
                                    SECURITY_LOCAL_SYSTEM_RID };


    // Check to see if running under local system first
    //
    if (!CheckTokenMembership( NULL, &sidLocalSystem, &fIsMember ))
    {
        TRACE( "CheckTokenMemberShip for local system failed.");
        fIsMember = FALSE;
    }

    fRet = fIsMember;

    if (!fIsMember)
    {
        // Allocate a SID for the Administrators group and check to see
        // if the user is a member.
        //
        if (AllocateAndInitializeSid( &SidAuth, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &psid ))
        {
            if (!CheckTokenMembership( NULL, psid, &fIsMember ))
            {
                TRACE( "CheckTokenMemberShip for admins failed.");
                fIsMember = FALSE;
            }

            FreeSid( psid );

// Changes to the Windows 2000 permission model mean that regular Users
// on workstations are in the power user group.  So we no longer want to
// check for power user.
#if 0
            if (!fIsMember)
            {
                // They're not a member of the Administrators group so allocate a
                // SID for the Power Users group and check to see
                // if the user is a member.
                //
                if (AllocateAndInitializeSid( &SidAuth, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_POWER_USERS,
                             0, 0, 0, 0, 0, 0,
                             &psid ))
                {
                    if (!CheckTokenMembership( NULL, psid, &fIsMember ))
                    {
                        TRACE( "CheckTokenMemberShip for power users failed.");
                        fIsMember = FALSE;
                    }

                    FreeSid( psid );
                }
            }
#endif
        }

        fRet = fIsMember;
    }

    return fRet;
}

BOOL PeApply (IN HWND hwndPage)
{
    // Saves the contents of the property sheet.  'HwndPage is the handle of a
    // property page.  Pops up any errors that occur.
    //
    // Returns true is page can be dismissed, false otherwise.
    //
    DWORD dwErr;
    PEINFO* pInfo;
    BILLSPBENTRY* pEntry;

    TRACE( "PeApply" );

    pInfo = PeContext( hwndPage );
    ASSERT( pInfo );
    if (pInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pEntry = pInfo->pArgs->pEntry;
    ASSERT( pEntry );

    // Save General page fields.
    //
//  ASSERT( pInfo->hwndGe );
//  {
//      DTLNODE* pNode;

        // Retrieve the lone common control.
        //
//      pEntry->fShowMonitorIconInTaskBar =
//          Button_GetCheck( pInfo->hwndCbShowIcon );

//      if (pEntry->dwType == RASET_Phone)
//      {
//          DWORD dwCount;

//          dwCount = GeSaveLvDeviceChecks( pInfo );

            // Don't allow the user to deselect all of the
            // devices
//          if ( (pInfo->pArgs->fMultipleDevices) && (dwCount == 0) )
//          {
//              MsgDlg( hwndPage, SID_SelectDevice, NULL );
//              PropSheet_SetCurSel ( pInfo->hwndDlg, pInfo->hwndGe, 0 );
//              SetFocus ( pInfo->hwndLvDevices );
//              return FALSE;
//          }

            // Save the "shared phone number" setting.  As usual, single
            // device mode implies shared mode, allowing things to fall
            // through correctly.
            //
//          if (pInfo->pArgs->fMultipleDevices)
//          {
//              pEntry->fSharedPhoneNumbers =
//                  Button_GetCheck( pInfo->hwndCbSharedPhoneNumbers );
//          }
//          else
//          {
//              pEntry->fSharedPhoneNumbers = TRUE;
//          }

            // Set the phone number set for the first phone number of the
            // current link (shared or selected) to the contents of the phone
            // number controls.
            //
//          GeGetPhoneFields( pInfo, pInfo->pCurLinkNode );

            // Swap lists, saving updates to caller's global list of area
            // codes.  Caller's original list will be destroyed by PeTerm.
            //
//          if (pInfo->pListAreaCodes)
//          {
//              DtlSwapLists(
//                  pInfo->pArgs->pUser->pdtllistAreaCodes,
//                  pInfo->pListAreaCodes );
//              pInfo->pArgs->pUser->fDirty = TRUE;
//          }
//      }
//      else if (pEntry->dwType == RASET_Vpn)
//      {
//          DTLNODE* pNode;
//          PBLINK* pLink;
//          PBPHONE* pPhone;

            // Save host name, i.e. the VPN phone number.
            //
//          pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//          ASSERT( pNode );
//          pLink = (PBLINK* )DtlGetData( pNode );
//          pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

//          if(NULL == pNode)
//          {
//              return FALSE;
//          }

//          pPhone = (PBPHONE* )DtlGetData( pNode );
//          Free0( pPhone->pszPhoneNumber );
//          pPhone->pszPhoneNumber = GetText( pInfo->hwndEbHostName );
//          FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

            // Any prequisite entry selection change has been saved already.
            // Just need to toss it if disabled.
            //
//          if (!Button_GetCheck( pInfo->hwndCbDialAnotherFirst ))
//          {
//              Free0( pEntry->pszPrerequisiteEntry );
//              pEntry->pszPrerequisiteEntry = NULL;
//              Free0( pEntry->pszPrerequisitePbk );
//              pEntry->pszPrerequisitePbk = NULL;
//          }
//      }
//      else if (pEntry->dwType == RASET_Broadband)
//      {
//          DTLNODE* pNode;
//          PBLINK* pLink;
//          PBPHONE* pPhone;

            // Save service name, i.e. the broadband phone number.
            //
//          pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//          ASSERT( pNode );
//          pLink = (PBLINK* )DtlGetData( pNode );
//          pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

//          if(NULL == pNode)
//          {
//              return FALSE;
//          }

//          pPhone = (PBPHONE* )DtlGetData( pNode );
//          Free0( pPhone->pszPhoneNumber );
//          pPhone->pszPhoneNumber = GetText( pInfo->hwndEbBroadbandService );
//          FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );
//      }
//      else if (pEntry->dwType == RASET_Direct)
//      {
//          DTLNODE* pNode;
//          PBLINK* pLink;

            // The currently enabled device is the one
            // that should be used for the connection.  Only
            // one device will be enabled (DnUpdateSelectedDevice).
//          for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//               pNode;
//               pNode = DtlGetNextNode( pNode ))
//          {
//              pLink = (PBLINK* )DtlGetData( pNode );
//              ASSERT(pLink);

//              if ( pLink->fEnabled )
//                  break;
//          }

            // If we found a link successfully, deal with it
            // now.
//          if ( pLink && pLink->fEnabled ) {
//              if (pLink->pbport.pbdevicetype == PBDT_ComPort)
//                  MdmInstallNullModem (pLink->pbport.pszPort);
//          }
//      }
//  }

    // Save Options page fields.
    //
//  if (pInfo->hwndOe)
//  {
//      UINT unValue;
//      BOOL f;
//      INT iSel;

//      pEntry->fShowDialingProgress =
//          Button_GetCheck( pInfo->hwndCbDisplayProgress );

        // Note: The'fPreviewUserPw', 'fPreviewDomain' fields are updated as
        //       they are changed.

//      pEntry->fPreviewPhoneNumber =
//          Button_GetCheck( pInfo->hwndCbPreviewNumber );

//      unValue = GetDlgItemInt(
//          pInfo->hwndOe, CID_OE_EB_RedialAttempts, &f, FALSE );
//      if (f && unValue <= 999999999)
//      {
//          pEntry->dwRedialAttempts = unValue;
//      }

//      iSel = ComboBox_GetCurSel( pInfo->hwndLbRedialTimes );
//      pEntry->dwRedialSeconds =
//          (DWORD )ComboBox_GetItemData( pInfo->hwndLbRedialTimes, iSel );

//      iSel = ComboBox_GetCurSel( pInfo->hwndLbIdleTimes );
//      pEntry->lIdleDisconnectSeconds =
//          (LONG )ComboBox_GetItemData( pInfo->hwndLbIdleTimes, iSel );

//      if (pInfo->pArgs->fRouter)
//      {
//          pEntry->fRedialOnLinkFailure =
//              Button_GetCheck( pInfo->hwndRbPersistent );
//      }
//      else
//      {
//          pEntry->fRedialOnLinkFailure =
//              Button_GetCheck( pInfo->hwndCbRedialOnDrop );
//      }

        // Note: dwDialMode is saved as changed.
        // Note: X.25 settings are saved at OK on that dialog.
//  }

    // Save Security page fields.
    //
//  if (pInfo->hwndLo)
//  {
//      if (Button_GetCheck( pInfo->hwndRbTypicalSecurity ))
//      {
//          LoSaveTypicalAuthSettings( pInfo );

//          if (pEntry->dwTypicalAuth == TA_CardOrCert)
//          {
                /*
                // Toss any existing advanced EAP configuration remnants when
                // typical smartcard, per bug 262702 and VBaliga email.
                //
                Free0( pEntry->pCustomAuthData );
                pEntry->pCustomAuthData = NULL;
                pEntry->cbCustomAuthData = 0;

                */
//              (void) DwSetCustomAuthData(
//                          pEntry,
//                          0,
//                          NULL);

//              TRACE( "RasSetEapUserData" );
//              ASSERT( g_pRasGetEntryDialParams );
//              g_pRasSetEapUserData(
//                  INVALID_HANDLE_VALUE,
//                  pInfo->pArgs->pFile->pszPath,
//                  pEntry->pszEntryName,
//                  NULL,
//                  0 );
//              TRACE( "RasSetEapUserData done" );
//          }
//      }

//      if (pEntry->dwType == RASET_Phone)
//      {
//          Free0( pEntry->pszScriptAfter );
//          SuGetInfo( &pInfo->suinfo,
//              &pEntry->fScriptAfter,
//              &pEntry->fScriptAfterTerminal,
//              &pEntry->pszScriptAfter );
//      }
//  }

    // Save Network page fields.
    // We won't have anything to do if we never initialized pNetCfg.
    //
//  if (pInfo->pNetCfg)
//  {
//      HRESULT             hr;

        // Update the phone book entry with the enabled state of the components.
        // Do this by enumerating the components from the list view item data
        // and consulting the check state for each.
        //
//      NeSaveBindingChanges(pInfo);

//      hr = INetCfg_Apply (pInfo->pNetCfg);
//      if (((NETCFG_S_REBOOT == hr) || (pInfo->fRebootAlreadyRequested)) &&
//            pInfo->pNetConUtilities)
//      {
//          DWORD dwFlags = QUFR_REBOOT;
//          if (!pInfo->fRebootAlreadyRequested)
//              dwFlags |= QUFR_PROMPT;

            //$TODO NULL caption?
//          INetConnectionUiUtilities_QueryUserForReboot (
//                  pInfo->pNetConUtilities, pInfo->hwndDlg, NULL, dwFlags);
//      }
//  }

    // Save Shared Access page fields
    //
    if (pInfo->hwndSa)
    {
        // record the (new) sharing and demand-dial settings
        //
        pInfo->pArgs->fNewShared =
            Button_GetCheck( pInfo->hwndSaPbShared );
        pInfo->pArgs->fNewDemandDial =
            Button_GetCheck( pInfo->hwndSaPbDemandDial );
        pInfo->pArgs->fNewBeaconControl = 
            Button_GetCheck( GetDlgItem(pInfo->hwndSa, CID_SA_PB_Beacon) );

        // we only look at the private-lan drop list
        // if the user just turned on sharing, since that's the only time
        // we display the drop-list to begin with. we also need to look if
        // we need to reset the private adapter
        //
        if ((pInfo->pArgs->fNewShared && !pInfo->pArgs->fShared)
            || pInfo->pArgs->fResetPrivateAdapter)
        {
            if (pInfo->pArgs->dwLanCount > 1)
            {
                INT item = ComboBox_GetCurSel( pInfo->hwndSaLbPrivateLan );
                if (item != CB_ERR)
                {
                    pInfo->pArgs->pPrivateLanConnection =
                        (IHNetConnection*)ComboBox_GetItemData(
                                    pInfo->hwndSaLbPrivateLan, item );
                }
            }
            else if (pInfo->pArgs->dwLanCount)
            {
                ASSERT(pInfo->pArgs->rgPrivateConns);

                pInfo->pArgs->pPrivateLanConnection =
                    pInfo->pArgs->rgPrivateConns[0];
            }
        }

    // Save Firewall fields
    //
        pInfo->pArgs->fNewFirewalled =
            Button_GetCheck( pInfo->hwndSaPbFirewalled );
    }

#if 0 //!!!
    if ((fLocalPad || iPadSelection != 0)
        && (!pEntry->pszX25Address || IsAllWhite( pEntry->pszX25Address )))
    {
        // Address field is blank with X.25 dial-up or local PAD chosen.
        //
        MsgDlg( pInfo->hwndDlg, SID_NoX25Address, NULL );
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_XsPage );
        SetFocus( pInfo->hwndEbX25Address );
        Edit_SetSel( pInfo->hwndEbX25Address, 0, -1 );
        return FALSE;
    }
#endif

    // Make sure proprietary ISDN options are disabled if more than one link
    // is enabled.  The proprietary ISDN option is only meaningful when
    // calling a down-level server that needs Digiboard channel aggragation
    // instead of PPP multi-link.
    //
//  {
//      DTLNODE* pNode;
//      DWORD cIsdnLinks;

//      cIsdnLinks = 0;
//      for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//           pNode;
//           pNode = DtlGetNextNode( pNode ))
//      {
//          PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
//          ASSERT(pLink);

//          if (pLink->fEnabled && pLink->pbport.pbdevicetype == PBDT_Isdn)
//          {
//              ++cIsdnLinks;
//          }
//      }

//      if (cIsdnLinks > 1)
//      {
//          for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
//               pNode;
//               pNode = DtlGetNextNode( pNode ))
//          {
//              PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
//              ASSERT(pLink);

//              if (pLink->fEnabled && pLink->fProprietaryIsdn)
//              {
//                  pLink->fProprietaryIsdn = FALSE;
//              }
//          }
//      }
//  }

    // Inform user that edits to the connected entry won't take affect until
    // the entry is hung up and re-dialed, per PierreS's insistence.
    //
//  if (HrasconnFromEntry( pInfo->pArgs->pFile->pszPath, pEntry->pszEntryName ))
//  {
//      MsgDlg( pInfo->hwndDlg, SID_EditConnected, NULL );
//  }

    // It's a valid new/changed entry.  Commit the changes to the phonebook
    // and preferences.  This occurs immediately in "ShellOwned" mode where
    // the RasEntryDlg API has already returned, but is otherwise deferred
    // until the API is ready to return.
    //
//  if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
//  {
        EuCommit( pInfo->pArgs );
//  }
//  else
//  {
//      pInfo->pArgs->fCommit = TRUE;
//  }
    return TRUE;
}

BOOL EuCommit(IN EINFO* pInfo )
{
    // Commits the new or changed entry node to the phonebook file and list.
    // Also adds the area code to the per-user list, if indicated.  'PInfo' is
    // the common entry information block.
    //
    // Returns true if successful, false otherwise.
    //
    DWORD dwErr;
//  BOOL fEditMode;
//  BOOL fChangedNameInEditMode;

    // If shared phone number, copy the phone number information from the
    // shared link to each enabled link.
    //
//  if (pInfo->pEntry->fSharedPhoneNumbers)
//  {
//      DTLNODE* pNode;

//      ASSERT( pInfo->pEntry->dwType == RASET_Phone );

//      for (pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//           pNode;
//           pNode = DtlGetNextNode( pNode ))
//      {
//          PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
//          ASSERT(pLink);

//          if (pLink->fEnabled)
//          {
//              CopyLinkPhoneNumberInfo( pNode, pInfo->pSharedNode );
//          }
//      }
//  }

    // Delete all disabled link nodes.
    //
//  if (pInfo->fMultipleDevices)
//  {
//      DTLNODE* pNode;

//      pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//      while (pNode)
//      {
//          PBLINK*  pLink = (PBLINK* )DtlGetData( pNode );
//          DTLNODE* pNextNode = DtlGetNextNode( pNode );

//          if (!pLink->fEnabled)
//          {
//              DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNode );
//              DestroyLinkNode( pNode );
//          }

//          pNode = pNextNode;
//      }
//  }

    // pmay: 277801
    //
    // Update the preferred device if the one selected is different
    // from the device this page was initialized with.
    //
//  if ((pInfo->fMultipleDevices) &&
//      (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1))
//  {
//      DTLNODE* pNodeL;
//      PBLINK* pLink;
//      BOOL bUpdatePref = FALSE;

//      pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
//      pLink = (PBLINK*) DtlGetData( pNodeL );

//      TRACE( "Mult devs, only one selected -- check preferred dev." );

//      if ((pInfo->pszCurDevice == NULL) || (pInfo->pszCurPort == NULL))
//      {
//          TRACE( "No preferred device.  Resetting preferred to current." );
//          bUpdatePref = TRUE;
//      }
//      else if (
//          (lstrcmpi(pInfo->pszCurDevice, pLink->pbport.pszDevice)) ||
//          (lstrcmpi(pInfo->pszCurPort, pLink->pbport.pszPort)))
//      {
//          TRACE( "New device selected as preferred device" );
//          bUpdatePref = TRUE;
//      }
//      if (bUpdatePref)
//      {
//          Free0(pInfo->pEntry->pszPreferredDevice);
//          Free0(pInfo->pEntry->pszPreferredPort);

//          pInfo->pEntry->pszPreferredDevice =
//              StrDup(pLink->pbport.pszDevice);
//          pInfo->pEntry->pszPreferredPort =
//              StrDup(pLink->pbport.pszPort);
//      }
//  }

    // Save preferences if they've changed.
    //
//  if (pInfo->pUser->fDirty)
//  {
//      INTERNALARGS *pIArgs = (INTERNALARGS *)pInfo->pApiArgs->reserved;

//      if (g_pSetUserPreferences(
//              (pIArgs) ? pIArgs->hConnection : NULL,
//              pInfo->pUser,
//              (pInfo->fRouter) ? UPM_Router : UPM_Normal ) != 0)
//      {
//          return FALSE;
//      }
//  }

    // Save the changed phonebook entry.
    //
//  pInfo->pEntry->fDirty = TRUE;

    // The final name of the entry is output to caller via API structure.
    //
//  lstrcpyn(
//      pInfo->pApiArgs->szEntry,
//      pInfo->pEntry->pszEntryName,
//      RAS_MaxEntryName + 1);

    // Delete the old node if in edit mode, then add the new node.
    //
//  EuGetEditFlags( pInfo, &fEditMode, &fChangedNameInEditMode );

//  if (fEditMode)
//  {
//      DtlDeleteNode( pInfo->pFile->pdtllistEntries, pInfo->pOldNode );
//  }

//  DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pInfo->pNode );
//  pInfo->pNode = NULL;

    // Write the change to the phone book file.
    //
//  dwErr = WritePhonebookFile( pInfo->pFile,
//              (fChangedNameInEditMode) ? pInfo->szOldEntryName : NULL );

//  if (dwErr != 0)
//  {
//      ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_WritePhonebook, dwErr,
//          NULL );
//      // shaunco - fix RAID 171651 by assigning dwErr to callers structure.
//      pInfo->pApiArgs->dwError = dwErr;
//      return FALSE;
//  }

    // Notify through rasman that the entry has changed
    //
//  if(pInfo->pApiArgs->dwFlags & (RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry))
//  {
//      dwErr = DwSendRasNotification(
//                      ENTRY_ADDED,
//                      pInfo->pEntry,
//                      pInfo->pFile->pszPath);
//  }
//  else
//  {
//      dwErr = DwSendRasNotification(
//                      ENTRY_MODIFIED,
//                      pInfo->pEntry,
//                      pInfo->pFile->pszPath);

//  }

    // Ignore the error returned from DwSendRasNotification - we don't want
    // to fail the operation in this case. The worst case scenario is that
    // the connections folder won't refresh automatically.
    //
//  dwErr = ERROR_SUCCESS;

    // If EuCommit is being called as a result of completing the "new demand
    // dial interface" wizard, then we need to create the new demand dial
    // interface now.
    //
//  if ( EuRouterInterfaceIsNew( pInfo ) )
//  {
        //Create Router MPR interface and save user credentials
        //like UserName, Domain and Password
        //IPSec credentials are save in EuCredentialsCommitRouterIPSec
        //

//      dwErr = EuRouterInterfaceCreate( pInfo );

        // If we weren't successful at commiting the interface's
        // credentials, then delete the new phonebook entry.
        //
//      if ( dwErr != NO_ERROR )
//      {
//          WritePhonebookFile( pInfo->pFile, pInfo->pApiArgs->szEntry );
//          pInfo->pApiArgs->dwError = dwErr;
//          return FALSE;
//      }

//  }

    // Now save any per-connection credentials
    //
//  dwErr = EuCredentialsCommit( pInfo );

   // If we weren't successful at commiting the interface's
  // credentials, then delete the new phonebook entry.
   //
// if ( dwErr != NO_ERROR )
//  {
//      ErrorDlg( pInfo->pApiArgs->hwndOwner,
//                SID_OP_CredCommit,
//                dwErr,
//                NULL );

//      pInfo->pApiArgs->dwError = dwErr;

//     return FALSE;
//  }

    // Save the default Internet connection settings as appropriate.  Igonre
    // the error returned as failure to set the connection as default need
    // not prevent the connection/interface creation.
    //
//  dwErr = EuInternetSettingsCommitDefault( pInfo );
//  dwErr = NO_ERROR;

    // If the user edited/created a router-phonebook entry, store the bitmask
    // of selected network-protocols in 'reserved2'.
    //
//  if (pInfo->fRouter)
//  {
//      pInfo->pApiArgs->reserved2 =
//          ((NP_Ip | NP_Ipx) & ~pInfo->pEntry->dwfExcludedProtocols);
//  }

    // Commit the user's changes to home networking settings.
    // Ignore the return value.
    //
    dwErr = EuHomenetCommitSettings(pInfo);
    dwErr = NO_ERROR;

//  pInfo->pApiArgs->dwError = 0;
    return TRUE;
}

DWORD EuHomenetCommitSettings(IN EINFO* pInfo)
{
    HRESULT hr = S_OK;
    ULONG ulcPublic;
    ULONG ulcPrivate;
    BOOL fPrivateConfigured = FALSE;
    HNET_CONN_PROPERTIES *pProps;
    DWORD dwErr = NO_ERROR;
    BOOL fConflictMessageDisplayed = FALSE;


    if (pInfo->fRouter)
    {
        return NO_ERROR;
    }

    if (!!pInfo->fShared != !!pInfo->fNewShared)
    {
        if (pInfo->fShared)
        {
            hr = pInfo->pIcsSettings->DisableIcs (&ulcPublic, &ulcPrivate);
        }
        else
        {
            // Check to see if the private connection is
            // already properly configured
            //

            hr = pInfo->pPrivateLanConnection->GetProperties (&pProps);
            if (SUCCEEDED(hr))
            {
                fPrivateConfigured = !!pProps->fIcsPrivate;
                CoTaskMemFree(pProps);
            }

            if (pInfo->fOtherShared)
            {
                if (fPrivateConfigured)
                {
                    // Using the same private connection, so
                    // only modify the old public
                    //

                    ASSERT(NULL != pInfo->pOldSharedConnection);
                    hr = pInfo->pOldSharedConnection->Unshare();
                }
                else
                {
                    hr = pInfo->pIcsSettings->DisableIcs (&ulcPublic, &ulcPrivate);
                }
            }

            if (SUCCEEDED(hr))
            {
                IHNetIcsPublicConnection *pIcsPublic;
                IHNetIcsPrivateConnection *pIcsPrivate;

                hr = pInfo->pHNetConn->SharePublic (&pIcsPublic);
                if (SUCCEEDED(hr))
                {
                    if (!fPrivateConfigured)
                    {
                        hr = pInfo->pPrivateLanConnection->SharePrivate (&pIcsPrivate);
                        if (SUCCEEDED(hr))
                        {
                            pIcsPrivate->Release();
                        }
                        else
                        {
                            pIcsPublic->Unshare();
                        }
                    }
                    pIcsPublic->Release();
                }
            }

            if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_RRAS_CONFLICT))
            {
                fConflictMessageDisplayed = TRUE;
                MsgDlg(pInfo->hwndOwner, SID_SharingConflict, NULL);
            }
            else if (FAILED(hr))
            {
                if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
                {
                    dwErr = HRESULT_CODE(hr);
                }
                else
                {
                    dwErr = (DWORD) hr;
                }

                ErrorDlg(
                    pInfo->hwndOwner,
                    pInfo->fShared
                    ? SID_OP_UnshareConnection : SID_OP_ShareConnection,
                    dwErr, NULL );
            }
        }
    }
    else if (pInfo->fResetPrivateAdapter && pInfo->dwLanCount)
    {

        IHNetIcsPrivateConnection *pIcsPrivateConnection;
        hr = pInfo->pPrivateLanConnection->SharePrivate(&pIcsPrivateConnection);
        if (SUCCEEDED(hr))
        {
            pIcsPrivateConnection->Release();
        }
        else
        {
            ULONG ulPublicCount, ulPrivateCount;
            HRESULT hr2 = pInfo->pIcsSettings->DisableIcs(&ulPublicCount, &ulPrivateCount);
            if (SUCCEEDED(hr2))
            {
                pInfo->fShared = FALSE;
            }

            ErrorDlg(pInfo->hwndOwner, SID_OP_ShareConnection, hr, NULL );
        }
    }

    if (!!pInfo->fDemandDial != !!pInfo->fNewDemandDial)
    {
        dwErr = RasSetSharedAutoDial(pInfo->fNewDemandDial);
        if (dwErr)
        {
            ErrorDlg(
                pInfo->hwndOwner,
                pInfo->fDemandDial
                ? SID_OP_DisableDemandDial : SID_OP_EnableDemandDial,
                dwErr, NULL );
        }
    }

    HKEY hKey;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, NULL, 0, KEY_SET_VALUE, NULL, &hKey, NULL))
    {
        DWORD dwData = pInfo->fNewBeaconControl;
        RegSetValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, REG_DWORD, reinterpret_cast<LPBYTE>(&dwData), sizeof(dwData));
        RegCloseKey(hKey);
    }

    // Commit changes to firewall settings
    //
    if (!!pInfo->fFirewalled != !!pInfo->fNewFirewalled)
    {
        IHNetFirewalledConnection *pFwConn;

        if (pInfo->fNewFirewalled)
        {
            hr = pInfo->pHNetConn->Firewall (&pFwConn);
            if (SUCCEEDED(hr))
            {
                pFwConn->Release();
            }
        }
        else
        {
            hr = pInfo->pHNetConn->GetControlInterface (
                                IID_IHNetFirewalledConnection,
                                (void**)&pFwConn);
            if (SUCCEEDED(hr))
            {
                hr = pFwConn->Unfirewall();
                pFwConn->Release();
            }
        }

        if (FAILED(hr))
        {
            if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
            {
                dwErr = HRESULT_CODE(hr);
            }
            else
            {
                dwErr = (DWORD) hr;
            }

            if (dwErr != ERROR_SHARING_RRAS_CONFLICT)
            {
                ErrorDlg(
                    pInfo->hwndOwner,
                    pInfo->fFirewalled
                    ? SID_OP_UnshareConnection : SID_OP_ShareConnection,
                    dwErr, NULL );
            }
            else if (FALSE == fConflictMessageDisplayed)
            {
                MsgDlg(pInfo->hwndOwner, SID_SharingConflict, NULL);
            }
        }
    }


    return dwErr;
}

HRESULT APIENTRY
HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu)
{
    HRESULT hr;

    hr = CoCreateInstance (CLSID_NetConnectionUiUtilities, NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_INetConnectionUiUtilities, (void**)ppncuu);
    return hr;
}

// --------------------------------------------------------------------------
// exported function here
// --------------------------------------------------------------------------

static LPDLGTEMPLATE CopyDialogTemplate (HINSTANCE hinst, LPCWSTR wszResource)
{
    LPDLGTEMPLATE lpdtCopy = NULL;

    HRSRC hrsrc = FindResourceW (hinst, wszResource, (LPCWSTR)RT_DIALOG);
    if (hrsrc) {
        HGLOBAL hg = LoadResource (hinst, hrsrc);
        if (hg) {
            LPDLGTEMPLATE lpdt = (LPDLGTEMPLATE) LockResource (hg);
            if (lpdt) {
                DWORD dwSize = SizeofResource (hinst, hrsrc);
                if (dwSize) {
                    lpdtCopy = (LPDLGTEMPLATE)Malloc (dwSize);
                    if (lpdtCopy) {
                        CopyMemory (lpdtCopy, lpdt, dwSize);
                    }
                }
            }
        }
    }
    return lpdtCopy;
}

void SetSAUIhInstance (HINSTANCE hInstance)
{
    _ASSERT (g_hinstDll == NULL);
    _ASSERT (hInstance  != NULL);
    g_hinstDll = hInstance;
}

extern "C" HRESULT HNetGetFirewallSettingsPage (PROPSHEETPAGEW * pPSP, GUID * pGuid)
{
    // zeroth thing:  the PROPSHEETPAGEW struct is different sizes depending
    // on what version of _WIN32_IE and _WIN32_WINNT are set to.  So, check
    // the dwSize field
    if (IsBadWritePtr (pPSP, sizeof(DWORD)))
        return E_POINTER;
    if (IsBadWritePtr (pPSP, pPSP->dwSize))
        return HRESULT_FROM_WIN32 (ERROR_INVALID_SIZE);
    if (pPSP->dwSize < RTL_SIZEOF_THROUGH_FIELD (PROPSHEETPAGEW, lParam))
        return HRESULT_FROM_WIN32 (ERROR_INVALID_SIZE);

    // first thing: check rights
    if (FALSE == FIsUserAdminOrPowerUser ())
        return HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
    {
        // Check if ZAW is denying access to the Shared Access UI
        BOOL fShowAdvancedUi = TRUE;
        INetConnectionUiUtilities* pncuu = NULL;
        HrCreateNetConnectionUtilities(&pncuu);
        if (pncuu)
        {
            if ((FALSE == pncuu->UserHasPermission (NCPERM_ShowSharedAccessUi)) &&
                (FALSE == pncuu->UserHasPermission (NCPERM_PersonalFirewallConfig)))
               fShowAdvancedUi = FALSE;
            pncuu->Release();
        }
        if (FALSE == fShowAdvancedUi)
            return HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
    }

    // setup global(s)
    g_contextId = (LPCTSTR)GlobalAddAtom (TEXT("SAUI"));
    if (!g_contextId)
        return GetLastError();

    PEINFO * pPEINFO = NULL;
    DWORD dwError = PeInit (pGuid, &pPEINFO);
    if (dwError == S_OK) {
        // we need this to init the link
        LinkWindow_RegisterClass(); // no need to ever unregister:  see ...\shell\shell32\linkwnd.cpp

        // fill out PSP:
        DWORD dwSize;
        ZeroMemory (pPSP, dwSize = pPSP->dwSize);
        pPSP->dwSize          = dwSize;
        pPSP->dwFlags         = 0;
        LPDLGTEMPLATE lpdt    = CopyDialogTemplate (g_hinstDll, MAKEINTRESOURCE (PID_SA_Advanced));
        if (lpdt) {
            // avoid idd collisions
            pPSP->dwFlags    |= PSP_DLGINDIRECT;
            pPSP->pResource   = lpdt;
            pPEINFO->lpdt     = lpdt;   // hang it here so I can free it
        } else  // if all else fails... (this should never happen).
            pPSP->pszTemplate = MAKEINTRESOURCE (PID_SA_Advanced);
        pPSP->hInstance       = g_hinstDll;
        pPSP->pfnDlgProc      = SaDlgProc;
        pPSP->lParam          = (LPARAM)pPEINFO;
    }
    return dwError;
}

//
//  Figure out if this is a single user connection.  If it is, then we need
//  to give them an error that explains that they should be using an all user
//  connection instead.
//  If this is an All-User connection, warn them if they don't have global credentials
//
VOID VerifyConnTypeAndCreds(IN PEINFO* pInfo)
{
    if (NULL == pInfo)
    {
        return;
    }

    BOOL fAllUser = FALSE;
    TCHAR szAppData[MAX_PATH+1]={0};

    HINSTANCE hinstDll = LoadLibrary (TEXT("shfolder.dll"));;
    
    if (hinstDll)
    {
        typedef HRESULT (*pfnGetFolderPathFunction) (HWND, int, HANDLE, DWORD, LPTSTR);
#ifdef UNICODE
        pfnGetFolderPathFunction pfnGetFolderPath = (pfnGetFolderPathFunction)GetProcAddress (hinstDll, "SHGetFolderPathW");
#else
        pfnGetFolderPathFunction pfnGetFolderPath = (pfnGetFolderPathFunction)GetProcAddress (hinstDll, "SHGetFolderPathA");
#endif

        if (pfnGetFolderPath && pInfo->pArgs->pEntry->pszEntryName)
        {
            HRESULT hr = pfnGetFolderPath(pInfo->hwndDlg , CSIDL_COMMON_APPDATA, NULL, 0, szAppData);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                //
                //  Okay, now we have the path to the common application data directory.
                //  Let's compare that against the phonebook path that we have and see
                //  if this is an all user connection or not.
                //
                const TCHAR* const c_pszRelativePbkPath = TEXT("\\Microsoft\\Network\\Connections\\Pbk");
                DWORD dwSize = (lstrlen(szAppData) + lstrlen(c_pszRelativePbkPath) + 1) * sizeof(TCHAR);
                LPTSTR pszAllUserPhoneBookDir =  (LPTSTR)Malloc(dwSize);
                
                if (pszAllUserPhoneBookDir)
                {
                    wsprintf(pszAllUserPhoneBookDir, TEXT("%s%s"), szAppData, c_pszRelativePbkPath);
                            
                    //
                    // Compare
                    //
                    if (pInfo->pArgs->pEntry->pszPhonebookPath)
                    {
                        LPTSTR pszAllUser = _tcsstr(pInfo->pArgs->pEntry->pszPhonebookPath, pszAllUserPhoneBookDir);

                        if (pszAllUser)
                        {
                            fAllUser = TRUE;
                        }
                        else
                        {
                            //
                            //  If the phonebook path wasn't based on the common app data dir, check to see
                            //  if it was based on the old ras phonebook location %windir%\system32\ras.
                            //
                            HRESULT hr2 = pfnGetFolderPath(pInfo->hwndDlg , CSIDL_SYSTEM, NULL, 0, szAppData);
                            if (SUCCEEDED(hr2) && (S_FALSE != hr2))
                            {
                                const TCHAR* const c_pszRas = TEXT("\\Ras");
                                DWORD dwSize2 = (lstrlen(szAppData) + lstrlen(c_pszRas) + 1) * sizeof(TCHAR);
                                LPTSTR pszOldRasPhoneBook = (LPTSTR)Malloc(dwSize2);

                                if (pszOldRasPhoneBook)
                                {
                                    wsprintf(pszOldRasPhoneBook, TEXT("%s%s"), szAppData, c_pszRas);

                                    pszAllUser = _tcsstr(pInfo->pArgs->pEntry->pszPhonebookPath, pszOldRasPhoneBook);
                                    
                                    if (pszAllUser)
                                    {
                                        fAllUser = TRUE;
                                    }                        
                                }
                                Free0(pszOldRasPhoneBook);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Phone book string is null - using default RAS phonebook which is for all users
                        //
                        fAllUser = TRUE;
                    }

                    // 
                    // Finally check if we have the proper credentials for an all user profile. If not then
                    // prompt user to create and save global credentials (option A).
                    // or display a message that an all-user profile is needed (option B)
                    //
                    if (fAllUser)
                    {
                        //
                        // Check if we have global passwords
                        //
                        BOOL fUserCreds = FALSE;
                        BOOL fGlobalCreds = FALSE;

                        FindEntryCredentials(pInfo->pArgs->pEntry->pszPhonebookPath, 
                                             pInfo->pArgs->pEntry->pszEntryName, 
                                             &fUserCreds, 
                                             &fGlobalCreds);

                        if (FALSE == fGlobalCreds)
                        {
                            //
                            // need to display warning message (A) - should have global creds
                            //
                            MSGARGS msgargs;
                            ZeroMemory( &msgargs, sizeof(msgargs) );
                            msgargs.dwFlags = MB_OK | MB_ICONINFORMATION;
                            MsgDlg( pInfo->hwndDlg, IDS_ALL_USER_CONN_MUST_HAVE_GLOBAL_CREDS, &msgargs );
                        }
                    }
                    else
                    {
                        //
                        // need to display warning message (B) - should create an all-user connection
                        //
                        MSGARGS msgargs;
                        ZeroMemory( &msgargs, sizeof(msgargs) );
                        msgargs.dwFlags = MB_OK | MB_ICONINFORMATION;
                        MsgDlg( pInfo->hwndDlg, IDS_PER_USER_CONN_NEED_TO_CREATE_ALL_USER_CONN, &msgargs );
                    }
                }
                Free0(pszAllUserPhoneBookDir);
            }
        }

        FreeLibrary(hinstDll);
    }
}

//
// All of this function is taken from RAS - rasdlg - dial.c 
// with some parts removed since we didn't need them here.
//
DWORD 
FindEntryCredentials(
    IN  TCHAR* pszPath,
    IN  TCHAR* pszEntryName,
    OUT BOOL* pfUser,               // set true if per user creds found
    OUT BOOL* pfGlobal              // set true if global creds found
    )

// Loads the credentials for the given entry into memory.  This routine 
// determines whether per-user or per-connection credentials exist or 
// both. 
// 
// The logic is a little complicated because RasGetCredentials had to 
// support legacy usage of the API.
//
// Here's how it works.  If only one set of credentials is stored for a 
// connection, then RasGetCredentials will return that set regardless of 
// whether the RASCM_DefalutCreds flag is set.  If two sets of credentials
// are saved, then RasGetCredentials will return the per-user credentials
// if the RASCM_DefaultCreds bit is set, and the per-connection credentials
// otherwise.
//
// Here is the algorithm for loading the credentials
//
// 1. Call RasGetCredentials with the RASCM_DefaultCreds bit cleared
//    1a. If nothing is returned, no credentials are saved
//    1b. If the RASCM_DefaultCreds bit is set on return, then only
//        global credentials are saved.
//
// 2. Call RasGetCredentials with the RASCM_DefaultCreds bit set
//    2a. If the RASCM_DefaultCreds bit is set on return, then 
//        both global and per-connection credentials are saved.
//    2b. Otherwise, only per-user credentials are saved.
//
{
    DWORD dwErr;
    RASCREDENTIALS rc1, rc2;
    BOOL fUseLogonDomain;

    TRACE( "saui.cpp - FindEntryCredentials" );

    // Initialize
    //
    *pfUser = FALSE;
    *pfGlobal = FALSE;
    ZeroMemory( &rc1, sizeof(rc1) );
    ZeroMemory( &rc2, sizeof(rc2) );
    rc1.dwSize = sizeof(rc1);
    rc2.dwSize = sizeof(rc2);

    if (NULL == pszPath || NULL == pszEntryName)
    {
        return (DWORD)-1; 
    }

    do 
    {
        // Look up per-user cached username, password, and domain.
        // See comment '1.' in the function header
        //
        rc1.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
        TRACE( "RasGetCredentials per-user" );
        dwErr = RasGetCredentials(pszPath, pszEntryName, &rc1 );
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc1.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 1a. in the function header comments
        //
        if (rc1.dwMask == 0)
        {
            dwErr = NO_ERROR;
            break;
        }

        // See 1b. in the function header comments
        //
        else if (rc1.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;
            dwErr = NO_ERROR;
            break;
        }

        // Look up global per-user cached username, password, domain.
        // See comment 2. in the function header
        //
        rc2.dwMask =  
            RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;

        TRACE( "RasGetCredentials global" );
        
        dwErr = RasGetCredentials(pszPath, pszEntryName, &rc2 );
        
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc2.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 2a. in the function header comments
        //
        if (rc2.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;

            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }
        }

        // See 2b. in the function header comments
        //
        else
        {
            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }
        }

    }while (FALSE);

    // Cleanup
    //
    SecureZeroMemory( rc1.szPassword, sizeof(rc1.szPassword) );
    SecureZeroMemory( rc2.szPassword, sizeof(rc2.szPassword) );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hnetcfg.rc
//

#include "resourc2.h"

// used by saui.cpp
#define IID_Direct                      561
#define IID_Phone                       562
#define IID_Vpn                         565

#define SID_EnableSharedAccess          511
#define SID_ChangeSharedConnection      509

// rasdlg advanced page
#define PID_SA_Advanced                 543
#define CID_SA_ST_HomeConnection        101
#define CID_SA_PB_Beacon                102
#define IID_PersonalFirewall            573
#define CID_FW_PB_Firewalled            15026
#define CID_SA_GB_PrivateLan            1518
#define CID_SA_GB_Shared                1517
#define IID_Dun1                        136
#define CID_SA_PB_Shared                15022
#define CID_SA_LB_PrivateLan            1516
#define CID_SA_EB_PrivateLan            1521
#define CID_SA_PB_DemandDial            15023
#define CID_SA_SF_PrivateLan            1519
#define CID_SA_ST_HNWLink               1659
#define CID_SA_ST_ICFLink               1660
#define CID_SA_ST_ICSLink               1661
#define CID_SA_PB_Settings              1564

#define SID_SA_SelectAdapter            1663
#define SID_SA_SelectAdapterError       1664
#define DID_SA_DisableFirewallWarning   1660
#define CID_SA_PB_DisableFirewallWarning 1662

#define SID_HelpFile                    264
#define HID_SA_PB_Shared                1150
#define HID_SA_PB_DemandDial            1151
#define HID_SA_PB_Settings              1152
#define HID_SA_LB_PrivateLan            1153
#define HID_FW_PB_Firewalled            1154
#define HID_SA_ST_ICFLink               1155
#define HID_SA_EB_PrivateLan            1156
#define HID_SA_PB_Beacon                1157
#define HID_SA_ST_ICSLink               1158
#define HID_SA_ST_HNWLink               1159

#define SID_SharingConflict             194
#define SID_OP_UnshareConnection        319
#define SID_OP_ShareConnection          330
#define SID_OP_DisableDemandDial        502
#define SID_OP_EnableDemandDial         500
#define SID_FMT_ErrorMsg                250

#define IDS_ALL_USER_CONN_MUST_HAVE_GLOBAL_CREDS        17001
#define IDS_PER_USER_CONN_NEED_TO_CREATE_ALL_USER_CONN  17002
// used by sadlg.cpp, etc.
#define PID_FW_FirewallLogging          571
#define CID_FL_CB_LogDroppedInbound     1642
#define CID_FL_CB_LogOutboundConnections 1641
#define CID_FL_EB_Filename              1674
#define CID_FL_PB_Browse                1639
#define CID_FL_EB_Filesize              1640
#define CID_FL_CB_LogOutboundConnections 1641
#define CID_FL_CB_LogDroppedInbound     1642
#define CID_FL_PB_RestoreDefaults       1643
#define SID_SharedAccessSettings        545
#define SID_NetworkApplicationSettings  546
#define PID_FW_ICMP                     572
#define CID_IC_LV_Settings              1644
#define CID_IC_ST_Description           1645
#define SID_OP_LoadDlg                  318

#define SID_TypeResponseList            540
#define SID_ICMP_IECHO                  1646
#define SID_ICMP_IECHO                  1646
#define SID_ICMP_ITIME                  1647
#define SID_ICMP_IMASK                  1648
#define SID_ICMP_IROUT                  1649
#define SID_ICMP_ODEST                  1650
#define SID_ICMP_OQNCH                  1651
#define SID_ICMP_OPRAM                  1652
#define SID_ICMP_OTIME                  1653
#define SID_ICMP_XRDRT                  1654
#define SID_ICMP_IECHO_DESC             1665
#define SID_ICMP_ITIME_DESC             1666
#define SID_ICMP_IMASK_DESC             1667
#define SID_ICMP_IROUT_DESC             1668
#define SID_ICMP_ODEST_DESC             1669
#define SID_ICMP_OQNCH_DESC             1670
#define SID_ICMP_OPRAM_DESC             1671
#define SID_ICMP_OTIME_DESC             1672
#define SID_ICMP_XRDRT_DESC             1673
#define SID_FwbInvalidSize              1675
#define SID_FwbFilterDesc               1657
#define SID_FwbTitle                    1658
#define SID_FwbDefExt                   1655

// Shared access settings property sheet, Services page.
//
#define HID_SS_LV_Services              4250
#define HID_SS_PB_Add                   4251
#define HID_SS_PB_Edit                  4252
#define HID_SS_PB_Delete                4253

// Shared access settings property sheet, New Service dialog.
//
#define HID_SS_EB_ExternalPort          4349
#define HID_SS_EB_Service               4350
#define HID_SS_EB_Port                  4351
#define HID_SS_PB_Tcp                   4352
#define HID_SS_PB_Udp                   4353
#define HID_SS_EB_Address               4354

// Firewall Logging settings property sheet
//
#define HID_FL_CB_LogDroppedInbound     4355
#define HID_FL_CB_LogOutboundConnections 4356
#define HID_FL_EB_Filename              4357
#define HID_FL_PB_Browse                4358
#define HID_FL_EB_Filesize              4359
#define HID_FL_PB_RestoreDefaults       4360

// ICMP Settings property sheet
//
#define HID_IC_LV_Settings              4361
#define HID_IC_ST_Description           4362

// ALG Setup confirmation dialog and Error Dialog
//
#define IDD_CONFIRMATION                5000
#define IDC_EDIT_COMPANY                5001
#define IDC_EDIT_PRODUCT                5002
#define IDC_EDIT_PORTS                  5003
#define IDC_EDIT_PORTS2                 5004

#define IDD_INSTALLERROR                5010
#define IDC_EDIT_LASTERROR              5011
#define IDC_EDIT_LASTERROR_CODE         5012

// Display names for default port mappings
//
#define SID_PMP_FTP                     1700
#define SID_PMP_TELNET                  1701
#define SID_PMP_SMTP                    1702
#define SID_PMP_POP3                    1703
#define SID_PMP_IMAP3                   1704
#define SID_PMP_IMAP4                   1705
#define SID_PMP_HTTP                    1706
#define SID_PMP_HTTPS                   1707
#define SID_PMP_RDP                     1708

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        571
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1639
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\sadlg.cpp ===
// Copyright (c) 1998, Microsoft Corporation, all rights reserved
//
// sadlg.c
// Remote Access Common Dialog APIs
// Shared Access Settings property sheet
//
// 10/20/1998 Abolade Gbadegesin
//

//#include "pch.h"
#pragma hdrstop

#include "sautil.h"
#include <wininet.h>
#include <winsock2.h>
#include "sainfo.h"
#include "ipnat.h"
#include "fwpages.h"

// extern(s)
// replaced global atom with "HNETCFG_SADLG"

// Loopback address (127.0.0.1) in network and host byte order
//
#define LOOPBACK_ADDR               0x0100007f
#define LOOPBACK_ADDR_HOST_ORDER    0x7f000001

// 'Shared Access Settings' common block
//
typedef struct
_SADLG
{
    HWND hwndOwner;
    HWND hwndDlg;
    HWND hwndSrv;

    HWND hwndServers;

    IHNetCfgMgr *pHNetCfgMgr;
    IHNetConnection *pHNetConn;
    LIST_ENTRY PortMappings;
    BOOL fModified;
    TCHAR *ComputerName;

    IUPnPService * pUPS;    // iff downlevel
}
SADLG;

// Info block for port mapping entries
//
typedef struct
_SAPM
{
    LIST_ENTRY Link;
    IHNetPortMappingProtocol *pProtocol;
    IHNetPortMappingBinding *pBinding;
    BOOL fProtocolModified;
    BOOL fBindingModified;
    BOOL fNewEntry;
    BOOL fDeleted;

    TCHAR *Title;
    BOOL Enabled;
    BOOL BuiltIn;

    UCHAR Protocol;
    USHORT ExternalPort;
    USHORT InternalPort;

    TCHAR *InternalName;

    IStaticPortMapping * pSPM;
}
SAPM;

#define HTONS(s) ((UCHAR)((s) >> 8) | ((UCHAR)(s) << 8))
#define HTONL(l) ((HTONS(l) << 16) | HTONS((l) >> 16))
#define NTOHS(s) HTONS(s)
#define NTOHL(l) HTONL(l)

#define SAPAGE_Servers 0
#define SAPAGE_Applications 1
#define SAPAGE_FirewallLogging 2
#define SAPAGE_ICMPSettings 3
#define SAPAGE_PageCount 4

inline SADLG * SasContext(HWND hwnd)
{
    return (SADLG*)GetProp(GetParent(hwnd), _T("HNETCFG_SADLG"));
}
#define SasErrorDlg(h,o,e,a) \
    ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_SharedAccessSettings,SID_FMT_ErrorMsg)

const TCHAR c_szEmpty[] = TEXT("");

static DWORD g_adwSrvHelp[] =
{
    CID_SS_LV_Services,         HID_SS_LV_Services,
    CID_SS_PB_Add,              HID_SS_PB_Add,
    CID_SS_PB_Edit,             HID_SS_PB_Edit,
    CID_SS_PB_Delete,           HID_SS_PB_Delete,
    0, 0
};

static DWORD g_adwSspHelp[] =
{
    CID_SS_EB_Service,          HID_SS_EB_Service,
    CID_SS_EB_ExternalPort,     -1,
    CID_SS_EB_InternalPort,     HID_SS_EB_Port,
    CID_SS_PB_Tcp,              HID_SS_PB_Tcp,
    CID_SS_PB_Udp,              HID_SS_PB_Udp,
    CID_SS_EB_Address,          HID_SS_EB_Address,
    0, 0
};

// FORWARD DECLARATIONS
//
HRESULT
DeleteRemotePortMappingEntry(
    SADLG *pDlg,
    SAPM * pPortMapping
    );

VOID
FreePortMappingEntry(
    SAPM *pPortMapping );

VOID
FreeSharingAndFirewallSettings(
    SADLG* pDlg );

HRESULT
LoadPortMappingEntry(
    IHNetPortMappingBinding *pBinding,
    SADLG* pDlg,
    SAPM **ppPortMapping );

HRESULT
LoadRemotePortMappingEntry (
    IDispatch * pDisp,
/*  SADLG* pDlg, */
    SAPM **ppPortMapping );

HRESULT
LoadSharingAndFirewallSettings(
    SADLG* pDlg );

VOID
SasApply(
    SADLG* pDlg );

LVXDRAWINFO*
SasLvxCallback(
    HWND hwndLv,
    DWORD dwItem );

INT_PTR CALLBACK
SasSrvDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam );

HRESULT
SavePortMappingEntry(
    SADLG *pDlg,
    SAPM *pPortMapping );

BOOL
SharedAccessPortMappingDlg(
    IN HWND hwndOwner,
    IN OUT SAPM** PortMapping );

INT_PTR CALLBACK
SspDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
SrvAddOrEditEntry(
    SADLG* pDlg,
    LONG iItem,
    SAPM* PortMapping );

BOOL
SrvCommand(
    IN SADLG* pDlg,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
SrvConflictDetected(
    SADLG* pDlg,
    SAPM* PortMapping );

BOOL
SrvInit(
    HWND hwndPage,
    SADLG* pDlg );

#define WM_PRIVATE_CANCEL 0x8000

VOID
SrvUpdateButtons(
    SADLG* pDlg,
    BOOL fAddDelete,
    LONG iSetCheckItem );



void DisplayError (HWND hwnd, int idError, int idTitle)
{
    TCHAR* pszError = PszFromId (g_hinstDll, idError);
    if (pszError) {
        TCHAR* pszTitle = PszFromId (g_hinstDll, idTitle);
        if (pszTitle) {
            MessageBox (hwnd,
                        pszError, pszTitle,
                        MB_OK | MB_ICONERROR | MB_APPLMODAL);
            Free (pszTitle);
        }
        Free (pszError);
    }
}

BOOL APIENTRY
HNetSharedAccessSettingsDlg(
    BOOL fSharedAccessMode,
    HWND hwndOwner )

    // Displays the shared access settings property-sheet.
    // On input, 'hwndOwner' indicates the window of the caller,
    // with respect to which we offset the displayed property-sheet.
    //
{
    HRESULT hr;
    IHNetCfgMgr *pHNetCfgMgr;
    BOOL fComInitialized = FALSE;
    BOOL fModified = FALSE;

    TRACE("HNetSharedAccessSettingsDlg");

    //
    // Make sure COM is initialized on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (SUCCEEDED(hr))
    {
        fComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }

    //
    // Create the HNetCfgMgr
    //

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
                CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_ALL,
                IID_IHNetCfgMgr,
                (VOID**) &pHNetCfgMgr
                );

        if (SUCCEEDED(hr))
        {
            fModified = HNetSharingAndFirewallSettingsDlg(
                            hwndOwner,
                            pHNetCfgMgr,
                            FALSE,
                            NULL
                            );

            pHNetCfgMgr->Release();
        }
    }

    if (TRUE == fComInitialized)
    {
        CoUninitialize();
    }

    return fModified;
}

int CALLBACK
UnHelpCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    // A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    //
    // Returns 0 always.
    //
{
    TRACE2( "UnHelpCallbackFunc(m=%d,l=%08x)",unMsg, lparam );

    if (unMsg == PSCB_PRECREATE)
    {
        extern BOOL g_fNoWinHelp;

        // Turn off context help button if WinHelp won't work.  See
        // common\uiutil\ui.c.
        //
        if (g_fNoWinHelp)
        {
            DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
            pDlg->style &= ~(DS_CONTEXTHELP);
        }
    }

    return 0;
}

HRESULT APIENTRY HNetGetSharingServicesPage (IUPnPService * pUPS, PROPSHEETPAGE * psp)
{
//  _asm int 3

    if (!pUPS)  return E_INVALIDARG;
    if (!psp)   return E_INVALIDARG;

    // psp->dwSize muust be filled out by caller!
    if (psp->dwSize == 0)
        return E_INVALIDARG;

    SADLG* pDlg = (SADLG*)Malloc(sizeof(*pDlg));
    if (!pDlg)
        return E_OUTOFMEMORY;

    ZeroMemory(pDlg, sizeof(*pDlg));
    pDlg->hwndOwner = (HWND)psp->lParam;    // double-secret place to hang the owning window
    pDlg->pUPS = pUPS;
    pUPS->AddRef();
    InitializeListHead(&pDlg->PortMappings);

    HRESULT hr = LoadSharingAndFirewallSettings(pDlg);
    if (SUCCEEDED(hr)) {
        // use the size we're given
        DWORD dwSize = psp->dwSize;
        ZeroMemory (psp, dwSize);           // double-secret place gets wiped here
        psp->dwSize      = dwSize;

        psp->hInstance   = g_hinstDll;
        psp->pszTemplate = MAKEINTRESOURCE(PID_SS_SharedAccessServices);
        psp->pfnDlgProc  = SasSrvDlgProc;
        psp->lParam      = (LPARAM)pDlg;
    } else {
        FreeSharingAndFirewallSettings(pDlg);
        Free(pDlg);
    }
    return hr;
}

HRESULT APIENTRY HNetFreeSharingServicesPage (PROPSHEETPAGE * psp)
{   // this must be called if and only if the psp has not been displayed

    // NOTE: these tests are not definitive!!!
    if (IsBadReadPtr ((void*)psp->lParam, sizeof(SADLG)))
        return E_UNEXPECTED;

    SADLG * pDlg = (SADLG *)psp->lParam;
    if (pDlg->pUPS == NULL)
        return E_UNEXPECTED;

    // TODO:  should I walk the heap?

    FreeSharingAndFirewallSettings(pDlg);
    Free(pDlg);

    return S_OK;
}

BOOL
APIENTRY
HNetSharingAndFirewallSettingsDlg(
    IN HWND             hwndOwner,
    IN IHNetCfgMgr      *pHNetCfgMgr,
    IN BOOL             fShowFwOnlySettings,
    IN OPTIONAL IHNetConnection  *pHNetConn )

    // Displays the shared access settings property-sheet.
    // On input, 'hwndOwner' indicates the window of the caller,
    // with respect to which we offset the displayed property-sheet.
    //
{
//  _asm int 3

    DWORD dwErr;
    BOOL fModified = FALSE;
    SADLG* pDlg;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[SAPAGE_PageCount];
    TCHAR* pszCaption;
    CFirewallLoggingDialog FirewallLoggingDialog = {0};
    CICMPSettingsDialog ICMPSettingsDialog = {0};
    HRESULT hr;
    HRESULT hFirewallLoggingResult = E_FAIL;
    HRESULT hICMPSettingsResult = E_FAIL;

    TRACE("HNetSharingAndFirewallSettingsDlg");

    // Allocate and initialize the property-sheet's context block,
    // and read into it the current shared access settings.
    //
    pDlg = (SADLG*)Malloc(sizeof(*pDlg));
    if (!pDlg) { return FALSE; }

    ZeroMemory(pDlg, sizeof(*pDlg));
    pDlg->hwndOwner = hwndOwner;
    pDlg->pHNetCfgMgr = pHNetCfgMgr;
    pDlg->pHNetConn = pHNetConn;
    InitializeListHead(&pDlg->PortMappings);

    hr = LoadSharingAndFirewallSettings(pDlg);
    if (SUCCEEDED(hr))
    {
        // Construct the property sheet.
        // We use a single DlgProc for both our pages, and distinguish the pages
        // by setting the applications page's 'lParam' to contain the shared
        // context-block.
        // (See the 'WM_INITDIALOG' handling in 'SasDlgProc'.)
        //
        int nPages = 0;
        ZeroMemory(psp, sizeof(psp));
        ZeroMemory(&psh, sizeof(psh));

        if(NULL != pHNetConn && fShowFwOnlySettings)
        {
            hFirewallLoggingResult = CFirewallLoggingDialog_Init(&FirewallLoggingDialog, pHNetCfgMgr);
            hICMPSettingsResult = CICMPSettingsDialog_Init(&ICMPSettingsDialog, pHNetConn);
        }

        if(NULL != pHNetConn)
        {
            psp[nPages].dwSize = sizeof(PROPSHEETPAGE);
            psp[nPages].hInstance = g_hinstDll;
            psp[nPages].pszTemplate =
                MAKEINTRESOURCE(PID_SS_SharedAccessServices);
            psp[nPages].pfnDlgProc = SasSrvDlgProc;
            psp[nPages].lParam = (LPARAM)pDlg;
            nPages++;
        }

        if(SUCCEEDED(hFirewallLoggingResult))
        {
            psp[nPages].dwSize = sizeof(PROPSHEETPAGE);
            psp[nPages].hInstance = g_hinstDll;
            psp[nPages].pszTemplate =
                MAKEINTRESOURCE(PID_FW_FirewallLogging);
            psp[nPages].pfnDlgProc = CFirewallLoggingDialog_StaticDlgProc;
            psp[nPages].lParam = (LPARAM)&FirewallLoggingDialog;
            nPages++;
        }

        if(SUCCEEDED(hICMPSettingsResult))
        {
            psp[nPages].dwSize = sizeof(PROPSHEETPAGE);
            psp[nPages].hInstance = g_hinstDll;
            psp[nPages].pszTemplate =
                MAKEINTRESOURCE(PID_FW_ICMP);
            psp[nPages].pfnDlgProc = CICMPSettingsDialog_StaticDlgProc;
            psp[nPages].lParam = (LPARAM)&ICMPSettingsDialog;
            nPages++;
        }

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK;
        psh.hInstance = g_hinstDll;
        psh.nPages = nPages;
        psh.hwndParent = hwndOwner;
        psh.ppsp = (LPCPROPSHEETPAGE)psp;
        pszCaption = pHNetConn
            ? PszFromId(g_hinstDll, SID_SharedAccessSettings)
            : PszFromId(g_hinstDll, SID_NetworkApplicationSettings);
        psh.pszCaption = (pszCaption ? pszCaption : c_szEmpty);
        psh.pfnCallback = UnHelpCallbackFunc;

        if (PropertySheet(&psh) == -1)
        {
            dwErr = GetLastError();
            TRACE1("SharedAccessSettingsDlg: PropertySheet=%d", dwErr);
            SasErrorDlg(hwndOwner, SID_OP_LoadDlg, dwErr, NULL);
        }
        fModified = pDlg->fModified;
        Free0(pszCaption); // REVIEW is this right

        if(SUCCEEDED(hICMPSettingsResult))
        {
            CICMPSettingsDialog_FinalRelease(&ICMPSettingsDialog);
        }

        if(SUCCEEDED(hFirewallLoggingResult))
        {
            CFirewallLoggingDialog_FinalRelease(&FirewallLoggingDialog);
        }

        FreeSharingAndFirewallSettings(pDlg);
    }
    Free(pDlg);
    return fModified;
}

VOID
FreePortMappingEntry(
    SAPM *pPortMapping )

{
    ASSERT(NULL != pPortMapping);

    if (NULL != pPortMapping->pProtocol)
    {
        pPortMapping->pProtocol->Release();
    }

    if (NULL != pPortMapping->pBinding)
    {
        pPortMapping->pBinding->Release();
    }

    if (pPortMapping->pSPM)
        pPortMapping->pSPM->Release();

    Free0(pPortMapping->Title);
    Free0(pPortMapping->InternalName);

    Free(pPortMapping);
}

VOID
FreeSharingAndFirewallSettings(
    SADLG* pDlg )

    // Frees all sharing and firewall settings
    //

{
    PLIST_ENTRY pLink;
    SAPM *pPortMapping;

    ASSERT(pDlg);

    //
    // Free port-mapping entries
    //

    while (!IsListEmpty(&pDlg->PortMappings))
    {
        pLink = RemoveHeadList(&pDlg->PortMappings);
        pPortMapping = CONTAINING_RECORD(pLink, SAPM, Link);
        ASSERT(pPortMapping);

        FreePortMappingEntry(pPortMapping);
    }

    //
    // Free computer name
    //

    Free0(pDlg->ComputerName);

    if (pDlg->pUPS) {
        pDlg->pUPS->Release();
        pDlg->pUPS = NULL;
    }
}

#define NAT_API_ENTER
#define NAT_API_LEAVE
#include "natutils.h"
#include "sprtmapc.h"
HRESULT GetCollectionFromService (IUPnPService * pUPS, IStaticPortMappingCollection ** ppSPMC)
{
    CComObject<CStaticPortMappingCollection> * pC = NULL;
    HRESULT hr = CComObject<CStaticPortMappingCollection>::CreateInstance (&pC);
    if (pC) {
        pC->AddRef();
        // init
        hr = pC->Initialize (pUPS);
        if (SUCCEEDED(hr))
            hr = pC->QueryInterface (__uuidof(IStaticPortMappingCollection), (void**)ppSPMC);
        pC->Release();
    }
    return hr;
}

HRESULT GetStaticPortMappingCollection (
    SADLG* pDlg,
    IStaticPortMappingCollection ** ppSPMC)
{
    _ASSERT (pDlg);
    _ASSERT (pDlg->pUPS);
    _ASSERT (ppSPMC);

    *ppSPMC = NULL;

    return GetCollectionFromService (pDlg->pUPS, ppSPMC);
}

HRESULT
LoadRemotePortMappingEntry (IDispatch * pDisp, /* SADLG* pDlg, */ SAPM **ppPortMapping )
{   // NOTE: may need pDlg to get computer name if loopback

    *ppPortMapping = NULL;

    SAPM *pMapping  = (SAPM*)Malloc(sizeof(*pMapping));
    if (!pMapping)
        return E_OUTOFMEMORY;

    ZeroMemory(pMapping, sizeof(*pMapping));
    InitializeListHead(&pMapping->Link);

    HRESULT hr = pDisp->QueryInterface (__uuidof(IStaticPortMapping),
                                        (void**)&pMapping->pSPM);
    if (SUCCEEDED(hr)) {
        // get title (description)
        CComBSTR cbDescription;
        hr = pMapping->pSPM->get_Description (&cbDescription);
        if (SUCCEEDED(hr)) {
            // immediately figure out if it's "built-in"
            #define BUILTIN_KEY L" [MICROSOFT]"
            OLECHAR * tmp = wcsstr (cbDescription.m_str, BUILTIN_KEY);
            if (tmp && (tmp[wcslen(BUILTIN_KEY)] == 0)) {
                // if the key exists and is at the end, then it's a built-in mapping
                pMapping->BuiltIn = TRUE;
                *tmp = 0;
            }

            pMapping->Title = StrDupTFromW (cbDescription);
            if (NULL == pMapping->Title)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr)) {
            // get protocol
            CComBSTR cbProtocol;
            hr = pMapping->pSPM->get_Protocol (&cbProtocol);
            if (SUCCEEDED(hr)) {
                if (!_wcsicmp (L"tcp", cbProtocol))
                    pMapping->Protocol = NAT_PROTOCOL_TCP;
                else
                if (!_wcsicmp (L"udp", cbProtocol))
                    pMapping->Protocol = NAT_PROTOCOL_UDP;
                else {
                    _ASSERT (0 && "bad protocol!?");
                    hr = E_UNEXPECTED;
                }

                if (SUCCEEDED(hr)) {
                    // get external port
                    long lExternalPort = 0;
                    hr = pMapping->pSPM->get_ExternalPort (&lExternalPort);
                    if (SUCCEEDED(hr)) {
                        _ASSERT (lExternalPort > 0);
                        _ASSERT (lExternalPort < 65536);
                        pMapping->ExternalPort = ntohs ((USHORT)lExternalPort);

                        // get internal port
                        long lInternalPort = 0;
                        hr = pMapping->pSPM->get_InternalPort (&lInternalPort);
                        if (SUCCEEDED(hr)) {
                            _ASSERT (lInternalPort > 0);
                            _ASSERT (lInternalPort < 65536);
                            pMapping->InternalPort = ntohs ((USHORT)lInternalPort);

                            // get Enabled
                            VARIANT_BOOL vb;
                            hr = pMapping->pSPM->get_Enabled (&vb);
                            if (SUCCEEDED(hr)) {
                                pMapping->Enabled = vb == VARIANT_TRUE;
                            }
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr)) {
        // lastly, get private IP or host name (hard one)
        // TODO:  check for loopback, etc., like in LoadPortMappingEntry code below
        CComBSTR cbInternalClient;
        hr = pMapping->pSPM->get_InternalClient (&cbInternalClient);
        if (SUCCEEDED(hr)) {
            if (!(cbInternalClient == L"0.0.0.0")) {
                pMapping->InternalName = StrDupTFromW (cbInternalClient);
                if (!pMapping->InternalName)
                    hr = E_OUTOFMEMORY;
            }
        }
    }

    if (SUCCEEDED(hr))
        *ppPortMapping = pMapping;
    else
        FreePortMappingEntry (pMapping);

    return hr;
}

HRESULT
LoadPortMappingEntry(
    IHNetPortMappingBinding *pBinding,
    SADLG* pDlg,
    SAPM **ppPortMapping )

{
    HRESULT hr = S_OK;
    IHNetPortMappingProtocol *pProtocol = NULL;
    SAPM *pMapping;
    BOOLEAN fTemp;
    OLECHAR *pwsz;

    ASSERT(NULL != pBinding);
    ASSERT(NULL != ppPortMapping);

    pMapping = (SAPM*) Malloc(sizeof(*pMapping));

    if (NULL != pMapping)
    {
        ZeroMemory(pMapping, sizeof(*pMapping));
        InitializeListHead(&pMapping->Link);

        hr = pBinding->GetProtocol (&pProtocol);

        if (SUCCEEDED(hr))
        {
            hr = pProtocol->GetName (&pwsz);

            if (SUCCEEDED(hr))
            {
                pMapping->Title = StrDupTFromW(pwsz);
                if (NULL == pMapping->Title)
                {
                    hr = E_OUTOFMEMORY;
                }
                CoTaskMemFree(pwsz);
            }

            if (SUCCEEDED(hr))
            {
                hr = pProtocol->GetBuiltIn (&fTemp);
            }

            if (SUCCEEDED(hr))
            {
                pMapping->BuiltIn = !!fTemp;

                hr = pProtocol->GetIPProtocol (&pMapping->Protocol);
            }

            if (SUCCEEDED(hr))
            {
                hr = pProtocol->GetPort (&pMapping->ExternalPort);
            }

            pMapping->pProtocol = pProtocol;
            pMapping->pProtocol->AddRef();
            pProtocol->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = pBinding->GetTargetPort (&pMapping->InternalPort);
    }

    if (SUCCEEDED(hr))
    {
        hr = pBinding->GetEnabled (&fTemp);
    }

    if (SUCCEEDED(hr))
    {
        pMapping->Enabled = !!fTemp;

        hr = pBinding->GetCurrentMethod (&fTemp);
    }

    if (SUCCEEDED(hr))
    {
        if (fTemp)
        {
            hr = pBinding->GetTargetComputerName (&pwsz);

            if (SUCCEEDED(hr))
            {
                pMapping->InternalName = StrDupTFromW(pwsz);
                if (NULL == pMapping->InternalName)
                {
                    hr = E_OUTOFMEMORY;
                }
                CoTaskMemFree(pwsz);
            }
        }
        else
        {
            ULONG ulAddress;

            hr = pBinding->GetTargetComputerAddress (&ulAddress);

            if (SUCCEEDED(hr))
            {
                if (LOOPBACK_ADDR == ulAddress)
                {
                    //
                    // The mapping is directed at this machine, so
                    // replace the loopback address with our
                    // machine name
                    //

                    pMapping->InternalName = _StrDup(pDlg->ComputerName);
                    if (NULL == pMapping->InternalName)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else if (0 != ulAddress)
                {
                    pMapping->InternalName =
                        (LPTSTR) Malloc(16 * sizeof(TCHAR));

                    if (NULL != pMapping->InternalName)
                    {
                        IpHostAddrToPsz(
                            NTOHL(ulAddress),
                            pMapping->InternalName
                            );
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        pMapping->pBinding = pBinding;
        pMapping->pBinding->AddRef();
        *ppPortMapping = pMapping;
    }
    else if (NULL != pMapping)
    {
        FreePortMappingEntry(pMapping);
    }

    return hr;
}

class CWaitDialog
{
public:
    struct SWaitDialog
    {
        HWND hwndOwner;
    private:
        CComAutoCriticalSection m_acs;
        HWND m_hwndDlg;
    public:
        SWaitDialog (HWND hwnd)
        {
            hwndOwner = hwnd;
            m_hwndDlg = NULL;
        }
        void SetWindow (HWND hwnd)
        {
            m_acs.Lock();
            if (m_hwndDlg == NULL)
                m_hwndDlg = hwnd;
            m_acs.Unlock();
        }
        HWND GetWindow () { return m_hwndDlg; }
    };
private:
    SWaitDialog * m_pwd;
public:
    CWaitDialog (HWND hwndOwner)
    {
        m_pwd = new SWaitDialog (hwndOwner);
        if (m_pwd) {
            // create thread
            DWORD ThreadId = NULL;
            HANDLE hThread = CreateThread (NULL, 0,
                                           CWaitDialog::ThreadProc,
                                           (void*)m_pwd,
                                           0, &ThreadId);
            if (hThread == NULL) {
                delete m_pwd;
                m_pwd = NULL;
            } else {
                CloseHandle (hThread);
            }
        }
    }
   ~CWaitDialog ()
    {
        if (m_pwd) {
            HWND hwnd = m_pwd->GetWindow();
            m_pwd->SetWindow ((HWND)INVALID_HANDLE_VALUE);
            if (hwnd != NULL)
                EndDialog (hwnd, 1);
        }
    }
    static DWORD WINAPI ThreadProc (VOID *pVoid)
    {
        SWaitDialog * pWD = (SWaitDialog *)pVoid;
        EnableWindow (pWD->hwndOwner, FALSE);
        DialogBoxParam (g_hinstDll,
                        MAKEINTRESOURCE(PID_SS_PleaseWait),
                        pWD->hwndOwner,
                        CWaitDialog::DlgProc,
                        (LPARAM)pWD);
        EnableWindow (pWD->hwndOwner, TRUE);
        delete pWD;
        return 1;
    }
    static INT_PTR CALLBACK DlgProc (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
    {
        switch (uMsg) {
        case WM_INITDIALOG:
        {
            // hang onto my data
            SWaitDialog * pWD = (SWaitDialog *)lparam;
            SetWindowLongPtr (hwnd, DWLP_USER, (LONG_PTR)pWD);

            // center window on owner
            CenterWindow (hwnd, pWD->hwndOwner);

            // fill out dlg's hwnd
            pWD->SetWindow (hwnd);
            if (pWD->GetWindow() == INVALID_HANDLE_VALUE)   // already destructed!
                PostMessage (hwnd, 0x8000, 0, 0L);
            return TRUE;
        }
        case WM_PAINT:
        {
            SWaitDialog * pWD = (SWaitDialog *)GetWindowLongPtr (hwnd, DWLP_USER);
            if (pWD->GetWindow() == INVALID_HANDLE_VALUE)   // already destructed!
                PostMessage (hwnd, 0x8000, 0, 0L);
            break;
        }
        case 0x8000:
            EndDialog (hwnd, 1);
            return TRUE;
        }
        return FALSE;
    }
};

HRESULT
LoadSharingAndFirewallSettings(
    SADLG* pDlg )

{
    CWaitDialog wd(pDlg->hwndOwner);    // may be NULL

    HRESULT hr = S_OK;
    IHNetProtocolSettings *pProtSettings;
    ULONG ulCount;
    DWORD dwError;

    ASSERT(pDlg);

    //
    // Load the name of the computer
    //

#ifndef DOWNLEVEL_CLIENT    // downlevel client doesn't have this call
    ulCount = 0;
    if (!GetComputerNameEx(ComputerNameDnsHostname, NULL, &ulCount))
    {
        dwError = GetLastError();

        if (ERROR_MORE_DATA == dwError)
        {
            pDlg->ComputerName = (TCHAR*) Malloc(ulCount * sizeof(TCHAR));
            if (NULL != pDlg->ComputerName)
            {
                if (!GetComputerNameEx(
                        ComputerNameDnsHostname,
                        pDlg->ComputerName,
                        &ulCount
                        ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    else
    {
        //
        // Since we didn't pass in a buffer, this should never happen.
        //

        ASSERT(FALSE);
        hr = E_UNEXPECTED;
    }
    if (FAILED(hr))
        return hr;
#else
    // downlevel client version
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize       = MAX_COMPUTERNAME_LENGTH+1;
    if (!GetComputerName (szComputerName, &dwSize))
        hr = HRESULT_FROM_WIN32(GetLastError());
    else {
        pDlg->ComputerName = _StrDup (szComputerName);
        if (!pDlg->ComputerName)
            hr = E_OUTOFMEMORY;
    }
#endif

    // do downlevel and remote case here
    if (pDlg->pUPS) {
        CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
        hr = GetCollectionFromService (pDlg->pUPS, &spSPMC);
        if (spSPMC) {
            CComPtr<IEnumVARIANT> spEV = NULL;

            CComPtr<IUnknown> spunk = NULL;
            hr = spSPMC->get__NewEnum (&spunk);
            if (spunk)
                hr = spunk->QueryInterface (
                            __uuidof(IEnumVARIANT),
                            (void**)&spEV);
            if (spEV) {
                CComVariant cv;
                while (S_OK == spEV->Next (1, &cv, NULL)) {
                    if (V_VT (&cv) == VT_DISPATCH) {
                        SAPM *pSAPortMap = NULL;
                        hr = LoadRemotePortMappingEntry (V_DISPATCH (&cv), /* pDlg, */ &pSAPortMap);
                        if (SUCCEEDED(hr))
                            InsertTailList(&pDlg->PortMappings, &pSAPortMap->Link);
                    }
                    cv.Clear();
                }
            }
        }
    }

    // do stuff below iff not remote
    if (NULL != pDlg->pHNetConn)
    {
        IEnumHNetPortMappingBindings *pEnumBindings = NULL;

        //
        // Load port-mapping settings
        //

        hr = pDlg->pHNetConn->EnumPortMappings (FALSE, &pEnumBindings);

        if (SUCCEEDED(hr))
        {
            IHNetPortMappingBinding *pBinding;

            do
            {
                hr = pEnumBindings->Next (1, &pBinding, &ulCount);

                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    SAPM *pSAPortMap;

                    hr = LoadPortMappingEntry(pBinding, pDlg, &pSAPortMap);

                    if (SUCCEEDED(hr))
                    {
                        InsertTailList(&pDlg->PortMappings, &pSAPortMap->Link);
                    }
                    else
                    {
                        //
                        // Even though an error occured for this entry we'll
                        // keep on going -- this allows the UI to show up.
                        //
                        
                        hr = S_OK;
                    }

                    pBinding->Release();
                }

            } while (SUCCEEDED(hr) && 1 == ulCount);

            pEnumBindings->Release();
        }
    }
    return hr;
}

extern BOOL IsICSHost (); // in upnpnat.cpp
VOID
SasApply(
    SADLG* pDlg )

    // Called to save all changes made in the property sheet.
    //
{
    if (!pDlg->fModified)
    {
        return;
    }

    if (pDlg->hwndServers)
    {
        SAPM* pPortMapping;
#if DBG
        LONG i = -1;
        while ((i = ListView_GetNextItem(pDlg->hwndServers, i, LVNI_ALL))
                >= 0)
        {
            pPortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);
            ASSERT(pPortMapping->Enabled == ListView_GetCheck(pDlg->hwndServers, i));
        }
#endif

        //
        // Commit modified port-mapping entries. Since entries marked
        // for deletion were placed at the front of the port-mapping
        // list there's no chance of having a new or modified entry
        // conflicting with a deleted entry.
        //

        HRESULT hr = S_OK;

        PLIST_ENTRY Link;
        for (Link = pDlg->PortMappings.Flink;
             Link != &pDlg->PortMappings; Link = Link->Flink)
        {
            pPortMapping = CONTAINING_RECORD(Link, SAPM, Link);

            if (pPortMapping->fDeleted)
            {
                Link = Link->Blink;
                RemoveEntryList(&pPortMapping->Link);

                if(NULL != pPortMapping->pProtocol)
                {
                    pPortMapping->pProtocol->Delete();
                }
                else if (pPortMapping->pSPM)
                {
                    HRESULT hr = DeleteRemotePortMappingEntry (pDlg, pPortMapping);
                    if (FAILED(hr)) {
                        // TODO: should I pop up some UI?
                    }
                }

                FreePortMappingEntry(pPortMapping);
            }
            else if (pPortMapping->fProtocolModified
                     || pPortMapping->fBindingModified
                     || pPortMapping->fNewEntry)
            {
                HRESULT hr2 = SavePortMappingEntry(pDlg, pPortMapping);
                if (SUCCEEDED(hr2))
                {
                    pPortMapping->fProtocolModified = FALSE;
                    pPortMapping->fBindingModified = FALSE;
                    pPortMapping->fNewEntry = FALSE;
                } else {
                    if (SUCCEEDED(hr))
                        hr = hr2;   // grab first error
                }
            }
        }
        if (FAILED(hr)) {
            if (pDlg->pUPS && !IsICSHost ())
                DisplayError (pDlg->hwndDlg,
                              SID_OP_TheirGatewayError,
                              SID_PopupTitle);
            else
                DisplayError (pDlg->hwndDlg,
                              SID_OP_GenericPortMappingError,
                              SID_PopupTitle);
        }
    }
}

INT_PTR CALLBACK
SasSrvDlgProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wparam,
    LPARAM lparam )

    // Called to handle messages for the 'Services' pages.
    //
{
    // Give the extended list-control a chance to look at all messages first.
    //
    if (ListView_OwnerHandler(hwnd, unMsg, wparam, lparam, SasLvxCallback))
    {
        return TRUE;
    }
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            SADLG* pDlg = (SADLG*)((PROPSHEETPAGE*)lparam)->lParam;
            return SrvInit(hwnd, pDlg);
        }
        case WM_PRIVATE_CANCEL:
        {
            SADLG* pDlg = SasContext(hwnd);
            PostMessage (pDlg->hwndDlg, PSM_PRESSBUTTON, PSBTN_CANCEL, 0L);
            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            SADLG* pDlg = SasContext(hwnd);
            ContextHelp(g_adwSrvHelp, hwnd, unMsg, wparam, lparam);
            break;
        }

        case WM_COMMAND:
        {
            SADLG* pDlg = SasContext(hwnd);
                return SrvCommand(
                    pDlg, HIWORD(wparam), LOWORD(wparam), (HWND)lparam);
        }

        case WM_NOTIFY:
        {
            SADLG* pDlg = SasContext(hwnd);
            switch (((NMHDR*)lparam)->code)
            {
                case PSN_APPLY:
                {
                    SasApply(pDlg);
                    return TRUE;
                }

                case NM_DBLCLK:
                {
                    SendMessage(
                        GetDlgItem(hwnd, CID_SS_PB_Edit), BM_CLICK, 0, 0);
                    return TRUE;
                }

                case LVXN_SETCHECK:
                {
                    pDlg->fModified = TRUE;
                    SrvUpdateButtons(
                        pDlg, FALSE, ((NM_LISTVIEW*)lparam)->iItem);
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    if ((((NM_LISTVIEW*)lparam)->uNewState & LVIS_SELECTED)
                        != (((NM_LISTVIEW*)lparam)->uOldState & LVIS_SELECTED))
                    {
                        SrvUpdateButtons(
                            pDlg, FALSE, ((NM_LISTVIEW*)lparam)->iItem);
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
SasInit(
    HWND hwndPage,
    SADLG* pDlg )

    // Called to initialize the settings property sheet.
    // Sets the window-property in which the shared context-block is stored,
    // and records the dialog's window-handle.
    //
{
    HWND hwndDlg = GetParent(hwndPage);
    if (!SetProp(hwndDlg, _T("HNETCFG_SADLG"), pDlg))
    {
        return FALSE;
    }
    pDlg->hwndDlg = hwndDlg;
    return TRUE;
}

LVXDRAWINFO*
SasLvxCallback(
    HWND hwndLv,
    DWORD dwItem )

    // Callback for extended list-controls on the 'Applications' and 'Services'
    // pages.
    //
{
    static LVXDRAWINFO info = { 1, 0, LVXDI_DxFill, { LVXDIA_Static } };
    return &info;
}

HRESULT DeleteRemotePortMappingEntry (SADLG *pDlg, SAPM * pPortMapping)
{
    _ASSERT (pPortMapping);
    _ASSERT (!pPortMapping->pProtocol);
    _ASSERT (!pPortMapping->pBinding);
    _ASSERT (pPortMapping->pSPM);

    // don't use value in pPortMapping struct:  they could have been edited.
    long lExternalPort = 0;
    HRESULT hr = pPortMapping->pSPM->get_ExternalPort (&lExternalPort);
    if (SUCCEEDED(hr)) {
        CComBSTR cbProtocol;
        hr = pPortMapping->pSPM->get_Protocol (&cbProtocol);
        if (SUCCEEDED(hr)) {

            // get IStaticPortMappings interface (collection has Remove method)
            CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
            hr = GetStaticPortMappingCollection (pDlg, &spSPMC);
            if (spSPMC)
                hr = spSPMC->Remove (lExternalPort, cbProtocol);
        }
    }
    return hr;
}

HRESULT
SaveRemotePortMappingEntry(
    SADLG *pDlg,
    SAPM *pPortMapping )
{
    _ASSERT (pPortMapping);
    _ASSERT (!pPortMapping->pProtocol);
    _ASSERT (!pPortMapping->pBinding);
    _ASSERT (pDlg->pUPS);  // either remote or downlevel

    USES_CONVERSION;

    HRESULT hr = S_OK;

    // common params
    long lExternalPort = htons (pPortMapping->ExternalPort);
    long lInternalPort = htons (pPortMapping->InternalPort);
    CComBSTR cbClientIPorDNS = T2OLE(pPortMapping->InternalName);
    CComBSTR cbDescription   = T2OLE(pPortMapping->Title);
    CComBSTR cbProtocol;
    if (pPortMapping->Protocol == NAT_PROTOCOL_TCP)
        cbProtocol =  L"TCP";
    else
        cbProtocol =  L"UDP";

    if (NULL == pPortMapping->pSPM) {
        // brand-new entry:
        // delete dup if any
        // add new entry

        CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
        hr = GetStaticPortMappingCollection (pDlg, &spSPMC);
        if (spSPMC) {
            spSPMC->Remove (lExternalPort, cbProtocol); // just in case
            hr = spSPMC->Add (lExternalPort,
                              cbProtocol,
                              lInternalPort,
                              cbClientIPorDNS,
                              pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE,
                              cbDescription,
                              &pPortMapping->pSPM);
        }
        return hr;
    }

    // edited case:  check what changed.

    // if ports or protocol changed,...
    long lOldExternalPort = 0;
    pPortMapping->pSPM->get_ExternalPort (&lOldExternalPort);
    CComBSTR cbOldProtocol;
    pPortMapping->pSPM->get_Protocol (&cbOldProtocol);
    if ((lOldExternalPort != lExternalPort) ||
        (!(cbOldProtocol == cbProtocol))) {
        // ... delete old entry and create new entry

        CComPtr<IStaticPortMappingCollection> spSPMC = NULL;
        hr = GetStaticPortMappingCollection (pDlg, &spSPMC);
        if (spSPMC)
            hr = spSPMC->Remove (lOldExternalPort, cbOldProtocol);

        if (SUCCEEDED(hr)) {
            pPortMapping->pSPM->Release();
            pPortMapping->pSPM = NULL;

            hr = spSPMC->Add (lExternalPort,
                              cbProtocol,
                              lInternalPort,
                              cbClientIPorDNS,
                              pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE,
                              cbDescription,
                              &pPortMapping->pSPM);
        }
        return hr;
    }
    // else, just edit in place.
    // Note that the client address must be filled out before trying to enable

    // did the client IP address change?
    CComBSTR cbOldClientIP;
    pPortMapping->pSPM->get_InternalClient (&cbOldClientIP);
    if (!(cbClientIPorDNS == cbOldClientIP)) {
        hr = pPortMapping->pSPM->EditInternalClient (cbClientIPorDNS);
        if (FAILED(hr))
            return hr;
    }

    // did the internal port change?
    long lOldInternalPort = 0;
    pPortMapping->pSPM->get_InternalPort (&lOldInternalPort);
    if (lOldInternalPort != lInternalPort) {
        hr = pPortMapping->pSPM->EditInternalPort (lInternalPort);
        if (FAILED(hr))
            return hr;
    }

    // did the enabled flag change?
    VARIANT_BOOL vbEnabled = FALSE;
    pPortMapping->pSPM->get_Enabled (&vbEnabled);
    if (vbEnabled != (pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE)) {
        hr = pPortMapping->pSPM->Enable (pPortMapping->Enabled ? VARIANT_TRUE : VARIANT_FALSE);
    }
    return hr;
}

HRESULT
SavePortMappingEntry(
    SADLG *pDlg,
    SAPM *pPortMapping )

{
    if (pDlg->pUPS)  // remote case
        return SaveRemotePortMappingEntry (pDlg, pPortMapping);

    HRESULT hr = S_OK;
    OLECHAR *wszTitle;

    ASSERT(NULL != pDlg);
    ASSERT(NULL != pPortMapping);

    wszTitle = StrDupWFromT(pPortMapping->Title);
    if (NULL == wszTitle)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (pPortMapping->fNewEntry)
    {
        IHNetProtocolSettings *pSettings;

        ASSERT(NULL == pPortMapping->pProtocol);
        ASSERT(NULL == pPortMapping->pBinding);

        hr = pDlg->pHNetCfgMgr->QueryInterface (IID_IHNetProtocolSettings,
                                                (void**)&pSettings);

        if (SUCCEEDED(hr))
        {
            hr = pSettings->CreatePortMappingProtocol(
                    wszTitle,
                    pPortMapping->Protocol,
                    pPortMapping->ExternalPort,
                    &pPortMapping->pProtocol
                    );

            pSettings->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = pDlg->pHNetConn->GetBindingForPortMappingProtocol(
                    pPortMapping->pProtocol,
                    &pPortMapping->pBinding
                    );

            if (SUCCEEDED(hr))
            {
                //
                // At this point, the protocol is set. However, we
                // still need to save the binding information
                //

                pPortMapping->fProtocolModified = FALSE;
                pPortMapping->fBindingModified = TRUE;
            }
        }
    }

    if (SUCCEEDED(hr) && pPortMapping->fProtocolModified)
    {
        hr = pPortMapping->pProtocol->SetName (wszTitle);

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pProtocol->SetIPProtocol (
                                                    pPortMapping->Protocol);
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pProtocol->SetPort (pPortMapping->ExternalPort);
        }
    }

    if (SUCCEEDED(hr)
        && pPortMapping->fBindingModified
        && NULL != pPortMapping->InternalName)
    {
        ULONG ulAddress = INADDR_NONE;

        if (lstrlen(pPortMapping->InternalName) >= 7)
        {
            //
            // 1.2.3.4 -- minimum of 7 characters
            //

            ulAddress = IpPszToHostAddr(pPortMapping->InternalName);
        }

        if (INADDR_NONE == ulAddress)
        {
            //
            // Check to see if the target name is either
            // 1) this computer's name, or
            // 2) "localhost"
            //
            // If so, use the loopback address instead of the name.
            //

            if (0 == _tcsicmp(pPortMapping->InternalName, pDlg->ComputerName)
                || 0 == _tcsicmp(pPortMapping->InternalName, _T("localhost")))
            {
                ulAddress = LOOPBACK_ADDR_HOST_ORDER;
            }
        }

        //
        // We can't just check for INADDR_NONE here, since that
        // is 0xFFFFFFFF, which is 255.255.255.255. To catch this
        // we need to compare the name against that explicit string
        // address.
        //

        if (INADDR_NONE == ulAddress
            && 0 != _tcsicmp(pPortMapping->InternalName, _T("255.255.255.255")))
        {
            OLECHAR *wsz;

            wsz = StrDupWFromT(pPortMapping->InternalName);
            if (NULL != wsz)
            {
                hr = pPortMapping->pBinding->SetTargetComputerName (wsz);

                Free(wsz);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = pPortMapping->pBinding->SetTargetComputerAddress
                        (HTONL(ulAddress));
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pBinding->SetEnabled (!!pPortMapping->Enabled);
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pBinding->SetTargetPort (pPortMapping->InternalPort);
        }
    }

    Free0(wszTitle);

    return hr;
}

VOID
SrvAddOrEditEntry(
    SADLG* pDlg,
    LONG iItem,
    SAPM* PortMapping )

    // Called to display the 'Add' or 'Edit' dialog for a service.
    //
{
    LV_ITEM lvi;

    // Display the dialog, and return if the user cancels.
    // Otherwise, remove the old item (if any) and insert the added or edited
    // item.
    //

    if (!SharedAccessPortMappingDlg(pDlg->hwndDlg, &PortMapping))
    {
        return;
    }

    if (iItem != -1)
    {
        ListView_DeleteItem(pDlg->hwndServers, iItem);
    }

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.lParam = (LPARAM)PortMapping;
    lvi.pszText = PortMapping->Title;
    lvi.cchTextMax = lstrlen(PortMapping->Title) + 1;
    lvi.iItem = 0;

    iItem = ListView_InsertItem(pDlg->hwndServers, &lvi);
    if (iItem == -1)
    {
        RemoveEntryList(&PortMapping->Link);
        if (NULL != PortMapping->pProtocol)
        {
            PortMapping->pProtocol->Delete();
        }
        else if (NULL != PortMapping->pSPM)
        {
            DeleteRemotePortMappingEntry (pDlg, PortMapping);
        }
        FreePortMappingEntry(PortMapping);
        return;
    }

    // Update the item's 'enabled' state. Setting the check on the item
    // triggers an update of the button state as well as conflict detection.
    // (See 'SrvUpdateButtons' and the LVXN_SETCHECK handling in 'SasDlgProc').
    //
    ListView_SetCheck(pDlg->hwndServers, iItem, PortMapping->Enabled);
    ListView_SetItemState(
        pDlg->hwndServers, iItem, LVIS_SELECTED, LVIS_SELECTED);
    pDlg->fModified = TRUE;
}

BOOL
SrvCommand(
    IN SADLG* pDlg,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called to process a 'WM_COMMAND' message from one of the page's buttons.
    //
{
    switch (wId)
    {
        case CID_SS_PB_Add:
        {
            SrvAddOrEditEntry(pDlg, -1, NULL);
            return TRUE;
        }

        case CID_SS_PB_Edit:
        {
            LONG i = ListView_GetNextItem(pDlg->hwndServers, -1, LVNI_SELECTED);
            SAPM* PortMapping;
            if (i == -1)
            {
                MsgDlg(pDlg->hwndDlg, SID_NoModifySelection, NULL);
                SetFocus(pDlg->hwndServers);
                return FALSE;
            }
            PortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);
            if (PortMapping)
            {
                SrvAddOrEditEntry(pDlg, i, PortMapping);
            }
            SetFocus(pDlg->hwndServers);
            return TRUE;
        }

        case CID_SS_PB_Delete:
        {
            LONG i = ListView_GetNextItem(pDlg->hwndServers, -1, LVNI_SELECTED);
            SAPM* PortMapping;
            if (i == -1)
            {
                MsgDlg(pDlg->hwndDlg, SID_NoDeleteSelection, NULL);
                SetFocus(pDlg->hwndServers);
                return FALSE;
            }

            // Delete each selected item. Items with marked 'built-in'
            // cannot be deleted, and are ignored.
            //
            do {
                PortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);

                if(NULL == PortMapping)
                {
                    break;
                }

                if (PortMapping->BuiltIn)
                {
                    ++i;
                }
                else
                {
                    ListView_DeleteItem(pDlg->hwndServers, i);
                    --i;

                    //
                    // If this is a new entry we can immediately remove
                    // it from the list and free it; otherwise, we move
                    // it to the front of the list and mark it for
                    // deletion.
                    //

                    RemoveEntryList(&PortMapping->Link);
                    if (PortMapping->fNewEntry)
                    {
                        _ASSERT(NULL == PortMapping->pProtocol);
                        _ASSERT(NULL == PortMapping->pSPM);

                        FreePortMappingEntry(PortMapping);
                    }
                    else
                    {
                        InsertHeadList(&pDlg->PortMappings, &PortMapping->Link);
                        PortMapping->fDeleted = TRUE;
                    }
                }
                i = ListView_GetNextItem(pDlg->hwndServers, i, LVNI_SELECTED);
            } while (i != -1);

            // Update the dialog and synchronize the button-states with the
            // current selection, if any.
            //
            pDlg->fModified = TRUE;
            SetFocus(pDlg->hwndServers);
            SrvUpdateButtons(pDlg, TRUE, -1);
            return TRUE;
        }
    }
    return TRUE;
}

BOOL
SrvConflictDetected(
    SADLG* pDlg,
    SAPM* PortMapping )

    // Called to determine whether the given item conflicts with any other
    // item and, if so, to display a message.
    //
{
    SAPM* Duplicate;
    PLIST_ENTRY Link;
    for (Link = pDlg->PortMappings.Flink;
         Link != &pDlg->PortMappings; Link = Link->Flink)
    {
        Duplicate = CONTAINING_RECORD(Link, SAPM, Link);
        if (PortMapping != Duplicate &&
            !Duplicate->fDeleted &&
            PortMapping->Protocol == Duplicate->Protocol &&
            PortMapping->ExternalPort == Duplicate->ExternalPort)
        {
            MsgDlg(pDlg->hwndDlg, SID_DuplicatePortNumber, NULL);
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
SrvInit(
    HWND hwndPage,
    SADLG* pDlg )

    // Called to initialize the services page. Fills the list-control with
    // configured services.
    //
{
    BOOL fModified;
    LONG i;
    LV_ITEM lvi;
    PLIST_ENTRY Link;
    SAPM* PortMapping;

    // Initialize the containing property-sheet, then store this page's
    // data in the shared control-block at 'pDlg'.
    //
    if (!SasInit(hwndPage, pDlg))
    {
        return FALSE;
    }

    // Store this page's data in the shared control-block at 'pDlg'.
    //
    pDlg->hwndSrv = hwndPage;
    pDlg->hwndServers = GetDlgItem(hwndPage, CID_SS_LV_Services);

    // Initialize the list-control with checkbox-handling,
    // insert a single column, and fill the list-control with the configured
    // items.
    //
    ListView_InstallChecks(pDlg->hwndServers, g_hinstDll);
    ListView_InsertSingleAutoWidthColumn(pDlg->hwndServers);

    fModified = pDlg->fModified;
    for (Link = pDlg->PortMappings.Flink;
         Link != &pDlg->PortMappings; Link = Link->Flink)
    {
        PortMapping = CONTAINING_RECORD(Link, SAPM, Link);

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.lParam = (LPARAM)PortMapping;
        lvi.pszText = PortMapping->Title;
        lvi.cchTextMax = lstrlen(PortMapping->Title) + 1;

        i = ListView_InsertItem(pDlg->hwndServers, &lvi);

        if (i != -1)
        {
            ListView_SetCheck(pDlg->hwndServers, i, PortMapping->Enabled);
        }
    }
    pDlg->fModified = fModified;

    // Finally, update the appearance of the buttons for the current selection.
    //
    ListView_SetItemState(pDlg->hwndServers, 0, LVIS_SELECTED, LVIS_SELECTED);
    SrvUpdateButtons(pDlg, TRUE, -1);

    // if we got no portmappings, check to see if the button allowing
    // other network users to control the gateway is unchecked (on the host)
    if (IsListEmpty (pDlg->PortMappings.Flink) &&
        pDlg->pUPS && IsICSHost ()) {

        // display error
        DisplayError (pDlg->hwndDlg, SID_OP_OurGatewayError, SID_PopupTitle);
        // cancel
        PostMessage (hwndPage, WM_PRIVATE_CANCEL, 0, 0L);
    }

    return TRUE;
}

VOID
SrvUpdateButtons(
    SADLG* pDlg,
    BOOL fAddDelete,
    LONG iSetCheckItem )

    // Called to set an initial selection if necessary, update the appearance
    // of the 'Edit' and 'Delete' buttons, and perform conflict-detection
    // if an entry's checkbox was set.
    //
{
    LONG i;
    SAPM* PortMapping;

    // If an entry was added or removed, ensure that there is a selection.
    // If there are no entries at all, disable the 'Edit' button.
    //
    if (fAddDelete)
    {
        if (ListView_GetItemCount(pDlg->hwndServers))
        {
            ListView_SetItemState(
                pDlg->hwndServers, 0, LVIS_SELECTED, LVIS_SELECTED);
            EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Edit), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Edit), FALSE);
        }
    }

    // Disable the 'Delete' button, and enable it only if at least one of the
    // selected items is not a built-in item.
    //
    EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Delete), FALSE);
    i = ListView_GetNextItem(pDlg->hwndServers, -1, LVNI_SELECTED);
    while (i != -1)
    {
        PortMapping = (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, i);
        if (    (NULL != PortMapping)
            &&  (!PortMapping->BuiltIn))
        {
            EnableWindow(GetDlgItem(pDlg->hwndSrv, CID_SS_PB_Delete), TRUE);
            break;
        }

        i = ListView_GetNextItem(pDlg->hwndServers, i, LVNI_SELECTED);
    }

    // If the check-state of an item was changed and the item is now checked,
    // perform conflict-detection. If a conflict is detected, clear the item's
    // check state.
    //
    if (iSetCheckItem != -1)
    {
        PortMapping =
            (SAPM*)ListView_GetParamPtr(pDlg->hwndServers, iSetCheckItem);

        if(NULL == PortMapping)
        {
            return;
        }

        if (ListView_GetCheck(pDlg->hwndServers, iSetCheckItem))
        {
            if (SrvConflictDetected(pDlg, PortMapping))
            {
                ListView_SetCheck(pDlg->hwndServers, iSetCheckItem, FALSE);
                SrvAddOrEditEntry(pDlg, iSetCheckItem, PortMapping);
            }
            else
            {
                PortMapping->Enabled = TRUE;
                PortMapping->fBindingModified = TRUE;

                // If the item is marked 'built-in' and it is being enabled
                // for the first time, pop up the edit-dialog so the user can
                // specify an internal IP address or name for the server.
                //
                if (/* Bug 630840:  a similar scenario can happen when you
                       create the "same" port mapping on two NICs:
                       the second one's per NIC info is missing, and
                       when enabling it, the code below needs to run.
                      PortMapping->BuiltIn &&
                    */
                    (!PortMapping->InternalName
                     || !lstrlen(PortMapping->InternalName)))
                {

                    //
                    // We fill in the local computer name as the default
                    // target. It's OK if this allocation fails; the UI
                    // will show an empty field, so the user will be
                    // required to enter a target.
                    //

                    PortMapping->InternalName = _StrDup(pDlg->ComputerName);
                    SrvAddOrEditEntry(pDlg, iSetCheckItem, PortMapping);

                    if (!PortMapping->InternalName
                        || !lstrlen(PortMapping->InternalName))
                    {
                        ListView_SetCheck(
                            pDlg->hwndServers, iSetCheckItem, FALSE);

                        PortMapping->Enabled = FALSE;
                        PortMapping->fBindingModified = FALSE;
                    }
                }
            }
        }
        else
        {
            PortMapping->Enabled = FALSE;
            PortMapping->fBindingModified = TRUE;
        }
    }
}


BOOL
SharedAccessPortMappingDlg(
    IN HWND hwndOwner,
    IN OUT SAPM** PortMapping )

    // Called to display the dialog for adding or editing a service-entry.
    // 'Server' points to NULL if adding, or the target entry if editing.
    //
{
    LRESULT nResult =
        DialogBoxParam(g_hinstDll, MAKEINTRESOURCE(DID_SS_Service),
            hwndOwner, SspDlgProc, (LPARAM)PortMapping);
    return nResult == -1 ? FALSE : (BOOL)nResult;
}

INT_PTR CALLBACK
SspDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // Called to handle messages for the add/edit service dialog.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            SADLG* pDlg;
            SAPM* PortMapping;

            // Retrieve the context-block for the settings dialog from which
            // this dialog was launched.
            //
            if (!(pDlg = SasContext(hwnd)))
            {
                EndDialog(hwnd, FALSE);
                return TRUE;
            }

            Edit_LimitText(GetDlgItem(hwnd, CID_SS_EB_ExternalPort), 5);
            Edit_LimitText(GetDlgItem(hwnd, CID_SS_EB_InternalPort), 5);
            Edit_LimitText(GetDlgItem(hwnd, CID_SS_EB_Service), INTERNET_MAX_HOST_NAME_LENGTH-1);
            Edit_LimitText(GetDlgItem(hwnd, CID_SS_EB_Address), INTERNET_MAX_HOST_NAME_LENGTH-1);

            // Create new service if adding a service, or retrieve the service
            // to be edited.
            //
            if (!(PortMapping = *(SAPM**)lparam))
            {
                PortMapping = (SAPM*)Malloc(sizeof(*PortMapping));
                if (!PortMapping)
                {
                    EndDialog(hwnd, FALSE);
                    return TRUE;
                }
                *(SAPM**)lparam = PortMapping;
                ZeroMemory(PortMapping, sizeof(*PortMapping));
                PortMapping->Enabled = TRUE;
                PortMapping->fNewEntry = TRUE;
                InitializeListHead(&PortMapping->Link);
                CheckDlgButton(hwnd, CID_SS_PB_Tcp, TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, CID_SS_EB_Service), FALSE);
                SetDlgItemText(hwnd, CID_SS_EB_Service, PortMapping->Title);
                SetDlgItemInt(hwnd, CID_SS_EB_ExternalPort, ntohs(PortMapping->ExternalPort), FALSE);
                SetDlgItemInt(hwnd, CID_SS_EB_InternalPort, ntohs(PortMapping->InternalPort), FALSE);
                CheckDlgButton(
                    hwnd, CID_SS_PB_Tcp, PortMapping->Protocol == NAT_PROTOCOL_TCP);
                CheckDlgButton(
                    hwnd, CID_SS_PB_Udp, PortMapping->Protocol != NAT_PROTOCOL_TCP);
                SetDlgItemText(hwnd, CID_SS_EB_Address, PortMapping->InternalName);

                // If the entry to be modified is marked 'built-in', disable
                // all input fields except the server-name, which the user must
                // now enter.
                //

                if (PortMapping->BuiltIn)
                {
                    EnableWindow(GetDlgItem(hwnd, CID_SS_EB_ExternalPort), FALSE);
                    EnableWindow(GetDlgItem(hwnd, CID_SS_EB_InternalPort), FALSE);
                    EnableWindow(GetDlgItem(hwnd, CID_SS_PB_Tcp), FALSE);
                    EnableWindow(GetDlgItem(hwnd, CID_SS_PB_Udp), FALSE);
                }
            }

            SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR)PortMapping);
            CenterWindow(hwnd, GetParent(hwnd));
            AddContextHelpButton(hwnd);
            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwSspHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            if (HIWORD(wparam) != BN_CLICKED) { return FALSE; }

            // If the user is dismissing the dialog, clean up and return.
            //
            SAPM* PortMapping;
            SADLG* pDlg;
            if (IDCANCEL == LOWORD(wparam))
            {
                PortMapping = (SAPM*)GetWindowLongPtr(hwnd, DWLP_USER);
                if (IsListEmpty(&PortMapping->Link))
                {
                    FreePortMappingEntry(PortMapping);
                }
                EndDialog (hwnd, FALSE);
                return TRUE;
            }
            else if (LOWORD(wparam) != IDOK)
            {
                return FALSE;
            }
            else if (!(pDlg = SasContext(hwnd)))
            {
                return FALSE;
            }

            // Retrieve the service to be added or modified.
            //
            PortMapping = (SAPM*)GetWindowLongPtr(hwnd, DWLP_USER);

            // Retrieve the values specified by the user,
            // and attempt to save them in the new or modified entry.
            //
            UCHAR Protocol = IsDlgButtonChecked(hwnd, CID_SS_PB_Tcp)
                ? NAT_PROTOCOL_TCP : NAT_PROTOCOL_UDP;

            BOOL Success;
            ULONG ExternalPort = GetDlgItemInt(hwnd, CID_SS_EB_ExternalPort, &Success, FALSE);
            if (!Success || ExternalPort < 1 || ExternalPort > 65535)
            {
                MsgDlg(hwnd, SID_TypePortNumber, NULL);
                SetFocus(GetDlgItem(hwnd, CID_SS_EB_ExternalPort));
                return FALSE;
            }
            ExternalPort = htons((USHORT)ExternalPort);

            //
            // Check to see if this is a duplicate. To do this we need
            // to save the old port and protocol values, put the new
            // values into the protocol entry, perform the check, and
            // then restore the old values.
            //

            USHORT OldExternalPort    = PortMapping->ExternalPort;
            PortMapping->ExternalPort = (USHORT)ExternalPort;
            UCHAR OldProtocol     = PortMapping->Protocol;
            PortMapping->Protocol = Protocol;

            if (SrvConflictDetected(pDlg, PortMapping))
            {
                PortMapping->ExternalPort = OldExternalPort;
                PortMapping->Protocol = OldProtocol;
                SetFocus(GetDlgItem(hwnd, CID_SS_EB_ExternalPort));
                return FALSE;
            }
            PortMapping->ExternalPort = OldExternalPort;
            PortMapping->Protocol = OldProtocol;

            // per BillI, there's no need to test internal ports for conflicts
            ULONG InternalPort = GetDlgItemInt(hwnd, CID_SS_EB_InternalPort, &Success, FALSE);
            if (InternalPort == 0)
                InternalPort = ExternalPort;
            else {
                if (InternalPort < 1 || InternalPort > 65535)
                {
                    MsgDlg(hwnd, SID_TypePortNumber, NULL);
                    SetFocus(GetDlgItem(hwnd, CID_SS_EB_InternalPort));
                    return FALSE;
                }
                InternalPort = htons((USHORT)InternalPort);
            }

            TCHAR* InternalName = GetText(GetDlgItem(hwnd, CID_SS_EB_Address));
            if (!InternalName || !lstrlen(InternalName))
            {
                MsgDlg(hwnd, SID_SS_TypeAddress, NULL);
                SetFocus(GetDlgItem(hwnd, CID_SS_EB_Address));
                return FALSE;
            }

            if (IsListEmpty(&PortMapping->Link))
            {
                PortMapping->Title = GetText(GetDlgItem(hwnd, CID_SS_EB_Service));
                if (!PortMapping->Title || !lstrlen(PortMapping->Title))
                {
                    MsgDlg(hwnd, SID_TypeEntryName, NULL);
                    SetFocus(GetDlgItem(hwnd, CID_SS_EB_Service));
                    Free0(InternalName);
                    return FALSE;
                }
            }

            if (PortMapping->Protocol     != Protocol ||
                PortMapping->ExternalPort != (USHORT)ExternalPort ||
                PortMapping->InternalPort != (USHORT)InternalPort)
            {
                PortMapping->fProtocolModified = TRUE;
            }

            PortMapping->fBindingModified = TRUE;
            PortMapping->Protocol         = Protocol;
            PortMapping->ExternalPort     = (USHORT)ExternalPort;
            PortMapping->InternalPort     = (USHORT)InternalPort;
            if (PortMapping->InternalName)
            {
                Free(PortMapping->InternalName);
            }
            PortMapping->InternalName = InternalName;
            if (IsListEmpty(&PortMapping->Link))
            {
                InsertTailList(&pDlg->PortMappings, &PortMapping->Link);
            }
            EndDialog (hwnd, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Home Networking Configuration Manager"
#define VER_INTERNALNAME_STR            "HNETCFG.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\dprtmapc.h ===
// DPrtMapC.h : Declaration of the CDynamicPortMappingCollection

#ifndef __DYNAMICPORTMAPPINGCOLLECTION_H_
#define __DYNAMICPORTMAPPINGCOLLECTION_H_

#include "dportmap.h"

/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMappingCollection
class ATL_NO_VTABLE CDynamicPortMappingCollection : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CDynamicPortMappingCollection, &CLSID_DynamicPortMappingCollection>,
	public IDispatchImpl<IDynamicPortMappingCollection, &IID_IDynamicPortMappingCollection, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IUPnPService> m_spUPS;

public:
	CDynamicPortMappingCollection()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_DYNAMICPORTMAPPINGCOLLECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDynamicPortMappingCollection)
	COM_INTERFACE_ENTRY(IDynamicPortMappingCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDynamicPortMappingCollection
public:
   STDMETHOD(Add)(/*[in]*/ BSTR bstrRemoteHost, /*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[in]*/ long lInternalPort, /*[in]*/ BSTR bstrInternalClient, /*[in]*/ VARIANT_BOOL bEnabled, /*[in]*/ BSTR bstrDescription, /*[in]*/ long lLeaseDuration, /*[retval][out]*/ IDynamicPortMapping **ppDPM);
   STDMETHOD(Remove)(/*[in]*/ BSTR bstrRemoteHost, /*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol);
   STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown* *pVal);
   STDMETHOD(get_Item)(/*[in]*/ BSTR bstrRemoteHost, /*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[out, retval]*/ IDynamicPortMapping ** ppDPM);

// CDynamicPortMappingCollection
public:
   HRESULT Initialize (IUPnPService * pUPS);
};

// quickie enumerator
class CEnumDynamicPortMappingCollection : public IEnumVARIANT
{
private:
   CComPtr<IUPnPService> m_spUPS;
   long m_index, m_refs;

   CEnumDynamicPortMappingCollection ()
   {
      m_refs = 0;
      m_index = 0;
   }
   HRESULT Init (IUPnPService * pUPS, long lIndex)
   {
      m_index = lIndex;
      m_spUPS = pUPS;
      return S_OK;
   }

public:
   static IEnumVARIANT * CreateInstance (IUPnPService * pUPS, long lIndex = 0)
   {
      CEnumDynamicPortMappingCollection * pCEV = new CEnumDynamicPortMappingCollection ();
      if (!pCEV)
         return NULL;
      HRESULT hr = pCEV->Init (pUPS, lIndex);
      if (FAILED(hr)) {
         delete pCEV;
         return NULL;
      }

      IEnumVARIANT * pIEV = NULL;
      pCEV->AddRef();
      pCEV->QueryInterface (IID_IEnumVARIANT, (void**)&pIEV);
      pCEV->Release();
      return pIEV;
   }

// IUnknown
   virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void ** ppvObject)
   {
      NAT_API_ENTER

      if (ppvObject)
         *ppvObject = NULL;
      else
         return E_POINTER;

      HRESULT hr = S_OK;
      if ((riid == IID_IUnknown) ||
         (riid == IID_IEnumVARIANT) ){
         AddRef();
         *ppvObject = (void *)this;
      } else
         hr = E_NOINTERFACE;
      return hr;

      NAT_API_LEAVE
   }
   virtual ULONG STDMETHODCALLTYPE AddRef ()
   {
      return InterlockedIncrement ((PLONG)&m_refs);
   }
   virtual ULONG STDMETHODCALLTYPE Release ()
   {
      ULONG l = InterlockedDecrement ((PLONG)&m_refs);
      if (l == 0)
         delete this;
      return l;
   }

// IEnumVARIANT
   virtual HRESULT STDMETHODCALLTYPE Next (/*[in]*/ ULONG celt, /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar, /*[out]*/ ULONG * pCeltFetched)
   {
      NAT_API_ENTER

      // clear stuff being passed in (just in case)
      if (pCeltFetched)   *pCeltFetched = 0;
      for (ULONG i=0; i<celt; i++)
         VariantInit (&rgVar[i]);

      HRESULT hr = S_OK;

      // get the next celt elements
      for (i=0; i<celt; i++) {

         // ask service for more....
         CComPtr<IDynamicPortMapping> spDPM = NULL;
         hr = CDynamicPortMapping::CreateInstance (m_spUPS, (long)m_index+i, &spDPM);
         if (!spDPM)
            break;

         // can't fail
         V_VT (&rgVar[i]) = VT_DISPATCH;
         spDPM->QueryInterface (__uuidof(IDispatch), 
                               (void**)&V_DISPATCH (&rgVar[i]));
      }
      if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
         hr = S_OK;  // no more; will return S_FALSE below

      if (FAILED(hr)) {
         // on error clear variant array....
         for (ULONG j=0; j<i; j++)
            VariantClear (&rgVar[j]);
         return hr;
      }

      // now update index
      m_index += i;

      // fill out how many we're returning
      if (pCeltFetched)
         *pCeltFetched = i;
      return i < celt ? S_FALSE : S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Skip (/*[in]*/ ULONG celt)
   {
      NAT_API_ENTER

      if (celt + m_index > GetTotal())
         return S_FALSE;
      m_index += celt;
      return S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Reset ()
   {
      NAT_API_ENTER

      m_index = 0;
      return S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Clone (/*[out]*/ IEnumVARIANT ** ppEnum)
   {
      NAT_API_ENTER

      if (!(*ppEnum = CreateInstance (m_spUPS, m_index)))
         return E_OUTOFMEMORY;
      return S_OK;

      NAT_API_LEAVE
   }

private:
   ULONG GetTotal()
   {
      ULONG ul = 0;
      GetNumberOfEntries (m_spUPS, &ul);
      return ul;
   }
};

#endif //__DYNAMICPORTMAPPINGCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\sautil.h ===
#ifndef _SAUTIL_H
#define _SAUTIL_H


#include "resource.h"

#define TRACE(a)
#define TRACE1(a,b)
#define TRACE2(a,b,c)
#define TRACE3(a,b,c,d)

extern HINSTANCE g_hinstDll;  // in saui.cpp

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
#endif

VOID ContextHelp(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam);

VOID AddContextHelpButton (IN HWND hwnd);

/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define MSGARGS struct tagMSGARGS
MSGARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwMsg' string, or
    ** NULLs if none.
    */
    TCHAR* apszArgs[ 9 ];

    /* Currently, as for MessageBox, where defaults if 0 are MB_OK and
    ** MB_ICONINFORMATION.
    */
    DWORD dwFlags;

    /* If non-NULL, specifies a string overriding the loading of the 'dwMsg'
    ** parameter string.
    */
    TCHAR* pszString;

    /* If 'fStringOutput' is true, the MsgDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle );

VOID UnclipWindow (IN HWND hwnd);
VOID CenterWindow (IN HWND hwnd, IN HWND hwndRef);
LRESULT CALLBACK CenterDlgOnOwnerCallWndProc (int code, WPARAM wparam, LPARAM lparam);
TCHAR* PszFromId (IN HINSTANCE hInstance, IN DWORD dwStringId);
TCHAR* GetText (IN HWND hwnd);
BOOL GetErrorText (DWORD dwError, TCHAR** ppszError);

#define ERRORARGS struct tagERRORARGS
ERRORARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwOperation' string,
    ** or NULLs if none.
    */
    TCHAR* apszOpArgs[ 9 ];

    /* Insertion strings for auxillary arguments %4 to %6 in the 'dwFormat'
    ** string, or NULLs if none.  (The standard arguments are %1=the
    ** 'dwOperation' string, %2=the decimal error number, and %3=the
    ** 'dwError'string.)
    */
    TCHAR* apszAuxFmtArgs[ 3 ];

    /* If 'fStringOutput' is true, the ErrorDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat );
int MsgDlgUtil(IN HWND hwndOwner, IN DWORD dwMsg, IN OUT MSGARGS* pargs, IN HINSTANCE hInstance, IN DWORD dwTitle);
#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)



// LVX stuff (cut-n-paste'd from ...\net\rras\ras\ui\common\uiutil\lvx.c, etc.

/* Text indents within a column in pixels.  If you mess with the dx, you're
** asking for misalignment problems with the header labels.  BTW, the first
** column doesn't line up with it's header if there are no icons.  Regular
** list view has this problem, too.  If you try to fix this you'll wind up
** duplicating the AUTOSIZE_USEHEADER option of ListView_SetColumnWidth.
** Should be able to change the dy without causing problems.
*/
#define LVX_dxColText 4
#define LVX_dyColText 1

/* Guaranteed vertical space between icons.  Should be able to mess with this
** without causing problems.
*/
#define LVX_dyIconSpacing 1

#define SI_Unchecked 1
#define SI_Checked   2
#define SI_DisabledUnchecked 3
#define SI_DisabledChecked 4

#define LVXN_SETCHECK (LVN_LAST + 1)
#define LVXN_DBLCLK (LVN_LAST + 2)

/* The extended list view control calls the owner back to find out the layout
** and desired characteristics of the enhanced list view.
*/
#define LVX_MaxCols      10
#define LVX_MaxColTchars 512

/* 'dwFlags' option bits.
*/
#define LVXDI_DxFill     1  // Auto-fill wasted space on right (recommended)
#define LVXDI_Blend50Sel 2  // Dither small icon if selected (not recommended)
#define LVXDI_Blend50Dis 4  // Dither small icon if disabled (recommended)

/* 'adwFlags' option bits.
*/
#define LVXDIA_3dFace 1  // Column is not editable but other columns are
#define LVXDIA_Static 2  // Emulates static text control w/icon if disabled

/* Returned by owner at draw item time.
*/
#define LVXDRAWINFO struct tagLVXDRAWINFO
LVXDRAWINFO
{
    /* The number of columns.  The list view extensions require that your
    ** columns are numbered sequentially from left to right where 0 is the
    ** item column and 1 is the first sub-item column.  Required always.
    */
    INT cCols;

    /* Pixels to indent this item, or -1 to indent a "small icon" width.  Set
    ** 0 to disable.
    */
    INT dxIndent;

    /* LVXDI_* options applying to all columns.
    */
    DWORD dwFlags;

    /* LVXDIA_* options applying to individual columns.
    */
    DWORD adwFlags[ LVX_MaxCols ];
};
typedef LVXDRAWINFO* (*PLVXCALLBACK)( IN HWND, IN DWORD dwItem );


BOOL ListView_IsCheckDisabled (IN HWND hwndLv, IN INT  iItem);
VOID ListView_SetCheck (IN HWND hwndLv, IN INT iItem, IN BOOL fCheck);
VOID* ListView_GetParamPtr(IN HWND hwndLv, IN INT iItem);
BOOL ListView_GetCheck(IN HWND hwndLv, IN INT iItem);
LRESULT APIENTRY LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );
BOOL ListView_InstallChecks(IN HWND hwndLv, IN HINSTANCE hinst);
VOID ListView_InsertSingleAutoWidthColumn (HWND hwndLv);
TCHAR* Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL);
BOOL LvxDrawItem(IN DRAWITEMSTRUCT* pdis, IN PLVXCALLBACK pLvxCallback);
BOOL LvxMeasureItem(IN HWND hwnd, IN OUT MEASUREITEMSTRUCT* pmis);
BOOL ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback );

TCHAR* _StrDup(LPCTSTR psz);
TCHAR* StrDupTFromW (LPCWSTR psz);
WCHAR* StrDupWFromT (LPCTSTR psz);
void  IpHostAddrToPsz(IN DWORD dwAddr, OUT LPTSTR pszBuffer);
DWORD IpPszToHostAddr(IN LPCTSTR cp);

VOID* Free0 (VOID* p);

HRESULT ActivateLuna(HANDLE* phActivationContext, ULONG_PTR* pulCookie);
HRESULT DeactivateLuna(HANDLE hActivationContext, ULONG_PTR ulCookie);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\dportmap.h ===
// DPortMap.h : Declaration of the CDynamicPortMapping

#ifndef __DYNAMICPORTMAPPING_H_
#define __DYNAMICPORTMAPPING_H_

#include <upnp.h>


/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMapping
class ATL_NO_VTABLE CDynamicPortMapping : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CDynamicPortMapping, &CLSID_DynamicPortMapping>,
	public IDispatchImpl<IDynamicPortMapping, &IID_IDynamicPortMapping, &LIBID_NATUPNPLib>
{
private:
   enum eEnumData {
      eNoData = -1,
      eSomeData,
      eAllData
   };
   eEnumData  m_eComplete;

   CComBSTR m_cbRemoteHost;   // "" == wildcard (for static)
   long     m_lExternalPort;
   CComBSTR m_cbProtocol;     // "TCP" or "UDP"
   long     m_lInternalPort;  // internal == external for static
   CComBSTR m_cbInternalClient;
   VARIANT_BOOL m_vbEnabled;
   CComBSTR m_cbDescription;
   // Lease is live

   CComPtr<IUPnPService> m_spUPS;

public:
	CDynamicPortMapping()
	{
      m_eComplete = eNoData;

      m_lInternalPort =
      m_lExternalPort = 0;
      m_vbEnabled     = VARIANT_FALSE;
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_DYNAMICPORTMAPPING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDynamicPortMapping)
	COM_INTERFACE_ENTRY(IDynamicPortMapping)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDynamicPortMapping
public:
   STDMETHOD(get_ExternalIPAddress)(/*[out, retval]*/ BSTR *pVal); // live one!
   STDMETHOD(get_RemoteHost)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_ExternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_Protocol)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_InternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_InternalClient)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_Enabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
   STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_LeaseDuration)(/*[out, retval]*/ long *pVal);  // live one!
   STDMETHOD(RenewLease)(/*[in]*/ long lLeaseDurationDesired, /*[out, retval]*/ long * pLeaseDurationReturned);
   STDMETHOD(EditInternalClient)(/*[in]*/ BSTR bstrInternalClient);
   STDMETHOD(Enable)(/*[in]*/ VARIANT_BOOL vb);
   STDMETHOD(EditDescription)(/*[in]*/ BSTR bstrDescription);
   STDMETHOD(EditInternalPort)(/*[in]*/ long lInternalPort);

// CDynamicPortMapping
public:
   static HRESULT CreateInstance (IUPnPService * pUPS, long lIndex, IDynamicPortMapping ** ppDPM);
   HRESULT Initialize (IUPnPService * pUPS, long lIndex);

   static HRESULT CreateInstance (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, IDynamicPortMapping ** ppDPM);
   HRESULT Initialize (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol);

private:
   HRESULT GetAllData (long * pLease = NULL);
};

#endif //__DYNAMICPORTMAPPING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\dll\sautil.cpp ===
//#include "pch.h"
#pragma hdrstop

#include "sautil.h"

BOOL g_fNoWinHelp = FALSE;

VOID ContextHelp(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam)
    // Calls WinHelp to popup context sensitive help.  'PadwMap' is an array
    // of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
    // WM_HELP or WM_CONTEXTMENU indicating the message received requesting
    // help.  'Wparam' and 'lparam' are the parameters of the message received
    // requesting help.
    //
{
    HWND hwnd;
    UINT unType;
    TCHAR* pszHelpFile;

    ASSERT( unMsg==WM_HELP || unMsg==WM_CONTEXTMENU );

    // Don't try to do help if it won't work.  See common\uiutil\ui.c.
    //
    {
        extern BOOL g_fNoWinHelp;
        if (g_fNoWinHelp)
        {
            return;
        }
    }

    if (unMsg == WM_HELP)
    {
        LPHELPINFO p = (LPHELPINFO )lparam;;

        TRACE3( "ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x)",
            p->iContextType, p->iCtrlId,p->hItemHandle );

        if (p->iContextType != HELPINFO_WINDOW)
        {
            return;
        }

        hwnd = (HWND)p->hItemHandle;
        ASSERT( hwnd );
        unType = HELP_WM_HELP;
    }
    else
    {
        // Standard Win95 method that produces a one-item "What's This?" menu
        // that user must click to get help.
        //
        TRACE1( "ContextHelp(WM_CONTEXTMENU,h=$%08x)", wparam );

        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    };

//    if (fRouter)
//    {
//        pszHelpFile = g_pszRouterHelpFile;
//    }
//    else
//    {
//      pszHelpFile = g_pszHelpFile;
//    }
    pszHelpFile = PszFromId (g_hinstDll, SID_HelpFile );
    if (pszHelpFile)
    {
        TRACE1( "WinHelp(%s)", pszHelpFile );
        WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR ) padwMap );

        Free0 (pszHelpFile);
    }
}

VOID
AddContextHelpButton(
    IN HWND hwnd )

    /* Turns on title bar context help button in 'hwnd'.
    **
    ** Dlgedit.exe doesn't currently support adding this style at dialog
    ** resource edit time.  When that's fixed set DS_CONTEXTHELP in the dialog
    ** definition and remove this routine.
    */
{
    LONG lStyle;

    if (g_fNoWinHelp)
        return;

    lStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if (lStyle)
        SetWindowLong( hwnd, GWL_EXSTYLE, lStyle | WS_EX_CONTEXTHELP );
}

/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/

/*----------------------------------------------------------------------------
** Message popup
**----------------------------------------------------------------------------
*/

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle )

    /* Pops up a message dialog centered on 'hwndOwner'.  'DwMsg' is the
    ** string resource ID of the message text.  'Pargs' is a extended
    ** formatting arguments or NULL if none.  'hInstance' is the
    ** application/module handle where string resources are located.
    ** 'DwTitle' is the string ID of the dialog title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("MsgDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the message string.
    */
    pszResult = pszNotFound;

    if (pargs && pargs->pszString)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pargs->pszString, 0, 0, (LPTSTR )&pszResult, 1,
            (va_list* )pargs->apszArgs );
    }
    else
    {
        pszUnformatted = PszFromId( hInstance, dwMsg );

        if (pszUnformatted)
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING +
                    FORMAT_MESSAGE_ALLOCATE_BUFFER +
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszUnformatted, 0, 0, (LPTSTR )&pszResult, 1,
                (va_list* )((pargs) ? pargs->apszArgs : NULL) );

            Free( pszUnformatted );
        }
    }

    if (!pargs || !pargs->fStringOutput)
    {
        TCHAR* pszTitle;
        DWORD  dwFlags;
        HHOOK  hhook;

        if (pargs && pargs->dwFlags != 0)
            dwFlags = pargs->dwFlags;
        else
            dwFlags = MB_ICONINFORMATION + MB_OK + MB_SETFOREGROUND;

        pszTitle = PszFromId( hInstance, dwTitle );

        if (hwndOwner)
        {
            /* Install hook that will get the message box centered on the
            ** owner window.
            */
            hhook = SetWindowsHookEx( WH_CALLWNDPROC,
                CenterDlgOnOwnerCallWndProc,
                hInstance, GetCurrentThreadId() );
        }
        else
            hhook = NULL;

        if (pszResult)
        {
            nResult = MessageBox( hwndOwner, pszResult, pszTitle, dwFlags );
        }

        if (hhook)
            UnhookWindowsHookEx( hhook );

        Free0( pszTitle );
        if (pszResult != pszNotFound)
            LocalFree( pszResult );
    }
    else
    {
        /* Caller wants the string without doing the popup.
        */
        pargs->pszOutput = (pszResult != pszNotFound) ? pszResult : NULL;
        nResult = IDOK;
    }

    return nResult;
}


VOID
UnclipWindow(
    IN HWND hwnd )

    /* Moves window 'hwnd' so any clipped parts are again visible on the
    ** screen.  The window is moved only as far as necessary to achieve this.
    */
{
    RECT rect;
    INT  dxScreen = GetSystemMetrics( SM_CXSCREEN );
    INT  dyScreen = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    if (rect.right > dxScreen)
        rect.left = dxScreen - (rect.right - rect.left);

    if (rect.left < 0)
        rect.left = 0;

    if (rect.bottom > dyScreen)
        rect.top = dyScreen - (rect.bottom - rect.top);

    if (rect.top < 0)
        rect.top = 0;

    SetWindowPos(
        hwnd, NULL,
        rect.left, rect.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );
}
VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef )

    /* Center window 'hwnd' on window 'hwndRef' or if 'hwndRef' is NULL on
    ** screen.  The window position is adjusted so that no parts are clipped
    ** by the edge of the screen, if necessary.  If 'hwndRef' has been moved
    ** off-screen with SetOffDesktop, the original position is used.
    */
{
    RECT rectCur;
    LONG dxCur;
    LONG dyCur;
    RECT rectRef;
    LONG dxRef;
    LONG dyRef;

    GetWindowRect( hwnd, &rectCur );
    dxCur = rectCur.right - rectCur.left;
    dyCur = rectCur.bottom - rectCur.top;

    if (hwndRef)
    {
//        if (!SetOffDesktop( hwndRef, SOD_GetOrgRect, &rectRef ))
            GetWindowRect( hwndRef, &rectRef );
    }
    else
    {
        rectRef.top = rectRef.left = 0;
        rectRef.right = GetSystemMetrics( SM_CXSCREEN );
        rectRef.bottom = GetSystemMetrics( SM_CYSCREEN );
    }

    dxRef = rectRef.right - rectRef.left;
    dyRef = rectRef.bottom - rectRef.top;

    rectCur.left = rectRef.left + ((dxRef - dxCur) / 2);
    rectCur.top = rectRef.top + ((dyRef - dyCur) / 2);

    SetWindowPos(
        hwnd, NULL,
        rectCur.left, rectCur.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );

    UnclipWindow( hwnd );
}

LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndProc hook callback that looks for the next dialog
    ** started and centers it on it's owner window.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to center
        ** the dialog on it's owner's window.
        */
        if (p->message == WM_INITDIALOG)
            CenterWindow( p->hwnd, GetParent( p->hwnd ) );
    }

    return 0;
}

TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId )

    /* String resource message loader routine.
    **
    ** Returns the address of a heap block containing the string corresponding
    ** to string resource 'dwStringId' or NULL if error.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    HRSRC  hrsrc;
    TCHAR* pszBuf;
    int    cchBuf = 256;
    int    cchGot;

    for (;;)
    {
        pszBuf = (TCHAR*)Malloc( cchBuf * sizeof(TCHAR) );
        if (!pszBuf)
            break;

        /* LoadString wants to deal with character-counts rather than
        ** byte-counts...weird.  Oh, and if you're thinking I could
        ** FindResource then SizeofResource to figure out the string size, be
        ** advised it doesn't work.  From perusing the LoadString source, it
        ** appears the RT_STRING resource type requests a segment of 16
        ** strings not an individual string.
        */
        cchGot = LoadString( hInstance, (UINT )dwStringId, pszBuf, cchBuf );

        if (cchGot < cchBuf - 1)
        {
            TCHAR *pszTemp = pszBuf;

            /* Good, got the whole string.  Reduce heap block to actual size
            ** needed.
            */
            pszBuf = (TCHAR*)Realloc( pszBuf, (cchGot + 1) * sizeof(TCHAR));

            if(NULL == pszBuf)
            {
                Free(pszTemp);
            }

            break;
        }

        /* Uh oh, LoadStringW filled the buffer entirely which could mean the
        ** string was truncated.  Try again with a larger buffer to be sure it
        ** wasn't.
        */
        Free( pszBuf );
        cchBuf += 256;
        TRACE1("Grow string buf to %d",cchBuf);
    }

    return pszBuf;
}

TCHAR*
GetText(
    IN HWND hwnd )

    /* Returns heap block containing the text contents of the window 'hwnd' or
    ** NULL.  It is caller's responsibility to Free the returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = GetWindowTextLength( hwnd );
    psz = (TCHAR*)Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        GetWindowText( hwnd, psz, cch + 1 );
    }

    return psz;
}

BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError )

    /* Fill caller's '*ppszError' with the address of a LocalAlloc'ed heap
    ** block containing the error text associated with error 'dwError'.  It is
    ** caller's responsibility to LocalFree the returned string.
    **
    ** Returns true if successful, false otherwise.
    */
{
#define MAXRASERRORLEN 256

    TCHAR  szBuf[ MAXRASERRORLEN + 1 ];
    DWORD  dwFlags;
    HANDLE hmodule;
    DWORD  cch;

    /* Don't panic if the RAS API address is not loaded.  Caller may be trying
    ** and get an error up during LoadRas.
    */
//  if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
//      && g_pRasGetErrorString
//      && g_pRasGetErrorString(
    if (RasGetErrorString ((UINT)dwError, (LPTSTR)szBuf, MAXRASERRORLEN) == 0)
    {
        /* It's a RAS error.
        */
        *ppszError = (TCHAR*)LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) * sizeof(TCHAR) );
        if (!*ppszError)
            return FALSE;

        lstrcpy( *ppszError, szBuf );
        return TRUE;
    }

    /* The rest adapted from BLT's LoadSystem routine.
    */
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS;

    if (dwError >= MIN_LANMAN_MESSAGE_ID && dwError <= MAX_LANMAN_MESSAGE_ID)
    {
        /* It's a net error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_HMODULE;
        hmodule = GetModuleHandle( TEXT("NETMSG.DLL") );
    }
    else
    {
        /* It must be a system error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_SYSTEM;
        hmodule = NULL;
    }

    cch = FormatMessage(
        dwFlags, hmodule, dwError, 0, (LPTSTR )ppszError, 1, NULL );
    return (cch > 0);
}

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat )

    /* Pops up a modal error dialog centered on 'hwndOwner'.  'DwOperation' is
    ** the string resource ID of the string describing the operation underway
    ** when the error occurred.  'DwError' is the code of the system or RAS
    ** error that occurred.  'Pargs' is a extended formatting arguments or
    ** NULL if none.  'hInstance' is the application/module handle where
    ** string resources are located.  'DwTitle' is the string ID of the dialog
    ** title.  'DwFormat' is the string ID of the error format title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszOp;
    TCHAR  szErrorNum[ 50 ];
    TCHAR* pszError;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("ErrorDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the error number string.
    */
    if (dwError > 0x7FFFFFFF)
        wsprintf( szErrorNum, TEXT("0x%X"), dwError );
    else
        wsprintf( szErrorNum, TEXT("%u"), dwError );

    /* Build the error text string.
    */
    if (!GetErrorText( dwError, &pszError ))
        pszError = pszNotFound;

    /* Build the operation string.
    */
    pszUnformatted = PszFromId( hInstance, dwOperation );
    pszOp = pszNotFound;

    if (pszUnformatted)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszUnformatted, 0, 0, (LPTSTR )&pszOp, 1,
            (va_list* )((pargs) ? pargs->apszOpArgs : NULL) );

        Free( pszUnformatted );
    }

    /* Call MsgDlgUtil with the standard arguments plus any auxillary format
    ** arguments.
    */
    pszUnformatted = PszFromId( hInstance, dwFormat );
    pszResult = pszNotFound;

    if (pszUnformatted)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK + MB_SETFOREGROUND;
        msgargs.pszString = pszUnformatted;
        msgargs.apszArgs[ 0 ] = pszOp;
        msgargs.apszArgs[ 1 ] = szErrorNum;
        msgargs.apszArgs[ 2 ] = pszError;

        if (pargs)
        {
            msgargs.fStringOutput = pargs->fStringOutput;

            CopyMemory( &msgargs.apszArgs[ 3 ], pargs->apszAuxFmtArgs,
                3 * sizeof(TCHAR) );
        }

        nResult =
            MsgDlgUtil(
                hwndOwner, 0, &msgargs, hInstance, dwTitle );

        Free( pszUnformatted );

        if (pargs && pargs->fStringOutput)
            pargs->pszOutput = msgargs.pszOutput;
    }

    if (pszOp != pszNotFound)
        LocalFree( pszOp );
    if (pszError != pszNotFound)
        LocalFree( pszError );

    return nResult;
}
int MsgDlgUtil(IN HWND hwndOwner, IN DWORD dwMsg, IN OUT MSGARGS* pargs, IN HINSTANCE hInstance, IN DWORD dwTitle);
#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)



// LVX stuff (cut-n-paste'd from ...\net\rras\ras\ui\common\uiutil\lvx.c, etc.


static LPCTSTR g_lvxcbContextId = NULL;

BOOL
ListView_IsCheckDisabled (
        IN HWND hwndLv,
        IN INT  iItem)

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is disabled, false otherwise.
    */
{
    UINT unState;
    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );

    if ((unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )) ||
        (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledUnchecked )))
        return TRUE;

    return FALSE;
}

VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck )

    /* Sets the check mark on item 'iItem' of listview of checkboxes 'hwndLv'
    ** to checked if 'fCheck' is true or unchecked if false.
    */
{
    NM_LISTVIEW nmlv;

    if (ListView_IsCheckDisabled(hwndLv, iItem))
        return;

    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );

    nmlv.hdr.code = LVXN_SETCHECK;
    nmlv.hdr.hwndFrom = hwndLv;
    nmlv.iItem = iItem;

    FORWARD_WM_NOTIFY(
        GetParent(hwndLv), GetDlgCtrlID(hwndLv), &nmlv, SendMessage
        );
}

VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns the lParam address of the 'iItem' item in 'hwndLv' or NULL if
    ** none or error.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;

    if (!ListView_GetItem( hwndLv, &item ))
        return NULL;

    return (VOID* )item.lParam;
}

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is checked, false otherwise.  This function works on disabled
    ** check boxes as well as enabled ones.
    */
{
    UINT unState;

    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );
    return !!((unState == INDEXTOSTATEIMAGEMASK( SI_Checked )) ||
              (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )));
}

LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* List view subclass window procedure to trap toggle-check events.
    */
{
    WNDPROC pOldProc;
    INT     iItem;
    BOOL    fSet;
    BOOL    fClear;
    BOOL    fToggle;

    iItem = -1;
    fSet = fClear = fToggle = FALSE;

    if (unMsg == WM_LBUTTONDOWN)
    {
        LV_HITTESTINFO info;

        /* Left mouse button pressed over checkbox icon toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  Now figure out if it's over the
            ** checkbox.  Note this currently doesn't account for use of the
            ** "indent" feature on an owner-drawn item.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON ))
                iItem = -1;
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_LBUTTONDBLCLK)
    {
        LV_HITTESTINFO info;

        /* Left mouse button double clicked over any area toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  If the click does not occur
             * over a checkbox, inform the parent of the double click.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON )) {
                NM_LISTVIEW nmlv;
                nmlv.hdr.code = LVXN_DBLCLK;
                nmlv.hdr.hwndFrom = hwnd;
                nmlv.iItem = iItem;

                FORWARD_WM_NOTIFY(
                    GetParent(hwnd), GetDlgCtrlID(hwnd), &nmlv, SendMessage);

                iItem = -1;
            }

            /*
             * Otherwise, toggle the state.
            */
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_CHAR)
    {
        /* Space bar pressed with item selected toggles check.
        ** Plus or Equals keys set check.
        ** Minus key clears check.
        */
        switch (wparam)
        {
            case TEXT(' '):
                fToggle = TRUE;
                break;

            case TEXT('+'):
            case TEXT('='):
                fSet = TRUE;
                break;

            case TEXT('-'):
                fClear = TRUE;
                break;
        }

        if (fToggle || fSet || fClear)
            iItem = ListView_GetNextItem( hwnd, -1, LVNI_SELECTED );
    }
    else if (unMsg == WM_KEYDOWN)
    {
        /* Left arrow becomes up arrow and right arrow becomes down arrow so
        ** the list of checkboxes behaves just like a static group of
        ** checkboxes.
        */
        if (wparam == VK_LEFT)
            wparam = VK_UP;
        else if (wparam == VK_RIGHT)
            wparam = VK_DOWN;
    }

    if (iItem >= 0)
    {

        /* If we are handling the spacebar, plus, minus, or equals,
        ** the change we make applies to all the selected items;
        ** hence the do {} while(WM_CHAR).
        */

        do {

            if (fToggle)
            {
                UINT unOldState;
                BOOL fCheck;

                fCheck = ListView_GetCheck( hwnd, iItem );
                ListView_SetCheck( hwnd, iItem, !fCheck );
            }
            else if (fSet)
            {
                if (!ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, TRUE );
            }
            else if (fClear)
            {
                if (ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, FALSE );
            }

            iItem = ListView_GetNextItem(hwnd, iItem, LVNI_SELECTED);

        } while(iItem >= 0 && unMsg == WM_CHAR);

        if (fSet || fClear) {

            /* Don't pass to listview to avoid beep.
            */
            return 0;
        }
    }

    pOldProc = (WNDPROC )GetProp( hwnd, g_lvxcbContextId );
    if (pOldProc)
        return CallWindowProc( pOldProc, hwnd, unMsg, wparam, lparam );

    return 0;
}

BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Initialize "list of checkbox" handling for listview 'hwndLv'.  'Hinst'
    ** is the module instance containing the two checkbox icons.  See LVX.RC.
    **
    ** Returns true if successful, false otherwise.  Caller must eventually
    ** call 'ListView_UninstallChecks', typically in WM_DESTROY processing.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;
    WNDPROC    pOldProc;

    // pmay: 397395
    //
    // Prevent endless loops resulting from accidentally calling this
    // api twice.
    //
    pOldProc = (WNDPROC)GetWindowLongPtr(hwndLv, GWLP_WNDPROC);
    if (pOldProc == LvxcbProc)
    {
        return TRUE;
    }

    /* Build checkbox image lists.
    */
    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK | ILC_MIRROR, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Unchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Checked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_DisabledUnchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_DisabledChecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_STATE );

    /* Register atom for use in the Windows XxxProp calls which are used to
    ** associate the old WNDPROC with the listview window handle.
    */
    if (!g_lvxcbContextId)
        g_lvxcbContextId = (LPCTSTR )GlobalAddAtom( _T("RASLVXCB") );
    if (!g_lvxcbContextId)
        return FALSE;

    /* Subclass the current window procedure.
    */
    pOldProc = (WNDPROC)SetWindowLongPtr(
                                hwndLv, GWLP_WNDPROC, (ULONG_PTR)LvxcbProc );

    return SetProp( hwndLv, g_lvxcbContextId, (HANDLE )pOldProc );
}

VOID
ListView_InsertSingleAutoWidthColumn(
    HWND hwndLv )

    // Insert a single auto-sized column into listview 'hwndLv', e.g. for a
    // list of checkboxes with no visible column header.
    //
{
    LV_COLUMN col;

    ZeroMemory( &col, sizeof(col) );
    col.mask = LVCF_FMT;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndLv, 0, &col );
    ListView_SetColumnWidth( hwndLv, 0, LVSCW_AUTOSIZE );
}

TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL )

    /* Returns a heap string containing the 'psz' shortened to fit in the
    ** given width, if necessary, by truncating and adding "...". 'Hdc' is the
    ** device context with the appropiate font selected.  'DxColumn' is the
    ** width of the column.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    const TCHAR szDots[] = TEXT("...");

    SIZE   size;
    TCHAR* pszResult;
    TCHAR* pszResultLast;
    TCHAR* pszResult2nd;
    DWORD  cch;

    cch = lstrlen( psz );
    pszResult = (TCHAR*)Malloc( (cch * sizeof(TCHAR)) + sizeof(szDots) );
    if (!pszResult)
        return NULL;
    lstrcpy( pszResult, psz );

    dxColumn -= dxColText;
    if (dxColumn <= 0)
    {
        /* None of the column text will be visible so bag the calculations and
        ** just return the original string.
        */
        return pszResult;
    }

    if (!GetTextExtentPoint32( hdc, pszResult, cch, &size ))
    {
        Free( pszResult );
        return NULL;
    }

    pszResult2nd = CharNext( pszResult );
    pszResultLast = pszResult + cch;

    while (size.cx > dxColumn && pszResultLast > pszResult2nd)
    {
        /* Doesn't fit.  Lop off a character, add the ellipsis, and try again.
        ** The minimum result is "..." for empty original or "x..." for
        ** non-empty original.
        */
        pszResultLast = CharPrev( pszResult2nd, pszResultLast );
        lstrcpy( pszResultLast, szDots );

        if (!GetTextExtentPoint( hdc, pszResult, lstrlen( pszResult ), &size ))
        {
            Free( pszResult );
            return NULL;
        }
    }

    return pszResult;
}

BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback )

    /* Respond to WM_DRAWITEM by drawing the list view item.  'Pdis' is the
    ** information sent by the system.  'PLvxCallback' is caller's callback to
    ** get information about drawing the control.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    LV_ITEM      item;
    INT          i;
    INT          dxState;
    INT          dyState;
    INT          dxSmall;
    INT          dySmall;
    INT          dxIndent;
    UINT         uiStyleState;
    UINT         uiStyleSmall;
    HIMAGELIST   himlState;
    HIMAGELIST   himlSmall;
    LVXDRAWINFO* pDrawInfo;
    RECT         rc;
    RECT         rcClient;
    BOOL         fEnabled;
    BOOL         fSelected;
    HDC          hdc;
    HFONT        hfont;


    TRACE3("LvxDrawItem,i=%d,a=$%X,s=$%X",
        pdis->itemID,pdis->itemAction,pdis->itemState);

    /* Make sure this is something we want to handle.
    */
    if (pdis->CtlType != ODT_LISTVIEW)
        return FALSE;

    if (pdis->itemAction != ODA_DRAWENTIRE
        && pdis->itemAction != ODA_SELECT
        && pdis->itemAction != ODA_FOCUS)
    {
        return TRUE;
    }

    /* Get item information from the list view.
    */
    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_IMAGE + LVIF_STATE;
    item.iItem = pdis->itemID;
    item.stateMask = LVIS_STATEIMAGEMASK;
    if (!ListView_GetItem( pdis->hwndItem, &item ))
    {
        TRACE("LvxDrawItem GetItem failed");
        return TRUE;
    }

    /* Stash some useful stuff for reference later.
    */
    fEnabled = IsWindowEnabled( pdis->hwndItem )
               && !(pdis->itemState & ODS_DISABLED);
    fSelected = (pdis->itemState & ODS_SELECTED);
    GetClientRect( pdis->hwndItem, &rcClient );

    /* Callback owner to get drawing information.
    */
    ASSERT(pLvxCallback);
    pDrawInfo = pLvxCallback( pdis->hwndItem, pdis->itemID );
    ASSERT(pDrawInfo);

    /* Get image list icon sizes now, though we draw them last because their
    ** background is set up during first column text output.
    */
    dxState = dyState = 0;
    himlState = ListView_GetImageList( pdis->hwndItem, LVSIL_STATE );
    if (himlState)
        ImageList_GetIconSize( himlState, &dxState, &dyState );

    dxSmall = dySmall = 0;
    himlSmall = ListView_GetImageList( pdis->hwndItem, LVSIL_SMALL );
    if (himlSmall)
        ImageList_GetIconSize( himlSmall, &dxSmall, &dySmall );

    uiStyleState = uiStyleSmall = ILD_TRANSPARENT;

    /* Figure out the number of pixels to indent the item, if any.
    */
    if (pDrawInfo->dxIndent >= 0)
        dxIndent = pDrawInfo->dxIndent;
    else
    {
        if (dxSmall > 0)
            dxIndent = dxSmall;
        else
            dxIndent = GetSystemMetrics( SM_CXSMICON );
    }

    /* Get a device context for the window and set it up with the font the
    ** control says it's using.  (Can't use the one that comes in the
    ** DRAWITEMSTRUCT because sometimes it has the wrong rectangle, see bug
    ** 13106)
    */
    hdc = GetDC( pdis->hwndItem );

    if(NULL == hdc)
    {
        return FALSE;
    }

    hfont = (HFONT )SendMessage( pdis->hwndItem, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    /* Set things up as if we'd just got done processing a column that ends
    ** after the icons, then loop thru each column from left to right.
    */
    rc.right = pdis->rcItem.left + dxIndent + dxState + dxSmall;
    rc.top = pdis->rcItem.top;
    rc.bottom = pdis->rcItem.bottom;

    for (i = 0; i < pDrawInfo->cCols; ++i)
    {
        TCHAR  szText[ LVX_MaxColTchars + 1 ];
        TCHAR* pszText;
        INT    dxCol;

        /* Get the column width, adding any index and icon width to the first
        ** column.
        */
        dxCol = ListView_GetColumnWidth( pdis->hwndItem, i );
        if (i == 0)
            dxCol -= dxIndent + dxState + dxSmall;

        szText[ 0 ] = TEXT('\0');
        ListView_GetItemText( pdis->hwndItem, pdis->itemID, i, szText,
            LVX_MaxColTchars + 1 );

        /* Update rectangle to enclose just this one item's column 'i'.
        */
        rc.left = rc.right;
        rc.right = rc.left + dxCol;

        if ((pDrawInfo->dwFlags & LVXDI_DxFill)
            && i == pDrawInfo->cCols - 1)
        {
            INT dxWnd = pdis->rcItem.left + rcClient.right;

            if (rc.right < dxWnd)
            {
                /* When the last column does not fill out a full controls
                ** width of space, extend it to the right so it does.  Note
                ** this does not mean the user can't scroll off to the right
                ** if they want.
                ** (Abolade-Gbadegesin 03-27-96)
                ** Don't subtrace rc.left when there is only one column;
                ** this accounts for the space needed for icons.
                */
                rc.right = pdis->rcItem.right = dxWnd;
                if (i == 0) {
                    ListView_SetColumnWidth(pdis->hwndItem, i, rc.right);
                }
                else {
                    ListView_SetColumnWidth(
                        pdis->hwndItem, i, rc.right - rc.left );
                }
            }
        }

        /* Lop the text and append "..." if it won't fit in the column.
        */
        pszText = Ellipsisize( hdc, szText, rc.right - rc.left, LVX_dxColText );
        if (!pszText)
            continue;

        /* Figure out the appropriate text and background colors for the
        ** current item state.
        */
        if (fEnabled)
        {
            if (fSelected)
            {
                SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
                if (pDrawInfo->dwFlags & LVXDI_Blend50Sel)
                    uiStyleSmall |= ILD_BLEND50;
            }
            else
            {
                if (pDrawInfo->adwFlags[ i ] & LVXDIA_3dFace)
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
                }
                else
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW ) );
                }
            }
        }
        else
        {
            if (pDrawInfo->adwFlags[ i ] & LVXDIA_Static)
            {
                SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }
            else
            {
                SetTextColor( hdc, GetSysColor( COLOR_GRAYTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }

            if (pDrawInfo->dwFlags & LVXDI_Blend50Dis)
                uiStyleSmall |= ILD_BLEND50;
        }

        /* Draw the column text.  In the first column the background of any
        ** indent and icons is erased to the text background color.
        */
        {
            RECT rcBg = rc;

            if (i == 0)
                rcBg.left -= dxIndent + dxState + dxSmall;

            ExtTextOut( hdc, rc.left + LVX_dxColText,
                rc.top + LVX_dyColText, ETO_CLIPPED + ETO_OPAQUE,
                &rcBg, pszText, lstrlen( pszText ), NULL );
        }

        Free( pszText );
    }

    /* Finally, draw the icons, if caller specified any.
    */
    if (himlState)
    {
        ImageList_Draw( himlState, (item.state >> 12) - 1, hdc,
            pdis->rcItem.left + dxIndent, pdis->rcItem.top, uiStyleState );
    }

    if (himlSmall)
    {
        ImageList_Draw( himlSmall, item.iImage, hdc,
            pdis->rcItem.left + dxIndent + dxState,
            pdis->rcItem.top, uiStyleSmall );
    }

    /* Draw the dotted focus rectangle around the whole item, if indicated.
    */
//comment for bug 52688 whistler
//   if ((pdis->itemState & ODS_FOCUS) && GetFocus() == pdis->hwndItem)
//        DrawFocusRect( hdc, &pdis->rcItem );
//

    ReleaseDC( pdis->hwndItem, hdc );

    return TRUE;
}

BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis )

    /* Respond to WM_MEASUREITEM message, i.e. fill in the height of an item
    ** in the ListView.  'Hwnd' is the owner window.  'Pmis' is the structure
    ** provided from Windows.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    HDC        hdc;
    HWND       hwndLv;
    HFONT      hfont;
    TEXTMETRIC tm;
    UINT       dySmIcon;
    RECT       rc;

    TRACE("LvxMeasureItem");

    if (pmis->CtlType != ODT_LISTVIEW)
        return FALSE;

    hwndLv = GetDlgItem( hwnd, pmis->CtlID );
    ASSERT(hwndLv);

    /* Get a device context for the list view control and set up the font the
    ** control says it's using.  MSDN claims the final font may not be
    ** available at this point, but it sure seems to be.
    */
    hdc = GetDC( hwndLv );
    hfont = (HFONT )SendMessage( hwndLv, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    if (GetTextMetrics( hdc, &tm ))
        pmis->itemHeight = tm.tmHeight + 1;
    else
        pmis->itemHeight = 0;

    /* Make sure it's tall enough for a standard small icon.
    */
    dySmIcon = (UINT )GetSystemMetrics( SM_CYSMICON );
    if (pmis->itemHeight < dySmIcon + LVX_dyIconSpacing)
        pmis->itemHeight = dySmIcon + LVX_dyIconSpacing;

    /* Set the width since the docs say to, though I don't think it's used by
    ** list view.
    */
    GetClientRect( hwndLv, &rc );
    pmis->itemWidth = rc.right - rc.left - 1;

    ReleaseDC( hwndLv, hdc );
    return TRUE;
}

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback )

    /* Handler that, when installed, turns a regular report-view-only list
    ** view (but with style LVS_OWNERDRAWFIXED) into an enhanced list view
    ** with full width selection bar and other custom column display options.
    ** It should appear in list view owner's dialog proc as follows:
    **
    **     BOOL
    **     MyDlgProc(
    **         IN HWND   hwnd,
    **         IN UINT   unMsg,
    **         IN WPARAM wparam,
    **         IN LPARAM lparam )
    **     {
    **         if (ListView_OwnerHandler(
    **                 hwnd, unMsg, wParam, lParam, MyLvxCallback ))
    **             return TRUE;
    **
    **         <the rest of your stuff here>
    **     }
    **
    ** 'PLvxCallback' is caller's callback routine that provides information
    ** about drawing columns and other options.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    /* This routine executes on EVERY message thru the dialog so keep it
    ** efficient, please.
    */
    switch (unMsg)
    {
        case WM_DRAWITEM:
            return LvxDrawItem( (DRAWITEMSTRUCT* )lparam, pLvxCallback );

        case WM_MEASUREITEM:
            return LvxMeasureItem( hwnd, (MEASUREITEMSTRUCT* )lparam );
    }

    return FALSE;
}

// StrDup* functions
TCHAR* _StrDup(LPCTSTR psz )    // my local version...

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  It is caller's responsibility to
    ** 'Free' the returned string.
    */
{
    TCHAR* pszNew = NULL;

    if (psz)
    {
        pszNew = (TCHAR*)Malloc( (lstrlen( psz ) + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDup Malloc failed");
            return NULL;
        }

        lstrcpy( pszNew, psz );
    }

    return pszNew;
}

TCHAR*
StrDupTFromW(
    LPCWSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return _StrDup ( psz );

#else // !UNICODE

    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )Malloc( cb + 1 );
        if (!pszNew)
        {
            TRACE("StrDupTFromW Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupTFromW conversion failed");
            return NULL;
        }
    }

    return pszNew;

#endif
}

WCHAR*
StrDupWFromT(
    LPCTSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or if 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return _StrDup ( psz );

#else // !UNICODE

    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = (WCHAR*)Malloc( (cb + 1) * sizeof(WCHAR) );
        if (!pszNew)
        {
            TRACE("StrDupWFromT Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupWFromT conversion failed");
            return NULL;
        }
    }

    return pszNew;
#endif
}

void
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT LPTSTR  pszBuffer )

    // Converts an IP address in host byte order to its
    // string representation.
    // pszBuffer should be allocated by the caller and be
    // at least 16 characters long.
    //
{
    BYTE* pb = (BYTE*)&dwAddr;
    static const TCHAR c_szIpAddr [] = TEXT("%d.%d.%d.%d");
    wsprintf (pszBuffer, c_szIpAddr, pb[3], pb[2], pb[1], pb[0]);
}
#ifdef DOWNLEVEL_CLIENT
DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp )

    // Converts an IP address represented as a string to
    // host byte order.
    //
{
    DWORD val, base, n;
    TCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == TEXT('0'))
        base = 8, cp++;
    if (*cp == TEXT('x') || *cp == TEXT('X'))
        base = 16, cp++;
    while (c = *cp)
    {
        if ((c >= TEXT('0')) && (c <= TEXT('9')))
        {
            val = (val * base) + (c - TEXT('0'));
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= TEXT('0')) && (c <= TEXT('9'))) ||
              ((c >= TEXT('A')) && (c <= TEXT('F'))) ||
              ((c >= TEXT('a')) && (c <= TEXT('f'))) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= TEXT('a')) && (c <= TEXT('f')))
                            ? TEXT('a')
                            : TEXT('A') ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == TEXT('.'))
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
            return (DWORD) -1;
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != TEXT(' ')))
        return 0xffffffff;

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD) (pp - parts);
    switch (n)
    {
    case 1:             // a -- 32 bits
        val = parts[0];
        break;

    case 2:             // a.b -- 8.24 bits
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:             // a.b.c -- 8.8.16 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
            (parts[2] & 0xffff);
        break;

    case 4:             // a.b.c.d -- 8.8.8.8 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        return 0xffffffff;
    }

    return val;
}
#endif
VOID*
Free0(
    VOID* p )

    /* Like Free, but deals with NULL 'p'.
    */
{
    if (!p)
        return NULL;

    return Free( p );
}

HRESULT ActivateLuna(HANDLE* phActivationContext, ULONG_PTR* pulCookie)
{
    HRESULT hr = E_FAIL;
    
    
    TCHAR szPath[MAX_PATH];
    if(0 != GetModuleFileName(_Module.GetResourceInstance(), szPath, sizeof(szPath) / sizeof(TCHAR)))
    {
        ACTCTX ActivationContext;
        ZeroMemory(&ActivationContext, sizeof(ActivationContext));
        ActivationContext.cbSize = sizeof(ActivationContext);
        ActivationContext.lpSource = szPath;
        ActivationContext.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        ActivationContext.lpResourceName = MAKEINTRESOURCE(123);
        
        ULONG_PTR ulCookie;
        HANDLE hActivationContext = CreateActCtx(&ActivationContext);
        if(NULL != hActivationContext)
        {
            if(TRUE == ActivateActCtx(hActivationContext, &ulCookie))
            {
                *phActivationContext = hActivationContext;
                *pulCookie = ulCookie;
                hr = S_OK;
            }
            else
            {
                ReleaseActCtx(hActivationContext);
            }
        }
    }
    return hr;
}

HRESULT DeactivateLuna(HANDLE hActivationContext, ULONG_PTR ulCookie)
{
    DeactivateActCtx(0, ulCookie);
    ReleaseActCtx(hActivationContext);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnapi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001
//
//  File:       H N A P I . H
//
//  Contents:   OEM API
//
//  Notes:
//
//  Author:     billi 21 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#define HNET_OEM_API_ENTER try {
#define HNET_OEM_API_LEAVE } catch (...) { return DISP_E_EXCEPTION; }

#include <eh.h>
class HNet_Oem_SEH_Exception 
{
private:
    unsigned int m_uSECode;
public:
   HNet_Oem_SEH_Exception(unsigned int uSECode) : m_uSECode(uSECode) {}
   HNet_Oem_SEH_Exception() {}
  ~HNet_Oem_SEH_Exception() {}
   unsigned int getSeHNumber() { return m_uSECode; }
};
void __cdecl hnet_oem_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp );
void EnableOEMExceptionHandling();
void DisableOEMExceptionHandling();

#ifndef IID_PPV_ARG
   #define IID_PPV_ARG(Type, Expr) \
       __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))
#endif


#ifndef ReleaseObj

#define ReleaseObj(obj)  (( obj ) ? (obj)->Release() : 0)

#endif


BOOLEAN IsSecureContext();

BOOLEAN IsNotifyApproved();

HRESULT InitializeOemApi( HINSTANCE hInstance );

HRESULT ReleaseOemApi();

HRESULT _ObtainIcsSettingsObj( IHNetIcsSettings** ppIcsSettings );

// structs
typedef struct tagICSPortMapping
{
   OLECHAR *pszwName;

   UCHAR    ucIPProtocol;
   USHORT   usExternalPort;
   USHORT   usInternalPort;
   DWORD    dwOptions;

   OLECHAR *pszwTargetName;
   OLECHAR *pszwTargetIPAddress;

   VARIANT_BOOL bEnabled;
}
ICS_PORTMAPPING, *LPICS_PORTMAPPING;

typedef struct tagICS_RESPONSE_RANGE
{
   UCHAR  ucIPProtocol;
   USHORT usStartPort;
   USHORT usEndPort;
}
ICS_RESPONSE_RANGE, *LPICS_RESPONSE_RANGE;

typedef struct tagICS_APPLICATION_DEFINITION
{
   VARIANT_BOOL bEnabled;
   OLECHAR *pszwName;
   UCHAR    ucIPProtocol;
   USHORT   usOutgoingPort;
   DWORD    dwOptions;
   USHORT   uscResponses;

   ICS_RESPONSE_RANGE lpResponse[1];
}
ICS_APPLICATION_DEFINITION, *LPICS_APPLICATION_DEFINITION;

class ATL_NO_VTABLE CNetConnectionProps :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetConnectionProps, &IID_INetConnectionProps, &LIBID_NETCONLib>
{
private:
   INetConnection* m_pNetConnection;   

public:

   BEGIN_COM_MAP(CNetConnectionProps)
      COM_INTERFACE_ENTRY(INetConnectionProps)
      COM_INTERFACE_ENTRY(IDispatch)
   END_COM_MAP()

   CNetConnectionProps()
   {
      m_pNetConnection = NULL;
   }
  ~CNetConnectionProps()
   {
      ReleaseObj (m_pNetConnection);
   }

   HRESULT Initialize (INetConnection * pNC)
   {
      _ASSERT (pNC);
      if (!pNC)
         return E_POINTER;
      ReleaseObj (m_pNetConnection);

      m_pNetConnection = pNC;
      m_pNetConnection->AddRef();
      return S_OK;
   }

// INetConnectionProps
   STDMETHODIMP get_Guid (BSTR * pbstrGuid)
   {
      HNET_OEM_API_ENTER

      if (!pbstrGuid)
         return E_POINTER;
      *pbstrGuid = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         LPOLESTR lpo = NULL;
         hr = StringFromCLSID (pNCP->guidId, &lpo);
         if (lpo) {
            *pbstrGuid = SysAllocString (lpo);
            if (!*pbstrGuid)
               hr = E_OUTOFMEMORY;
            CoTaskMemFree (lpo);
         }
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_Name (BSTR * pbstrName)
   {
      HNET_OEM_API_ENTER

      if (!pbstrName)
         return E_POINTER;
      *pbstrName = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pbstrName = SysAllocString (pNCP->pszwName);
         if (!*pbstrName)
            hr = E_OUTOFMEMORY;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_DeviceName(BSTR * pbstrDeviceName)
   {
      HNET_OEM_API_ENTER

      if (!pbstrDeviceName)
         return E_POINTER;
      *pbstrDeviceName = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pbstrDeviceName = SysAllocString (pNCP->pszwDeviceName);
         if (!*pbstrDeviceName)
            hr = E_OUTOFMEMORY;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_Status    (NETCON_STATUS * pStatus)
   {
      HNET_OEM_API_ENTER

      if (!pStatus)
         return E_POINTER;
//    *pStatus = NULL;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pStatus = pNCP->Status;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   STDMETHODIMP get_MediaType (NETCON_MEDIATYPE * pMediaType)
   {
      HNET_OEM_API_ENTER

      if (!pMediaType)
         return E_POINTER;
      *pMediaType = NCM_NONE;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pMediaType = pNCP->MediaType;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }

   STDMETHODIMP get_Characteristics (DWORD * pdwFlags)
   {
      HNET_OEM_API_ENTER

      if (!pdwFlags)
         return E_POINTER;
      *pdwFlags = NCCF_NONE;

      _ASSERT (m_pNetConnection);
      if (!m_pNetConnection)
         return E_UNEXPECTED;

      NETCON_PROPERTIES * pNCP = NULL;
      HRESULT hr = m_pNetConnection->GetProperties (&pNCP);
      if (pNCP) {
         *pdwFlags = pNCP->dwCharacter;
         NcFreeNetconProperties (pNCP);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
};

class ATL_NO_VTABLE CNetSharingConfiguration : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetSharingConfiguration, &IID_INetSharingConfiguration, &LIBID_NETCONLib>
{

private:

   IHNetConnection*        m_pHNetConnection;   
   IHNetProtocolSettings*   m_pSettings;

   CRITICAL_SECTION      m_csSharingConfiguration;

   // private method called from 2 wrappers below (get_SharingEnabled, get_SharingEnabledType)
   STDMETHODIMP GetSharingEnabled (BOOLEAN* pbEnabled, SHARINGCONNECTIONTYPE* pType);
   // this was necessary because oleautomation allows only one retval type

public:

    BEGIN_COM_MAP(CNetSharingConfiguration)
        COM_INTERFACE_ENTRY(INetSharingConfiguration)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

   CNetSharingConfiguration()
   {
      m_pHNetConnection = NULL;
      m_pSettings       = NULL;

       InitializeCriticalSection(&m_csSharingConfiguration);
   }

   ~CNetSharingConfiguration()
   {
       DeleteCriticalSection(&m_csSharingConfiguration);
   }

   HRESULT
   Initialize(
      INetConnection *pNetConnection );
   
   HRESULT
   FinalRelease()
   {
      ReleaseObj(m_pHNetConnection);
      ReleaseObj(m_pSettings);

      return S_OK;
   }

   STDMETHODIMP get_SharingEnabled    (VARIANT_BOOL* pbEnabled);
   STDMETHODIMP get_SharingConnectionType(SHARINGCONNECTIONTYPE* pType);

   STDMETHODIMP
   DisableSharing();

   STDMETHODIMP
   EnableSharing(
      SHARINGCONNECTIONTYPE  Type );

   STDMETHODIMP
   get_InternetFirewallEnabled(
      VARIANT_BOOL *pbEnabled );

   STDMETHODIMP
   DisableInternetFirewall();

   STDMETHODIMP
   EnableInternetFirewall();

    // Return an IEnumSharingPortMapping interface used to enumerate all of
    // the contained INetSharingPortMapping objects.
    //
   STDMETHODIMP
    get_EnumPortMappings(
        SHARINGCONNECTION_ENUM_FLAGS Flags,
        INetSharingPortMappingCollection** ppColl);

   STDMETHODIMP
   AddPortMapping(
      OLECHAR*                 pszwName,
      UCHAR                    ucIPProtocol,
      USHORT                   usExternalPort,
      USHORT                   usInternalPort,
        DWORD                      dwOptions,
      OLECHAR*                 pszwTargetNameOrIPAddress,
      ICS_TARGETTYPE           eTargetType,
      INetSharingPortMapping** ppMapping );

   STDMETHODIMP
   RemovePortMapping( 
      INetSharingPortMapping*  pMapping );

};


class ATL_NO_VTABLE CNetSharingManager : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CNetSharingManager, &CLSID_NetSharingManager>,
    public IDispatchImpl<INetSharingManager, &IID_INetSharingManager, &LIBID_NETCONLib>
{

private:
  
   IHNetIcsSettings*  m_pIcsSettings;

public:

    BEGIN_COM_MAP(CNetSharingManager)
        COM_INTERFACE_ENTRY(INetSharingManager)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_SHAREMGR)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

   CNetSharingManager()
   {
      m_pIcsSettings = NULL;
   }
   
   HRESULT FinalConstruct()
   {
      return _ObtainIcsSettingsObj( &m_pIcsSettings );
   }

   HRESULT FinalRelease()
   {
      ReleaseObj( m_pIcsSettings );

      return S_OK;
   }


   STDMETHODIMP
   get_SharingInstalled( 
      VARIANT_BOOL *pbInstalled );

    // Return an IEnumNetEveryConnection interface used to enumerate all of
    // the contained INetConnections
    //
    STDMETHODIMP
    get_EnumEveryConnection(
        INetSharingEveryConnectionCollection** ppColl);

    // Return an IEnumNetPublicConnection interface used to enumerate all of
    // the contained INetConnections configured as a public adapter
    //
    STDMETHODIMP
    get_EnumPublicConnections(
        SHARINGCONNECTION_ENUM_FLAGS Flags,
        INetSharingPublicConnectionCollection** ppColl);

    // Return an IEnumNetPrivateConnection interface used to enumerate all of
    // the contained INetConnections configured as a private adapter
    //
    STDMETHODIMP
    get_EnumPrivateConnections(
        SHARINGCONNECTION_ENUM_FLAGS Flags,
        INetSharingPrivateConnectionCollection** ppColl);

   STDMETHODIMP
   get_INetSharingConfigurationForINetConnection(
        INetConnection*            pNetConnection,
        INetSharingConfiguration** ppNetSharingConfiguration
        );


   STDMETHODIMP
   get_NetConnectionProps(
      INetConnection      * pNetConnection,
      INetConnectionProps **ppProps)
   {
      HNET_OEM_API_ENTER

      if (!ppProps)
         return E_POINTER;
      else
         *ppProps = NULL;
      if (!pNetConnection)
         return E_INVALIDARG;

      CComObject<CNetConnectionProps>* pNCP = NULL;
      HRESULT hr = CComObject<CNetConnectionProps>::CreateInstance(&pNCP);
      if (pNCP) {
         pNCP->AddRef();
         hr = pNCP->Initialize (pNetConnection);
         if (hr == S_OK)
            hr = pNCP->QueryInterface (
                     __uuidof(INetConnectionProps), (void**)ppProps);
         pNCP->Release();
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
};


template<
   class IMapping,
   class IProtocol
   >
class TNetMapping :
    public CComObjectRootEx<CComMultiThreadModel>,
   public IMapping
{

private:

   IProtocol*        m_pIProtocol;
   CRITICAL_SECTION  m_csDefinition;

protected:

   IProtocol* _IProtocol() { return m_pIProtocol; }

   IProtocol* _IProtocol( IProtocol* _pIProtocol )
   {
      if ( m_pIProtocol ) ReleaseObj(m_pIProtocol);

      m_pIProtocol = _pIProtocol;

      if ( m_pIProtocol ) m_pIProtocol->AddRef();
      
      return m_pIProtocol;
   }

   CRITICAL_SECTION* _CriticalSection()
   {
      return &m_csDefinition;
   }

public:

   typedef TNetMapping<IMapping, IProtocol> _ThisClass;

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(IMapping)
    END_COM_MAP()

public:

   TNetMapping()
   {
      m_pIProtocol = NULL;

      InitializeCriticalSection(&m_csDefinition);
   }

   ~TNetMapping()
   {
      DeleteCriticalSection(&m_csDefinition);
   }

   HRESULT
   FinalRelease()
   {
      ReleaseObj( m_pIProtocol );

      return S_OK;
   }
   
   HRESULT
   Initialize(
      IProtocol*  pItem)
   {
      EnterCriticalSection(&m_csDefinition);

      _IProtocol( pItem );

      LeaveCriticalSection(&m_csDefinition);

      return S_OK;
   }

   STDMETHOD(Disable)(void)
   {
      HRESULT   hr;

      if ( !IsNotifyApproved() )
      {
         hr = E_ACCESSDENIED;
      }
      else if ( NULL == m_pIProtocol )
      {
         hr = E_UNEXPECTED;
      }
      else
      {
         hr = m_pIProtocol->SetEnabled( FALSE );
      }

      return hr;
   }

   STDMETHOD(Enable)(void)
   {
      HRESULT   hr;

      if ( !IsNotifyApproved() )
      {
         hr = E_ACCESSDENIED;
      }
      else if ( NULL == m_pIProtocol )
      {
         hr = E_UNEXPECTED;
      }
      else
      {
         hr = m_pIProtocol->SetEnabled( TRUE );
      }

      return hr;
   }
};

class ATL_NO_VTABLE CNetSharingPortMapping :
   public IDispatchImpl<TNetMapping<INetSharingPortMapping, IHNetPortMappingBinding>, &IID_INetSharingPortMapping, &LIBID_NETCONLib>
{

public:

   typedef TNetMapping<INetSharingPortMapping, IHNetPortMappingBinding> _ThisOtherClass;

    BEGIN_COM_MAP(CNetSharingPortMapping)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisOtherClass)
    END_COM_MAP()

   STDMETHODIMP get_Properties (/*[out, retval]*/ INetSharingPortMappingProps ** ppNSPMP);

   STDMETHODIMP
   Delete();
};


template<
   class EnumInterface,
   class ItemInterface,
   class EnumWrapped,
   class ItemWrapped
   >
class TNetApiEnum :
    public CComObjectRootEx<CComMultiThreadModel>,
    public EnumInterface,
    public IEnumVARIANT
{

protected:

    typedef TNetApiEnum<EnumInterface, ItemInterface, EnumWrapped, ItemWrapped> _ThisClass;

   friend class TNetApiEnum<EnumInterface, ItemInterface, EnumWrapped, ItemWrapped>;

   SHARINGCONNECTION_ENUM_FLAGS  m_fEnumFlags;
   EnumWrapped*                  m_pEnum;

   CRITICAL_SECTION            m_csEnum;

public:

    TNetApiEnum ()
    {
      m_fEnumFlags = ICSSC_DEFAULT;
      m_pEnum      = NULL;

       InitializeCriticalSection(&m_csEnum);
    }

   ~TNetApiEnum ()
   {
      DeleteCriticalSection(&m_csEnum);
   }

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(EnumInterface)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

   HRESULT Initialize( EnumWrapped* pEnum, SHARINGCONNECTION_ENUM_FLAGS Flags )
   {
      EnterCriticalSection(&m_csEnum);

      ReleaseObj( m_pEnum );

      m_fEnumFlags = Flags;
      m_pEnum      = pEnum;

      m_pEnum->AddRef();

      LeaveCriticalSection(&m_csEnum);

      return S_OK;
   }

   HRESULT FinalRelease ()
   {
      ReleaseObj( m_pEnum );

      return S_OK;      
   }

   virtual HRESULT GetItemInterfaceFromItemWrapped( ItemWrapped* pItem, ItemInterface** ppIface )
   {
      HRESULT hr;

      if ( NULL == ppIface )
      {   
         hr = E_POINTER;
      }
      else if ( NULL == pItem )
      {
         hr = E_INVALIDARG;
      }
      else
      {
         *ppIface = NULL;

         hr = E_NOTIMPL;
      }

      return hr;
   }

private:
    STDMETHOD (Next) (
        ULONG              celt,
        ItemInterface**    rgelt,
        ULONG*             pceltFetched)
   {
      HRESULT hr = S_OK;
      ULONG   ulFetched = 0;

      ItemInterface  **ppNet = rgelt;
      ItemWrapped    **ItemArray;

      // Validate parameters.

      if ( !rgelt || ((1 < celt) && !pceltFetched) )
      {
         hr = E_POINTER;
      }
      else if ( 0 == celt )
      {
         hr = E_INVALIDARG;
      }

      if ( SUCCEEDED(hr) )
      {
         ZeroMemory(rgelt, sizeof(ItemInterface*) * celt);

         if ( pceltFetched ) *pceltFetched = 0;

         ulFetched = 0;
      
         if ( NULL == m_pEnum )
         {
            hr = S_FALSE;
         }
         else
         {
            ItemArray = new ItemWrapped * [ sizeof(ItemWrapped) * celt ];

            if ( ItemArray )
            {
               ZeroMemory( ItemArray, sizeof(ItemWrapped) * celt );
            }
            else
            {
               hr = E_OUTOFMEMORY;
            }
         }
      }

      if ( SUCCEEDED(hr) && m_pEnum )
      {
         ItemWrapped **ppItem;
         ULONG         ulBatchFetched, i;

         hr = m_pEnum->Next( celt, ItemArray, &ulBatchFetched );

         ppItem = ItemArray;
         ppNet  = rgelt;

         for( i=0, ulFetched=0; ( ( i < ulBatchFetched ) && ( S_OK == hr ) ); i++, ppItem++ )
         {
            hr = GetItemInterfaceFromItemWrapped( *ppItem, ppNet );

            if ( SUCCEEDED(hr) )
            {
               ppNet++;

               ulFetched++;
            }

            ReleaseObj( *ppItem );
         }

         delete [] ItemArray;
      }

      if ( ulFetched > 0 )
      {
         hr = ( ulFetched == celt ) ? S_OK : S_FALSE;

         if ( pceltFetched ) *pceltFetched = ulFetched;
      }

      return hr;
   }
public:
   STDMETHOD (Next) (ULONG celt, VARIANT * rgVar, ULONG * pceltFetched)
   {  // this Next calls the private Next to wrap up ItemInterfaces in VARIANTs
      HNET_OEM_API_ENTER

      if (!rgVar || ((1 < celt) && !pceltFetched))
         return E_POINTER;
      else if (0 == celt)
         return E_INVALIDARG;

      // clear variant array
      for (ULONG c=0; c<celt; c++)
         VariantInit (&rgVar[c]);

      HRESULT hr = S_OK;

      // alloc array of ItemInterface* and call private Next
      ItemInterface ** rgelt = (ItemInterface**)malloc (celt*sizeof(ItemInterface*));
      if (!rgelt)
         hr = E_OUTOFMEMORY;
      else {
         ULONG ulElements = 0;
         hr = Next (celt, rgelt, &ulElements);
         if (pceltFetched)
            *pceltFetched = ulElements;

         if (SUCCEEDED(hr)) {

            for (ULONG ul=0; ul<ulElements; ul++) {
               if (S_OK == (hr = rgelt[ul]->QueryInterface (__uuidof(IDispatch), (void**)&V_DISPATCH (&rgVar[ul]))))
                  V_VT (&rgVar[ul]) = VT_DISPATCH;
               else 
               if (S_OK == (hr = rgelt[ul]->QueryInterface (__uuidof(IUnknown),  (void**)&V_UNKNOWN  (&rgVar[ul]))))
                  V_VT (&rgVar[ul]) = VT_UNKNOWN;
               else
                  break;
            }
            for (ULONG ul=0; ul<ulElements; ul++)
               rgelt[ul]->Release();
         }
         free (rgelt);
      }
      return hr;

      HNET_OEM_API_LEAVE
   }

    STDMETHOD (Skip) (
        ULONG   celt)
   {
      return ( (m_pEnum) ? m_pEnum->Skip(celt) : S_OK );
   }


    STDMETHOD (Reset) ()
   {
      return ( (m_pEnum) ? m_pEnum->Reset() : S_OK );
   }

public:
    STDMETHOD (Clone) (
        EnumInterface**  ppEnum)
   {
      HNET_OEM_API_ENTER
      
      HRESULT hr = S_OK;

      CComObject<_ThisClass>* pNewEnum;
      EnumWrapped*            pClonedEnum;

      if ( NULL == ppEnum )
      {
          hr = E_POINTER;
      }
      else 
      {
          // Attempt to clone the embedded enumeration.

          pClonedEnum = NULL;
          hr = m_pEnum->Clone(&pClonedEnum);
      }


      if ( SUCCEEDED(hr) )
      {
          // Create an initialized a new instance of ourselves

          hr = CComObject<_ThisClass>::CreateInstance(&pNewEnum);

          if ( SUCCEEDED(hr) )
          {
              pNewEnum->AddRef();
              
              hr = pNewEnum->Initialize( pClonedEnum, m_fEnumFlags );

              if ( SUCCEEDED(hr) )
              {
                  hr = pNewEnum->QueryInterface( IID_PPV_ARG(EnumInterface, ppEnum) );
              }

              pNewEnum->Release();
          }

          // Release the cloned enum. New enum object will have
          // AddReffed it...

          pClonedEnum->Release();
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
public:
   STDMETHOD (Clone) (IEnumVARIANT ** ppEnum)
   {
      HNET_OEM_API_ENTER

      EnumInterface* pEnum = NULL;
      HRESULT hr = Clone (&pEnum);
      if (pEnum) {
         hr = pEnum->QueryInterface (__uuidof(IEnumVARIANT), (void**)ppEnum);
         pEnum->Release();
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   
};

template<> 
HRESULT TNetApiEnum <IEnumNetSharingEveryConnection,
                 INetConnection,
                 IEnumNetConnection,
                 INetConnection>
::GetItemInterfaceFromItemWrapped( 
   INetConnection*  pItem, 
   INetConnection** ppIface 
   )
{
   HRESULT hr;

   if ( NULL == ppIface )
   {   
      hr = E_POINTER;
   }
   else if ( NULL == pItem )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      hr = pItem->QueryInterface( IID_PPV_ARG( INetConnection, ppIface ) );
   }

   return hr;
}

class ATL_NO_VTABLE CSharingManagerEnumEveryConnection :
   public TNetApiEnum <IEnumNetSharingEveryConnection,
                   INetConnection,
                   IEnumNetConnection,
                   INetConnection>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumEveryConnection)
        COM_INTERFACE_ENTRY(IEnumNetSharingEveryConnection)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

template<> 
HRESULT TNetApiEnum <IEnumNetSharingPublicConnection,
                 INetConnection,
                 IEnumHNetIcsPublicConnections,
                 IHNetIcsPublicConnection>
::GetItemInterfaceFromItemWrapped( 
   IHNetIcsPublicConnection* pItem, 
   INetConnection**          ppIface 
   )
{
   HRESULT hr;

   if ( NULL == ppIface )
   {   
      hr = E_POINTER;
   }
   else if ( NULL == pItem )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      IHNetConnection* pHNet;

      *ppIface = NULL;

      hr = pItem->QueryInterface( IID_PPV_ARG( IHNetConnection, &pHNet ) );

      if ( SUCCEEDED(hr) )
      {
         hr = pHNet->GetINetConnection( ppIface );
      
         ReleaseObj( pHNet );
      }
   }

   return hr;
}

class ATL_NO_VTABLE CSharingManagerEnumPublicConnection :
   public TNetApiEnum <IEnumNetSharingPublicConnection,
                   INetConnection,
                   IEnumHNetIcsPublicConnections,
                   IHNetIcsPublicConnection>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumPublicConnection)
        COM_INTERFACE_ENTRY(IEnumNetSharingPublicConnection)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

template<>
HRESULT TNetApiEnum <IEnumNetSharingPrivateConnection,
                INetConnection,
                IEnumHNetIcsPrivateConnections,
                IHNetIcsPrivateConnection>
::GetItemInterfaceFromItemWrapped( 
         IHNetIcsPrivateConnection* pItem, 
         INetConnection**           ppIface )
{
   HRESULT hr;

   if ( NULL == ppIface )
   {   
      hr = E_POINTER;
   }
   else if ( NULL == pItem )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      IHNetConnection* pHNet;

      *ppIface = NULL;

      hr = pItem->QueryInterface( IID_PPV_ARG( IHNetConnection, &pHNet ) );

      if ( SUCCEEDED(hr) )
      {
         hr = pHNet->GetINetConnection( ppIface );
      
         ReleaseObj( pHNet );
      }
   }

   return hr;
}


class ATL_NO_VTABLE CSharingManagerEnumPrivateConnection :
   public TNetApiEnum <IEnumNetSharingPrivateConnection,
                   INetConnection,
                   IEnumHNetIcsPrivateConnections,
                   IHNetIcsPrivateConnection>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumPrivateConnection)
        COM_INTERFACE_ENTRY(IEnumNetSharingPrivateConnection)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

template<>
HRESULT TNetApiEnum<IEnumNetSharingPortMapping,
               INetSharingPortMapping,
               IEnumHNetPortMappingBindings,
               IHNetPortMappingBinding>
::GetItemInterfaceFromItemWrapped( 
         IHNetPortMappingBinding*  pItem, 
         INetSharingPortMapping**  ppIface )
{
   HRESULT hr;

   hr = ( NULL == ppIface ) ? E_POINTER : S_OK;

   if ( SUCCEEDED(hr) )
   {
      *ppIface = NULL;

      if ( NULL == pItem )
      {
         hr = E_INVALIDARG;
      }
   }

   if ( SUCCEEDED(hr) )
   {
      CComObject<CNetSharingPortMapping>* pMap;

        hr = CComObject<CNetSharingPortMapping>::CreateInstance(&pMap);
      
      if ( SUCCEEDED(hr) )
      {
         pMap->AddRef();

         hr = pMap->Initialize( pItem );

         if ( SUCCEEDED(hr) )
         {
            hr = pMap->QueryInterface( IID_PPV_ARG( INetSharingPortMapping, ppIface ) );
         }

         ReleaseObj(pMap);
      }
   }

   return hr;
}


class ATL_NO_VTABLE CSharingManagerEnumPortMapping :
   public TNetApiEnum<IEnumNetSharingPortMapping,
                  INetSharingPortMapping,
                  IEnumHNetPortMappingBindings,
                  IHNetPortMappingBinding>
{

public:

    BEGIN_COM_MAP(CSharingManagerEnumPortMapping)
        COM_INTERFACE_ENTRY(IEnumNetSharingPortMapping)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

// collections
template <class IEnumBase, class IEnumerator>
class TNetCollection :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IEnumBase
{
private:
   IEnumerator * m_pE;

public:

   typedef TNetCollection<IEnumBase, IEnumerator> _ThisClass;

   BEGIN_COM_MAP(_ThisClass)
      COM_INTERFACE_ENTRY(IEnumBase)
   END_COM_MAP()

public:

   TNetCollection()
   {
      m_pE = NULL;
   }
  ~TNetCollection()
   {
      ReleaseObj(m_pE);
   }

   HRESULT Initialize (IEnumerator * pE)
   {
      _ASSERT ( pE != NULL);
      _ASSERT(m_pE == NULL);
      m_pE = pE;
      m_pE->AddRef();
      return S_OK;
   }

   STDMETHOD(get__NewEnum)(IUnknown** ppVal)
   {
      HNET_OEM_API_ENTER

       if (!ppVal)
           return E_POINTER;
       if (!m_pE)
           return E_UNEXPECTED;
       return m_pE->QueryInterface (__uuidof(IUnknown), (void**)ppVal);

      HNET_OEM_API_LEAVE
   }

   STDMETHOD(get_Count)(long *pVal)
   {
      HNET_OEM_API_ENTER

      if (!pVal)
          return E_POINTER;
      if (!m_pE)
          return E_UNEXPECTED;
   
      CComPtr<IEnumerator> spE;
      HRESULT hr = m_pE->Clone (&spE);
      if (spE) {
          long lCount = 0;
          spE->Reset();
          while (1) {
              CComVariant cvar;
              HRESULT hr2 = spE->Next (1, &cvar, NULL);
              if (hr2 == S_OK)
                  lCount++;
              else
                  break;
          }
          *pVal = lCount;
      }
      return hr;

      HNET_OEM_API_LEAVE
   }
   
};

class ATL_NO_VTABLE CNetSharingEveryConnectionCollection :
    public IDispatchImpl<TNetCollection<INetSharingEveryConnectionCollection, IEnumNetSharingEveryConnection>, &IID_INetSharingEveryConnectionCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingEveryConnectionCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

class ATL_NO_VTABLE CNetSharingPublicConnectionCollection :
    public IDispatchImpl<TNetCollection<INetSharingPublicConnectionCollection, IEnumNetSharingPublicConnection>, &IID_INetSharingPublicConnectionCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingPublicConnectionCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

class ATL_NO_VTABLE CNetSharingPrivateConnectionCollection :
    public IDispatchImpl<TNetCollection<INetSharingPrivateConnectionCollection,IEnumNetSharingPrivateConnection>, &IID_INetSharingPrivateConnectionCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingPrivateConnectionCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};

class ATL_NO_VTABLE CNetSharingPortMappingCollection :
    public IDispatchImpl<TNetCollection<INetSharingPortMappingCollection, IEnumNetSharingPortMapping>, &IID_INetSharingPortMappingCollection, &LIBID_NETCONLib>
{
public:
    BEGIN_COM_MAP(CNetSharingPortMappingCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(_ThisClass)
    END_COM_MAP()
};


// props
class ATL_NO_VTABLE CNetSharingPortMappingProps :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetSharingPortMappingProps, &IID_INetSharingPortMappingProps, &LIBID_NETCONLib>
{
private:
   ICS_PORTMAPPING m_IPM;  // not alloc'd

public:
    BEGIN_COM_MAP(CNetSharingPortMappingProps)
        COM_INTERFACE_ENTRY(INetSharingPortMappingProps)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

public:
   CNetSharingPortMappingProps()
   {
      ZeroMemory (&m_IPM, sizeof(ICS_PORTMAPPING));
   }
  ~CNetSharingPortMappingProps()
   {
      FreeData (&m_IPM);
   }


public:  // CNetSharingPortMappingProps
   ICS_PORTMAPPING * GetVolatileRawData (void)
   {
      return &m_IPM;
   }
   HRESULT SetRawData (ICS_PORTMAPPING * pIPM)
   {
      _ASSERT (pIPM);
      if (!pIPM)
         return E_POINTER;

      ICS_PORTMAPPING IPM = {0};
      HRESULT hr = DupData (pIPM, &IPM);
      if (hr == S_OK) {
         FreeData (&m_IPM);
         m_IPM = IPM;  // struct copy
      }
      return S_OK;
   }
   static OLECHAR * DupString (OLECHAR * in)
   {
      OLECHAR * po = NULL;
      if (in) {
         po = (OLECHAR*)malloc ((wcslen (in) + 1)*sizeof(OLECHAR));
         if (po)
            wcscpy(po, in);
      } else {
         // one of pszwTargetName or pszwTargetIPAddress may be blank! so...
         po = (OLECHAR*)malloc (1*sizeof(OLECHAR));
         if (po)
            *po = 0; // ...alloc an emptry string
      }
      return po;
   }
   static HRESULT DupData (ICS_PORTMAPPING * in, ICS_PORTMAPPING * out)
   {
      if (!in) return E_POINTER;

      out->ucIPProtocol   = in->ucIPProtocol;
      out->usExternalPort = in->usExternalPort;
      out->usInternalPort = in->usInternalPort;
      out->dwOptions      = in->dwOptions;
      out->bEnabled       = in->bEnabled;

      out->pszwName            = DupString (in->pszwName);
      out->pszwTargetName      = DupString (in->pszwTargetName);
      out->pszwTargetIPAddress = DupString (in->pszwTargetIPAddress);
      if (!out->pszwName || !out->pszwTargetName || !out->pszwTargetIPAddress) {
         FreeData (out);
         return E_OUTOFMEMORY;
      }
      return S_OK;
   }
   static void FreeData (ICS_PORTMAPPING * pIPM)
   {
      if (pIPM) {
         if (pIPM->pszwName)            free (pIPM->pszwName);
         if (pIPM->pszwTargetName)      free (pIPM->pszwTargetName);
         if (pIPM->pszwTargetIPAddress) free (pIPM->pszwTargetIPAddress);
      }
   }

public:  // INetSharingPortMappingProps

   STDMETHODIMP get_Name           (/*[out, retval]*/ BSTR  * pbstrName);
   STDMETHODIMP get_IPProtocol     (/*[out, retval]*/ UCHAR * pucIPProt);
   STDMETHODIMP get_ExternalPort   (/*[out, retval]*/ long    * pusPort);
   STDMETHODIMP get_InternalPort   (/*[out, retval]*/ long    * pusPort);
   STDMETHODIMP get_Options        (/*[out, retval]*/ long   * pdwOptions);
   STDMETHODIMP get_TargetName     (/*[out, retval]*/ BSTR  * pbstrTargetName);
   STDMETHODIMP get_TargetIPAddress(/*[out, retval]*/ BSTR  * pbstrTargetIPAddress);
   STDMETHODIMP get_Enabled        (/*[out, retval]*/ VARIANT_BOOL * pbool);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnappprt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P P P R T . H
//
//  Contents:   CHNetAppProtocol declarations
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetAppProtocol :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetApplicationProtocol
{
private:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to WMI instance
    //

    BSTR m_bstrProtocol;

    //
    // True if this is a built-in protocol. We cache
    // this value as it will be used quite often, and
    // will never change for the instance.
    //

    BOOLEAN m_fBuiltIn;

    //
    // Obtains the protocol object from the stored path
    //

    HRESULT
    GetProtocolObject(
        IWbemClassObject **ppwcoInstance
        );

public:

    BEGIN_COM_MAP(CHNetAppProtocol)
        COM_INTERFACE_ENTRY(IHNetApplicationProtocol)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //
    
    CHNetAppProtocol()
    {
        m_piwsHomenet = NULL;
        m_bstrProtocol = NULL;
        m_fBuiltIn = FALSE;
    };
    
    //
    // Atl methods
    //

    HRESULT
    FinalRelease();

    //
    // Object initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoInstance
        );

    //
    // IHNetApplicationProtocol methods
    //

    STDMETHODIMP
    GetName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    SetName(
        OLECHAR *pszwName
        );

    STDMETHODIMP
    GetOutgoingIPProtocol(
        UCHAR *pucProtocol
        );

    STDMETHODIMP
    SetOutgoingIPProtocol(
        UCHAR ucProtocol
        );

    STDMETHODIMP
    GetOutgoingPort(
        USHORT *pusPort
        );

    STDMETHODIMP
    SetOutgoingPort(
        USHORT usPort
        );

    STDMETHODIMP
    GetResponseRanges(
        USHORT *puscResponses,
        HNET_RESPONSE_RANGE *prgResponseRange[]
        );

    STDMETHODIMP
    SetResponseRanges(
        USHORT uscResponses,
        HNET_RESPONSE_RANGE rgResponseRange[]
        );

    STDMETHODIMP
    GetBuiltIn(
        BOOLEAN *pfBuiltIn
        );

    STDMETHODIMP
    GetEnabled(
        BOOLEAN *pfEnabled
        );

    STDMETHODIMP
    SetEnabled(
        BOOLEAN fEnable
        );

    STDMETHODIMP
    Delete();
};

//
// Type to use for our enumeration class
//

typedef CHNCEnum<
            IEnumHNetApplicationProtocols,
            IHNetApplicationProtocol,
            CHNetAppProtocol
            >
        CEnumHNetApplicationProtocols;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\idl\sauclsid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File: SAUClsId.c
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

// {d851f103-8c90-4321-aff0-58ba5bd421c2}

DEFINE_GUID(CLSID_SAUpdate, 0xd851f103,0x8c90,0x4321,0xaf,0xf0,0x58,0xba,0x5b,0xd4,0x21,0xc2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnbrgcon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R G C O N . H
//
//  Contents:   CHNBridgedConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNBridgedConn :
    public CHNetConn,
    public IHNetBridgedConnection
{
private:
    HRESULT
    CHNBridgedConn::UnbindFromBridge(
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );

    HRESULT
    CopyBridgeBindings(
        IN INetCfgComponent     *pnetcfgAdapter,
        IN INetCfgComponent     *pnetcfgBridge
        );

public:

    BEGIN_COM_MAP(CHNBridgedConn)
        COM_INTERFACE_ENTRY(IHNetBridgedConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    //
    // Ojbect initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoConnection
        );

    //
    // IHNetBridgedConnection methods
    //

    STDMETHODIMP
    GetBridge(
        IHNetBridge **ppBridge
        );

    STDMETHODIMP
    RemoveFromBridge(
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );
};

typedef CHNCArrayEnum<IEnumHNetBridgedConnections, IHNetBridgedConnection> CEnumHNetBridgedConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncatl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       H N C A T L . H
//
//  Contents:   Common code for use with ATL.
//
//  Notes:      
//
//  Author:     jonburs     23 May 2000 (from shaunco   22 Sep 1997)
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _HNCATL_H_
#define _HNCATL_H_

//
// This file should be included *after* your standard ATL include sequence.
//
//      #include <atlbase.h>
//      extern CComModule _Module;
//      #include <atlcom.h>
//      #include "hncatl.h"      <------
//
// We cannot directly include that sequence here because _Module may be
// derived from CComModule as opposed to an instance of it.
//

//
// We have our own version of AtlModuleRegisterServer coded here
// because the former brings in oleaut32.dll so it can register
// type libraries.  We don't care to have a type library registered
// so we can avoid the whole the mess associated with oleaut32.dll.
//

inline
HRESULT
NcAtlModuleRegisterServer(
    _ATL_MODULE* pM
    )
{
    /*AssertH (pM);
    AssertH(pM->m_hInst);
    AssertH(pM->m_pObjMap);*/

    HRESULT hr = S_OK;

    for (_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
         pEntry->pclsid;
         pEntry++)
    {
        if (pEntry->pfnGetObjectDescription() != NULL)
        {
            continue;
        }

        hr = pEntry->pfnUpdateRegistry(TRUE);
        if (FAILED(hr))
        {
            break;
        }
    }

    // TraceError ("NcAtlModuleRegisterServer", hr);
    return hr;
}

#endif // _HNCATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C B A S E . H
//
//  Contents:   Base include file for HNetCfg service. Defines globals.
//
//  Notes:
//
//  Author:     jonburs     23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include "hncatl.h"

#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

//
// Return value to use for policy violations
//

#define HN_E_POLICY E_ACCESSDENIED

// Return value to use for sharing configuration conflict

#define HNETERRORSTART          0x200
#define E_ANOTHERADAPTERSHARED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, HNETERRORSTART+1)
#define E_ICSADDRESSCONFLICT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, HNETERRORSTART+2)

// Buffer sizes to use for notifications

#ifndef NOTIFYFORMATBUFFERSIZE
#define NOTIFYFORMATBUFFERSIZE	1024
#endif

#ifndef HNWCALLBACKBUFFERSIZE
#define HNWCALLBACKBUFFERSIZE  1024
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncfgmgr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C F G M G R . H
//
//  Contents:   CHNetCfgMgr declarations
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetCfgMgr :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHNetCfgMgr, &CLSID_HNetCfgMgr>,
    public IHNetCfgMgr,
    public IHNetBridgeSettings,
    public IHNetFirewallSettings,
    public IHNetIcsSettings,
    public IHNetProtocolSettings

{
protected:

    //
    // Connection to \\.\Root\Microsoft\HomeNet WMI namespace. Obtained
    // through IWbemLocator::ConnectServer
    //

    IWbemServices *m_piwsHomenet;

    //
    // Policy check object
    //

    INetConnectionUiUtilities *m_pNetConnUiUtil;

    //
    // Netman update object
    //

    INetConnectionHNetUtil *m_pNetConnHNetUtil;

    //
    // Commonly used BSTRs.
    //

    BSTR m_bstrWQL;

    //
    // Copies an HNet_FirewallLoggingSettings instance to an
    // HNET_FW_LOGGING_SETTINGS struct
    //

    HRESULT
    CopyLoggingInstanceToStruct(
        IWbemClassObject *pwcoInstance,
        HNET_FW_LOGGING_SETTINGS *pfwSettings
        );

    //
    // Copies an HNET_FW_LOGGING_SETTINGS struct to
    // an HNet_FirewallLoggingSettings instance
    //

    HRESULT
    CopyStructToLoggingInstance(
        HNET_FW_LOGGING_SETTINGS *pfwSettings,
        IWbemClassObject *pwcoInstance
        );

    //
    // Installs the bridge protocol and miniport
    //

    HRESULT
    InstallBridge(
        GUID *pguid,
        INetCfg *pnetcfgExisting
        );

    //
    // Creates the appropriate instances for a connection that there is
    // no record of in the store. The returned instances must be commited
    // (through IWbemServices::PutInstance)
    //

    HRESULT
    CreateConnectionAndPropertyInstances(
        GUID *pGuid,
        BOOLEAN fLanConnection,
        LPCWSTR pszwName,
        IWbemClassObject **ppwcoConnection,
        IWbemClassObject **ppwcoProperties
        );

    //
    // Helper routine to perform policy checks. Returns
    // TRUE if this action is prohibited.
    //

    BOOLEAN
    ProhibitedByPolicy(
        DWORD dwPerm
        );

    //
    // Helper routine to update netman that some homenet
    // property changed
    //

    HRESULT
    UpdateNetman();

public:

    BEGIN_COM_MAP(CHNetCfgMgr)
        COM_INTERFACE_ENTRY(IHNetCfgMgr)
        COM_INTERFACE_ENTRY(IHNetBridgeSettings)
        COM_INTERFACE_ENTRY(IHNetFirewallSettings)
        COM_INTERFACE_ENTRY(IHNetIcsSettings)
        COM_INTERFACE_ENTRY(IHNetProtocolSettings)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_HNETCFG)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //

    CHNetCfgMgr()
    {
        m_piwsHomenet = NULL;
        m_bstrWQL = NULL;
        m_pNetConnUiUtil = NULL;
        m_pNetConnHNetUtil = NULL;
    };

    //
    // Atl methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // IHNetCfgMgr methods
    //

    STDMETHODIMP
    GetIHNetConnectionForINetConnection(
        INetConnection *pNetConnection,
        IHNetConnection **ppHNetConnection
        );

    STDMETHODIMP
    GetIHNetConnectionForGuid(
        GUID *pGuid,
        BOOLEAN fLanConnection,
        BOOLEAN fCreateEntries,
        IHNetConnection **ppHNetConnection
        );

    //
    // IHNetBridgeSettings methods
    //

    STDMETHODIMP
    EnumBridges(
        IEnumHNetBridges **ppEnum
        );

    STDMETHODIMP
    CreateBridge(
        IHNetBridge **ppHNetBridge,
        INetCfg *pnetcfgExisting
        );

    STDMETHODIMP
    DestroyAllBridges(
        ULONG *pcBridges,
        INetCfg *pnetcfgExisting
        );

    //
    // IHNetFirewallSettings methods
    //

    STDMETHODIMP
    EnumFirewalledConnections(
        IEnumHNetFirewalledConnections **ppEnum
        );

    STDMETHODIMP
    GetFirewallLoggingSettings(
        HNET_FW_LOGGING_SETTINGS **ppSettings
        );

    STDMETHODIMP
    SetFirewallLoggingSettings(
        HNET_FW_LOGGING_SETTINGS *pSettings
        );

    STDMETHODIMP
    DisableAllFirewalling(
        ULONG *pcFirewalledConnections
        );

    //
    // IHNetIcsSettings methods
    //

    STDMETHODIMP
    EnumIcsPublicConnections(
        IEnumHNetIcsPublicConnections **ppEnum
        );

    STDMETHODIMP
    EnumIcsPrivateConnections(
        IEnumHNetIcsPrivateConnections **ppEnum
        );

    STDMETHODIMP
    DisableIcs(
        ULONG *pcIcsPublicConnections,
        ULONG *pcIcsPrivateConnections
        );

    STDMETHODIMP
    GetPossiblePrivateConnections(
        IHNetConnection *pConn,
        ULONG *pcPrivateConnections,
        IHNetConnection **pprgPrivateConnections[],
        LONG *pxCurrentPrivate
        );

    STDMETHODIMP
    GetAutodialSettings(
        BOOLEAN *pfAutodialEnabled
        );

    STDMETHODIMP
    SetAutodialSettings(
        BOOLEAN fEnableAutodial
        );

    STDMETHODIMP
    GetDhcpEnabled(
        BOOLEAN *pfDhcpEnabled
        );

    STDMETHODIMP
    SetDhcpEnabled(
        BOOLEAN fEnableDhcp
        );

    STDMETHODIMP
    GetDhcpScopeSettings(
        DWORD *pdwScopeAddress,
        DWORD *pdwScopeMask
        );

    STDMETHODIMP
    SetDhcpScopeSettings(
        DWORD dwScopeAddress,
        DWORD dwScopeMask
        );

    STDMETHODIMP
    EnumDhcpReservedAddresses(
        IEnumHNetPortMappingBindings **ppEnum
        );

    STDMETHODIMP
    GetDnsEnabled(
        BOOLEAN *pfDnsEnabled
        );

    STDMETHODIMP
    SetDnsEnabled(
        BOOLEAN fEnableDns
        );

    STDMETHODIMP
    RefreshTargetComputerAddress(
        OLECHAR *pszwName,
        ULONG ulAddress
        );

    //
    // IHNetProtocolSettings methods
    //

    STDMETHODIMP
    EnumApplicationProtocols(
        BOOLEAN fEnabledOnly,
        IEnumHNetApplicationProtocols **ppEnum
        );

    STDMETHODIMP
    CreateApplicationProtocol(
        OLECHAR *pszwName,
        UCHAR ucOutgoingIPProtocol,
        USHORT usOutgoingPort,
        USHORT uscResponses,
        HNET_RESPONSE_RANGE rgResponses[],
        IHNetApplicationProtocol **ppProtocol
        );

    STDMETHODIMP
    EnumPortMappingProtocols(
        IEnumHNetPortMappingProtocols **ppEnum
        );

    STDMETHODIMP
    CreatePortMappingProtocol(
        OLECHAR *pszwName,
        UCHAR ucIPProtocol,
        USHORT usPort,
        IHNetPortMappingProtocol **ppProtocol
        );

    STDMETHODIMP
    FindPortMappingProtocol(
        GUID *pGuid,
        IHNetPortMappingProtocol **ppProtocol
        );
    
};

class CHNetCfgMgrChild : public CHNetCfgMgr
{

protected:

    // Do our initialization work in Initialize() instead of
    // FinalConstruct
    HRESULT
    FinalConstruct()
    {
        // Do nothing
        return S_OK;
    }

public:

    HRESULT
    Initialize(
        IWbemServices       *piwsHomenet
        )
    {
        HRESULT             hr = S_OK;

        //
        // Allocate the commonly used BSTRs
        //

        m_bstrWQL = SysAllocString(c_wszWQL);

        if (NULL == m_bstrWQL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_piwsHomenet = piwsHomenet;
            m_piwsHomenet->AddRef();
        }

        return hr;
    };

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncdbg.h ===
//depot/private/homenet/net/homenet/Config/inc/HNCDbg.h#2 - edit change 5763 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C D B G . H
//
//  Contents:   Home Networking Configuration debug routines
//
//  Notes:
//
//  Author:     jonburs 13 June 2000
//
//----------------------------------------------------------------------------

#pragma once

//
// The standard CRT assertions do bad things such as displaying message boxes.
// These macros will just print stuff out to the debugger. If you do want the
// standard CRT assertions, just define _DEBUG before including this header
//

#ifdef DBG   // checked build
#ifndef _DEBUG // DEBUG_CRT is not enabled.

#undef _ASSERT
#undef _ASSERTE
#define BUF_SIZE 512

#define _ASSERT(expr)                   \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("HNetCfg: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)

#define _ASSERTE(expr)                  \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("HNetCfg: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncaenum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C A E N U M . H
//
//  Contents:   Array enumerator
//
//  Notes:
//
//  Author:     maiken 13 Dec 2000
//
//----------------------------------------------------------------------------

//
// This simple template acts as an enumerator for an array of COM pointers.
//


template<
    class EnumInterface,
    class ItemInterface
    >
class CHNCArrayEnum :
    public CComObjectRootEx<CComMultiThreadModel>,
    public EnumInterface
{
private:
    typedef CHNCArrayEnum<EnumInterface, ItemInterface> _ThisClass;

    //
    // The array of pointers we're holding
    //
    ItemInterface           **m_rgItems;

    //
    // Our position counter
    //
    ULONG                   m_pos;

    //
    // Number of pointers in m_rgItems
    //
    ULONG                   m_numItems;

protected:

    VOID
    SetPos(
        ULONG               pos
        )
    {
        _ASSERT( pos < m_numItems );
        m_pos = pos;
    };

public:

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(EnumInterface)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Object Creation
    //

    CHNCArrayEnum()
    {
        m_rgItems = NULL;
        m_pos = 0L;
        m_numItems = 0L;
    };

    HRESULT
    Initialize(
        ItemInterface       **pItems,
        ULONG               countItems
        )
    {
        HRESULT             hr = S_OK;

        // pItems can be NULL to indicate an enumeration of nothing
        if( NULL != pItems )
        {
            _ASSERT( countItems > 0L );
            m_rgItems = new ItemInterface*[countItems];

            if( NULL == m_rgItems )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                ULONG       i;

                for( i = 0L; i < countItems; i++ )
                {
                    m_rgItems[i] = pItems[i];
                    m_rgItems[i]->AddRef();
                }

                m_numItems = countItems;
            }
        }

        return hr;
    };

    //
    // Object Destruction
    //

    HRESULT
    FinalRelease()
    {
        if( m_rgItems != NULL )
        {
            ULONG           i;

            for( i = 0L; i < m_numItems; i++ )
            {
                m_rgItems[i]->Release();
            }

            delete [] m_rgItems;
        }

        return S_OK;
    };

    //
    // EnumInterface methods
    //

    STDMETHODIMP
    Next(
        ULONG               cElt,
        ItemInterface       **rgElt,
        ULONG               *pcEltFetched
        )

    {
        HRESULT             hr = S_OK;
        ULONG               ulCopied = 0L;

        if (NULL == rgElt)
        {
            hr = E_POINTER;
        }
        else if (0 == cElt)
        {
            hr = E_INVALIDARG;
        }
        else if (1 != cElt && NULL == pcEltFetched)
        {
            hr = E_POINTER;
        }

        if( S_OK == hr )
        {
            ulCopied = 0L;

            // Copy until we run out of items to copy;
            while( (m_pos < m_numItems) && (ulCopied < cElt) )
            {
                rgElt[ulCopied] = m_rgItems[m_pos];
                rgElt[ulCopied]->AddRef();
                m_pos++;
                ulCopied++;
            }

            if( ulCopied == cElt )
            {
                // Copied all the requested items
                hr = S_OK;
            }
            else
            {
                // Copied a subset of the requested items (or none)
                hr = S_FALSE;
            }

            if( pcEltFetched != NULL )
            {
                *pcEltFetched = ulCopied;
            }
        }

        return hr;
    };

    STDMETHODIMP
    Clone(
        EnumInterface **ppEnum
        )

    {
        HRESULT                     hr = S_OK;

        if (NULL == ppEnum)
        {
            hr = E_POINTER;
        }
        else
        {
            CComObject<_ThisClass>      *pNewEnum;

            //
            // Create an initialized, new instance of ourselves
            //

            hr = CComObject<_ThisClass>::CreateInstance(&pNewEnum);

            if (SUCCEEDED(hr))
            {
                pNewEnum->AddRef();

                hr = pNewEnum->Initialize(m_rgItems, m_numItems);

                if (SUCCEEDED(hr))
                {
                    pNewEnum->SetPos( m_pos );

                    hr = pNewEnum->QueryInterface(
                            IID_PPV_ARG(EnumInterface, ppEnum)
                            );

                    //
                    // This QI should never fail, unless we were given
                    // bogus template arguments.
                    //

                    _ASSERT(SUCCEEDED(hr));
                }

                pNewEnum->Release();
            }
        }

        return hr;
    };

    //
    // Skip and Reset simply delegate to the contained enumeration.
    //

    STDMETHODIMP
    Reset()

    {
        m_pos = 0L;;
        return S_OK;
    };

    STDMETHODIMP
    Skip(
        ULONG cElt
        )

    {
        HRESULT         hr;

        if( m_pos + cElt < m_numItems )
        {
            m_pos += cElt;
            hr = S_OK;
        }
        else
        {
            m_pos = m_numItems - 1;
            hr = S_FALSE;
        }

        return hr;
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N M R E S . H
//
//  Contents:   Master resource header for HNetCfg
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
#define IDS_SECURITYNOTIFICATIONTEXT		22000
#define IDS_SECURITYNOTIFICATIONTITLE		22001

#define IDS_SHARINGCONFIGURATIONUNAVAIL     22002
#define IDS_DISABLEFIREWALLFAIL             22003
#define IDS_DESTROYBRIDGEFAIL               22004
#define IDS_DISABLEICS                      22005
#define IDS_NEWBRIDGECREATED                22006
#define IDS_NEWBRIDGEFAILED                 22007
#define IDS_NEWPRIVATECONNECTIONCREATED     22008                  
#define IDS_NEWPRIVATECONNECTIONFAILED      22009
#define IDS_SHARINGCFGFORADAPTERUNAVAIL     22010
#define IDS_NEWPUBLICCONNECTIONCREATED      22011
#define IDS_NEWPUBLICCONNECTIONFAILED       22012
#define IDS_FIREWALLCONNECTION				22013
#define IDS_FIREWALLCONNECTIONFAILED		22014
#define IDS_WSAERRORDURINGDETECTION			22015
#define IDS_SENDARPERRORDURINGDETECTION     22016
#define IDS_ICSADDRESSCONFLICTDETECTED      22017
#define IDS_ADD_REMOVE                      22018
#define IDS_REMOVE_ALG_PLUGIN               22019

//+---------------------------------------------------------------------------
// Dialog ID's
//

#define IDD_SecurityNotification			22500


//+---------------------------------------------------------------------------
// Control ID's
//

#define IDC_TXT_NOTIFICATION				22600
#define IDC_BTN_MOREINFO					22601
#define IDC_CHK_DISABLESHARESECURITYWARN	22602

//+---------------------------------------------------------------------------
// Registry resources
//	 

#define IDR_HNETCFG     100
#define IDR_HNETMOF     101
#define IDR_SHAREMGR    102
#define IDR_UPNPNAT     103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnbridge.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R I D G E . H
//
//  Contents:   CHNBridge declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNBridge :
    public CHNetConn,
    public IHNetBridge
{
private:

    HRESULT
    BindNewAdapter(
        IN GUID                 *pguid,
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );

    HRESULT
    RemoveMiniport(
        IN OPTIONAL INetCfg     *pnetcfgExisting
        );

public:

    BEGIN_COM_MAP(CHNBridge)
        COM_INTERFACE_ENTRY(IHNetBridge)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    //
    // IHNetBridge Methods
    //

    STDMETHODIMP
    EnumMembers(
        IEnumHNetBridgedConnections **ppEnum
        );

    STDMETHODIMP
    AddMember(
        IHNetConnection *pConn,
        IHNetBridgedConnection **ppBridgedConn,
        INetCfg *pnetcfgExisting
        );

    STDMETHODIMP
    Destroy(
        INetCfg *pnetcfgExisting
        );
};

typedef CHNCArrayEnum<IEnumHNetBridges, IHNetBridge>    CEnumHNetBridges;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C U T I L . H
//
//  Contents:   Home Networking Configuration Utility Routines
//
//  Notes:
//
//  Author:     jonburs 13 June 2000
//
//----------------------------------------------------------------------------

#define HTONS(s) ((UCHAR)((s) >> 8) | ((UCHAR)(s) << 8))
#define HTONL(l) ((HTONS(l) << 16) | HTONS((l) >> 16))
#define NTOHS(s) HTONS(s)
#define NTOHL(l) HTONL(l)

BOOLEAN
ApplicationProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usOutgoingPort,
    UCHAR ucOutgoingIPProtocol
    );

HRESULT
HrFromLastWin32Error();

HRESULT
BuildAndString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildAssociatorsQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszAssocClass
    );

HRESULT
BuildEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildEscapedQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildQuotedEqualsString(
    LPWSTR *ppwsz,
    LPCWSTR pwszLeft,
    LPCWSTR pwszRight
    );

HRESULT
BuildReferencesQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszObjectPath,
    LPCWSTR pwszTargetClass
    );

HRESULT
BuildSelectQueryBstr(
    BSTR *pBstr,
    LPCWSTR pwszProperties,
    LPCWSTR pwszFromClause,
    LPCWSTR pwszWhereClause
    );

BOOLEAN
ConnectionIsBoundToTcp(
    PIP_INTERFACE_INFO pIpInfoTable,
    GUID *pConnectionGuid
    );

HRESULT
ConvertResponseRangeArrayToInstanceSafearray(
    IWbemServices *piwsNamespace,
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponses[],
    SAFEARRAY **ppsa
    );

HRESULT
CopyResponseInstanceToStruct(
    IWbemClassObject *pwcoInstance,
    HNET_RESPONSE_RANGE *pResponse
    );

HRESULT
CopyStructToResponseInstance(
    HNET_RESPONSE_RANGE *pResponse,
    IWbemClassObject *pwcoInstance
    );

HRESULT
DeleteWmiInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    );

LPWSTR
EscapeString(
    LPCWSTR wsz
    );

HRESULT
InitializeNetCfgForWrite(
    OUT INetCfg             **ppnetcfg,
    OUT INetCfgLock         **ppncfglock
    );

void
UninitializeNetCfgForWrite(
    IN INetCfg              *pnetcfg,
    IN INetCfgLock          *pncfglock
    );

HRESULT
FindAdapterByGUID(
    IN INetCfg              *pnetcfg,
    IN GUID                 *pguid,
    OUT INetCfgComponent    **ppncfgcomp
    );

HRESULT
BindOnlyToBridge(
    IN INetCfgComponent     *pnetcfgcomp
    );

HRESULT
FindINetConnectionByGuid(
    GUID *pGuid,
    INetConnection **ppNetCon
    );

HRESULT
GetBridgeConnection(
    IN IWbemServices        *piwsHomenet,
    OUT IHNetBridge        **pphnetBridge
    );

HRESULT
GetIHNetConnectionForNetCfgComponent(
    IN IWbemServices        *piwsHomenet,
    IN INetCfgComponent     *pnetcfgcomp,
    IN BOOLEAN               fLanConnection,
    IN REFIID                iid,
    OUT PVOID               *ppv
    );

HRESULT
GetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN *pfBoolean
    );

HRESULT
GetConnectionInstanceByGuid(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection
    );

HRESULT
GetConnAndPropInstancesByGuid(
    IWbemServices *piwsNamespace,
    GUID *pGuid,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    );

HRESULT
GetConnAndPropInstancesForHNC(
    IWbemServices *piwsNamespace,
    IHNetConnection *pConn,
    IWbemClassObject **ppwcoConnection,
    IWbemClassObject **ppwcoProperties
    );

HRESULT
GetPhonebookPathFromRasNetcon(
    INetConnection *pConn,
    LPWSTR *ppwstr
    );

HRESULT
GetPortMappingBindingInstance(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    BSTR bstrConnectionPath,
    BSTR bstrProtocolPath,
    USHORT usPublicPort,
    IWbemClassObject **ppInstance
    );

HRESULT
GetPropInstanceFromConnInstance(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection,
    IWbemClassObject **ppwcoProperties
    );

HRESULT
GetWmiObjectFromPath(
    IWbemServices *piwsNamespace,
    BSTR bstrPath,
    IWbemClassObject **pwcoInstance
    );

HRESULT
GetWmiPathFromObject(
    IWbemClassObject *pwcoInstance,
    BSTR *pbstrPath
    );

HRESULT
MapGuidStringToAdapterIndex(
    LPCWSTR pwszGuid,
    ULONG *pulIndex
    );

HRESULT
HostAddrToIpPsz(
    DWORD   dwIPAddress,
    LPWSTR* ppszwNewStr
    );

DWORD
IpPszToHostAddr(
    LPCWSTR cp
    );

BOOLEAN
IsRrasConfigured();

BOOLEAN
IsServiceRunning(
    LPCWSTR pwszServiceName
    );

HRESULT
OpenRegKey(
    PHANDLE Key,
    ACCESS_MASK DesiredAccess,
    PCWSTR Name
    );

BOOLEAN
PortMappingProtocolExists(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    USHORT usPort,
    UCHAR ucIPProtocol
    );

HRESULT
QueryRegValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    );

HRESULT
ReadDhcpScopeSettings(
    DWORD *pdwScopeAddress,
    DWORD *pdwScopeMask
    );

HRESULT
RetrieveSingleInstance(
    IWbemServices *piwsNamespace,
    const OLECHAR *pwszClass,
    BOOLEAN fCreate,
    IWbemClassObject **ppwcoInstance
    );

HRESULT
SetBooleanValue(
    IWbemClassObject *pwcoInstance,
    LPCWSTR pwszProperty,
    BOOLEAN fBoolean
    );

VOID
SetProxyBlanket(
    IUnknown *pUnk
    );

HRESULT
SpawnNewInstance(
    IWbemServices *piwsNamespace,
    LPCWSTR wszClass,
    IWbemClassObject **ppwcoInstance
    );

DWORD
StartOrUpdateService(
    VOID
    );

VOID
StopService(
    VOID
    );

HRESULT
UpdateOrStopService(
    IWbemServices *piwsNamespace,
    BSTR bstrWQL,
    DWORD dwControlCode
    );

VOID
UpdateService(
    DWORD dwControlCode
    );

VOID
ValidateFinishedWCOEnum(
    IWbemServices *piwsNamespace,
    IEnumWbemClassObject *pwcoEnum
    );

HRESULT
SendPortMappingListChangeNotification();

HRESULT
SignalModifiedConnection(
    GUID            *pGUID
    );

HRESULT
SignalNewConnection(
    GUID            *pGUID
    );

HRESULT
SignalDeletedConnection(
    GUID            *pGUID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnfwconn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N F W C O N N . H
//
//  Contents:   CHNFWConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNFWConn :
    public CHNetConn,
    public IHNetFirewalledConnection
{       
public:

    BEGIN_COM_MAP(CHNFWConn)
        COM_INTERFACE_ENTRY(IHNetFirewalledConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // IHNetFirewalledConnection methods
    //

    STDMETHODIMP
    Unfirewall();
};

typedef CHNCEnum<
            IEnumHNetFirewalledConnections,
            IHNetFirewalledConnection,
            CHNFWConn
            >
        CEnumHNetFirewalledConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnetconn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N E T C O N N. H
//
//  Contents:   CHNetConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetConn :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetConnection
{
protected:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to the WMI instance for the connection
    //

    BSTR m_bstrConnection;

    //
    // Path to the WMI instance for the connection properties
    //

    BSTR m_bstrProperties;  

    //
    // Pointer to our corresponding INetConnection. May
    // be null, depending on how we were created.
    //
    
    INetConnection *m_pNetConn;

    //
    // Cached connection type. Always valid and read-only
    // after construction
    //

    BOOLEAN m_fLanConnection;

    //
    // Cached GUID. Will be NULL until someone (possibly internal)
    // asks for our GUID.
    //

    GUID *m_pGuid;

    //
    // Cached connection name. Will be NULL until someone
    // asks for our name
    //

    LPWSTR m_wszName;

    //
    // Commonly used BSTR
    //

    BSTR m_bstrWQL;

    //
    // Policy check helper object
    //

    INetConnectionUiUtilities *m_pNetConnUiUtil;

    //
    // Netman update object
    //

    INetConnectionHNetUtil *m_pNetConnHNetUtil;

    //
    // Netman UI refresh object
    //

    INetConnectionRefresh *m_pNetConnRefresh;

    //
    // Retrieves the HNet_FwIcmpSettings associated with
    // this connection
    //
    
    HRESULT
    GetIcmpSettingsInstance(
        IWbemClassObject **ppwcoSettings
        );

    //
    // Copies from an IWbemClassObject representing an ICMP settings
    // instance to an HNET_FW_ICMP_SETTINGS structure
    //

    HRESULT
    CopyIcmpSettingsInstanceToStruct(
        IWbemClassObject *pwcoSettings,
        HNET_FW_ICMP_SETTINGS *pSettings
        );

    //
    // Copies from an HNET_FW_ICMP_SETTINGS structure to
    // an IWbemClassObject representing an ICMP settings
    // instance.
    //

    HRESULT
    CopyStructToIcmpSettingsInstance(
        HNET_FW_ICMP_SETTINGS *pSettings,
        IWbemClassObject *pwcoSettings
        );

    //
    // Ensures that all port mapping bindings have been created
    // for this connection. Called when EnumPortMappings is
    // called on the connection, and fEnabledOnly is false.
    //

    HRESULT
    CreatePortMappingBindings();

    //
    // Copies our property instance into an allocated structure
    //

    HRESULT
    InternalGetProperties(
        IWbemClassObject *pwcoProperties,
        HNET_CONN_PROPERTIES *pProperties
        );

    //
    // Configures the connection to be the private adapter
    //

    HRESULT
    SetupConnectionAsPrivateLan();

    //
    // Saves the current IP configuration into the store
    //

    HRESULT
    BackupIpConfiguration();

    //
    // Set's the IP configuration to what was saved in the store
    //

    HRESULT
    RestoreIpConfiguration();

    //
    // Open a registry key to our IP settings
    //

    HRESULT
    OpenIpConfigurationRegKey(
        ACCESS_MASK DesiredAccess,
        HANDLE *phKey
        );

    //
    // Retrieves our GUID. The caller must NOT free the pointer
    // that is returned.
    
    HRESULT
    GetGuidInternal(
        GUID **ppGuid
        );

    //
    // Retrieves the underlying connection object
    //

    HRESULT
    GetConnectionObject(
        IWbemClassObject **ppwcoConnection
        );

    //
    // Retrieves the underlying connection properties object
    //

    HRESULT
    GetConnectionPropertiesObject(
        IWbemClassObject **ppwcoProperties
        );

    //
    // Helper routine to perform policy checks. Returns
    // TRUE if this action is prohibited.
    //

    BOOLEAN
    ProhibitedByPolicy(
        DWORD dwPerm
        );

    //
    // Helper routine to update netman that some homenet
    // property changed
    //

    HRESULT
    UpdateNetman();

    //
    // Creates the association between the connection and the
    // ICMP settings block
    //

    HRESULT
    CreateIcmpSettingsAssociation(
        BSTR bstrIcmpSettingsPath
        );

    //
    // Obtains the name of a RAS connection from the
    // appropriate phonebook.
    //

    HRESULT
    GetRasConnectionName(
        OLECHAR **ppszwConnectionName
        );

    //
    // Helper routine to inform netman that a change requiring
    // a UI refresh has occured.
    //

    HRESULT
    RefreshNetConnectionsUI(
        VOID
        );


public:

    BEGIN_COM_MAP(CHNetConn)
        COM_INTERFACE_ENTRY(IHNetConnection)
    END_COM_MAP()

    //
    // Inline constructor
    //

    CHNetConn()
    {
        m_piwsHomenet = NULL;
        m_bstrConnection = NULL;
        m_bstrProperties = NULL;
        m_pNetConn = NULL;
        m_fLanConnection = FALSE;
        m_pGuid = NULL;
        m_wszName = NULL;
        m_bstrWQL = NULL;
        m_pNetConnUiUtil = NULL;
        m_pNetConnHNetUtil = NULL;
        m_pNetConnRefresh = NULL;
    };

    //
    // ATL Methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Ojbect initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoProperties
        );

    HRESULT
    InitializeFromConnection(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoConnection
        );

    HRESULT
    InitializeFromInstances(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoConnection,
        IWbemClassObject *pwcoProperties
        );

    HRESULT
    InitializeFull(
        IWbemServices *piwsNamespace,
        BSTR bstrConnection,
        BSTR bstrProperties,
        BOOLEAN fLanConnection
        );

    HRESULT
    SetINetConnection(
        INetConnection *pConn
        );

    //
    // IHNetConnection methods
    //

    STDMETHODIMP
    GetINetConnection(
        INetConnection **ppNetConnection
        );

    STDMETHODIMP
    GetGuid(
        GUID **ppGuid
        );

    STDMETHODIMP
    GetName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    GetRasPhonebookPath(
        OLECHAR **ppszwPath
        );

    STDMETHODIMP
    GetProperties(
        HNET_CONN_PROPERTIES **ppProperties
        );

    STDMETHODIMP
    GetControlInterface(
        REFIID iid,
        void **ppv
        );

    STDMETHODIMP
    Firewall(
        IHNetFirewalledConnection **ppFirewalledConn
        );

    STDMETHODIMP
    SharePublic(
        IHNetIcsPublicConnection **ppIcsPublicConn
        );

    STDMETHODIMP
    SharePrivate(
        IHNetIcsPrivateConnection **ppIcsPrivateConn
        );

    STDMETHODIMP
    EnumPortMappings(
        BOOLEAN fEnabledOnly,
        IEnumHNetPortMappingBindings **ppEnum
        );

    STDMETHODIMP
    GetBindingForPortMappingProtocol(
        IHNetPortMappingProtocol *pProtocol,
        IHNetPortMappingBinding **ppBinding
        );

    STDMETHODIMP
    GetIcmpSettings(
        HNET_FW_ICMP_SETTINGS **ppSettings
        );

    STDMETHODIMP
    SetIcmpSettings(
        HNET_FW_ICMP_SETTINGS *pSettings
        );

    STDMETHODIMP
    ShowAutoconfigBalloon(
        BOOLEAN *pfShowBalloon
        );

    STDMETHODIMP
    DeleteRasConnectionEntry();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncenum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C E N U M . H
//
//  Contents:   Generic WMI enumerator template
//
//  Notes:
//
//  Author:     jonburs 20 June 2000
//
//----------------------------------------------------------------------------

template<
    class EnumInterface,
    class ItemInterface,
    class WrapperClass
    >
class CHNCEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public EnumInterface
{
private:
    typedef CHNCEnum<EnumInterface, ItemInterface, WrapperClass> _ThisClass;

    //
    // The IEnumWbemClassObject we're wrapping
    //

    IEnumWbemClassObject *m_pwcoEnum;

    //
    // The IWbemServices for our namespace
    //

    IWbemServices *m_pwsNamespace;

public:

    BEGIN_COM_MAP(_ThisClass)
        COM_INTERFACE_ENTRY(EnumInterface)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Object Creation
    //

    CHNCEnum()
    {
        m_pwcoEnum = NULL;
        m_pwsNamespace = NULL;
    };

    HRESULT
    Initialize(
        IWbemServices *pwsNamespace,
        IEnumWbemClassObject *pwcoEnum
        )
    {
        _ASSERT(NULL == m_pwsNamespace);
        _ASSERT(NULL == m_pwcoEnum);
        _ASSERT(NULL != pwsNamespace);
        _ASSERT(NULL != pwcoEnum);

        m_pwcoEnum = pwcoEnum;
        m_pwcoEnum->AddRef();
        m_pwsNamespace = pwsNamespace;
        m_pwsNamespace->AddRef();

        return S_OK;
    };

    //
    // Object Destruction
    //

    HRESULT
    FinalRelease()
    {
        if (NULL != m_pwcoEnum)
        {
            m_pwcoEnum->Release();
        }

        if (NULL != m_pwsNamespace)
        {
            m_pwsNamespace->Release();
        }

        return S_OK;
    };

    //
    // EnumInterface methods
    //
    
    STDMETHODIMP
    Next(
        ULONG cElt,
        ItemInterface **rgElt,
        ULONG *pcEltFetched
        )
        
    {
        HRESULT hr = S_OK;
        ULONG cInstancesFetched = 0;
        IWbemClassObject **rgpwcoInstances = NULL;
        CComObject<WrapperClass> *pWrapper = NULL;
        LONG i;

        _ASSERT(NULL != m_pwcoEnum);

        if (NULL == rgElt)
        {
            hr = E_POINTER;
        }
        else if (0 == cElt)
        {
            hr = E_INVALIDARG;
        }
        else if (1 != cElt && NULL == pcEltFetched)
        {
            hr = E_POINTER;
        }

        if (S_OK == hr)
        {
            //
            // Zero the output array
            //

            ZeroMemory(rgElt, cElt * sizeof(ItemInterface*));
            
            //
            // Allocate enough memory to hold pointers to the instances we
            // were asked to fetch.
            //

            rgpwcoInstances = new IWbemClassObject*[cElt];
            if (NULL != rgpwcoInstances)
            {
                ZeroMemory(rgpwcoInstances, sizeof(IWbemClassObject*) * cElt);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            //
            // Grab the requested number of instances from the contained
            // WMI enumeration.
            //

            hr = m_pwcoEnum->Next(
                    WBEM_INFINITE,
                    cElt,
                    rgpwcoInstances,
                    &cInstancesFetched
                    );
        }

        if (SUCCEEDED(hr))
        {
            //
            // For each instance we retrieved, create the wrapper
            // object.
            //

            for (i = 0;
                 static_cast<ULONG>(i) < cInstancesFetched;
                 i++)
            {
                hr = CComObject<WrapperClass>::CreateInstance(&pWrapper);

                if (SUCCEEDED(hr))
                {
                    pWrapper->AddRef();
                    hr = pWrapper->Initialize(
                            m_pwsNamespace,
                            rgpwcoInstances[i]
                            );
                
                    if (SUCCEEDED(hr))
                    {
                        //
                        // QI for the desired interface, and place into
                        // the output array
                        //

                        hr = pWrapper->QueryInterface(
                                IID_PPV_ARG(ItemInterface, &rgElt[i])
                                );

                        //
                        // This can only fail if we were given incorrect
                        // template arguments.
                        //
                        
                        _ASSERT(SUCCEEDED(hr));
                    }

                    pWrapper->Release();
                }

                if (FAILED(hr))
                {
                    break;
                }
            }

            if (FAILED(hr))
            {
                //
                // Something went wrong, and we destroy all of the objects
                // we just created and QI'd. (The position of the last object
                // created is one less than the current value of i.)
                //

                for (i-- ; i >= 0; i--)
                {
                    if (NULL != rgElt[i])
                    {
                        rgElt[i]->Release();
                    }
                }
            }

            //
            // Release all of the instances we retrieved
            //

            for (ULONG j = 0; j < cInstancesFetched; j++)
            {
                if (NULL != rgpwcoInstances[j])
                {
                    rgpwcoInstances[j]->Release();
                }
            }
        }

        //
        // If necessary, release the memory we used to hold the
        // instance pointers.
        //

        if (NULL != rgpwcoInstances)
        {
            delete [] rgpwcoInstances;
        }

        if (SUCCEEDED(hr))
        {
            //
            // Set the number of items we retrieved
            //

            if (NULL != pcEltFetched)
            {
                *pcEltFetched = cInstancesFetched;
            }

            //
            // Normalize return value
            //

            if (cInstancesFetched == cElt)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }

        return hr;
    };

    STDMETHODIMP
    Clone(
        EnumInterface **ppEnum
        )

    {
        HRESULT hr = S_OK;
        IEnumWbemClassObject *pwcoClonedEnum;
        CComObject<_ThisClass> *pNewEnum;

        if (NULL == ppEnum)
        {
            hr = E_POINTER;
        }
        else
        {
            //
            // Attempt to clone the embedded enumeration.
            //

            pwcoClonedEnum = NULL;
            hr = m_pwcoEnum->Clone(&pwcoClonedEnum);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Create an initialized a new instance of ourselves
            //

            hr = CComObject<_ThisClass>::CreateInstance(&pNewEnum);
            if (SUCCEEDED(hr))
            {
                pNewEnum->AddRef();
                hr = pNewEnum->Initialize(m_pwsNamespace, pwcoClonedEnum);

                if (SUCCEEDED(hr))
                {
                    hr = pNewEnum->QueryInterface(
                            IID_PPV_ARG(EnumInterface, ppEnum)
                            );

                    //
                    // This QI should never fail, unless we were given
                    // bogus template arguments.
                    //
                    
                    _ASSERT(SUCCEEDED(hr));
                }

                pNewEnum->Release();
            }

            //
            // Release the cloned enum. New enum object will have
            // AddReffed it...
            //

            pwcoClonedEnum->Release();
        }

        return hr;
    };

    //
    // Skip and Reset simply delegate to the contained enumeration.
    //

    STDMETHODIMP
    Reset()
    
    {
        _ASSERT(NULL != m_pwcoEnum);
        return m_pwcoEnum->Reset();
    };

    STDMETHODIMP
    Skip(
        ULONG cElt
        )
        
    {
        _ASSERT(NULL != m_pwcoEnum);
        return m_pwcoEnum->Skip(WBEM_INFINITE, cElt);
    };   
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnicspub.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P U B . H
//
//  Contents:   CHNIcsPublicConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNIcsPublicConn :
    public IHNetIcsPublicConnection,
    public CHNetConn
{
public:

    BEGIN_COM_MAP(CHNIcsPublicConn)
        COM_INTERFACE_ENTRY(IHNetIcsPublicConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // IHNetIcsPublicConnection methods
    //

    STDMETHODIMP
    Unshare();
};

typedef CHNCEnum<
            IEnumHNetIcsPublicConnections,
            IHNetIcsPublicConnection,
            CHNIcsPublicConn
            >
        CEnumHNetIcsPublicConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hncstrs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C S T R S . H
//
//  Contents:   extern constant string declarations
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#pragma once

extern const OLECHAR c_wszNamespace[];
extern const OLECHAR c_wszWQL[];
extern const OLECHAR c_wszStar[];
extern const OLECHAR c_wszHnetConnection[];
extern const OLECHAR c_wszHnetProperties[];
extern const OLECHAR c_wszHnetApplicationProtocol[];
extern const OLECHAR c_wszHnetPortMappingProtocol[];
extern const OLECHAR c_wszHnetConnectionPortMapping[];
extern const OLECHAR c_wszHnetFWLoggingSettings[];
extern const OLECHAR c_wszHnetIcsSettings[];
extern const OLECHAR c_wszHnetResponseRange[];
extern const OLECHAR c_wszPath[];
extern const OLECHAR c_wszMaxFileSize[];
extern const OLECHAR c_wszLogDroppedPackets[];
extern const OLECHAR c_wszLogConnections[];
extern const OLECHAR c_wszDhcpEnabled[];
extern const OLECHAR c_wszDnsEnabled[];

extern const OLECHAR c_wszName[];
extern const OLECHAR c_wszDeviceName[];
extern const OLECHAR c_wszEnabled[];
extern const OLECHAR c_wszBuiltIn[];
extern const OLECHAR c_wszOutgoingIPProtocol[];
extern const OLECHAR c_wszOutgoingPort[];
extern const OLECHAR c_wszResponseCount[];
extern const OLECHAR c_wszResponseArray[];
extern const OLECHAR c_wszIPProtocol[];
extern const OLECHAR c_wszStartPort[];
extern const OLECHAR c_wszEndPort[];
extern const OLECHAR c_wszPort[];
extern const OLECHAR c_wszId[];

extern const OLECHAR c_wszConnection[];
extern const OLECHAR c_wszProtocol[];
extern const OLECHAR c_wszTargetName[];
extern const OLECHAR c_wszTargetIPAddress[];
extern const OLECHAR c_wszTargetPort[];
extern const OLECHAR c_wszNameActive[];

extern const OLECHAR c_wszIsLanConnection[];
extern const OLECHAR c_wszIsFirewalled[];
extern const OLECHAR c_wszIsIcsPublic[];
extern const OLECHAR c_wszIsIcsPrivate[];
extern const OLECHAR c_wszIsBridgeMember[];
extern const OLECHAR c_wszIsBridge[];
extern const OLECHAR c_wszPhonebookPath[];
extern const OLECHAR c_wszGuid[];

extern const OLECHAR c_wszHnetFwIcmpSettings[];
extern const OLECHAR c_wszAllowOutboundDestinationUnreachable[];
extern const OLECHAR c_wszAllowOutboundSourceQuench[];
extern const OLECHAR c_wszAllowRedirect[];
extern const OLECHAR c_wszAllowInboundEchoRequest[];
extern const OLECHAR c_wszAllowInboundRouterRequest[];
extern const OLECHAR c_wszAllowOutboundTimeExceeded[];
extern const OLECHAR c_wszAllowOutboundParameterProblem[];
extern const OLECHAR c_wszAllowInboundTimestampRequest[];
extern const OLECHAR c_wszAllowInboundMaskRequest[];
extern const OLECHAR c_wszDefault[];
extern const OLECHAR c_wszDefaultIcmpSettingsPath[];

extern const OLECHAR c_wszHnetConnectionIcmpSetting[];
extern const OLECHAR c_wszIcmpSettings[];

extern const OLECHAR c_wszHnetBridgeMember[];
extern const OLECHAR c_wszBridge[];
extern const OLECHAR c_wszMember[];

extern const OLECHAR c_wszSelect[];
extern const OLECHAR c_wszFrom[];
extern const OLECHAR c_wszWhere[];
extern const OLECHAR c_wsz__Path[];
extern const OLECHAR c_wszReferencesOf[];
extern const OLECHAR c_wszWhereResultClass[];
extern const OLECHAR c_wszAssociatorsOf[];
extern const OLECHAR c_wszWhereAssocClass[];

extern const OLECHAR c_wszPortMappingProtocolQueryFormat[];
extern const OLECHAR c_wszApplicationProtocolQueryFormat[];
extern const OLECHAR c_wszConnectionPropertiesPathFormat[];

extern const OLECHAR c_wszBackupIpConfiguration[];
extern const OLECHAR c_wszEnableDHCP[];
extern const OLECHAR c_wszInterfaces[];
extern const OLECHAR c_wszIPAddress[];
extern const OLECHAR c_wszSubnetMask[];
extern const OLECHAR c_wszDefaultGateway[];
extern const OLECHAR c_wszTcpipParametersKey[];
extern const OLECHAR c_wszZeroIpAddress[];

extern const OLECHAR c_wszSharedAccess[];
extern const OLECHAR c_wszDevice[];
extern const OLECHAR c_wszServiceCheckQuery[];

extern const OLECHAR c_wszHnetConnectionAutoconfig[];

extern const OLECHAR c_wszIcsUpgradeEventName[];

//
// Commonly used string lengths. Generating these at compile time
// saves us a large number of wcslen calls. On debug builds, these
// values are compared with the output of wcslen, and an assertion is
// raised if the values do not match.
//

extern const ULONG c_cchSelect;
extern const ULONG c_cchFrom;
extern const ULONG c_cchWhere;
extern const ULONG c_cchReferencesOf;
extern const ULONG c_cchWhereResultClass;
extern const ULONG c_cchAssociatorsOf;
extern const ULONG c_cchWhereAssocClass;
extern const ULONG c_cchConnection;
extern const ULONG c_cchConnectionPropertiesPathFormat;

//
// Bindings-related strings
//

extern const WCHAR c_wszSBridgeMPID[];
extern const WCHAR c_wszSBridgeSID[];
extern const WCHAR *c_pwszBridgeBindExceptions[];

extern const WCHAR c_wszRrasConfigurationPath[];
extern const WCHAR c_wszRrasConfigurationValue[];

extern const TCHAR c_szEnableFirewall[];
extern const TCHAR c_szYes[];
extern const TCHAR c_szNo[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\natutils.h ===
#ifndef __UPNPNAT_UTILS_H_
#define __UPNPNAT_UTILS_H_

#include <upnp.h>

HRESULT GetNumberOfEntries (IUPnPService * pUS, ULONG * pul);
HRESULT GetExternalIPAddress (IUPnPService * pUS, BSTR * pbstr);

HRESULT InvokeAction      (IUPnPService * pUPS, CComBSTR & bstrActionName, VARIANT pvIn, VARIANT * pvOut, VARIANT * pvRet);
HRESULT AddPortMapping    (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, long lInternalPort, BSTR bstrInternalClient, VARIANT_BOOL vbEnabled, BSTR bstrDescription, long lLeaseDurationDesired);
HRESULT DeletePortMapping (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol);

HRESULT GetOnlyVariantElementFromVariantSafeArray (VARIANT * pvSA, VARIANT * pv);
HRESULT AddToSafeArray (SAFEARRAY * psa, VARIANT * pv, long lIndex);
HRESULT GetBSTRFromSafeArray (SAFEARRAY * psa, BSTR * pbstr, long lIndex);
HRESULT GetLongFromSafeArray (SAFEARRAY * psa, long * pl, long lIndex);
HRESULT GetBoolFromSafeArray (SAFEARRAY * psa, VARIANT_BOOL  * pvb, long lIndex);

NETCON_MEDIATYPE GetMediaType (INetConnection * pNC);

//HRESULT GetOnlyChildDevice (IUPnPDevice * pParent, IUPnPDevice ** ppChild);
//HRESULT FindDeviceByType (IUPnPDevices * pUPDs, BSTR bstrType, IUPnPDevice ** ppUPD);

#endif //__UPNPNAT_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\natem.h ===
// NATEM.h : Declaration of the CNATDynamicPortMappingService

#ifndef __NATEVENTMANAGER_H_
#define __NATEVENTMANAGER_H_

#include <upnp.h>
#include <upnpp.h>
#include <netcon.h>

#include <list>

/////////////////////////////////////////////////////////////////////////////
// CNATEventManager
class ATL_NO_VTABLE CNATEventManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CNATEventManager, &CLSID_NATEventManager>,
	public IDispatchImpl<INATEventManager, &IID_INATEventManager, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IUPnPServiceCallbackPrivate> m_spUPSCP;
   std::list<DWORD> m_listOfCookies;

public:
	CNATEventManager()
	{
	}
  ~CNATEventManager()
   {
      // run through list of cookies and remove each callback
      std::list<DWORD>::iterator iterCookies = m_listOfCookies.begin();
      for (DWORD dwCookie = *iterCookies;
           iterCookies != m_listOfCookies.end();
           dwCookie = *++iterCookies) {
         HRESULT hr = m_spUPSCP->RemoveTransientCallback (dwCookie);
         _ASSERT (hr == S_OK);
      }
      m_listOfCookies.clear();
   }

//DECLARE_REGISTRY_RESOURCEID(IDR_NATEVENTMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATEventManager)
	COM_INTERFACE_ENTRY(INATEventManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// INATEventManager
public:
   STDMETHOD(put_ExternalIPAddressCallback)(/*[in]*/ IUnknown * pUnk);
   STDMETHOD(put_NumberOfEntriesCallback)(/*[in]*/ IUnknown * pUnk);

// CNATEventManager
public:
   HRESULT Initialize (IUPnPService * pUPS)
   {
       if (!pUPS)
           return E_INVALIDARG;
   
       _ASSERT (m_spUPSCP == NULL);
       return pUPS->QueryInterface (__uuidof(IUPnPServiceCallbackPrivate),
                                    (void**)&m_spUPSCP);
   }
   HRESULT AddTransientCallback (IUnknown * punk)
   {
      DWORD dwCookie = 0;
      HRESULT hr = m_spUPSCP->AddTransientCallback (punk, &dwCookie);
      if (SUCCEEDED(hr)) {
         // add cookie to list
         m_listOfCookies.push_back (dwCookie);
      }
      return hr;
   }
};

class ATL_NO_VTABLE CExternalIPAddressCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPServiceCallback
{
private:
   CComPtr<IUnknown> m_spUnk;

public:
    BEGIN_COM_MAP(CExternalIPAddressCallback)
        COM_INTERFACE_ENTRY(IUPnPServiceCallback)
    END_COM_MAP()

// IUPnPServiceCallback
public:
    STDMETHODIMP StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue);
    STDMETHODIMP ServiceInstanceDied(IUPnPService *pus);

// CExternalIPAddressCallback
public:
   HRESULT Initialize (IUnknown * punk)
   { 
      _ASSERT (m_spUnk == NULL);
      m_spUnk = punk;
      return S_OK;
   }
};

class ATL_NO_VTABLE CNumberOfEntriesCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPServiceCallback
{
private:
   CComPtr<IUnknown> m_spUnk;

public:
    BEGIN_COM_MAP(CNumberOfEntriesCallback)
        COM_INTERFACE_ENTRY(IUPnPServiceCallback)
    END_COM_MAP()

// IUPnPServiceCallback
public:
    STDMETHODIMP StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue);
    STDMETHODIMP ServiceInstanceDied(IUPnPService *pus);

// CNumberOfEntriesCallback
public:
   HRESULT Initialize (IUnknown * punk)
   { 
      _ASSERT (m_spUnk == NULL);
      m_spUnk = punk;
      return S_OK;
   }
};


#endif //__NATEVENTMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnprtmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . H
//
//  Contents:   CHNetPortMappingProtocol declarations
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "hnprivate.h"

class ATL_NO_VTABLE CHNetPortMappingProtocol :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetPortMappingProtocol,
    public IHNetPrivate
{
private:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to WMI instance
    //

    BSTR m_bstrProtocol;

    //
    // True if this is a built-in protocol. We cache
    // this value as it will be used quite often, and
    // will never change for the instance.
    //

    BOOLEAN m_fBuiltIn;

    //
    // Commonly used BSTR
    //

    BSTR m_bstrWQL;

    //
    // Get protocol object from cached path
    //

    HRESULT
    GetProtocolObject(
        IWbemClassObject **ppwcoInstance
        );

    //
    // Sends an update notification for connections with
    // enabled bindings to this protocol.
    //

    HRESULT
    SendUpdateNotification();

    //
    // Queries for bindings for this protocol that are
    // enabled
    //

    HRESULT
    GetEnabledBindingEnumeration(
        IEnumHNetPortMappingBindings **ppEnum
        );

public:

    BEGIN_COM_MAP(CHNetPortMappingProtocol)
        COM_INTERFACE_ENTRY(IHNetPortMappingProtocol)
        COM_INTERFACE_ENTRY(IHNetPrivate)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //
    
    CHNetPortMappingProtocol()
    {
        m_piwsHomenet = NULL;
        m_bstrProtocol = NULL;
        m_fBuiltIn = FALSE;
        m_bstrWQL = NULL;
    };
    
    //
    // Atl methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Object initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoInstance
        );

    //
    // IHNetPortMappingProtocol methods
    //

    STDMETHODIMP
    GetName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    SetName(
        OLECHAR *pszwName
        );

    STDMETHODIMP
    GetIPProtocol(
        UCHAR *pucProtocol
        );

    STDMETHODIMP
    SetIPProtocol(
        UCHAR ucProtocol
        );

    STDMETHODIMP
    GetPort(
        USHORT *pusPort
        );

    STDMETHODIMP
    SetPort(
        USHORT usPort
        );

    STDMETHODIMP
    GetBuiltIn(
        BOOLEAN *pfBuiltIn
        );

    STDMETHODIMP
    Delete();

    STDMETHODIMP
    GetGuid(
        GUID **ppGuid
        );

    //
    // IHNetPrivate methods
    //

    STDMETHODIMP
    GetObjectPath(
        BSTR *pbstrPath
        );


};

//
// Type to use for our enumeration class
//

typedef CHNCEnum<
            IEnumHNetPortMappingProtocols,
            IHNetPortMappingProtocol,
            CHNetPortMappingProtocol
            >
        CEnumHNetPortMappingProtocols;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\sportmap.h ===
// SPortMap.h : Declaration of the CStaticPortMapping

#ifndef __STATICPORTMAPPING_H_
#define __STATICPORTMAPPING_H_

#include <upnp.h>
#include "dportmap.h"

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMapping
class ATL_NO_VTABLE CStaticPortMapping : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CStaticPortMapping, &CLSID_StaticPortMapping>,
	public IDispatchImpl<IStaticPortMapping, &IID_IStaticPortMapping, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IDynamicPortMapping> m_spDPM;

public:
	CStaticPortMapping()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_STATICPORTMAPPING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStaticPortMapping)
	COM_INTERFACE_ENTRY(IStaticPortMapping)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStaticPortMapping
public:
   STDMETHOD(get_ExternalIPAddress)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_ExternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_Protocol)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_InternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_InternalClient)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_Enabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
   STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(EditInternalClient)(/*[in]*/ BSTR bstrInternalClient);
   STDMETHOD(Enable)(/*[in]*/ VARIANT_BOOL vb);
   STDMETHOD(EditDescription)(/*[in]*/ BSTR bstrDescription);
   STDMETHOD(EditInternalPort)(/*[in]*/ long lInternalPort);

// CStaticPortMapping
public:
   HRESULT Initialize (IDynamicPortMapping * pDPM)
   {
      _ASSERT (m_spDPM == NULL);
      m_spDPM = pDPM;
      return S_OK;
   }

   static IStaticPortMapping * CreateInstance (IDynamicPortMapping * pDPM)
   {
      CComObject<CStaticPortMapping> * spm = NULL;
      HRESULT hr = CComObject<CStaticPortMapping>::CreateInstance (&spm);
      if (!spm)
         return NULL;

      IStaticPortMapping * pSPM = NULL;
      spm->AddRef();
      hr = spm->Initialize (pDPM);
      if (SUCCEEDED(hr))
         spm->QueryInterface (__uuidof(IStaticPortMapping), (void**)&pSPM);
      spm->Release();
      return pSPM;
   }
};

#endif //__STATICPORTMAPPING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnicsprv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P R V . H
//
//  Contents:   CHNIcsPrivateConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNIcsPrivateConn :
    public CHNetConn,
    public IHNetIcsPrivateConnection
{
public:

    BEGIN_COM_MAP(CHNIcsPrivateConn)
        COM_INTERFACE_ENTRY(IHNetIcsPrivateConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // IHNetIcsPrivateConnection methods
    //

    STDMETHODIMP
    RemoveFromIcs();
};

typedef CHNCEnum<
            IEnumHNetIcsPrivateConnections,
            IHNetIcsPrivateConnection,
            CHNIcsPrivateConn
            >
        CEnumHNetIcsPrivateConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\hnprtbnd.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . H
//
//  Contents:   CHNetPortMappingBinding declarations
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetPortMappingBinding :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetPortMappingBinding
{
private:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to WMI instance.
    //

    BSTR m_bstrBinding;

    //
    // Commonly used BSTR
    //

    BSTR m_bstrWQL;

    //
    // Generate a target address w/in our DHCP scope when using
    // a name-based port mapping
    //

    HRESULT
    GenerateTargetAddress(
        LPCWSTR pszwTargetName,
        ULONG *pulAddress
        );

    //
    // Get the object corresponding to our stored path
    //
    
    HRESULT
    GetBindingObject(
        IWbemClassObject **ppwcoInstance
        );

    //
    // Sends an update notification to SharedAccess (if the
    // service is running).
    //

    HRESULT
    SendUpdateNotification();

public:

    BEGIN_COM_MAP(CHNetPortMappingBinding)
        COM_INTERFACE_ENTRY(IHNetPortMappingBinding)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //
    
    CHNetPortMappingBinding()
    {
        m_piwsHomenet = NULL;
        m_bstrBinding = NULL;
        m_bstrWQL = NULL;
    };
    
    //
    // Atl methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Object initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoInstance
        );

    //
    // IHNetPortMappingBinding methods
    //

    STDMETHODIMP
    GetConnection(
        IHNetConnection **ppConnection
        );

    STDMETHODIMP
    GetProtocol(
        IHNetPortMappingProtocol **ppProtocol
        );

    STDMETHODIMP
    GetEnabled(
        BOOLEAN *pfEnabled
        );

    STDMETHODIMP
    SetEnabled(
        BOOLEAN fEnable
        );

    STDMETHODIMP
    GetCurrentMethod(
        BOOLEAN *pfUseName
        );

    STDMETHODIMP
    GetTargetComputerName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    SetTargetComputerName(
        OLECHAR *pszwName
        );

    STDMETHODIMP
    GetTargetComputerAddress(
        ULONG *pulAddress
        );

    STDMETHODIMP
    SetTargetComputerAddress(
        ULONG ulAddress
        );

    STDMETHODIMP
    GetTargetPort(
        USHORT *pusPort
        );

    STDMETHODIMP
    SetTargetPort(
        USHORT usPort
        );
};

//
// Type to use for our enumeration class
//

typedef CHNCEnum<
            IEnumHNetPortMappingBindings,
            IHNetPortMappingBinding,
            CHNetPortMappingBinding
            >
        CEnumHNetPortMappingBindings;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\upnpnat.h ===
// UPnPNAT.h : Declaration of the CUPnPNAT

#ifndef __UPNPNAT_H_
#define __UPNPNAT_H_

#include <upnp.h>
#include <netcon.h>

#include "hncres.h"

extern void EnableNATExceptionHandling();
extern void DisableNATExceptionHandling();

/////////////////////////////////////////////////////////////////////////////
// CUPnPNAT
class ATL_NO_VTABLE CUPnPNAT : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUPnPNAT, &CLSID_UPnPNAT>,
	public IDispatchImpl<IUPnPNAT, &IID_IUPnPNAT, &LIBID_NATUPNPLib>
{
public:
	CUPnPNAT()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UPNPNAT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUPnPNAT)
	COM_INTERFACE_ENTRY(IUPnPNAT)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IUPnPNAT
public:
   STDMETHOD(get_StaticPortMappingCollection) (/*[out, retval]*/ IStaticPortMappingCollection ** ppSPMC);
   STDMETHOD(get_DynamicPortMappingCollection)(/*[out, retval]*/ IDynamicPortMappingCollection ** ppDPMC);
   STDMETHOD(get_NATEventManager)             (/*[out, retval]*/ INATEventManager ** ppNEM);

// CUPnPNAT
public:
};

#endif //__UPNPNAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\mof\makefile.inc ===
#
# generate binary mof file (bmf)
#

clean:
    del HNetCfg.bmf 

HNetCfg.bmf: HNetCfg.mof
    mofcomp -B:$(O)\HNetCfg.bmf HNetCfg.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\igfclsid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File: IGFClsId.c
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

// dup'd from ..\..\beacon\client\internetgatewayfinder.h
DEFINE_GUID(CLSID_CInternetGatewayFinder, 
0x4d3f9715, 0x73da, 0x4506, 0x89, 0x33, 0x1e, 0xe, 0x17, 0x18, 0xba, 0x3b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\dprtmapc.cpp ===
// DPrtMapC.cpp : Implementation of CDynamicPortMappingCollection
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "DPrtMapC.h"
#include "DPortMap.h"

/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMappingCollection

STDMETHODIMP CDynamicPortMappingCollection::get_Item (BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, IDynamicPortMapping ** ppDPM)
{
    NAT_API_ENTER

    if (!ppDPM)
        return E_POINTER;
    *ppDPM = NULL;

    return CDynamicPortMapping::CreateInstance (m_spUPS, bstrRemoteHost, lExternalPort, bstrProtocol, ppDPM);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::get_Count(long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    ULONG ul = 0;
    HRESULT hr = GetNumberOfEntries (m_spUPS, &ul);
    if (SUCCEEDED(hr))
        *pVal = (long)ul;
    return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::Remove(BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol)
{
    NAT_API_ENTER

    return DeletePortMapping (m_spUPS, bstrRemoteHost, lExternalPort, bstrProtocol);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::Add(BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, long lInternalPort, BSTR bstrInternalClient, VARIANT_BOOL bEnabled, BSTR bstrDescription, long lLeaseDuration, IDynamicPortMapping ** ppDPM)
{
    NAT_API_ENTER

    if (!ppDPM)
        return E_POINTER;
    *ppDPM = NULL;

    if (!bstrRemoteHost)
        return E_INVALIDARG;
    if ((lExternalPort < 0) || (lExternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrProtocol)
        return E_INVALIDARG;
    if (wcscmp (bstrProtocol, L"TCP") && wcscmp (bstrProtocol, L"UDP"))
        return E_INVALIDARG;
    if ((lInternalPort < 0) || (lInternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrInternalClient)
        return E_INVALIDARG;
    if (!bstrDescription)
        return E_INVALIDARG;
    if ((lLeaseDuration < 0) || (lLeaseDuration > 65535))
        return E_INVALIDARG;

    HRESULT hr = AddPortMapping (m_spUPS, 
                                 bstrRemoteHost,
                                 lExternalPort,
                                 bstrProtocol,
                                 lInternalPort,
                                 bstrInternalClient,
                                 bEnabled,
                                 bstrDescription,
                                 lLeaseDuration);
    if (SUCCEEDED(hr)) {
        hr = CDynamicPortMapping::CreateInstance (
                    m_spUPS, bstrRemoteHost,lExternalPort,
                    bstrProtocol, ppDPM);
    }
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::get__NewEnum(IUnknown **ppVal)
{
    NAT_API_ENTER

    if (!ppVal)
        return E_POINTER;
    *ppVal = NULL;

    CComPtr<IEnumVARIANT> spEV = 
                CEnumDynamicPortMappingCollection::CreateInstance (m_spUPS);
    if (!spEV)
        return E_OUTOFMEMORY;
    return spEV->QueryInterface (__uuidof(IUnknown), (void**)ppVal);

    NAT_API_LEAVE
}

HRESULT CDynamicPortMappingCollection::Initialize (IUPnPService * pUPS)
{
    _ASSERT (pUPS);
    _ASSERT (m_spUPS == NULL);

    m_spUPS = pUPS;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\dportmap.cpp ===
// DPortMap.cpp : Implementation of CDynamicPortMapping
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "DPortMap.h"

/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMapping

STDMETHODIMP CDynamicPortMapping::get_ExternalIPAddress (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    return GetExternalIPAddress (m_spUPS, pVal);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_LeaseDuration (long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    // live
    return GetAllData (pVal);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_RemoteHost (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbRemoteHost);    // "" == wildcard (for static)
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_ExternalPort (long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = m_lExternalPort;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_Protocol (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbProtocol);  // "TCP" or "UDP"
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_InternalPort (long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = m_lInternalPort;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_InternalClient (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbInternalClient);
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_Enabled (VARIANT_BOOL *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = VARIANT_FALSE;  // REVIEW: true?

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = m_vbEnabled;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_Description (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbDescription);
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::RenewLease (long lLeaseDurationDesired, long * pLeaseDurationReturned)
{
    NAT_API_ENTER

    if (!pLeaseDurationReturned)
        return E_POINTER;
    *pLeaseDurationReturned = 0;

    HRESULT hr;
    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    hr = AddPortMapping (m_spUPS,
                         m_cbRemoteHost,
                         m_lExternalPort,
                         m_cbProtocol,
                         m_lInternalPort,
                         m_cbInternalClient,
                         m_vbEnabled,
                         m_cbDescription,
                         lLeaseDurationDesired);
    if (SUCCEEDED(hr))
        hr = get_LeaseDuration (pLeaseDurationReturned);
    
    return hr;

    NAT_API_LEAVE
}

static BOOL IsBuiltIn (BSTR bstrDescription)
{
    #define BUILTIN_KEY L" [MICROSOFT]"
    OLECHAR * tmp = wcsstr (bstrDescription, BUILTIN_KEY);
    if (tmp && (tmp[wcslen(BUILTIN_KEY)] == 0))
        return TRUE;
    return FALSE;
}

HRESULT CDynamicPortMapping::EditInternalClient (BSTR bstrInternalClient)
{
    NAT_API_ENTER

    if (!bstrInternalClient)
        return E_INVALIDARG;

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);
    if (SUCCEEDED(hr)) {
        if (IsBuiltIn (m_cbDescription)) {
            // built-in mappings can't be deleted.

            // if enabled, I won't be able to edit the internal client.
            // so, disable it first.  Note that this must be done after 
            // the call to get_LeaseDuration so that all the data is up-to-date.
            VARIANT_BOOL vbEnabled = m_vbEnabled;   // put in local variable, so I can change it back
            if (m_vbEnabled == VARIANT_TRUE)
                hr = Enable (VARIANT_FALSE);
            
            if (SUCCEEDED(hr)) {
                hr = AddPortMapping (m_spUPS,
                                     m_cbRemoteHost,
                                     m_lExternalPort,
                                     m_cbProtocol,
                                     m_lInternalPort,
                                     bstrInternalClient,
                                     vbEnabled,
                                     m_cbDescription,
                                     lLease);
                if (SUCCEEDED(hr))
                    m_vbEnabled = vbEnabled;
            }
        } else {
            hr = DeletePortMapping (m_spUPS,
                                    m_cbRemoteHost,
                                    m_lExternalPort,
                                    m_cbProtocol);
            if (SUCCEEDED(hr))
                hr = AddPortMapping (m_spUPS,
                                     m_cbRemoteHost,
                                     m_lExternalPort,
                                     m_cbProtocol,
                                     m_lInternalPort,
                                     bstrInternalClient,
                                     m_vbEnabled,
                                     m_cbDescription,
                                     lLease);
        }
        if (SUCCEEDED(hr)) {
            m_cbInternalClient = bstrInternalClient;
            if (!m_cbInternalClient.m_str)
                return E_OUTOFMEMORY;
        }
    }
    return hr;
    
    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::Enable (VARIANT_BOOL vb)
{
    NAT_API_ENTER

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);

    if (SUCCEEDED(hr)) {
        hr = AddPortMapping (m_spUPS,
                             m_cbRemoteHost,
                             m_lExternalPort,
                             m_cbProtocol,
                             m_lInternalPort,
                             m_cbInternalClient,
                             vb,
                             m_cbDescription,
                             lLease);
        if (SUCCEEDED(hr))
            m_vbEnabled = vb;
    }

    return hr;

    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::EditDescription (BSTR bstrDescription)
{
    NAT_API_ENTER

    if (!bstrDescription)
        return E_INVALIDARG;

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);
    if (SUCCEEDED(hr)) {
        hr = AddPortMapping (m_spUPS,
                             m_cbRemoteHost,
                             m_lExternalPort,
                             m_cbProtocol,
                             m_lInternalPort,
                             m_cbInternalClient,
                             m_vbEnabled,
                             bstrDescription,
                             lLease);
        if (SUCCEEDED(hr)) {
            m_cbDescription = bstrDescription;
            if (!m_cbDescription.m_str)
                return E_OUTOFMEMORY;
        }
    }

    return hr;
    
    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::EditInternalPort (long lInternalPort)
{
    NAT_API_ENTER

    if ((lInternalPort < 0) || (lInternalPort > 65535))
        return E_INVALIDARG;

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);

    if (SUCCEEDED(hr)) {
        hr = AddPortMapping (m_spUPS,
                             m_cbRemoteHost,
                             m_lExternalPort,
                             m_cbProtocol,
                               lInternalPort,
                             m_cbInternalClient,
                             m_vbEnabled,
                             m_cbDescription,
                             lLease);
        if (SUCCEEDED(hr))
            m_lInternalPort = lInternalPort;
    }

    return hr;

    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::GetAllData (long * pLease)
{
    if (pLease)
       *pLease = NULL;

    _ASSERT (m_cbRemoteHost);
    _ASSERT (m_lExternalPort != 0);
    _ASSERT (m_cbProtocol);

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 3;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT
        hr = AddToSafeArray (psa, &CComVariant(m_cbRemoteHost), 0);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(m_lExternalPort), 1);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(m_cbProtocol),     2);

    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (m_spUPS, CComBSTR(L"GetSpecificPortMappingEntry"), cvIn, &cvOut, &cvRet);
        if (SUCCEEDED(hr)) {
            if (V_VT (&cvOut) != (VT_VARIANT | VT_ARRAY))   {
                _ASSERT (0 && "InvokeAction didn't fill out a [out] parameter (properly)!");
                hr = E_UNEXPECTED;
            } else {
                SAFEARRAY * pSA = V_ARRAY (&cvOut);
                _ASSERT (pSA);

                long lLower = 0, lUpper = -1;
                SafeArrayGetLBound (pSA, 1, &lLower);
                SafeArrayGetUBound (pSA, 1, &lUpper);
                if (lUpper - lLower != 5 - 1)
                    hr = E_UNEXPECTED;
                else {
                    hr = GetLongFromSafeArray (pSA, &m_lInternalPort, 0);
                    if (SUCCEEDED(hr)) {
                        m_cbInternalClient.Empty();
                        hr = GetBSTRFromSafeArray (pSA, &m_cbInternalClient, 1);
                        if (SUCCEEDED(hr)) {
                            hr = GetBoolFromSafeArray (pSA, &m_vbEnabled,      2);
                            if (SUCCEEDED(hr)) {
                                m_cbDescription.Empty();
                                hr = GetBSTRFromSafeArray (pSA, &m_cbDescription, 3);
                                if (SUCCEEDED(hr)) {
                                    if (pLease)
                                        hr = GetLongFromSafeArray (pSA, pLease,   4);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
        m_eComplete = eAllData;
    return hr;
}

HRESULT CDynamicPortMapping::CreateInstance (IUPnPService * pUPS, long lIndex, IDynamicPortMapping ** ppDPM)
{
    if (ppDPM)
        *ppDPM = NULL;

    if (!pUPS)
        return E_INVALIDARG;
    if (!ppDPM)
        return E_POINTER;

    CComObject<CDynamicPortMapping> * pDPM = NULL;
    HRESULT hr = CComObject<CDynamicPortMapping>::CreateInstance (&pDPM);
    if (pDPM) {
        pDPM->AddRef();

        hr = pDPM->Initialize (pUPS, lIndex);
        if (SUCCEEDED(hr))
            hr = pDPM->QueryInterface (__uuidof(IDynamicPortMapping),
                                      (void**)ppDPM);
        pDPM->Release();
    }
    return hr;
}
            
HRESULT CDynamicPortMapping::Initialize (IUPnPService * pUPS, long lIndex)
{
    _ASSERT (m_spUPS == NULL);
    _ASSERT (m_eComplete == eNoData);

    m_spUPS = pUPS;

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 1;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT hr = AddToSafeArray (psa, &CComVariant(lIndex), 0);
    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (m_spUPS, CComBSTR(L"GetGenericPortMappingEntry"), cvIn, &cvOut, &cvRet);

        if (0) {
            long l = 0;
            HRESULT hr1 = m_spUPS->get_LastTransportStatus (&l);
            _ASSERT (l == 200);
        }

        if (SUCCEEDED(hr)) {
            if (V_VT (&cvOut) != (VT_VARIANT | VT_ARRAY))   {
                _ASSERT (0 && "InvokeAction didn't fill out a [out] parameter (properly)!");
                hr = E_UNEXPECTED;
            } else {
                SAFEARRAY * pSA = V_ARRAY (&cvOut);
                _ASSERT (pSA);

                long lLower = 0, lUpper = -1;
                SafeArrayGetLBound (pSA, 1, &lLower);
                SafeArrayGetUBound (pSA, 1, &lUpper);
                if (lUpper - lLower != 8 - 1)
                    hr = E_UNEXPECTED;
                else {
                        hr = GetBSTRFromSafeArray (pSA, &m_cbRemoteHost, 0);
                    if (SUCCEEDED(hr))
                        hr = GetLongFromSafeArray (pSA, &m_lExternalPort, 1);
                    if (SUCCEEDED(hr))
                        hr = GetBSTRFromSafeArray (pSA, &m_cbProtocol,     2);
                    if (SUCCEEDED(hr))
                        hr = GetLongFromSafeArray (pSA, &m_lInternalPort,   3);
                    if (SUCCEEDED(hr))
                        hr = GetBSTRFromSafeArray (pSA, &m_cbInternalClient, 4);
                    if (SUCCEEDED(hr))
                        hr = GetBoolFromSafeArray (pSA, &m_vbEnabled,       5);
                    if (SUCCEEDED(hr))
                        hr = GetBSTRFromSafeArray (pSA, &m_cbDescription,  6);
                    // skip lease duration, since it's live and we get it every time.
                }
            }
        }
    }
    return hr;
}

HRESULT CDynamicPortMapping::CreateInstance (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, IDynamicPortMapping ** ppDPM)
{
    if (ppDPM)
        *ppDPM = NULL;

    if (!pUPS)
        return E_INVALIDARG;
    if (!ppDPM)
        return E_POINTER;

    CComObject<CDynamicPortMapping> * pDPM = NULL;
    HRESULT hr = CComObject<CDynamicPortMapping>::CreateInstance (&pDPM);
    if (pDPM) {
        pDPM->AddRef();

        hr = pDPM->Initialize (pUPS, bstrRemoteHost, lExternalPort, bstrProtocol);
        if (SUCCEEDED(hr))
            hr = pDPM->QueryInterface (__uuidof(IDynamicPortMapping),
                                       (void**)ppDPM);
        pDPM->Release();
    }
    return hr;
}

HRESULT CDynamicPortMapping::Initialize (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol)
{
    if (!pUPS)
        return E_INVALIDARG;
    if (!bstrRemoteHost)
        return E_INVALIDARG;
    if ((lExternalPort < 0) || (lExternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrProtocol)
        return E_INVALIDARG;
    if (wcscmp (bstrProtocol, L"TCP") && wcscmp (bstrProtocol, L"UDP"))
        return E_INVALIDARG;

    _ASSERT (m_spUPS == NULL);
    _ASSERT (m_eComplete == eNoData);

    m_spUPS = pUPS;
    
    m_cbRemoteHost  = bstrRemoteHost;
    m_lExternalPort = lExternalPort;
    m_cbProtocol    = bstrProtocol;

    if (!m_cbRemoteHost || !m_cbProtocol)
        return E_OUTOFMEMORY;
    else
        return GetAllData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\inc\sprtmapc.h ===
// SPrtMapC.h : Declaration of the CStaticPortMappingCollection

#ifndef __STATICPORTMAPPINGCOLLECTION_H_
#define __STATICPORTMAPPINGCOLLECTION_H_

#include "dprtmapc.h"   // everything goes through CEnumDynamicPortMappingCollection
#include "sportmap.h"

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMappingCollection
class ATL_NO_VTABLE CStaticPortMappingCollection : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CStaticPortMappingCollection, &CLSID_StaticPortMappingCollection>,
	public IDispatchImpl<IStaticPortMappingCollection, &IID_IStaticPortMappingCollection, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IUPnPService> m_spUPS;

public:
	CStaticPortMappingCollection()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_STATICPORTMAPPINGCOLLECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStaticPortMappingCollection)
	COM_INTERFACE_ENTRY(IStaticPortMappingCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStaticPortMappingCollection
public:
   STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown* *pVal);
   STDMETHOD(get_Item)(/*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[out, retval]*/ IStaticPortMapping ** ppSPM);
   STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
   STDMETHOD(Remove)(/*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol);
   STDMETHOD(Add)(/*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[in]*/ long lInternalPort, /*[in]*/ BSTR bstrInternalClient, /*[in]*/ VARIANT_BOOL bEnabled, /*[in]*/ BSTR bstrDescription, /*[out, retval]*/ IStaticPortMapping ** ppSPM);

// CStaticPortMappingCollection
public:
   HRESULT Initialize (IUPnPService * pUPS);
};

// quickie enumerator
class CEnumStaticPortMappingCollection : public IEnumVARIANT
{
private:
   CComPtr<IEnumVARIANT> m_spEV;
   CComPtr<IUPnPService> m_spUPS;
   long m_index, m_refs;

   CEnumStaticPortMappingCollection ()
   {
      m_refs = 0;
      m_index = 0;
   }

   HRESULT Init (IUPnPService * pUPS)
   {
      m_spUPS = pUPS;   // we need to hang onto this for the Clone method

      CComPtr<IEnumVARIANT> spEV = 
                CEnumDynamicPortMappingCollection::CreateInstance (pUPS);
      if (!spEV)
         return E_OUTOFMEMORY;

      m_spEV = spEV;
      return S_OK;
   }

public:
   static IEnumVARIANT * CreateInstance (IUPnPService * pUPS)
   {
      CEnumStaticPortMappingCollection * pCEV = new CEnumStaticPortMappingCollection ();
      if (!pCEV)
         return NULL;
      HRESULT hr = pCEV->Init (pUPS);
      if (FAILED(hr)) {
         delete pCEV;
         return NULL;
      }

      IEnumVARIANT * pIEV = NULL;
      pCEV->AddRef();
      pCEV->QueryInterface (IID_IEnumVARIANT, (void**)&pIEV);
      pCEV->Release();
      return pIEV;
   }

// IUnknown
   virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void ** ppvObject)
   {
      NAT_API_ENTER

      if (ppvObject)
         *ppvObject = NULL;
      else
         return E_POINTER;

      HRESULT hr = S_OK;
      if ((riid == IID_IUnknown) ||
         (riid == IID_IEnumVARIANT) ){
         AddRef();
         *ppvObject = (void *)this;
      } else
         hr = E_NOINTERFACE;
      return hr;

      NAT_API_LEAVE
   }
   virtual ULONG STDMETHODCALLTYPE AddRef ()
   {
      return InterlockedIncrement ((PLONG)&m_refs);
   }
   virtual ULONG STDMETHODCALLTYPE Release ()
   {
      ULONG l = InterlockedDecrement ((PLONG)&m_refs);
      if (l == 0)
         delete this;
      return l;
   }

// IEnumVARIANT
   virtual HRESULT STDMETHODCALLTYPE Next (/*[in]*/ ULONG celt, /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar, /*[out]*/ ULONG * pCeltFetched)
   {
      NAT_API_ENTER

      // pass everything to contained dynamic portmapping enumerator

      // clear stuff being passed in (just in case)
      if (pCeltFetched)   *pCeltFetched = 0;
      for (ULONG i=0; i<celt; i++)
         VariantInit (&rgVar[i]);

      HRESULT hr = S_OK;

      // get the next celt elements
      for (i=0; i<celt; i++) {

         CComVariant cv;
         hr = m_spEV->Next (1, &cv, NULL);
         if (hr != S_OK)
            break;

         // all static port mappings are in the beginning of NAT's array:
         // we can stop as soon as we hit a dynamic one.

         CComPtr<IDynamicPortMapping> spDPM = NULL;
         V_DISPATCH (&cv)->QueryInterface (__uuidof(IDynamicPortMapping),
                                           (void**)&spDPM);
         _ASSERT (spDPM != NULL);   // can't fail

         if (!IsStaticPortMapping (spDPM))
            i--;  // try next one.
         else {
            // create a static port map object out of a dynamic object.
            CComPtr<IStaticPortMapping> spSPM =
                                 CStaticPortMapping::CreateInstance (spDPM);
            if (!spSPM) {
               hr = E_OUTOFMEMORY;
               break;
            }

            V_VT (&rgVar[i]) = VT_DISPATCH;
            spSPM->QueryInterface (__uuidof(IDispatch),
                                   (void**)&V_DISPATCH (&rgVar[i]));
         }
      }
      if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
         hr = S_OK;  // no more; will return S_FALSE below

      if (FAILED(hr)) {
         // on error clear variant array....
         for (ULONG j=0; j<i; j++)
            VariantClear (&rgVar[j]);
         return hr;
      }

      // now update index
      m_index += i;

      // fill out how many we're returning
      if (pCeltFetched)
         *pCeltFetched = i;
      return i < celt ? S_FALSE : S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Skip (/*[in]*/ ULONG celt)
   {
      NAT_API_ENTER

      HRESULT hr = S_OK;

      for (ULONG i=0; i<celt; i++) {
         CComVariant cv;
         hr = Next (1, &cv, NULL);
         if (hr != S_OK)
            break;
      }

      m_index += i;

      if (FAILED(hr))
         return hr;
      if (i != celt)
         return S_FALSE;
      return S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Reset ()
   {
      NAT_API_ENTER

      m_index = 0;
      return m_spEV->Reset ();

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Clone (/*[out]*/ IEnumVARIANT ** ppEnum)
   {
      NAT_API_ENTER

      if (!ppEnum)
         return E_POINTER;

      if (!(*ppEnum = CreateInstance (m_spUPS)))
         return E_OUTOFMEMORY;

      return (*ppEnum)->Skip (m_index);

      NAT_API_LEAVE
   }

private:
   static BOOL IsStaticPortMapping (IDynamicPortMapping * pDPM)
   {
      /* is it dynamic?
         lease must be infinite (i.e. 0)
         remote host must be wildcard (i.e. "")
         ports must match
      */
      long lLease = -1;
      HRESULT hr = pDPM->get_LeaseDuration (&lLease);
      if (FAILED(hr))
         return FALSE;
      if (lLease != 0)
         return FALSE;

      CComBSTR cbRemoteHost;
      hr = pDPM->get_RemoteHost (&cbRemoteHost);
      if (FAILED(hr))
         return FALSE;
      if (wcscmp(cbRemoteHost, L""))
         return FALSE;

      // still here?  must be static!
      return TRUE;
   }

};

#endif //__STATICPORTMAPPINGCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\makefile.inc ===
TARGETPATH=obj$(BUILD_ALT_DIR)

C_DEFINES=$(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE -D_NTSDK=1 -DMPR50=1

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\stdafx.pch
PRECOMPILED_TARGET=$(O)\stdafx.pch
PRECOMPILED_OBJ=$(O)\stdafx.obj

RCOPTIONS=-N
UMTYPE=windows
ATL_VER=30
USE_STATIC_ATL=1
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\natem.cpp ===
// NATDPMS.cpp : Implementation of CNATEventManager
#include "stdafx.h"
#pragma hdrstop

#include "NATEM.h"

/////////////////////////////////////////////////////////////////////////////
// CNATEventManager


STDMETHODIMP CNATEventManager::put_ExternalIPAddressCallback(IUnknown * pUnk)
{
    NAT_API_ENTER

    if (!m_spUPSCP)
        return E_UNEXPECTED;
    if (!pUnk)
        return E_INVALIDARG;

    // create a IUPnPServiceCallback
    CComObject<CExternalIPAddressCallback> * pEIAC = NULL;
    HRESULT hr = CComObject<CExternalIPAddressCallback>::CreateInstance (&pEIAC);
    if (pEIAC) {
        pEIAC->AddRef();

        hr = pEIAC->Initialize (pUnk);
        if (SUCCEEDED(hr)) {
            CComPtr<IUnknown> spUnk = NULL;
            hr = pEIAC->QueryInterface (__uuidof(IUnknown), (void**)&spUnk);
            if (spUnk)
                hr = AddTransientCallback (spUnk);
        }

        pEIAC->Release();
    }
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CNATEventManager::put_NumberOfEntriesCallback(IUnknown * pUnk)
{
    NAT_API_ENTER

    if (!m_spUPSCP)
        return E_UNEXPECTED;
    if (!pUnk)
        return E_INVALIDARG;

    // create a IUPnPServiceCallback
    CComObject<CNumberOfEntriesCallback> * pEIAC = NULL;
    HRESULT hr = CComObject<CNumberOfEntriesCallback>::CreateInstance (&pEIAC);
    if (pEIAC) {
        pEIAC->AddRef();

        hr = pEIAC->Initialize (pUnk);
        if (SUCCEEDED(hr)) {
            CComPtr<IUnknown> spUnk = NULL;
            hr = pEIAC->QueryInterface (__uuidof(IUnknown), (void**)&spUnk);
            if (spUnk)
                hr = AddTransientCallback (spUnk);
        }

        pEIAC->Release();
    }
	return hr;

    NAT_API_LEAVE
}

// cut-n-pasted from ...\nt\net\upnp\upnp\api\upnpservice.cpp
// fixed up leaks
HRESULT
HrInvokeDispatchCallback(IDispatch * pdispCallback, // user-supplied IDispatch
                         LPCWSTR pszCallbackType,   // L"ServiceDied", or L"StateVariableChanged"
                         IDispatch * pdispThis,     // IDispatch of service
                         LPCWSTR pszStateVarName,   // name of variable
                         VARIANT * lpvarValue)      // new value of variable
{
    HRESULT hr = S_OK;
    VARIANT     ary_vaArgs[4];

    ::VariantInit(&ary_vaArgs[0]);
    ::VariantInit(&ary_vaArgs[1]);
    ::VariantInit(&ary_vaArgs[2]);
    ::VariantInit(&ary_vaArgs[3]);

    // Fourth argument is the value.
    if (lpvarValue)
    {
        hr = VariantCopy(&ary_vaArgs[0], lpvarValue);
        if (FAILED(hr))
        {
            ::VariantInit(&ary_vaArgs[0]);
            goto Cleanup;
        }
    }

    // Third argument is the state variable name.
    // Copy this in case our caller parties on it.

    if (pszStateVarName)
    {
        BSTR bstrVarName;

        bstrVarName = ::SysAllocString(pszStateVarName);
        if (!bstrVarName)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        V_VT(&ary_vaArgs[1]) = VT_BSTR;
        V_BSTR(&ary_vaArgs[1]) = bstrVarName;
    }

    // Second argument is the pointer to the service object.
    pdispThis->AddRef();

    V_VT(&ary_vaArgs[2]) = VT_DISPATCH;
    V_DISPATCH(&ary_vaArgs[2]) = pdispThis;

    // First argument is the string defining the type
    // of callback.
    {
        BSTR bstrCallbackType;

        bstrCallbackType = ::SysAllocString(pszCallbackType);
        if (!bstrCallbackType)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        V_VT(&ary_vaArgs[3]) = VT_BSTR;
        V_BSTR(&ary_vaArgs[3]) = bstrCallbackType;
    }

    {
        VARIANT     vaResult;
        DISPPARAMS  dispParams = {ary_vaArgs, NULL, 4, 0};

        VariantInit(&vaResult);

        hr = pdispCallback->Invoke(0,
                                   IID_NULL,
                                   LOCALE_USER_DEFAULT,
                                   DISPATCH_METHOD,
                                   &dispParams,
                                   &vaResult,
                                   NULL,
                                   NULL);

        if (FAILED(hr))
        {
        }
    }

Cleanup:
    if ((VT_ARRAY | VT_UI1) == V_VT(&ary_vaArgs[0]))
    {
        SafeArrayDestroy(V_ARRAY(&ary_vaArgs[0]));
    }
    else
    {
        ::VariantClear(&ary_vaArgs[0]);
    }
    ::VariantClear(&ary_vaArgs[1]);
    ::VariantClear(&ary_vaArgs[2]);
    ::VariantClear(&ary_vaArgs[3]);

    return hr;
}

HRESULT Callback (IUnknown * punk, IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{
    /*
       IUnknown is either INATExternalIPAddressCallback, 
       INATNumberOfEntriesCallback, or an IDispatch.
       If the latter, call "Invoke" with dispid 0, and all the rest of
       the parameters are the same as for StateVariableChanged.
       Er, except there's an extra BSTR parameter specifying whether
       it's a variable state change or a service died thingy.
    */

    CComPtr<IDispatch> spDisp = NULL;
    punk->QueryInterface (__uuidof(IDispatch), (void**)&spDisp);
    if (spDisp) {
        CComPtr<IDispatch> spDispService = NULL;
        pus->QueryInterface (__uuidof(IDispatch), (void**)&spDispService);
        if (spDispService) {
            HrInvokeDispatchCallback (spDisp,
                                      L"VARIABLE_UPDATE",
                                      spDispService,
                                      pcwszStateVarName,
                                      &vaValue);
            return S_OK;
        }
    }

    // UPnP ignores the error
    return S_OK;
}

HRESULT CExternalIPAddressCallback::StateVariableChanged (IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{
    NAT_API_ENTER

    if (wcscmp (pcwszStateVarName, L"ExternalIPAddress"))
        return S_OK;    // not interested

    CComPtr<INATExternalIPAddressCallback> spEIAC = NULL;
    m_spUnk->QueryInterface (__uuidof(INATExternalIPAddressCallback), (void**)&spEIAC);
    if (spEIAC) {
        _ASSERT (V_VT (&vaValue) == VT_BSTR);
        spEIAC->NewExternalIPAddress (V_BSTR (&vaValue));
        return S_OK;
    }

    return Callback (m_spUnk, pus, pcwszStateVarName, vaValue);

    NAT_API_LEAVE
}
HRESULT CExternalIPAddressCallback::ServiceInstanceDied(IUPnPService *pus)
{
    return S_OK;    // not interested
}

HRESULT CNumberOfEntriesCallback::StateVariableChanged (IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{
    NAT_API_ENTER

    if (wcscmp (pcwszStateVarName, L"PortMappingNumberOfEntries"))
        return S_OK;    // not interested

    CComPtr<INATNumberOfEntriesCallback> spNOEC = NULL;
    m_spUnk->QueryInterface (__uuidof(INATNumberOfEntriesCallback), (void**)&spNOEC);
    if (spNOEC) {
        _ASSERT ((V_VT (&vaValue) == VT_I4) ||
                 (V_VT (&vaValue) == VT_UI4) );
        spNOEC->NewNumberOfEntries (V_I4 (&vaValue));
        return S_OK;
    }

    return Callback (m_spUnk, pus, pcwszStateVarName, vaValue);

    NAT_API_LEAVE
}

HRESULT CNumberOfEntriesCallback::ServiceInstanceDied(IUPnPService *pus)
{
    return S_OK;    // not interested
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3055FA29_74C3_4E43_A83A_2054CA60B628__INCLUDED_)
#define AFX_STDAFX_H__3055FA29_74C3_4E43_A83A_2054CA60B628__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <netcon.h>
#include <upnp.h>
#include <NATUPnP.h>

#include <netconp.h>
#include "natupnpp.h"
#include "NATUtils.h"

#define NAT_API_ENTER try {
#define NAT_API_LEAVE } catch (...) { return DISP_E_EXCEPTION; }

#include <eh.h>
class NAT_SEH_Exception 
{
private:
    unsigned int m_uSECode;
public:
   NAT_SEH_Exception(unsigned int uSECode) : m_uSECode(uSECode) {}
   NAT_SEH_Exception() {}
  ~NAT_SEH_Exception() {}
   unsigned int getSeHNumber() { return m_uSECode; }
};
void __cdecl nat_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp );
void EnableNATExceptionHandling();
void DisableNATExceptionHandling();

#endif // !defined(AFX_STDAFX_H__3055FA29_74C3_4E43_A83A_2054CA60B628__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\sprtmapc.cpp ===
// SPrtMapC.cpp : Implementation of CStaticPortMappingCollection
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "SPrtMapC.h"
#include "SPortMap.h"

static HRESULT CreateDynamicCollection (IUPnPService * pUPS, IDynamicPortMappingCollection ** ppDPMC)
{
    CComObject<CDynamicPortMappingCollection> * pDPMC = NULL;
    HRESULT hr = CComObject<CDynamicPortMappingCollection>::CreateInstance (&pDPMC);
    if (pDPMC) {
        pDPMC->AddRef();
        // init
        hr = pDPMC->Initialize (pUPS);
        if (SUCCEEDED(hr))
            hr = pDPMC->QueryInterface (__uuidof(IDynamicPortMappingCollection), (void**)ppDPMC);
        pDPMC->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMappingCollection

STDMETHODIMP CStaticPortMappingCollection::get_Item(long lExternalPort, BSTR bstrProtocol, IStaticPortMapping ** ppSPM)
{
    NAT_API_ENTER

    if (!ppSPM)
        return E_POINTER;
    *ppSPM = NULL;

    CComPtr<IDynamicPortMappingCollection> spDPMC = NULL;
    HRESULT hr = CreateDynamicCollection (m_spUPS, &spDPMC);
    if (spDPMC) {
        CComPtr<IDynamicPortMapping> spDPM = NULL;
        hr = spDPMC->get_Item (L"", lExternalPort, bstrProtocol, &spDPM);
        if (spDPM) {
            *ppSPM = CStaticPortMapping::CreateInstance (spDPM);
            if (!*ppSPM)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::get_Count(long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    long lCount = 0;

    CComPtr<IUnknown> spUnk = NULL;
    HRESULT hr = get__NewEnum (&spUnk);
    if (spUnk) {
        CComPtr<IEnumVARIANT> spEV = NULL;
        hr = spUnk->QueryInterface (__uuidof(IEnumVARIANT), (void**)&spEV);
        if (spEV) {
            spEV->Reset();
            CComVariant cv;
            while (S_OK == spEV->Next (1, &cv, NULL)) {
                lCount++;
                cv.Clear();
            }
        }
    }

    *pVal = lCount;
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::Remove(long lExternalPort, BSTR bstrProtocol)
{
    NAT_API_ENTER

    CComPtr<IDynamicPortMappingCollection> spDPMC = NULL;
    HRESULT hr = CreateDynamicCollection (m_spUPS, &spDPMC);
    if (spDPMC)
        hr = spDPMC->Remove (L"", lExternalPort, bstrProtocol);

    return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::Add(long lExternalPort, BSTR bstrProtocol, long lInternalPort, BSTR bstrInternalClient, VARIANT_BOOL bEnabled, BSTR bstrDescription, IStaticPortMapping ** ppSPM)
{
    NAT_API_ENTER

    if (!ppSPM)
        return E_POINTER;
    *ppSPM = NULL;

    CComPtr<IDynamicPortMappingCollection> spDPMC = NULL;
    HRESULT hr = CreateDynamicCollection (m_spUPS, &spDPMC);
    if (spDPMC) {
        CComPtr<IDynamicPortMapping> spDPM = NULL;
        hr = spDPMC->Add (L"", lExternalPort, bstrProtocol, lInternalPort, bstrInternalClient, bEnabled, bstrDescription, 0L, &spDPM);
        if (spDPM) {
            *ppSPM = CStaticPortMapping::CreateInstance (spDPM);
            if (!*ppSPM)
                hr = E_OUTOFMEMORY;
        }
    }
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::get__NewEnum(IUnknown **ppVal)
{
    NAT_API_ENTER

    if (!ppVal)
        return E_POINTER;
    *ppVal = NULL;

    CComPtr<IEnumVARIANT> spEV =
                   CEnumStaticPortMappingCollection::CreateInstance (m_spUPS);
    if (!spEV)
        return E_OUTOFMEMORY;
    return spEV->QueryInterface (__uuidof(IUnknown), (void**)ppVal);

    NAT_API_LEAVE
}

HRESULT CStaticPortMappingCollection::Initialize (IUPnPService * pUPS)
{
    _ASSERT (pUPS);
    _ASSERT (m_spUPS == NULL);

    m_spUPS = pUPS;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\natutils.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <winsock.h>

// upnp functions
HRESULT TranslateError (HRESULT hr)
{
    if ((hr >= UPNP_E_ACTION_SPECIFIC_BASE) &&
        (hr <= UPNP_E_ACTION_SPECIFIC_MAX)) {

        int iError = FAULT_ACTION_SPECIFIC_BASE - 0x300 + (int)(0xFFFF & hr);
        switch (iError) {
        case 401: // FAULT_INVALID_ACTION            
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_FUNCTION);
            break;

        case 402: // FAULT_INVALID_ARG               
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
            break;

        case 403: // FAULT_INVALID_SEQUENCE_NUMBER   
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_SIGNAL_NUMBER);
            break;

        case 404: // FAULT_INVALID_VARIABLE          
            hr = HRESULT_FROM_WIN32 (ERROR_PROC_NOT_FOUND);
            break;

        case 501: // FAULT_DEVICE_INTERNAL_ERROR     
            hr = HRESULT_FROM_WIN32 (ERROR_GEN_FAILURE);
            break;

        default:
            _ASSERT (0 && "unknown error");
            // fall thru
        case 701: // ValueAlreadySpecified: The value specified in the action is already available in the list and is consequently ignored.
        case 703: // InactiveConnectionStateRequired: Current value of ConnectionStatus should be either Disconnected or Unconfigured to permit this action.
        case 704: // ConnectionSetupFailed: There was a failure in setting up the IP or PPP connection with the service provider.  See LastConnectoinError for more details.
        case 705: // ConnectionSetupInProgress: The connection is already in the process of being setup
        case 706: // ConnectionNotConfigured: Current ConnectionStatus is Unconfigured
        case 707: // DisconnectInProgress: The connection is in the process of being torn down.
        case 708: // InvalidLayer2Address: Corresponding Link Config service has an invalid VPI/VPC or phone number.
        case 709: // InternetAccessDisabled: The EnabledForInternet flag is set to 0.
        case 710: // InvalidConnectionType: This command is valid only when ConnectionType is IP-Routed
        case 711: // ConnectionAlreadyTerminated: An attempt was made to terminate a connection that is no longer active.
        case 715: // WildCardNoPermitedInSrcIP: The source IP address cannot be wild-carded
        case 716: // WildCardNotPermittedInExtPort: The external port cannot be wild-carded

        case 719: // ActionDisallowedWhenAutoConfigEnabled: The specified action is not permitted when auto configuration is enabled on the modem.
        case 720: // InvalidDeviceUUID: the UUID of a device specified in the action arguments is invalid.
        case 721: // InvalidServiceID: The Service ID of a service specified in the action arguments in invalid.

        case 723: // InvalidConnServiceSelection: The selected connection service instance cannot be set as a default connection.
            hr = HRESULT_FROM_WIN32 (ERROR_SERVICE_SPECIFIC_ERROR);
            break;

        case 702: // ValueSpecifiedIsInvalid:  The specified value is not present in the list
            hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
            break;

        case 712: // The specified array index holds a NULL value
            hr = E_UNEXPECTED;  // ?? shouldn't the array compact?
            break;

        case 713: // The specified array index is out of bounds
        case 714: // NoSuchEntryInArray: The specified value does not exist in the array
            hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
            break;

        case 718: // ConflictInMappingEntry: The service mapping entry specified conflicts with a mapping assigned previously to another client
            hr = HRESULT_FROM_WIN32 (ERROR_BUSY);
            break;

        case 724: // SamePortValuesRequired: Internal and External port valuse must be the same.
        case 725: // OnlyPermanentLeasesSupported: The NAT implementation only supports permanent lease times on port mappings
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
            break;

        }
    }
    return hr;
}

HRESULT InvokeAction (IUPnPService * pUPS, CComBSTR & bstrActionName, VARIANT pvIn, VARIANT * pvOut, VARIANT * pvRet)
{
    if (!bstrActionName.m_str)
        return E_OUTOFMEMORY;

    HRESULT hr = pUPS->InvokeAction (bstrActionName, pvIn, pvOut, pvRet);
    if (FAILED(hr))
        hr = TranslateError (hr);
    return hr;
}

HRESULT QueryStateVariable (IUPnPService * pUPS, CComBSTR & bstrVariableName, VARIANT * pvOut)
{
    if (!bstrVariableName.m_str)
        return E_OUTOFMEMORY;

    HRESULT hr = pUPS->QueryStateVariable (bstrVariableName, pvOut);
    if (FAILED(hr))
        hr = TranslateError (hr);
    return hr;
}

HRESULT GetNumberOfEntries (IUPnPService * pUS, ULONG * pul)
{
    if (!pul)
        return E_POINTER;
    *pul = 0;

    CComVariant cv;
    HRESULT hr = QueryStateVariable (pUS, CComBSTR(L"PortMappingNumberOfEntries"), &cv);
    if (SUCCEEDED (hr)) {

        if ((V_VT (&cv) != VT_I4) &&
            (V_VT (&cv) != VT_UI4)) {
            _ASSERT (0 && "bad type from QueryStateVariable (PortMappingNumberOfEntries, ...)?");
            hr = E_UNEXPECTED;
        } else
            *pul = V_UI4 (&cv);  // it's a union, so this works in either case
    }
    return hr;
}

HRESULT GetExternalIPAddress (IUPnPService * pUPS, BSTR * pbstr)
{
    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 0;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    CComVariant cvOut, cvRet;
    HRESULT hr = InvokeAction (pUPS, CComBSTR(L"GetExternalIPAddress"), cvIn, &cvOut, &cvRet);
    if (SUCCEEDED (hr)) {
        if (V_VT (&cvOut) != (VT_VARIANT | VT_ARRAY))   {
            _ASSERT (0 && "InvokeAction didn't fill out a [out] parameter (properly)!");
            hr = E_UNEXPECTED;
        } else {
            SAFEARRAY * pSA = V_ARRAY (&cvOut);
            _ASSERT (pSA);

            long lLower = 0, lUpper = -1;
            SafeArrayGetLBound (pSA, 1, &lLower);
            SafeArrayGetUBound (pSA, 1, &lUpper);
            if (lUpper - lLower != 1 - 1)
                hr = E_UNEXPECTED;
            else {
                hr = GetBSTRFromSafeArray (pSA, pbstr, 0);
            }
        }
    }
    return hr;
}

// some utils
HRESULT GetOnlyVariantElementFromVariantSafeArray (VARIANT * pvSA, VARIANT * pv)
{
    HRESULT hr = S_OK;
                      
    if (V_VT (pvSA) != (VT_VARIANT | VT_ARRAY))   {
        _ASSERT (0 && "InvokeAction didn't fill out a [out,retval] parameter (properly)!");
        hr = E_UNEXPECTED;
    } else {
        SAFEARRAY * pSA = V_ARRAY (pvSA);
        _ASSERT (pSA);
        // this should contain a VARIANT that's really a BSTR
        long lLower = 0, lUpper = -1;
        SafeArrayGetLBound (pSA, 1, &lLower);
        SafeArrayGetUBound (pSA, 1, &lUpper);
        if (lUpper != lLower)
            hr = E_UNEXPECTED;
        else
            hr = SafeArrayGetElement (pSA, &lLower, (void*)pv);
    }
    return hr;
}

HRESULT AddToSafeArray (SAFEARRAY * psa, VARIANT * pv, long lIndex)
{
    if (V_VT (pv) == VT_ERROR)
        return V_ERROR (pv);
    return SafeArrayPutElement (psa, &lIndex, (void*)pv);
}

HRESULT GetBSTRFromSafeArray (SAFEARRAY * psa, BSTR * pbstr, long lIndex)
{
    *pbstr = NULL;

    CComVariant cv;
    HRESULT hr = SafeArrayGetElement (psa, &lIndex, (void*)&cv);
    if (SUCCEEDED(hr)) {
        if (V_VT (&cv) != VT_BSTR)
            hr = E_UNEXPECTED;
        else {
            *pbstr = SysAllocString (V_BSTR (&cv));
            if (!*pbstr)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT GetLongFromSafeArray (SAFEARRAY * psa, long * pl, long lIndex)
{
    *pl = 0;

    CComVariant cv;
    HRESULT hr = SafeArrayGetElement (psa, &lIndex, (void*)&cv);
    if (SUCCEEDED(hr)) {
        if ((V_VT (&cv) == VT_I4) || (V_VT (&cv) == VT_UI4))
            *pl = V_I4 (&cv);   // it's a union, so this works in either case
        else
        if ((V_VT (&cv) == VT_I2) || (V_VT (&cv) == VT_UI2))
            *pl = V_UI2 (&cv);  // it's a union, so this works in either case
        else
            hr = E_UNEXPECTED;
    }
    return hr;
}

HRESULT GetBoolFromSafeArray (SAFEARRAY * psa, VARIANT_BOOL  * pvb, long lIndex)
{
    *pvb = 0;

    CComVariant cv;
    HRESULT hr = SafeArrayGetElement (psa, &lIndex, (void*)&cv);
    if (SUCCEEDED(hr)) {
        if (V_VT (&cv) != VT_BOOL)
            hr = E_UNEXPECTED;
        else
            *pvb = V_BOOL (&cv);
    }
    return hr;
}

#ifdef KEEP
HRESULT FindDeviceByType (IUPnPDevices * pUPDs, BSTR bstrType, IUPnPDevice ** ppUPD)
{   // finds a device in a collection of devices, by type.

    CComPtr<IUnknown> spUnk = NULL;
    HRESULT hr = pUPDs->get__NewEnum (&spUnk);
    if (spUnk) {
        CComPtr<IEnumVARIANT> spEV = NULL;
        hr = spUnk->QueryInterface (__uuidof(IEnumVARIANT), (void**)&spEV);
        spUnk = NULL;   // don't need this anymore
        if (spEV) {
            CComVariant cv;
            while (S_OK == (hr = spEV->Next (1, &cv, NULL))) {
                if (V_VT (&cv) == VT_DISPATCH) {
                    CComPtr<IUPnPDevice> spUPD = NULL;
                    hr = V_DISPATCH (&cv)->QueryInterface (
                                                __uuidof(IUPnPDevice),
                                                (void**)&spUPD);
                    if (spUPD) {
                        // see if this device is of the right type
                        CComBSTR cb;
                        spUPD->get_Type (&cb);
                        if (cb == bstrType) {
                            // found it!
                            return spUPD->QueryInterface (
                                                    __uuidof(IUPnPDevice),
                                                    (void**)ppUPD);
                        }
                    }
                }
                cv.Clear();
            }
        }
    }
    // if we got here, we either didn't find it, or there was an error
    if (SUCCEEDED(hr))
        hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
    return hr;
}

HRESULT GetOnlyChildDevice (IUPnPDevice * pParent, IUPnPDevice ** ppChild)
{
    *ppChild = NULL;

    CComPtr<IUPnPDevices> spUPDs = NULL;
    HRESULT hr = pParent->get_Children (&spUPDs);
    if (spUPDs) {
        long lCount = 0;
        spUPDs->get_Count (&lCount);
        if (lCount != 1)
            return E_INVALIDARG;

        CComPtr<IUnknown> spUnk = NULL;
        hr = spUPDs->get__NewEnum (&spUnk);
        if (spUnk) {
            CComPtr<IEnumVARIANT> spEV = NULL;
            hr = spUnk->QueryInterface (__uuidof(IEnumVARIANT), (void**)&spEV);
            if (spEV) {
                spEV->Reset();  // probably not necessary

                CComVariant cv;
                hr = spEV->Next (1, &cv, NULL);
                if (hr == S_OK) {
                    if (V_VT (&cv) != VT_DISPATCH)
                        hr = E_FAIL;
                    else {
                        hr = V_DISPATCH (&cv)->QueryInterface (
                                                    __uuidof(IUPnPDevice),
                                                    (void**)ppChild);
                    }
                }
            }
        }
    }
    return hr;
}
#endif

NETCON_MEDIATYPE GetMediaType (INetConnection * pNC)
{
    NETCON_PROPERTIES* pProps = NULL;
    pNC->GetProperties (&pProps);
    if (pProps) {
        NETCON_MEDIATYPE MediaType = pProps->MediaType;
        NcFreeNetconProperties (pProps);
        return MediaType;
    }
    return NCM_NONE;
}

HRESULT AddPortMapping (IUPnPService * pUPS, 
                        BSTR bstrRemoteHost,
                        long lExternalPort,
                        BSTR bstrProtocol,
                        long lInternalPort,
                        BSTR bstrInternalClient,
                        VARIANT_BOOL vbEnabled,
                        BSTR bstrDescription,
                        long lLeaseDurationDesired)
{
    // special handling for loopback and localhost
    CComBSTR cbInternalClient;
    USES_CONVERSION;
    #define LOOPBACK_ADDR 0x0100007f
    if ((LOOPBACK_ADDR == inet_addr (OLE2A (bstrInternalClient))) ||
        (!_wcsicmp (bstrInternalClient, L"localhost"))) {
        // use computer name, using A version
        CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize       = MAX_COMPUTERNAME_LENGTH+1;
        if (!GetComputerNameA (szComputerName, &dwSize))
            return HRESULT_FROM_WIN32(GetLastError());
        else {
            cbInternalClient = A2OLE(szComputerName);
        }
    } else {
        cbInternalClient = bstrInternalClient;
    }
    if (!cbInternalClient.m_str)
        return E_OUTOFMEMORY;

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 8;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT
        hr = AddToSafeArray (psa, &CComVariant(bstrRemoteHost), 0);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lExternalPort),   1);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(bstrProtocol),     2);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lInternalPort),     3);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(cbInternalClient),   4);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant((bool)!!vbEnabled),   5);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(bstrDescription),      6);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lLeaseDurationDesired), 7);

    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (pUPS, CComBSTR(L"AddPortMapping"), cvIn, &cvOut, &cvRet);
    }
    return hr;
}

HRESULT DeletePortMapping (IUPnPService * pUPS,
                           BSTR bstrRemoteHost,
                           long lExternalPort,
                           BSTR bstrProtocol)
{
    if (!bstrRemoteHost)
        return E_INVALIDARG;
    if ((lExternalPort < 0) || (lExternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrProtocol)
        return E_INVALIDARG;
    if (wcscmp (bstrProtocol, L"TCP") && wcscmp (bstrProtocol, L"UDP"))
        return E_INVALIDARG;

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 3;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT
        hr = AddToSafeArray (psa, &CComVariant(bstrRemoteHost), 0);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lExternalPort), 1);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(bstrProtocol), 2);

    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (pUPS, CComBSTR(L"DeletePortMapping"), cvIn, &cvOut, &cvRet);
        // no [out] or [out,retval] paramters
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\upnpnat.cpp ===
// UPnPNAT.cpp : Implementation of CUPnPNAT
#include "stdafx.h"
#pragma hdrstop

#include "UPnPNAT.h"
#include "NATEM.h"
#include "dprtmapc.h"
#include "sprtmapc.h"

DEFINE_GUID(CLSID_CInternetGatewayFinder, 
0x4d3f9715, 0x73da, 0x4506, 0x89, 0x33, 0x1e, 0xe, 0x17, 0x18, 0xba, 0x3b);

void __cdecl nat_trans_func (unsigned int uSECode, EXCEPTION_POINTERS* pExp)
{
   throw NAT_SEH_Exception (uSECode);
}
void EnableNATExceptionHandling()
{
   _set_se_translator (nat_trans_func);
}
void DisableNATExceptionHandling()
{
   _set_se_translator (NULL);
}

HRESULT GetServiceFromINetConnection (IUnknown * pUnk, IUPnPService ** ppUPS)
{
    CComPtr<INetConnection> spNC = NULL;
    HRESULT hr = pUnk->QueryInterface (__uuidof(INetConnection), (void**)&spNC);
    if (!spNC)
        return E_INVALIDARG;

    SAHOST_SERVICES sas;

    // make sure we have either
    // NCM_SHAREDACCESSHOST_LAN or NCM_SHAREDACCESSHOST_RAS
    switch (GetMediaType (spNC)) {
    case NCM_SHAREDACCESSHOST_LAN:
        sas = SAHOST_SERVICE_WANIPCONNECTION;
        break;
    case NCM_SHAREDACCESSHOST_RAS:
        sas = SAHOST_SERVICE_WANPPPCONNECTION;
        break;
    default:
        return E_INVALIDARG;
    }

    CComPtr<INetSharedAccessConnection> spNSAC = NULL;
    hr = pUnk->QueryInterface (__uuidof(INetSharedAccessConnection), (void**)&spNSAC);
    if (spNSAC)
        hr = spNSAC->GetService (sas, ppUPS);
	return hr;
}

HRESULT GetServiceFromFinder (IInternetGatewayFinder * pIGF, IUPnPService ** ppUPS)
{
    CComPtr<IInternetGateway> spIG = NULL;
    HRESULT hr = pIGF->GetInternetGateway (NULL, &spIG);    // NULL gets default.
    if (spIG) {
        NETCON_MEDIATYPE MediaType = NCM_NONE;
        hr = spIG->GetMediaType (&MediaType);
        if (SUCCEEDED(hr)) {
            switch (MediaType) {
            case NCM_SHAREDACCESSHOST_LAN:
                hr = spIG->GetService (SAHOST_SERVICE_WANIPCONNECTION, ppUPS);
                break;
            case NCM_SHAREDACCESSHOST_RAS:
                hr = spIG->GetService (SAHOST_SERVICE_WANPPPCONNECTION, ppUPS);
                break;
            default:
                return E_UNEXPECTED;
            }
        }
    }
    return hr;
}

HRESULT GetService (IUPnPService ** ppUPS)
{
    if (!ppUPS)
        return E_POINTER;
    *ppUPS = NULL;

    // either enum all netconnections, or
    // for downlevel, use Ken's object

    CComPtr<INetConnectionManager> spNCM = NULL;
    HRESULT hr = ::CoCreateInstance (CLSID_ConnectionManager,
                                     NULL,
                                     CLSCTX_ALL,
                                     __uuidof(INetConnectionManager),
                                     (void**)&spNCM);
    if (spNCM) {
        CComPtr<IUnknown> spUnk = NULL;
        CComPtr<IEnumNetConnection> spENC = NULL;
        hr = spNCM->EnumConnections (NCME_DEFAULT, &spENC);
        if (spENC) {
            ULONG ul = 0;
            CComPtr<INetConnection> spNC = NULL;
            while (S_OK == spENC->Next (1, &spNC, &ul)) {
                NETCON_PROPERTIES * pProps = NULL;
                spNC->GetProperties (&pProps);
                if (pProps) {
                    NETCON_MEDIATYPE MediaType = pProps->MediaType;
                    NcFreeNetconProperties (pProps);
                    if ((MediaType == NCM_SHAREDACCESSHOST_LAN) ||
                        (MediaType == NCM_SHAREDACCESSHOST_RAS) ){
                        // found it
                        spNC->QueryInterface (__uuidof(IUnknown),
                                              (void**)&spUnk);
                        break;
                    }
                }
                spNC = NULL;
            }
        }
        if (spUnk)
            hr = GetServiceFromINetConnection (spUnk, ppUPS);
        else
            hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
    } else {
        // downlevel
        CComPtr<IInternetGatewayFinder> spIGF = NULL;
        hr = ::CoCreateInstance (CLSID_CInternetGatewayFinder,
                                 NULL,
                                 CLSCTX_ALL,
                                 __uuidof(IInternetGatewayFinder),
                                 (void**)&spIGF);
        if (spIGF)
            hr = GetServiceFromFinder (spIGF, ppUPS);
    }
    return hr;
}

template<class C, class I> class UN {
public:
    HRESULT Create (I ** ppI)
    {
        if (ppI)
            *ppI = NULL;

        if (!ppI)
            return E_POINTER;

        CComPtr<IUPnPService> spUPS = NULL;
        HRESULT hr = GetService (&spUPS);
        if (spUPS) {
            // create class so that I can initialize it
            CComObject<C> * pC = NULL;
            hr = CComObject<C>::CreateInstance (&pC);
            if (pC) {
                pC->AddRef();
                // init
                hr = pC->Initialize (spUPS);
                if (SUCCEEDED(hr))
                    hr = pC->QueryInterface (__uuidof(I), (void**)ppI);
                pC->Release();
            }
        }
		return hr;
    }
};

/////////////////////////////////////////////////////////////////////////////
// CUPnPNAT

STDMETHODIMP CUPnPNAT::get_NATEventManager(INATEventManager ** ppNEM)
{
    NAT_API_ENTER

    UN<CNATEventManager, INATEventManager> un;
    return un.Create (ppNEM);

    NAT_API_LEAVE
}

STDMETHODIMP CUPnPNAT::get_DynamicPortMappingCollection (IDynamicPortMappingCollection ** ppDPMC)
{
    NAT_API_ENTER

    // remove the section below when turning dynamic port mappings back on
    if (!ppDPMC)
        return E_POINTER;
    *ppDPMC = NULL;
    return E_NOTIMPL;
    // remove the section above when turning dynamic port mappings back on

    UN<CDynamicPortMappingCollection, IDynamicPortMappingCollection> un;
    return un.Create (ppDPMC);

    NAT_API_LEAVE
}

STDMETHODIMP CUPnPNAT::get_StaticPortMappingCollection (IStaticPortMappingCollection ** ppSPMC)
{
    NAT_API_ENTER

    UN<CStaticPortMappingCollection, IStaticPortMappingCollection> un;
    return un.Create (ppSPMC);

    NAT_API_LEAVE
}

// private method(s)
HRESULT GetOSInfoService (IUPnPService ** ppUPS)
{
    if (!ppUPS)
        return E_POINTER;
    *ppUPS = NULL;

    // either enum all netconnections, or
    // for downlevel, use Ken's object

    CComPtr<INetConnectionManager> spNCM = NULL;
    HRESULT hr = ::CoCreateInstance (CLSID_ConnectionManager,
                                     NULL,
                                     CLSCTX_ALL,
                                     __uuidof(INetConnectionManager),
                                     (void**)&spNCM);
    if (spNCM) {
        CComPtr<IEnumNetConnection> spENC = NULL;
        hr = spNCM->EnumConnections (NCME_DEFAULT, &spENC);
        if (spENC) {
            ULONG ul = 0;
            CComPtr<INetConnection> spNC = NULL;
            while (S_OK == spENC->Next (1, &spNC, &ul)) {
                NETCON_PROPERTIES * pProps = NULL;
                spNC->GetProperties (&pProps);
                if (pProps) {
                    NETCON_MEDIATYPE MediaType = pProps->MediaType;
                    NcFreeNetconProperties (pProps);
                    if ((MediaType == NCM_SHAREDACCESSHOST_LAN) ||
                        (MediaType == NCM_SHAREDACCESSHOST_RAS) ){
                        // found it
                        break;
                    }
                }
                spNC = NULL;
            }
            if (spNC) {
                CComPtr<INetSharedAccessConnection> spNSAC = NULL;
                hr = spNC->QueryInterface (__uuidof(INetSharedAccessConnection), (void**)&spNSAC);
                if (spNSAC)
                    hr = spNSAC->GetService (SAHOST_SERVICE_OSINFO, ppUPS);
            } else
                hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
        }
    } else {
        // downlevel
        CComPtr<IInternetGatewayFinder> spIGF = NULL;
        hr = ::CoCreateInstance (CLSID_CInternetGatewayFinder,
                                 NULL,
                                 CLSCTX_ALL,
                                 __uuidof(IInternetGatewayFinder),
                                 (void**)&spIGF);
        if (spIGF) {
            CComPtr<IInternetGateway> spIG = NULL;
            hr = spIGF->GetInternetGateway (NULL, &spIG);    // NULL gets default.
            if (spIG)
                hr = spIG->GetService (SAHOST_SERVICE_OSINFO, ppUPS);
        }
    }
    return hr;
}
BOOL IsICSHost ()
{
    CComPtr<IUPnPService> spOSI = NULL;
    GetOSInfoService (&spOSI);
    if (spOSI)
        return TRUE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\natupnp\sportmap.cpp ===
// SPortMap.cpp : Implementation of CStaticPortMapping
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "SPortMap.h"

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMapping

STDMETHODIMP CStaticPortMapping::get_ExternalIPAddress (BSTR *pVal)
{
    return m_spDPM->get_ExternalIPAddress (pVal);
}

STDMETHODIMP CStaticPortMapping::get_Description(BSTR *pVal)
{
    return m_spDPM->get_Description (pVal);
}

STDMETHODIMP CStaticPortMapping::get_ExternalPort(long *pVal)
{
    return m_spDPM->get_ExternalPort (pVal);
}

STDMETHODIMP CStaticPortMapping::get_Protocol(BSTR *pVal)
{
    return m_spDPM->get_Protocol (pVal);
}

STDMETHODIMP CStaticPortMapping::get_InternalPort(long *pVal)
{
    return m_spDPM->get_InternalPort (pVal);
}

STDMETHODIMP CStaticPortMapping::get_InternalClient(BSTR *pVal)
{
    return m_spDPM->get_InternalClient (pVal);
}

STDMETHODIMP CStaticPortMapping::get_Enabled(VARIANT_BOOL *pVal)
{
    return m_spDPM->get_Enabled (pVal);
}

STDMETHODIMP CStaticPortMapping::EditInternalClient (BSTR bstrInternalClient)
{
    return m_spDPM->EditInternalClient (bstrInternalClient);
}

STDMETHODIMP CStaticPortMapping::Enable (VARIANT_BOOL vb)
{
    return m_spDPM->Enable (vb);
}

STDMETHODIMP CStaticPortMapping::EditDescription (BSTR bstrDescription)
{
    return m_spDPM->EditDescription (bstrDescription);
}
 
STDMETHODIMP CStaticPortMapping::EditInternalPort (long lInternalPort)
{
    return m_spDPM->EditInternalPort (lInternalPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\bridge.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : bridge.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

extern ULONG            g_ulBridgeNumTopCmds;
extern ULONG            g_ulBridgeNumGroups;
extern CMD_ENTRY        g_BridgeCmds[];
extern CMD_GROUP_ENTRY  g_BridgeCmdGroups[];

FN_HANDLE_CMD  HandleBridgeSetAdapter;
FN_HANDLE_CMD  HandleBridgeShowAdapter;
FN_HANDLE_CMD  HandleBridgeInstall;
FN_HANDLE_CMD  HandleBridgeUninstall;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\bridge.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : bridge.cpp
//
//  Contents  : bridge context specific code
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

const TCHAR c_stRegKeyBridgeAdapters[]  =
    _T("SYSTEM\\CurrentControlSet\\Services\\Bridge\\Parameters\\Adapters");
const TCHAR c_stFCMode[]     = _T("ForceCompatibilityMode");


CMD_ENTRY  g_BridgeSetCmdTable[] = {
    CREATE_CMD_ENTRY(BRIDGE_SET_ADAPTER, HandleBridgeSetAdapter),
};

CMD_ENTRY  g_BridgeShowCmdTable[] = {
    CREATE_CMD_ENTRY(BRIDGE_SHOW_ADAPTER, HandleBridgeShowAdapter),
};


CMD_GROUP_ENTRY g_BridgeCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_BridgeSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_BridgeShowCmdTable),
};

ULONG g_ulBridgeNumGroups = sizeof(g_BridgeCmdGroups)/sizeof(CMD_GROUP_ENTRY);



CMD_ENTRY g_BridgeCmds[] =
{
    CREATE_CMD_ENTRY(INSTALL, HandleBridgeInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleBridgeUninstall),
};

ULONG g_ulBridgeNumTopCmds = sizeof(g_BridgeCmds)/sizeof(CMD_ENTRY);


DWORD WINAPI
BridgeDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    //
    // Output the string that shows our settings.
    // The idea here is to spit out a script that,
    // when run from the command line (netsh -f script)
    // will cause your component to be configured
    // exactly as it is when this dump command was run.
    //
    PrintMessageFromModule(
        g_hModule,
        DMP_BRIDGE_HEADER
        );
        
    PrintMessageFromModule(
        g_hModule,
        DMP_BRIDGE_FOOTER
        );

    return NO_ERROR;
    
} 



HRESULT
HrCycleBridge(
    IHNetBridge *pIHNetBridge
    )
{
    HRESULT hr = S_OK;
    
    //
    // Check to see if the bridge is up and running.
    // If it is, then disable and reenable
    //

    do
    {
        //
        // Get the pointer to IID_IHNetConnection interface of this
        // bridged connection
        //
        CComPtr<IHNetConnection> spIHNConn;

        hr = pIHNetBridge->QueryInterface(
                 IID_PPV_ARG(IHNetConnection, &spIHNConn)
                 );

        assert(SUCCEEDED(hr));
    
        if (FAILED(hr))
        {
            break;
        }

        INetConnection *pINetConn;

        hr = spIHNConn->GetINetConnection(&pINetConn);

        if (SUCCEEDED(hr))
        {
            NETCON_PROPERTIES* pNCProps;

            hr = pINetConn->GetProperties(&pNCProps);

            if(SUCCEEDED(hr))
            {
                //
                // check status - restart only if already running
                //
                if (pNCProps->Status == NCS_CONNECTED ||
                    pNCProps->Status == NCS_CONNECTING)
                {
                    pINetConn->Disconnect();

                    pINetConn->Connect();
                }
                
                NcFreeNetconProperties(pNCProps);
            }

            ReleaseObj(pINetConn);
        }
        
    } while(FALSE);
    
    return hr;
}


DWORD
SetBridgeAdapterInfo(
    DWORD   adapterId,
    BOOL    bFlag
    )
{
    DWORD           dwErr        = NO_ERROR;
    IHNetCfgMgr*    pIHNetCfgMgr = NULL;
    HRESULT         hr           = S_OK;

    hr = HrInitializeHomenetConfig(
             &g_fInitCom,
             &pIHNetCfgMgr
             );

    if (SUCCEEDED(hr))
    {
    {
        //
        // Get the IHNetBridgeSettings
        //
        CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;

        hr = pIHNetCfgMgr->QueryInterface(
                 IID_PPV_ARG(IHNetBridgeSettings, &spIHNetBridgeSettings)
                 );

        if (SUCCEEDED(hr))
        {
            //
            // Get the IEnumHNetBridges
            //
            CComPtr<IEnumHNetBridges> spehBridges;

            if ((hr = spIHNetBridgeSettings->EnumBridges(&spehBridges)) == S_OK)
            {
                //
                // Get the first IHNetBridge
                //
                CComPtr<IHNetBridge> spIHNetBridge;

                if ((hr = spehBridges->Next(1, &spIHNetBridge, NULL)) == S_OK)
                {
                    {
                        //
                        // We currently should have only one bridge;
                        // this may change in the future. The
                        // code here is just to catch future instances
                        // where this function would have to change in case
                        // there is more than one bridge.
                        //
                        CComPtr<IHNetBridge> spIHNetBridge2;

                        if ((hr = spehBridges->Next(1, &spIHNetBridge2, NULL)) == S_OK)
                        {
                            assert(FALSE);
                        }
                    }

                    //
                    // Get the IEnumHNetBridgedConnections
                    //
                    CComPtr<IEnumHNetBridgedConnections> spehBrdgConns;

                    if ((hr = spIHNetBridge->EnumMembers(&spehBrdgConns)) == S_OK)
                    {
                        //
                        // enumerate all the IHNetBridgedConnections
                        //                        
                        DWORD                   id = 0;
                        IHNetBridgedConnection* pIHNetBConn;

                        spehBrdgConns->Reset();
                        
                        while (S_OK == spehBrdgConns->Next(1, &pIHNetBConn, NULL))
                        {
                            id++;

                            if (id != adapterId)
                            {   
                                //
                                // release the IHNetBridgedConnection
                                //
                                ReleaseObj(pIHNetBConn);
                                continue;
                            }
                            
                            //
                            // Get the pointer to IID_IHNetConnection interface of this
                            // bridged connection
                            //
                            CComPtr<IHNetConnection> spIHNConn;

                            hr = pIHNetBConn->QueryInterface(
                                     IID_PPV_ARG(IHNetConnection, &spIHNConn)
                                     );
                            
                            assert(SUCCEEDED(hr));
                            
                            if (SUCCEEDED(hr))
                            {
                                GUID *pGuid = NULL;

                                hr = spIHNConn->GetGuid(&pGuid);

                                if (SUCCEEDED(hr) && (NULL != pGuid))
                                {
                                    PTCHAR pwszKey = NULL;
                                    int    keyLen;
                                    TCHAR  wszGuid[128];
                                    HKEY   hKey = NULL;
                                    DWORD  dwDisp = 0;
                                    BOOL   bCycleBridge = TRUE;
                                    DWORD  dwOldValue;
                                    DWORD  dwNewValue = (bFlag) ? 1 : 0;

                                    do
                                    {
                                        
                                        ZeroMemory(wszGuid, sizeof(wszGuid));

                                        StringFromGUID2(
                                            *pGuid,
                                            wszGuid,
                                            ARRAYSIZE(wszGuid)
                                            );

                                        keyLen = _tcslen(c_stRegKeyBridgeAdapters) +
                                                 _tcslen(_T("\\"))                 +
                                                 _tcslen(wszGuid)                  +
                                                 1;

                                        pwszKey = (TCHAR *) HeapAlloc(
                                                                GetProcessHeap(),
                                                                0,
                                                                keyLen * sizeof(TCHAR)
                                                                );
                                        if (!pwszKey)
                                        {
                                            break;
                                        }

                                        ZeroMemory(pwszKey, sizeof(pwszKey));
                                        _tcscpy(pwszKey, c_stRegKeyBridgeAdapters);
                                        _tcscat(pwszKey, _T("\\"));
                                        _tcscat(pwszKey, wszGuid);

                                        dwErr = RegCreateKeyEx(
                                                    HKEY_LOCAL_MACHINE,
                                                    pwszKey,
                                                    0,
                                                    NULL,
                                                    REG_OPTION_NON_VOLATILE,
                                                    KEY_ALL_ACCESS,
                                                    NULL,
                                                    &hKey,
                                                    &dwDisp
                                                    );

                                        if (ERROR_SUCCESS != dwErr)
                                        {
                                            break;
                                        }

                                        //
                                        // if the key was old, get its value

                                        // and compare to see if we need to
                                        // cycle the bridge
                                        //
                                        if (dwDisp &&
                                            dwDisp == REG_OPENED_EXISTING_KEY)
                                        {
                                            DWORD dwSize = sizeof(dwOldValue);
                    
                                            if (ERROR_SUCCESS == RegQueryValueEx(
                                                                     hKey,
                                                                     c_stFCMode,
                                                                     NULL,
                                                                     NULL,
                                                                     (LPBYTE)&dwOldValue,
                                                                     &dwSize))
                                            {
                                                if (dwOldValue == dwNewValue)
                                                {
                                                    //
                                                    // no need to cycle the bridge
                                                    //
                                                    bCycleBridge = FALSE;
                                                }
                                            }
                                        
                                        }
                                            
                                        dwErr = RegSetValueEx(
                                                    hKey,
                                                    c_stFCMode,
                                                    0,
                                                    REG_DWORD,
                                                    (LPBYTE) &dwNewValue,
                                                    sizeof(dwNewValue)
                                                    );

                                        if (ERROR_SUCCESS != dwErr)
                                        {
                                            break;
                                        }

                                        if (bCycleBridge)
                                        {
                                            //
                                            // cycle the (respective) bridge
                                            //
                                            hr = HrCycleBridge(
                                                     spIHNetBridge
                                                     );
                                        }

                                    } while(FALSE);

                                    //
                                    // cleanup
                                    //
                                    if (hKey)
                                    {
                                        RegCloseKey(hKey);
                                    }

                                    if (pwszKey)
                                    {
                                        HeapFree(GetProcessHeap(), 0, pwszKey);
                                    }

                                    CoTaskMemFree(pGuid);
                                }
                            }

                            //
                            // release the IHNetBridgedConnection
                            //
                            ReleaseObj(pIHNetBConn);

                            break;
                        } //while
                    }
                }
            }
        }
    }

        //
        // we are done completely
        //
        hr = HrUninitializeHomenetConfig(
                 g_fInitCom,
                 pIHNetCfgMgr
                 );
    }

    return (hr==S_OK) ? dwErr : hr;
}



DWORD
WINAPI
HandleBridgeSetAdapter(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
{
    DWORD           dwRet        = NO_ERROR;
    PDWORD          pdwTagType   = NULL;
    DWORD           dwNumOpt;
    DWORD           dwNumArg;
    DWORD           dwRes;
    DWORD           dwErrIndex   =-1,
                    i;

    //
    // default values
    //
    DWORD           id           = 0;
    DWORD           bFCMode      = FALSE;
    
    TAG_TYPE    pttTags[] =
    {
        {TOKEN_OPT_ID, NS_REQ_PRESENT, FALSE},
        {TOKEN_OPT_FCMODE, NS_REQ_ZERO, FALSE} // not required to allow for
                                               // addition of future flags
    };

    
    if (dwCurrentIndex >= dwArgCount)
    {
        // No arguments specified. At least interface name should be specified.

        return ERROR_INVALID_SYNTAX;
    }
        
    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = (DWORD *) HeapAlloc(
                               GetProcessHeap(),
                               0,
                               dwNumArg * sizeof(DWORD)
                               );

    if (NULL == pdwTagType)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwRet = PreprocessCommand(
                g_hModule,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pttTags,
                ARRAYSIZE(pttTags),
                1,                  // min args
                2,                  // max args
                pdwTagType
                );

    if (NO_ERROR != dwRet)
    {
        HeapFree(GetProcessHeap(), 0, pdwTagType);

        if (ERROR_INVALID_OPTION_TAG == dwRet)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwRet;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0:
            {
                //
                // refers to the 'id' field
                //
                id = _tcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
                break;
            }
            case 1:
            {
                //
                // refers to the 'forcecompatmode' field
                // possible values are : enable or disable
                //

                TOKEN_VALUE rgEnums[] = 
                {
                    {TOKEN_OPT_VALUE_ENABLE, TRUE},
                    {TOKEN_OPT_VALUE_DISABLE, FALSE}
                };
               
                dwRet = MatchEnumTag(
                            g_hModule,
                            ppwcArguments[i + dwCurrentIndex],
                            ARRAYSIZE(rgEnums),
                            rgEnums,
                            &dwRes
                            );         

                if (dwRet != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwRet = ERROR_INVALID_PARAMETER;
                    break;
                }    

                switch (dwRes)
                {
                    case 0:
                        bFCMode = FALSE;
                        break;

                    case 1:
                        bFCMode = TRUE;
                        break;
                }

                break;
            }
            default:
            {
                i = dwNumArg;
                dwRet = ERROR_INVALID_PARAMETER;
                break;
            }
        
        } //switch

        if (dwRet != NO_ERROR)
        {
            break ;
        }
            
    } //for

    //
    // adapter id MUST be present
    //
    
    if (!pttTags[0].bPresent)
    {
        dwRet = ERROR_INVALID_SYNTAX;
    }

    
    switch(dwRet)
    {
        case NO_ERROR:
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                PrintError(
                    g_hModule,
                    EMSG_BAD_OPTION_VALUE,
                    ppwcArguments[dwErrIndex + dwCurrentIndex],
                    pttTags[pdwTagType[dwErrIndex]].pwszTag
                    );
            }
            dwRet = ERROR_SUPPRESS_OUTPUT;
            break;
            
        default:
            //
            // error message already printed
            //
            break;
    }

    if (pdwTagType)
    {
        HeapFree(GetProcessHeap(), 0, pdwTagType);
    }

    if (NO_ERROR != dwRet)
    {
        return dwRet;
    }

    //
    // we have the requisite info - process them
    //

    //
    // since we may or may not have flag info, check for it
    //
    if (pttTags[1].bPresent)
    {
        dwRet = SetBridgeAdapterInfo(
                    id,
                    bFCMode
                    );
    }

    return dwRet;
}



DWORD
ShowBridgeAdapterInfo(
    DWORD            id,
    IHNetConnection  *pIHNConn
    )
{
    HRESULT hr;

    //
    // print out the bridged connections details
    //
    PWSTR pwszName = NULL;
    PWSTR pwszState = NULL;
    
    hr = pIHNConn->GetName(&pwszName);

    if (SUCCEEDED(hr) && (NULL != pwszName))
    {
        GUID *pGuid = NULL;

        hr = pIHNConn->GetGuid(&pGuid);

        if (SUCCEEDED(hr) && (NULL != pGuid))
        {
            WCHAR wszGuid[128];
            ZeroMemory(wszGuid, sizeof(wszGuid));
            StringFromGUID2(*pGuid, wszGuid, ARRAYSIZE(wszGuid));

            //
            // check to see if registry settings present
            //
            // for forcecompatmode:
            // + if   key is not present --> disabled
            // + if   key is     present
            //                   0x1     --> enabled
            //                   0x0     --> disabled
            // + all other errors        --> unknown
            //


            {
                HKEY    hBAKey;
                DWORD   msgState = STRING_UNKNOWN;

                if (ERROR_SUCCESS == RegOpenKeyEx(
                                         HKEY_LOCAL_MACHINE,
                                         c_stRegKeyBridgeAdapters,
                                         0,
                                         KEY_READ,
                                         &hBAKey))
                {
                    HKEY hBCKey;
                    
                    if (ERROR_SUCCESS == RegOpenKeyEx(
                                         hBAKey,
                                         wszGuid,
                                         0,
                                         KEY_READ,
                                         &hBCKey))
                    {
                        DWORD dwFCModeState = 0;
                        DWORD dwSize = sizeof(dwFCModeState);
                        
                        if (ERROR_SUCCESS == RegQueryValueEx(
                                                 hBCKey,
                                                 c_stFCMode,
                                                 NULL,
                                                 NULL,
                                                 (LPBYTE)&dwFCModeState,
                                                 &dwSize))
                        {
                            switch (dwFCModeState)
                            {
                                case 0:
                                    msgState = STRING_DISABLED;
                                    break;
                                case 1:
                                    msgState = STRING_ENABLED;
                                    break;
                                default:
                                    msgState = STRING_UNKNOWN;
                            }
                        }
                        else
                        {
                            //
                            // value not present
                            //
                            msgState = STRING_DISABLED;
                        }

                        RegCloseKey(hBCKey);
                    }
                    else
                    {
                        //
                        // bridged connection guid key not present
                        //
                        msgState = STRING_DISABLED;
                    }

                    RegCloseKey(hBAKey);
                }

                pwszState = MakeString(g_hModule, msgState);
            }


            PrintMessage(
                L" %1!2d! %2!-27s! %3!s!%n",
                id,
                pwszName,
                pwszState
                );

            if (pwszState)
            {
                FreeString(pwszState);
            }


            CoTaskMemFree(pGuid);
        }

        CoTaskMemFree(pwszName);
    }

    return NO_ERROR;
}



DWORD
ShowBridgeAllAdapterInfo(
    BOOL    bShowAll,               // TRUE to show all
    DWORD   adapterId               // valid only if bShowAll is FALSE
    )
{
    IHNetCfgMgr*    pIHNetCfgMgr = NULL;
    HRESULT         hr = S_OK;

    hr = HrInitializeHomenetConfig(
             &g_fInitCom,
             &pIHNetCfgMgr
             );

    if (SUCCEEDED(hr))
    {
    {
        //
        // Get the IHNetBridgeSettings
        //
        CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;

        hr = pIHNetCfgMgr->QueryInterface(
                 IID_PPV_ARG(IHNetBridgeSettings, &spIHNetBridgeSettings)
                 );

        if (SUCCEEDED(hr))
        {
            //
            // Get the IEnumHNetBridges
            //
            CComPtr<IEnumHNetBridges> spehBridges;

            if ((hr = spIHNetBridgeSettings->EnumBridges(&spehBridges)) == S_OK)
            {
                //
                // Get the first IHNetBridge
                //
                CComPtr<IHNetBridge> spIHNetBridge;

                if ((hr = spehBridges->Next(1, &spIHNetBridge, NULL)) == S_OK)
                {
                    {
                        //
                        // We currently should have only one bridge;
                        // this may change in the future. The
                        // code here is just to catch future instances
                        // where this function would have to change in case
                        // there is more than one bridge.
                        //
                        CComPtr<IHNetBridge> spIHNetBridge2;

                        if ((hr = spehBridges->Next(1, &spIHNetBridge2, NULL)) == S_OK)
                        {
                            assert(FALSE);
                        }
                    }

                    //
                    // Get the IEnumHNetBridgedConnections
                    //
                    CComPtr<IEnumHNetBridgedConnections> spehBrdgConns;

                    if ((hr = spIHNetBridge->EnumMembers(&spehBrdgConns)) == S_OK)
                    {
                        //
                        // spit out header for displaying the list
                        //
                        PrintMessageFromModule(
                            g_hModule,
                            MSG_BRIDGE_ADAPTER_INFO_HDR
                            );
                    
                        //
                        // enumerate all the IHNetBridgedConnections
                        //                        
                        DWORD                   id = 0;
                        IHNetBridgedConnection* pIHNetBConn;

                        spehBrdgConns->Reset();
                        
                        while (S_OK == spehBrdgConns->Next(1, &pIHNetBConn, NULL))
                        {
                            id++;

                            //
                            // check if we are looking for a specific id
                            //
                            if (FALSE == bShowAll && id != adapterId)
                            {   
                                //
                                // release the IHNetBridgedConnection
                                //
                                ReleaseObj(pIHNetBConn);
                                continue;
                            }
                            
                            //
                            // Get the pointer to IID_IHNetConnection interface of this
                            // bridged connection
                            //
                            CComPtr<IHNetConnection> spIHNConn;

                            hr = pIHNetBConn->QueryInterface(
                                     IID_PPV_ARG(IHNetConnection, &spIHNConn)
                                     );
                            
                            assert(SUCCEEDED(hr));
                            
                            if (SUCCEEDED(hr))
                            {
                                ShowBridgeAdapterInfo(
                                    id,
                                    spIHNConn
                                    );
                            }

                            //
                            // release the IHNetBridgedConnection
                            //
                            ReleaseObj(pIHNetBConn);

                            //
                            // if we reached here and we were looking for a
                            // specific id, our work is done - break out
                            //
                            if (FALSE == bShowAll)
                            {
                                break;
                            }
                        }

                        //
                        // spit out footer for displaying the list
                        //
                        PrintMessageFromModule(
                            g_hModule,
                            TABLE_SEPARATOR
                            );
                    }
                }
            }
        }
    }

        //
        // we are done completely
        //
        hr = HrUninitializeHomenetConfig(
                 g_fInitCom,
                 pIHNetCfgMgr
                 );
    }

    return (hr==S_OK) ? NO_ERROR : hr;

}



DWORD
WINAPI
HandleBridgeShowAdapter(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
/*++

Routine Description:

    Gets options for showing bridge adapter info

Arguements:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    IHNetCfgMgr*    pIHNetCfgMgr = NULL;
    HRESULT         hr = S_OK;
    BOOL            bShowAll = FALSE;
    DWORD           id = 0,
                    i,
                    dwRet = NO_ERROR,
                    dwNumOpt,
                    dwNumArg,
                    dwSize,
                    dwRes;
    PDWORD          pdwTagType = NULL;

    TAG_TYPE      pttTags[] = 
    {
        {TOKEN_OPT_ID, NS_REQ_ZERO, FALSE}
    };

    if (dwCurrentIndex > dwArgCount)
    {
        //
        // No arguments specified
        //
        return ERROR_INVALID_SYNTAX;
    }

    if (dwCurrentIndex == dwArgCount)
    {
        bShowAll = TRUE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = (DWORD *) HeapAlloc(
                               GetProcessHeap(),
                               0,
                               dwNumArg * sizeof(DWORD)
                               );

    if (dwNumArg && NULL == pdwTagType)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwRet = PreprocessCommand(
                g_hModule,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pttTags,
                ARRAYSIZE(pttTags),
                0,                  // min args
                1,                  // max args
                pdwTagType
                );

    if (NO_ERROR == dwRet)
    {
        //
        // process each argument...
        //
        for (i = 0; i < (dwArgCount - dwCurrentIndex); i++)
        {
            //
            // Check its corresponding value in the pdwTagType array.
            //
            switch (pdwTagType[i])
            {
                case 0:
                    //
                    // refers to the 'id' field
                    //
                    id = _tcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
                    break;
                default:
                    //
                    // Since there is only one valid value, means the arg
                    // wasn't recognized. Shouldn't reach this point because
                    // PreprocessCommand wouldn't have returned NO_ERROR if
                    // this was the case.
                    //
                    dwRet = ERROR_INVALID_SYNTAX;
                    break;
            }
        }

        dwRet = ShowBridgeAllAdapterInfo(
                    bShowAll,
                    id
                    ) ;        
    }
    else
    {
        dwRet = ERROR_SHOW_USAGE;
    }

    //
    // cleanup
    //
    if (pdwTagType)
    {
        HeapFree(GetProcessHeap(), 0, pdwTagType);
    }

    return dwRet;
}



DWORD
WINAPI
HandleBridgeInstall(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
{

    PrintMessageFromModule(
        g_hModule,
        HLP_BRIDGE_USE_GUI,
        CMD_INSTALL
        );

    return NO_ERROR;
}



DWORD
WINAPI
HandleBridgeUninstall(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
{
    PrintMessageFromModule(
        g_hModule,
        HLP_BRIDGE_USE_GUI,
        CMD_UNINSTALL
        );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include <winsock2.h>
#include <netsh.h>
#include <hnetcfg.h>

#include "strdefs.h"
#include "hnmstring.h"
#include "hnmbase.h"
#include "bridge.h"
#include "hnetmon.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\hnmbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnmbase.h
//
//  Contents  : Base include file for HNetMon. Includes ATL stuff.
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------
#pragma once

#ifndef __HNMBASE_H_
#define __HNMBASE_H_

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>

#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))


#ifndef AddRefObj
#define AddRefObj (obj)  (( obj ) ? (obj)->AddRef () : 0)
#endif

#ifndef ReleaseObj
#define ReleaseObj(obj)  (( obj ) ? (obj)->Release() : 0)
#endif



#endif  // __HNMBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\hnmstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnmstring.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 10 May 2001
//
//----------------------------------------------------------------------------

#define MSG_HELP_START L"%1!-14s! - "
#define MSG_NEWLINE _T("\n")

//
// The following are context names.
//
#define TOKEN_BRIDGE                           _T("bridge")


    // tokens for commands
#define TOKEN_COMMAND_ADD                      _T("add")
#define TOKEN_COMMAND_DELETE                   _T("delete")
#define TOKEN_COMMAND_SET                      _T("set")
#define TOKEN_COMMAND_SHOW                     _T("show")
#define TOKEN_COMMAND_HELP                     _T("help")
#define TOKEN_COMMAND_INSTALL                  _T("install")
#define TOKEN_COMMAND_UNINSTALL                _T("uninstall")

#define TOKEN_COMMAND_HELP1                    _T("/?")
#define TOKEN_COMMAND_HELP2                    _T("-?")

   // Bridge Adapter Options
#define TOKEN_OPT_ID                           _T("id")
#define TOKEN_OPT_FCMODE                       _T("forcecompatmode")

   // Bridge Adapter flag modes

   // Misc. option vlues
#define TOKEN_OPT_VALUE_INPUT                  _T("INPUT")
#define TOKEN_OPT_VALUE_OUTPUT                 _T("OUTPUT")

#define TOKEN_OPT_VALUE_ENABLE                 _T("enable")
#define TOKEN_OPT_VALUE_DISABLE                _T("disable")
#define TOKEN_OPT_VALUE_DEFAULT                _T("default")

#define TOKEN_OPT_VALUE_FULL                   _T("FULL")
#define TOKEN_OPT_VALUE_YES                    _T("YES")
#define TOKEN_OPT_VALUE_NO                     _T("NO")

#define TOKEN_HLPER_BRIDGE                     _T("bridge")

    // Commands for configuring the various protocols

    // tokens for commands required by most protocols

#define CMD_GROUP_ADD                          _T("add")
#define CMD_GROUP_DELETE                       _T("delete")
#define CMD_GROUP_SET                          _T("set")
#define CMD_GROUP_SHOW                         _T("show")

#define CMD_SHOW_HELPER                        _T("show helper")
#define CMD_INSTALL                            _T("install")
#define CMD_UNINSTALL                          _T("uninstall")
#define CMD_DUMP                               _T("dump")
#define CMD_HELP1                              _T("help")
#define CMD_HELP2                              _T("?")
#define CMD_ADD_HELPER                         _T("add helper")
#define CMD_DEL_HELPER                         _T("delete helper")

    // Bridge commands

    // Bridge add commands

#define CMD_BRIDGE_ADD_ADAPTER                 _T("adapter")

    // Bridge delete commands

#define CMD_BRIDGE_DEL_ADAPTER                 _T("adapter")

    // Bridge set commands

#define CMD_BRIDGE_SET_ADAPTER                 _T("adapter")

    // Bridge show commands

#define CMD_BRIDGE_SHOW_ADAPTER                _T("adapter")


    // Common dump commands

#define DMP_POPD                                L"\n\npopd\n"
#define DMP_UNINSTALL                           L"uninstall\n"

    // Bridge dump commands

#define DMP_BRIDGE_PUSHD                        L"\
pushd bridge\n"

#define DMP_BRIDGE_INSTALL                      _T("\
install\n")

#define DMP_BRIDGE_UNINSTALL                    _T("\
uninstall\n")

#define DMP_BRIDGE_DELETE_ADAPTER               _T("\
delete adapter name=%1!s! \n")

#define DMP_BRIDGE_ADD_ADAPTER                  _T("\
add adapter name=%1!s! \n")

#define DMP_BRIDGE_SET_ADAPTER                  _T("\
set adapter name=%1!s!\
 forcecompatmode=%2!d!\n")

    // Other strings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\hnetmon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnetmon.cpp
//
//  Contents  : helper initialization code
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

//
// Global variables.
//
HANDLE g_hModule = 0;



BOOL
WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            //DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //

            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}



DWORD
WINAPI
InitHelperDll(
    IN      DWORD           dwNetshVersion,
    OUT     PVOID           pReserved
    )
{   
    DWORD                   dwRet;
    NS_HELPER_ATTRIBUTES    attMyAttributes;

    //
    // Register helpers
    // We have a single helper only (BRIDGE)
    //
    
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.dwVersion      = BRIDGEMON_HELPER_VERSION;
    attMyAttributes.pfnStart       = BridgeStartHelper;
    attMyAttributes.pfnStop        = BridgeStopHelper;
    attMyAttributes.guidHelper     = g_BridgeGuid;
    
    //
    // Specify g_RootGuid as the parent helper to indicate 
    // that any contexts registered by this helper will be top 
    // level contexts.
    //
    dwRet = RegisterHelper(
                &g_RootGuid,
                &attMyAttributes
                );
                
    return dwRet;
}



DWORD
WINAPI
BridgeStartHelper(
    IN      CONST GUID *    pguidParent,
    IN      DWORD           dwVersion
    )
{
    DWORD                   dwRet = ERROR_INVALID_PARAMETER;
    NS_CONTEXT_ATTRIBUTES   attMyContextAttributes;

    ZeroMemory(&attMyContextAttributes, sizeof(attMyContextAttributes));
    
    attMyContextAttributes.dwVersion    = BRIDGEMON_HELPER_VERSION;
    attMyContextAttributes.dwFlags      = 0;
    attMyContextAttributes.ulPriority   = DEFAULT_CONTEXT_PRIORITY;
    attMyContextAttributes.pwszContext  = TOKEN_BRIDGE;
    attMyContextAttributes.guidHelper   = g_BridgeGuid;
    attMyContextAttributes.ulNumTopCmds = g_ulBridgeNumTopCmds;
    attMyContextAttributes.pTopCmds     = (CMD_ENTRY (*)[])g_BridgeCmds;
    attMyContextAttributes.ulNumGroups  = g_ulBridgeNumGroups;
    attMyContextAttributes.pCmdGroups   = (CMD_GROUP_ENTRY (*)[])g_BridgeCmdGroups;
    attMyContextAttributes.pfnCommitFn  = BridgeCommit;
    attMyContextAttributes.pfnConnectFn = BridgeConnect;
    attMyContextAttributes.pfnDumpFn    = BridgeDump;

    dwRet = RegisterContext(&attMyContextAttributes);
    
    return dwRet;
}



DWORD
WINAPI
BridgeStopHelper(
    IN  DWORD   dwReserved
    )
{
    return NO_ERROR;   
}



DWORD
WINAPI
BridgeCommit(
    IN  DWORD   dwAction
    )
{
    //
    // The handling of this action is admittedly simple in this example.
    // We simply have two copies of the data that we persist and consider
    // one the "online" set of data and one the "offline" set of data.
    // However, since neither the offline nor online sets of data need to
    // be "applied" to anything, it makes the distinction between them
    // somewhat meaningless.  The scheme used to support online/offline modes
    // is generally left up to the developer.
    //
    switch (dwAction)
    {
        case NETSH_COMMIT:
            //
            // Change to commit mode, otherwise known as online.
            //
            break;
            
        case NETSH_UNCOMMIT:
            //
            // Change to uncommit mode, otherwise known as offline.
            //
            break;
            
        case NETSH_FLUSH:
            //
            // Flush all uncommitted changes.
            //
            break;
            
        case NETSH_SAVE:
            //
            // Save all uncommitted changes.
            //            
            break;
            
        default:
            //
            // Not supported.
            //
            break;
    }       
    return NO_ERROR;
}



DWORD
WINAPI
BridgeConnect(
    IN  LPCWSTR pwszMachine
    )
{
    //
    // This function is called whenever the machine name changes.
    // If the context this was called for (you can specify a connect
    // function on a per context basis, see RegisterContext) is
    // supposed to be remotable, then the helper should verify
    // connectivity to the machine specified by pwszMachine and 
    // return an error if unable to reach the machine.
    //
    
    //
    // This is also where the helper might want to call RegisterContext
    // again on a context to remove or add commands at will.  This allows
    // the commands in your context to be dynamic, that is, commands
    // may be added and removed at will.  However, the versioning
    // functions tend to make a dynamic context unnecessary, as most
    // dynamic command changes are needed because of differing OS's the
    // commands are used on.  Note that NULL for pwszMachine indicates
    // that the machine to be connected to is the local machine.  When
    // and if the connect function returns an error code, the command
    // that was going to be executed (whether a context command or 
    // entering a context) will fail.
    //
    
    //
    // Uncomment this line to see how often the Connect function is called
    // and what gets passed to it.
    //
    //PrintMessageFromModule(g_hModule, GEN_CONNECT_SHOWSTRING, pwszMachine);
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\hnetmon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnetmon.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#define BRIDGEMON_HELPER_VERSION               1

//
// We need separate GUID's for each context we are registering,
// because each context has a different parent.  Contexts that
// have identical parents need not have differing GUID's
//
const GUID g_BridgeGuid = { /* 00770721-44ea-11d5-93ba-00b0d022dd1f */
    0x00770721,
    0x44ea,
    0x11d5,
    {0x93, 0xba, 0x00, 0xb0, 0xd0, 0x22, 0xdd, 0x1f}
  };

const GUID g_RootGuid   =   NETSH_ROOT_GUID;

//
// Function prototypes.
//
DWORD
WINAPI
InitHelperDll(
    IN      DWORD           dwNetshVersion,
    OUT     PVOID           pReserved
    );
    
DWORD
WINAPI
BridgeStartHelper(
    IN      CONST GUID *    pguidParent,
    IN      DWORD           dwVersion
    );

DWORD
WINAPI
BridgeStopHelper(
    IN  DWORD   dwReserved
    );

DWORD
WINAPI
BridgeCommit(
    IN  DWORD   dwAction
    );

DWORD
WINAPI
BridgeConnect(
    IN  LPCWSTR pwszMachine
    );

DWORD
WINAPI
BridgeDump(
    IN      LPCWSTR         pwszRouter,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwArgCount,
    IN      LPCVOID         pvData
    );


//
// externs
//
extern HANDLE g_hModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\strdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : strdefs.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 10 May 2001
//
//----------------------------------------------------------------------------

#ifndef __STRDEFS_H__
#define __STRDEFS_H__


// The string table entries that are identified here are arranged
// in a hierachy as follows

    // common hlp messages

    // command usage messages per protocol
        // show command usage
        // add command usage
        // delete command usage
        // set command usage

    // Output messages
        // Bridge messages
        // Miscellaneous messages

    // Strings
        // Protocol types
        // Miscellaneous strings

    // Error Messages
        // Bridge error messages

#define MSG_NULL                                1000

// commmon hlp messages

#define HLP_HELP                                2100
#define HLP_HELP_EX                             2101
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX
#define HLP_INSTALL                             2110
#define HLP_INSTALL_EX                          2111
#define HLP_UNINSTALL                           2112
#define HLP_UNINSTALL_EX                        2113
#define HLP_DUMP                                2120
#define HLP_DUMP_EX                             2121
#define HLP_GROUP_SET                           2150
#define HLP_GROUP_SHOW                          2151


// BRIDGE

// bridge install/uninstall
#define HLP_BRIDGE_INSTALL                      5000
#define HLP_BRIDGE_INSTALL_EX                   5001
#define HLP_BRIDGE_UNINSTALL                    5002
#define HLP_BRIDGE_UNINSTALL_EX                 5003
#define HLP_BRIDGE_USE_GUI                      5004

// bridge dump

#define DMP_BRIDGE_HEADER                       5010
#define DMP_BRIDGE_FOOTER                       5011

// bridge set hlp

#define HLP_BRIDGE_SET_ADAPTER                  5110
#define HLP_BRIDGE_SET_ADAPTER_EX               5111

// bridge show hlp

#define HLP_BRIDGE_SHOW_ADAPTER                 5210
#define HLP_BRIDGE_SHOW_ADAPTER_EX              5211


// Output messages

        // Bridge messages
#define MSG_BRIDGE_GLOBAL_INFO                  20501

#define MSG_BRIDGE_ADAPTER_INFO_HDR             20551
#define MSG_BRIDGE_ADAPTER_INFO                 20552

#define MSG_BRIDGE_FLAGS                        20553


        // Miscellaneous messages
#define MSG_OK                                  30001
#define MSG_NO_HELPER                           30002
#define MSG_NO_HELPERS                          30003
#define MSG_CTRL_C_TO_QUIT                      30004


// Strings

    // Protocol types
#define STRING_PROTO_OTHER                      31001
#define STRING_PROTO_BRIDGE                     31002

    // Miscellaneous strings
#define STRING_CREATED                          32001
#define STRING_DELETED                          32002
#define STRING_ENABLED                          32003
#define STRING_DISABLED                         32004

#define STRING_YES                              32011
#define STRING_NO                               32012
#define STRING_Y                                32013
#define STRING_N                                32014

#define STRING_UNKNOWN                          32100

#define TABLE_SEPARATOR                         32200

// Error messages

    // Bridge error messages
#define MSG_BRIDGE_PRESENT                      40100
#define MSG_BRIDGE_NOT_PRESENT                  40101

    // Miscellaneous messages
#define EMSG_BAD_OPTION_VALUE                   50100

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\utils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : utils.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

extern BOOL g_fInitCom;


HRESULT
HrInitializeHomenetConfig(
    BOOL*           pfInitCom,
    IHNetCfgMgr**   pphnc
    );

HRESULT
HrUninitializeHomenetConfig(
    BOOL            fUninitCom,
    IHNetCfgMgr*    phnc
    );

//
// useful extern functions
//

extern "C"
{

// from \rras\netsh\shell

LPWSTR
WINAPI
MakeString(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

VOID
WINAPI
FreeString(
    IN  LPWSTR pwszMadeString
    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\netsh\utils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : utils.cpp
//
//  Contents  : Common utilities required by helper.
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

BOOL g_fInitCom = TRUE;


HRESULT
HrInitializeHomenetConfig(
    BOOL*           pfInitCom,
    IHNetCfgMgr**   pphnc
    )
/*++

Routine Description

    Cocreate and initialize the root IHNetCfgMgr object.  This will
    optionally initialize COM for the caller too.

Arguments

    pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
                               returns TRUE if COM was successfully
                               initialized FALSE if not.
                               If NULL, means don't initialize COM.
    pphnc           [out]      The returned IHNetCfgMgr object.
    
Return Value

    S_OK or an error code.
    
--*/
{
    HRESULT hr;
    

    //
    // Initialize the output parameter.
    //
    *pphnc = NULL;


    //
    // Initialize COM if the caller requested.
    //
    hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx(
                 NULL,
                 COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED
                 );

        if (RPC_E_CHANGED_MODE == hr)
        {
            //
            // we have already been initialized in a different model
            //
            hr = S_OK;
            *pfInitCom = FALSE;
        }
    }
    
    if (SUCCEEDED(hr))
    {

        //
        // Create Homenet Configuration Manager COM Instance
        //
        hr = CoCreateInstance(
                 CLSID_HNetCfgMgr,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_PPV_ARG(IHNetCfgMgr, pphnc)
                 );

        if (SUCCEEDED(hr))
        {
            //
            // great! dont need to anything more here...
            //
        }

        //
        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize();
        }

    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeHomenetConfig
//
//  Purpose:    Unintialize and release an IHNetCfgMgr object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the IHNetCfgMgr is
//                      uninitialized and released.
//      phnc       [in] The IHNetCfgMgr object.
//
//  Returns:    S_OK or an error code.
//
//  Author:     rgatta 11 May 2001
//
//----------------------------------------------------------------------------
HRESULT
HrUninitializeHomenetConfig(
    BOOL            fUninitCom,
    IHNetCfgMgr*    phnc
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    assert(phnc);
    HRESULT hr = S_OK;

    if (phnc)
    {
        phnc->Release();
    }
    
    phnc = NULL;

    if (fUninitCom)
    {
        CoUninitialize ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\clientapi.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ClientApi.c

Abstract:

    User-mode interface to HTTP.SYS: Client-side APIs

Author:

    Rajesh Sundaram (rajeshsu)    1-Aug-2000

Revision History:

--*/


#include "precomp.h"
#include <stdio.h>

//
// Private macros.
//

#define HTTP_PREFIX_W       L"HTTP://"
#define HTTP_PREFIX_LENGTH  (sizeof(HTTP_PREFIX_W) - sizeof(WCHAR))
#define HTTPS_PREFIX_W      L"HTTPS://"
#define HTTPS_PREFIX_LENGTH (sizeof(HTTPS_PREFIX_W) - sizeof(WCHAR))

#define HTTP_DEFAULT_PORT   80
#define HTTPS_DEFAULT_PORT  443

//
// Ssl stream filter stuff.
//

WCHAR   g_StrmFilt[]          = L"strmfilt.dll";
LONG    g_bStrmFiltLoaded     = 0;
HMODULE g_hStrmFilt           = NULL;
FARPROC g_pStrmFiltInitialize = NULL;
FARPROC g_pStrmFiltStart      = NULL;
FARPROC g_pStrmFiltStop       = NULL;
FARPROC g_pStrmFiltTerminate  = NULL;
extern  CRITICAL_SECTION        g_InitCritSec;


#ifndef DBG

#define DbgCriticalSectionOwned(pcs) (TRUE)

#else

/***************************************************************************++

Routine Description:

    This routine determines if the calling thread owns a critical section.

Arguments:

    pcs - Pointer to CRITICAL_SECTION.

Return Value:

    BOOLEAN

--***************************************************************************/
BOOLEAN
DbgCriticalSectionOwned(
    PCRITICAL_SECTION pcs
    )
{
#define HANDLE_TO_DWORD(Handle) ((DWORD)PtrToUlong(Handle))

    if (pcs->LockCount >= 0 &&
        HANDLE_TO_DWORD(pcs->OwningThread) == GetCurrentThreadId())
    {
        return TRUE;
    }

    return FALSE;
}

#endif


/***************************************************************************++

Routine Description:

    This function resolves a name to an IP.

Arguments:

    pServerName      - The name to be resolved.
    ServerNameLength - Length of the name (in WCHAR).

Return Value:

    DWORD - Completion status.

--***************************************************************************/
DWORD
ResolveName(
    IN  PWCHAR              pServerName,
    IN  USHORT              ServerNameLength,
    IN  USHORT              PortNumber,
    OUT PTRANSPORT_ADDRESS *pTransportAddress,
    OUT PUSHORT             TransportAddressLength
    )
{
    LPSTR            pBuffer;
    ULONG            BufferLen;
    struct           addrinfo *pAi, *pTempAi;
    ULONG            AiLen, AiCount;
    DWORD            dwResult;
    PTA_ADDRESS      CurrentAddress;

   
    //
    // We need space to store the ANSI version of the name.
    //

    BufferLen = WideCharToMultiByte(
                           CP_ACP,
                           0,
                           pServerName,
                           ServerNameLength,
                           NULL,
                           0,
                           NULL,
                           NULL);

    if(!BufferLen)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Account for '\0'
    //
 
    BufferLen = BufferLen + 1;

    pBuffer = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              BufferLen
                              );

    if(!pBuffer)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    //
    // Convert the name to ANSI.
    //
    
    if(WideCharToMultiByte(CP_ACP,
                           0,
                           pServerName,
                           ServerNameLength,
                           pBuffer,
                           BufferLen-1,
                           NULL,
                           NULL) == 0)
    {
        dwResult = GetLastError();

        RtlFreeHeap(RtlProcessHeap(),
                    0,
                    pBuffer);

        return dwResult;
    }

    //
    // NULL terminate it.
    //

    *(pBuffer + BufferLen - 1) = 0;


    //
    // Resolve it.
    //

    if((dwResult = getaddrinfo(pBuffer, NULL, 0, &pAi)) != 0)
    {
        RtlFreeHeap(RtlProcessHeap(),
                    0,
                    pBuffer);

        return dwResult;
    }
    else 
    { 
        //
        // Compute size of all entries returned by getaddrinfo
        //

        pTempAi = pAi;
        AiLen   = 0;
        AiCount = 0;

        while(pAi != NULL)
        {
            if(pAi->ai_family == PF_INET || pAi->ai_family == AF_INET6)
            {
                AiCount ++;

                //
                // ai_addrlength includes the size of the AddressType,
                // but TA_ADDRESS expects AddressLength to exclude this.
                //

                AiLen = AiLen + 
                            ((ULONG)pAi->ai_addrlen - 
                             RTL_FIELD_SIZE(TA_ADDRESS, AddressType));
            }
    
            pAi = pAi->ai_next;
        }

        if(AiCount == 0)
        {
            // No addresses found.
            return ERROR_INVALID_PARAMETER;
        }

        AiLen += ((AiCount * FIELD_OFFSET(TA_ADDRESS, Address)) + 
                 FIELD_OFFSET(TRANSPORT_ADDRESS, Address));

        if(BufferLen >= AiLen)
        {
            *pTransportAddress = (PTRANSPORT_ADDRESS) pBuffer;
        }
        else
        {
            RtlFreeHeap(RtlProcessHeap(),
                        0,
                        pBuffer
                        );
            
            *pTransportAddress =  (PTRANSPORT_ADDRESS) 
                                     RtlAllocateHeap(RtlProcessHeap(),
                                                     0,
                                                     AiLen
                                                    );

            if(!*pTransportAddress)
            {
                freeaddrinfo(pAi);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    
    
        //
        // Convert this to a Transport Address.
        //

        pAi = pTempAi;

        (*pTransportAddress)->TAAddressCount = AiCount;

        CurrentAddress = (*pTransportAddress)->Address;

        while(pAi != NULL)
        {
            switch(pAi->ai_family)
            {
                case PF_INET:
                case PF_INET6:
                    //
                    // ai_addrlength includes the size of the AddressType,
                    // but TA_ADDRESS expects AddressLength to exclude this.
                    //
                    CurrentAddress->AddressLength = 
                            (USHORT)
                                pAi->ai_addrlen - 
                                    RTL_FIELD_SIZE(TA_ADDRESS, AddressType);
                     
                    CurrentAddress->AddressType = pAi->ai_addr->sa_family;

                    RtlCopyMemory(
                            &CurrentAddress->Address,
                            pAi->ai_addr->sa_data,
                            CurrentAddress->AddressLength
                            );

                    if(PF_INET == pAi->ai_family)
                    {
                        ((TDI_ADDRESS_IP *)
                            CurrentAddress->Address)->sin_port =
                                htons(PortNumber);
                    }
                    else
                    {
                        ((TDI_ADDRESS_IP6 *)
                            CurrentAddress->Address)->sin6_port = 
                                htons(PortNumber);
                    }
    
                    CurrentAddress = (PTA_ADDRESS)
                                    (CurrentAddress->Address + 
                                      CurrentAddress->AddressLength);
    
                    break;

                default:
                    break;
    
            }

            pAi = pAi->ai_next;
        }

        *TransportAddressLength = (USHORT) AiLen;

        freeaddrinfo(pTempAi);
    }

    return NO_ERROR;
}


/***************************************************************************++

Routine Description:

    This function takes in a string (of the form "Hostname[:PortNumber]"),
    performs DNS lookup on "Hostname".  Returns a TRANSPORT_ADDRESS
    containing the resolved Host address and port number.

    Hostname can be:
        hostname (e.g. foo.bar.com) or
        IPv4 address (e.g. 128.101.35.201) or
        IPv6 address (e.g. [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210])

    This Function is a HACK and will go away when we do DNS in the kernel.

Arguments:

    pServerLocationStr      - (Input) Hostname:PortNumber string 
    ServerLocationStrLength - (Input) Server Location string length
    pTransportAddress       - (Output) Transport address (and port) of Server
    TransportAddressLength  - (Output) Length of the structure pointed to by
                                       pTransportAddress

Return Value:

    DWORD - Completion status.

--***************************************************************************/
DWORD
ProcessHostAndPort(
    IN  PWCHAR               pServerLocationStr,
    IN  USHORT               ServerLocationStrLength,
    IN  USHORT               DefaultPort,
    OUT PTRANSPORT_ADDRESS  *pTransportAddress,
    OUT PUSHORT              pTransportAddressLength
    )
{
    DWORD  Status;
    ULONG  PortNumber = 0;
    PWSTR  ptr;
    PWSTR  pEndStr = pServerLocationStr + 
                    (ServerLocationStrLength/sizeof(WCHAR));

    PWSTR pStartHostname = pServerLocationStr;
    PWSTR pEndHostname = pEndStr;  // may change due to presence of port #

    //
    // Empty Host String?
    //
    if (pEndStr == pServerLocationStr)
        return ERROR_INVALID_PARAMETER;

    //
    // check if the HostStr contains IPv6 address (RFC 2732)
    //
    if (*pServerLocationStr == L'[')
    {
        // skip '['
        pStartHostname = pServerLocationStr + 1;

        // find the matching ']'
        for (ptr = pServerLocationStr+1; ptr != pEndStr && *ptr != L']'; ptr++)
            /* do nothing */;

        // missing ']'?
        if (ptr == pEndStr)
            return ERROR_INVALID_PARAMETER;

        // IPv6 host address ends here
        pEndHostname = ptr;

        // skip ']'
        ptr++;

        if (ptr != pEndStr && *ptr != L':')
            return ERROR_INVALID_PARAMETER;
    }
    else // Host name or IPv4 address is present
    {
        pStartHostname = pServerLocationStr;

        // Check if a port number is present 
        for (ptr = pServerLocationStr; ptr != pEndStr && *ptr != L':'; ptr++)
            /* do nothing */;

        pEndHostname = ptr;
    }

    // If a port number is present...grab it.
    if (ptr != pEndStr)
    {
        ASSERT(*ptr == L':');

        for (ptr++; ptr != pEndStr; ptr++)
        {
            if (!iswdigit(*ptr))
            {
                // Junk instead of digits
                return ERROR_INVALID_PARAMETER;
            }

            PortNumber = 10*PortNumber + (ULONG)(*ptr - L'0');

            // Port numbers are only 16 bit wide
            if (PortNumber >= (ULONG)(1<<16))
            {
                return ERROR_INVALID_PARAMETER;
            }
        }

    }

    if(PortNumber == 0)
    {
        PortNumber = DefaultPort;
    }

    Status = ResolveName(pStartHostname,
                         (USHORT) (pEndHostname-pStartHostname),
                         (USHORT)PortNumber,
                         pTransportAddress,
                         pTransportAddressLength
                        );
    return Status;
}


/****************************************************************************++

Routine Description:

    Loads dymanically linked library strmfilt.dll.
    If the library is already loaded, it returns NO_ERROR

Arguments:

    None.

Return Value:

    NO_ERROR - Library was loaded (now or previously) successfully
    Other errors as encountered.

--****************************************************************************/
DWORD
LoadStrmFilt(
    VOID
    )
{
    LONG    OldValue;
    HRESULT hr;
    DWORD   Error;

    //
    // Quick check outside the lock to see if the library is already loaded.
    //

    if (g_bStrmFiltLoaded)
    {
        return NO_ERROR;
    }

    //
    // Make sure there is no other thread trying to load the library.
    //

    EnterCriticalSection(&g_InitCritSec);

    if (g_bStrmFiltLoaded == 0)
    {
        //
        // Library is not loaded.  Proceed to load StrmFilt.dll.
        //

        g_hStrmFilt = LoadLibrary(g_StrmFilt);

        if (g_hStrmFilt == NULL)
        {
            Error = GetLastError();
            goto Quit;
        }

        //
        // Get addresses of the following procedures:
        //    StreamFilterClientInitialize, StreamFilterClientTerminate
        //    StreamFilterClientStart, StreamFilterClientStop
        //

        g_pStrmFiltInitialize = GetProcAddress(g_hStrmFilt,
                                               "StreamFilterClientInitialize");

        if (g_pStrmFiltInitialize == NULL)
        {
            Error = GetLastError();
            goto Unload;
        }

        g_pStrmFiltStart = GetProcAddress(g_hStrmFilt, "StreamFilterClientStart");

        if (g_pStrmFiltStart == NULL)
        {
            Error = GetLastError();
            goto Unload;
        }

        g_pStrmFiltStop = GetProcAddress(g_hStrmFilt, "StreamFilterClientStop");

        if (g_pStrmFiltStop == NULL)
        {
            Error = GetLastError();
            goto Unload;
        }

        g_pStrmFiltTerminate  = GetProcAddress(g_hStrmFilt,
                                               "StreamFilterClientTerminate");

        if (g_pStrmFiltTerminate == NULL)
        {
            Error = GetLastError();
            goto Unload;
        }

        //
        // Try to initialize StrmFilt.
        //

        hr = (HRESULT)g_pStrmFiltInitialize();

        if (SUCCEEDED(hr))
        {
            //
            // StrmFilt initialized suceessfully.  Now try to start it.
            //

            hr = (HRESULT)g_pStrmFiltStart();

            if (FAILED(hr))
            {
                //
                // Could not start StrmFilt.  Terminate it!
                //

                g_pStrmFiltTerminate();
            }
        }

        if (FAILED(hr))
        {
            Error = (DWORD)hr;
            goto Unload;
        }

        //
        // Remember that StrmFilt has been loaded and initialized.
        // Atomically set bStrmFilt to 1.  The reason for atomic operation
        // is that g_bStrmFiltLoaded can be read without a lock.
        //

        OldValue = InterlockedExchange(&g_bStrmFiltLoaded, 1);

        //
        // g_bStrmFiltLoaded is always set to 1 under g_InitCritSec.
        //

        ASSERT(OldValue == 0);
    }

    //
    // This is the normal case, when everything went OK.
    //

    LeaveCriticalSection(&g_InitCritSec);

    return NO_ERROR;

    //
    //  Erroneous cases come here.
    //

 Unload:
    //
    // Set these function pointers so that they aren't be used.
    //

    g_pStrmFiltInitialize = NULL;
    g_pStrmFiltStart      = NULL;
    g_pStrmFiltStop       = NULL;
    g_pStrmFiltTerminate  = NULL;

    //
    // Unload strmfilt.dll.
    //

    ASSERT(g_hStrmFilt);

    FreeLibrary(g_hStrmFilt);

    g_hStrmFilt = NULL;

 Quit:

    LeaveCriticalSection(&g_InitCritSec);

    return Error;
}


/****************************************************************************++

Routine Description:

    Unloads strmfilt.dll, if loaded previously.
    This routine is called inside g_InitCritSec critical section.

Arguments:

    None.

Return Value:

    NO_ERROR if strmfilt.dll successfully unloaded.
    Other errors as encountered.

--****************************************************************************/
DWORD
UnloadStrmFilt(
    VOID
    )
{
    LONG    OldValue;

    ASSERT(DbgCriticalSectionOwned(&g_InitCritSec));

    OldValue = InterlockedExchange(&g_bStrmFiltLoaded, 0);

    //
    // Has strmfilt been initialized before?
    //

    if (OldValue == 0)
    {
        return ERROR_NOT_FOUND;
    }

    ASSERT(OldValue == 1);

    //
    // Sanity checks.
    //

    ASSERT(g_pStrmFiltInitialize);
    ASSERT(g_pStrmFiltStart);
    ASSERT(g_pStrmFiltStop);
    ASSERT(g_pStrmFiltTerminate);

    //
    // Stop StreamFilter and terminate it.
    //

    g_pStrmFiltStop();
    g_pStrmFiltTerminate();

    //
    // Set these function pointers so that they aren't used.
    //

    g_pStrmFiltInitialize = NULL;
    g_pStrmFiltStart      = NULL;
    g_pStrmFiltStop       = NULL;
    g_pStrmFiltTerminate  = NULL;

    //
    // Unload strmfilt.dll.
    //

    ASSERT(g_hStrmFilt);

    FreeLibrary(g_hStrmFilt);

    g_hStrmFilt = NULL;

    return NO_ERROR;
}


/***************************************************************************++

Routine Description:

    This is the first api that an application uses before it can talk to a
    server. This call creates a NT FileHandle for the origin server

Arguments:

    ServerNameLength     - The Length of server name
    pServerName          - The Full URI (starts with http[s]://servername/...)
    dwServerFlags        - Flags
    pConfigInfo          - Array of config objects
    pReserved            - Must be NULL
    pServerHandle        - The File Handle

Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG 
WINAPI
HttpInitializeServerContext(    
        IN    USHORT                 ServerNameLength,
        IN    PWCHAR                 pServerName,
        IN    USHORT                 ProxyLength            OPTIONAL,
        IN    PWCHAR                 pProxy                 OPTIONAL,
        IN    ULONG                  ServerFlags            OPTIONAL,
        IN    PVOID                  pReserved,
        OUT   PHANDLE                pServerHandle
    )
{
    
    NTSTATUS             Status;
    ULONG                Win32Status;
    PTRANSPORT_ADDRESS   pTransportAddress;
    USHORT               TransportAddressLength = 0;
    DWORD                CreateDisposition;
    PWCHAR               pServerNameStart = NULL;
    USHORT               DefaultPort;

    if(ServerFlags != 0 || pReserved != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    CreateDisposition = FILE_CREATE;


    //
    // Process the scheme name. We need at least one character after the 
    // http:// or https://, so the comparision is > instead of >=
    //

    if(ServerNameLength > HTTP_PREFIX_LENGTH)
    {
        if (_wcsnicmp(pServerName,
                      HTTP_PREFIX_W,
                      HTTP_PREFIX_LENGTH/sizeof(WCHAR)) == 0)
        {
            pServerNameStart = pServerName + 
                                    (HTTP_PREFIX_LENGTH/sizeof(WCHAR));
            DefaultPort = HTTP_DEFAULT_PORT;
        }
        else if(ServerNameLength > HTTPS_PREFIX_LENGTH)
        {
            if (_wcsnicmp(pServerName,
                          HTTPS_PREFIX_W,
                          HTTPS_PREFIX_LENGTH/sizeof(WCHAR)) == 0)
            {
                pServerNameStart = pServerName + 
                                        (HTTPS_PREFIX_LENGTH/sizeof(WCHAR));

                //
                // If an HTTPS server is being initialized, load strmfilt.dll
                //
                
                DefaultPort = HTTPS_DEFAULT_PORT;

                Win32Status = LoadStrmFilt();

                if (Win32Status != NO_ERROR)
                {
                    return Win32Status;
                }
            }
            else
            {
                // neither http:// nor https://
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            // Not enough space to compare https://
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // Not enough space to compare http://
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT(pServerNameStart != NULL);

    //
    // We don't do DNS in the kernel yet, so for now, we'll do DNS resolution
    // in user mode and pass the IP address across the boundary. This hack
    // has to be removed when we get DNS support in the kernel.
    //

    if(ProxyLength)
    {
        // The user has supplied a proxy, we don't have to resolve the 
        // server name.
        //
      
        DefaultPort = HTTP_DEFAULT_PORT; 
        if((Win32Status = ProcessHostAndPort(pProxy,
                                             ProxyLength,
                                             DefaultPort,
                                             &pTransportAddress,
                                             &TransportAddressLength
                                             ))
           != NO_ERROR)
        {
            return Win32Status;
        }
    }
    else
    {
        PWCHAR pServerNameEnd;
        PWCHAR pUriEnd = pServerName + (ServerNameLength / sizeof(WCHAR));

        //
        // At this point pUri points to the first thing after the scheme. Walk
        // through the URI until either we hit the end or find a terminating /.
        //

        // By the comparision above, we are guaranteed to have at least one
        // character

        ASSERT(pUriEnd != pServerNameStart);
    
        pServerNameEnd = pServerNameStart;
    
        while(*pServerNameEnd != L'/')
        {
            pServerNameEnd ++;

            // See if we still have URI left to examine.
    
            if (pServerNameEnd == pUriEnd)
            {
                break;
            }
        }

        // Check for a zero server name -         
        if(pServerNameStart == pServerNameEnd)
        {
            return ERROR_INVALID_PARAMETER;
        }
    
        if((Win32Status = 
                ProcessHostAndPort(
                   pServerNameStart, 
                   (USHORT) (pServerNameEnd - pServerNameStart) * sizeof(WCHAR),
                   DefaultPort,
                   &pTransportAddress,
                   &TransportAddressLength)) != NO_ERROR)
        {
            return Win32Status;
        }   
    }


    Status = HttpApiOpenDriverHelper(
                pServerHandle,     
                pServerName,                         // URI
                ServerNameLength,
                pProxy,                              // Proxy
                ProxyLength,
                pTransportAddress,
                TransportAddressLength,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Acces
                HttpApiServerHandleType,
                0,                                   // Object Name
                0,                                   // Options
                CreateDisposition,                   // createDisposition
                NULL
                );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //
    
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        Status == STATUS_OBJECT_PATH_NOT_FOUND)
    { 
        if (HttpApiTryToStartDriver(HTTP_SERVICE_NAME))
        {
            Status = HttpApiOpenDriverHelper(
                        pServerHandle,
                        pServerName,                    // URI
                        ServerNameLength,
                        pProxy,                         // Proxy
                        ProxyLength,
                        pTransportAddress,
                        TransportAddressLength,
                        GENERIC_READ | GENERIC_WRITE |
                        SYNCHRONIZE,                    // Desired Acces
                        HttpApiServerHandleType,
                        0,                              // Object Name
                        0,                              // Options
                        CreateDisposition,              // createDisposition
                        NULL
                        );
        }
    }

    //
    // Need to free the pTransportAddress
    //
    RtlFreeHeap(RtlProcessHeap(),
                0,
                pTransportAddress
               );

    return HttpApiNtStatusToWin32Status( Status ); 
}


/***************************************************************************++

Routine Description:
    Sends an HTTP request.

Arguments:
    ServerHandle         - Supplies the handle corresponding to a particular 
                           server.
                           This is the handle as returned by 
                           HttpInitializeServerContext.
    pHttpRequest         - The HTTP request.
    HttpRequestFlags     - The Request Flags.
    pConfig              - Config information for this request.
    pOverlapped          - Overlapped structure for Overlapped I/O.
    ResponseBufferLength - Contains the response buffer length.
    ResponseBuffer       - A pointer to a buffer to return the response.
    pBytesReceived       - The # of bytes that actually got written.
    pRequestID           - A pointer to a request identifier - This will return an 
                           ID that can be used in subsequent calls.
Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG 
WINAPI
HttpSendHttpRequest(
    IN      HANDLE               ServerHandle,
    IN      PHTTP_REQUEST        pHttpRequest,
    IN      ULONG                HttpRequestFlags,
    IN      USHORT               RequestConfigCount      OPTIONAL,
    IN      PHTTP_REQUEST_CONFIG pRequestConfig          OPTIONAL,
    IN      LPOVERLAPPED         pOverlapped             OPTIONAL,
    IN      ULONG                ResponseBufferLength    OPTIONAL,
    OUT     PHTTP_RESPONSE       pResponseBuffer         OPTIONAL,
    IN      ULONG                Reserved,               // must be 0
    OUT     PVOID                pReserved,              // must be NULL
    OUT     PULONG               pBytesReceived          OPTIONAL,
    OUT     PHTTP_REQUEST_ID     pRequestID
    )
{
    HTTP_SEND_REQUEST_INPUT_INFO  HttpSendRequestInput;

    if(Reserved != 0 || pReserved != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory(&HttpSendRequestInput, 
                  sizeof(HTTP_SEND_REQUEST_INPUT_INFO));

    HTTP_SET_NULL_ID(pRequestID);
    HttpSendRequestInput.pHttpRequestId        = pRequestID;
    HttpSendRequestInput.pHttpRequest          = pHttpRequest;
    HttpSendRequestInput.HttpRequestFlags      = HttpRequestFlags;
    HttpSendRequestInput.pRequestConfig        = pRequestConfig;
    HttpSendRequestInput.RequestConfigCount    = RequestConfigCount;
    HttpSendRequestInput.pBytesTaken           = pBytesReceived;

    return HttpApiDeviceControl(
                ServerHandle,                  // FileHandle
                pOverlapped,                   // Overlapped
                IOCTL_HTTP_SEND_REQUEST,       // IO Control code
                &HttpSendRequestInput,         // InputBuffer
                sizeof(HttpSendRequestInput),  // InputBufferLength
                pResponseBuffer,               // Output Buffer
                ResponseBufferLength,          // Output Buffer length
                pBytesReceived
               );
}    


/***************************************************************************++

Routine Description:
    Sends additional entity bodies.

Arguments:
    ServerHandle         - Supplies the handle corresponding to a particular 
                           server.
                           This is the handle as returned by 
                           HttpInitializeServerContext.
    RequestID            - The request ID that was returned by HttpSendRequest.
    Flags                - The Request Flags.
    pOverlapped          - Overlapped structure for Overlapped I/O.
    EntityBodyLength     - The count of entity bodies.
    pHttpEntityBody      - The pointer to the entity bodies.            
                           ID that can be used in subsequent calls.
Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG 
WINAPI
HttpSendRequestEntityBody( 
                    IN  HANDLE              ServerHandle,
                    IN  HTTP_REQUEST_ID     RequestID,
                    IN  ULONG               Flags,
                    IN  USHORT              EntityBodyCount,
                    IN  PHTTP_DATA_CHUNK    pHttpEntityBody,
                    IN  LPOVERLAPPED        pOverlapped        OPTIONAL
                    )
{
    HTTP_SEND_REQUEST_ENTITY_BODY_INFO  HttpEntity;

    RtlZeroMemory(&HttpEntity, sizeof(HTTP_SEND_REQUEST_ENTITY_BODY_INFO));

    HttpEntity.EntityChunkCount  = EntityBodyCount;
    HttpEntity.Flags             = Flags;
    HttpEntity.RequestID         = RequestID;
    HttpEntity.pHttpEntityChunk  = pHttpEntityBody;

    return HttpApiDeviceControl(
                ServerHandle,                        // FileHandle
                pOverlapped,                         // Overlapped
                IOCTL_HTTP_SEND_REQUEST_ENTITY_BODY, // IO Control code
                &HttpEntity,                         // InputBuffer
                sizeof(HttpEntity),                  // InputBufferLength
                NULL,                                // ResponseBuffer
                0,                                   // Output Buffer length
                NULL                                 // Bytes received.
                );
}    


/***************************************************************************++

Routine Description:
    Receives the response

Arguments:
    ServerHandle         - Supplies the handle corresponding to a particular 
                           server.This is the handle as returned by 
                           HttpInitializeServerContext.
    RequestID            - The request ID that was returned by HttpSendRequest.
    Flags                - The Request Flags.
    pOverlapped          - Overlapped structure for Overlapped I/O.
    EntityBodyLength     - The count of entity bodies.
    pHttpEntityBody      - The pointer to the entity bodies.            
                           ID that can be used in subsequent calls.
Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG 
WINAPI
HttpReceiveHttpResponse(
    IN      HANDLE            ServerHandle,
    IN      HTTP_REQUEST_ID   RequestID,
    IN      ULONG             Flags,
    IN      ULONG             ResponseBufferLength,
    OUT     PHTTP_RESPONSE    pResponseBuffer,
    IN      ULONG             Reserved,               // must be 0
    OUT     PVOID             pReserved,              // must be NULL
    OUT     PULONG            pBytesReceived         OPTIONAL,
    IN      LPOVERLAPPED      pOverlapped            OPTIONAL
    )
{
    HTTP_RECEIVE_RESPONSE_INFO  HttpResponse;

    if(Reserved != 0 || pReserved != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory(&HttpResponse, sizeof(HTTP_RECEIVE_RESPONSE_INFO));

    HttpResponse.RequestID        = RequestID;
    HttpResponse.Flags            = Flags;
    HttpResponse.pBytesTaken      = pBytesReceived;

    return HttpApiDeviceControl( 
                ServerHandle,                // FileHandle
                pOverlapped,                 // Overlapped
                IOCTL_HTTP_RECEIVE_RESPONSE, // IO Control code
                &HttpResponse,               // InputBuffer
                sizeof(HttpResponse),        // InputBufferLength
                pResponseBuffer,             // Output Buffer
                ResponseBufferLength,        // Output Buffer length
                pBytesReceived               // Bytes received.
               );
}


/***************************************************************************++

Routine Description:
    Sets server config

Arguments:
    ServerHandle    - Supplies the handle corresponding to a particular server.
                      This is the handle as returned by 
                      HttpInitializeServerContext.
    pConfig         - The Config object
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG 
WINAPI
HttpSetServerContextInformation(
    IN  HANDLE                ServerHandle,
    IN  HTTP_SERVER_CONFIG_ID ConfigId,
    IN  PVOID                 pInputBuffer,
    IN  ULONG                 InputBufferLength,
    IN  LPOVERLAPPED          pOverlapped
    )
{
    HTTP_SERVER_CONTEXT_INFORMATION     Info;

    Info.ConfigID          = ConfigId;
    Info.pInputBuffer      = pInputBuffer;
    Info.InputBufferLength = InputBufferLength;
    Info.pBytesTaken       = NULL;

    return HttpApiDeviceControl( 
                ServerHandle,
                pOverlapped,
                IOCTL_HTTP_SET_SERVER_CONTEXT_INFORMATION, 
                &Info,
                sizeof(Info),
                NULL,
                0,
                NULL
               );
}


/***************************************************************************++

Routine Description:
    Query server config

Arguments:
    ServerHandle    - Supplies the handle corresponding to a particular server.
                      This is the handle as returned by 
                      HttpInitializeServerContext.
    pConfig         - The Config object
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG 
WINAPI
HttpQueryServerContextInformation(
    IN  HANDLE                 ServerHandle,
    IN  HTTP_SERVER_CONFIG_ID  ConfigId,
    IN  PVOID                  pReserved1,
    IN  ULONG                  Reserved2,
    OUT PVOID                  pOutputBuffer,
    IN  ULONG                  OutputBufferLength,
    OUT PULONG                 pReturnLength,  
    IN  LPOVERLAPPED           pOverlapped
    )
{
    HTTP_SERVER_CONTEXT_INFORMATION     Info;

    if(pReserved1 != NULL || Reserved2 != 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    Info.ConfigID          = ConfigId;
    Info.pInputBuffer      = NULL;
    Info.InputBufferLength = 0;
    Info.pBytesTaken       = pReturnLength;

    return HttpApiDeviceControl( 
                ServerHandle,
                pOverlapped,
                IOCTL_HTTP_QUERY_SERVER_CONTEXT_INFORMATION, 
                &Info,
                sizeof(Info),
                pOutputBuffer,
                OutputBufferLength,
                pReturnLength
               );
}


/***************************************************************************++

Routine Description:
    Cancels a request

Arguments:
    ServerHandle         - Supplies the handle corresponding to a particular 
                           server.This is the handle as returned by 
                           HttpInitializeServerContext.
    RequestID            - The request ID that was returned by HttpSendRequest.
    pOverlapped          - Overlapped structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG 
WINAPI
HttpCancelHttpRequest(
    IN      HANDLE            ServerHandle,
    IN      HTTP_REQUEST_ID   RequestID,
    IN      ULONG             Flags,
    IN      LPOVERLAPPED      pOverlapped            OPTIONAL
    )
{
    HTTP_RECEIVE_RESPONSE_INFO  HttpResponse;

    RtlZeroMemory(&HttpResponse, sizeof(HTTP_RECEIVE_RESPONSE_INFO));

    HttpResponse.RequestID        = RequestID;
    HttpResponse.Flags            = Flags;

    return HttpApiDeviceControl( 
                ServerHandle,                // FileHandle
                pOverlapped,                 // Overlapped
                IOCTL_HTTP_CANCEL_REQUEST,   // IO Control code
                &HttpResponse,               // InputBuffer
                sizeof(HttpResponse),        // InputBufferLength
                NULL,
                0,
                NULL
               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\counter.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    Counter.c

Abstract:

    User-mode interface to HTTP.SYS: Performance Counter collection API

Author:

     Eric Stenson (ericsten)        28-Sept-2000

Revision History:

--*/


#include "precomp.h"

//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Gathers the perf counters for HTTP.SYS

Arguments:

    pControlChannelHandle - A handle to the control channel of HTTP.SYS

    CounterGroup - which counter set to get (global or site)

    pSizeCounterBlock - (IN) size of buffer, (OUT) bytes written if successful,
        zero otherwise

    pCounterBlocks - Buffer to receive the returned counter data block(s)

    pNumInstances - number of blocks returned.


Return Values:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INVALID_DEVICE_REQUEST
    STATUS_INVALID_PARAMETER

--***************************************************************************/

ULONG
WINAPI
HttpGetCounters(
    IN HANDLE ControlChannelHandle,
    IN HTTP_COUNTER_GROUP CounterGroup,
    IN OUT PULONG pSizeCounterBlock,
    IN OUT PVOID pCounterBlocks,
    OUT PULONG pNumInstances OPTIONAL
    )
{
    ULONG result;

    if(pSizeCounterBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    result = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,           // FileHandle
                    IOCTL_HTTP_GET_COUNTERS,        // IoControlCode
                    &CounterGroup,                  // pInputBuffer
                    sizeof(HTTP_COUNTER_GROUP),     // InputBufferLength
                    pCounterBlocks,                 // pOutputBuffer
                    *pSizeCounterBlock,             // OutputBufferLength
                    pSizeCounterBlock               // pBytesTransferred
                    );

    //
    // Calc the number of blocks returned.
    //

    if (NO_ERROR == result)
    {
        if (pNumInstances)
        {
            if (HttpCounterGroupGlobal == CounterGroup)
            {
                *pNumInstances = (*pSizeCounterBlock / sizeof(HTTP_GLOBAL_COUNTERS));
            }
            else
            {
                ASSERT(HttpCounterGroupSite == CounterGroup);
                *pNumInstances = (*pSizeCounterBlock / sizeof(HTTP_SITE_COUNTERS));
            }
        }
    }
    else
    {
        if (pSizeCounterBlock)
            *pSizeCounterBlock = 0;

        if (pNumInstances)
            *pNumInstances = 0;
    }

    return result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\config.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Config.c

Abstract:

    User-mode interface to HTTP.SYS: Configuration Group handler.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//

//
// Private prototypes.
//

/***************************************************************************++

Routine Description:

    Private function to add a URL to a config group.

Arguments:

    UrlType              - Type of URL (Reservation or Registration).
    ControlChannelHandle - Supplies a control channel handle.
    ConfigGroupId        - Supplies an identifier as returned by
                           HttpCreateConfigGroup().
    pFullyQualifiedUrl   - The URL.
    UrlContext           - URL Context.
    pSecurityDescriptor  - Security Descriptor

Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG
AddUrlToConfigGroup(
    IN HTTP_URL_OPERATOR_TYPE   UrlType,
    IN HANDLE                   ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID     ConfigGroupId,
    IN PCWSTR                   pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT         UrlContext,
    IN PSECURITY_DESCRIPTOR     pSecurityDescriptor,
    IN ULONG                    SecurityDescriptorLength
    )
{
    NTSTATUS                   Status;
    HTTP_CONFIG_GROUP_URL_INFO urlInfo;

    //
    // Initialize the input structure.
    //

    urlInfo.UrlType                  = UrlType;
    urlInfo.ConfigGroupId            = ConfigGroupId;
    urlInfo.UrlContext               = UrlContext;
    urlInfo.pSecurityDescriptor      = pSecurityDescriptor;
    urlInfo.SecurityDescriptorLength = SecurityDescriptorLength;

    Status = RtlInitUnicodeStringEx( &urlInfo.FullyQualifiedUrl, pFullyQualifiedUrl );

    if ( !NT_SUCCESS(Status) )
    {
        return HttpApiNtStatusToWin32Status( Status );
    }

    // Make the request.

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_ADD_URL_TO_CONFIG_GROUP, // IoControlCode
                    &urlInfo,                           // pInputBuffer
                    sizeof(urlInfo),                    // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

} // HttpAddUrlToConfigGroup

/***************************************************************************++

Routine Description:

    Private function to remove a URL to a config group.

Arguments:

    UrlType              - Type of URL (Reservation or Registration).
    ControlChannelHandle - Supplies a control channel handle.
    ConfigGroupId        - Supplies an identifier as returned by
                           HttpCreateConfigGroup().
    pFullyQualifiedUrl   - The URL.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
RemoveUrlFromConfigGroup(
    IN HTTP_URL_OPERATOR_TYPE   UrlType,
    IN HANDLE                   ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID     ConfigGroupId,
    IN PCWSTR                   pFullyQualifiedUrl
    )
{
    NTSTATUS                   Status;
    HTTP_CONFIG_GROUP_URL_INFO urlInfo;

    // Initialize the input structure.

    urlInfo.UrlType       = UrlType;
    urlInfo.ConfigGroupId = ConfigGroupId;

    Status = RtlInitUnicodeStringEx( &urlInfo.FullyQualifiedUrl, pFullyQualifiedUrl );

    if ( !NT_SUCCESS(Status) )
    {
        return HttpApiNtStatusToWin32Status( Status );
    }

    // Make the request.

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_REMOVE_URL_FROM_CONFIG_GROUP,    // IoControlCode
                    &urlInfo,                           // pInputBuffer
                    sizeof(urlInfo),                    // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );
}

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    pConfigGroupId - Receives an opaque identifier for the new
        configuration group.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpCreateConfigGroup(
    IN HANDLE ControlChannelHandle,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroupId
    )
{
    ULONG result;
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Make the request.
    //

    result = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_CREATE_CONFIG_GROUP,     // IoControlCode
                    NULL,                               // pInputBuffer
                    0,                                  // InputBufferLength
                    &configGroupInfo,                   // pOutputBuffer
                    sizeof(configGroupInfo),            // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    if (result == NO_ERROR)
    {
        //
        // Retrieve the container ID.
        //

        *pConfigGroupId = configGroupInfo.ConfigGroupId;
    }

    return result;

} // HttpCreateConfigGroup


/***************************************************************************++

Routine Description:

    Deletes an existing configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpDeleteConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Initialize the input structure.
    //

    configGroupInfo.ConfigGroupId = ConfigGroupId;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_DELETE_CONFIG_GROUP,     // IoControlCode
                    &configGroupInfo,                   // pInputBuffer
                    sizeof(configGroupInfo),            // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

} // HttpDeleteConfigGroup


/***************************************************************************++

Routine Description:

    Adds a fully qualified URL to an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    pFullyQualifiedUrl - Supplies the fully qualified URL to add to the
        container.

    UrlContext - Supplies an uninterpreted context to be associated with
        the URL.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpAddUrlToConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT UrlContext
    )
{
    return AddUrlToConfigGroup(
                HttpUrlOperatorTypeRegistration,
                ControlChannelHandle,
                ConfigGroupId,
                pFullyQualifiedUrl,
                UrlContext,
                NULL,
                0
                );

} // HttpAddUrlToConfigGroup


/***************************************************************************++

Routine Description:

    Removes a fully qualified URL from an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    pFullyQualifiedUrl - Supplies the fully qualified URL to remove from
        the container.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpRemoveUrlFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl
    )
{
    return RemoveUrlFromConfigGroup(
                HttpUrlOperatorTypeRegistration,
                ControlChannelHandle,
                ConfigGroupId,
                pFullyQualifiedUrl
                );


} // HttpRemoveUrlFromConfigGroup


/***************************************************************************++

Routine Description:

    Removes all URLs from an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpRemoveAllUrlsFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    HTTP_REMOVE_ALL_URLS_INFO urlInfo;

    //
    // Initialize the input structure.
    //

    urlInfo.ConfigGroupId = ConfigGroupId;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP,
                                                        // IoControlCode
                    &urlInfo,                           // pInputBuffer
                    sizeof(urlInfo),                    // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

} // HttpRemoveAllUrlsFromConfigGroup


/***************************************************************************++

Routine Description:

    Queries information from an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    InformationClass - Supplies the type of information to query.

    pConfigGroupInformation - Supplies a buffer for the query.

    Length - Supplies the length of pConfigGroupInformation.

    pReturnLength - Receives the length of data written to the buffer.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    OUT PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Initialize the input structure.
    //

    configGroupInfo.ConfigGroupId = ConfigGroupId;
    configGroupInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_QUERY_CONFIG_GROUP,      // IoControlCode
                    &configGroupInfo,                   // pInputBuffer
                    sizeof(configGroupInfo),            // InputBufferLength
                    pConfigGroupInformation,            // pOutputBuffer
                    Length,                             // OutputBufferLength
                    pReturnLength                       // pBytesTransferred
                    );

} // HttpQueryConfigGroupInformation

/***************************************************************************++

Routine Description:

    Before passing down the config group information. Make sure that the 
    directory name in the HttpConfigGroupLogInformation is not pointing back
    to local machine if it's a UNC path

Arguments:

    pConfigGroupInformation - Supplies the config group info with dir name
    Length  - Length of the above

Return

    STATUS_SUCCESS : If the UNC path doesn't include the local machine name
                     Or if the path is not UNC path.
    
    STATUS_INVALID_PARAMETER : If the buffer itself is corrupted or something
                               fatal is preventing us from getting computer
                               name when path is UNC.

    STATUS_NOT_SUPPORTED: If UNC path points back to the local machine.
    
--***************************************************************************/

NTSTATUS
HttpApiConfigGroupInformationSanityCheck(
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    )
{
    PHTTP_CONFIG_GROUP_LOGGING pLoggingInfo;
    WCHAR pwszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG ulComputerNameLength;
    PWCHAR pwsz,pwszT;
    ULONG ulSrcUncLength;
    ULONG ulDirNameLength;

    //
    // Only for HttpConfigGroupLogInformation
    //

    if(InformationClass != HttpConfigGroupLogInformation ||
       pConfigGroupInformation == NULL
       )
    {
        return STATUS_SUCCESS;
    }

    if (Length < sizeof(HTTP_CONFIG_GROUP_LOGGING))
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Try to check the log dir name if it's a UNC Path
    //
    __try
    {            
        pLoggingInfo = (PHTTP_CONFIG_GROUP_LOGGING)pConfigGroupInformation;
        ulDirNameLength = pLoggingInfo->LogFileDir.Length / sizeof(WCHAR);
            
        if (ulDirNameLength > 2)
        {        
            if (pLoggingInfo->LogFileDir.Buffer[0] == L'\\' &&
                pLoggingInfo->LogFileDir.Buffer[1] == L'\\')
            {
                // UNC Path
                
                ULONG ccLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                if (!GetComputerNameW(pwszComputerName, &ccLength))
                {
                    // This should never fail unless there's really fatal 
                    // system problem. But if it fails then refuse the 
                    // UNC path regardless.
                    
                    return STATUS_INVALID_PARAMETER;                
                }
                
                if (ccLength == 0)
                {
                    return STATUS_INVALID_PARAMETER;
                }

                ulComputerNameLength = ccLength;                    

                // Extract the computername from the full path
                
                pwsz = pwszT = &pLoggingInfo->LogFileDir.Buffer[2];
                ulDirNameLength -= 2;
                    
                // Forward the temp pointer to the end of the supposed
                // computername
                
                while(ulDirNameLength && *pwszT != UNICODE_NULL && *pwszT != L'\\') 
                {
                    pwszT++;
                    ulDirNameLength--;
                }

                ulSrcUncLength = (ULONG) DIFF(pwszT - pwsz);

                // Compare not case sensitive
                
                if(ulComputerNameLength == ulSrcUncLength &&
                   _wcsnicmp(pwszComputerName, pwsz, ulSrcUncLength) == 0
                   )
                {
                    return STATUS_NOT_SUPPORTED;
                }

            }            
        
        }

    }    
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    return STATUS_SUCCESS;
    
}

/***************************************************************************++

Routine Description:

    Sets information in an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    InformationClass - Supplies the type of information to set.

    pConfigGroupInformation - Supplies the data to set.

    Length - Supplies the length of pConfigGroupInformation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Initialize the input structure.
    //

    configGroupInfo.ConfigGroupId = ConfigGroupId;
    configGroupInfo.InformationClass = InformationClass;

    status = HttpApiConfigGroupInformationSanityCheck(
                    InformationClass,
                    pConfigGroupInformation,
                    Length
                    );
    if (!NT_SUCCESS(status))
    {
        return HttpApiNtStatusToWin32Status(status);
    }
        
    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_SET_CONFIG_GROUP,        // IoControlCode
                    &configGroupInfo,                   // pInputBuffer
                    sizeof(configGroupInfo),            // InputBufferLength
                    pConfigGroupInformation,            // pOutputBuffer
                    Length,                             // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

} // HttpSetConfigGroupInformation


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\filter.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    Filter.c

Abstract:

    User-mode interface to HTTP.SYS: Filter handler.

Author:

    Michael Courage (mcourage)   17-Mar-2000

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a filter channel to HTTP.SYS.

Arguments:

    pFilterHandle - Receives a handle to the new filter object.

    pFilterName - Supplies the name of the new filter.

    pSecurityAttributes - Optionally supplies security attributes for
        the new filter.

    Options - Supplies creation options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpCreateFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pFilterHandle,              // pHandle
                    NULL,
                    0,
                    NULL,
                    0,
                    NULL,
                    0,
                    GENERIC_READ |              // DesiredAccess
                        GENERIC_WRITE |
                        SYNCHRONIZE,
                    HttpApiFilterChannelHandleType, // HandleType
                    pFilterName,                // pObjectName
                    Options,                    // Options
                    FILE_CREATE,                // CreateDisposition
                    pSecurityAttributes         // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (HttpApiTryToStartDriver(HTTP_SERVICE_NAME))
        {
            status = HttpApiOpenDriverHelper(
                            pFilterHandle,              // pHandle
                            NULL,
                            0,
                            NULL,
                            0,
                            NULL,
                            0,
                            GENERIC_READ |              // DesiredAccess
                                GENERIC_WRITE |
                                SYNCHRONIZE,
                            HttpApiFilterChannelHandleType, // HandleType
                            pFilterName,                // pObjectName
                            Options,                    // Options
                            FILE_CREATE,                // CreateDisposition
                            pSecurityAttributes         // pSecurityAttributes
                            );
        }
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpApiCreateFilter



/***************************************************************************++

Routine Description:

    Opens an existing filter channel.

Arguments:

    pFilterHandle - Receives a handle to the new filter object.

    pFilterName - Supplies the name of the new filter.

    Options - Supplies open options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpOpenFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pFilterHandle,              // pHandle
                    NULL,
                    0,
                    NULL,
                    0,
                    NULL,
                    0,
                    GENERIC_READ |              // DesiredAccess
                        SYNCHRONIZE,
                    HttpApiFilterChannelHandleType, // HandleType
                    pFilterName,                // pObjectName
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpApiOpenFilter



/***************************************************************************++

Routine Description:

    Cancels all I/O outstanding on the handle.

Arguments:

    FilterHandle - the filter channel

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpShutdownFilter(
    IN HANDLE FilterHandle
    )
{
    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                FilterHandle,                       // FileHandle
                IOCTL_HTTP_SHUTDOWN_FILTER_CHANNEL, // IoControlCode
                NULL,                               // pInputBuffer
                0,                                  // InputBufferLength
                NULL,                               // pOutputBuffer
                0,                                  // OutputBufferLength
                NULL                                // pBytesTransferred
                );

} // HttpShutdownFilter


/***************************************************************************++

Routine Description:

    Accepts a new connection from the network, and optionally receives
    some data from that connection.

Arguments:

    FilterHandle - the filter channel
    pRawConnectionInfo - returns information about the accepted connection
    RawConnectionInfoSize - size of the raw info buffer
    pBytesReceived - returns the number of bytes received
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAccept(
    IN HANDLE FilterHandle,
    OUT PHTTP_RAW_CONNECTION_INFO pRawConnectionInfo,
    IN ULONG RawConnectionInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_ACCEPT,       // IoControlCode
                NULL,                           // pInputBuffer
                0,                              // InputBufferLength
                pRawConnectionInfo,             // pOutputBuffer
                RawConnectionInfoSize,          // OutputBufferLength
                pBytesReceived                  // pBytesTransferred
                );

} // HttpFilterAccept


/***************************************************************************++

Routine Description:

    Closes a connection that was accepted with HttpFilterAccept.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the connection to close
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterClose(
    IN HANDLE FilterHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_CLOSE,        // IoControlCode
                &ConnectionId,                  // pInputBuffer
                sizeof(ConnectionId),           // InputBufferLength
                NULL,                           // pOutputBuffer
                0,                              // OutputBufferLength
                NULL                            // pBytesTransferred
                );

} // HttpFilterClose


/***************************************************************************++

Routine Description:

    Reads unfiltered data into the filter process from the http app after
    writing the given data buffer to the raw connection.

Arguments:

    FilterHandle - the filter channel
    pHttpBufferPlus - read and write buffers, and the connection ID
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterRawWriteAndAppRead(
    IN HANDLE FilterHandle,
    IN OUT PHTTP_FILTER_BUFFER_PLUS pHttpBufferPlus,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    ASSERT(pHttpBufferPlus);

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_APP_READ,     // IoControlCode
                pHttpBufferPlus,                // pInputBuffer
                sizeof(HTTP_FILTER_BUFFER_PLUS),// InputBufferLength
                pHttpBufferPlus->pBuffer,       // pOutputBuffer
                pHttpBufferPlus->BufferSize,    // OutputBufferLength
                NULL                            // pBytesTransferred
                );

} // HttpFilterRawWriteAndAppRead


/***************************************************************************++

Routine Description:

    Writes data to a connection that was accepted with HttpFilterAccept, and
    subsequently reads data from the connection.

Arguments:

    FilterHandle - the filter channel
    pHttpBufferPlus - read and write buffers, and the connection ID
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAppWriteAndRawRead(
    IN HANDLE FilterHandle,
    IN OUT PHTTP_FILTER_BUFFER_PLUS pHttpBufferPlus,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    return HttpApiDeviceControl(
                FilterHandle,                   //FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_RAW_READ,     // IoControlCode
                pHttpBufferPlus,                // pInputBuffer
                sizeof(HTTP_FILTER_BUFFER_PLUS),// InputBufferLength
                pHttpBufferPlus->pBuffer,       // pOutputBuffer
                pHttpBufferPlus->BufferSize,    // OutputBufferLength
                NULL                            // pBytesTransferred
                );

} // HttpFilterAppWriteAndRawRead


/***************************************************************************++

Routine Description:

    Reads data from a connection that was accepted with HttpFilterAccept.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the connection to read
    pBuffer - that's where we put the data
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes read
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterRawRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    OUT PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_RAW_READ,     // IoControlCode
                &ConnectionId,                  // pInputBuffer
                sizeof(ConnectionId),           // InputBufferLength
                pBuffer,                        // pOutputBuffer
                BufferSize,                     // OutputBufferLength
                pBytesReceived                  // pBytesTransferred
                );

} // HttpFilterRawRead


/***************************************************************************++

Routine Description:

    Writes data to a connection that was accepted with HttpFilterAccept.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the raw connection
    pBuffer - data to write
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterRawWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_RAW_WRITE,    // IoControlCode
                &ConnectionId,                  // pInputBuffer
                sizeof(ConnectionId),           // InputBufferLength
                pBuffer,                        // pOutputBuffer
                BufferSize,                     // OutputBufferLength
                pBytesReceived                  // pBytesTransferred
                );

} // HttpFilterRawWrite


/***************************************************************************++

Routine Description:

    Reads unfiltered data (or other requests like cert renegotiation) into
    the filter process from the http app.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the raw connection
    pBuffer - this is the buffer where we put the data
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAppRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN OUT PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    // CODEWORK: Remove BufferSize and update function signature
    UNREFERENCED_PARAMETER(BufferSize);
    ASSERT(pBuffer);

    //
    // Store the ID in pBuffer.
    //

    pBuffer->Reserved = ConnectionId;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_APP_READ,     // IoControlCode
                pBuffer,                        // pInputBuffer
                sizeof(HTTP_FILTER_BUFFER),     // InputBufferLength
                pBuffer->pBuffer,               // pOutputBuffer
                pBuffer->BufferSize,            // OutputBufferLength
                pBytesReceived                  // pBytesTransferred
                );

} // HttpFilterAppRead


/***************************************************************************++

Routine Description:

    Writes filtered data back to a connection. That data will be parsed
    and routed to an application pool.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the raw connection
    pBuffer - data to write
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAppWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN OUT PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    // CODEWORK: Remove BufferSize and update function signature
    UNREFERENCED_PARAMETER(BufferSize);
    ASSERT(pBuffer);

    //
    // Store the ID in pBuffer.
    //

    pBuffer->Reserved = ConnectionId;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                FilterHandle,                   // FileHandle
                pOverlapped,                    // pOverlapped
                IOCTL_HTTP_FILTER_APP_WRITE,    // IoControlCode
                pBuffer,                        // pInputBuffer
                sizeof(HTTP_FILTER_BUFFER),     // InputBufferLength
                pBuffer->pBuffer,               // pOutputBuffer
                pBuffer->BufferSize,            // OutputBufferLength
                pBytesReceived                  // pBytesTransferred
                );

} // HttpFilterAppWrite


/***************************************************************************++

Routine Description:

    Asks the filter process to renegotiate the SSL connection to get a
    client certificate. The certificate is optionally mapped to a token.
    The resulting cert info and token are copied into the callers buffer.

Arguments:

    AppPoolHandle - the application pool
    ConnectionId - ID of the http connection
    Flags - valid flag is HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP
    pSslClientCertInfo - the buffer that receives cert info
    SslClientCertInfoSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpReceiveClientCertificate(
    IN HANDLE AppPoolHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN ULONG Flags,
    OUT PHTTP_SSL_CLIENT_CERT_INFO pSslClientCertInfo,
    IN ULONG SslClientCertInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped
    )
{
    HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO receiveCertInfo;

    //
    // Initialize the input structure.
    //

    receiveCertInfo.ConnectionId = ConnectionId;
    receiveCertInfo.Flags = Flags;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                          // FileHandle
                pOverlapped,                            // pOverlapped
                IOCTL_HTTP_FILTER_RECEIVE_CLIENT_CERT,  // IoControlCode
                &receiveCertInfo,                       // pInputBuffer
                sizeof(receiveCertInfo),                // InputBufferLength
                pSslClientCertInfo,                     // pOutputBuffer
                SslClientCertInfoSize,                  // OutputBufferLength
                pBytesReceived                          // pBytesTransferred
                );

} // HttpReceiveClientCertificate

//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\hhandle.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    HHandle.c

Abstract:

    User-mode interface to HTTP.SYS: Public Listener API

Author:

    Eric Stenson (ericsten)        16-July-2001

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new Request Queue (actually an Application Pool).

Arguments:

    pAppPoolHandle - Receives a handle to the new application pool.

    Options - Supplies creation options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateHttpHandle(
    OUT PHANDLE   pReqQueueHandle,
    IN  ULONG     Options
    )
{
    ULONG               result;
    HANDLE              appPool = NULL;
    HTTP_APP_POOL_ENABLED_STATE  AppPoolState;


    //
    // Sanity check
    //

    if (NULL == pReqQueueHandle )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Init OUT parameter
    //

    *pReqQueueHandle = NULL;

    //
    // Verify we've been init'd.
    //

    if ( !HttpIsInitialized(HTTP_INITIALIZE_SERVER) )
    {
        return ERROR_DLL_INIT_FAILED; 
    }

    //
    // Create an application pool.
    // REVIEW: Do we need to set up default Security Attributes on the App Pool?
    //

    result = HttpCreateAppPool(
                    &appPool,
                    NULL,        // Generic App Pool Name
                    NULL ,      // PSECURITY_ATTRIBUTES
                    Options
                    );

    if (result != NO_ERROR)
    {
        HttpTrace1( "HttpCreateAppPool() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Turn on AppPool
    // CODEWORK: Leave AppPool off, create another API for switching App Pool on & off.
    //

    AppPoolState = HttpAppPoolEnabled;
    
    result = HttpSetAppPoolInformation(
                 appPool,
                 HttpAppPoolStateInformation,
                 &AppPoolState,
                 sizeof(AppPoolState)
                 );

    if (result != NO_ERROR)
    {
        HttpTrace1( "HttpSetAppPoolInformation: could not enable app pool %p\n", appPool );
        goto cleanup;
    }
    
    // CODEWORK: (DBG ONLY) Add to global Active App Pool list.

    //
    // Return App Pool to user in pReqQueueHandle.
    //
    *pReqQueueHandle = appPool;

 cleanup:

    if (NO_ERROR != result)
    {
        // Failed.  cleanup.

        if ( appPool )
        {
            CloseHandle( appPool );
        }
    }

    return result;

} // HttpCreateHttpHandle


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\apppool.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    AppPool.c

Abstract:

    User-mode interface to HTTP.SYS: Application Pool handler.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new Application Pool.

Arguments:

    pAppPoolHandle - Receives a handle to the new application pool.
        object.

    pAppPoolName - Supplies the name of the new application pool.

    pSecurityAttributes - Optionally supplies security attributes for
        the new application pool.

    Options - Supplies creation options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpCreateAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    )
{
    NTSTATUS    status;
    ACCESS_MASK AccessMask;

    AccessMask = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;

    if(pAppPoolName != NULL)
    {
        // WAS needs WRITE_DAC permission to support different worker
        // processes.

        AccessMask |= WRITE_DAC;
    }
        

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pAppPoolHandle,             // pHandle
                    NULL,
                    0,
                    NULL,
                    0,
                    NULL,
                    0,
                    AccessMask,
                    HttpApiAppPoolHandleType,   // HandleType
                    pAppPoolName,               // pObjectName
                    Options,                    // Options
                    FILE_CREATE,                // CreateDisposition
                    pSecurityAttributes         // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (HttpApiTryToStartDriver(HTTP_SERVICE_NAME))
        {
            status = HttpApiOpenDriverHelper(
                            pAppPoolHandle,         // pHandle
                            NULL,
                            0,
                            NULL,
                            0,
                            NULL,
                            0,
                            AccessMask,
                            HttpApiAppPoolHandleType,   // HandleType
                            pAppPoolName,           // pObjectName
                            Options,                // Options
                            FILE_CREATE,            // CreateDisposition
                            pSecurityAttributes     // pSecurityAttributes
                            );
        }
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpCreateAppPool


/***************************************************************************++

Routine Description:

    Opens an existing application pool.

Arguments:

    pAppPoolHandle - Receives a handle to the existing application pool object.

    pAppPoolName - Supplies the name of the existing application pool.

    Options - Supplies open options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpOpenAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pAppPoolHandle,             // pHandle
                    NULL,
                    0,
                    NULL,
                    0,
                    NULL,
                    0,
                    GENERIC_READ |              // DesiredAccess
                        SYNCHRONIZE,
                    HttpApiAppPoolHandleType,   // HandleType
                    pAppPoolName,               // pObjectName
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpOpenAppPool

/***************************************************************************++

Routine Description:

    Shuts down an application pool.

Arguments:

    AppPoolHandle - the pool to shut down.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpShutdownAppPool(
    IN HANDLE AppPoolHandle
    )
{
    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                AppPoolHandle,                  // FileHandle
                IOCTL_HTTP_SHUTDOWN_APP_POOL,   // IoControlCode
                NULL,                           // pInputBuffer
                0,                              // InputBufferLength
                NULL,                           // pOutputBuffer
                0,                              // OutputBufferLength
                NULL                            // pBytesTransferred
                );

} // HttpShutdownAppPool


/***************************************************************************++

Routine Description:

    Queries information from a application pool.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    InformationClass - Supplies the type of information to query.

    pAppPoolInformation - Supplies a buffer for the query.

    Length - Supplies the length of pAppPoolInformation.

    pReturnLength - Receives the length of data written to the buffer.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID pAppPoolInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    HTTP_APP_POOL_INFO appPoolInfo;

    //
    // Initialize the input structure.
    //

    appPoolInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                AppPoolHandle,                          // FileHandle
                IOCTL_HTTP_QUERY_APP_POOL_INFORMATION,  // IoControlCode
                &appPoolInfo,                           // pInputBuffer
                sizeof(appPoolInfo),                    // InputBufferLength
                pAppPoolInformation,                    // pOutputBuffer
                Length,                                 // OutputBufferLength
                pReturnLength                           // pBytesTransferred
                );

} // HttpQueryAppPoolInformation


/***************************************************************************++

Routine Description:

    Sets information in an admin container.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    InformationClass - Supplies the type of information to set.

    pAppPoolInformation - Supplies the data to set.

    Length - Supplies the length of pAppPoolInformation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    IN PVOID pAppPoolInformation,
    IN ULONG Length
    )
{
    HTTP_APP_POOL_INFO appPoolInfo;

    //
    // Initialize the input structure.
    //

    appPoolInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                AppPoolHandle,                      // FileHandle
                IOCTL_HTTP_SET_APP_POOL_INFORMATION,// IoControlCode
                &appPoolInfo,                       // pInputBuffer
                sizeof(appPoolInfo),                // InputBufferLength
                pAppPoolInformation,                // pOutputBuffer
                Length,                             // OutputBufferLength
                NULL                                // pBytesTransferred
                );

} // HttpSetAppPoolInformation


/***************************************************************************++

Routine Description:

    Flushes the response cache.

Arguments:

    ReqQueueHandle - Supplies a handle to a application pool.

    pFullyQualifiedUrl - Supplies the fully qualified URL to flush.

    Flags - Supplies behavior control flags.

    pOverlapped - Supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpFlushResponseCache(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pFullyQualifiedUrl,
    IN ULONG Flags,
    IN LPOVERLAPPED pOverlapped
    )
{
    NTSTATUS                       Status;
    HTTP_FLUSH_RESPONSE_CACHE_INFO flushInfo;

    // Initialize the input structure.

    Status = RtlInitUnicodeStringEx( &flushInfo.FullyQualifiedUrl, pFullyQualifiedUrl );

    if ( NT_SUCCESS(Status) )
    {
        flushInfo.Flags = Flags;

        // Make the request.

        return HttpApiDeviceControl(
                    ReqQueueHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_FLUSH_RESPONSE_CACHE,    // IoControlCode
                    &flushInfo,                         // pInputBuffer
                    sizeof(flushInfo),                  // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );
    }
    
    return HttpApiNtStatusToWin32Status( Status );

} // HttpFlushResponseCache


/***************************************************************************++

Routine Description:

    Adds a fragment cache entry.

Arguments:

    ReqQueueHandle - Supplies a handle to a application pool.

    pFragmentName - Supplies the name of the fragment to add.

    pBuffer - Supplies a pointer to the buffer of data to be cached.

    BufferLength - Supplies the length of the buffer to be cached.

    pCachePolicy - Supplies caching policy for the fragment cache.

    pOverlapped - Supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpAddFragmentToCache(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pFragmentName,
    IN PHTTP_DATA_CHUNK pDataChunk,
    IN PHTTP_CACHE_POLICY pCachePolicy,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS               Status;
    HTTP_ADD_FRAGMENT_INFO addInfo;


    if (!pDataChunk || !pCachePolicy)
    {
        return HttpApiNtStatusToWin32Status( STATUS_INVALID_PARAMETER );
    }

    // Initialize the input structure.

    Status = RtlInitUnicodeStringEx( &addInfo.FragmentName, pFragmentName );

    if ( !NT_SUCCESS(Status) )
    {
        return HttpApiNtStatusToWin32Status( Status );
    }

    addInfo.DataChunk = *pDataChunk;
    addInfo.CachePolicy = *pCachePolicy;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                ReqQueueHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_ADD_FRAGMENT_TO_CACHE,   // IoControlCode
                &addInfo,                           // pInputBuffer
                sizeof(addInfo),                    // InputBufferLength
                NULL,                               // pOutputBuffer
                0,                                  // OutputBufferLength
                NULL                                // pBytesTransferred
                );

} // HttpAddFragmentToCache


/***************************************************************************++

Routine Description:

    Reads a fragment back from the cache.

Arguments:

    ReqQueueHandle - Supplies a handle to a application pool.

    pFragmentName - Supplies the name of the fragment cache entry to read.

    pByteRange - Specifies the offset and length to read from the cache entry.

    pBuffer - Supplies a pointer to the output buffer of data to be copied.

    BufferLength - Supplies the length of the buffer to be copied.

    pBytesRead - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data returned if this read completes
        synchronously (in-line).

    pOverlapped - Supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpReadFragmentFromCache(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pFragmentName,
    IN PHTTP_BYTE_RANGE pByteRange OPTIONAL,
    OUT PVOID pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesRead OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS                Status;
    HTTP_READ_FRAGMENT_INFO readInfo;

    // Initialize the input structure.

    Status = RtlInitUnicodeStringEx( &readInfo.FragmentName, pFragmentName );

    if ( !NT_SUCCESS(Status) )
    {
        return HttpApiNtStatusToWin32Status( Status );
    }

    if (pByteRange != NULL)
    {
        readInfo.ByteRange = *pByteRange;
    }
    else
    {
        readInfo.ByteRange.StartingOffset.QuadPart = 0;
        readInfo.ByteRange.Length.QuadPart = HTTP_BYTE_RANGE_TO_EOF;
    }

    // Make the request.

    return HttpApiDeviceControl(
                ReqQueueHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_READ_FRAGMENT_FROM_CACHE,// IoControlCode
                &readInfo,                          // pInputBuffer
                sizeof(readInfo),                   // InputBufferLength
                pBuffer,                            // pOutputBuffer
                BufferLength,                       // OutputBufferLength
                pBytesRead                          // pBytesTransferred
                );

} // HttpReadFragmentFromCache


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\control.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Control.c

Abstract:

    User-mode interface to HTTP.SYS: Control Channel handler.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a control channel to HTTP.SYS.

Arguments:

    pControlChannel - Receives a handle to the control channel if successful.

    Options - Supplies zero or more HTTP_OPTION_* flags.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpOpenControlChannel(
    OUT PHANDLE pControlChannel,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // First, just try to open the driver.
    //

    status = HttpApiOpenDriverHelper(
                    pControlChannel,            // pHandle
                    NULL,
                    0,
                    NULL,
                    0,
                    NULL,
                    0,
                    GENERIC_READ |              // DesiredAccess
                        GENERIC_WRITE |
                        SYNCHRONIZE,
                    HttpApiControlChannelHandleType,    // handle type
                    NULL,                       // pObjectName
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (HttpApiTryToStartDriver(HTTP_SERVICE_NAME))
        {
            status = HttpApiOpenDriverHelper(
                            pControlChannel,            // pHandle
                            NULL,
                            0,
                            NULL,
                            0,
                            NULL,
                            0,
                            GENERIC_READ |              // DesiredAccess
                                GENERIC_WRITE |
                                SYNCHRONIZE,
                            HttpApiControlChannelHandleType,    // handle type
                            NULL,                       // pObjectName
                            Options,                    // Options
                            FILE_OPEN,                  // CreateDisposition
                            NULL                        // pSecurityAttributes
                            );
        }
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpOpenControlChannel


/***************************************************************************++

Routine Description:

    Queries information from a control channel.

Arguments:

    ControlChannelHandle - Supplies a HTTP.SYS control channel handle.

    InformationClass - Supplies the type of information to query.

    pControlChannelInformation - Supplies a buffer for the query.

    Length - Supplies the length of pControlChannelInformation.

    pReturnLength - Receives the length of data written to the buffer.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    OUT PVOID pControlChannelInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    HTTP_CONTROL_CHANNEL_INFO channelInfo;

    //
    // Initialize the input structure.
    //

    channelInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_QUERY_CONTROL_CHANNEL,   // IoControlCode
                    &channelInfo,                       // pInputBuffer
                    sizeof(channelInfo),                // InputBufferLength
                    pControlChannelInformation,         // pOutputBuffer
                    Length,                             // OutputBufferLength
                    pReturnLength                       // pBytesTransferred
                    );

} // HttpQueryControlChannelInformation


/***************************************************************************++

Routine Description:

    Sets information in a control channel.

Arguments:

    ControlChannelHandle - Supplies a HTTP.SYS control channel handle.

    InformationClass - Supplies the type of information to set.

    pControlChannelInformation - Supplies the data to set.

    Length - Supplies the length of pControlChannelInformation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    )
{
    HTTP_CONTROL_CHANNEL_INFO channelInfo;

    //
    // Initialize the input structure.
    //

    channelInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    return HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_SET_CONTROL_CHANNEL,     // IoControlCode
                    &channelInfo,                       // pInputBuffer
                    sizeof(channelInfo),                // InputBufferLength
                    pControlChannelInformation,         // pOutputBuffer
                    Length,                             // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

} // HttpSetControlChannelInformation


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\httpapip.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    HttpApiP.h

Abstract:

    Private "global" include for HttpApi.dll

Author:

    Eric Stenson (ericsten)        16-July-2001

Revision History:

--*/

#ifndef __HTTPAPIP_H__
#define __HTTPAPIP_H__


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Crit Sec Spin Count
//
#define HTTP_CS_SPIN_COUNT    4000

//
// init.c
//

#define HTTP_LEGAL_INIT_FLAGS              (HTTP_INITIALIZE_SERVER|HTTP_INITIALIZE_CLIENT|HTTP_INITIALIZE_CONFIG)
#define HTTP_ILLEGAL_INIT_FLAGS           (~(HTTP_LEGAL_INIT_FLAGS))
#define HTTP_LEGAL_TERM_FLAGS             (HTTP_LEGAL_INIT_FLAGS)
#define HTTP_ILLEGAL_TERM_FLAGS          (~(HTTP_LEGAL_TERM_FLAGS))

DWORD
OpenAndEnableControlChannel(
    OUT PHANDLE pHandle
    );

ULONG
HttpApiInitializeListener(
    IN ULONG Flags
    );

ULONG
HttpApiInitializeClient(
    IN ULONG Flags
    );

ULONG
HttpApiTerminateListener(
    IN ULONG Flags
    );

ULONG
HttpApiInitializeConfiguration(
    IN ULONG Flags
    );

ULONG
HttpApiInitializeResources(
    IN ULONG Flags
    );

ULONG
HttpApiTerminateListener(
    IN ULONG Flags
    );

ULONG
HttpApiTerminateClient(
    IN ULONG Flags
    );

ULONG
HttpApiTerminateConfiguration(
    IN ULONG Flags
    );

ULONG
HttpApiTerminateResources(
    IN ULONG Flags
    );


//
// misc.c
//    
ULONG
CreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR * ppSD
    );

VOID
FreeSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    );

//
// url.c
//    
ULONG
InitializeConfigGroupTable(
    VOID
    );

VOID
TerminateConfigGroupTable(
    VOID
    );

//
// config.c
// 
ULONG
AddUrlToConfigGroup(
    IN HTTP_URL_OPERATOR_TYPE   UrlType,
    IN HANDLE                   ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID     ConfigGroupId,
    IN PCWSTR                   pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT         UrlContext,
    IN PSECURITY_DESCRIPTOR     pSecurityDescriptor,
    IN ULONG                    SecurityDescriptorLength
    );

ULONG
RemoveUrlFromConfigGroup(
    IN HTTP_URL_OPERATOR_TYPE   UrlType,
    IN HANDLE                   ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID     ConfigGroupId,
    IN PCWSTR                   pFullyQualifiedUrl
    );

//
// serverconfig.c
//
ULONG
InitializeConfigurationGlobals(
    VOID
    );

VOID
TerminateConfigurationGlobals(
    VOID
    );
    

//
// init.c
//
extern HANDLE               g_ControlChannel;

extern DWORD                g_TlsIndex;

//
// clientapi.c
//
DWORD UnloadStrmFilt(
    VOID
    );


#if DBG    

//
// Trace output
//    
#define HTTP_TRACE_NAME     L"httpapi"

extern DWORD                g_HttpTraceId;


#define HttpTrace(str)            TracePrintfEx( g_HttpTraceId, 0, L##str)    
#define HttpTrace1(str, a)      TracePrintfEx( g_HttpTraceId, 0, L##str, a )
#define HttpTrace2(str, a, b)  TracePrintfEx( g_HttpTraceId, 0, L##str, a, b )
#define HttpTrace4(str, a, b, c, d)  \
                         TracePrintfEx( g_HttpTraceId, 0, L##str, a, b, c, d )


#else // DBG

#define HttpTrace(str)
#define HttpTrace1(str, a)
#define HttpTrace2(str, a, b)
#define HttpTrace4(str, a, b, c, d)

#endif // DBG


BOOL
HttpIsInitialized(
    IN ULONG Flags
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus

#endif // __HTTPAPIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\init.c ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    User-mode interface to HTTP.SYS: DLL initialization/termination routines.

Author:

    Eric Stenson (ericsten)      31-May-2001

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private data.
//

//
// Initialize/Terminate control
//
static DWORD                      g_InitServerRefCount;
static DWORD                      g_InitClientRefCount;
static DWORD                      g_InitConfigRefCount;
static DWORD                      g_InitResourcesRefCount;

//
// Critical section for accessing the init counts.  Also used by client
// api for synchronization during initialization.
//

CRITICAL_SECTION                  g_InitCritSec;

#if DBG

extern DWORD                g_HttpTraceId    = 0;

#endif

//
// DLL ref count (for tracking one-time DLL init)
//
static DWORD                g_DllRefCount    = 0;

//
// global, singleton control channel
//
extern HANDLE               g_ControlChannel = NULL;

//
// Thread load storage index for synchronous I/O event
//
extern DWORD                g_TlsIndex = 0;

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs DLL initialization/termination.

Arguments:

    DllHandle - Supplies a handle to the current DLL.

    Reason - Supplies the notification code.

    pContext - Optionally supplies a context.

Return Value:

    BOOLEAN - TRUE if initialization completed successfully, FALSE
        otherwise. Ignored for notifications other than process
        attach.

--***************************************************************************/
BOOL
WINAPI
DllMain(
    IN HMODULE DllHandle,
    IN DWORD Reason,
    IN LPVOID pContext OPTIONAL
    )
{
    BOOL result = TRUE;
    HANDLE hEvent = NULL;

    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(DllHandle);

    //
    // Interpret the reason code.
    //

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // One time init
        //
        if ( 1 == InterlockedIncrement( (PLONG)&g_DllRefCount ) )
        {
            //
            // Allocate space in TLS for cached event for synchronous
            // IOCTL calls
            //
                
            g_TlsIndex = TlsAlloc();
            if(g_TlsIndex == TLS_OUT_OF_INDEXES)
            {
                result = FALSE;
            }
            
            if(TRUE == result)
            {
                HttpCmnInitializeHttpCharsTable(FALSE);
    
                result = InitializeCriticalSectionAndSpinCount( &g_InitCritSec, 0 );

                g_InitServerRefCount = 0L;
                g_InitClientRefCount = 0L;
                g_InitConfigRefCount = 0L;
                g_InitResourcesRefCount = 0L;
            }

#if DBG
            if(TRUE == result)
            {
                g_HttpTraceId = TraceRegisterEx( HTTP_TRACE_NAME, 0 );
            }

#endif
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // Ref counting & cleanup assertion(s).
        //
        if ( 0 == InterlockedDecrement( (PLONG)&g_DllRefCount ) )
        {
            // Check to see if we've been cleaned up.
            if ( NULL != g_ControlChannel )
            {
                HttpTrace( "DLL_PROCESS_DETACH called with Control Channel still OPEN!\n" );
            }
            
            if (    ( 0L != g_InitServerRefCount ) ||
                    ( 0L != g_InitClientRefCount ) ||
                    ( 0L != g_InitConfigRefCount ) ||
                    ( 0L != g_InitResourcesRefCount )  )
            {
                HttpTrace( "DLL_PROCESS_DETACH called with nonzero Reference Count(s)!\n" );
            }

#if DBG
            if(0 != g_HttpTraceId)
            {
                TraceDeregisterEx(g_HttpTraceId, 0);
    
                g_HttpTraceId = 0;
            }
#endif
    
            // If DeleteCriticalSection raises an exception should we catch it?

            DeleteCriticalSection( &g_InitCritSec );
            
            TlsFree( g_TlsIndex );
        }
        
        break;

    case DLL_THREAD_DETACH:

        hEvent = (HANDLE) TlsGetValue( g_TlsIndex );
        if ( hEvent != NULL )
        {
            NtClose( hEvent );
            TlsSetValue( g_TlsIndex, NULL );
        }

        break;
        
    }

    return result;

}   // DllMain


/***************************************************************************++

Routine Description:

    Performs global initialization.

Arguments:

    Reserved - Must be zero. May be used in future for interface version
        negotiation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpInitialize(
    IN HTTPAPI_VERSION Version,
    IN ULONG           Flags,
    IN OUT VOID*       Reserved
    )
{
    ULONG result = ERROR_INVALID_FUNCTION;
    HTTPAPI_VERSION HttpVersion = HTTPAPI_VERSION_1;

    HttpTrace4("=> HttpInitialize Major=%d Minor%d Flags=%ld Reserved=%p", 
               Version.HttpApiMajorVersion, Version.HttpApiMinorVersion, Flags, Reserved);
               
    if ( Version.HttpApiMajorVersion != HttpVersion.HttpApiMajorVersion ||
         Version.HttpApiMinorVersion != HttpVersion.HttpApiMinorVersion )
    {
        result = ERROR_INVALID_DLL;
    }
    else if( (NULL != Reserved) || (HTTP_ILLEGAL_INIT_FLAGS & Flags) )
    {
        result = ERROR_INVALID_PARAMETER;
    }
    else
    {
        EnterCriticalSection( &g_InitCritSec );

        // Initialize event cache even if no flags are set

        result = HttpApiInitializeResources( Flags );

        // Perform specified initialization

        if ( NO_ERROR == result )
        {
            if ( HTTP_INITIALIZE_CONFIG & Flags )
            {
                result = HttpApiInitializeConfiguration( Flags );
            }

            if ( NO_ERROR == result )
            {
                // Perform specified initialization
            
                if ( HTTP_INITIALIZE_SERVER & Flags )
                {
                    result = HttpApiInitializeListener( Flags );
                }

                if ( NO_ERROR == result ) 
                {
                    if ( HTTP_INITIALIZE_CLIENT & Flags )
                    {
                        result = HttpApiInitializeClient( Flags );
                    }

                    if ( ( NO_ERROR != result ) && ( HTTP_INITIALIZE_SERVER & Flags ) )
                    {
                        // If we try to initialize both the server and client features then we must succeed with both
                        // initializations or fail both.  We have no error code that distinguishes between total and 
                        // partial failure.
                        
                        HttpApiTerminateListener( Flags );
                    }
                }

                // If we fail to initialize the specified server or client features then we terminate the associated configuration
                // as well even if HTTP_INITIALIZE_CONFIGURATION was set in the Flags.  We have no error code that
                // distinguishes between total and partial failure.
                
                if ( ( NO_ERROR != result ) && ( HTTP_INITIALIZE_CONFIG & Flags ) )
                {
                    // Terminate config
                    HttpApiTerminateConfiguration( Flags );
                }
            }

            // If we fail any initialization step then we terminate the associated cache initialization.  We have no error code
            // that distinguishes between total and partial failure.

            if ( NO_ERROR != result )
            {
                HttpApiTerminateResources( Flags );
            }

        }

        LeaveCriticalSection( &g_InitCritSec );
        
    }
        
    HttpTrace1( "<= HttpInitialize = 0x%0x",  result );
    ASSERT( ERROR_INVALID_FUNCTION != result );

    return result;

} // HttpInitialize


/***************************************************************************++

Routine Description:

    Performs global termination.

--***************************************************************************/
ULONG
WINAPI
HttpTerminate(
    IN ULONG Flags,
    IN OUT VOID* Reserved
    )
{
    ULONG result;

    HttpTrace2("=> HttpTerminate Flags=%ld Reserved=%p", Flags, Reserved);

    if( (NULL != Reserved) || (HTTP_ILLEGAL_TERM_FLAGS & Flags) )
    {
        result = ERROR_INVALID_PARAMETER;
    }
    else
    {
        ULONG tempResult;
        
        result = NO_ERROR;

        EnterCriticalSection( &g_InitCritSec );

        if ( (HTTP_INITIALIZE_SERVER) & Flags )
        {
            result = HttpApiTerminateListener( Flags );
        }

        if ( (HTTP_INITIALIZE_CLIENT) & Flags )
        {
            tempResult = HttpApiTerminateClient( Flags );

            result = ( NO_ERROR == result ) ? tempResult : NO_ERROR;
        }

        if ( (HTTP_INITIALIZE_CONFIG) & Flags )
        {
            tempResult = HttpApiTerminateConfiguration( Flags );

            result = ( NO_ERROR == result ) ? tempResult : NO_ERROR;
        }

        HttpApiTerminateResources( Flags );

        LeaveCriticalSection( &g_InitCritSec );

    }

    HttpTrace1( "<= HttpApiTerminate = 0x%0x", result );
        
    return result;

} // HttpTerminate


/***************************************************************************++

Routine Description:

    Predicate to test if DLL has been initalized.

--***************************************************************************/
BOOL
HttpIsInitialized(
    IN ULONG Flags
    )
{
    BOOL fRet = FALSE;

    //
    // Grab crit sec
    //
    EnterCriticalSection( &g_InitCritSec );

    if ( 0 == Flags )
    {
        fRet = (BOOL) (0 != g_InitResourcesRefCount );
    }
    else if ( HTTP_LEGAL_INIT_FLAGS & Flags )
    {
        fRet = (BOOL) (0 != g_InitResourcesRefCount );

        if ( HTTP_INITIALIZE_SERVER & Flags )
        {
            fRet &= (BOOL) (0 != g_InitServerRefCount);
        }

        if ( HTTP_INITIALIZE_CLIENT & Flags )
        {
            fRet &= (BOOL) (0 != g_InitClientRefCount);
        }

        if ( HTTP_INITIALIZE_CONFIG & Flags )
        {
            fRet &= (BOOL) (0 != g_InitConfigRefCount);
        }
    }

    LeaveCriticalSection( &g_InitCritSec );

    return fRet;

} // HttpIsInitalized


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Performs configuration initialization.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  With any Flags bit set we check the reference count
    and initialize the configuration if needed.  On success we increment the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiInitializeConfiguration(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiInitializeConfiguration Flags=%ld Reserved=%p", Flags);

    if ( HTTP_LEGAL_INIT_FLAGS & Flags )
    {
        result = NO_ERROR;

        if (  0 == g_InitConfigRefCount  )
        {
            // component not configured
            
            result = InitializeConfigurationGlobals();
        }
        else if ( MAXULONG == g_InitConfigRefCount )
        {
            // don't want to overflow the reference count
            
            result = ERROR_TOO_MANY_SEM_REQUESTS;
        }

        if ( NO_ERROR == result )
        {
             g_InitConfigRefCount++;
        }
    }

    HttpTrace2( "<= HttpApiInitializeConfiguration = 0x%0x RefCount = 0x%0x", result, g_InitConfigRefCount );

    return result;
    
}


/***************************************************************************++

Routine Description:

    Performs Resources initialization.  This internal function must be called 
    from with the critical section g_ApiCriticalSection held.  On success we
    increment the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for
            server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for 
            client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for
            applications that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiInitializeResources(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;
    ULONG count;

    HttpTrace1( "=> HttpApiInitializeResources Flags=%ld Reserved=%p", 
                      Flags);

    if ( ( HTTP_LEGAL_INIT_FLAGS & Flags ) || ( 0L == Flags ) )
    {
        result = NO_ERROR;
    
        // We increment the resources ref count twice
        // for every legal bit set.  We increment the ref count
        // once when the flags are ZERO.
        // HttpInitialize may be called with no flags indicating
        // that only the resources are to be initialized.  This
        // convention allows support for existing code.
            
        if ( 0 == Flags )
        {
            count = 1;
        }
        else
        {
            count  = 0;
            if ( HTTP_INITIALIZE_CLIENT & Flags ) count += 2;
            if ( HTTP_INITIALIZE_SERVER & Flags ) count += 2;
            if ( HTTP_INITIALIZE_CONFIG & Flags ) count += 2;
        }

        if ( MAXULONG-count < g_InitResourcesRefCount )
        {
            // don't want to overflow the reference count
                
            result = ERROR_TOO_MANY_SEM_REQUESTS;
        }
        else
        {
            g_InitResourcesRefCount += count;
        }
    }

    HttpTrace2( "<= HttpApiInitializeResources = 0x%0x RefCount = 0x%0x", 
                      result, 
                      g_InitResourcesRefCount );

    return result;
    
}

/***************************************************************************++

Routine Description:

    Private function to open a HTTP.sys control channel and enable it.

Arguments:

    ControlChannelHandle - Supplies a ptr to hold the control channel handle.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
DWORD
OpenAndEnableControlChannel(
    OUT PHANDLE pHandle
    )
{
    DWORD result;

    result = HttpOpenControlChannel(
                 pHandle,
                 0
                 );

    if ( NO_ERROR == result )
    {
        //
        // Turn on Control Channel
        //

        HTTP_ENABLED_STATE controlState = HttpEnabledStateActive;

        result = HttpSetControlChannelInformation(
                     *pHandle,
                     HttpControlChannelStateInformation,
                     &controlState,
                     sizeof(controlState)
                     );

        if ( NO_ERROR != result )
        {
            CloseHandle(*pHandle);

            *pHandle = NULL;
        }
    }

    return result;
}



/***************************************************************************++

Routine Description:

    Performs server initialization.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  With the HTTP_INITIALIZE_SERVER Flags bit set we 
    check the reference count and initialize the configuration if needed.  On success we 
    increment the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiInitializeListener(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiInitializeListener Flags=%ld Reserved=%p", Flags);

    if ( HTTP_INITIALIZE_SERVER & Flags )
    {
        result = NO_ERROR;

        if ( 0 == g_InitServerRefCount )
        {
            //
            // Start HTTPFilter service
            //
            HttpApiTryToStartDriver(HTTP_FILTER_SERVICE_NAME);

            //
            // Open Control channel
            //

            ASSERT( NULL == g_ControlChannel );

            result = OpenAndEnableControlChannel(
                        &g_ControlChannel
                        );

            if(NO_ERROR == result)
            {
                // 
                // Init Config Group Hash Table
                //
                result = InitializeConfigGroupTable();

                if(NO_ERROR != result)
                {
                    CloseHandle(g_ControlChannel);
                }
               
            }
        }

        else if ( MAXULONG == g_InitServerRefCount )
        {
            // don't want to overflow the reference count
            
            result = ERROR_TOO_MANY_SEM_REQUESTS;
        }

        if ( NO_ERROR == result )
        {
            g_InitServerRefCount++;
        }
    }

    HttpTrace2( "<= HttpApiInitializeListener = 0x%0x RefCount = 0x%0x", result, g_InitServerRefCount );

    return result;

} // HttpApiInitializeListener


/***************************************************************************++

Routine Description:

    Performs server initialization.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  With the HTTP_INITIALIZE_CLIENT Flags bit set we 
    check the reference count and initialize the configuration if needed.  On success we 
    increment the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiInitializeClient(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiInitializeClient Flags=%ld Reserved=%p", Flags);

    if ( HTTP_INITIALIZE_CLIENT & Flags )
    {
        result = NO_ERROR;

        if ( 0 == g_InitClientRefCount )
        {
            WORD    wVersionRequested;
            WSADATA wsaData;

            result            = NO_ERROR;
            wVersionRequested = MAKEWORD( 2, 2 );
        
            if(WSAStartup( wVersionRequested, &wsaData ) != 0)
            {
                result = GetLastError();
            }
        }
        else if ( MAXULONG == g_InitClientRefCount )
        {
            // don't want to overflow the reference count
            
            result = ERROR_TOO_MANY_SEM_REQUESTS;
        }

        if ( NO_ERROR == result )
        {
            g_InitClientRefCount++;
        }
    }

    HttpTrace2( "<= HttpApiInitializeClient = 0x%0x RefCount = 0x%0x", result, g_InitClientRefCount );

    return result;

} // HttpApiInitializeClient


/***************************************************************************++

Routine Description:

    Performs configuration termination.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  With any Flags bit set we check the reference count
    and terminate the configuration if needed.  On success we decrement the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiTerminateConfiguration(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiTerminateConfiguration Flags=%ld Reserved=%p", Flags);

    if ( (HTTP_INITIALIZE_CONFIG) & Flags )
    {
        result = NO_ERROR;

        if ( 0L == g_InitConfigRefCount )
        {
            //
            // Configuration not initalized, or init previously failed, or terminated
            // 
            result = ERROR_DLL_INIT_FAILED;
        }
        else
        {
            if ( 1L ==  g_InitConfigRefCount )
            {
                TerminateConfigurationGlobals();

                g_InitConfigRefCount = 0L;
            }
            else
            {
                g_InitConfigRefCount--;
            }
        }
    }

    HttpTrace2( "<= HttpApiTerminateConfiguration = 0x%0x RefCount = 0x%0x", result, g_InitConfigRefCount );

    return result;
    
}


/***************************************************************************++

Routine Description:

    Performs resource termination.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  On success we decrement the reference count.

    We need to hold onto the cache configuration if any of the other ref counts for server, client,
    or config are nonzero.  This is true because we need event objects available in the cache 
    for 'synchronous' IO calls to http.sys.

    As a result of our dependency on the other ref counts, HttpApiTerminateResources MUST be
    called last in HttpTerminate or any similar termination routine.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiTerminateResources(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiTerminateResources Flags=%ld Reserved=%p", Flags);

    if ( ( HTTP_LEGAL_TERM_FLAGS & Flags ) || ( 0L == Flags ) )
    {
        result = NO_ERROR;
    
        if ( 0L == g_InitResourcesRefCount )
        {
            //
            // Configuration not initalized, or init previously failed, or terminated
            // 
            result = ERROR_DLL_INIT_FAILED;
        }
        else 
        {
            ULONG count = 1;
            BOOL bTerminate = FALSE;

            // We decrement the resources ref count twice
            // for every legal initialization bit in the Flags.
            // We decrement the ref count once if the flags are ZERO.
            // HttpTerminate may be called with no flags indicating
            // that only the resources are to be released.  This
            // convention allows support for existing code.

            if ( 0 == Flags )
            {
                count = 1;
            }
            else
            {
                count  = 0;
                if ( HTTP_INITIALIZE_CLIENT & Flags ) count += 2;
                if ( HTTP_INITIALIZE_SERVER & Flags ) count += 2;
                if ( HTTP_INITIALIZE_CONFIG & Flags ) count += 2;
            }

            bTerminate = (BOOL) ( count >= g_InitResourcesRefCount );

            g_InitResourcesRefCount -= count;
            
            if ( bTerminate )
            {
                g_InitResourcesRefCount = 0L;
            }
        }
    }

    HttpTrace2( "<= HttpApiTerminateResources = 0x%0x RefCount = 0x%0x", result, g_InitResourcesRefCount );

    return result;
    
}


/***************************************************************************++

Routine Description:

    Performs server termination.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  With any Flags bit set we check the reference count
    and terminate the server context if needed.  On success we decrement the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiTerminateListener(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiTerminateListener Flags=%ld Reserved=%p", Flags);

    if ( (HTTP_INITIALIZE_SERVER) & Flags )
    {
        result = NO_ERROR;
    
        if ( 0L == g_InitServerRefCount )
        {
            //
            // DLL not initalized, or init previously failed, or terminated
            // 
            result = ERROR_DLL_INIT_FAILED;
        }
        else 
        {
            if ( 1L == g_InitServerRefCount )
            {
                // Clean up Config Group table
                TerminateConfigGroupTable();
            
                // Clean up Control Channel
                if ( g_ControlChannel )
                {
                    __try 
                    {
                        CloseHandle( g_ControlChannel );
                    }
                    __finally 
                    {
                        HttpTrace1(
                            "HttpTerminateListener: exception closing control channel handle %p\n",
                            g_ControlChannel
                            );
                    }

                    g_ControlChannel = NULL;
                }

                g_InitServerRefCount = 0L;

            }
            else
            {
                g_InitServerRefCount--;
            }
        }
    }
    
    HttpTrace2( "<= HttpApiTerminateListener = 0x%0x RefCount = 0x%0x", result, g_InitServerRefCount );

    return result;

} // HttpTerminateListener


/***************************************************************************++

Routine Description:

    Performs client termination.  This internal function must be called from with the critical
    section g_ApiCriticalSection held.  With any Flags bit set we check the reference count
    and terminate the client context if needed.  On success we decrement the reference count.

Arguments:

    Flags - 
        HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for server applications
        HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for client applications
        HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for applications
            that will modify the HTTP configuration.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiTerminateClient(
    IN ULONG Flags
    )
{
    ULONG result = ERROR_INVALID_PARAMETER;

    HttpTrace1("=> HttpApiTerminateClient Flags=%ld Reserved=%p", Flags);

    if ( HTTP_INITIALIZE_CLIENT & Flags )
    {
        result = NO_ERROR;

        if ( 0L == g_InitClientRefCount )
        {
            //
            // Configuration not initalized, or init previously failed, or terminated
            // 
            result = ERROR_DLL_INIT_FAILED;
        }
        else
        {
            if ( 1L == g_InitClientRefCount )
            {
                g_InitClientRefCount = 0L;

                // Unload Ssl filter, if it was loaded.
                UnloadStrmFilt();

                WSACleanup();
            }
            else
            {
                g_InitClientRefCount--;
            }
        }
    }

    HttpTrace2( "<= HttpApiTerminateClient = 0x%0x RefCount = 0x%0x", result, g_InitClientRefCount );

    return result;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\internal.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Internal.c

Abstract:

    User-mode interface to HTTP.SYS: Internal helper functions.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

    Rajesh Sundaram (rajeshsu)   10-Oct-2000 : Added HTTP client code

--*/


#include "precomp.h"

//
// Private macros.
//
#ifndef MAX
#define MAX(_a, _b) ((_a) > (_b)? (_a): (_b))
#endif
#define MAX_HTTP_DEVICE_NAME            \
    (MAX(MAX(sizeof(HTTP_SERVER_DEVICE_NAME)/sizeof(WCHAR), sizeof(HTTP_CONTROL_DEVICE_NAME)/sizeof(WCHAR)), \
         MAX(sizeof(HTTP_APP_POOL_DEVICE_NAME)/sizeof(WCHAR), sizeof(HTTP_FILTER_DEVICE_NAME)/sizeof(WCHAR))))


//
// Private prototypes.
//

NTSTATUS
HttpApiAcquireCachedEvent(
    OUT HANDLE *        phEvent
    );

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Synchronous wrapper around NtDeviceIoControlFile().

Arguments:

    FileHandle - Supplies a handle to the file on which the service is
        being performed.

    IoControlCode - Subfunction code to determine exactly what operation
        is being performed.

    pInputBuffer - Optionally supplies an input buffer to be passed to the
        device driver. Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the pInputBuffer in bytes.

    pOutputBuffer - Optionally supplies an output buffer to receive
        information from the device driver. Whether or not the buffer is
        actually optional is dependent on the IoControlCode.

    OutputBufferLength - Length of the pOutputBuffer in bytes.

    pBytesTransferred - Optionally receives the number of bytes transferred.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiSynchronousDeviceControl(
    IN  HANDLE   FileHandle,
    IN  ULONG    IoControlCode,
    IN  PVOID    pInputBuffer        OPTIONAL,
    IN  ULONG    InputBufferLength,
    OUT PVOID    pOutputBuffer       OPTIONAL,
    IN  ULONG    OutputBufferLength,
    OUT PULONG   pBytesTransferred   OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    LARGE_INTEGER timeout;
    HANDLE hEvent;

    //
    // Try to snag an event object.
    //

    status = HttpApiAcquireCachedEvent( &hEvent );

    if (NT_SUCCESS(status))
    {
        ASSERT( hEvent != NULL );
        
        //
        // Make the call.
        //

        status = NtDeviceIoControlFile(
                        FileHandle,                     // FileHandle
                        hEvent,                         // Event
                        NULL,                           // ApcRoutine
                        NULL,                           // ApcContext
                        &ioStatusBlock,                 // IoStatusBlock
                        IoControlCode,                  // IoControlCode
                        pInputBuffer,                   // InputBuffer
                        InputBufferLength,              // InputBufferLength
                        pOutputBuffer,                  // OutputBuffer
                        OutputBufferLength              // OutputBufferLength
                        );

        if (status == STATUS_PENDING)
        {
            //
            // Wait for it to complete.
            //

            timeout.LowPart = 0xFFFFFFFF;
            timeout.HighPart = 0x7FFFFFFF;

            status = NtWaitForSingleObject( hEvent,
                                            FALSE,
                                            &timeout );
            ASSERT( status == STATUS_SUCCESS );

            status = ioStatusBlock.Status;
        }

        //
        // If the call didn't fail and the caller wants the number
        // of bytes transferred, grab the value from the I/O status
        // block & return it.
        //

        if (!NT_ERROR(status) && pBytesTransferred != NULL)
        {
            *pBytesTransferred = (ULONG)ioStatusBlock.Information;
        }

        //
        // Note: We do not have to release the cached event.  The event is associated
        // with this thread using TLS.  There is nothing to cleanup now.
        // The event will be cleaned up when the thread goes away.
        //
    }

    return HttpApiNtStatusToWin32Status( status );

}   // HttpApiSynchronousDeviceControl


/***************************************************************************++

Routine Description:

    Overlapped wrapper around NtDeviceIoControlFile().

Arguments:

    FileHandle - Supplies a handle to the file on which the service is
        being performed.

    pOverlapped - Supplies an OVERLAPPED structure.

    IoControlCode - Subfunction code to determine exactly what operation
        is being performed.

    pInputBuffer - Optionally supplies an input buffer to be passed to the
        device driver. Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the pInputBuffer in bytes.

    pOutputBuffer - Optionally supplies an output buffer to receive
        information from the device driver. Whether or not the buffer is
        actually optional is dependent on the IoControlCode.

    OutputBufferLength - Length of the pOutputBuffer in bytes.

    pBytesTransferred - Optionally receives the number of bytes transferred.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiOverlappedDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    NTSTATUS status;
    ULONG result;

    //
    // Overlapped I/O gets a little more interesting. We'll strive to be
    // compatible with NT's KERNEL32 implementation. See DeviceIoControl()
    // in \sdnt\base\win32\client\filehops.c for the gory details.
    //

    ASSERT(pOverlapped);

    SET_STATUS_OVERLAPPED_TO_IO_STATUS(pOverlapped, STATUS_PENDING);

    status = NtDeviceIoControlFile(
                    FileHandle,                         // FileHandle
                    pOverlapped->hEvent,                // Event
                    NULL,                               // ApcRoutine
                    (ULONG_PTR)pOverlapped->hEvent & 1  // ApcContext
                        ? NULL : pOverlapped,
                    OVERLAPPED_TO_IO_STATUS(pOverlapped), // IoStatusBlock
                    IoControlCode,                      // IoControlCode
                    pInputBuffer,                       // InputBuffer
                    InputBufferLength,                  // InputBufferLength
                    pOutputBuffer,                      // OutputBuffer
                    OutputBufferLength                  // OutputBufferLength
                    );

    //
    // Set LastError using the original status returned so RtlGetLastNtStatus
    // RtlGetLastWin32Error will get the correct status.
    //

    result = HttpApiNtStatusToWin32Status( status );

    //
    // Convert all informational and warning status to ERROR_IO_PENDING so
    // user can always expect the completion routine gets called.
    //

    if (NT_INFORMATION(status) || NT_WARNING(status))
    {
        result = ERROR_IO_PENDING;
    }

    //
    // If the call didn't fail or pend and the caller wants the number of
    // bytes transferred, grab the value from the I/O status block &
    // return it.
    //

    if (result == NO_ERROR && pBytesTransferred)
    {
        //
        // We need a __try __except to mimic DeviceIoControl().
        // 

        __try
        {
            *pBytesTransferred =
                (ULONG)OVERLAPPED_TO_IO_STATUS(pOverlapped)->Information;
        } 
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            *pBytesTransferred = 0;
        }
    }

    return result;

}   // HttpApiOverlappedDeviceControl


/***************************************************************************++

Routine Description:

    This routine checks to see if a service has been started. If the service
    is in START_PENDING, it waits for it to start completely.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--***************************************************************************/
BOOLEAN
QueryAndWaitForServiceStart(
    IN SC_HANDLE svcHandle
    )
{
    SERVICE_STATUS Status;

    for(;;)
    {
        if(!QueryServiceStatus(svcHandle, &Status))
        {
            return FALSE;
        }

        switch(Status.dwCurrentState)
        {
            case SERVICE_RUNNING:
                return TRUE;
                break;

            case SERVICE_START_PENDING:

                // Yield to another thread on current processor. If
                // no threads are ready to run on the current 
                // processor, we'll have to sleep to avoid consuming 
                // too much CPU in what would look almost like a busy
                // wait
                
                if(!SwitchToThread())
                {
                    Sleep(50);
                }
                break;

            default:
                return FALSE;
                break;
        }
    } 
}

/***************************************************************************++

Routine Description:

    This routine attempts to start HTTP.SYS.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--***************************************************************************/
BOOLEAN
HttpApiTryToStartDriver(
    IN PWSTR ServiceName
    )
{
    BOOLEAN result;
    SC_HANDLE scHandle;
    SC_HANDLE svcHandle;

    result = FALSE; // until proven otherwise...

    //  
    // NOTE: 
    //
    // If an auto-start service calls into HTTP from their Service Entry
    // point AND if they have not laid out a dependency on the HTTP service,
    // we will deadlock. This is because ServiceStart() will not return until
    // all auto-start services are started.
    //
    // We "could" check for this by checking the status on the named event 
    // called SC_AUTOSTART_EVENTNAME. If this event is signalled, we have
    // completed autostart. However, this event cannot be opened by non-admin
    // processes. Therefore, we'll just not even bother checking for this.
    //

    //
    // Open the service controller.
    //

    scHandle = OpenSCManagerW(
                   NULL,                        // lpMachineName
                   NULL,                        // lpDatabaseName
                   SC_MANAGER_CONNECT           // dwDesiredAccess
                   );

    if (scHandle != NULL)
    {
        //
        // Try to open the HTTP service.
        //

        svcHandle = OpenServiceW(
                        scHandle,                            // hSCManager
                        ServiceName,                         // lpServiceName
                        SERVICE_START | SERVICE_QUERY_STATUS // dwDesiredAccess
                        );

        if (svcHandle != NULL)
        {
            //
            // First, see if the service is already started. We can't call
            // ServiceStart() directly, because of the SCM deadlock mentioned
            // above.
            //

            if(QueryAndWaitForServiceStart(svcHandle))
            {
                // If the service is already running, we don't have to do 
                // anything else.

                result = TRUE;
            } 
            else
            {

                //
                // Service is not running. So, we try to start it, and wait 
                // the start to complete.
                //
    
                if (StartService( svcHandle, 0, NULL))
                {
                    if(QueryAndWaitForServiceStart(svcHandle))
                    {
                        result = TRUE;
                    }
                }
                else
                {
                    if(ERROR_SERVICE_ALREADY_RUNNING == GetLastError())
                    {
                        // some other thread has already started this service,
                        // let's treat this as success.
    
                        result = TRUE;
                    }
                }
            }

            CloseServiceHandle( svcHandle );
        }

        CloseServiceHandle( scHandle );
    }

    return result;

}   // HttpTryToStartDriver


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Helper routine for opening a HTTP.SYS handle.

Arguments:

    pHandle - Receives a handle if successful.

    DesiredAccess - Supplies the types of access requested to the file.

    HandleType - one of Filter, ControlChannel, or AppPool

    pObjectName - Optionally supplies the name of the application pool
        to create/open.

    Options - Supplies zero or more HTTP_OPTION_* flags.

    CreateDisposition - Supplies the creation disposition for the new
        object.

    pSecurityAttributes - Optionally supplies security attributes for
        the newly created application pool. Ignored if opening a
        control channel.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpApiOpenDriverHelper(
    OUT PHANDLE              pHandle,
    IN  PWCHAR               Uri,
    IN  USHORT               UriLength,
    IN  PWCHAR               Proxy,
    IN  USHORT               ProxyLength,
    IN  PTRANSPORT_ADDRESS   pTransportAddress,
    IN  USHORT               TransportAddressLength,
    IN  ACCESS_MASK          DesiredAccess,
    IN  HTTPAPI_HANDLE_TYPE  HandleType,
    IN  PCWSTR               pObjectName         OPTIONAL,
    IN  ULONG                Options,
    IN  ULONG                CreateDisposition,
    IN  PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL
    )
{
    NTSTATUS                      status;
    OBJECT_ATTRIBUTES             objectAttributes;
    UNICODE_STRING                deviceName;
    IO_STATUS_BLOCK               ioStatusBlock;
    ULONG                         shareAccess;
    ULONG                         createOptions;
    PFILE_FULL_EA_INFORMATION     pEaBuffer;
    WCHAR                         deviceNameBuffer[MAX_HTTP_DEVICE_NAME + MAX_PATH + 2];
    PHTTP_OPEN_PACKET             pOpenVersion;
    ULONG                         EaBufferLength;

    //
    // Validate the parameters.
    //

    if ((pHandle == NULL) ||
        (Options & ~HTTP_OPTION_VALID)) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ((HandleType != HttpApiControlChannelHandleType) &&
        (HandleType != HttpApiFilterChannelHandleType) &&
        (HandleType != HttpApiAppPoolHandleType) &&
        (HandleType != HttpApiServerHandleType))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build the open packet.
    //

    EaBufferLength = 
        sizeof(HTTP_OPEN_PACKET)         +
        HTTP_OPEN_PACKET_NAME_LENGTH     +
        sizeof(FILE_FULL_EA_INFORMATION);

    pEaBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                0,
                                EaBufferLength
                                );

    if(!pEaBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the first EA which will contain the version info.
    //
    
    pEaBuffer->Flags           = 0;
    pEaBuffer->EaNameLength    = HTTP_OPEN_PACKET_NAME_LENGTH;
    pEaBuffer->EaValueLength   = sizeof(*pOpenVersion);
    pEaBuffer->NextEntryOffset = 0;

    RtlCopyMemory(
                  pEaBuffer->EaName,
                  HTTP_OPEN_PACKET_NAME,
                  HTTP_OPEN_PACKET_NAME_LENGTH + 1);

    pOpenVersion = (PHTTP_OPEN_PACKET)
                    (pEaBuffer->EaName +pEaBuffer->EaNameLength + 1);

    pOpenVersion->MajorVersion           = HTTP_INTERFACE_VERSION_MAJOR;
    pOpenVersion->MinorVersion           = HTTP_INTERFACE_VERSION_MINOR;
    pOpenVersion->ServerNameLength       = UriLength;
    pOpenVersion->pServerName            = Uri;
    pOpenVersion->ProxyNameLength        = ProxyLength;
    pOpenVersion->pProxyName             = Proxy;
    pOpenVersion->pTransportAddress      = pTransportAddress;
    pOpenVersion->TransportAddressLength = TransportAddressLength;

    //
    // Build the device name.
    //

    if(HandleType == HttpApiControlChannelHandleType)
    {
        //
        // It's a control channel, so just use the appropriate device name.
        //

        wcscpy( deviceNameBuffer, HTTP_CONTROL_DEVICE_NAME );
    }
    else if (HandleType == HttpApiFilterChannelHandleType)
    {
        //
        // It's a fitler channel, so start with the appropriate
        // device name.
        //

        wcscpy( deviceNameBuffer, HTTP_FILTER_DEVICE_NAME );
    }
    else  if(HandleType == HttpApiAppPoolHandleType)
    {
        //
        // It's an app pool, so start with the appropriate device name.
        //

        wcscpy( deviceNameBuffer, HTTP_APP_POOL_DEVICE_NAME );

        //
        // Set WRITE_OWNER in DesiredAccess if AppPool is a controller.
        //
    
        if ((Options & HTTP_OPTION_CONTROLLER))
        {
            DesiredAccess |= WRITE_OWNER;
        }
    }
    else 
    {
        ASSERT(HandleType == HttpApiServerHandleType);
        wcscpy( deviceNameBuffer, HTTP_SERVER_DEVICE_NAME );
    }

    if (pObjectName != NULL )
    {
        //
        // It's a named object, so append a slash and the name,
        // but first check to ensure we don't overrun our buffer.
        //
        if ((wcslen(deviceNameBuffer) + wcslen(pObjectName) + 2)
                > DIMENSION(deviceNameBuffer))
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        wcscat( deviceNameBuffer, L"\\" );
        wcscat( deviceNameBuffer, pObjectName );
    }

    //
    // Determine the share access and create options based on the
    // Flags parameter.
    //

    shareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
    createOptions = 0;

    //
    // Build the object attributes.
    //

    status = RtlInitUnicodeStringEx( &deviceName, deviceNameBuffer );

    if ( !NT_SUCCESS(status) )
    {
        goto complete;
    }

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE,                   // Attributes
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    if (pSecurityAttributes != NULL)
    {
        objectAttributes.SecurityDescriptor = 
           pSecurityAttributes->lpSecurityDescriptor;

        if (pSecurityAttributes->bInheritHandle)
        {
            objectAttributes.Attributes |= OBJ_INHERIT;
        }
    }

    //
    // Open the UL device.
    //

    status = NtCreateFile(
                pHandle,                        // FileHandle
                DesiredAccess,                  // DesiredAccess
                &objectAttributes,              // ObjectAttributes
                &ioStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0,                              // FileAttributes
                shareAccess,                    // ShareAccess
                CreateDisposition,              // CreateDisposition
                createOptions,                  // CreateOptions
                pEaBuffer,                      // EaBuffer
                EaBufferLength                  // EaLength
                );

complete:

    if (!NT_SUCCESS(status))
    {
        *pHandle = NULL;
    }

    RtlFreeHeap(RtlProcessHeap(),
                0,
                pEaBuffer);

    return status;

}   // HttpApiOpenDriverHelper


/***************************************************************************++

Routine Description:

    Acquires a short-term event from the global event cache. This event
    object may only be used for pseudo-synchronous I/O.

    We will cache the event and associate it with the thread using TLS.
    Therefore acquiring the event simply means checking whether we already
    have an associated event with TLS.  If not, we'll create an event and
    associate it.  

Arguments:

    phEvent - Receives handle to event

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpApiAcquireCachedEvent(
    HANDLE *                phEvent
    )
{
    NTSTATUS                status;
    HANDLE                  hEvent = NULL;

    //
    // See if an event was already associated with TLS
    //

    hEvent = TlsGetValue( g_TlsIndex );
    if (hEvent == NULL)
    {
        //
        // No event associated.  Create one now
        //
                    
        status = NtCreateEvent(
                     &hEvent,                           // EventHandle
                     EVENT_ALL_ACCESS,                  // DesiredAccess
                     NULL,                              // ObjectAttributes
                     SynchronizationEvent,              // EventType
                     FALSE                              // InitialState
                     );
                     
        if (!NT_SUCCESS( status ))
        {
            return status;   
        }

        //
        // Associate so subsequent requests on this thread don't have to
        // create the event
        //

        if (!TlsSetValue( g_TlsIndex, hEvent ))
        {
            //
            // If we couldn't set the TLS, then something really bad
            // happened.  Bail with error
            //

            NtClose( hEvent );

            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    *phEvent = hEvent;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\serverconfig.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    ServerConfig.c

Abstract:

    Code for handling server configuration APIs.

Author:

    Rajesh Sundaram (rajeshsu)    1-Nov-2001

Revision History:

    Eric Stenson    (ericsten)  **-***-**** -- Add IP Listen support.
    Rajesh Sundaram (rajeshsu)  16-Apr-2002 -- Add URL ACL support.

--*/



#include "precomp.h"
#include <stdio.h>
#include <search.h>
#include <Shlwapi.h>
#include <sddl.h>

#define HTTP_PARAM_KEY \
    L"System\\CurrentControlSet\\Services\\HTTP\\Parameters"
#define URLACL_REGISTRY_KEY                  HTTP_PARAM_KEY L"\\UrlAclInfo"

//
// Keys for synchronizing registry access.
//

#define HTTP_SYNCHRONIZE_KEY                 HTTP_PARAM_KEY L"\\Synchronize"
#define SSL_REGISTRY_KEY_SYNCHRONIZE         L"SSL"
#define IP_REGISTRY_KEY_SYNCHRONIZE          L"IPListen"

HKEY    g_SynchronizeRegistryHandle;

//
// SSL Config
//

#define SSL_REGISTRY_KEY                     HTTP_PARAM_KEY L"\\SslBindingInfo"
#define SSL_CERT_HASH                        L"SslCertHash"
#define SSL_APPID                            L"AppId"
#define SSL_CERT_STORE_NAME                  L"SslCertStoreName"
#define SSL_CERT_CHECK_MODE                  L"DefaultSslCertCheckMode"
#define SSL_REVOCATION_FRESHNESS_TIME L"DefaultSslRevocationFreshnessTime"
#define SSL_REVOCATION_URL_RETRIEVAL_TIMEOUT \
                    L"DefaultSslRevocationUrlRetrievalTimeout"
#define SSL_CTL_IDENTIFIER                   L"DefaultSslCtlIdentifier"
#define SSL_CTL_STORENAME                    L"DefaultSslCtlStoreName"
#define SSL_FLAGS                            L"DefaultFlags"

HKEY    g_SslRegistryHandle;

HANDLE g_ServiceControlChannelHandle;
HKEY   g_UrlAclRegistryHandle;

//
// IP Listen Only Config
//

#define IP_LISTEN_ONLY_VALUE                 L"ListenOnlyList"


// 
// Macros.
//

// NOTE: REG_QUERY_VALUE will not raise an exception for ERROR_FILE_NOT_FOUND
// because not all parameters are mandatory (e.g. SslCtlIdentifier).

#define REG_QUERY_VALUE(Status, Handle, Value, pBuffer,  BytesAvail)    \
{                                                                       \
    (Status) = RegQueryValueEx(                                         \
                (Handle),                                               \
                (Value),                                                \
                0,                                                      \
                NULL,                                                   \
                (PVOID)(pBuffer),                                       \
                &(BytesAvail)                                           \
                );                                                      \
                                                                        \
    if((Status) != NO_ERROR && (Status) != ERROR_FILE_NOT_FOUND)        \
    {                                                                   \
        __leave;                                                        \
    }                                                                   \
}

#define ADVANCE_BUFFER(Status, pSrc, lSrc, pBuffer, BytesAvail, pWritten) \
{                                                                         \
    if((Status) == NO_ERROR)                                              \
    {                                                                     \
        (pSrc) = (PVOID)(pBuffer);                                        \
        (lSrc) = (BytesAvail);                                            \
        *(pWritten) += ALIGN_UP((BytesAvail), PVOID);                     \
        (pBuffer) += ALIGN_UP((BytesAvail), PVOID);                       \
    }                                                                     \
}


#define REG_SET_VALUE(Status, Handle, Value, Type, pBuffer, Length)  \
{                                                                    \
    (Status) = RegSetValueEx((Handle),                               \
                            (Value),                                 \
                            0,                                       \
                            (Type),                                  \
                            (PVOID)(pBuffer),                        \
                            (Length)                                 \
                            );                                       \
    if((Status) != ERROR_SUCCESS)                                    \
    {                                                                \
        __leave;                                                     \
    }                                                                \
}

#define REG_SET_SZ(Status, Handle, Value, pBuffer)                   \
{                                                                    \
    if((pBuffer))                                                    \
    {                                                                \
        REG_SET_VALUE((Status),                                      \
                      (Handle),                                      \
                      (Value),                                       \
                      REG_SZ,                                        \
                      (pBuffer),                                     \
                      (ULONG)(wcslen((pBuffer)) + 1) * sizeof(WCHAR) \
                      );                                             \
    }                                                                \
} 


//
// Internal Functions.
//

DWORD
ComputeSockAddrLength(
    IN PSOCKADDR pSockAddr
    )
{
    DWORD dwLength;

    switch(pSockAddr->sa_family)
    {
        case AF_INET:
            dwLength = sizeof(SOCKADDR_IN);
            break; 

        case AF_INET6:
            dwLength = sizeof(SOCKADDR_IN6);
            break;

        default:
            dwLength = 0;
            break;
    }

    return dwLength;
}

/***************************************************************************++

Routine Description:

    Performs initialization of the configuration globals.

Arguments:

    None.

Return Value:

    Success/Failure.

--***************************************************************************/

ULONG
InitializeConfigurationGlobals()
{
    ULONG            Status, Disposition;
    WORD             wVersionRequested;
    WSADATA          wsaData;

    //
    // Init to NULL
    //
    g_SynchronizeRegistryHandle = NULL;
    g_SslRegistryHandle         = NULL;

    wVersionRequested = MAKEWORD( 2, 2 );

    if(WSAStartup( wVersionRequested, &wsaData ) != 0)
    {
        return GetLastError();
    }

    //
    // Create the SSL registry key.
    //
    Status = RegCreateKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SSL_REGISTRY_KEY,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &g_SslRegistryHandle,
                  &Disposition
                  );

    if(NO_ERROR != Status)
    {
        TerminateConfigurationGlobals();
        return Status;
    }


    //
    // Create the Synchronize registry key.
    //
    
    Status = RegCreateKeyEx(
                  HKEY_LOCAL_MACHINE,
                  HTTP_SYNCHRONIZE_KEY,
                  0,
                  NULL,
                  REG_OPTION_VOLATILE,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &g_SynchronizeRegistryHandle,
                  &Disposition
                  );

    if(NO_ERROR != Status)
    {
        TerminateConfigurationGlobals();
        return Status;
    }

    // 
    // URL ACL registry key.
    // 
    Status = RegCreateKeyEx(
                  HKEY_LOCAL_MACHINE,
                  URLACL_REGISTRY_KEY,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &g_UrlAclRegistryHandle,
                  &Disposition
                  );

    if(NO_ERROR != Status)
    {
        TerminateConfigurationGlobals();
        return Status;
    }

    //
    // Control channel for URL ACL.
    //
   
    Status = OpenAndEnableControlChannel(&g_ServiceControlChannelHandle);

    if(NO_ERROR != Status)
    {
        TerminateConfigurationGlobals();
        return Status;
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Performs termination of the configuration globals.

Arguments:

    None.

Return Value:

    None.
--***************************************************************************/

VOID 
TerminateConfigurationGlobals(VOID)
{
    WSACleanup();

    if(g_SynchronizeRegistryHandle)
    {
        RegCloseKey(g_SynchronizeRegistryHandle);
        g_SynchronizeRegistryHandle = NULL;
    }

    if(g_SslRegistryHandle)
    {
        RegCloseKey(g_SslRegistryHandle);
        g_SslRegistryHandle = NULL;
    }

    if(g_UrlAclRegistryHandle)
    {
        RegCloseKey(g_UrlAclRegistryHandle);
        g_UrlAclRegistryHandle = NULL;
    }

    if(g_ServiceControlChannelHandle)
    {
        CloseHandle(g_ServiceControlChannelHandle);
        g_ServiceControlChannelHandle = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Acquires a process wide mutex (for interprocess synchronization). We could
    make this into a MRSW lock, but that's not going to help us a whole lot
    since Set/Delete are rare operations & there is only one reader.

Arguments:

    None.

Return Value:

    None.
--***************************************************************************/

_inline
DWORD
AcquireHttpRegistryMutex(
    PWCHAR pKey
    )
{
    DWORD  Status;
    DWORD  Disposition;
    HKEY   SubKeyHandle;
    HANDLE hEvent = NULL;

    for(;;)
    {
        Status = RegCreateKeyEx(
                  g_SynchronizeRegistryHandle,
                  pKey,
                  0,
                  NULL,
                  REG_OPTION_VOLATILE,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &SubKeyHandle,
                  &Disposition
                  );

        if(Status != ERROR_SUCCESS)
        {
            return Status;
        }

        RegCloseKey(SubKeyHandle);

        if(Disposition == REG_OPENED_EXISTING_KEY)
        {
            // Some other thread has acquired the lock. We'll wait till we 
            // own the lock.  In order to do this, we register for change 
            // notification for g_SynchronizeRegistryHandle (i.e the owner
            // thread deletes the HTTP_SYNCHRONIZE_KEY key).
            //
            // Now, there are two issues here. There could be a race where
            // the key gets deleted just before we call RegNotifyChangeKeyValue
            // In order to protect from this, we add a timeout to the Wait 
            // routine.
            // 
            // Secondly, we could get woken when the app changes other parts 
            // of the registry under g_SynchronizeRegistryHandle. However, 
            // since Sets & deletes are not common operations, this is OK.

            //
            // We don't care about the return value of RegNotifyChangeKeyValue
            // If it fails, we'll just wait till the timeout expires.
            //

            if(!hEvent)
            {
                hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        
                if(!hEvent)
                {
                    return GetLastError();
                }
            }

            RegNotifyChangeKeyValue(
                    g_SynchronizeRegistryHandle, 
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME,
                    hEvent,
                    TRUE
                    );

            if(WaitForSingleObject(
                        hEvent, 
                        10000       // 10 seconds.
                        ) == WAIT_FAILED)
            {
                CloseHandle(hEvent);
                return GetLastError();
            }
        }
        else
        {
            // We've acquired the lock.

            break;
        }
    }

    if(hEvent)
    {
        CloseHandle(hEvent);
    }

    return ERROR_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Releases a process wide mutex (for interprocess synchronization)

Arguments:

    None.

Return Value:

    None.
--***************************************************************************/
_inline
VOID
ReleaseHttpRegistryMutex(
    IN PWCHAR pKey
    )
{
    RegDeleteKey(g_SynchronizeRegistryHandle, pKey);
}

/***************************************************************************++

Routine Description:

    Internal function that sets SSL configuration.

Arguments:
    pConfigInformation      - pointer to HTTP_SERVICE_CONFIG_SSL_SET
    ConfigInformationLength - length of input buffer.


Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
SetSslServiceConfiguration(
    IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength
    )
{
    ULONG                        Status = NO_ERROR;
    HKEY                         SubKeyHandle = NULL;
    PHTTP_SERVICE_CONFIG_SSL_SET pSslConfig;
    WCHAR                        IpAddrBuff[MAX_PATH];
    DWORD                        dwIpAddrLength, Disposition;
    DWORD                        dwSockAddrLength;
    BOOLEAN                      bDeleteCreatedKey = FALSE;

    //
    //  Parameter validation.
    //
    
    pSslConfig = (PHTTP_SERVICE_CONFIG_SSL_SET) pConfigInformation;
    
    if(!pSslConfig ||
       ConfigInformationLength != sizeof(HTTP_SERVICE_CONFIG_SSL_SET))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // acquire the mutex to prevent other processes from reading this
    // since we are acquiring a machine wide mutex, we need to ensure
    // that we release the mutex if the app passes bad parameters.

    // Acquire the mutex.

    __try 
    {
        if((Status = 
            AcquireHttpRegistryMutex(SSL_REGISTRY_KEY_SYNCHRONIZE)) != NO_ERROR)
        {   
            __leave;
        }

        // Convert the address into a string.
        //
    
        dwIpAddrLength = MAX_PATH; 

        dwSockAddrLength = ComputeSockAddrLength(pSslConfig->KeyDesc.pIpPort);

        if(dwSockAddrLength == 0)
        {
            Status = ERROR_NOT_SUPPORTED;
            __leave;
        }

        Status = WSAAddressToString(
                        pSslConfig->KeyDesc.pIpPort, 
                        dwSockAddrLength,
                        NULL,
                        IpAddrBuff,
                        &dwIpAddrLength
                        );

        if(Status != NO_ERROR)
        {
            __leave;
        }

        // First, we try to create the IP:port. If this already exists,
        // we'll bail. 

        Status = RegCreateKeyEx(
                  g_SslRegistryHandle,
                  IpAddrBuff,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &SubKeyHandle,
                  &Disposition
                  );

        if(Status != ERROR_SUCCESS)
        {
            __leave;
        }

        if(Disposition == REG_OPENED_EXISTING_KEY)
        {
            Status = ERROR_ALREADY_EXISTS;
            __leave;
        }

        // 
        // Any errors from now onwards should delete the key.
        //
        bDeleteCreatedKey = TRUE;

        // 
        // REG_BINARY: Cert Hash
        //
        REG_SET_VALUE(Status,
                      SubKeyHandle, 
                      SSL_CERT_HASH,
                      REG_BINARY,
                      pSslConfig->ParamDesc.pSslHash,
                      pSslConfig->ParamDesc.SslHashLength
                      );

        // 
        // REG_BINARY: AppID
        //
        REG_SET_VALUE(Status,
                      SubKeyHandle, 
                      SSL_APPID,
                      REG_BINARY,
                      &pSslConfig->ParamDesc.AppId,
                      sizeof(pSslConfig->ParamDesc.AppId)
                      );

        // 
        // REG_DWORD: The Cert Check Mode.
        //
        REG_SET_VALUE(Status,
                      SubKeyHandle, 
                      SSL_CERT_CHECK_MODE,
                      REG_DWORD,
                      &pSslConfig->ParamDesc.DefaultCertCheckMode,
                      sizeof(pSslConfig->ParamDesc.DefaultCertCheckMode)
                      );

        //
        // REG_DWORD: The revocation freshness time
        //

        REG_SET_VALUE(
                 Status,
                 SubKeyHandle, 
                 SSL_REVOCATION_FRESHNESS_TIME,
                 REG_DWORD,
                 &pSslConfig->ParamDesc.DefaultRevocationFreshnessTime,
                 sizeof(pSslConfig->ParamDesc.DefaultRevocationFreshnessTime)
                 );

        //
        // REG_DWORD: The URL Retrieval Timeout
        //
        REG_SET_VALUE(
             Status,
             SubKeyHandle, 
             SSL_REVOCATION_URL_RETRIEVAL_TIMEOUT,
             REG_DWORD,
             &pSslConfig->ParamDesc.DefaultRevocationUrlRetrievalTimeout,
             sizeof(pSslConfig->ParamDesc.DefaultRevocationUrlRetrievalTimeout)
             );

        // 
        // REG_DWORD: SSL Flags
        //
        REG_SET_VALUE(Status,
                      SubKeyHandle, 
                      SSL_FLAGS,
                      REG_DWORD,
                      &pSslConfig->ParamDesc.DefaultFlags,
                      sizeof(pSslConfig->ParamDesc.DefaultFlags)
                      );

        // 
        // REG_SZ: The Cert Store name.
        //

        REG_SET_SZ(Status,
                   SubKeyHandle, 
                   SSL_CERT_STORE_NAME,
                   pSslConfig->ParamDesc.pSslCertStoreName
                   );

        //
        // REG_SZ: The CTL Identifier
        //

        REG_SET_SZ(Status,
                   SubKeyHandle, 
                   SSL_CTL_IDENTIFIER,
                   pSslConfig->ParamDesc.pDefaultSslCtlIdentifier
                   );

        // 
        // REG_SZ: The CTL Store name.
        //

        REG_SET_SZ(Status,
                   SubKeyHandle, 
                   SSL_CTL_STORENAME,
                   pSslConfig->ParamDesc.pDefaultSslCtlStoreName
                   );

    }
    __finally
    {

        if(SubKeyHandle)
        {
            RegCloseKey(SubKeyHandle);
            SubKeyHandle = NULL;
        }

        if(Status != NO_ERROR && bDeleteCreatedKey)
        {
            // Recursively delete subkeys & all descendents.
            SHDeleteKey(g_SslRegistryHandle, IpAddrBuff);
        }

        // Free the mutex.
        //
        ReleaseHttpRegistryMutex(SSL_REGISTRY_KEY_SYNCHRONIZE);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Internal function that deletes SSL configuration.

Arguments:
    pConfigInformation      - pointer to HTTP_SERVICE_CONFIG_SSL_SET
    ConfigInformationLength - length of input buffer.

Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
DeleteSslServiceConfiguration(
    IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength
    )
{
    ULONG                        Status = NO_ERROR;
    PHTTP_SERVICE_CONFIG_SSL_SET pSslConfig;
    WCHAR                        IpAddrBuff[MAX_PATH];
    DWORD                        dwIpAddrLength;
    DWORD                        dwSockAddrLength;

    //
    //  Parameter validation.
    //
    
    pSslConfig = (PHTTP_SERVICE_CONFIG_SSL_SET) pConfigInformation;
    
    if(!pSslConfig ||
       ConfigInformationLength != sizeof(HTTP_SERVICE_CONFIG_SSL_SET))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // acquire the mutex to prevent other processes from reading this
    // since we are acquiring a machine wide mutex, we need to ensure
    // that we release the mutex if the app passes bad parameters.

    __try 
    {
        if((Status = 
            AcquireHttpRegistryMutex(SSL_REGISTRY_KEY_SYNCHRONIZE)) != NO_ERROR)
        {   
            __leave;
        }

        // Convert the address into a string.
        //
     
        dwIpAddrLength   = MAX_PATH; 
        dwSockAddrLength = ComputeSockAddrLength(pSslConfig->KeyDesc.pIpPort);

        if(dwSockAddrLength == 0)
        {
            Status = ERROR_NOT_SUPPORTED;
            __leave;
        }

        Status = WSAAddressToString(
                        pSslConfig->KeyDesc.pIpPort, 
                        dwSockAddrLength,
                        NULL,
                        IpAddrBuff,
                        &dwIpAddrLength
                        );

        if(Status != NO_ERROR)
        {
            __leave;
        }

        //
        // Recursively delete all subkeys under this.
        //
        Status = SHDeleteKey(g_SslRegistryHandle, IpAddrBuff);

    }
    __finally
    {
        // Free the mutex.
        //
        ReleaseHttpRegistryMutex(SSL_REGISTRY_KEY_SYNCHRONIZE);
    }


    return Status;
}

/***************************************************************************++

Routine Description:

    Internal function that queries SSL configuration for a exact match. This
    routine is called with the SSL Mutex acquired.

Arguments:
    pInput        - pointer to HTTP_SERVICE_CONFIG_SSL_QUERY
    InputLength   - length of input buffer.
    pOutput       - pointer to output buffer
    OutputLength  - sizeof output buffer
    pReturnLength - Bytes written/needed.

Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
QuerySslServiceConfigurationExact(
    IN PWCHAR                       lpszIpAddrBuff,
    IN PCHAR                        pBuffer,
    OUT PULONG                      pReturnLength,
    IN ULONG                        BytesAvailable
    )
{
    DWORD Status           = NO_ERROR;
    HKEY  SubKeyHandle     = NULL;
    DWORD dwSockAddrLength = sizeof(SOCKADDR_STORAGE);
    DWORD BytesRequired, ValueCount, MaxValueLength;
    PHTTP_SERVICE_CONFIG_SSL_SET pSslSet;

    //
    // Validate output parameters.
    //

    pSslSet = (PHTTP_SERVICE_CONFIG_SSL_SET) pBuffer;

    Status = RegOpenKeyEx(
                  g_SslRegistryHandle,
                  lpszIpAddrBuff,
                  0,
                  KEY_READ | KEY_WRITE,
                  &SubKeyHandle
                  );

    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    __try
    {
        Status = RegQueryInfoKey(
                      SubKeyHandle,
                      NULL,                 // class buffer
                      0,                    // sizeof class buffer
                      NULL,                 // reserved
                      NULL,                 // # of subkeys
                      NULL,                 // longest subkey name
                      NULL,                 // longest class string
                      &ValueCount,          // # of value entries.
                      NULL,                 // longest value name
                      &MaxValueLength,      // longest value data
                      NULL,                 // security descriptor length
                      NULL                  // last write time
                      );
    
        if(Status != ERROR_SUCCESS)
        {
            __leave;
        }

        //
        // MaxValueLength does not include the size of the NULL terminator,
        // so let's compensate for that.
        //

        MaxValueLength += sizeof(WCHAR);

        //
        // We'll assume that all the Value's under SubKey are of MaxValueLength
        // that keeps things a lot simpler.
        //

        BytesRequired = dwSockAddrLength + 
                        sizeof(HTTP_SERVICE_CONFIG_SSL_SET) + 
                        (ValueCount * ALIGN_UP(MaxValueLength, PVOID));


        if(pBuffer == NULL || BytesAvailable < BytesRequired)
        {   
            *pReturnLength = BytesRequired;
            Status =  ERROR_INSUFFICIENT_BUFFER;
            __leave;
        }


        ZeroMemory(pSslSet, sizeof(HTTP_SERVICE_CONFIG_SSL_SET));
        pBuffer      += sizeof(HTTP_SERVICE_CONFIG_SSL_SET);
        *pReturnLength = sizeof(HTTP_SERVICE_CONFIG_SSL_SET);


        //
        // Set up SOCKET_ADDRESS.
        //

        pSslSet->KeyDesc.pIpPort = (LPSOCKADDR)pBuffer;

        // Convert the IP address into SOCKADDR
        //
        
        // First, we try v4

        Status = WSAStringToAddress(
                    lpszIpAddrBuff,
                    AF_INET,
                    NULL,
                    pSslSet->KeyDesc.pIpPort,
                    (LPINT) &dwSockAddrLength
                    );

        if(Status != NO_ERROR)
        {
            dwSockAddrLength = sizeof(SOCKADDR_STORAGE);

            Status = WSAStringToAddress(
                        lpszIpAddrBuff,
                        AF_INET6,
                        NULL,
                        pSslSet->KeyDesc.pIpPort,
                        (LPINT)&dwSockAddrLength
                        );

            if(Status != NO_ERROR)
            {
                Status = GetLastError();
                __leave;
            }
        }

        pBuffer        += sizeof(SOCKADDR_STORAGE);
        *pReturnLength += sizeof(SOCKADDR_STORAGE);

        //
        // Query SSL HASH.
        //

        BytesAvailable              = MaxValueLength;

        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_CERT_HASH, 
                        pBuffer,
                        BytesAvailable
                        );

        ADVANCE_BUFFER(Status,
                       pSslSet->ParamDesc.pSslHash,
                       pSslSet->ParamDesc.SslHashLength,
                       pBuffer, 
                       BytesAvailable,
                       pReturnLength
                       );

        // 
        // Query pSslCertStoreName
        //

        BytesAvailable = MaxValueLength;

        REG_QUERY_VALUE(Status,
                        SubKeyHandle,
                        SSL_CERT_STORE_NAME, 
                        pBuffer,
                        BytesAvailable
                        );

        ADVANCE_BUFFER(Status,
                       pSslSet->ParamDesc.pSslCertStoreName,
                       BytesAvailable,
                       pBuffer, 
                       BytesAvailable,
                       pReturnLength
                       );


        // 
        // Query pDefaultSslCtlIdentifier
        //

        BytesAvailable = MaxValueLength;

        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_CTL_IDENTIFIER, 
                        pBuffer,
                        BytesAvailable
                        );

        ADVANCE_BUFFER(Status,
                       pSslSet->ParamDesc.pDefaultSslCtlIdentifier,
                       BytesAvailable,
                       pBuffer, 
                       BytesAvailable,
                       pReturnLength
                       );
        // 
        // Query pDefaultSslCtlStoreName
        //

        BytesAvailable = MaxValueLength;
        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_CTL_STORENAME, 
                        pBuffer,
                        BytesAvailable
                        );

        ADVANCE_BUFFER(Status,
                       pSslSet->ParamDesc.pDefaultSslCtlStoreName,
                       BytesAvailable,
                       pBuffer, 
                       BytesAvailable,
                       pReturnLength
                       );

        //
        // NOTE: when querying DWORDs, we don't have to call ADVANCE_BUFFER
        // as we use the space provided in the structure itself.
        //

        // 
        // Query DefaultCertCheckMode
        //

        BytesAvailable = sizeof(pSslSet->ParamDesc.DefaultCertCheckMode);

        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_CERT_CHECK_MODE, 
                        &pSslSet->ParamDesc.DefaultCertCheckMode,
                        BytesAvailable
                        );

        // 
        // Query RevocationFreshnessTime
        //

        BytesAvailable = 
            sizeof(pSslSet->ParamDesc.DefaultRevocationFreshnessTime);
        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_REVOCATION_FRESHNESS_TIME, 
                        &pSslSet->ParamDesc.DefaultRevocationFreshnessTime,
                        BytesAvailable
                        );

        // 
        // Query RevocationUrlRetrievalTimeout
        //

        BytesAvailable =
            sizeof(pSslSet->ParamDesc.DefaultRevocationUrlRetrievalTimeout);
        REG_QUERY_VALUE(
                    Status,
                    SubKeyHandle, 
                    SSL_REVOCATION_URL_RETRIEVAL_TIMEOUT, 
                    &pSslSet->ParamDesc.DefaultRevocationUrlRetrievalTimeout,
                    BytesAvailable
                    );

        // 
        // Query DefaultFlags
        //

        BytesAvailable = sizeof(pSslSet->ParamDesc.DefaultFlags);
        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_FLAGS, 
                        &pSslSet->ParamDesc.DefaultFlags,
                        BytesAvailable
                        );


        //
        // Query the AppId. 
        //

        BytesAvailable = sizeof(GUID);
        REG_QUERY_VALUE(Status,
                        SubKeyHandle, 
                        SSL_APPID, 
                        &pSslSet->ParamDesc.AppId,
                        BytesAvailable
                        );

        //
        // If the last REG_QUERY_VALUE returned an error, we'll consume it.
        // Some of these registry parameters are optional so we don't want to 
        // fail the API with FILE_NOT_FOUND.
        //
   
        Status = NO_ERROR; 
    }
    __finally
    {
        if(SubKeyHandle)
        {
            RegCloseKey(SubKeyHandle);
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Internal function that queries SSL configuration.

Arguments:
    pInput        - pointer to HTTP_SERVICE_CONFIG_SSL_QUERY
    InputLength   - length of input buffer.
    pOutput       - pointer to output buffer
    OutputLength  - sizeof output buffer
    pReturnLength - Bytes written/needed.

Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
QuerySslServiceConfiguration(
    IN  PVOID  pInputConfigInfo,
    IN  ULONG  InputLength,
    IN  PVOID  pOutput,
    IN  ULONG  OutputLength,
    OUT PULONG pReturnLength
    )
{
    ULONG                          Status = NO_ERROR;
    PHTTP_SERVICE_CONFIG_SSL_QUERY pSslQuery;
    WCHAR                          IpAddrBuff[MAX_PATH];
    DWORD                          dwSize, dwIndex;
    FILETIME                       FileTime;
    DWORD                          dwIpAddrLength;
    DWORD                          dwSockAddrLength;

    pSslQuery = (PHTTP_SERVICE_CONFIG_SSL_QUERY) pInputConfigInfo;

    //
    // Validate input parameters.
    //

    if(pSslQuery == NULL || 
       InputLength != sizeof(HTTP_SERVICE_CONFIG_SSL_QUERY))
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try
    {
        if((Status = 
            AcquireHttpRegistryMutex(SSL_REGISTRY_KEY_SYNCHRONIZE)) != NO_ERROR)
        {   
            __leave;
        }

        switch(pSslQuery->QueryDesc)
        {
            case HttpServiceConfigQueryExact:
            {
                //
                // Convert the address into a string.
                //
             
                dwIpAddrLength = MAX_PATH; 

                dwSockAddrLength = ComputeSockAddrLength(
                                        pSslQuery->KeyDesc.pIpPort
                                        );

                if(dwSockAddrLength == 0)
                {
                    Status = ERROR_NOT_SUPPORTED;
                    __leave;
                }

                Status = WSAAddressToString(
                                pSslQuery->KeyDesc.pIpPort, 
                                dwSockAddrLength,
                                NULL,
                                IpAddrBuff,
                                &dwIpAddrLength
                                );
        
                if(Status != NO_ERROR)
                {
                    break;
                }

                Status = QuerySslServiceConfigurationExact(
                                IpAddrBuff,
                                pOutput,
                                pReturnLength,
                                OutputLength
                                );

                break;
            }

            case HttpServiceConfigQueryNext:
            {
                dwIndex = pSslQuery->dwToken;
                dwSize  = MAX_PATH;

                Status = RegEnumKeyEx(
                                g_SslRegistryHandle,
                                dwIndex,
                                IpAddrBuff,
                                &dwSize,
                                NULL,
                                NULL,
                                NULL,
                                &FileTime
                                );

                if(Status != NO_ERROR)
                {
                    break;
                }

                Status = QuerySslServiceConfigurationExact(
                                IpAddrBuff,
                                pOutput,
                                pReturnLength,
                                OutputLength
                                );

                if(Status != NO_ERROR)
                {
                    break;
                }

                break;
            }

            default:
            {
                Status = ERROR_INVALID_PARAMETER;
                break;
            }
        }

    }
    __finally
    {
        // Free the mutex.
        //
        ReleaseHttpRegistryMutex(SSL_REGISTRY_KEY_SYNCHRONIZE);
    }

    return Status;
}


//
// IP Listen-Only List
//

/***************************************************************************++

Routine Description:

    Internal function that adds an address to the IP Listen-Only list.

Arguments:
    pConfigInformation      - pointer to HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM
    ConfigInformationLength - length of input buffer.


Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
SetIpListenServiceConfiguration(
    IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength
    )
{
    DWORD Status           = NO_ERROR;
    HKEY  SubKeyHandle     = NULL;
    WCHAR IpAddrBuff[MAX_PATH+1];
    DWORD dwIpAddrLength;
    DWORD dwValueSize;
    DWORD dwType;
    PWSTR pNewValue        = NULL;
    DWORD dwNewValueSize;
    DWORD AddrCount;
    DWORD i;
    PWSTR pTmp;
    PWSTR pTempBuffer       = NULL;
    PWSTR  *AddrArray       = NULL;
    PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM pIpListenParam;

    //
    // Validate params.
    //
    
    if ( !pConfigInformation ||
        ConfigInformationLength != sizeof(HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM) )
    {
        return ERROR_INVALID_PARAMETER;        
    }

    pIpListenParam = (PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM) pConfigInformation;

    if ( !pIpListenParam->AddrLength ||
         !pIpListenParam->pAddress )
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try
    {
        if((Status =
            AcquireHttpRegistryMutex(IP_REGISTRY_KEY_SYNCHRONIZE)) != NO_ERROR)
        {
            __leave;
        }


        //
        // Convert the address into a string.
        //
                 
        dwIpAddrLength = MAX_PATH; 
    
        Status = WSAAddressToString(
                    pIpListenParam->pAddress,
                    pIpListenParam->AddrLength,
                    NULL,
                    IpAddrBuff,
                    &dwIpAddrLength     // in chars, including NULL.
                    );
            
        if ( SOCKET_ERROR == Status )
        {
            Status = WSAGetLastError();
            __leave;
        }
    
        // finesse: add double null now
        IpAddrBuff[dwIpAddrLength] = L'\0';
    
        //
        // open HTTP parameters reg key
        //
        
        Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    HTTP_PARAM_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &SubKeyHandle
                    );
    
        if ( Status != ERROR_SUCCESS )
        {
            // CODEWORK: add tracing.
            __leave;
        }
    
        ASSERT(SubKeyHandle);
    
        //
        // query existing value
        //
    
        dwValueSize = 0;
        Status = RegQueryValueEx(
                    SubKeyHandle,           // handle to key
                    IP_LISTEN_ONLY_VALUE,   // value name
                    NULL,                   // reserved
                    &dwType,                // type buffer
                    NULL,                   // data buffer
                    &dwValueSize            // size of data buffer (bytes)
                    );
    
        if ( ERROR_SUCCESS == Status )  
        {
            // There's an existing value!
    
            if (REG_MULTI_SZ != dwType)
            {
                // type mismatch.  fail.
                Status = ERROR_DATATYPE_MISMATCH;
                __leave;
            }
    
            // alloc local buffer to hold existing value plus new
            // address (and its NULL)
    
            dwNewValueSize = dwValueSize + (sizeof(WCHAR) * dwIpAddrLength);
            pNewValue = ALLOC_MEM(dwNewValueSize);
    
            if (!pNewValue)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY; 
                __leave;
            }
    
            // zero-out the block (so we don't have to worry about the 
            // double-null at the end)
            ZeroMemory(pNewValue, dwNewValueSize);
            
            // read existing value into local buffer
            Status = RegQueryValueEx(
                        SubKeyHandle,           // handle to key
                        IP_LISTEN_ONLY_VALUE,   // value name
                        NULL,                   // reserved
                        &dwType,                // type buffer
                        (LPBYTE)pNewValue,      // data buffer
                        &dwValueSize            // size of data buffer (bytes)
                        );
    
            if ( ERROR_SUCCESS != Status )
            {
                __leave;
            }
    
            if (REG_MULTI_SZ != dwType)
            {
                // type mismatch.  fail.
                Status = ERROR_DATATYPE_MISMATCH;
                __leave;
            }
    
    
            // count how many strings there are
    
            pTmp = pNewValue;
            AddrCount = 0;
            
            while ( *pTmp )
            {
                // check if the new addr is a dup
                if ( (wcslen(pTmp) == (dwIpAddrLength - 1)) &&
                    (0 == wcsncmp(pTmp, IpAddrBuff, dwIpAddrLength-1)) )
                {
                    // Dup found; bail out
                    Status = ERROR_ALREADY_EXISTS;
                    __leave;
                }
    
                // advance to next multi-sz string
                pTmp += ( wcslen(pTmp) + 1 );
    
                AddrCount ++;
            }
    
            // Add new address to end of the list
            // finesse: leverage the fact that the buffer is big enough, and
            // we've already double-nulled the end of the new address (hence
            // the dwIpAddrLength+1)
            memcpy( pTmp, IpAddrBuff, (sizeof(WCHAR) * (dwIpAddrLength+1)) );
            AddrCount++;
    
            // alloc array of pointers for quicksort
            AddrArray = ALLOC_MEM( AddrCount * sizeof(PWSTR) );
    
            if ( !AddrArray )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
    
            // Init array of addresses
            pTmp = pNewValue;
            i = 0;
            while( *pTmp )
            {
                AddrArray[i] = pTmp;
                pTmp += ( wcslen(pTmp) + 1 );
                i++;
            }
            
            // Sort Array of PWSTR pointers
            // NOTE: this does not sort the array!
            qsort(
                AddrArray,
                AddrCount,
                sizeof(PWSTR),
                wcscmp
                );
    
            // Alloc a temp buffer (because an in-place rearrangement is painful)
    
            pTempBuffer = ALLOC_MEM(dwNewValueSize);
                             
            if (!pTempBuffer)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY; 
                __leave;
            }
    
            pTmp = pTempBuffer;
            for ( i = 0; i < AddrCount; i++ )
            {
                // CODEWORK: add an heuristic for checking for duplicates.
                wcscpy( pTmp, AddrArray[i] );
                pTmp += wcslen(AddrArray[i]) + 1;
            }
    
            // add double-null
            ASSERT( (DWORD)(pTmp - pTempBuffer) < dwNewValueSize );
            *pTmp = L'\0';
    
            // set sorted value
            REG_SET_VALUE(Status,
                          SubKeyHandle,
                          IP_LISTEN_ONLY_VALUE,
                          REG_MULTI_SZ,
                          pTempBuffer,
                          dwNewValueSize
                          );
    
            FREE_MEM( pTempBuffer );
        }
        else
        {
            // No value exists!
            // calc the buffer size in bytes (including the double-null)
    
            dwValueSize = sizeof(WCHAR) * (dwIpAddrLength + 1);
    
            // set value
            // finesse: the value has already been double-null'd above.
            
            REG_SET_VALUE(Status,
                          SubKeyHandle,
                          IP_LISTEN_ONLY_VALUE,
                          REG_MULTI_SZ,
                          IpAddrBuff,
                          dwValueSize
                          );
        }
    }
    __finally
    {
        //
        // close reg key
        //

        if ( SubKeyHandle )
        {
            RegCloseKey(SubKeyHandle);
        }

        //
        // release alloc'd values
        //
    
        if ( pNewValue )
        {
            FREE_MEM( pNewValue );
        }

        if ( AddrArray )
        {
            FREE_MEM( AddrArray );
        }

        ReleaseHttpRegistryMutex(IP_REGISTRY_KEY_SYNCHRONIZE);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Internal function that deletes an address from the IP Listen-Only list.

Arguments:
    pConfigInformation      - pointer to HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM
    ConfigInformationLength - length of input buffer.


Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
DeleteIpListenServiceConfiguration(
    IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength
    )
{
    DWORD Status           = NO_ERROR;
    HKEY  SubKeyHandle     = NULL;
    WCHAR IpAddrBuff[MAX_PATH];
    DWORD dwIpAddrLength;
    DWORD dwValueSize;
    DWORD dwRemainder;
    PWSTR pNewValue        = NULL;
    DWORD dwType;
    PWSTR pTmp;
    PWSTR pNext;
    PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM pIpListenParam;


    //
    // Validate params.
    //
    
    if ( !pConfigInformation ||
         ConfigInformationLength != sizeof(HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM) )
    {
        return ERROR_INVALID_PARAMETER;        
    }

    pIpListenParam = (PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM) pConfigInformation;

    if ( !pIpListenParam->AddrLength ||
         !pIpListenParam->pAddress )
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try
    {
        if((Status =
            AcquireHttpRegistryMutex(IP_REGISTRY_KEY_SYNCHRONIZE)) != NO_ERROR)
        {
            __leave;
        }

        //
        // Convert the address into a string.
        //
                 
        dwIpAddrLength = MAX_PATH; 
    
        Status = WSAAddressToString(
                    pIpListenParam->pAddress,
                    pIpListenParam->AddrLength,
                    NULL,
                    IpAddrBuff,
                    &dwIpAddrLength     // in chars, including NULL.
                    );
            
        if ( SOCKET_ERROR == Status )
        {
            Status = WSAGetLastError();
            __leave;
        }
    
        //
        // open HTTP parameters reg key
        //
        
        Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    HTTP_PARAM_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &SubKeyHandle
                    );
    
        if ( Status != ERROR_SUCCESS )
        {
            // CODEWORK: add tracing.
            __leave;
        }
    
        ASSERT(SubKeyHandle);
    
        //
        // query existing value
        //
    
        dwValueSize = 0;
        Status = RegQueryValueEx(
                    SubKeyHandle,           // handle to key
                    IP_LISTEN_ONLY_VALUE,   // value name
                    NULL,                   // reserved
                    &dwType,                // type buffer
                    NULL,                   // data buffer
                    &dwValueSize            // size of data buffer (bytes)
                    );
    
        if ( ERROR_SUCCESS == Status )  
        {
            // There's an existing value!
    
            if (REG_MULTI_SZ != dwType)
            {
                // type mismatch.  fail.
                Status = ERROR_DATATYPE_MISMATCH;
                __leave;
            }
    
    
            pNewValue = ALLOC_MEM(dwValueSize);
    
            if (!pNewValue)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY; 
                __leave;
            }
            
            // read existing value into local buffer
            Status = RegQueryValueEx(
                        SubKeyHandle,           // handle to key
                        IP_LISTEN_ONLY_VALUE,   // value name
                        NULL,                   // reserved
                        &dwType,                // type buffer
                        (LPBYTE)pNewValue,      // data buffer
                        &dwValueSize            // size of data buffer (bytes)
                        );
    
            if ( ERROR_SUCCESS != Status )
            {
                __leave;
            }
    
            if (REG_MULTI_SZ != dwType)
            {
                // type mismatch.  fail.
                Status = ERROR_DATATYPE_MISMATCH;
                __leave;
            }
    
            // walk value, looking for match as we go
            Status    = ERROR_NOT_FOUND;
            pTmp      = pNewValue;
            
            while ( *pTmp )
            {
                // check if the new addr is a dup
                if ( (wcslen(pTmp) == (dwIpAddrLength - 1)) &&
                    (0 == wcsncmp(pTmp, IpAddrBuff, dwIpAddrLength-1)) )
                {
                    // Found: move suffix of values up.
                    pNext = pTmp + dwIpAddrLength;
                    dwRemainder = dwValueSize - (DWORD)((PUCHAR)pNext - (PUCHAR)pNewValue);
                    dwValueSize -= (dwIpAddrLength * sizeof(WCHAR));
    
                    if (dwRemainder)
                    {
                        MoveMemory(pTmp,
                               pNext,
                               dwRemainder
                               );
                    }
                    else
                    {
                        // removing last element on list;
                        // must insert trailing double-null
                        *pTmp = L'\0';
                    }
    
                    if (dwValueSize > sizeof(WCHAR))
                    {
                        // write updated value to key
                        REG_SET_VALUE(Status,
                                      SubKeyHandle,
                                      IP_LISTEN_ONLY_VALUE,
                                      REG_MULTI_SZ,
                                      pNewValue,
                                      dwValueSize
                                      );
                    }
                    else
                    {
                        // no more IPs left on list; remove the value
                        Status = RegDeleteValue(
                                    SubKeyHandle,
                                    IP_LISTEN_ONLY_VALUE
                                    );
                    }

                    __leave;
            
                }
    
                // advance to next multi-sz string
                pTmp += ( wcslen(pTmp) + 1 );
            }
        }
        else
        {
            // No existing value, so therefore we can't delete.
            Status = ERROR_NOT_FOUND;
        }
    }
    __finally
    {
        ReleaseHttpRegistryMutex(IP_REGISTRY_KEY_SYNCHRONIZE);

        if ( pNewValue )
        {
            FREE_MEM( pNewValue );
        }
    
        if (SubKeyHandle)
        {
            RegCloseKey(SubKeyHandle);
        }
    }
    
    return Status;
}


/***************************************************************************++

Routine Description:

    Internal function that queries the IP Listen-Only configuration.
    This function grabs the entire list and returns it in one chunk.

Arguments:
    pOutput       - pointer to output buffer (point to caller provided
                    HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY structure)
                    [OPTIONAL]
    OutputLength  - sizeof output buffer.  Must be zero if pOutput is NULL.
    pReturnLength - Bytes written/needed.

Return Value:

    Win32 error code.
    ERROR_INSUFFICIENT_BUFFER - if OutputLength cannot hold entire list.  
                    pReturnLength will contain the required bytes.
    ERROR_NOT_ENOUGH_MEMORY - Can't alloc enough memory to complete operation.
    
--***************************************************************************/
ULONG
QueryIpListenServiceConfiguration(
    IN  PVOID  pOutput,
    IN  ULONG  OutputLength,
    OUT PULONG pReturnLength
    )
{
    DWORD Status           = NO_ERROR;
    HKEY  SubKeyHandle     = NULL;
    DWORD dwValueSize;
    DWORD dwSockAddrLength;
    DWORD AddrCount;
    DWORD BytesNeeded      = 0;
    PWSTR pValue           = NULL;
    PWSTR pTmp;
    PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY  pIpListenQuery;
    PSOCKADDR_STORAGE pHttpAddr;

    //
    // Validate parameters
    //

    if ( pOutput &&
         OutputLength < sizeof(HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pReturnLength )
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try
    {
        if((Status =
            AcquireHttpRegistryMutex(IP_REGISTRY_KEY_SYNCHRONIZE)) != NO_ERROR)
        {
            __leave;
        }


        //
        // open HTTP parameters reg key
        //
        
        Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    HTTP_PARAM_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &SubKeyHandle
                    );
    
        if ( Status != ERROR_SUCCESS )
        {
            // CODEWORK: add tracing.
            __leave;
        }
    
        ASSERT(SubKeyHandle);
    
        //
        // query existing value
        //
    
        dwValueSize = 0;
        Status = RegQueryValueEx(
                    SubKeyHandle,           // handle to key
                    IP_LISTEN_ONLY_VALUE,   // value name
                    NULL,                   // reserved
                    NULL,                   // type buffer
                    NULL,                   // data buffer
                    &dwValueSize            // size of data buffer (bytes)
                    );
    
        if ( ERROR_SUCCESS == Status )  
        {
            // There's an existing value!
    
            pValue = ALLOC_MEM(dwValueSize);
    
            if (!pValue)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY; 
                __leave;
            }
    
            // read existing value into local buffer
            Status = RegQueryValueEx(
                        SubKeyHandle,           // handle to key
                        IP_LISTEN_ONLY_VALUE,   // value name
                        NULL,                   // reserved
                        NULL,                   // type buffer
                        (LPBYTE)pValue,      // data buffer
                        &dwValueSize            // size of data buffer (bytes)
                        );
    
            if ( ERROR_SUCCESS != Status )
            {
                __leave;
            }
    
            // first pass: count the number of addresses & see if we
            // have enough buffer.  
            pTmp      = pValue;
            AddrCount = 0;
            while ( *pTmp )
            {
                AddrCount++;
                
                // advance to next multi-sz string
                pTmp += ( wcslen(pTmp) + 1 );
            }
    
            if ( 0 == AddrCount )
            {
                // invalid.  bail out.
                Status = ERROR_REGISTRY_CORRUPT;
                __leave;
            }
    
            // calculate bytes needed
            BytesNeeded = sizeof(HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY) + 
                          (sizeof(SOCKADDR_STORAGE) * (AddrCount - 1));
    
    
            // see if we have enough buffer to write out the whole mess
            if ( (NULL == pOutput) || 
                 (OutputLength < BytesNeeded) )
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
                __leave;
            }
    
            // second pass: walk value, converting into buffer as we go
            pIpListenQuery = (PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY) pOutput;
            pHttpAddr      = (PSOCKADDR_STORAGE) &(pIpListenQuery->AddrList[0]);
            pIpListenQuery->AddrCount = AddrCount;
    
            pTmp           = pValue;
            while ( *pTmp )
            {
                //
                // Convert the IP addresses into SOCKADDRs
                //
            
                // First, we try v4
                dwSockAddrLength = sizeof(SOCKADDR_STORAGE);
                Status = WSAStringToAddress(
                            pTmp,
                            AF_INET,
                            NULL,
                            (LPSOCKADDR)pHttpAddr,
                            (LPINT)&dwSockAddrLength
                            );
    
                if ( Status != NO_ERROR )
                {
                    // Second, we try v6
                    dwSockAddrLength = sizeof(SOCKADDR_STORAGE);
                    Status = WSAStringToAddress(
                                pTmp,
                                AF_INET6,
                                NULL,
                                (LPSOCKADDR)pHttpAddr,
                                (LPINT)&dwSockAddrLength
                                );
    
                    if ( Status != NO_ERROR )
                    {
                        // if that fails, bail out; corrupt value.
                        Status = ERROR_REGISTRY_CORRUPT;
                        __leave;
                    }
                }
    
                // advance to next multi-sz string
                pTmp += ( wcslen(pTmp) + 1 );
                pHttpAddr++;
            }
    
        }
        else
        {
            // No existing value, so therefore we can't query.
            Status = ERROR_NOT_FOUND;
        }
    }
    __finally
    {
        
        // free memory
        if (pValue)
        {
            FREE_MEM(pValue);
        }
    
        // close reg key
        
        if (SubKeyHandle)
        {
            RegCloseKey(SubKeyHandle);
        }

        ReleaseHttpRegistryMutex(IP_REGISTRY_KEY_SYNCHRONIZE);

        // tell caller how many bytes are need
        *pReturnLength = BytesNeeded;
    }

    return Status;
}

//
// URL ACL functions.
//

/***************************************************************************++

Routine Description:

    Internal function that adds an URL ACL entry

Arguments:
    pConfigInformation      - pointer to HTTP_SERVICE_CONFIG_URL_ACL
    ConfigInformationLength - length of input buffer.

Return Value:

    Win32 error code.

--***************************************************************************/
ULONG
SetUrlAclInfo(
    IN PVOID   pConfigInformation,
    IN ULONG   ConfigInformationLength
    )
{
    DWORD                           Status;
    PHTTP_SERVICE_CONFIG_URLACL_SET pUrlAcl;
    PSECURITY_DESCRIPTOR            pSecurityDescriptor;
    ULONG                           SecurityDescriptorLength;

    //
    // Validate arguments.
    //

    if (pConfigInformation == NULL ||
        ConfigInformationLength != sizeof(HTTP_SERVICE_CONFIG_URLACL_SET))
    {
        return ERROR_INVALID_PARAMETER;
    }

    pUrlAcl = (PHTTP_SERVICE_CONFIG_URLACL_SET) pConfigInformation;

    if(FALSE == ConvertStringSecurityDescriptorToSecurityDescriptor(
                    pUrlAcl->ParamDesc.pStringSecurityDescriptor,
                    SDDL_REVISION_1,
                    &pSecurityDescriptor,
                    &SecurityDescriptorLength
                    ))
    {
        return GetLastError();
    }

    //
    // Now, make the IOCTL call
    //

    Status = AddUrlToConfigGroup(
                HttpUrlOperatorTypeReservation,
                g_ServiceControlChannelHandle,
                HTTP_NULL_ID,
                pUrlAcl->KeyDesc.pUrlPrefix,
                HTTP_NULL_ID,
                pSecurityDescriptor,
                SecurityDescriptorLength
                );

    LocalFree(pSecurityDescriptor);

    return Status;
}

/***************************************************************************++

Routine Description:

    Internal function that queries URL ACL configuration 

Arguments:
    pInputConfigInfo    - pointer to HTTP_SERVICE_CONFIG_URLACL_QUERY
    InputLength         - length of input buffer.
    pBuffer            - Output Buffer
    pReturnLength      - Bytes written/needed.
    BytesAvailable     - sizeof output buffer
Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
QueryUrlAclInfo(
    IN  PVOID  pInputConfigInfo,
    IN  ULONG  InputLength,
    IN  PVOID  pOutput,
    IN  ULONG  OutputLength,
    OUT PULONG pReturnLength
    )
{
    ULONG                                Status;
    PHTTP_SERVICE_CONFIG_URLACL_QUERY    pUrlAclQuery;
    PHTTP_SERVICE_CONFIG_URLACL_SET      pUrlAclSet;
    DWORD                                dwIndex;
    PVOID                                pData; 
    PUCHAR                               pBuffer;
    DWORD                                Type;
    DWORD                                DataSize;
    DWORD                                NameSize;
    PWSTR                                pFullyQualifiedUrl = NULL;
    PSECURITY_DESCRIPTOR                 pSecurityDescriptor;
    PWSTR                                pStringSecurityDescriptor;
    BOOLEAN                              bAllocatedUrl = FALSE;

    pData = NULL;
    pStringSecurityDescriptor = NULL;
    Status = NO_ERROR;

    pUrlAclQuery = (PHTTP_SERVICE_CONFIG_URLACL_QUERY) pInputConfigInfo;

    //
    // Validate input parameters.
    //

    if(pUrlAclQuery == NULL || 
       InputLength != sizeof(HTTP_SERVICE_CONFIG_URLACL_QUERY))
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch(pUrlAclQuery->QueryDesc)
    {
        case HttpServiceConfigQueryNext:
        {
            dwIndex  = pUrlAclQuery->dwToken;
            DataSize = 0;

            //
            // RegEnumValue wants ValueName to be MAXUSHORT characters. 
            //
            NameSize = (MAXUSHORT + 1) * sizeof(WCHAR);
            pFullyQualifiedUrl = LocalAlloc(LMEM_FIXED, NameSize);

            if(!pFullyQualifiedUrl)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                RtlZeroMemory(pFullyQualifiedUrl, NameSize);
                bAllocatedUrl = TRUE;
            }

            // 
            // Set NameSize to WCHARs & exclude the NULL.
            //
            NameSize = MAXUSHORT;

            //
            // Get the Size.
            //
            Status = RegEnumValue(
                          g_UrlAclRegistryHandle,
                          dwIndex,
                          pFullyQualifiedUrl,
                          &NameSize,
                          NULL,       // Reserved
                          &Type,      // Type
                          NULL,       // Data
                          &DataSize   // DataSize
                          );

            // On return, NameSize contains size in WCHARs
            // excluding NULL. Account for the NULL. The buffer is already
            // zero'd out.
            //
            // At this time, NameSize is in WCHARs, including NULL
            //
            NameSize ++;
        }
        break;

        case HttpServiceConfigQueryExact:
        {
            pFullyQualifiedUrl = pUrlAclQuery->KeyDesc.pUrlPrefix,

            // 
            // NameSize must be in WCHARs including NULL.
            //
            NameSize = (DWORD)((wcslen(pFullyQualifiedUrl) + 1));

            Status = RegQueryValueEx(
                        g_UrlAclRegistryHandle,
                        pFullyQualifiedUrl,
                        0,
                        &Type,
                        NULL, // Buffer
                        &DataSize
                        );
        }
        break;

        default:
            Status = ERROR_INVALID_PARAMETER;
            goto Cleanup;

    } // switch

    if(Status != NO_ERROR)
    {
        goto Cleanup;
    }

    if(Type != REG_BINARY || DataSize == 0)
    {
        Status = ERROR_REGISTRY_CORRUPT;
        goto Cleanup;
    }

    //
    // Allocate space for data
    //
    pData = LocalAlloc(LMEM_FIXED, DataSize);

    if(!pData)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    
    Status = RegQueryValueEx(
                g_UrlAclRegistryHandle,
                pFullyQualifiedUrl,
                0,
                &Type,
                pData, // Buffer
                &DataSize
                );

    if(Status != NO_ERROR)
    {
        goto Cleanup;
    }

    if(Type != REG_BINARY)
    {
        Status = ERROR_REGISTRY_CORRUPT;
        goto Cleanup;
    }

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR) pData;

    //
    // If we are here, we have to convert the binary to a SDDL.
    //
    if(FALSE == ConvertSecurityDescriptorToStringSecurityDescriptor(
                    pSecurityDescriptor,
                    SDDL_REVISION_1,
                    OWNER_SECURITY_INFORMATION | 
                    GROUP_SECURITY_INFORMATION | 
                    DACL_SECURITY_INFORMATION  | 
                    SACL_SECURITY_INFORMATION,
                    &pStringSecurityDescriptor,
                    &DataSize
                    ))
    {
        Status = GetLastError();
        goto Cleanup;
    }

    //
    // Convert WCHAR to length.
    //
    DataSize *= sizeof(WCHAR);
    NameSize *= sizeof(WCHAR);

    *pReturnLength = DataSize + 
                     NameSize + 
                     sizeof(HTTP_SERVICE_CONFIG_URLACL_SET);

    if(OutputLength >= *pReturnLength)
    {
        pBuffer = pOutput;
        pUrlAclSet = (PHTTP_SERVICE_CONFIG_URLACL_SET) pBuffer;
        pBuffer += sizeof(HTTP_SERVICE_CONFIG_URLACL_SET);

        RtlZeroMemory(pUrlAclSet, sizeof(HTTP_SERVICE_CONFIG_URLACL_SET));

        pUrlAclSet->KeyDesc.pUrlPrefix = (PWSTR) pBuffer;
        pBuffer += NameSize;

        // Includes NULL.
        RtlCopyMemory(
                pUrlAclSet->KeyDesc.pUrlPrefix,
                pFullyQualifiedUrl,
                NameSize
                );

        pUrlAclSet->ParamDesc.pStringSecurityDescriptor = (PWSTR)pBuffer;

        RtlCopyMemory(
                pUrlAclSet->ParamDesc.pStringSecurityDescriptor,
                pStringSecurityDescriptor,
                DataSize
                );

        Status = NO_ERROR;
    }
    else
    {
        Status = ERROR_INSUFFICIENT_BUFFER;
    }

Cleanup:

    if(bAllocatedUrl)
    {
        LocalFree(pFullyQualifiedUrl);
    }

    if(pStringSecurityDescriptor)
    {
        LocalFree(pStringSecurityDescriptor);
    }

    if(pData)
    {
        LocalFree(pData);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

        Internal function that deletes an URL ACL entry

    Arguments:
        pConfigInformation      - pointer to HTTP_SERVICE_CONFIG_URL_ACL
        ConfigInformationLength - length of input buffer.

    Return Value:

    Win32 error code.
--***************************************************************************/
ULONG
DeleteUrlAclInfo(
    IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength
    )
{
    DWORD                            Status;
    PHTTP_SERVICE_CONFIG_URLACL_SET  pUrlAcl;

    //
    // Validate arguments.
    //

    if (pConfigInformation == NULL ||
        ConfigInformationLength != sizeof(HTTP_SERVICE_CONFIG_URLACL_SET))
    {
        return ERROR_INVALID_PARAMETER;
    }

    pUrlAcl = (PHTTP_SERVICE_CONFIG_URLACL_SET) pConfigInformation;

    //
    // Now, make the IOCTL call
    //

    Status = RemoveUrlFromConfigGroup(
                HttpUrlOperatorTypeReservation,
                g_ServiceControlChannelHandle,
                HTTP_NULL_ID,
                pUrlAcl->KeyDesc.pUrlPrefix
                );

    return Status;
}

//
// Public Functions.
//

/***************************************************************************++

Routine Description:

    Sets a service configuration parameter.

Arguments:

    ConfigId                - ID of the parameter that we are setting.
    pConfigInformation      - pointer to the object that is being set.
    ConfigInformationLength - Length of the object.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetServiceConfiguration(
    IN HANDLE                  pHandle,
    IN HTTP_SERVICE_CONFIG_ID  ConfigId,
    IN PVOID                   pConfigInformation,
    IN ULONG                   ConfigInformationLength,
    IN LPOVERLAPPED            pOverlapped
    )
{
    ULONG                        Status = NO_ERROR;

    if(pOverlapped != NULL  || pHandle != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch(ConfigId)
    {
        case HttpServiceConfigSSLCertInfo:
        {
            Status = SetSslServiceConfiguration(pConfigInformation,
                                                ConfigInformationLength 
                                                );
                
            break;
        }

        case HttpServiceConfigIPListenList:
        {
            Status = SetIpListenServiceConfiguration(
                        pConfigInformation,
                        ConfigInformationLength
                        );
            break;
        }

        case HttpServiceConfigUrlAclInfo:
        {
            Status = SetUrlAclInfo(
                        pConfigInformation,
                        ConfigInformationLength
                        );
            break;
        }

        default:
            Status = ERROR_INVALID_PARAMETER;
            break;
    }

    return Status;        
}

/***************************************************************************++

Routine Description:

    Deletes a service configuration parameter.

Arguments:

    ConfigId                - ID of the parameter that we are setting.
    pConfigInformation      - pointer to the object that is being set.
    ConfigInformationLength - Length of the object.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpDeleteServiceConfiguration(
    IN HANDLE                  pHandle,
    IN HTTP_SERVICE_CONFIG_ID  ConfigId,
    IN PVOID                   pConfigInformation,
    IN ULONG                   ConfigInformationLength,
    IN LPOVERLAPPED            pOverlapped
    )
{
    ULONG   Status = NO_ERROR;

    if(pOverlapped != NULL  || pHandle != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch(ConfigId)
    {
        case HttpServiceConfigSSLCertInfo:
            Status = DeleteSslServiceConfiguration(pConfigInformation,
                                                   ConfigInformationLength 
                                                   );
            break;

        case HttpServiceConfigIPListenList:
        {
            Status = DeleteIpListenServiceConfiguration(
                        pConfigInformation,
                        ConfigInformationLength
                        );
            break;
        }

        case HttpServiceConfigUrlAclInfo:
        {
            Status = DeleteUrlAclInfo(
                        pConfigInformation,
                        ConfigInformationLength
                        );
            break;
        }

        default:
            Status = ERROR_INVALID_PARAMETER;
            break;
    }

    return Status;        
}

/***************************************************************************++

Routine Description:

    Queries a service configuration parameter.

Arguments:

    ConfigId                - ID of the parameter that we are setting.
    pConfigInformation      - pointer to the object that is being set.
    ConfigInformationLength - Length of the object.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryServiceConfiguration(
    IN  HANDLE                   pHandle,
    IN  HTTP_SERVICE_CONFIG_ID   ConfigId,
    IN  PVOID                    pInput,
    IN  ULONG                    InputLength,
    IN  OUT PVOID                pOutput,          
    IN  ULONG                    OutputLength,                 
    OUT PULONG                   pReturnLength,
    IN  LPOVERLAPPED             pOverlapped
    )
{
    ULONG  Status = NO_ERROR;


    if(pOverlapped != NULL  || pHandle != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch(ConfigId)
    {
        case HttpServiceConfigSSLCertInfo:
        {
            Status = QuerySslServiceConfiguration(
                            pInput,
                            InputLength,
                            pOutput,
                            OutputLength,
                            pReturnLength
                            );

            break;

        }

        case HttpServiceConfigIPListenList:
        {
            Status = QueryIpListenServiceConfiguration(
                            pOutput,
                            OutputLength,
                            pReturnLength
                            );
            break;
        }

        case HttpServiceConfigUrlAclInfo:
        {
            Status = QueryUrlAclInfo(
                        pInput,
                        InputLength,
                        pOutput,
                        OutputLength,
                        pReturnLength
                        );
            break;
        }

        default:
            Status = ERROR_INVALID_PARAMETER;
            break;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\precomp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Precomp.h

Abstract:

    Master include file for HTTPAPI.LIB user-mode interface to HTTP.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// We are willing to ignore the following warnings, as we need the DDK to 
// compile.
//

#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4306)   // conversion from 'type1' to 'type2' of 
                                // greater size

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tdi.h>

#include <rtutils.h>

#define HTTPAPI_LINKAGE
#include <http.h>
#include <httpp.h>
#include <httpioctl.h>
#include "httpapip.h"


#include <PoolTag.h>

#define HTTPAPI 1
#include <HttpCmn.h>

//
// Private macros.
//

#define ALLOC_MEM(cb) RtlAllocateHeap( RtlProcessHeap(), 0, (cb) )
#define FREE_MEM(ptr) RtlFreeHeap( RtlProcessHeap(), 0, (ptr) )

#define ALIGN_DOWN(length, type)                                \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type)                                  \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define OVERLAPPED_TO_IO_STATUS( pOverlapped )                  \
    ((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)

#define SET_STATUS_OVERLAPPED_TO_IO_STATUS( pOverlapped, ntstatus ) \
    do { \
        (((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)->Status = (ntstatus)); \
    } while (0, 0)



//
// Private types.
//

typedef enum _HTTPAPI_HANDLE_TYPE
{
    HttpApiControlChannelHandleType,
    HttpApiFilterChannelHandleType,
    HttpApiAppPoolHandleType,
    HttpApiServerHandleType,

    HttpApiMaxHandleType

} HTTPAPI_HANDLE_TYPE;

//
// Private prototypes.
//

BOOL
WINAPI
DllMain(
    IN HMODULE DllHandle,
    IN DWORD Reason,
    IN LPVOID pContext OPTIONAL
    );

#define HttpApiNtStatusToWin32Status( Status )  \
    ( ( (Status) == STATUS_SUCCESS )            \
          ? NO_ERROR                            \
          : RtlNtStatusToDosError( Status ) )

NTSTATUS
HttpApiOpenDriverHelper(
    OUT PHANDLE              pHandle,
    IN  PWCHAR               Uri,
    IN  USHORT               UriLength,
    IN  PWCHAR               Proxy,
    IN  USHORT               ProxyLength,
    IN  PTRANSPORT_ADDRESS   pTransportAddress,
    IN  USHORT               TransportAddressLength,
    IN  ACCESS_MASK          DesiredAccess,
    IN  HTTPAPI_HANDLE_TYPE  HandleType,
    IN  PCWSTR               pObjectName         OPTIONAL,
    IN  ULONG                Options,
    IN  ULONG                CreateDisposition,
    IN  PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL
    );

ULONG
HttpApiSynchronousDeviceControl(
    IN HANDLE FileHandle,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    );

ULONG
HttpApiOverlappedDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    );

BOOLEAN
HttpApiTryToStartDriver(
    PWSTR pServiceName
    );

__inline
ULONG
HttpApiDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    if (pOverlapped == NULL)
    {
        return HttpApiSynchronousDeviceControl(
                    FileHandle,
                    IoControlCode,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pBytesTransferred
                    );
    }
    else
    {
        return HttpApiOverlappedDeviceControl(
                    FileHandle,
                    pOverlapped,
                    IoControlCode,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pBytesTransferred
                    );
    }
}


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\url.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Url.c

Abstract:

    User-mode interface to HTTP.SYS: URL handler for Server APIs.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

    Eric Stenson (ericsten)      01-Jun-2001
        Add public "shims" for Transient API

    Eric Stenson (ericsten)      19-Jul-2001
        Split up HTTPAPI/HTTPIIS DLLs.

--*/


#include "precomp.h"


//
// Private prototypes.
//

extern NTSTATUS
HttpApiConfigGroupInformationSanityCheck(
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    );

static CRITICAL_SECTION     g_CGListCritSec;
static LIST_ENTRY           g_ConfigGroupListHead;
static DWORD                g_ConfigGroupInitialized = 0;


typedef struct _tagCONFIG_GROUP_INFO {
    LIST_ENTRY              ListEntry;
    HTTP_CONFIG_GROUP_ID    ConfigGroupId;
    LPWSTR                  Url;
} CONFIG_GROUP_INFO, *PCONFIG_GROUP_INFO;


ULONG
AddConfigGroupToTable(
    HTTP_CONFIG_GROUP_ID CGId,
    LPCWSTR wszUrl
    );

VOID
DeleteConfigIdFromTable(
    HTTP_CONFIG_GROUP_ID CGId
    );


HTTP_CONFIG_GROUP_ID
DeleteUrlFromTable(
    LPCWSTR wszUrl
    );

//
// Public functions.
//


/***************************************************************************++

Routine Description:

    Add a URL to the Request Queue (App Pool).  The Request Queue will
    listen for all requests for longest matching URI for the URL.  We
    create a new Config Group object for this URL and associate the
    Config Group to the App Pool.

Arguments:

    ReqQueueHandle - App Pool Handle

    pFullyQualifiedUrl - full URL with port descriptor & path

    pReserved - Must be NULL


Return Value:

    ULONG - Completion status.

--***************************************************************************/
HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddUrl(
    IN HANDLE                ReqQueueHandle,
    IN PCWSTR                pFullyQualifiedUrl,
    IN PVOID                 pReserved
    )
{
    ULONG status;
    HTTP_CONFIG_GROUP_ID configId = HTTP_NULL_ID;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;


    //
    // Verify we've been init'd.
    //

    if ( !HttpIsInitialized(HTTP_INITIALIZE_SERVER) )
    {
        return ERROR_DLL_INIT_FAILED; 
    }

    //
    // Validate ReqQueue and URL
    //
    if ( (NULL != pReserved) ||
         (NULL == ReqQueueHandle) ||
         (NULL == pFullyQualifiedUrl) ||
         (0 == wcslen(pFullyQualifiedUrl)) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Create Config Group (get new Config Group ID)
    //
    status = HttpCreateConfigGroup(
                    g_ControlChannel,
                    &configId
                    );

    if (status != NO_ERROR)
    {
        HttpTrace1( "HttpCreateConfigGroup failed, error %lu\n", status );
        goto cleanup;
    }

    //
    // Add a URL to the configuration group.
    //
    status = HttpAddUrlToConfigGroup(
                    g_ControlChannel,
                    configId,
                    pFullyQualifiedUrl,
                    0
                    );

    if (status != NO_ERROR)
    {
        HttpTrace1( "HttpAddUrlToConfigGroup failed, error %lu\n", status );
        goto cleanup;
    }

    //
    // Associate the configuration group with the application pool.
    //
    configAppPool.Flags.Present = 1;
    configAppPool.AppPoolHandle = ReqQueueHandle;

    status = HttpSetConfigGroupInformation(
                    g_ControlChannel,
                    configId,
                    HttpConfigGroupAppPoolInformation,
                    &configAppPool,
                    sizeof(configAppPool)
                    );
    
    if (status != NO_ERROR)
    {
        HttpTrace1( "Set HttpConfigGroupAppPoolInformation failed, error %lu\n", status );
        goto cleanup;
    }

    //
    // Set the config group state.
    //
    configState.Flags.Present = 1;
    configState.State = HttpEnabledStateActive;

    status = HttpSetConfigGroupInformation(
                    g_ControlChannel,
                    configId,
                    HttpConfigGroupStateInformation,
                    &configState,
                    sizeof(configState)
                    );

    if (status != NO_ERROR)
    {
        HttpTrace1( "Set HttpConfigGroupStateInformation failed, error %lu\n", status );
        goto cleanup;
    }

    // Store URL & Config Group ID in hash table, keyed on URL
    status = AddConfigGroupToTable(
        configId,
        pFullyQualifiedUrl
        );

    if (status != NO_ERROR)
    {
        HttpTrace1( "AddConfigGroupToTable failed, error %lu\n", status );
        goto cleanup;
    }
        
 cleanup:
    if ( NO_ERROR != status )
    {
        // Failed.  Clean up whatever needs to be cleaned up.
        if ( HTTP_NULL_ID != configId )
        {
            // Delete config group
            HttpDeleteConfigGroup(
                        g_ControlChannel,
                        configId
                        );
            
            // Remove config group from table
            DeleteConfigIdFromTable( configId );
        }
    }

    return status;
} // HttpAddUrl


/***************************************************************************++

Routine Description:

    Removes an existing URL from the Request Queue (App Pool).  
    NOTE: The associated Config Group should be cleaned up here. (NYI).

Arguments:

    ReqQueueHandle - App Pool Handle

    pFullyQualifiedUrl - full URL with port descriptor & path


Return Value:

    ULONG - Completion status.

--***************************************************************************/
HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveUrl(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pFullyQualifiedUrl
    )
{
    ULONG                   status;
    HTTP_CONFIG_GROUP_ID    CGId;
    
    //
    // Verify we've been init'd.
    //

    if ( !HttpIsInitialized(HTTP_INITIALIZE_SERVER) )
    {
        return ERROR_DLL_INIT_FAILED; 
    }

    //
    // Validate ReqQueue and URL
    //
    if ( !ReqQueueHandle ||
         !pFullyQualifiedUrl ||
         !wcslen(pFullyQualifiedUrl) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // REVIEW: Do we need to do some sort of access check before we zap
    // REVIEW: the URL & Config Group?

    //
    // Look up Config Group ID from URL
    //
    CGId = DeleteUrlFromTable( pFullyQualifiedUrl );

    if ( HTTP_NULL_ID != CGId )
    {
        //
        // Del All URLs from Config Group
        //
        HttpRemoveAllUrlsFromConfigGroup(
            g_ControlChannel,
            CGId
            );

        //
        // Del Config Group
        //
        status = HttpDeleteConfigGroup(
                     g_ControlChannel,
                     CGId
                     );
        
    } else
    {
        status = ERROR_FILE_NOT_FOUND;
    }

    return status;

} // HttpRemoveUrl


/***************************************************************************++

Routine Description:

    Initializes the config group hash table

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
InitializeConfigGroupTable(
    VOID
    )
{
    if (!InitializeCriticalSectionAndSpinCount(
            &g_CGListCritSec,
            HTTP_CS_SPIN_COUNT
            ))
    {
        return GetLastError();
    }

    // CODEWORK: actually implement this as a hash table and not just a list
    InitializeListHead( &g_ConfigGroupListHead );

    InterlockedIncrement( (PLONG)&g_ConfigGroupInitialized );

    return NO_ERROR;

} // InitializeConfigGroupTable


/***************************************************************************++

Routine Description:

    Terminates the config group hash table.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
VOID
TerminateConfigGroupTable(
    VOID
    )
{
    PCONFIG_GROUP_INFO  pCGInfo;
    PLIST_ENTRY         pEntry;

    ASSERT( g_ControlChannel );

    // If not initialized, bail out.
    
    if ( g_ConfigGroupInitialized == 0 )
    {
        return;
    }
    
    // CODEWORK: actually implement this as a hash table and not just a list
    
    EnterCriticalSection( &g_CGListCritSec );
    
    for ( ;; )
    {
        pEntry = RemoveTailList( &g_ConfigGroupListHead );
        if (pEntry == &g_ConfigGroupListHead )
        {
            break;
        }

        pCGInfo = CONTAINING_RECORD( pEntry, CONFIG_GROUP_INFO, ListEntry );

        HttpTrace1( "TerminateConfigGroupTable: Removing %S\n", pCGInfo->Url ); 

        //
        // Delete Config Group by ID
        //
        ASSERT( HTTP_NULL_ID != pCGInfo->ConfigGroupId );

        HttpRemoveAllUrlsFromConfigGroup(
            g_ControlChannel,
            pCGInfo->ConfigGroupId
            );

        HttpDeleteConfigGroup(
            g_ControlChannel,
            pCGInfo->ConfigGroupId
            );
        
        FREE_MEM( pCGInfo );
    }

    LeaveCriticalSection( &g_CGListCritSec );


} // TerminateEventCache


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Adds a Config Group ID/URL pair to a hash table, keyed on URL.
    
    CODEWORK: Need to re-implement as hash table

Arguments:

    CGId - Config Group ID to add to hash table.

    wszUrl - URL associated with config group (always 1:1 mapping)
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
AddConfigGroupToTable(
    HTTP_CONFIG_GROUP_ID CGId,
    LPCWSTR wszUrl
    )
{
    PCONFIG_GROUP_INFO pCGInfo;
    size_t             cbSize;

    ASSERT( wszUrl );
    
    cbSize = sizeof( CONFIG_GROUP_INFO );
    cbSize += sizeof( WCHAR ) * (wcslen( wszUrl ) + 1);

    pCGInfo = ALLOC_MEM( cbSize );
    if ( NULL == pCGInfo )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pCGInfo->ConfigGroupId = CGId;

    if ( wcslen(wszUrl) )
    {
        pCGInfo->Url = (LPWSTR) (((PCHAR)pCGInfo) + sizeof( CONFIG_GROUP_INFO ));
        wcscpy( pCGInfo->Url, wszUrl );
    }

    EnterCriticalSection( &g_CGListCritSec );

    InsertTailList(
        &g_ConfigGroupListHead,
        &pCGInfo->ListEntry
        );

    LeaveCriticalSection( &g_CGListCritSec );

    return NO_ERROR;
    
} // AddConfigGroupToTable


/***************************************************************************++

Routine Description:

    Removes an entry from the hash table (by Config Group ID)

Arguments:

    CGId - Config Group ID.

--***************************************************************************/
VOID
DeleteConfigIdFromTable(
    HTTP_CONFIG_GROUP_ID CGId
    )
{
    PLIST_ENTRY         pEntry;
    PCONFIG_GROUP_INFO  pCGInfo;    
    
    // Grab crit sec
    EnterCriticalSection( &g_CGListCritSec );
    
    // Walk List looking for matching entry
    pEntry = g_ConfigGroupListHead.Flink;

    while( pEntry != &g_ConfigGroupListHead )
    {
        pCGInfo = CONTAINING_RECORD( pEntry, CONFIG_GROUP_INFO, ListEntry );

        if ( pCGInfo->ConfigGroupId == CGId )
        {
            // Remove entry from List
            RemoveEntryList( pEntry );
            
            // Free structure.
            FREE_MEM( pCGInfo );

            break;
        }

        pEntry = pEntry->Flink;
    }
    
    // Release crit sec
    LeaveCriticalSection( &g_CGListCritSec );

} // DeleteConfigIdFromTable


/***************************************************************************++

Routine Description:

    Removes an entry from the hash table (by URL)

Arguments:

    wszUrl - URL associated with Config Group Id.

Returns:

    HTTP_CONFIG_GROUP_ID - ID of config group associated with wszUrl;
        HTTP_NULL_ID if no match found.

--***************************************************************************/
HTTP_CONFIG_GROUP_ID
DeleteUrlFromTable(
    LPCWSTR wszUrl
    )
{
    
    PLIST_ENTRY         pEntry;
    PCONFIG_GROUP_INFO  pCGInfo;
    HTTP_CONFIG_GROUP_ID CGId = HTTP_NULL_ID;
    
    // Grab crit sec
    EnterCriticalSection( &g_CGListCritSec );
    
    // Walk List looking for matching entry
    pEntry = g_ConfigGroupListHead.Flink;

    while( pEntry != &g_ConfigGroupListHead )
    {
        pCGInfo = CONTAINING_RECORD( pEntry, CONFIG_GROUP_INFO, ListEntry );

        if ( 0 == wcscmp( pCGInfo->Url, wszUrl ) )
        {
            // Remove entry from List
            RemoveEntryList( pEntry );
            
            // Free structure.
            CGId = pCGInfo->ConfigGroupId;

            FREE_MEM( pCGInfo );

            break;
        }

        pEntry = pEntry->Flink;
    }
    
    // Release crit sec
    LeaveCriticalSection( &g_CGListCritSec );

    return CGId;

} // DeleteUrlFromTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\c14n.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    C14n.c

Abstract:

    URL canonicalization (c14n) routines

Author:

    George V. Reilly (GeorgeRe)     22-Mar-2002

Revision History:

--*/

#include <precomp.h>

#include "c14np.h"

#if defined(ALLOC_PRAGMA) && defined(KERNEL_PRIV)

#pragma alloc_text( PAGE, HttpInitializeDefaultUrlC14nConfig)
#pragma alloc_text( PAGE, HttpInitializeDefaultUrlC14nConfigEncoding)
#pragma alloc_text( PAGE, HttpUnescapePercentHexEncoding)
#pragma alloc_text( PAGE, HttppPopCharHostNameUtf8)
#pragma alloc_text( PAGE, HttppPopCharHostNameDbcs)
#pragma alloc_text( PAGE, HttppPopCharHostNameAnsi)
#pragma alloc_text( PAGE, HttpCopyHost)
#pragma alloc_text( PAGE, HttppCopyHostByType)
#pragma alloc_text( PAGE, HttpValidateHostname)
#pragma alloc_text( PAGE, HttppPopCharAbsPathUtf8)
#pragma alloc_text( PAGE, HttppPopCharAbsPathDbcs)
#pragma alloc_text( PAGE, HttppPopCharAbsPathAnsi)
#pragma alloc_text( PAGE, HttppPopCharQueryString)
#pragma alloc_text( PAGE, HttppCopyUrlByType)
#pragma alloc_text( PAGE, HttpCopyUrl)
#pragma alloc_text( PAGE, HttpCleanAndCopyUrl)
#pragma alloc_text( PAGE, HttppCleanAndCopyUrlByType)
#pragma alloc_text( PAGE, HttpFindUrlToken)
#pragma alloc_text( PAGE, HttppParseIPv6Address)
#pragma alloc_text( PAGE, HttppPrintIpAddressW)
#pragma alloc_text( PAGE, HttpParseUrl)
#pragma alloc_text( PAGE, HttpNormalizeParsedUrl)


#endif // ALLOC_PRAGMA && KERNEL_PRIV

#if 0   // Non-Pageable Functions
NOT PAGEABLE -- 
#endif // Non-Pageable Functions



VOID
HttpInitializeDefaultUrlC14nConfig(
    PURL_C14N_CONFIG pCfg
    )
{
    PAGED_CODE();

    pCfg->HostnameDecodeOrder   = UrlDecode_Utf8_Else_Dbcs_Else_Ansi;
    pCfg->AbsPathDecodeOrder    = UrlDecode_Utf8;
    pCfg->EnableNonUtf8         = FALSE;
    pCfg->FavorUtf8             = FALSE;
    pCfg->EnableDbcs            = FALSE;
    pCfg->PercentUAllowed       = DEFAULT_C14N_PERCENT_U_ALLOWED;
    pCfg->AllowRestrictedChars  = DEFAULT_C14N_ALLOW_RESTRICTED_CHARS;
    pCfg->CodePage              = 0;
    pCfg->UrlMaxLength          = DEFAULT_C14N_URL_MAX_LENGTH;
    pCfg->UrlSegmentMaxLength   = DEFAULT_C14N_URL_SEGMENT_MAX_LENGTH;
    pCfg->UrlSegmentMaxCount    = DEFAULT_C14N_URL_SEGMENT_MAX_COUNT;
    pCfg->MaxLabelLength        = DEFAULT_C14N_MAX_LABEL_LENGTH;
    pCfg->MaxHostnameLength     = DEFAULT_C14N_MAX_HOSTNAME_LENGTH;

} // HttpInitializeDefaultUrlC14nConfig



VOID
HttpInitializeDefaultUrlC14nConfigEncoding(
    PURL_C14N_CONFIG    pCfg,
    BOOLEAN             EnableNonUtf8,
    BOOLEAN             FavorUtf8,
    BOOLEAN             EnableDbcs
    )
{
    PAGED_CODE();

    HttpInitializeDefaultUrlC14nConfig(pCfg);

    pCfg->EnableNonUtf8     = EnableNonUtf8;
    pCfg->FavorUtf8         = FavorUtf8;
    pCfg->EnableDbcs        = EnableDbcs;

    if (EnableNonUtf8)
    {
        if (FavorUtf8)
        {
            pCfg->AbsPathDecodeOrder = (EnableDbcs
                                            ? UrlDecode_Utf8_Else_Dbcs
                                            : UrlDecode_Utf8_Else_Ansi);
        }
        else
        {
            pCfg->AbsPathDecodeOrder = (EnableDbcs
                                            ? UrlDecode_Dbcs_Else_Utf8
                                            : UrlDecode_Ansi_Else_Utf8);
        }
    }
    else
    {
        pCfg->AbsPathDecodeOrder = UrlDecode_Utf8;
    }

} // HttpInitializeDefaultUrlC14nConfigEncoding



/***************************************************************************++

Routine Description:

    Convert '%NN' or '%uNNNN' to a ULONG.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    PercentUAllowed - Accept '%uNNNN' notation?
    pOutChar        - decoded character
    pBytesToSkip    - number of bytes consumed from pSourceChar;
                      will be 3 for %NN and 6 for %uNNNN.

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttpUnescapePercentHexEncoding(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    OUT PULONG  pOutChar,
    OUT PULONG  pBytesToSkip
    )
{
    ULONG   Result, i, NumDigits;
    PCUCHAR pHexDigits;

    PAGED_CODE();

    if (SourceLength < STRLEN_LIT("%NN"))
    {
        UlTraceError(PARSER, (
                    "http!HttpUnescapePercentHexEncoding(%p): "
                    "Length too short, %lu.\n",
                    pSourceChar, SourceLength
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }
    else if (pSourceChar[0] != PERCENT)
    {
        UlTraceError(PARSER, (
                    "http!HttpUnescapePercentHexEncoding(%p): "
                    "Starts with 0x%02lX, not '%%'.\n",
                    pSourceChar, (ULONG) pSourceChar[0]
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    if (pSourceChar[1] != 'u'  &&  pSourceChar[1] != 'U')
    {
        // RFC 2396 says that an "escaped octet is encoded as a character
        // triplet, consisting of the percent character '%' followed by
        // the two hexadecimal digits representing the octet code."

        pHexDigits    = pSourceChar + STRLEN_LIT("%");
        NumDigits     = 2;
        *pBytesToSkip = STRLEN_LIT("%NN");
    }
    else
    {
        // This is the %uNNNN notation generated by JavaScript's escape() fn

        if (! PercentUAllowed)
        {
            UlTraceError(PARSER, (
                        "http!HttpUnescapePercentHexEncoding(%p): "
                        "%%uNNNN forbidden.\n",
                        pSourceChar, SourceLength
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }
        else if (SourceLength < STRLEN_LIT("%uNNNN"))
        {
            UlTraceError(PARSER, (
                        "http!HttpUnescapePercentHexEncoding(%p): "
                        "Length %lu too short for %%uNNNN.\n",
                        pSourceChar, SourceLength
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        pHexDigits    = pSourceChar + STRLEN_LIT("%u");
        NumDigits     = 4;
        *pBytesToSkip = STRLEN_LIT("%uNNNN");
    }

    ASSERT(*pBytesToSkip <= SourceLength);

    Result = 0;

    for (i = 0;  i < NumDigits;  ++i)
    {
        ULONG Char = pHexDigits[i];
        ULONG Digit;

        //
        // HexToChar() inlined. Note: in ASCII, '0' < 'A' < 'a' and there are
        // no gaps in ranges '0'..'9', 'A'..'F', and 'a'..'f' (unlike EBCDIC,
        // which has gaps between 'I'/'J', 'R'/'S', 'i'/'j', and 'r'/'s').
        //

        C_ASSERT('0' < 'A'  &&  'A' < 'a');
        C_ASSERT('9' - '0'  == 10 - 1);
        C_ASSERT('F' - 'A'  ==  6 - 1);
        C_ASSERT('f' - 'a'  ==  6 - 1);

        if (! IS_HTTP_HEX(Char))
        {
            UlTraceError(PARSER, (
                        "http!HttpUnescapePercentHexEncoding(%p): "
                        "Invalid hex character[%lu], 0x%02lX.\n",
                        pSourceChar, i, Char
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }
        else if ('a' <= Char)
        {
            ASSERT('a' <= Char  &&  Char <= 'f');
            Digit = Char - 'a' + 0xA;
        }
        else if ('A' <= Char)
        {
            ASSERT('A' <= Char  &&  Char <= 'F');
            Digit = Char - 'A' + 0xA;
        }
        else
        {
            ASSERT('0' <= Char  &&  Char <= '9');
            Digit = Char - '0';
        }

        ASSERT(Digit < 0x10);

        Result = (Result << 4)  |  Digit;
    }

    *pOutChar = Result;

    return STATUS_SUCCESS;

} // HttpUnescapePercentHexEncoding



/***************************************************************************++

Routine Description:

    Consume 1-4 bytes from pSourceChar, treating it as raw UTF-8.
    This routine is only suitable for the hostname part of an HTTP URL,

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharHostNameUtf8(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(SourceLength > 0);

    Status = HttpUtf8RawBytesToUnicode(
                    pSourceChar,
                    SourceLength,
                    pUnicodeChar,
                    pBytesToSkip
                    );

    return Status;

} // HttppPopCharHostNameUtf8



/***************************************************************************++

Routine Description:

    Consume 1-2 bytes from pSourceChar and converts it from raw DBCS to Unicode.
    This routine is only suitable for the hostname part of an HTTP URL.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharHostNameDbcs(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    NTSTATUS Status;
    ULONG    AnsiCharSize;
    WCHAR    WideChar;

    PAGED_CODE();

    ASSERT(SourceLength > 0);

    if (! IS_DBCS_LEAD_BYTE(pSourceChar[0]))
    {
        AnsiCharSize = 1;
    }
    else
    {
        if (SourceLength < 2)
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharHostNameDbcs(%p): "
                        "ERROR: DBCS lead byte, 0x%02lX, at end of string\n",
                        pSourceChar, *pSourceChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        AnsiCharSize = 2;
    }

    Status = RtlMultiByteToUnicodeN(
                    &WideChar,
                    sizeof(WCHAR),
                    NULL,
                    (PCSTR) pSourceChar,
                    AnsiCharSize
                    );

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharHostNameDbcs(%p): "
                    "MultiByteToUnicode(%lu) failed, %s.\n",
                    pSourceChar, AnsiCharSize, HttpStatusToString(Status)
                    ));

        return Status;
    }

    *pUnicodeChar = WideChar;
    *pBytesToSkip = AnsiCharSize;

    return STATUS_SUCCESS;

} // HttppPopCharHostNameDbcs



/***************************************************************************++

Routine Description:

    Consume 1 bytes from pSourceChar and converts it from raw ANSI to Unicode.
    This routine is only suitable for the hostname part of an HTTP URL.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharHostNameAnsi(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    NTSTATUS Status;

#if !DBG
    UNREFERENCED_PARAMETER(SourceLength);
#endif // !DBG

    PAGED_CODE();

    ASSERT(SourceLength > 0);

    *pUnicodeChar = AnsiToUnicodeMap[pSourceChar[0]];
    *pBytesToSkip = 1;

    Status = (0 != *pUnicodeChar)
                ? STATUS_SUCCESS
                : STATUS_OBJECT_PATH_SYNTAX_BAD;

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharHostNameAnsi(%p): "
                    "No mapping for %lu.\n",
                    pSourceChar, *pSourceChar
                    ));
    }

    return Status;

} // HttppPopCharHostNameAnsi



/***************************************************************************++

Routine Description:

    Common tail function called at the end of the HttppPopCharAbsPath*()
    functions, to minimize code replication.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    UnicodeChar     - decoded character
    BytesToSkip     - number of characters consumed from pSourceChar
    pUnicodeChar    - where to put UnicodeChar result
    pBytesToSkip    - where to put BytesToSkip result

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

__inline
NTSTATUS
HttppPopCharAbsPathCommonTail(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  ULONG   UnicodeChar,
    IN  ULONG   BytesToSkip,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
#if !DBG
    UNREFERENCED_PARAMETER(pSourceChar);
    UNREFERENCED_PARAMETER(SourceLength);
#endif // !DBG

    //
    // Special handling for characters in the 8-bit range.
    // May want to look at BytesToSkip to distinguish between
    // raw and hex-escaped/UTF-8-encoded data.
    //
    // In particular, should we allow %2F or %u002F as alternate
    // represenations of '/' in a URL? Why would anyone have a legitimate
    // need to escape a slash character?
    //

    if (UnicodeChar < 0x100)
    {
        // Transform backslashes to forward slashes

        if (BACK_SLASH == UnicodeChar)
        {
            UnicodeChar = FORWARD_SLASH;
        }
        else if (!AllowRestrictedChars  &&  IS_URL_INVALID(UnicodeChar))
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharAbsPathCommonTail(%p): "
                        "Invalid character, U+%04X.\n",
                        pSourceChar, UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        // CODEWORK: should we allow hex-escaped "restricted" or "unwise"
        // characters at all?
    }

    ASSERT(BytesToSkip <= SourceLength);

    *pBytesToSkip = BytesToSkip;
    *pUnicodeChar = UnicodeChar;

    return STATUS_SUCCESS;

} // HttppPopCharAbsPathCommonTail



/***************************************************************************++

Routine Description:

    Consume 1-12 bytes from pSourceChar. Handle hex-escaped UTF-8 encoding.
    This routine is only suitable for the /abspath part of an HTTP URL.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharAbsPathUtf8(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    NTSTATUS Status;
    ULONG    UnicodeChar;
    ULONG    BytesToSkip;
    ULONG    Temp;
    ULONG    OctetCount;
    UCHAR    Octets[4];
    UCHAR    LeadByte;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(SourceLength > 0);

    //
    // validate it as a valid URL character
    //

    if (! IS_URL_TOKEN(pSourceChar[0]))
    {
        UlTraceError(PARSER, (
            "http!HttppPopCharAbsPathUtf8(%p): "
            "first char, 0x%02lX, isn't URL token\n",
            pSourceChar, (ULONG) pSourceChar[0]
            ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    //
    // need to unescape hex encoding, '%NN' or '%uNNNN'?
    //

    if (PERCENT != pSourceChar[0])
    {
        UnicodeChar = pSourceChar[0];
        BytesToSkip = 1;

        //
        // All octets with bit7 set MUST be hex-escaped.
        // Do NOT accept literals with hi-bit set.
        //

        if (UnicodeChar > ASCII_MAX)
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharAbsPathUtf8(%p): "
                        "Invalid hi-bit literal, 0x%02lX.\n",
                        pSourceChar, UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        Status = STATUS_SUCCESS;
        goto unslash;
    }

    Status = HttpUnescapePercentHexEncoding(
                    pSourceChar,
                    SourceLength,
                    PercentUAllowed,
                    &UnicodeChar,
                    &BytesToSkip
                    );

    if (! NT_SUCCESS(Status))
    {
        UlTraceError(PARSER, (
            "http!HttppPopCharAbsPathUtf8(%p): "
            "Invalid hex encoding.\n",
            pSourceChar
            ));

        return Status;
    }

    //
    // If we consumed '%uNNNN', don't attempt any UTF-8 decoding
    //

    if (STRLEN_LIT("%uNNNN") == BytesToSkip)
        goto unslash;

    ASSERT(STRLEN_LIT("%NN") == BytesToSkip);
    ASSERT(UnicodeChar <= 0xFF);

    Octets[0] = LeadByte = (UCHAR) UnicodeChar;

    OctetCount = UTF8_OCTET_COUNT(LeadByte);

    if (0 == OctetCount)
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharAbsPathUtf8(%p): "
                    "Invalid lead byte, 0x%02lX.\n",
                    pSourceChar, UnicodeChar
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    ASSERT(OctetCount <= sizeof(Octets) / sizeof(Octets[0]));

    BytesToSkip = OctetCount * STRLEN_LIT("%NN");

    if (BytesToSkip > SourceLength)
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharAbsPathUtf8(%p): "
                    "%lu octets is not enough for %lu-byte UTF-8 encoding.\n",
                    pSourceChar, OctetCount, SourceLength
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    if (OctetCount == 1)
    {
#if DBG
        // Singleton: no trail bytes

        Status = HttpUtf8RawBytesToUnicode(
                        Octets,
                        OctetCount,
                        &UnicodeChar,
                        &Temp
                        );

        ASSERT(STATUS_SUCCESS == Status);
        ASSERT(UnicodeChar == LeadByte);
        ASSERT(1 == Temp);
#endif // DBG
    }
    else
    {
        ULONG i;

        //
        // Decode the hex-escaped trail bytes
        //

        for (i = 1;  i < OctetCount;  ++i)
        {
            ULONG TrailChar;
            UCHAR TrailByte;

            Status = HttpUnescapePercentHexEncoding(
                            pSourceChar  +  i * STRLEN_LIT("%NN"),
                            STRLEN_LIT("%NN"),
                            FALSE,  // do not allow %uNNNN for trail bytes
                            &TrailChar,
                            &Temp
                            );

            if (! NT_SUCCESS(Status))
            {
                UlTraceError(PARSER, (
                            "http!HttppPopCharAbsPathUtf8(%p): "
                            "Invalid hex-encoded trail byte[%lu].\n",
                            pSourceChar, i
                            ));

                return Status;
            }

            ASSERT(STRLEN_LIT("%NN") == Temp);
            ASSERT(TrailChar <= 0xFF);

            Octets[i] = TrailByte = (UCHAR) TrailChar;

            if (! IS_UTF8_TRAILBYTE(TrailByte))
            {
                UlTraceError(PARSER, (
                            "http!HttppPopCharAbsPathUtf8(%p): "
                            "Invalid trail byte[%lu], 0x%02lX.\n",
                            pSourceChar, i, TrailChar
                            ));

                RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
            }
        }

        //
        // Decode the raw UTF-8 bytes
        //

        Status = HttpUtf8RawBytesToUnicode(
                        Octets,
                        OctetCount,
                        &UnicodeChar,
                        &Temp
                        );

        if (! NT_SUCCESS(Status))
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharAbsPathUtf8(%p): "
                        "Invalid UTF-8 sequence.\n",
                        pSourceChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }
    }

unslash:

    ASSERT(NT_SUCCESS(Status));

    return HttppPopCharAbsPathCommonTail(
                pSourceChar,
                SourceLength,
                UnicodeChar,
                BytesToSkip,
                AllowRestrictedChars,
                pUnicodeChar,
                pBytesToSkip
                );

} // HttppPopCharAbsPathUtf8



/***************************************************************************++

Routine Description:

    Consume 1-6 bytes from pSourceChar. Handle hex-escaped DBCS encoding.
    This routine is only suitable for the /abspath part of an HTTP URL.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharAbsPathDbcs(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    NTSTATUS Status;
    ULONG    UnicodeChar;
    WCHAR    WideChar;
    ULONG    BytesToSkip;
    UCHAR    AnsiChar[2];
    ULONG    AnsiCharSize;
    UCHAR    LeadByte;
    UCHAR    SecondByte = 0;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(SourceLength > 0);

    if (! IS_URL_TOKEN(pSourceChar[0]))
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharAbsPathDbcs(%p): "
                    "first char, 0x%02lX, isn't URL token\n",
                    pSourceChar, (ULONG) pSourceChar[0]
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    if (PERCENT != pSourceChar[0])
    {
        // Note: unlike UTF-8, we allow literal bytes whose top bit is set

        UnicodeChar = pSourceChar[0];
        BytesToSkip = 1;
    }
    else
    {
        // need to unescape hex encoding, '%NN' or '%uNNNN'

        Status = HttpUnescapePercentHexEncoding(
                        pSourceChar,
                        SourceLength,
                        PercentUAllowed,
                        &UnicodeChar,
                        &BytesToSkip
                        );

        if (! NT_SUCCESS(Status))
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharAbsPathDbcs(%p): "
                        "Invalid hex encoding.\n",
                        pSourceChar
                        ));

            return Status;
        }

        //
        // If we consumed '%uNNNN', don't attempt DBCS-to-Unicode conversion
        //

        if (STRLEN_LIT("%uNNNN") == BytesToSkip)
            goto unslash;

        ASSERT(STRLEN_LIT("%NN") == BytesToSkip);
        ASSERT(UnicodeChar <= 0xFF);
    }

    LeadByte    = (UCHAR) UnicodeChar;
    AnsiChar[0] = LeadByte;

    if (! IS_DBCS_LEAD_BYTE(LeadByte))
    {
        AnsiCharSize = 1;
    }
    else
    {
        //
        // This is a double-byte character.
        //

        ASSERT(BytesToSkip <= SourceLength);

        if (BytesToSkip == SourceLength)
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharAbsPathDbcs(%p): "
                        "ERROR: DBCS lead byte, 0x%02lX, at end of string\n",
                        pSourceChar, UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        AnsiCharSize = 2;
        SecondByte   = pSourceChar[BytesToSkip];

        if (PERCENT != SecondByte)
        {
            BytesToSkip += 1;
        }
        else
        {
            ULONG TrailChar;
            ULONG Temp;

            if (BytesToSkip + STRLEN_LIT("%NN") > SourceLength)
            {
                UlTraceError(PARSER, (
                            "http!HttppPopCharAbsPathDbcs(%p): "
                            "ERROR: no space for DBCS hex-encoded suffix\n",
                            pSourceChar
                            ));

                RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
            }

            Status = HttpUnescapePercentHexEncoding(
                            pSourceChar  + BytesToSkip,
                            SourceLength - BytesToSkip,
                            FALSE,          // no %uNNNN allowed here
                            &TrailChar,
                            &Temp
                            );

            if (! NT_SUCCESS(Status))
            {
                UlTraceError(PARSER, (
                            "http!HttppPopCharAbsPathDbcs(%p): "
                            "Invalid hex encoding of trail byte.\n",
                            pSourceChar
                            ));

                return Status;
            }

            ASSERT(STRLEN_LIT("%NN") == Temp);
            ASSERT(TrailChar <= 0xFF);

            SecondByte   = (UCHAR) TrailChar;
            BytesToSkip += STRLEN_LIT("%NN");
        }

        AnsiChar[1] = SecondByte;
    }

    Status = RtlMultiByteToUnicodeN(
                    &WideChar,
                    sizeof(WCHAR),
                    NULL,
                    (PCHAR) &AnsiChar[0],
                    AnsiCharSize
                    );

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharAbsPathDbcs(%p): "
                    "MultiByteToUnicode(%lu) failed, %s.\n",
                    pSourceChar, AnsiCharSize, HttpStatusToString(Status)
                    ));

        return Status;
    }

    UnicodeChar = WideChar;

#if DBG
    //
    // Describe conversion in debug spew.
    //

    if (1 == AnsiCharSize)
    {
        UlTraceVerbose(PARSER, (
            "http!HttppPopCharAbsPathDbcs(%p): "
            "converted %02X to U+%04lX '%C'\n",
            pSourceChar,
            LeadByte,
            UnicodeChar,
            UnicodeChar
            ));
    }
    else
    {
        ASSERT(2 == AnsiCharSize);

        UlTraceVerbose(PARSER, (
            "http!HttppPopCharAbsPathDbcs(%p): "
            "converted %02X %02X to U+%04lX '%C'\n",
            pSourceChar,
            LeadByte,
            SecondByte,
            UnicodeChar,
            UnicodeChar
            ));
    }
#endif // DBG

unslash:

    ASSERT(NT_SUCCESS(Status));

    return HttppPopCharAbsPathCommonTail(
                pSourceChar,
                SourceLength,
                UnicodeChar,
                BytesToSkip,
                AllowRestrictedChars,
                pUnicodeChar,
                pBytesToSkip
                );

} // HttppPopCharAbsPathDbcs



/***************************************************************************++

Routine Description:

    Consume 1-6 bytes from pSourceChar. Handle hex-escaped ANSI encoding.
    This routine is only suitable for the /abspath part of an HTTP URL.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharAbsPathAnsi(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    UnicodeChar;
    ULONG    BytesToSkip;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(SourceLength > 0);

    //
    // DBCS and ANSI decoders must allow any raw byte whose top bit 
    // is set (0x80-0xFF)
    //
    
    if (! IS_URL_TOKEN(pSourceChar[0])     && 
        !(0x80 & pSourceChar[0]))
    {
        UlTraceError(PARSER, (
                    "http!HttppPopCharAbsPathAnsi(%p): "
                    "first char, 0x%02lX, isn't URL token\n",
                    pSourceChar, (ULONG) pSourceChar[0]
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    if (PERCENT != pSourceChar[0])
    {
        // Note: unlike UTF-8, we allow literal bytes whose top bit is set

        UnicodeChar = AnsiToUnicodeMap[ pSourceChar[0] ];
        BytesToSkip = 1;
    }
    else
    {
        // need to unescape hex encoding, '%NN' or '%uNNNN'

        Status = HttpUnescapePercentHexEncoding(
                        pSourceChar,
                        SourceLength,
                        PercentUAllowed,
                        &UnicodeChar,
                        &BytesToSkip
                        );

        if (! NT_SUCCESS(Status))
        {
            UlTraceError(PARSER, (
                        "http!HttppPopCharAbsPathAnsi(%p): "
                        "Invalid hex encoding.\n",
                        pSourceChar
                        ));

            return Status;
        }

        //
        // If we consumed '%uNNNN', don't attempt Ansi-to-Unicode conversion
        //

        if (STRLEN_LIT("%uNNNN") != BytesToSkip)
        {
            ASSERT(STRLEN_LIT("%NN") == BytesToSkip);
            ASSERT(UnicodeChar <= 0xFF);

            UnicodeChar = AnsiToUnicodeMap[(UCHAR) UnicodeChar];
        }
    }

    ASSERT(NT_SUCCESS(Status));

    return HttppPopCharAbsPathCommonTail(
                pSourceChar,
                SourceLength,
                UnicodeChar,
                BytesToSkip,
                AllowRestrictedChars,
                pUnicodeChar,
                pBytesToSkip
                );

} // HttppPopCharAbsPathAnsi



/***************************************************************************++

Routine Description:

    Consume 1 bytes from pSourceChar and returns it unaltered.
    This routine is only suitable for the ?querystring part of an HTTP URL,
    which we do not interpret.

    CODEWORK: don't 'convert' querystring to Unicode. Send it up verbatim.

Arguments:

    pSourceChar     - Input buffer
    SourceLength    - Length of pSourceChar, in bytes
    pUnicodeChar    - decoded character
    pBytesToSkip    - number of characters consumed from pSourceChar

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttppPopCharQueryString(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(SourceLength);
    UNREFERENCED_PARAMETER(PercentUAllowed);
    UNREFERENCED_PARAMETER(AllowRestrictedChars);

    *pUnicodeChar = *pSourceChar;
    *pBytesToSkip = 1;

    return STATUS_SUCCESS;

} // HttppPopCharQueryString



//
// a cool local helper macro
//

#define EMIT_CHAR(ch, pDest, BytesCopied, Status, AllowRestrictedChars) \
    do                                                          \
    {                                                           \
        WCHAR HighSurrogate, LowSurrogate;                      \
                                                                \
        if ((ch) > LOW_NONCHAR_BITS)                            \
        {                                                       \
            Status = HttpUcs4toUtf16((ch),                      \
                            &HighSurrogate, &LowSurrogate);     \
                                                                \
            if (! NT_SUCCESS(Status))                           \
                goto end;                                       \
                                                                \
            *pDest++ = HighSurrogate;                           \
            *pDest++ = LowSurrogate;                            \
            BytesCopied += 2 * sizeof(WCHAR);                   \
        }                                                       \
        else                                                    \
        {                                                       \
            ASSERT(ch < HIGH_SURROGATE_START                    \
                    ||   LOW_SURROGATE_END < ch);               \
                                                                \
            if ( IS_UNICODE_NONCHAR((ch)) )                     \
            {                                                   \
                UlTraceError(PARSER, (                          \
                    "http!HttpUcs4toUtf16(): "                  \
                    "Non-character code point, U+%04lX.\n",     \
                    (ch) ));                                    \
                                                                \
                Status = STATUS_INVALID_PARAMETER;              \
                goto end;                                       \
            }                                                   \
                                                                \
            *pDest++ = (WCHAR) (ch);                            \
            BytesCopied += sizeof(WCHAR);                       \
        }                                                       \
                                                                \
        /* Can probably omit this test */                       \
        if (BytesCopied > UNICODE_STRING_MAX_BYTE_LEN)          \
        {                                                       \
            Status = STATUS_DATA_OVERRUN;                       \
            goto end;                                           \
        }                                                       \
    } while (0, 0)


#define EMIT_LITERAL_CHAR(ch, pDest, BytesCopied)               \
    do                                                          \
    {                                                           \
        ASSERT(IS_ASCII(ch));                                   \
                                                                \
        *pDest++ = (WCHAR) (ch);                                \
        BytesCopied += sizeof(WCHAR);                           \
    } while (0, 0)


#define HttppUrlEncodingToString(UrlEncoding)                   \
    ((UrlEncoding == UrlDecode_Ansi)                            \
        ? "Ansi"                                                \
        : (UrlEncoding == UrlDecode_Dbcs)                       \
            ? "Dbcs"                                            \
            : "Utf8")


/***************************************************************************++

Routine Description:

    Copies a hostname, converting it to Unicode

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpCopyHost(
    IN      PURL_C14N_CONFIG    pCfg,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PURL_ENCODING_TYPE  pHostnameEncodingType
    )
{
    NTSTATUS Status         = STATUS_UNSUCCESSFUL;
    ULONG    DecodeOrder    = pCfg->HostnameDecodeOrder;

    PAGED_CODE();

    ASSERT(NULL != pCfg);
    ASSERT(NULL != pDestination);
    ASSERT(NULL != pSource);
    ASSERT(NULL != pBytesCopied);
    ASSERT(NULL != pHostnameEncodingType);

    if (0 == DecodeOrder  ||  DecodeOrder != (DecodeOrder & UrlDecode_MaxMask))
    {
        UlTraceError(PARSER,
                    ("http!HttpCopyHost: invalid DecodeOrder, 0x%lX\n",
                    DecodeOrder
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    for ( ;
         0 != DecodeOrder  &&  !NT_SUCCESS(Status);
         DecodeOrder >>= UrlDecode_Shift
        )
    {
        ULONG UrlEncoding = (DecodeOrder & UrlDecode_Mask);

        switch (UrlEncoding)
        {
            default:
                ASSERT(! "Impossible UrlDecodeOrder");

            case UrlDecode_None:
                break;

            case UrlDecode_Ansi:
            case UrlDecode_Dbcs:
            case UrlDecode_Utf8:

                UlTraceVerbose(PARSER,
                                ("http!HttpCopyHost(%s, Src=%p, %lu)\n",
                                HttppUrlEncodingToString(UrlEncoding),
                                pSource, SourceLength
                                ));

                Status = HttppCopyHostByType(
                            (URL_ENCODING_TYPE) UrlEncoding,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied
                            );

                if (NT_SUCCESS(Status))
                {
                    *pHostnameEncodingType = (URL_ENCODING_TYPE) UrlEncoding;

                    UlTraceVerbose(PARSER,
                                    ("http!HttpCopyHost(%s): "
                                     "(%lu) '%.*s' -> (%lu) '%ls'\n",
                                     HttppUrlEncodingToString(UrlEncoding),
                                     SourceLength, SourceLength, pSource,
                                     *pBytesCopied/sizeof(WCHAR), pDestination
                                    ));
                }

                break;
        };
    }

    return Status;

} // HttpCopyHost



/***************************************************************************++

Routine Description:

    Copies a hostname, converting it to Unicode

    CODEWORK: Handle ACE-encoded hostnames

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttppCopyHostByType(
    IN      URL_ENCODING_TYPE   UrlEncoding,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied
    )
{
    NTSTATUS                Status;
    PWSTR                   pDest;
    PCUCHAR                 pChar;
    ULONG                   BytesCopied;
    ULONG                   UnicodeChar;
    ULONG                   CharToSkip;
    PFN_POPCHAR_HOSTNAME    pfnPopChar;

    if (UrlEncoding_Ansi == UrlEncoding)
        pfnPopChar = &HttppPopCharHostNameAnsi;
    else if (UrlEncoding_Dbcs == UrlEncoding)
        pfnPopChar = &HttppPopCharHostNameDbcs;
    else if (UrlEncoding_Utf8 == UrlEncoding)
        pfnPopChar = &HttppPopCharHostNameUtf8;
    else
    {
        ASSERT(! "Invalid UrlEncoding");
        RETURN(STATUS_INVALID_PARAMETER);
    }
    //
    // Sanity check.
    //

    PAGED_CODE();


    pDest = pDestination;
    BytesCopied = 0;

    pChar = pSource;

    while ((int)SourceLength > 0)
    {
        UnicodeChar = *pChar;

        if (IS_ASCII(UnicodeChar))
        {
            CharToSkip = 1;
        }
        else
        {
            Status = (*pfnPopChar)(
                            pChar,
                            SourceLength,
                            &UnicodeChar,
                            &CharToSkip
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;
        }

        ASSERT(CharToSkip <= SourceLength);

        EMIT_CHAR(
            UnicodeChar,
            pDest,
            BytesCopied,
            Status,
            FALSE
            );

        pChar += CharToSkip;
        SourceLength -= CharToSkip;
    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;
    *pBytesCopied = BytesCopied;

    Status = STATUS_SUCCESS;


end:
    return Status;

}   // HttppCopyHostByType



/*++

Routine Description:

    Validates that a hostname is well-formed

    CODEWORK: For future IDN (International Domain Names) work,
    we may need to handle raw UTF-8 or ACE hostnames.

    Note: if the validation algorithm changes here, it may be necessary
    to update HttpParseUrl() too.

Arguments:

    pHostname       - the hostname
    HostnameLength  - length of hostname, in bytes
    HostnameType    - Source of the hostname: Host header, AbsUri, or
                        synthesized from the transport's local IP address

Return Value:

    STATUS_SUCCESS if valid

--*/

NTSTATUS
HttpValidateHostname(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      PCUCHAR             pHostname,
    IN      ULONG               HostnameLength,
    IN      HOSTNAME_TYPE       HostnameType,
    OUT     PSHORT              pAddressType
    )
{
    PCUCHAR         pChar;
    PCUCHAR         pLabel;
    PCUCHAR         pEnd = pHostname + HostnameLength;
    PCSTR           pTerminator;
    NTSTATUS        Status;
    USHORT          Port;
    struct in_addr  IPv4Address;
    struct in6_addr IPv6Address;
    BOOLEAN         AlphaLabel;

    PAGED_CODE();

    ASSERT(NULL != pCfg);
    ASSERT(NULL != pHostname);
    ASSERT(NULL != pAddressType);

    if (0 == HostnameLength)
    {
        // RFC 2616, 14.23 "Host" says that the Host header can be empty
        if (Hostname_HostHeader == HostnameType)
            goto end;

        // It is an error for empty hostnames to appear elsewhere
        UlTraceError(PARSER,
                    ("http!HttpValidateHostname: empty hostname\n"
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Is this an IPv6 literal address, per RFC 2732?

    if ('[' == *pHostname)
    {
        // Empty brackets?
        if (HostnameLength < STRLEN_LIT("[0]")  ||  ']' == pHostname[1])
        {
            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: IPv6 address too short\n"
                         ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        for (pChar = pHostname + STRLEN_LIT("[");  pChar < pEnd;  ++pChar)
        {
            if (']' == *pChar)
                break;

            //
            // Dots are allowed because the last 32 bits may be represented
            // in IPv4 dotted-octet notation. We do not accept Scope IDs
            // (indicated by '%') in hostnames.
            //

            if (IS_HTTP_HEX(*pChar)  ||  ':' == *pChar  ||  '.' == *pChar)
                continue;

            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: "
                        "Invalid char in IPv6 address, 0x%02X '%c', "
                        "after '%.*s'\n",
                        *pChar,
                        IS_HTTP_PRINT(*pChar) ? *pChar : '?',
                        DIFF(pChar - pHostname),
                        pHostname
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (pChar == pEnd)
        {
            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: No ']' for IPv6 address\n"
                         ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        ASSERT(pChar < pEnd);
        ASSERT(']' == *pChar);

        // Let the RTL routine do the hard work of parsing IPv6 addrs
        Status = RtlIpv6StringToAddressA(
                    (PCSTR) pHostname + STRLEN_LIT("["),
                    &pTerminator,
                    &IPv6Address
                    );

        if (! NT_SUCCESS(Status))
        {
            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: "
                        "Invalid IPv6 address, %s\n",
                        HttpStatusToString(Status)
                        ));

            RETURN(Status);
        }

        if (pTerminator != (PCSTR) pChar)
        {
            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: "
                        "Invalid IPv6 terminator, 0x%02X '%c'\n",
                        *pTerminator,
                        IS_HTTP_PRINT(*pTerminator) ? *pTerminator : '?'
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        *pAddressType = TDI_ADDRESS_TYPE_IP6;

        // Skip the terminating ']'
        pChar += STRLEN_LIT("]");

        // Any chars after the ']'?
        if (pChar == pEnd)
        {
            ASSERT(DIFF(pEnd - pHostname) <= pCfg->MaxHostnameLength);
            goto end;
        }

        ASSERT(pChar < pEnd);

        if (':' == *pChar)
            goto port;

        UlTraceError(PARSER,
                    ("http!HttpValidateHostname: "
                    "Invalid char after IPv6 ']', 0x%02X '%c'\n",
                    *pChar,
                    IS_HTTP_PRINT(*pChar) ? *pChar : '?'
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    //
    // It must be a domain name or an IPv4 literal. We'll try to treat
    // it as a domain name first. If it turns out to be all-numeric,
    // we'll try decoding it as an IPv4 literal. We'll see if the name
    // is well-formed, but we will not do a DNS lookup to see if it exists,
    // as that would be much too expensive.
    //

    AlphaLabel = FALSE;
    pLabel     = pHostname;

    for (pChar = pHostname;  pChar < pEnd;  ++pChar)
    {
        if (':' == *pChar)
        {
            if (pChar == pHostname)
            {
                UlTraceError(PARSER,
                            ("http!HttpValidateHostname: empty hostname\n"
                             ));

                RETURN(STATUS_INVALID_PARAMETER);
            }


            // exit the loop
            break;
        }

        if ('.' == *pChar)
        {
            ULONG LabelLength = DIFF(pChar - pLabel);

            // There must be at least one char in the label
            if (0 == LabelLength)
            {
                UlTraceError(PARSER,
                            ("http!HttpValidateHostname: empty label\n"
                             ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            // Label can't have more than 63 chars
            if (LabelLength > pCfg->MaxLabelLength)
            {
                UlTraceError(PARSER,
                            ("http!HttpValidateHostname: overlong label, %lu\n",
                             LabelLength
                             ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            // Reset for the next label
            pLabel = pChar + STRLEN_LIT(".");

            continue;
        }

        // CODEWORK: handle DBCS characters

        if (!IS_URL_ILLEGAL_COMPUTERNAME(*pChar))
        {
            if (!IS_HTTP_DIGIT(*pChar))
                AlphaLabel = TRUE;

            if (pChar > pLabel)
                continue;

            // The first char of a label cannot be a hyphen. (Underscore?)
            if ('-' == *pChar)
            {
                UlTraceError(PARSER,
                            ("http!HttpValidateHostname: "
                             "'-' at beginning of label\n"
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            continue;
        }

        UlTraceError(PARSER,
                    ("http!HttpValidateHostname: "
                     "Invalid char in hostname, 0x%02X '%c', "
                     "after '%.*s'\n",
                     *pChar,
                     IS_HTTP_PRINT(*pChar) ? *pChar : '?',
                     DIFF(pChar - pHostname),
                     pHostname
                    ));

        RETURN(STATUS_INVALID_PARAMETER);

    } // loop through hostname


    ASSERT(pChar == pEnd  ||  ':' == *pChar);

    if (AlphaLabel)
    {
        *pAddressType = 0;
    }
    else
    {
        // Let's see if it's a valid IPv4 address
        Status = RtlIpv4StringToAddressA(
                    (PCSTR) pHostname,
                    TRUE,           // strict => 4 dotted decimal octets
                    &pTerminator,
                    &IPv4Address
                    );

        if (!NT_SUCCESS(Status))
        {
            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: "
                        "Invalid IPv4 address, %s\n",
                        HttpStatusToString(Status)
                        ));

            RETURN(Status);
        }

        if (pTerminator != (PCSTR) pChar)
        {
            ASSERT(pTerminator < (PCSTR) pChar);

            UlTraceError(PARSER,
                        ("http!HttpValidateHostname: "
                        "Invalid IPv4 address after %lu chars, "
                        "0x%02X, '%c'\n",
                        DIFF(pTerminator - (PCSTR) pHostname),
                        *pTerminator,
                        IS_HTTP_PRINT(*pTerminator) ? *pTerminator : '?'
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        *pAddressType = TDI_ADDRESS_TYPE_IP;
    }

port:

    //
    // Parse the port number
    //

    // Check for overlong hostnames
    if (DIFF(pChar - pHostname) > pCfg->MaxHostnameLength)
    {
        UlTraceError(PARSER,
                    ("http!HttpValidateHostname: overlong hostname, %lu\n",
                     DIFF(pChar - pHostname)
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    if (pChar == pEnd)
        goto end;

    ASSERT(pHostname < pChar  &&  pChar < pEnd);
    ASSERT(':' == *pChar);

    pChar += STRLEN_LIT(":");

    ASSERT(pChar <= pEnd);

    // RFC 2616, section 3.2.2 "http URL", says:
    // "If the port is empty or not given, port 80 is assumed".
    if (pChar == pEnd)
    {
        Port = 80;
        goto end;
    }

    Status = HttpAnsiStringToUShort(
                pChar,
                pEnd - pChar,   // <port> must occupy all remaining chars
                FALSE,          // no leading zeros permitted
                10,
                (PUCHAR*) &pTerminator,
                &Port
                );

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER,
                    ("http!HttpValidateHostname: "
                    "Invalid port number, %s\n",
                    HttpStatusToString(Status)
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(pTerminator == (PCSTR) pEnd);

    if (0 == Port)
    {
        UlTraceError(PARSER,
                    ("http!HttpValidateHostname: Port must not be zero.\n"
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

end:
    RETURN(STATUS_SUCCESS);

} // HttpValidateHostname



/***************************************************************************++

Routine Description:

    Convert to unicode

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
HttpCopyUrl(
    IN      PURL_C14N_CONFIG    pCfg,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PURL_ENCODING_TYPE  pUrlEncodingType
    )
{
    NTSTATUS Status         = STATUS_UNSUCCESSFUL;
    ULONG    DecodeOrder    = pCfg->AbsPathDecodeOrder;

    PAGED_CODE();

    ASSERT(NULL != pDestination);
    ASSERT(NULL != pSource);
    ASSERT(NULL != pBytesCopied);
    ASSERT(NULL != pUrlEncodingType);

    if (0 == DecodeOrder  ||  DecodeOrder != (DecodeOrder & UrlDecode_MaxMask))
    {
        UlTraceError(PARSER,
                    ("http!HttpCopyUrl: invalid DecodeOrder, 0x%lX\n",
                    DecodeOrder
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    for ( ;
         0 != DecodeOrder  &&  !NT_SUCCESS(Status);
         DecodeOrder >>= UrlDecode_Shift
        )
    {
        ULONG UrlEncoding = (DecodeOrder & UrlDecode_Mask);

        switch (UrlEncoding)
        {
            default:
                ASSERT(! "Impossible UrlDecodeOrder");

            case UrlDecode_None:
                break;

            case UrlDecode_Ansi:
            case UrlDecode_Dbcs:
            case UrlDecode_Utf8:

                UlTraceVerbose(PARSER,
                                ("http!HttpCopyUrl(%s, Src=%p, %lu)\n",
                                HttppUrlEncodingToString(UrlEncoding),
                                pSource, SourceLength
                                ));

                Status = HttppCopyUrlByType(
                            pCfg,
                            (URL_ENCODING_TYPE) UrlEncoding,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied
                            );

                if (NT_SUCCESS(Status))
                {
                    *pUrlEncodingType = (URL_ENCODING_TYPE) UrlEncoding;

                    UlTraceVerbose(PARSER,
                                    ("http!HttpCopyUrl(%s): "
                                     "(%lu) '%.*s' -> (%lu) '%ls'\n",
                                     HttppUrlEncodingToString(UrlEncoding),
                                     SourceLength, SourceLength, pSource,
                                     *pBytesCopied/sizeof(WCHAR), pDestination
                                    ));
                }

                break;
        };
    }

    return Status;

} // HttpCopyUrl



/***************************************************************************++

Routine Description:

    This function can be told to copy UTF-8, ANSI, or DBCS URLs.

    Convert to Unicode

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
HttppCopyUrlByType(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      URL_ENCODING_TYPE   UrlEncoding,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied
    )
{
    PWSTR               pDest;
    PCUCHAR             pChar;
    ULONG               BytesCopied;
    ULONG               UnicodeChar;
    ULONG               CharToSkip;
#if DBG
    NTSTATUS            Status;
    PFN_POPCHAR_ABSPATH pfnPopChar;
    PWSTR               pSegment = pDestination;
    ULONG               SegmentCount = 0;
#endif // DBG

    //
    // Sanity check.
    //

    PAGED_CODE();

#if DBG
    if (UrlEncoding_Ansi == UrlEncoding)
        pfnPopChar = &HttppPopCharAbsPathAnsi;
    else if (UrlEncoding_Dbcs == UrlEncoding)
        pfnPopChar = &HttppPopCharAbsPathDbcs;
    else if (UrlEncoding_Utf8 == UrlEncoding)
        pfnPopChar = &HttppPopCharAbsPathUtf8;
    else
    {
        ASSERT(! "Invalid UrlEncoding");
        RETURN(STATUS_INVALID_PARAMETER);
    }
#else  // !DBG
    UNREFERENCED_PARAMETER(pCfg);
    UNREFERENCED_PARAMETER(UrlEncoding);
#endif // DBG

    pDest = pDestination;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 1;

    while ((int)SourceLength > 0)
    {
        ULONG NextUnicodeChar = FastPopChars[*pChar];

        //
        // Grab the next character.
        //
        // All clean chars have a non-zero entry in FastPopChars[].
        // All clean chars are in the US-ASCII range, 0-127.
        //

        ASSERT(0 != NextUnicodeChar);
        ASSERT(IS_ASCII(NextUnicodeChar));

#if DBG
        Status = (*pfnPopChar)(
                        pChar,
                        SourceLength,
                        pCfg->PercentUAllowed,
                        pCfg->AllowRestrictedChars,
                        &UnicodeChar,
                        &CharToSkip
                        );

        ASSERT(NT_SUCCESS(Status));
        ASSERT(UnicodeChar == NextUnicodeChar);
        ASSERT(CharToSkip == 1);
#endif // !DBG

        UnicodeChar = (WCHAR) NextUnicodeChar;
        CharToSkip = 1;

#if DBG
        // Because HttpFindUrlToken() marks as dirty any URLs that
        // (appear to) have too many segments or overlong segments,
        // we should never hit these assertions
        if (FORWARD_SLASH == UnicodeChar)
        {
            ULONG SegmentLength = DIFF(pDest - pSegment);

            // The segment length should be within bounds

            ASSERT(SegmentLength > 0  ||  pDestination == pSegment);
            ASSERT(SegmentLength
                            <= pCfg->UrlSegmentMaxLength + WCSLEN_LIT(L"/"));

            pSegment = pDest;
            ++SegmentCount;

            // There should not be too many segments
            ASSERT(SegmentCount <= pCfg->UrlSegmentMaxCount);
        }
#endif // DBG

        EMIT_LITERAL_CHAR(UnicodeChar, pDest, BytesCopied);

        pChar += CharToSkip;
        SourceLength -= CharToSkip;
    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;
    *pBytesCopied = BytesCopied;

    ASSERT(DIFF(pDest - pSegment) > 0);
    ASSERT(DIFF(pDest - pSegment)
                <= pCfg->UrlSegmentMaxLength + WCSLEN_LIT(L"/"));
    ASSERT(SegmentCount < pCfg->UrlSegmentMaxCount);

    return STATUS_SUCCESS;

}   // HttppCopyUrlByType



/***************************************************************************++

Routine Description:


    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode

Arguments:


Return Value:

    NTSTATUS - Completion status.


Note: Any changes to this code may require changes for the fast path code too.
      The fast path is HttpCopyUrl.

--***************************************************************************/
NTSTATUS
HttpCleanAndCopyUrl(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      URL_PART            UrlPart,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PWSTR *             ppQueryString OPTIONAL,
    OUT     PURL_ENCODING_TYPE  pUrlEncodingType
    )
{
    NTSTATUS Status         = STATUS_UNSUCCESSFUL;
    ULONG    DecodeOrder    = pCfg->AbsPathDecodeOrder;

    PAGED_CODE();

    ASSERT(NULL != pDestination);
    ASSERT(NULL != pSource);
    ASSERT(NULL != pBytesCopied);
    ASSERT(NULL != pUrlEncodingType);

    if (0 == DecodeOrder  ||  DecodeOrder != (DecodeOrder & UrlDecode_MaxMask))
    {
        UlTraceError(PARSER,
                    ("http!HttpCleanAndCopyUrl: invalid DecodeOrder, 0x%lX\n",
                    DecodeOrder
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    for ( ;
         0 != DecodeOrder  &&  !NT_SUCCESS(Status);
         DecodeOrder >>= UrlDecode_Shift
        )
    {
        ULONG UrlEncoding = (DecodeOrder & UrlDecode_Mask);

        switch (UrlEncoding)
        {
            default:
                ASSERT(! "Impossible UrlDecodeOrder");

            case UrlDecode_None:
                break;

            case UrlDecode_Ansi:
            case UrlDecode_Dbcs:
            case UrlDecode_Utf8:

                UlTraceVerbose(PARSER,
                                ("http!HttpCleanAndCopyUrl(%s, Src=%p, %lu)\n",
                                HttppUrlEncodingToString(UrlEncoding),
                                pSource, SourceLength
                                ));

                Status = HttppCleanAndCopyUrlByType(
                            pCfg,
                            (URL_ENCODING_TYPE) UrlEncoding,
                            UrlPart,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied,
                            ppQueryString
                            );

                if (NT_SUCCESS(Status))
                {
                    *pUrlEncodingType = (URL_ENCODING_TYPE) UrlEncoding;

                    UlTraceVerbose(PARSER,
                                    ("http!HttpCleanAndCopyUrl(%s): "
                                     "(%lu) '%.*s' -> (%lu) '%ls'\n",
                                     HttppUrlEncodingToString(UrlEncoding),
                                     SourceLength, SourceLength, pSource,
                                     *pBytesCopied/sizeof(WCHAR), pDestination
                                    ));
                }

                break;
        };
    }

    return Status;

} // HttpCleanAndCopyUrl



//
// HttppCleanAndCopyUrlByType() uses StateFromStateAndToken[][] and
// ActionFromStateAndToken[][] to handle "//", "/./", and "/../" productions.
//

#define TOK_STATE(state, other, dot, eos, slash)    \
    {                                               \
        URL_STATE_ ## other,                        \
        URL_STATE_ ## dot,                          \
        URL_STATE_ ## eos,                          \
        URL_STATE_ ## slash                         \
    }

//
// CanonStateFromStateAndToken[][] is used by HttpParseUrl() to reject
// "//", "/./", and "/../" sequences, as these URLs are supposed to
// be in canonical form already.
//

const URL_STATE
CanonStateFromStateAndToken[URL_STATE_MAX][URL_TOKEN_MAX] =
{
//             State \ Token:  Other       '.'             EOS     '/'
    TOK_STATE( START,          START,      START,          END,    SLASH),
    TOK_STATE( SLASH,          START,      SLASH_DOT,      END,    ERROR),
    TOK_STATE( SLASH_DOT,      START,      SLASH_DOT_DOT,  END,    ERROR),
    TOK_STATE( SLASH_DOT_DOT,  START,      START,          ERROR,  ERROR),

    TOK_STATE( END,            END,        END,            END,    END),
    TOK_STATE( ERROR,          ERROR,      ERROR,          ERROR,  ERROR)
};


//
// StateFromStateAndToken[][] says which new state to transition to given
// the current state and the token we saw. Used by HttppCleanAndCopyUrlByType()
//

const URL_STATE
StateFromStateAndToken[URL_STATE_MAX][URL_TOKEN_MAX] =
{
//             State \ Token:  Other       '.'             EOS     '/'
    TOK_STATE( START,          START,      START,          END,    SLASH),
    TOK_STATE( SLASH,          START,      SLASH_DOT,      END,    SLASH),
    TOK_STATE( SLASH_DOT,      START,      SLASH_DOT_DOT,  END,    SLASH),
    TOK_STATE( SLASH_DOT_DOT,  START,      START,          END,    SLASH),

    TOK_STATE( END,            END,        END,            END,    END),
    TOK_STATE( ERROR,          ERROR,      ERROR,          ERROR,  ERROR)
};


//
// ActionFromStateAndToken[][] says what action to perform based on
// the current state and the current token
//

#define NEW_ACTION(state, other, dot, eos, slash)   \
    {                                               \
        ACTION_ ## other,                           \
        ACTION_ ## dot,                             \
        ACTION_ ## eos,                             \
        ACTION_ ## slash                            \
    }

const URL_ACTION
ActionFromStateAndToken[URL_STATE_MAX][URL_TOKEN_MAX] =
{
//             State \ Token: Other        '.'             EOS     '/'
    NEW_ACTION(START,         EMIT_CH,     EMIT_CH,        NOTHING, EMIT_CH),
    NEW_ACTION(SLASH,         EMIT_CH,     NOTHING,        NOTHING, NOTHING),
    NEW_ACTION(SLASH_DOT,     EMIT_DOT_CH, NOTHING,        NOTHING, NOTHING),
    NEW_ACTION(SLASH_DOT_DOT, EMIT_DOT_DOT_CH,
                                          EMIT_DOT_DOT_CH, BACKUP,  BACKUP),

    NEW_ACTION(END,           NOTHING,     NOTHING,        NOTHING, NOTHING)
};


#if DBG

PCSTR
HttppUrlActionToString(
    URL_ACTION Action)
{
    switch (Action)
    {
        case ACTION_NOTHING:            return "NOTHING";
        case ACTION_EMIT_CH:            return "EMIT_CH";
        case ACTION_EMIT_DOT_CH:        return "EMIT_DOT_CH";
        case ACTION_EMIT_DOT_DOT_CH:    return "EMIT_DOT_DOT_CH";
        case ACTION_BACKUP:             return "BACKUP";
        case ACTION_MAX:                return "MAX";
        default:
            ASSERT(! "Invalid URL_ACTION");
            return "ACTION_???";
    }
} // HttppUrlActionToString


PCSTR
HttppUrlStateToString(
    URL_STATE UrlState)
{
    switch (UrlState)
    {
        case URL_STATE_START:           return "START";
        case URL_STATE_SLASH:           return "SLASH";
        case URL_STATE_SLASH_DOT:       return "SLASH_DOT";
        case URL_STATE_SLASH_DOT_DOT:   return "SLASH_DOT_DOT";
        case URL_STATE_END:             return "END";
        case URL_STATE_ERROR:           return "ERROR";
        case URL_STATE_MAX:             return "MAX";
        default:
            ASSERT(! "Invalid URL_STATE");
            return "URL_STATE_???";
    }
} // HttppUrlStateToString


PCSTR
HttppUrlTokenToString(
    URL_STATE_TOKEN UrlToken)
{
    switch (UrlToken)
    {
        case URL_TOKEN_OTHER:           return "OTHER";
        case URL_TOKEN_DOT:             return "DOT";
        case URL_TOKEN_EOS:             return "EOS";
        case URL_TOKEN_SLASH:           return "SLASH";
        case URL_TOKEN_MAX:             return "MAX";
        default:
            ASSERT(! "Invalid URL_STATE_TOKEN");
            return "URL_TOKEN_???";
    }
} // HttppUrlTokenToString

#endif // DBG


PCSTR
HttpSiteTypeToString(
    HTTP_URL_SITE_TYPE SiteType
    )
{
    switch (SiteType)
    {
        case HttpUrlSite_None:              return "None";
        case HttpUrlSite_Name:              return "Name";
        case HttpUrlSite_IP:                return "IP";
        case HttpUrlSite_NamePlusIP:        return "Name+IP";
        case HttpUrlSite_WeakWildcard:      return "Weak";
        case HttpUrlSite_StrongWildcard:    return "Strong";
        case HttpUrlSite_Max:               return "Max";
        default:
            ASSERT(! "Invalid HTTP_URL_SITE_TYPE");
            return "????";
    }
}



/***************************************************************************++

Routine Description:

    This function can be told to clean up UTF-8, ANSI, or DBCS URLs.

    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode

Arguments:


Return Value:

    NTSTATUS - Completion status.

Note: Any changes to this code may require changes for the fast path code too.
      The fast path is HttppCopyUrlByType.


--***************************************************************************/
NTSTATUS
HttppCleanAndCopyUrlByType(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      URL_ENCODING_TYPE   UrlEncoding,
    IN      URL_PART            UrlPart,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PWSTR *             ppQueryString OPTIONAL
    )
{
    NTSTATUS            Status;
    PWSTR               pDest;
    PCUCHAR             pChar;
    ULONG               CharToSkip;
    ULONG               BytesCopied;
    PWSTR               pQueryString;
    URL_STATE           UrlState = URL_STATE_START;
    URL_STATE_TOKEN     UrlToken = URL_TOKEN_OTHER;
    URL_ACTION          Action = ACTION_NOTHING;
    ULONG               UnicodeChar;
    BOOLEAN             MakeCanonical;
    PWCHAR              pFastPopChar;
    PFN_POPCHAR_ABSPATH pfnPopChar;
    PWSTR               pSegment = pDestination;
    ULONG               SegmentCount = 0;
    BOOLEAN             TestSegment = FALSE;
#if DBG
    ULONG               OriginalSourceLength = SourceLength;
#endif

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UrlPart_AbsPath == UrlPart);

    if (UrlEncoding_Ansi == UrlEncoding)
        pfnPopChar = &HttppPopCharAbsPathAnsi;
    else if (UrlEncoding_Dbcs == UrlEncoding)
        pfnPopChar = &HttppPopCharAbsPathDbcs;
    else if (UrlEncoding_Utf8 == UrlEncoding)
        pfnPopChar = &HttppPopCharAbsPathUtf8;
    else
    {
        ASSERT(! "Invalid UrlEncoding");
        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(FORWARD_SLASH == *pSource);

    pDest = pDestination;
    pQueryString = NULL;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 0;

    UrlState = 0;

    MakeCanonical = (BOOLEAN) (UrlPart == UrlPart_AbsPath);

    if (UrlEncoding == UrlEncoding_Utf8 && UrlPart != UrlPart_QueryString)
    {
        pFastPopChar = FastPopChars;
    }
    else
    {
        pFastPopChar = DummyPopChars;
    }

    while (SourceLength > 0)
    {
        //
        // advance !  it's at the top of the loop to enable ANSI_NULL to
        // come through ONCE
        //

        ASSERT(CharToSkip <= SourceLength);

        pChar += CharToSkip;
        SourceLength -= CharToSkip;

        //
        // well?  have we hit the end?
        //

        if (SourceLength == 0)
        {
            UnicodeChar = UNICODE_NULL;
            CharToSkip = 1;
        }
        else
        {
            //
            // Nope.  Peek briefly to see if we hit the query string
            //

            if (UrlPart == UrlPart_AbsPath  &&  pChar[0] == QUESTION_MARK)
            {
                ASSERT(pQueryString == NULL);

                //
                // remember its location
                //

                pQueryString = pDest;

                //
                // let it fall through ONCE to the canonical
                // in order to handle a trailing "/.." like
                // "http://foobar:80/foo/bar/..?v=1&v2"
                //

                TestSegment = TRUE;
                UnicodeChar = QUESTION_MARK;
                CharToSkip  = 1;

                //
                // now we are cleaning the query string
                //

                UrlPart = UrlPart_QueryString;

                UlTraceVerbose(PARSER, ("QueryString @ %p\n", pQueryString));

                //
                // cannot use fast path for PopChar anymore
                //

                pFastPopChar = DummyPopChars;

                pfnPopChar = HttppPopCharQueryString;
            }
            else
            {
                ULONG NextUnicodeChar = pFastPopChar[*pChar];

                //
                // Grab the next character. Try to be fast for the
                // normal character case. Otherwise call PopChar.
                //

                if (NextUnicodeChar == 0)
                {
                    Status = (*pfnPopChar)(
                                    pChar,
                                    SourceLength,
                                    pCfg->PercentUAllowed,
                                    pCfg->AllowRestrictedChars,
                                    &UnicodeChar,
                                    &CharToSkip
                                    );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;
                }
                else
                {
#if DBG
                    Status = (*pfnPopChar)(
                                    pChar,
                                    SourceLength,
                                    pCfg->PercentUAllowed,
                                    pCfg->AllowRestrictedChars,
                                    &UnicodeChar,
                                    &CharToSkip
                                    );

                    ASSERT(NT_SUCCESS(Status));
                    ASSERT(UnicodeChar == NextUnicodeChar);
                    ASSERT(CharToSkip == 1);
#endif // DBG
                    UnicodeChar = (WCHAR) NextUnicodeChar;
                    CharToSkip = 1;
                }
            }
        }

        if (!MakeCanonical)
        {
            UrlToken = (UnicodeChar == UNICODE_NULL)
                            ? URL_TOKEN_EOS
                            : URL_TOKEN_OTHER;
            TestSegment = FALSE;
        }
        else
        {
            //
            // now use the state machine to make it canonical.
            //

            //
            // did we just hit the query string?  this will only happen once
            // that we take this branch after hitting it, as we stop
            // processing after hitting it.
            //

            if (UrlPart == UrlPart_QueryString)
            {
                //
                // treat this just like we hit a NULL, EOS.
                //

                ASSERT(QUESTION_MARK == UnicodeChar);

                UrlToken = URL_TOKEN_EOS;
                TestSegment = TRUE;
            }
            else
            {
                //
                // otherwise based the new state off of the char we
                // just popped.
                //

                switch (UnicodeChar)
                {
                case UNICODE_NULL:
                    UrlToken = URL_TOKEN_EOS;
                    TestSegment = TRUE;
                    break;

                case DOT:
                    UrlToken = URL_TOKEN_DOT;
                    TestSegment = FALSE;
                    break;

                case FORWARD_SLASH:
                    UrlToken = URL_TOKEN_SLASH;
                    TestSegment = TRUE;
                    break;

                default:
                    UrlToken = URL_TOKEN_OTHER;
                    TestSegment = FALSE;
                    break;
                }
            }
        }

        Action = ActionFromStateAndToken[UrlState][UrlToken];

        IF_DEBUG2BOTH(PARSER, VERBOSE)
        {
            ULONG   i;
            UCHAR   HexBuff[5*12 + 10];
            PUCHAR  p = HexBuff;
            UCHAR   Byte;

            ASSERT(CharToSkip <= 4 * STRLEN_LIT("%NN"));

            // Generate something like
            // "[25 65 32 25 38 30 25 39 35] '%e2%80%95'"

            *p++ = '[';

            for (i = 0;  i < CharToSkip;  ++i)
            {
                const static char hexArray[] = "0123456789ABCDEF";

                Byte = pChar[i];
                *p++ = hexArray[Byte >> 4];
                *p++ = hexArray[Byte & 0xf];
                *p++ = ' ';
            }
            
            p[-1] = ']'; // overwrite last ' '
            *p++ = ' ';
            *p++ = '\'';

            for (i = 0;  i < CharToSkip;  ++i)
            {
                Byte = pChar[i];
                *p++ = (IS_HTTP_PRINT(Byte) ? Byte : '?');
            }

            *p++ = '\'';
            *p++ = '\0';

            ASSERT(DIFF(p - HexBuff) <= DIMENSION(HexBuff));
            
            UlTrace(PARSER,
                    ("http!HttppCleanAndCopyUrlByType(%s): "
                     "(%lu) %s -> U+%04lX '%c': "
                     "[%s][%s] -> %s, %s%s\n",
                     HttppUrlEncodingToString(UrlEncoding),
                     CharToSkip, HexBuff,
                     UnicodeChar,
                     IS_ANSI(UnicodeChar) && IS_HTTP_PRINT(UnicodeChar)
                        ? (UCHAR) UnicodeChar : '?',
                     HttppUrlStateToString(UrlState),
                     HttppUrlTokenToString(UrlToken),
                     HttppUrlStateToString(
                         StateFromStateAndToken[UrlState][UrlToken]),
                     HttppUrlActionToString(Action),
                     TestSegment ? ", TestSegment" : ""
                    ));

        } // IF_DEBUG2BOTH(PARSER, VERBOSE)

        //
        // Segment length and segment count checks
        //

        if (TestSegment)
        {
            ULONG SegmentLength = DIFF(pDest - pSegment);

            ASSERT(pSegment <= pDest);

            UlTraceVerbose(PARSER,
                            ("http!HttppCleanAndCopyUrlByType: "
                             "Segment[%lu] %p (%lu) = '%.*ls'\n",
                             SegmentCount, pSegment, SegmentLength,
                             SegmentLength, pSegment
                            ));

            // Reject if segment too long
            if (SegmentLength > pCfg->UrlSegmentMaxLength + WCSLEN_LIT(L"/"))
            {
                UlTraceError(PARSER, (
                            "http!HttppCleanAndCopyUrlByType: "
                            "Segment too long: %lu\n",
                            SegmentLength
                            ));

                RETURN(STATUS_INVALID_DEVICE_REQUEST);
            }

            pSegment = pDest;

            // Reject if too many path segments

            if (Action != ACTION_NOTHING)
            {
                if (pSegment == pDestination)
                {
                    SegmentCount = 0;
                }
                else if (++SegmentCount > pCfg->UrlSegmentMaxCount)
                {
                    UlTraceError(PARSER, (
                                "http!HttppCleanAndCopyUrlByType: "
                                "Too many segments: %lu\n",
                                SegmentCount
                                ));

                    RETURN(STATUS_INVALID_DEVICE_REQUEST);
                }
            }
        }

        //
        //  Perform the action associated with the state.
        //

        switch (Action)
        {
        case ACTION_EMIT_DOT_DOT_CH:

            EMIT_LITERAL_CHAR(DOT, pDest, BytesCopied);

            // fall through

        case ACTION_EMIT_DOT_CH:

            EMIT_LITERAL_CHAR(DOT, pDest, BytesCopied);

            // fall through

        case ACTION_EMIT_CH:


            EMIT_CHAR(
                UnicodeChar,
                pDest,
                BytesCopied,
                Status,
                pCfg->AllowRestrictedChars
                );

            // fall through

        case ACTION_NOTHING:
            break;

        case ACTION_BACKUP:

            //
            // pDest currently points 1 past the last '/'.  backup over it and
            // find the preceding '/', set pDest to 1 past that one.
            //

            //
            // backup to the '/'
            //

            pDest       -= 1;
            BytesCopied -= sizeof(WCHAR);

            ASSERT(pDest[0] == FORWARD_SLASH);

            //
            // are we at the start of the string?  that's bad, can't go back!
            //

            if (pDest == pDestination)
            {
                ASSERT(BytesCopied == 0);

                UlTraceError(PARSER, (
                            "http!HttppCleanAndCopyUrl: "
                            "Can't back up for \"/../\"\n"
                            ));

                Status = STATUS_OBJECT_PATH_INVALID;
                goto end;
            }

            //
            // back up over the '/'
            //

            pDest       -= 1;
            BytesCopied -= sizeof(WCHAR);

            ASSERT(pDest > pDestination);

            //
            // now find the previous slash
            //

            while (pDest > pDestination  &&  pDest[0] != FORWARD_SLASH)
            {
                pDest       -= 1;
                BytesCopied -= sizeof(WCHAR);
            }

            //
            // Adjust segment trackers downwards
            //

            pSegment = pDest;

            if (pSegment == pDestination)
                SegmentCount = 0;
            else
                --SegmentCount;

            //
            // we already have a slash, so don't have to store one.
            //

            ASSERT(pDest[0] == FORWARD_SLASH);

            //
            // simply skip it, as if we had emitted it just now
            //

            pDest       += 1;
            BytesCopied += sizeof(WCHAR);

            break;

        default:
            ASSERT(!"http!HttppCleanAndCopyUrl: "
                    "Invalid action code in state table!");
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        //
        // Just hit the query string ?
        //

        if (MakeCanonical && UrlPart == UrlPart_QueryString)
        {
            //
            // Stop canonical processing
            //

            MakeCanonical = FALSE;

            //
            // Need to emit the '?', it wasn't emitted above
            //

            ASSERT(ActionFromStateAndToken[UrlState][UrlToken]
                    != ACTION_EMIT_CH);

            //
            // remember its location (in case we backed up)
            //
            
            pQueryString = pDest;

            EMIT_LITERAL_CHAR(QUESTION_MARK, pDest, BytesCopied);

            // reset
            UrlToken = URL_TOKEN_OTHER;
            UrlState = URL_STATE_START;
        }

        // update the URL state
        UrlState = StateFromStateAndToken[UrlState][UrlToken];

        ASSERT(URL_STATE_ERROR != UrlState);
    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;
    *pBytesCopied = BytesCopied;

    if (BytesCopied > pCfg->UrlMaxLength * sizeof(WCHAR))
    {
        UlTraceError(PARSER, (
                    "http!HttppCleanAndCopyUrlByType: "
                    "URL too long: %lu\n",
                    BytesCopied
                    ));

        RETURN(STATUS_INVALID_DEVICE_REQUEST);
    }

    if (ppQueryString != NULL)
    {
        *ppQueryString = pQueryString;
    }

    UlTraceVerbose(PARSER,
                    ("http!HttppCleanAndCopyUrlByType: "
                     "(%lu) '%.*s' -> (%lu) '%.*ls', %squerystring\n",
                     OriginalSourceLength,
                     OriginalSourceLength, pSource,
                     BytesCopied/sizeof(WCHAR),
                     BytesCopied/sizeof(WCHAR), pDestination,
                     pQueryString != NULL ? "" : "no "
                    ));

    Status = STATUS_SUCCESS;


end:
    return Status;

}   // HttppCleanAndCopyUrlByType



/*++

Routine Description:

    A utility routine to find a Url token. We take an input pointer, skip any
    preceding LWS, then scan the token until we find either LWS or a CRLF
    pair. We also mark the request to have a "Clean" Url

Arguments:

    pBuffer         - Buffer to search for token.
    BufferLength    - Length of data pointed to by pBuffer.
    ppTokenStart    - Where to return the start of the token, if we locate
                      its delimiter.
    pTokenLength    - Where to return the length of the token.
    pRawUrlClean    - where to return cleanliness of URL

Return Value:

    STATUS_SUCCESS if no parsing errors in the URL.
    We also return, in *ppTokenStart, a pointer to the token we found,
    or NULL if we don't find a whitespace-delimited token.
    pRawUrlClean flag may be set.

--*/
NTSTATUS
HttpFindUrlToken(
    IN  PURL_C14N_CONFIG    pCfg,
    IN  PCUCHAR             pBuffer,
    IN  ULONG               BufferLength,
    OUT PUCHAR*             ppTokenStart,
    OUT PULONG              pTokenLength,
    OUT PBOOLEAN            pRawUrlClean
    )
{
    PCUCHAR pTokenStart;
    PCUCHAR pSegment;
    UCHAR   CurrentChar;
    UCHAR   PreviousChar;
    ULONG   SegmentCount = 0;
    ULONG   TokenLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(NULL != pBuffer);
    ASSERT(NULL != ppTokenStart);
    ASSERT(NULL != pTokenLength);
    ASSERT(NULL != pRawUrlClean);

    //
    // Assume Clean RawUrl
    //

    *pRawUrlClean = TRUE;
    *ppTokenStart = NULL;
    *pTokenLength = 0;

    //
    // First, skip any preceding LWS.
    //

    while (BufferLength > 0 && IS_HTTP_LWS(*pBuffer))
    {
        pBuffer++;
        BufferLength--;
    }

    // If we stopped because we ran out of buffer, bail.
    if (BufferLength == 0)
    {
        return STATUS_SUCCESS;
    }

    pTokenStart  = pBuffer;
    PreviousChar = ANSI_NULL;

    // This will usually point to a '/', but it won't if this is an AbsURI.
    // It doesn't really matter, since only a few borderline cases will
    // be marked as dirty that might not otherwise be.
    pSegment = pBuffer;

    // Now skip over the token, until we see either LWS or a CR or LF.

    while ( BufferLength != 0 )
    {
        CurrentChar = *pBuffer;

        // must check for WS [ \t\r\n] first, since \t, \r, & \n are CTL chars!
        if ( IS_HTTP_WS_TOKEN(CurrentChar) )
        {
            break;
        }

        if ( IS_HTTP_CTL(CurrentChar) )
        {
            *pRawUrlClean = FALSE;
            *ppTokenStart = NULL;

            UlTraceError(PARSER, (
                    "http!HttpFindUrlToken: "
                    "Found control char: %02X\n",
                    CurrentChar
                    ));

            RETURN(STATUS_INVALID_DEVICE_REQUEST);
        }

        //
        // URL is NOT clean if it contains any of the following patterns
        //
        // a. back slash                                        "\"
        // b. dot, forward slash | forward slash, forward slash "./" | "//"
        // c. forward slash, dot | dot, dot                     "/." | ".."
        // d. question mark (querystring)                       "?"
        // e. percent (hex escape)                              "%"
        // f. raw bytes with high bit set, >= 0x80
        //
        // These are conservative estimates of "Clean"; some clean URLs may not
        // be marked as clean. For such URLs, we'll skip the fast path but at
        // no loss of functionality.
        //

        if ( IS_URL_DIRTY(CurrentChar) )
        {
            // Only do the checks if it's still clean
            if (*pRawUrlClean)
            {
                if (CurrentChar == FORWARD_SLASH || CurrentChar == DOT)
                {
                    if (PreviousChar == FORWARD_SLASH || PreviousChar == DOT)
                    {
                        *pRawUrlClean = FALSE;
                    }
                }
                else
                {
                    *pRawUrlClean = FALSE;
                }
            }

            if (CurrentChar == FORWARD_SLASH)
            {
                ULONG SegmentLength = DIFF(pBuffer - pSegment);

                // If the segment contains %-hex-escaped chars, it may become
                // acceptably short after PopChar() processing. Let
                // HttppCleanAndCopyUrlByType() figure it out.

                if (SegmentLength > pCfg->UrlSegmentMaxLength)
                    *pRawUrlClean = FALSE;

                pSegment = pBuffer;

                // If this is an AbsURI, instead of an AbsPath, the
                // segment count will be higher, because of the two slashes
                // before the hostname. Also, "/../", "/./", and "//"
                // minimization will reduce the final count of segments.
                // Again, let HttppCleanAndCopyUrlByType() figure it out. 

                if (++SegmentCount > pCfg->UrlSegmentMaxCount)
                    *pRawUrlClean = FALSE;
            }
        }

        PreviousChar = CurrentChar;
        pBuffer++;
        BufferLength--;
    }

    // See why we stopped.
    if (0 == BufferLength)
    {
        *pRawUrlClean = FALSE;

        // Ran out of buffer before end of token.
        return STATUS_SUCCESS;
    }

    ASSERT(IS_HTTP_WS_TOKEN(*pBuffer));

    TokenLength = DIFF(pBuffer - pTokenStart);

    if (0 == TokenLength)
    {
        UlTraceError(PARSER, ("http!HttpFindUrlToken: Found empty token\n"));

        RETURN(STATUS_INVALID_DEVICE_REQUEST);
    }

    // Check the final segment
    if (DIFF(pBuffer - pSegment) > pCfg->UrlSegmentMaxLength)
        *pRawUrlClean = FALSE;

    if (++SegmentCount > pCfg->UrlSegmentMaxCount)
        *pRawUrlClean = FALSE;

    if (TokenLength > pCfg->UrlMaxLength)
        *pRawUrlClean = FALSE;

    // Success! Set the token length and return the start of the token.
    *pTokenLength = TokenLength;
    *ppTokenStart = (PUCHAR) pTokenStart;

    return STATUS_SUCCESS;

}   // HttpFindUrlToken



/*++

Routine Description:

    Parse an IPv6 address from a Unicode buffer. Must be delimited by [].
    May contain a scope ID.

Arguments:

    pBuffer         - Buffer to parse. Must point to '['.
    BufferLength    - Length of data pointed to by pBuffer.
    ScopeIdAllowed  - if TRUE, an optional scope ID may be present
    pSockAddr6      - Where to return the parsed IPv6 address
    ppEnd           - On success, points to character after ']'

Return Value:

    STATUS_SUCCESS if no parsing errors in the IPv6 address.

--*/
NTSTATUS
HttppParseIPv6Address(
    IN  PCWSTR          pBuffer,
    IN  ULONG           BufferLength,
    IN  BOOLEAN         ScopeIdAllowed,
    OUT PSOCKADDR_IN6   pSockAddr6,
    OUT PCWSTR*         ppEnd
    )
{
    NTSTATUS    Status;
    PCWSTR      pEnd = pBuffer + BufferLength;
    PCWSTR      pChar;
    PWSTR       pTerminator;
    ULONG       ScopeTemp;

    ASSERT(NULL != pBuffer);
    ASSERT(0 < BufferLength);
    ASSERT(NULL != pSockAddr6);
    ASSERT(NULL != ppEnd);

    RtlZeroMemory(pSockAddr6, sizeof(*pSockAddr6));
    *ppEnd = NULL;

    pSockAddr6->sin6_family = TDI_ADDRESS_TYPE_IP6;

    // Caller guarantees this
    ASSERT(L'[' == *pBuffer);

    // Empty brackets?
    if (BufferLength < WCSLEN_LIT(L"[0]")  ||  L']' == pBuffer[1])
    {
        UlTraceError(PARSER,
                    ("http!HttppParseIPv6Address: IPv6 address too short\n"
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    for (pChar = pBuffer + WCSLEN_LIT(L"[");  pChar < pEnd;  ++pChar)
    {
        if (IS_ASCII(*pChar))
        {
            if (L']' == *pChar  ||  L'%' == *pChar)
                break;

            // Dots are allowed because the last 32 bits may be represented
            // in IPv4 dotted-octet notation
            if (IS_HTTP_HEX(*pChar)  ||  L':' == *pChar  ||  L'.' == *pChar)
                continue;
        }

        UlTraceError(PARSER,
                    ("http!HttppParseIPv6Address: "
                    "Invalid char in IPv6 address, U+%04X '%c', "
                    "after %lu chars, '%.*ls'\n",
                    *pChar,
                    IS_ANSI(*pChar) && IS_HTTP_PRINT(*pChar) ? *pChar : '?',
                    DIFF(pChar - pBuffer),
                    DIFF(pChar - pBuffer),
                    pBuffer
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    if (pChar == pEnd)
    {
        UlTraceError(PARSER,
                    ("http!HttppParseIPv6Address: No ']' for IPv6 address\n"
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(pChar < pEnd);
    ASSERT(L']' == *pChar  ||  L'%' == *pChar);

    // Let the RTL routine do the hard work of parsing IPv6 addrs
    Status = RtlIpv6StringToAddressW(
                pBuffer + WCSLEN_LIT(L"["),
                &pTerminator,
                &pSockAddr6->sin6_addr
                );

    if (! NT_SUCCESS(Status))
    {
        UlTraceError(PARSER,
                    ("http!HttppParseIPv6Address: "
                    "Invalid IPv6 address, %s\n",
                    HttpStatusToString(Status)
                    ));

        RETURN(Status);
    }

    if (pTerminator != pChar)
    {
        UlTraceError(PARSER,
                    ("http!HttppParseIPv6Address: "
                    "Invalid IPv6 terminator, U+%04X, '%c'\n",
                    *pTerminator,
                    IS_ANSI(*pTerminator) && IS_HTTP_PRINT(*pTerminator)
                        ? *pTerminator
                        : '?'
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Is a scopeid present?

    if (L'%' != *pChar)
    {
        ASSERT(L']' == *pChar);
        pSockAddr6->sin6_scope_id = 0;
    }
    else
    {
        PCWSTR pScopeEnd;

        // Skip the '%' denoting a scope ID
        pChar += WCSLEN_LIT(L"%");

        if (!ScopeIdAllowed)
        {
            UlTraceError(PARSER,
                        ("http!HttppParseIPv6Address: No scope ID allowed\n"
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (pChar == pEnd)
        {
            UlTraceError(PARSER,
                        ("http!HttppParseIPv6Address: "
                         "No IPv6 scope ID after '%%'\n"
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        pScopeEnd = pChar;

        do
        {
            if (*pScopeEnd < L'0'  ||  *pScopeEnd > L'9')
            {
                UlTraceError(PARSER,
                            ("http!HttppParseIPv6Address: "
                            "Invalid digit in IPv6 scope ID, "
                            "U+%04X, '%c'\n",
                            *pScopeEnd,
                            IS_ANSI(*pScopeEnd) && IS_HTTP_PRINT(*pScopeEnd)
                                ? *pScopeEnd
                                : '?'
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }
        } while (++pScopeEnd < pEnd  &&  L']' != *pScopeEnd);

        ASSERT(pScopeEnd > pChar);

        if (pScopeEnd == pEnd)
        {
            UlTraceError(PARSER,
                        ("http!HttppParseIPv6Address: "
                         "No ']' after IPv6 scope ID\n"
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        ASSERT(L']' == *pScopeEnd);

        Status = HttpWideStringToULong(
                    pChar,
                    pScopeEnd - pChar,
                    FALSE,          // no leading zeros permitted
                    10,
                    &pTerminator,
                    &ScopeTemp
                    );

        if (!NT_SUCCESS(Status))
        {
            UlTraceError(PARSER,
                        ("http!HttppParseIPv6Address: "
                        "Invalid scopeID, %s\n",
                        HttpStatusToString(Status)
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        // Scope ID does not get swapped to Network Byte Order
        *(UNALIGNED64 ULONG *)&pSockAddr6->sin6_scope_id = 
            ScopeTemp;

        ASSERT(pTerminator == pScopeEnd);

        pChar = pScopeEnd;

    } // '%' handling

    ASSERT(pChar < pEnd);
    ASSERT(L']' == *pChar);

    // Skip the terminating ']'
    pChar += WCSLEN_LIT(L"]");

    *ppEnd = pChar;

    RETURN(STATUS_SUCCESS);

} // HttppParseIPv6Address



/*++

Routine Description:

    Print an IPv4 or IPv6 address as Unicode.

Arguments:

    pSockAddr       - The IP address to print
    pBuffer         - Buffer to print to. Assumed to be large enough.

Return Value:

    Number of wide chars printed (the length)

--*/

ULONG
HttppPrintIpAddressW(
    IN  PSOCKADDR           pSockAddr,
    OUT PWSTR               pBuffer
    )
{
    PWSTR pResult = pBuffer;

    HTTP_FILL_BUFFER(pBuffer, MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN);

    if (TDI_ADDRESS_TYPE_IP == pSockAddr->sa_family)
    {
        PSOCKADDR_IN pAddr4 = (PSOCKADDR_IN) pSockAddr;

        pResult = RtlIpv4AddressToStringW(&pAddr4->sin_addr, pResult);
    }
    else if (TDI_ADDRESS_TYPE_IP6 == pSockAddr->sa_family)
    {
        PSOCKADDR_IN6 pAddr6 = (PSOCKADDR_IN6) pSockAddr;

        *pResult++ = L'[';
        pResult = RtlIpv6AddressToStringW(&pAddr6->sin6_addr, pResult);
        // CODEWORK: Handle scope ID
        *pResult++ = L']';
    }
    else
    {
        UlTraceError(PARSER,
                     ("http!HttppPrintIpAddressW(): invalid sa_family, %hd\n",
                      pSockAddr->sa_family
                     ));

        ASSERT(! "Invalid SockAddr Family");
    }

    *pResult = UNICODE_NULL;

    return DIFF(pResult - pBuffer);

} // HttppPrintIpAddressW



/***************************************************************************++

Routine Description:
    This checks to see if the URL is well-formed.
    A well-formed URL has a scheme ("http" or "https"),
    a valid hostname (including + and * wildcards, IPv4, and IPv6 literals),
    a port, and a well-formed abspath.

 *  Must check that the URL is well-formed and in canonical form; e.g.,
        - Disallow /../ and /./
        - Disallow invalid characters, including invalid Unicode surrogate
          pairs. The URL is already in Unicode, so it's not a question of
          using the IS_URL_TOKEN() macro.


Arguments:
    pCfg                - configuration parameters
    pUrl                - Unicode string containing URL (not assumed to be
                            zero-terminated)
    UrlLength           - length of pUrl, in WCHARs
    TrailingSlashReqd   - if TRUE, pUrl must end in '/'
    ForceRoutingIP      - if TRUE and the hostname is an IPv4 or IPv6 literal,
                            pParsedUrl->Normalized will be cleared, to force
                            HttpNormalizeParsedUrl() to rewrite the URL as
                            http://IP:port:IP/path
    pParsedUrl          - on successful exit, the components of the URL

Return Value:

    NTSTATUS

--***************************************************************************/

NTSTATUS
HttpParseUrl(
    IN  PURL_C14N_CONFIG    pCfg,
    IN  PCWSTR              pUrl,
    IN  ULONG               UrlLength,
    IN  BOOLEAN             TrailingSlashReqd,
    IN  BOOLEAN             ForceRoutingIP,
    OUT PHTTP_PARSED_URL    pParsedUrl
    )
{
    NTSTATUS            Status;
    ULONG               PreviousChar;
    ULONG               UnicodeChar;
    PCWSTR              pEnd = pUrl + UrlLength;
    PCWSTR              pHostname;
    PCWSTR              pChar;
    PCWSTR              pLabel;
    PCWSTR              pSlash;
    PCWSTR              pSegment;
    PWSTR               pTerminator;
    BOOLEAN             AlphaLabel;
    BOOLEAN             TestSegment;
    BOOLEAN             MoreChars;
    BOOLEAN             LastCharHack;
    ULONG               SegmentCount;
    URL_STATE           UrlState;
    URL_STATE_TOKEN     UrlToken;
    URL_ACTION          Action;
    WCHAR               IpAddr[MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN];
    ULONG               Length;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(NULL != pCfg);
    ASSERT(NULL != pUrl);
    ASSERT(0 < UrlLength  &&  UrlLength <= UNICODE_STRING_MAX_WCHAR_LEN);
    ASSERT(FALSE == TrailingSlashReqd  ||  TRUE == TrailingSlashReqd);
    ASSERT(FALSE == ForceRoutingIP  ||  TRUE == ForceRoutingIP);
    ASSERT(NULL != pParsedUrl);

    RtlZeroMemory(pParsedUrl, sizeof(*pParsedUrl));

    pParsedUrl->Signature           = HTTP_PARSED_URL_SIGNATURE;
    pParsedUrl->pFullUrl            = (PWSTR) pUrl;
    pParsedUrl->UrlLength           = (USHORT) UrlLength;
    pParsedUrl->Normalized          = TRUE;
    pParsedUrl->TrailingSlashReqd   = TrailingSlashReqd;

    // This is the shortest possible valid URL

    if (UrlLength < WCSLEN_LIT(L"http://*:1/"))
    {
        UlTraceError(PARSER,
                     ("http!HttpParseUrl: Url too short, %lu, %.*ls\n",
                      UrlLength, UrlLength, pUrl
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Check the scheme

    if (0 == wcsncmp(pUrl, L"http://",  WCSLEN_LIT(L"http://")))
    {
        pParsedUrl->Secure = FALSE;
        pHostname = pUrl + WCSLEN_LIT(L"http://");
    }
    else if (0 == wcsncmp(pUrl, L"https://", WCSLEN_LIT(L"https://")))
    {
        pParsedUrl->Secure = TRUE;
        pHostname = pUrl + WCSLEN_LIT(L"https://");
    }
    else
    {
        UlTraceError(PARSER,
                     ("http!HttpParseUrl: invalid scheme, %.*ls\n",
                      UrlLength, pUrl
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    pParsedUrl->pHostname = (PWSTR) pHostname;

    // Is a trailing slash present, if required?

    if (TrailingSlashReqd  &&  L'/' != pUrl[UrlLength - 1])
    {
        // No, then the URL will have to be rewritten
        pParsedUrl->Normalized = FALSE;
    }

    //
    // The hostname validation code below looks a lot like that in
    // HttpValidateHostname(). However, it is sufficiently different
    // (WCHAR vs. UCHAR, Host+IP, Scope IDs, compulsory ports, etc) that
    // it is not easy to combine them into one routine. If the hostname
    // validation code is changed here, it may be necessary to change it
    // in HttpValidateHostname() too, or vice versa.
    //

    // Check for weak (http://*:port/) and strong (http://+:port/) wildcards

    if (L'*' == *pHostname  ||  L'+' == *pHostname)
    {
        pParsedUrl->SiteType = (L'*' == *pHostname)
                                    ? HttpUrlSite_WeakWildcard
                                    : HttpUrlSite_StrongWildcard;

        pChar = pHostname + WCSLEN_LIT(L"*");

        ASSERT(pChar < pEnd);

        // The wildcard must be followed by ":port"
        if (L':' == *pChar)
            goto port;

        UlTraceError(PARSER,
                    ("http!HttpParseUrl: No port in '%c' wildcard address\n",
                     *pHostname
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Is this an IPv6 literal address, per RFC 2732?

    if (L'[' == *pHostname)
    {
        pParsedUrl->SiteType = HttpUrlSite_IP;

        Status = HttppParseIPv6Address(
                        pHostname,
                        DIFF(pEnd - pHostname),
                        TRUE,      // scope ID allowed
                        &pParsedUrl->SockAddr6,
                        &pChar);

        if (!NT_SUCCESS(Status))
        {
            UlTraceError(PARSER,
                        ("http!HttpParseUrl: "
                        "Invalid IPv6 address, %s\n",
                        HttpStatusToString(Status)
                        ));

            RETURN(Status);
        }

        ASSERT(TDI_ADDRESS_TYPE_IP6 == pParsedUrl->SockAddr.sa_family);
        ASSERT(pChar > pHostname);

        // There must be a port
        if (pChar == pEnd  ||  L':' != *pChar)
        {
            UlTraceError(PARSER,
                        ("http!HttpParseUrl: No port after IPv6 address\n"
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        //
        // There are so many legitimate ways to write an IPv6 literal
        // that we can't assume that a valid IPv6 literal is normalized.
        // Since we do string comparisons, we'll have to rewrite the URL
        // if the Normalized flag is not set.
        //

        Length = HttppPrintIpAddressW(&pParsedUrl->SockAddr, IpAddr);

        if (Length != DIFF_USHORT(pChar - pHostname)
                || 0 != _wcsnicmp(pHostname, IpAddr, Length))
        {
            pParsedUrl->Normalized = FALSE;
        }

        goto port;

    } // IPv6

    //
    // It must be a domain name or an IPv4 literal. We'll try to treat
    // it as a domain name first. If the labels turn out to be all-numeric,
    // we'll try decoding it as an IPv4 literal.
    //

    AlphaLabel = FALSE;
    pLabel     = pHostname;

    for (pChar = pHostname;  pChar < pEnd;  ++pChar)
    {
        if (L':' == *pChar)
        {
            if (pChar == pHostname)
            {
                UlTraceError(PARSER,
                            ("http!HttpParseUrl: empty hostname\n"
                             ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            // Have we seen any non-digits?
            if (AlphaLabel)
            {
                ASSERT(0 == pParsedUrl->SockAddr.sa_family);
                pParsedUrl->SiteType = HttpUrlSite_Name;
                goto port;
            }

            pParsedUrl->SiteType = HttpUrlSite_IP;
            pParsedUrl->SockAddr4.sin_family = TDI_ADDRESS_TYPE_IP;
            ASSERT(TDI_ADDRESS_TYPE_IP == pParsedUrl->SockAddr.sa_family);

            // Let's see if it's a valid IPv4 address
            Status = RtlIpv4StringToAddressW(
                        pHostname,
                        TRUE,           // strict => 4 dotted decimal octets
                        &pTerminator,
                        &pParsedUrl->SockAddr4.sin_addr
                        );

            if (!NT_SUCCESS(Status))
            {
                UlTraceError(PARSER,
                            ("http!HttpParseUrl: "
                            "Invalid IPv4 address, %s\n",
                            HttpStatusToString(Status)
                            ));

                RETURN(Status);
            }

            if (pTerminator != pChar)
            {
                ASSERT(pTerminator < pChar);

                UlTraceError(PARSER,
                            ("http!HttpParseUrl: "
                            "Invalid IPv4 address after %lu chars, "
                            "U+%04X, '%c'\n",
                            DIFF(pTerminator - pHostname),
                            *pTerminator,
                            IS_ANSI(*pTerminator) && IS_HTTP_PRINT(*pTerminator)
                                ? *pTerminator
                                : '?'
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            Length = HttppPrintIpAddressW(&pParsedUrl->SockAddr, IpAddr);

            if (Length != DIFF_USHORT(pChar - pHostname)
                    || 0 != _wcsnicmp(pHostname, IpAddr, Length))
            {
                pParsedUrl->Normalized = FALSE;
            }

            goto port;

        } // ':' handling

        if (L'.' == *pChar)
        {
            ULONG LabelLength = DIFF(pChar - pLabel);

            // There must be at least one char in the label
            if (0 == LabelLength)
            {
                UlTraceError(PARSER,
                            ("http!HttpParseUrl: empty label\n"
                             ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            // Label can't have more than 63 chars
            if (LabelLength > pCfg->MaxLabelLength)
            {
                UlTraceError(PARSER,
                            ("http!HttpParseUrl: overlong label, %lu\n",
                             LabelLength
                             ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            // Reset for the next label
            pLabel = pChar + WCSLEN_LIT(L".");

            continue;
        }

        //
        // All chars above 0xFF are considered valid
        //

        if (!IS_ANSI(*pChar)  ||  !IS_URL_ILLEGAL_COMPUTERNAME(*pChar))
        {
            if (!IS_ANSI(*pChar)  ||  !IS_HTTP_DIGIT(*pChar))
                AlphaLabel = TRUE;

            if (pChar > pLabel)
                continue;

            // The first char of a label cannot be a hyphen. (Underscore?)
            if (L'-' == *pChar)
            {
                UlTraceError(PARSER,
                            ("http!HttpParseUrl: '-' at beginning of label\n"
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            continue;
        }

        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                     "Invalid char in hostname, U+%04X '%c',"
                     " after %lu chars, '%.*s'\n",
                     *pChar,
                     IS_ANSI(*pChar) && IS_HTTP_PRINT(*pChar) ? *pChar : '?',
                     DIFF(pChar - pHostname),
                     DIFF(pChar - pHostname),
                     pHostname
                    ));

        RETURN(STATUS_INVALID_PARAMETER);

    } // hostname


    //
    // If we got here, we fell off the end of the buffer,
    // without finding a ':' for the port
    //

    ASSERT(pChar == pEnd);

    UlTraceError(PARSER, ("http!HttpParseUrl: No port\n"));

    RETURN(STATUS_INVALID_PARAMETER);


port:

    //
    // Parse the port number
    //

    ASSERT(pHostname < pChar  &&  pChar < pEnd);
    ASSERT(L':' == *pChar);

    pParsedUrl->HostnameLength  = DIFF_USHORT(pChar - pHostname);

    // First, check for overlong hostnames
    if (pParsedUrl->HostnameLength > pCfg->MaxHostnameLength)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: overlong hostname, %hu\n",
                     pParsedUrl->HostnameLength
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Skip the ':' denoting a port number
    pChar += WCSLEN_LIT(L":");

    if (pChar == pEnd)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: No port after ':'\n"
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Search for the '/' or second ':' that terminates the port number

    pSlash = pChar;
    pParsedUrl->pPort = (PWSTR) pSlash;

    do
    {
        if (*pSlash < L'0'  ||  *pSlash > L'9')
        {
            UlTraceError(PARSER,
                        ("http!HttpParseUrl: "
                        "Invalid digit in port, U+%04X, '%c'\n",
                        *pSlash,
                        IS_ANSI(*pSlash) && IS_HTTP_PRINT(*pSlash)
                            ? *pSlash
                            : '?'
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }
    } while (++pSlash < pEnd  &&  L'/' != *pSlash  &&  L':' != *pSlash);

    ASSERT(pSlash > pChar);

    pParsedUrl->PortLength = DIFF_USHORT(pSlash - pChar);

    if (pSlash == pEnd)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: No '/' (or second ':') after port\n"
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(L'/' == *pSlash  ||  L':' == *pSlash);

    Status = HttpWideStringToUShort(
                pChar,
                pParsedUrl->PortLength,
                FALSE,          // no leading zeros permitted
                10,
                &pTerminator,
                &pParsedUrl->PortNumber
                );

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                    "Invalid port number, %s\n",
                    HttpStatusToString(Status)
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    if (0 == pParsedUrl->PortNumber)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: Port must not be zero.\n"
                     ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(pTerminator == pSlash);

    pChar = pSlash;

    goto routing_IP;    // so /W4 won't complain about an unreferenced label


routing_IP:

    //
    // Is this a Host+IP site; i.e., is there a Routing IP address
    // after the port number?
    //

    if (L'/' == *pChar)
    {
        pParsedUrl->pRoutingIP      = NULL;
        pParsedUrl->RoutingIPLength = 0;
        ASSERT(0 == pParsedUrl->RoutingAddr.sa_family);

        //
        // If the hostname is an IP literal, but there is no routing IP
        // (i.e., http://IP:port/path), we must rewrite the URL as
        // http://IP:port:IP/path; i.e., explicitly use the hostname IP
        // as the routing IP.
        //

        if (ForceRoutingIP  &&  0 != pParsedUrl->SockAddr.sa_family)
        {
            ASSERT(TDI_ADDRESS_TYPE_IP == pParsedUrl->SockAddr.sa_family
                    ||  TDI_ADDRESS_TYPE_IP6 == pParsedUrl->SockAddr.sa_family);

            pParsedUrl->Normalized = FALSE;
        }

        goto parse_path;
    }

    ASSERT(L':' == *pChar);

    if (HttpUrlSite_WeakWildcard == pParsedUrl->SiteType
        ||  HttpUrlSite_StrongWildcard == pParsedUrl->SiteType)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                     "Can't have Routing IPs on Wildcard sites\n"
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    pChar += WCSLEN_LIT(L":");

    if (pChar == pEnd)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: No IP address after second ':'\n"
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    pParsedUrl->pRoutingIP = (PWSTR) pChar;

    ASSERT(HttpUrlSite_NamePlusIP != pParsedUrl->SiteType);
 
    if (HttpUrlSite_Name == pParsedUrl->SiteType)
    {
        pParsedUrl->SiteType = HttpUrlSite_NamePlusIP;
    }

    //
    // Is the Routing IP an IPv6 literal?
    //

    if (L'[' == *pChar)
    {
        if (TDI_ADDRESS_TYPE_IP == pParsedUrl->SockAddr.sa_family)
        {
            UlTraceError(PARSER,
                       ("http!HttpParseUrl: "
                        "Can't have http://IPv4:port:[IPv6]\n"
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        ASSERT(TDI_ADDRESS_TYPE_IP6 == pParsedUrl->SockAddr.sa_family
                ||  0 == pParsedUrl->SockAddr.sa_family);

        Status = HttppParseIPv6Address(
                        pChar,
                        DIFF(pEnd - pChar),
                        TRUE,      // scope ID allowed
                        &pParsedUrl->RoutingAddr6,
                        &pSlash);

        if (!NT_SUCCESS(Status))
        {
            UlTraceError(PARSER,
                        ("http!HttpParseUrl: "
                        "Invalid Host+IPv6 address, %s\n",
                        HttpStatusToString(Status)
                        ));

            RETURN(Status);
        }

        ASSERT(TDI_ADDRESS_TYPE_IP6 == pParsedUrl->RoutingAddr.sa_family);
        ASSERT(pSlash > pChar);

        // There must be a slash
        if (pSlash == pEnd  ||  L'/' != *pSlash)
        {
            UlTraceError(PARSER,
                        ("http!HttpParseUrl: '/' expected after Host+IPv6.\n"
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        // CODEWORK: Should we care if RoutingAddr6 != SockAddr6?

        pParsedUrl->RoutingIPLength = DIFF_USHORT(pSlash - pChar);

        Length = HttppPrintIpAddressW(&pParsedUrl->RoutingAddr, IpAddr);

        if (Length != pParsedUrl->RoutingIPLength
                || 0 != _wcsnicmp(pChar, IpAddr, Length))
        {
            pParsedUrl->Normalized = FALSE;
        }

        pChar = pSlash;

        goto parse_path;
    }


    //
    // No, then it must be an IPv4 literal
    //

    if (TDI_ADDRESS_TYPE_IP6 == pParsedUrl->SockAddr.sa_family)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: Can't have http://[IPv6]:port:IPv4\n"
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(TDI_ADDRESS_TYPE_IP == pParsedUrl->SockAddr.sa_family
            ||  0 == pParsedUrl->SockAddr.sa_family);

    // Search for the terminating '/'

    pSlash = pChar;

    do
    {
        if ((L'0' <= *pSlash  &&  *pSlash <= L'9')  ||  L'.' == *pSlash)
            continue;

        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                    "Invalid character in Host+IPv4, U+%04X, '%c'\n",
                    *pSlash,
                    IS_ANSI(*pSlash) && IS_HTTP_PRINT(*pSlash)
                        ? *pSlash
                        : '?'
                    ));

        RETURN(STATUS_INVALID_PARAMETER);

    } while (++pSlash < pEnd  &&  L'/' != *pSlash);

    ASSERT(pSlash > pChar);

    if (pSlash == pEnd)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: No '/' after Host+IPv4\n"
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    ASSERT(L'/' == *pSlash);

    Status = RtlIpv4StringToAddressW(
                pChar,
                TRUE,           // strict => 4 dotted decimal octets
                &pTerminator,
                &pParsedUrl->RoutingAddr4.sin_addr
                );

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                    "Invalid Host+IPv4 address, %s\n",
                    HttpStatusToString(Status)
                    ));

        RETURN(Status);
    }

    if (pTerminator != pSlash)
    {
        ASSERT(pTerminator < pSlash);

        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                    "Invalid Host+IPv4 address after %lu chars, "
                    "U+%04X, '%c'\n",
                    DIFF(pTerminator - pChar),
                    *pTerminator,
                    IS_ANSI(*pTerminator)  &&  IS_HTTP_PRINT(*pTerminator)
                        ? *pTerminator
                        : '?'
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    // CODEWORK: Should we care if RoutingAddr4 != SockAddr4

    pParsedUrl->RoutingIPLength         = DIFF_USHORT(pSlash - pChar);
    pParsedUrl->RoutingAddr4.sin_family = TDI_ADDRESS_TYPE_IP;

    Length = HttppPrintIpAddressW(&pParsedUrl->RoutingAddr, IpAddr);

    if (Length != pParsedUrl->RoutingIPLength
            || 0 != _wcsnicmp(pChar, IpAddr, Length))
    {
        pParsedUrl->Normalized = FALSE;
    }

    pChar = pSlash;



parse_path:

    //
    // Parse the abspath
    //

    ASSERT(pParsedUrl->pRoutingIP == NULL  ||  pParsedUrl->RoutingIPLength > 0);
    ASSERT(pHostname < pChar  &&  pChar < pEnd);
    ASSERT(L'/' == *pChar);

    pParsedUrl->pAbsPath        = (PWSTR) pChar;
    pParsedUrl->AbsPathLength   = DIFF_USHORT(pEnd - pChar);

    if (pParsedUrl->AbsPathLength > pCfg->UrlMaxLength)
    {
        UlTraceError(PARSER,
                    ("http!HttpParseUrl: "
                    "AbsPath is too long: %lu\n",
                    pParsedUrl->AbsPathLength
                    ));

        RETURN(STATUS_INVALID_PARAMETER);
    }

    UrlState        = URL_STATE_START;
    UrlToken        = URL_TOKEN_OTHER;
    Action          = ACTION_NOTHING;
    pSegment        = pChar;
    TestSegment     = FALSE;
    LastCharHack    = FALSE;
    MoreChars       = TRUE;
    PreviousChar    = UNICODE_NULL;
    UnicodeChar     = *pChar;
    SegmentCount    = 0;

    //
    // Loop through all the characters in pAbsPath, plus one or two
    // special ones at the end.
    //

    while (MoreChars)
    {
        switch (UnicodeChar)
        {
        case UNICODE_NULL:
            UrlToken = URL_TOKEN_EOS;
            TestSegment = TRUE;
            break;

        case DOT:
            UrlToken = URL_TOKEN_DOT;
            TestSegment = FALSE;
            break;

        case FORWARD_SLASH:
            UrlToken = URL_TOKEN_SLASH;
            TestSegment = TRUE;
            break;

        case PERCENT:           // no hex escapes
        case STAR:              // no wildcards
        case QUESTION_MARK:     // no wildcards or querystrings
        case BACK_SLASH:        // no C string escapes
            UlTraceError(PARSER,
                        ("http!HttpParseUrl: invalid '%c' char in path\n",
                         (UCHAR) UnicodeChar
                        ));
            RETURN(STATUS_INVALID_PARAMETER);

        default:
            UrlToken = URL_TOKEN_OTHER;
            TestSegment = FALSE;
            break;
        }

        UlTraceVerbose(PARSER,
                        ("http!HttpParseUrl: "
                         "[%lu] U+%04lX '%c' %p: [%s][%s] -> %s, %s\n",
                         DIFF(pChar - pParsedUrl->pAbsPath),
                         UnicodeChar,
                         IS_ANSI(UnicodeChar) && IS_HTTP_PRINT(UnicodeChar)
                            ? (UCHAR) UnicodeChar : '?',
                         pChar,
                         HttppUrlStateToString(UrlState),
                         HttppUrlTokenToString(UrlToken),
                         HttppUrlStateToString(
                             CanonStateFromStateAndToken[UrlState][UrlToken]),
                         TestSegment ? ", TestSegment" : ""
                        ));

        //
        // Reject control characters
        //

        if (!LastCharHack
                &&  !pCfg->AllowRestrictedChars
                &&  IS_ANSI(UnicodeChar)
                &&  IS_URL_INVALID(UnicodeChar))
        {
            UlTraceError(PARSER, (
                        "http!HttpParseUrl: "
                        "Invalid character, U+%04lX, in path.\n",
                        UnicodeChar
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        //
        // Check that (high-surrogate, low-surrogate) come in pairs
        //

        if (HIGH_SURROGATE_START <= PreviousChar
                && PreviousChar <= HIGH_SURROGATE_END)
        {
            if (UnicodeChar < LOW_SURROGATE_START
                    ||  UnicodeChar > LOW_SURROGATE_END)
            {
                UlTraceError(PARSER, (
                            "http!HttpParseUrl: "
                            "Illegal surrogate pair, U+%04lX, U+%04lX.\n",
                            PreviousChar, UnicodeChar
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }
        }
        else if (LOW_SURROGATE_START <= UnicodeChar
                    &&  UnicodeChar <= LOW_SURROGATE_END)
        {
            UlTraceError(PARSER, (
                        "http!HttpParseUrl: "
                        "Non-high surrogate, U+%04lX, "
                        "before low surrogate, U+%04lX.\n",
                        PreviousChar, UnicodeChar
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (URL_STATE_ERROR == CanonStateFromStateAndToken[UrlState][UrlToken])
        {
            UlTraceError(PARSER, (
                        "http!HttpParseUrl: "
                        "Error state from %s,%s in path, after U+%04lX.\n",
                         HttppUrlStateToString(UrlState),
                         HttppUrlTokenToString(UrlToken),
                        UnicodeChar
                        ));

            RETURN(STATUS_INVALID_PARAMETER);
        }

        UrlState = CanonStateFromStateAndToken[UrlState][UrlToken];

        //
        // Check segment limits
        //

        if (TestSegment)
        {
            ULONG SegmentLength = DIFF(pChar - pSegment);

            // The CanonStateFromStateAndToken checks should prevent
            // empty segments, among other things
            ASSERT(SegmentLength > 0  ||  pChar == pSegment);

            // Reject if segment too long
            if (SegmentLength > pCfg->UrlSegmentMaxLength + WCSLEN_LIT(L"/"))
            {
                UlTraceError(PARSER, (
                            "http!HttpParseUrl(): "
                            "Segment too long: %lu\n",
                            SegmentLength
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }

            pSegment = pChar;

            // Reject if too many path segments
            if (++SegmentCount > pCfg->UrlSegmentMaxCount)
            {
                UlTraceError(PARSER, (
                            "http!HttpParseUrl(): "
                            "Too many segments: %lu\n",
                            SegmentCount
                            ));

                RETURN(STATUS_INVALID_PARAMETER);
            }
        }

        //
        // Are there any more path characters?
        //

        PreviousChar = UnicodeChar;

        if (++pChar < pEnd)
        {
            UnicodeChar = *pChar;
        }
        else if (!LastCharHack)
        {
            // Want to make sure that the last segment is tested.
            // If there's no trailing slash, we'll enter here twice;
            // otherwise once

            if (TrailingSlashReqd  &&  FORWARD_SLASH != PreviousChar)
            {
                // First, fake a trailing slash, if needed
                UnicodeChar = FORWARD_SLASH;
            }
            else
            {
                // Second, always finish up with UNICODE_NULL
                UnicodeChar = UNICODE_NULL;
                LastCharHack = TRUE;
            }
        }
        else
        {
            // Terminate the loop
            MoreChars = FALSE;
        }

    } // while (MoreChars)

    RETURN(STATUS_SUCCESS);

} // HttpParseUrl



/***************************************************************************++

Routine Description:
    Some URLs parsed by HttpParseUrl() will not be considered normalized
    if they have IP literals, Routing IPs, or no trailing slash.
    This routine will build a fully normalized URL and (possibly) free the
    old one

Arguments:
    pParsedUrl          - On entry, points to a URL parsed by HttpParseUrl();
                            On successful exit, points to a normalized URL.
    pCfg                - configuration parameters
    ForceCopy           - if TRUE, will always make a new, normalized URL
    FreeOriginalUrl     - if FALSE, will never free the original URL.
                            The caller must manage the memory.
    ForceRoutingIP      - if TRUE and the hostname is an IPv4 or IPv6 literal,
                            the URL will be rewritten in the form
                            http://IP:port:IP/path
    PoolType            - PagedPool or NonPagedPool
    PoolTag             - Tag used to allocate pUrl

Return Value:

    NTSTATUS        - STATUS_SUCCESS or STATUS_NO_MEMORY

--***************************************************************************/
NTSTATUS
HttpNormalizeParsedUrl(
    IN OUT PHTTP_PARSED_URL pParsedUrl,
    IN     PURL_C14N_CONFIG pCfg,
    IN     BOOLEAN          ForceCopy,
    IN     BOOLEAN          FreeOriginalUrl,
    IN     BOOLEAN          ForceRoutingIP,
    IN     POOL_TYPE        PoolType,
    IN     ULONG            PoolTag
    )
{
    HTTP_PARSED_URL ParsedUrl   = *pParsedUrl;
    NTSTATUS        Status      = STATUS_SUCCESS;

    ASSERT(HTTP_PARSED_URL_SIGNATURE == ParsedUrl.Signature);

    if (ParsedUrl.Normalized  &&  !ForceCopy)
    {
        // nothing to do
    }
    else
    {
        PWSTR   pResult;
        WCHAR   HostAddrString[MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN];
        WCHAR   RoutingAddrString[MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN];
        ULONG   SchemeLength;
        ULONG   HostAddrLength;
        ULONG   HostnameLength;
        ULONG   RoutingAddrLength;
        ULONG   AbsPathLength;
        ULONG   Length;
        ULONG   TrailingSlashLength;
        PCWSTR  pUrl;

        pUrl = ParsedUrl.pFullUrl;

        SchemeLength = DIFF(ParsedUrl.pHostname - ParsedUrl.pFullUrl);

        // Calculate HostAddrLength and HostnameLength (mutually exclusive)
        if (0 != ParsedUrl.SockAddr.sa_family)
        {
            HostAddrLength = HttppPrintIpAddressW(
                                    &ParsedUrl.SockAddr,
                                    HostAddrString
                                    );
            HostnameLength = 0;
        }
        else
        {
            HostAddrLength = 0;
            HostAddrString[0] = UNICODE_NULL;
            HostnameLength = ParsedUrl.HostnameLength;
        }

        // Calculate RoutingAddrLength
        if (0 != ParsedUrl.RoutingAddr.sa_family)
        {
            RoutingAddrLength = WCSLEN_LIT(L":")
                                + HttppPrintIpAddressW(
                                        &ParsedUrl.RoutingAddr,
                                        RoutingAddrString
                                        );
        }
        else if (ForceRoutingIP  &&  0 != ParsedUrl.SockAddr.sa_family)
        {
            // We must rewrite http://IP:port/path as http://IP:port:IP/path
            RoutingAddrLength = WCSLEN_LIT(L":") + HostAddrLength;
            wcscpy(RoutingAddrString, HostAddrString);
        }
        else
        {
            RoutingAddrLength = 0;
            RoutingAddrString[0] = UNICODE_NULL;
        }

        AbsPathLength = ParsedUrl.AbsPathLength;

        ASSERT(AbsPathLength > 0);

        if (ParsedUrl.TrailingSlashReqd
                && FORWARD_SLASH != ParsedUrl.pAbsPath[AbsPathLength-1])
        {
            TrailingSlashLength = WCSLEN_LIT(L"/");
        }
        else
        {
            TrailingSlashLength = 0;
        }

        Length = SchemeLength
                    + HostAddrLength
                    + HostnameLength
                    + WCSLEN_LIT(L":") + ParsedUrl.PortLength
                    + RoutingAddrLength
                    + AbsPathLength
                    + TrailingSlashLength;

        pResult = (PWSTR) HTTPP_ALLOC(
                                PoolType,
                                (Length + 1) * sizeof(WCHAR),
                                PoolTag
                                );


        if (NULL == pResult)
        {
            Status = STATUS_NO_MEMORY;
            // Do not destroy the old URL. Let caller handle it.
        }
        else
        {
            PWSTR pDest = pResult;

#define WCSNCPY(pSrc, Length)                               \
    RtlCopyMemory(pDest, (pSrc), (Length) * sizeof(WCHAR)); \
    pDest += (Length)

#define WCSNCPY2(pField, Length)                            \
    WCSNCPY(ParsedUrl.pField, Length)

#define WCSNCPY_LIT(Lit)                                    \
    WCSNCPY(Lit, WCSLEN_LIT(Lit))

            WCSNCPY2(pFullUrl, SchemeLength);

            if (0 != HostnameLength)
            {
                ASSERT(0 == HostAddrLength);
                WCSNCPY2(pHostname, HostnameLength);
            }
            else
            {
                ASSERT(0 != HostAddrLength);
                WCSNCPY(HostAddrString, HostAddrLength);
            }

            WCSNCPY_LIT(L":");
            WCSNCPY2(pPort, ParsedUrl.PortLength);

            if (RoutingAddrLength > 0)
            {
                WCSNCPY_LIT(L":");
                WCSNCPY(
                    RoutingAddrString,
                    RoutingAddrLength - WCSLEN_LIT(L":")
                    );
            }

            WCSNCPY2(pAbsPath, AbsPathLength);

            if (TrailingSlashLength > 0)
            {
                WCSNCPY_LIT(L"/");
            }

            ASSERT(DIFF(pDest - pResult) == Length);

            *pDest = UNICODE_NULL;

            Status = HttpParseUrl(
                        pCfg,
                        pResult,
                        Length,
                        ParsedUrl.TrailingSlashReqd,
                        ForceRoutingIP,
                        &ParsedUrl
                        );

            ASSERT(STATUS_SUCCESS == Status);
            ASSERT(ParsedUrl.Normalized);

            if (FreeOriginalUrl)
                HTTPP_FREE((PVOID) pUrl, PoolTag);

            // Write the updated local copy back to the caller's HTTP_PARSED_URL
            *pParsedUrl = ParsedUrl;
        }
    }

    return Status;

} // HttpNormalizeParsedUrl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\misc.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Misc.c

Abstract:

    User-mode interface to HTTP.SYS: Miscellaneous functions.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//


/***************************************************************************++

Routine Description:

    Wait for a demand start notification.

Arguments:

    AppPoolHandle - Supplies a handle to a application pool.

    pBuffer - Unused, must be NULL.

    BufferLength - Unused, must be zero.

    pBytesReceived - Unused, must be NULL.

    pOverlapped - Supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpWaitForDemandStart(
    IN HANDLE AppPoolHandle,
    IN OUT PVOID pBuffer OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    // ASSERT(HttpIsInitialized(HTTP_INITIALIZE_SERVER));

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_WAIT_FOR_DEMAND_START,   // IoControlCode
                pBuffer,                            // pInputBuffer
                BufferLength,                       // InputBufferLength
                pBuffer,                            // pOutputBuffer
                BufferLength,                       // OutputBufferLength
                pBytesReceived                      // pBytesTransferred
                );

} // HttpWaitForDemandStart


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Given a set of Security Attributes, create a security descriptor.  If
    no Security Attributes given, create the best guess at a "default"
    Security Descriptor.

Arguments:

    pSA - Set of security attributes.

    ppSD - Security Descriptor created.  Caller must free using
        FreeSecurityDescriptor.

--***************************************************************************/
ULONG
CreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR * ppSD
    )
{
    ULONG                 result;
    ULONG                 daclSize;
    PSECURITY_DESCRIPTOR  pSecurityDescriptor = NULL;
    PACL                  pDacl = NULL;
    PSID                  pMySid;
    BOOL                  success;
    HANDLE                hProc;
    HANDLE                hToken = NULL;
    TOKEN_USER          * ptuInfo;
    TOKEN_DEFAULT_DACL  * ptddInfo;
    char                * rgcBuffer = NULL;
    DWORD                 cbLen = 0;


    //
    // Build default security descriptor from Process Token.
    //

    hProc = GetCurrentProcess(); // Gets pseudo-handle; no need to call CloseHandle

    success = OpenProcessToken(hProc, TOKEN_READ, &hToken);
    if (!success)
    {
        result = GetLastError();
        goto cleanup;
    }

    //
    // See if there's a default DACL we can just copy
    //
    success = GetTokenInformation(
                    hToken,
                    TokenDefaultDacl,
                    NULL,
                    0,
                    &cbLen
                    );

    // We know this will fail (we didn't provide a buffer)
    ASSERT(!success);
    
    result = GetLastError();
    if (ERROR_INSUFFICIENT_BUFFER != result)
        goto cleanup;

    if ( sizeof(TOKEN_DEFAULT_DACL) == cbLen )
    {
        //
        // No DACL present on token; must create DACL based on TokenUser
        //
        success = GetTokenInformation(
            hToken,
            TokenUser,
            NULL,
            0,
            &cbLen
            );

        // We know this will fail (we didn't provide a buffer)
        ASSERT(!success);
    
        result = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != result)
            goto cleanup;

        if ( 0 == cbLen )
        {
            goto cleanup;
        }

        rgcBuffer = ALLOC_MEM( cbLen );

        if ( rgcBuffer == NULL ) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        success = GetTokenInformation(
                      hToken,
                      TokenUser,
                      rgcBuffer,
                      cbLen,
                      &cbLen
                      );

        if (!success)
        {
            result = GetLastError();
            goto cleanup;
        }
            
        ptuInfo = (TOKEN_USER *) rgcBuffer;
        pMySid = ptuInfo->User.Sid;

        //
        // Verify that we've got a good SID
        //
        if( !IsValidSid(pMySid) )
        {
            HttpTrace( "Bogus SID\n" );
            result = ERROR_INVALID_SID;
            goto cleanup;
        }

        //
        // Alloc & init dacl entries
        //

        daclSize = sizeof(ACL) + 
                   sizeof(ACCESS_ALLOWED_ACE) +
                   GetLengthSid(pMySid);

        pDacl = ALLOC_MEM(daclSize);
        
        if ( pDacl == NULL ) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        success = InitializeAcl(pDacl, daclSize, ACL_REVISION);

        if (!success)
        {
            result = GetLastError();
            goto cleanup;
        }

        //
        // And add MySid ACE to DACL
        // NOTE: we need FILE_ALL_ACCESS because adding sub-items under
        // the current item requires write access, and removing requires
        // delete access.  This is enforced inside HTTP.SYS
        //

        success = AddAccessAllowedAce(
                    pDacl,
                    ACL_REVISION,
                    FILE_ALL_ACCESS,
                    pMySid
                    );
    
        if (!success)
        {
            result = GetLastError();
            goto cleanup;
        }

    } else
    {
        //
        // DACL present; Alloc space for DACL & fetch
        //

        ASSERT( 0 != cbLen );
        
        rgcBuffer = ALLOC_MEM( cbLen );

        if ( !rgcBuffer )
        {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        success = GetTokenInformation(
                      hToken,
                      TokenDefaultDacl,
                      rgcBuffer,
                      cbLen,
                      &cbLen
                      );

        if (!success)
        {
            result = GetLastError();
            goto cleanup;
        }

        ptddInfo = (TOKEN_DEFAULT_DACL *) rgcBuffer;
        daclSize = cbLen - sizeof(TOKEN_DEFAULT_DACL);

        pDacl = ALLOC_MEM( daclSize );
        if ( !pDacl )
        {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        CopyMemory( pDacl, ptddInfo->DefaultDacl, daclSize );

    }

    ASSERT( NULL != pDacl );

    //
    // allocate the security descriptor
    //
    pSecurityDescriptor = ALLOC_MEM( sizeof(SECURITY_DESCRIPTOR) );

    if (pSecurityDescriptor == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    success = InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );

    if (!success)
    {
        result = GetLastError();
        goto cleanup;
    }

    //
    // Set the DACL into the security descriptor
    //

    success = SetSecurityDescriptorDacl(
                    pSecurityDescriptor,
                    TRUE,                   // DaclPresent
                    pDacl,                  // pDacl
                    FALSE                   // DaclDefaulted
                    );

    if (!success)
    {
        result = GetLastError();
        HttpTrace1( "SetSecurityDescriptorDacl failed. result = %d\n", result );

        goto cleanup;
    }

    *ppSD = pSecurityDescriptor;

    result = NO_ERROR;

cleanup:

    if (result != NO_ERROR)
    {
        if (pSecurityDescriptor)
        {
            FREE_MEM(pSecurityDescriptor);
        }

        if (pDacl)
        {
            FREE_MEM(pDacl);
        }
    }

    if ( hToken )
    {
        CloseHandle( hToken );
    }

    if ( rgcBuffer )
    {
        FREE_MEM( rgcBuffer );
    }

    return result;

} // CreateSecurityDescriptor


/***************************************************************************++

Routine Description:

    Clean up a Security Descriptor created by InitSecurityDescriptor.

Arguments:

    pSD - Security Descriptor to clean up.

--***************************************************************************/
VOID
FreeSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    BOOL success;
    BOOL DaclPresent;
    PACL pDacl;
    BOOL DaclDefaulted;

    if (pSD)
    {
        success = GetSecurityDescriptorDacl(
                     pSD,
                     &DaclPresent,
                     &pDacl,
                     &DaclDefaulted
                     );

        if (success && DaclPresent && !DaclDefaulted) {
            FREE_MEM(pDacl);
        }

        FREE_MEM(pSD);
    }
    
} // FreeSecurityDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\api\httpio.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    HttpIo.c

Abstract:

    User-mode interface to HTTP.SYS: Server-side I/O handler.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Waits for an incoming HTTP request from HTTP.SYS.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier to receive a specific
        request. If this value is HTTP_NULL_ID, then receive any request.

    Flags - Currently unused and must be zero.

    pRequestBuffer - Supplies a pointer to the request buffer to be filled
        in by HTTP.SYS.

    RequestBufferLength - Supplies the length of pRequestBuffer.

    pBytesReturned - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data returned in the request buffer
        if this request completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure for the
        request.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpReceiveHttpRequest(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    OUT PHTTP_REQUEST pRequestBuffer,
    IN ULONG  RequestBufferLength,
    OUT PULONG  pBytesReturned OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    HTTP_RECEIVE_REQUEST_INFO ReceiveInfo;

#if DBG
    if (pRequestBuffer)
    {
        RtlFillMemory( pRequestBuffer, RequestBufferLength, (UCHAR)'\xc' );
    }
#endif

    ReceiveInfo.RequestId = RequestId;
    ReceiveInfo.Flags = Flags;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_RECEIVE_HTTP_REQUEST,    // IoControlCode
                &ReceiveInfo,                       // pInputBuffer
                sizeof(ReceiveInfo),                // InputBufferLength
                pRequestBuffer,                     // pOutputBuffer
                RequestBufferLength,                // OutputBufferLength
                pBytesReturned                      // pBytesTransferred
                );

} // HttpReceiveHttpRequest

/***************************************************************************++

Routine Description:

    Receives entity body for a request already read via ReceiveHttpRequest.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier to receive a specific
        request. If this value is HTTP_NULL_ID, then receive any request.

    pEntityBodyBuffer - Supplies a pointer to the request buffer to be filled
        in by HTTP.SYS.

    EntityBufferLength - Supplies the length of pEntityBuffer.

    pBytesReturned - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data returned in the request buffer
        if this request completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure for the
        request.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpReceiveRequestEntityBody(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    OUT PVOID pEntityBuffer,
    IN ULONG  EntityBufferLength,
    OUT PULONG  pBytesReturned,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    HTTP_RECEIVE_REQUEST_INFO ReceiveInfo;

#if DBG
    if (pEntityBuffer != NULL)
    {
        RtlFillMemory( pEntityBuffer, EntityBufferLength, (UCHAR)'\xc' );
    }
#endif

    ReceiveInfo.RequestId = RequestId;
    ReceiveInfo.Flags = Flags;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_RECEIVE_ENTITY_BODY,     // IoControlCode
                &ReceiveInfo,                       // pInputBuffer
                sizeof(ReceiveInfo),                // InputBufferLength
                pEntityBuffer,                      // pOutputBuffer
                EntityBufferLength,                 // OutputBufferLength
                pBytesReturned                      // pBytesTransferred
                );

} // HttpReceiveRequestEntityBody


/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier specifying the request
        the response is for.

    Flags - Supplies zero or more HTTP_SEND_RESPONSE_FLAG_* control flags.

    pHttpResponse - Supplies the HTTP response.

    pCachePolicy - Supplies caching policy for the response.

    pBytesSent - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data sent if this request
        completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSendHttpResponse(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PHTTP_RESPONSE pHttpResponse,
    IN PHTTP_CACHE_POLICY pCachePolicy OPTIONAL,
    OUT PULONG  pBytesSent OPTIONAL,
    OUT PHTTP_REQUEST pRequestBuffer OPTIONAL,
    IN ULONG RequestBufferLength OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL
    )
{
    HTTP_SEND_HTTP_RESPONSE_INFO responseInfo;

    //
    // Build the response structure.
    //

    RtlZeroMemory(&responseInfo, sizeof(responseInfo));

    responseInfo.pHttpResponse      = pHttpResponse;
    responseInfo.EntityChunkCount   = pHttpResponse->EntityChunkCount;
    responseInfo.pEntityChunks      = pHttpResponse->pEntityChunks;

    if (pCachePolicy != NULL)
    {
        responseInfo.CachePolicy    = *pCachePolicy;
    } else {
        responseInfo.CachePolicy.Policy = HttpCachePolicyNocache;
        responseInfo.CachePolicy.SecondsToLive = 0;
    }

    responseInfo.RequestId          = RequestId;
    responseInfo.Flags              = Flags;    
    responseInfo.pLogData           = pLogData;
    
    if (pRequestBuffer)
    {
        pRequestBuffer->RequestId   = HTTP_NULL_ID;
    }

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_SEND_HTTP_RESPONSE,      // IoControlCode
                &responseInfo,                      // pInputBuffer
                sizeof(responseInfo),               // InputBufferLength
                pRequestBuffer,                     // pOutputBuffer
                RequestBufferLength,                // OutputBufferLength
                pBytesSent                          // pBytesTransferred
                );

} // HttpSendHttpResponse



/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier specifying the request
        the response is for.

    Flags - Supplies zero or more HTTP_SEND_RESPONSE_FLAG_* control flags.

    pBytesSent - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data sent if this request
        completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSendResponseEntityBody(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN USHORT EntityChunkCount OPTIONAL,
    IN PHTTP_DATA_CHUNK pEntityChunks OPTIONAL,
    OUT PULONG  pBytesSent OPTIONAL,
    OUT PHTTP_REQUEST pRequestBuffer OPTIONAL,
    IN ULONG RequestBufferLength OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL
    )
{
    HTTP_SEND_HTTP_RESPONSE_INFO responseInfo;

    //
    // Build the response structure.
    //

    RtlZeroMemory(&responseInfo, sizeof(responseInfo));

    responseInfo.EntityChunkCount   = EntityChunkCount;
    responseInfo.pEntityChunks      = pEntityChunks;
    responseInfo.RequestId          = RequestId;
    responseInfo.Flags              = Flags;
    responseInfo.pLogData           = pLogData;

    if (pRequestBuffer)
    {
        pRequestBuffer->RequestId   = HTTP_NULL_ID;
    }

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_SEND_ENTITY_BODY,        // IoControlCode
                &responseInfo,                      // pInputBuffer
                sizeof(responseInfo),               // InputBufferLength
                pRequestBuffer,                     // pOutputBuffer
                RequestBufferLength,                // OutputBufferLength
                pBytesSent                          // pBytesTransferred
                );

} // HttpSendResponseEntityBody


/***************************************************************************++

Routine Description:

    Wait for the client to initiate a disconnect.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    ConnectionId - Supplies an opaque identifier specifying the connection.

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpWaitForDisconnect(
    IN HANDLE AppPoolHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    HTTP_WAIT_FOR_DISCONNECT_INFO waitInfo;

    //
    // Build the structure.
    //

    waitInfo.ConnectionId = ConnectionId;

    //
    // Make the request.
    //

    return HttpApiDeviceControl(
                AppPoolHandle,                      // FileHandle
                pOverlapped,                        // pOverlapped
                IOCTL_HTTP_WAIT_FOR_DISCONNECT,     // IoControlCode
                &waitInfo,                          // pInputBuffer
                sizeof(waitInfo),                   // InputBufferLength
                NULL,                               // pOutputBuffer
                0,                                  // OutputBufferLength
                NULL                                // pBytesTransferred
                );

} // HttpWaitForDisconnect


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\sources.inc ===
TARGETPATH=..\..\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES=$(INCLUDES);                       \
         ..\;                               \
         ..\..\inc;                         \
         ..\..\inc\$(O);                    \
         $(BASE_INC_PATH);                  \
         $(NET_INC_PATH); 

KERNELBASE=$(BASEDIR)
NTOS_INC_PATH=$(BASEDIR)\private\ntos\inc

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

MSC_WARNING_LEVEL=/W4

!if !$(FREEBUILD)
MSC_OPTIMIZATION=/Od
!endif

COMMON_SOURCES=     \
    ..\c14n.c       \
    ..\CmnMisc.c    \
    ..\Utf8.c       \

!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\utf8.c ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    Utf8.c

Abstract:

    UTF-8 manipulation routines

Author:

    George V. Reilly (GeorgeRe)     01-Apr-2002

Revision History:

--*/

#include "precomp.h"

#if defined(ALLOC_PRAGMA) && defined(KERNEL_PRIV)

#pragma alloc_text( INIT, HttpInitializeUtf8)
#pragma alloc_text( PAGE, HttpUnicodeToUTF8)
#pragma alloc_text( PAGE, HttpUTF8ToUnicode)
#pragma alloc_text( PAGE, HttpUcs4toUtf16)
#pragma alloc_text( PAGE, HttpUnicodeToUTF8Count)
#pragma alloc_text( PAGE, HttpUnicodeToUTF8Encode)
#pragma alloc_text( PAGE, HttpUtf8RawBytesToUnicode)

#endif // ALLOC_PRAGMA && KERNEL_PRIV

#if 0   // Non-Pageable Functions
NOT PAGEABLE -- 
#endif // Non-Pageable Functions



DECLSPEC_ALIGN(UL_CACHE_LINE)  
const UCHAR
Utf8OctetCount[256] =
{
    // singletons: 0x00 - 0x7F
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 0x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 1x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 2x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 3x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 4x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 5x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 6x
    1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   // 7x

    // UTF-8 trail bytes are not valid lead byte prefixes: 0x80 - 0xBF
    0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   // 8x
    0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   // 9x
    0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   // Ax
    0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   // Bx

    // two-byte prefixes: 0xC0 - 0xDF
    2, 2, 2, 2, 2, 2, 2, 2,   2, 2, 2, 2, 2, 2, 2, 2,   // Cx
    2, 2, 2, 2, 2, 2, 2, 2,   2, 2, 2, 2, 2, 2, 2, 2,   // Dx

    // three-byte prefixes: 0xE0 - 0xEF
    3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3,   // Ex

    // four-byte prefixes: 0xF0 - 0xF7
    4, 4, 4, 4, 4, 4, 4, 4,                             // Fx

    // invalid prefixes: 0xF8 - 0xFF
                              0, 0, 0, 0, 0, 0, 0, 0,   // Fx
};

const static char hexArray[] = "0123456789ABCDEF";


VOID
HttpInitializeUtf8(
    VOID
    )
{
#if DBG
    ULONG i;
    //
    // Validate Utf8OctetCount[]
    //

    for (i = 0;  i < 256;  ++i)
    {
        UCHAR OctetCount = UTF8_OCTET_COUNT(i);

        if (IS_UTF8_SINGLETON(i))
        {
            ASSERT(1 == OctetCount);
        }
        else if (IS_UTF8_1ST_BYTE_OF_2(i))
        {
            ASSERT(2 == OctetCount);
        }
        else if (IS_UTF8_1ST_BYTE_OF_3(i))
        {
            ASSERT(3 == OctetCount);
        }
        else if (IS_UTF8_1ST_BYTE_OF_4(i))
        {
            ASSERT(4 == OctetCount);
        }
        else
        {
            ASSERT(0 == OctetCount);
        }
    }
#endif // DBG
} // HttpInitializeUtf8



//
// Some Unicode to Utf8 conversion utilities taken and modified frm
// base\win32\winnls\utf.c. Use this until they expose the same functionality
// in kernel.
//

/***************************************************************************++

Routine Description:

    Maps a Unicode character string to its UTF-8 string counterpart

    Conversion continues until the source is finished or an error happens in
    either case it returns the number of UTF-8 characters written.

    If the supllied buffer is not big enough it returns 0.

--***************************************************************************/

ULONG
HttpUnicodeToUTF8(
    IN  PCWSTR  lpSrcStr,
    IN  LONG    cchSrc,
    OUT LPSTR   lpDestStr,
    IN  LONG    cchDest
    )
{
    LPCWSTR     lpWC  = lpSrcStr;
    LONG        cchU8 = 0;                // # of UTF8 chars generated
    ULONG       dwSurrogateChar;
    WCHAR       wchHighSurrogate = 0;
    BOOLEAN     bHandled;

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_TRAIL     | MIDDLE_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_TRAIL     | LOWER_6_BIT(wchHighSurrogate));
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 | (UCHAR)(dwSurrogateChar >> 18));             // 3 bits from 1st byte
                         lpDestStr[cchU8++] = (UTF8_TRAIL    | (UCHAR)((dwSurrogateChar >> 12) & 0x3f));    // 6 bits from 2nd byte
                         lpDestStr[cchU8++] = (UTF8_TRAIL    | (UCHAR)((dwSurrogateChar >> 6) & 0x3f));     // 6 bits from 3rd byte
                         lpDestStr[cchU8++] = (UTF8_TRAIL    | (UCHAR)(0x3f &dwSurrogateChar));             // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= UTF8_1_MAX)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_1ST_OF_2 | (*lpWC >> 6));
                        lpDestStr[cchU8++] = (UCHAR) (UTF8_TRAIL    | LOWER_6_BIT(*lpWC));
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = (UCHAR)(UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC));
                        lpDestStr[cchU8++] = (UCHAR)(UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC));
                        lpDestStr[cchU8++] = (UCHAR)(UTF8_TRAIL    | LOWER_6_BIT(*lpWC));
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = (UCHAR)(UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                lpDestStr[cchU8++] = (UCHAR)(UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                lpDestStr[cchU8++] = (UCHAR)(UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        return 0;
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return cchU8;

} // HttpUnicodeToUTF8


/***************************************************************************++

Routine Description:

    Maps a UTF-8 character string to its wide character string counterpart.

Return Value:

--***************************************************************************/
NTSTATUS
HttpUTF8ToUnicode(
    IN     LPCSTR lpSrcStr,
    IN     LONG   cchSrc,
       OUT LPWSTR lpDestStr,
    IN OUT PLONG  pcchDest,
    IN     ULONG  dwFlags
    )
{
    LONG        nTB = 0;              // # trail bytes to follow
    LONG        cchWC = 0;            // # of Unicode code points generated
    CONST BYTE* pUTF8 = (CONST BYTE*)lpSrcStr;
    LONG        dwSurrogateChar = 0;     // Full surrogate char
    BOOLEAN     bSurrogatePair = FALSE;  // Indicate we'r collecting a
                                         // surrogate pair
    BOOLEAN     bCheckInvalidBytes = (BOOLEAN)(dwFlags == 1);
    BYTE        UTF8;
    LONG        cchDest = *pcchDest;

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            nTB = bSurrogatePair = 0;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000) % 0x400 + LOW_SURROGATE_START);
                            }
                            else
                            {
                                // Error : Buffer too small
                                cchSrc++;
                                break;
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                        
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                if (bCheckInvalidBytes) 
                {
                    RETURN(STATUS_INVALID_PARAMETER);
                }
                // error - not expecting a trail byte. That is, there is a trailing byte without leading byte.
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                // error - A leading byte before the previous sequence is completed.
                if (bCheckInvalidBytes) 
                {
                    RETURN(STATUS_INVALID_PARAMETER);
                }            
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                // Put this character back so that we can start over another sequence.
                cchSrc++;
                pUTF8--;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // Check for non-shortest form.
                // 
                switch (nTB) {
                    case 1:
                        nTB = 0;
                        break;
                    case 2:
                        // Make sure that bit 8 ~ bit 11 is not all zero.
                        // 110XXXXx 10xxxxxx
                        if ((*pUTF8 & 0x1e) == 0)
                        {
                            nTB = 0;
                        }
                        break;
                    case 3:
                        // Look ahead to check for non-shortest form.
                        // 1110XXXX 10Xxxxxx 10xxxxxx
                        if (cchSrc >= 2)
                        {
                            if (((*pUTF8 & 0x0f) == 0) && (*(pUTF8 + 1) & 0x20) == 0)
                            {
                                nTB = 0;
                            }
                        }
                        break;
                    case 4:                    
                        //
                        // This is a surrogate unicode pair
                        //
                        if (cchSrc >= 3)
                        {
                            SHORT word = (((SHORT)*pUTF8) << 8) | *(pUTF8 + 1);
                            // Look ahead to check for non-shortest form.
                            // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx                        
                            // Check for the 5 bits are not all zero.
                            // 0x0730 == 00000111 11000000
                            if ((word & 0x0730) == 0) 
                            {
                                nTB = 0;
                            } else if ((word & 0x0400) == 0x0400)
                            {
                                // The 21st bit is 1.
                                // Make sure that the resulting Unicode is within the valid surrogate range.
                                // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point ragne
                                // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                // bit are all zero.
                                // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                // XXXXX can only be 10000.

                                // 0x0330 = 0000 0011 0011 0000
                                if ((word & 0x0330) != 0) 
                                {
                                    nTB = 0;
                                }  
                            }

                            if (nTB != 0)
                            { 
                                dwSurrogateChar = UTF8 >> nTB;
                                bSurrogatePair = TRUE;
                            }
                        }                        
                        break;
                    default:                    
                        // 
                        // If the bits is greater than 4, this is an invalid
                        // UTF8 lead byte.
                        //
                        nTB = 0;
                        break;
                }

                if (nTB != 0) 
                {
                    //
                    //  Store the value from the first byte and decrement
                    //  the number of bytes to follow.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(UTF8 >> nTB);
                    }
                    nTB--;
                } else 
                {
                    if (bCheckInvalidBytes) 
                    {
                        RETURN(STATUS_INVALID_PARAMETER);
                    }                 
                }
            }
        }
        pUTF8++;
    }

    if ((bCheckInvalidBytes && nTB != 0) || (cchWC == 0)) 
    {
        // About (cchWC == 0):
        // Because we now throw away non-shortest form, it is possible that we generate 0 chars.
        // In this case, we have to set error to ERROR_NO_UNICODE_TRANSLATION so that we conform
        // to the spec of MultiByteToWideChar.
        RETURN(STATUS_INVALID_PARAMETER);
    }
    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        RETURN(STATUS_BUFFER_TOO_SMALL);
    }


    //
    //  Return the number of Unicode characters written.
    //
    *pcchDest = cchWC;

    return STATUS_SUCCESS;

} // HttpUTF8ToUnicode



/***************************************************************************++

Routine Description:

    Split a UCS-4 character (32 bits)
    into 1 or 2 UTF-16 characters (16 bits each)

Arguments:

    UnicodeChar     - UCS-4 character
    pHighSurrogate  - First output character
    pLowSurrogate   - Second output character. Zero unless UnicodeChar > 0xFFFF

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttpUcs4toUtf16(
    IN  ULONG   UnicodeChar, 
    OUT PWCHAR  pHighSurrogate, 
    OUT PWCHAR  pLowSurrogate
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(NULL != pHighSurrogate);
    ASSERT(NULL != pLowSurrogate);

    if (UnicodeChar <= 0xFFFF)
    {
        *pHighSurrogate = (WCHAR) UnicodeChar;
        *pLowSurrogate  = 0;

        if (HIGH_SURROGATE_START <= UnicodeChar
                &&  UnicodeChar <= LOW_SURROGATE_END)
        {
            UlTraceError(PARSER, (
                        "http!HttpUcs4toUtf16(): "
                        "Illegal raw surrogate character, U+%04lX.\n",
                        UnicodeChar
                        ));

            Status = STATUS_INVALID_PARAMETER;
        }

        if ( IS_UNICODE_NONCHAR(UnicodeChar) )
        {
            UlTraceError(PARSER, (
                        "http!HttpUcs4toUtf16(): "
                        "Non-character code point, U+%04lX.\n",
                        UnicodeChar
                        ));

            Status = STATUS_INVALID_PARAMETER;
        }
    }
    else if (UnicodeChar <= UTF8_4_MAX)
    {
        if ( IS_UNICODE_NONCHAR(UnicodeChar) )
        {
            UlTraceError(PARSER, (
                        "http!HttpUcs4toUtf16(): "
                        "Non-character code point, U+%04lX.\n",
                        UnicodeChar
                        ));

            Status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            *pHighSurrogate
                = (WCHAR) (((UnicodeChar - 0x10000) >> 10)
                           + HIGH_SURROGATE_START);

            ASSERT(HIGH_SURROGATE_START <= *pHighSurrogate
                    &&  *pHighSurrogate <= HIGH_SURROGATE_END);

            *pLowSurrogate
                = (WCHAR) (((UnicodeChar - 0x10000) & ((1 << 10) - 1))
                           + LOW_SURROGATE_START);

            ASSERT(LOW_SURROGATE_START <= *pLowSurrogate
                    &&  *pLowSurrogate <= LOW_SURROGATE_END);
        }
    }
    else
    {
        UlTraceError(PARSER, (
                    "http!HttpUcs4toUtf16(): "
                    "Illegal large character, 0x%08lX.\n",
                    UnicodeChar
                    ));

        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;

} // HttpUcs4toUtf16



/***************************************************************************++

Routine Description:

    Count number of BYTEs required for UTF-8 conversion of UNICODE string.
    Count is terminated after dwInLen characters

Arguments:

    pwszIn  - pointer to input wide-character string

    dwInLen - number of characters in pwszIn

    bEncode - TRUE if we are to hex encode characters >= 0x80

Return Value:

    ULONG   - number of BYTEs required for conversion

--***************************************************************************/
ULONG
HttpUnicodeToUTF8Count(
    IN LPCWSTR pwszIn,
    IN ULONG dwInLen,
    IN BOOLEAN bEncode
    )
{
    ULONG dwCount = 0;
    ULONG oneCharLen = bEncode ? 3 : 1;
    ULONG twoCharLen = 2 * oneCharLen;

    ASSERT(pwszIn != NULL);
    ASSERT(dwInLen != 0);

    //
    // N.B. code arranged to reduce number of jumps in loop to 1 (while)
    //

    do {

        ULONG wchar = *pwszIn++;

        dwCount += (wchar & 0xF800) ? oneCharLen : 0;
        dwCount += ((wchar & 0xFF80) ? 0xFFFFFFFF : 0) & (twoCharLen - 1);
        ++dwCount;
    } while (--dwInLen != 0);

    return dwCount;

} // HttpUnicodeToUTF8Count



/***************************************************************************++

Routine Description:

    Maps a Unicode character string to its UTF-8 string counterpart. This
    also hex encodes the string.

    Conversion continues until the source is finished or an error happens in 
    either case it returns the number of UTF-8 characters written.
    
    If the supllied buffer is not big enough it returns 0.

    Convert a string of UNICODE characters to UTF-8:

        0000000000000000..0000000001111111: 0xxxxxxx
        0000000010000000..0000011111111111: 110xxxxx 10xxxxxx
        0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx

Arguments:

    pwszIn      - pointer to input wide-character string

    dwInLen     - number of CHARACTERS in pwszIn INCLUDING terminating NUL

    pszOut      - pointer to output narrow-character buffer

    dwOutLen    - number of BYTEs in pszOut

    pdwOutLen   - actual number of BYTES written to the output pszOut

    bEncode     - TRUE if we are to hex encode characters >= 0x80

Return Value:

    ULONG
        Success - STATUS_SUCCESS

        Failure - STATUS_INSUFFICIENT_RESOURCES
                    Not enough space in pszOut to store results
    
--***************************************************************************/
NTSTATUS
HttpUnicodeToUTF8Encode(
    IN  LPCWSTR pwszIn,
    IN  ULONG   dwInLen,
    OUT PUCHAR  pszOut,
    IN  ULONG   dwOutLen,
    OUT PULONG  pdwOutLen,
    IN  BOOLEAN bEncode
    )
{
    PUCHAR pOutput = pszOut;
    ULONG pOutputLen = dwOutLen;
    UCHAR lead;
    int shift;

    ULONG outputSize = bEncode ? 3 : 1;

    ASSERT(pwszIn != NULL);
    ASSERT((int)dwInLen > 0);
    ASSERT(pszOut != NULL);
    ASSERT((int)dwOutLen > 0);

    while (dwInLen-- && dwOutLen) {

        ULONG wchar = *pwszIn++;
        UCHAR bchar;

        if (wchar <= 0x007F) {
            *pszOut++ = (UCHAR)(wchar);
            --dwOutLen;
            continue;
        }

        lead = ((wchar >= 0x0800) ? 0xE0 : 0xC0);
        shift = ((wchar >= 0x0800) ? 12 : 6);

        if ((int)(dwOutLen -= outputSize) < 0)
        {
            RETURN(STATUS_INSUFFICIENT_RESOURCES);
        }
        bchar = lead | (UCHAR)(wchar >> shift);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;

        if (wchar >= 0x0800) {
            if ((int)(dwOutLen -= outputSize) < 0)
            {
                RETURN(STATUS_INSUFFICIENT_RESOURCES);
            }
            bchar = 0x80 | (UCHAR)((wchar >> 6) & 0x003F);
            if (bEncode) {
                *pszOut++ = '%';
                *pszOut++ = hexArray[bchar >> 4];
                bchar = hexArray[bchar & 0x0F];
            }
            *pszOut++ = bchar;
        }
        if ((int)(dwOutLen -= outputSize) < 0)
        {
            RETURN(STATUS_INSUFFICIENT_RESOURCES);
        }
        bchar = 0x80 | (UCHAR)(wchar & 0x003F);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;
    }

    ASSERT(pszOut >= pOutput && pszOut <= pOutput + pOutputLen);
    UNREFERENCED_PARAMETER(pOutputLen);

    if (pdwOutLen)
        *pdwOutLen = (ULONG)(pszOut - pOutput);

    return STATUS_SUCCESS;

} // HttpUnicodeToUTF8Encode



/***************************************************************************++

Routine Description:

    Splice together the bits from a UTF-8 lead byte and 0-3 trail bytes
    into a Unicode character.

Arguments:

    pOctetArray     - Input buffer: Raw lead byte + raw trail bytes
    SourceLength    - Length of pOctetArray, in bytes
    pUnicodeChar    - decoded character
    pOctetsToSkip   - number of bytes consumed from pOctetArray

Return Value:

    STATUS_SUCCESS or STATUS_OBJECT_PATH_SYNTAX_BAD

--***************************************************************************/

NTSTATUS
HttpUtf8RawBytesToUnicode(
    IN  PCUCHAR pOctetArray,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pOctetsToSkip
    )
{
    ULONG i;
    ULONG UnicodeChar;
    UCHAR LeadByte    = pOctetArray[0];
    ULONG OctetCount  = UTF8_OCTET_COUNT(LeadByte);

    ASSERT(SourceLength > 0);

    if (0 == OctetCount)
    {
        UlTraceError(PARSER, (
                    "http!HttpUtf8RawBytesToUnicode(): "
                    "Invalid UTF-8 lead byte, %%%02X.\n",
                    LeadByte
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }
    else if (OctetCount > SourceLength)
    {
        UlTraceError(PARSER, (
                    "http!HttpUtf8RawBytesToUnicode(): "
                    "UTF-8 lead byte, %%%02X, requires %lu bytes in buffer, "
                    "but only have %lu.\n",
                    LeadByte, OctetCount, SourceLength
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    // Check that the trail bytes are valid: 10xxxxxx.

    for (i = 1;  i < OctetCount;  ++i)
    {
        if (! IS_UTF8_TRAILBYTE(pOctetArray[i]))
        {
            UlTraceError(PARSER, (
                    "http!HttpUtf8RawBytesToUnicode(): "
                    "Invalid trail byte[%lu], %%%02X.\n",
                    i, pOctetArray[i]
                    ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }
    }

    //
    // Now splice together the bits from the lead byte and the trail byte(s)
    //

    switch (OctetCount)
    {

    case 1:
        // handle one-byte case:
        //      (0xxx xxxx)
        //          => 0xxx xxxx 

        ASSERT(IS_UTF8_SINGLETON(LeadByte));
        ASSERT(SourceLength >= 1);

        UnicodeChar = LeadByte;

        ASSERT(UnicodeChar <= UTF8_1_MAX);
        break;


    case 2:
        // handle two-byte case:
        //      (110y yyyy,  10xx xxxx)
        //          => 0000 0yyy yyxx xxxx 

        ASSERT(IS_UTF8_1ST_BYTE_OF_2(LeadByte));
        ASSERT(IS_UTF8_TRAILBYTE(pOctetArray[1]));
        ASSERT(SourceLength >= 2);

        UnicodeChar = (
                        ((pOctetArray[0] & 0x1f) << 6) |
                         (pOctetArray[1] & 0x3f)
                      );

        if (UnicodeChar <= UTF8_1_MAX)
        {
            UlTraceError(PARSER, (
                        "http!HttpUtf8RawBytesToUnicode(): "
                        "Overlong 2-byte sequence, "
                        "%%%02X %%%02X = U+%04lX.\n",
                        pOctetArray[0],
                        pOctetArray[1],
                        UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        ASSERT(UTF8_1_MAX < UnicodeChar  &&  UnicodeChar <= UTF8_2_MAX);
        break;


    case 3:
        // handle three-byte case:
        //      (1110 zzzz,  10yy yyyy,  10xx xxxx)
        //          => zzzz yyyy yyxx xxxx 

        ASSERT(IS_UTF8_1ST_BYTE_OF_3(LeadByte));
        ASSERT(IS_UTF8_TRAILBYTE(pOctetArray[1]));
        ASSERT(IS_UTF8_TRAILBYTE(pOctetArray[2]));
        ASSERT(SourceLength >= 3);

        UnicodeChar = (
                        ((pOctetArray[0] & 0x0f) << 12) |
                        ((pOctetArray[1] & 0x3f) <<  6) |
                         (pOctetArray[2] & 0x3f)
                      );

        if (UnicodeChar <= UTF8_2_MAX)
        {
            UlTraceError(PARSER, (
                        "http!HttpUtf8RawBytesToUnicode(): "
                        "Overlong 3-byte sequence, "
                        "%%%02X %%%02X %%%02X = U+%04lX.\n",
                        pOctetArray[0],
                        pOctetArray[1],
                        pOctetArray[2],
                        UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        ASSERT(UTF8_2_MAX < UnicodeChar  &&  UnicodeChar <= UTF8_3_MAX);
        break;


    case 4:
        // handle four-byte case:
        //      (1111 0uuu,  10uu zzzz,  10yy yyyy,  10xx xxxx)
        //          => 000u uuuu zzzz yyyy yyxx xxxx

        ASSERT(IS_UTF8_1ST_BYTE_OF_4(LeadByte));
        ASSERT(IS_UTF8_TRAILBYTE(pOctetArray[1]));
        ASSERT(IS_UTF8_TRAILBYTE(pOctetArray[2]));
        ASSERT(IS_UTF8_TRAILBYTE(pOctetArray[3]));
        ASSERT(SourceLength >= 4);

        UnicodeChar = (
                        ((pOctetArray[0] & 0x07) << 18) |
                        ((pOctetArray[1] & 0x3f) << 12) |
                        ((pOctetArray[2] & 0x3f) <<  6) |
                         (pOctetArray[3] & 0x3f)
                      );

        if (UnicodeChar <= UTF8_3_MAX)
        {
            UlTraceError(PARSER, (
                        "http!HttpUtf8RawBytesToUnicode(): "
                        "Overlong 4-byte sequence, "
                        "%%%02X %%%02X %%%02X %%%02X = U+%06lX.\n",
                        pOctetArray[0],
                        pOctetArray[1],
                        pOctetArray[2],
                        pOctetArray[3],
                        UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        // Not all values in the 21-bit range are valid
        if (UnicodeChar > UTF8_4_MAX)
        {
            UlTraceError(PARSER, (
                        "http!HttpUtf8RawBytesToUnicode(): "
                        "Overlarge 4-byte sequence, "
                        "%%%02X %%%02X %%%02X %%%02X = U+%06lX.\n",
                        pOctetArray[0],
                        pOctetArray[1],
                        pOctetArray[2],
                        pOctetArray[3],
                        UnicodeChar
                        ));

            RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        ASSERT(UTF8_3_MAX < UnicodeChar  &&  UnicodeChar <= UTF8_4_MAX);
        break;


    default:
        ASSERT(! "Impossible OctetCount");
        UnicodeChar = 0;
        break;
    }

    //
    // Do not allow characters in the high- or low-surrogate ranges
    // to be UTF-8-encoded directly.
    //

    if (HIGH_SURROGATE_START <= UnicodeChar && UnicodeChar <= LOW_SURROGATE_END)
    {
        UlTraceError(PARSER, (
                    "http!HttpUtf8RawBytesToUnicode(): "
                    "Illegal surrogate character, U+%04lX.\n",
                    UnicodeChar
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }


    // For security reasons we will signal an error for all noncharacter code 
    // points encountered.

    if ( IS_UNICODE_NONCHAR(UnicodeChar) )
    {
        ASSERT( (((LOW_NONCHAR_BOM & UnicodeChar) == LOW_NONCHAR_BOM) && 
         ((UnicodeChar >> 16) <= HIGH_NONCHAR_END)) ||
         ((LOW_NONCHAR_START <= UnicodeChar) && 
         (UnicodeChar <= LOW_NONCHAR_END)) );
    
        UlTraceError(PARSER, (
                    "http!HttpUtf8RawBytesToUnicode(): "
                    "Non-character code point, U+%04lX.\n",
                    UnicodeChar
                    ));

        RETURN(STATUS_OBJECT_PATH_SYNTAX_BAD);
    }

    *pUnicodeChar = UnicodeChar;
    *pOctetsToSkip = OctetCount;

    return STATUS_SUCCESS;

} // HttpUtf8RawBytesToUnicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\kernel\precomp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for CmnSys.lib

Author:

    George V. Reilly (GeorgeRe)     30-Jan-2002

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// We are willing to ignore the following warnings, as we need the DDK to 
// compile.
//

#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntosp.h>
#include <ipexport.h>
#include <tdi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// #include <sspi.h>
// #include <winerror.h>

#include <SockDecl.h>
#include "..\..\sys\config.h"
#include "..\..\sys\strlog.h"
#include "..\..\sys\debug.h"

//
// Project include files.
//

#include <httpkrnl.h>
#include <httppkrnl.h>
#include <HttpIoctl.h>

#include <HttpCmn.h>
#include <Utf8.h>
#include <C14n.h>

typedef UCHAR BYTE;

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\c14np.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    C14np.h

Abstract:

    URL canonicalization (c14n) routines

Author:

    George V. Reilly (GeorgeRe)     10-Apr-2002

Revision History:

--*/


#ifndef _C14NP_H_
#define _C14NP_H_

typedef 
NTSTATUS
(*PFN_POPCHAR_HOSTNAME)(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharHostNameUtf8(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharHostNameDbcs(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharHostNameAnsi(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

typedef 
NTSTATUS
(*PFN_POPCHAR_ABSPATH)(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharAbsPathUtf8(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharAbsPathDbcs(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharAbsPathAnsi(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppPopCharQueryString(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    IN  BOOLEAN AllowRestrictedChars,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttppCopyHostByType(
    IN      URL_ENCODING_TYPE   UrlEncoding,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied
    );

NTSTATUS
HttppCopyUrlByType(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      URL_ENCODING_TYPE   UrlEncoding,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied
    );

NTSTATUS
HttppCleanAndCopyUrlByType(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      URL_ENCODING_TYPE   UrlEncoding,
    IN      URL_PART            UrlPart,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PWSTR *             ppQueryString OPTIONAL
    );

NTSTATUS
HttppParseIPv6Address(
    IN  PCWSTR          pBuffer,
    IN  ULONG           BufferLength,
    IN  BOOLEAN         ScopeIdAllowed,
    OUT PSOCKADDR_IN6   pSockAddr6,
    OUT PCWSTR*         ppEnd
    );

ULONG
HttppPrintIpAddressW(
    IN  PSOCKADDR           pSockAddr,
    OUT PWSTR               pBuffer
    );

//
// Enumerations for the state machines in HttppCleanAndCopyUrlByType()
// and HttpParseUrl() that handle directory-relative processing for
// "//", "/./", and "/../".
//

typedef enum
{
    ACTION_NOTHING,             // eat the character
    ACTION_EMIT_CH,             // emit the character
    ACTION_EMIT_DOT_CH,         // emit "." and the character
    ACTION_EMIT_DOT_DOT_CH,     // emit ".." and the character
    ACTION_BACKUP,              // backup to previous segment:
                                //      "/x/y/../z" -> "/x/z"

    ACTION_MAX

} URL_ACTION;


typedef enum
{
    URL_STATE_START,            // default state
    URL_STATE_SLASH,            // seen "/"
    URL_STATE_SLASH_DOT,        // seen "/."
    URL_STATE_SLASH_DOT_DOT,    // seen "/.."
    URL_STATE_END,              // end state
    URL_STATE_ERROR,            // error state

    URL_STATE_MAX

} URL_STATE;


typedef enum
{
    URL_TOKEN_OTHER,            // everything else
    URL_TOKEN_DOT,              // got a '.'
    URL_TOKEN_EOS,              // End of String
    URL_TOKEN_SLASH,            // got a '/'

    URL_TOKEN_MAX

} URL_STATE_TOKEN;


#if DBG

PCSTR
HttppUrlActionToString(
    URL_ACTION Action);

PCSTR
HttppUrlStateToString(
    URL_STATE UrlState);

PCSTR
HttppUrlTokenToString(
    URL_STATE_TOKEN UrlToken);

#endif // DBG

#endif // _C14NP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\cmnmisc.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    CmnMisc.c

Abstract:

    Miscellaneous common routines

Author:

    George V. Reilly (GeorgeRe)     06-Dec-2001

Revision History:

--*/


#include "precomp.h"

#if defined(ALLOC_PRAGMA) && defined(KERNEL_PRIV)

#pragma alloc_text( INIT, HttpCmnInitializeHttpCharsTable )

#endif // ALLOC_PRAGMA && KERNEL_PRIV

#if 0   // Non-Pageable Functions
NOT PAGEABLE -- strnchr
NOT PAGEABLE -- wcsnchr
NOT PAGEABLE -- HttpStringToULongLong
NOT PAGEABLE -- HttpStringToULong
NOT PAGEABLE -- HttpStringToUShort
NOT PAGEABLE -- HttpFillBufferTrap
NOT PAGEABLE -- HttpFillBuffer
NOT PAGEABLE -- HttpStatusToString
#endif // Non-Pageable Functions


DECLSPEC_ALIGN(UL_CACHE_LINE)  ULONG   HttpChars[256];
DECLSPEC_ALIGN(UL_CACHE_LINE)  WCHAR   FastPopChars[256];
DECLSPEC_ALIGN(UL_CACHE_LINE)  WCHAR   DummyPopChars[256];
DECLSPEC_ALIGN(UL_CACHE_LINE)  WCHAR   FastUpcaseChars[256];
DECLSPEC_ALIGN(UL_CACHE_LINE)  WCHAR   AnsiToUnicodeMap[256];

//
// Counted version of strchr()
//

char*
strnchr(
    const char* string,
    char        c,
    size_t      count
    )
{
    const char* end = string + count;
    const char* s;

    for (s = string;  s < end;  ++s)
    {
        if (c == *s)
            return (char*) s;
    }

    return NULL;
} // strnchr


//
// Counted version of wcschr()
//
wchar_t*
wcsnchr(
    const wchar_t* string,
    wint_t         c,
    size_t         count
    )
{
    const wchar_t* end = string + count;
    const wchar_t* s;

    for (s = string;  s < end;  ++s)
    {
        if (c == *s)
            return (wchar_t*) s;
    }

    return NULL;
} // wcsnchr


#define SET_HTTP_FLAGS(Set, Flags)      \
    HttppCmnInitHttpCharsBySet((PUCHAR) (Set), sizeof(Set) - 1, (Flags))

__inline
VOID
HttppCmnInitHttpCharsBySet(
    PUCHAR Set,
    ULONG  SetSize,
    ULONG  Flags
    )
{
    ULONG i;

    ASSERT(NULL != Set);
    ASSERT(SetSize > 0);
    ASSERT(0 != Flags);
    ASSERT('\0' == Set[SetSize]);

    for (i = 0;  i < SetSize;  ++i)
    {
        UCHAR Byte = Set[i];
        ASSERT(0 == (HttpChars[Byte] & Flags));

        HttpChars[Byte] |= Flags;
    }
}



/*++

Routine Description:

    Routine to initialize HttpChars[] and the other lookup tables.
    See the declarations in HttpCmn.h

--*/
VOID
HttpCmnInitializeHttpCharsTable(
    BOOLEAN EnableDBCS
    )
{
    ULONG    i;
    CHAR     AnsiChar;
    WCHAR    WideChar;
    NTSTATUS Status;


    RtlZeroMemory(HttpChars, sizeof(HttpChars));

    for (i = 0;  i <= ASCII_MAX;  ++i)
    {
        HttpChars[i] |= HTTP_CHAR;
    }

    SET_HTTP_FLAGS(HTTP_CTL_SET,        HTTP_CTL);

    SET_HTTP_FLAGS(HTTP_UPALPHA_SET,    HTTP_UPCASE);

    SET_HTTP_FLAGS(HTTP_LOALPHA_SET,    HTTP_LOCASE);

    SET_HTTP_FLAGS(HTTP_DIGITS_SET,     HTTP_DIGIT);

    SET_HTTP_FLAGS(HTTP_LWS_SET,        HTTP_LWS);

    SET_HTTP_FLAGS(HTTP_HEX_SET,        HTTP_HEX);

    SET_HTTP_FLAGS(HTTP_SEPARATORS_SET, HTTP_SEPARATOR);

    SET_HTTP_FLAGS(HTTP_WS_TOKEN_SET,   HTTP_WS_TOKEN);

    SET_HTTP_FLAGS(HTTP_ISWHITE_SET,    HTTP_ISWHITE);

    for (i = 0;  i <= ASCII_MAX;  ++i)
    {
        if (!IS_HTTP_SEPARATOR(i)  &&  !IS_HTTP_CTL(i))
        {
            HttpChars[i] |= HTTP_TOKEN;
        }
    }

    for (i = 0;  i <= ANSI_HIGH_MAX;  ++i)
    {
        if (!IS_HTTP_CTL(i)  ||  IS_HTTP_LWS(i))
        {
            HttpChars[i] |= HTTP_PRINT;
        }

        if (!IS_HTTP_CTL(i)  ||  IS_HTTP_WS_TOKEN(i))
        {
            HttpChars[i] |= HTTP_TEXT;
        }
    }
    
    // Used in URI canonicalizer to identify '.', '/', '?' and '#' 
    HttpChars['.']  |= HTTP_CHAR_DOT;
    HttpChars['/']  |= HTTP_CHAR_SLASH;
    HttpChars['?']  |= HTTP_CHAR_QM_HASH;
    HttpChars['#']  |= HTTP_CHAR_QM_HASH;


    // URL flags initialization

    //
    // These US-ASCII characters are "excluded"; i.e., not URL_LEGAL (see RFC):
    //      '<' | '>' | ' ' (0x20)
    // In addition, control characters (0x00-0x1F and 0x7F) and
    // non US-ASCII characters (0x80-0xFF) are not URL_LEGAL.
    //
    SET_HTTP_FLAGS(URL_UNRESERVED_SET,  URL_LEGAL);
    SET_HTTP_FLAGS(URL_RESERVED_SET,    URL_LEGAL);
    // For compatibility with IIS 5.0 and DAV, we must allow
    // the "unwise" characters in URLs.
    SET_HTTP_FLAGS(URL_UNWISE_SET,      URL_LEGAL);
    SET_HTTP_FLAGS("%",                 URL_LEGAL);

    SET_HTTP_FLAGS(URL_DIRTY_SET,       URL_DIRTY);
    // All characters outside US-ASCII range are considered dirty
    for (i = ANSI_HIGH_MIN;  i <= ANSI_HIGH_MAX;  ++i)
        HttpChars[i] |= URL_DIRTY;

    SET_HTTP_FLAGS(URL_HOSTNAME_LABEL_LDH_SET,      URL_HOSTNAME_LABEL);

    SET_HTTP_FLAGS(URL_INVALID_SET,                 URL_INVALID);

    SET_HTTP_FLAGS(URL_ILLEGAL_COMPUTERNAME_SET,    URL_ILLEGAL_COMPUTERNAME);

    //
    // In DBCS locales we need to explicitly accept lead bytes that
    // we would normally reject.
    //

    if (EnableDBCS)
    {
        // By definition, lead bytes are in the range 0x80-0xFF
        for (i = ANSI_HIGH_MIN;  i <= ANSI_HIGH_MAX;  ++i)
        {
#if KERNEL_PRIV
            // These are copied from RTL NLS routines.
            extern PUSHORT NlsLeadByteInfo;
            BOOLEAN IsLeadByte
                = (BOOLEAN) (((*(PUSHORT *) NlsLeadByteInfo)[i]) != 0);
#else  // !KERNEL_PRIV
            BOOLEAN IsLeadByte = (BOOLEAN) IsDBCSLeadByte((BYTE) i);
#endif // !KERNEL_PRIV

            if (IsLeadByte)
            {
                HttpChars[i] |= HTTP_DBCS_LEAD_BYTE;

                if (IS_HIGH_ANSI(i))
                    HttpChars[i] |= URL_LEGAL;

                UlTrace(PARSER, (
                    "http!InitializeHttpUtil, "
                    "marking %x (%c) as a valid lead byte.\n",
                    i, i
                    ));
            }
            else
            {
                // For the DBCS locales, almost all bytes above 128 are
                // either lead bytes or valid single-byte characters.

                AnsiChar = (CHAR) i;

                Status = RtlMultiByteToUnicodeN(
                            &WideChar,
                            sizeof(WCHAR),
                            NULL,
                            (PCHAR) &AnsiChar,
                            1
                            );

                if (NT_SUCCESS(Status))
                {
                    HttpChars[i] |= URL_LEGAL;

                    UlTrace(PARSER, (
                        "http!InitializeHttpUtil, "
                        "marking %x (%c) as a legal DBCS character, %s.\n",
                        i, i,
                        HttpStatusToString(Status)
                        ));
                }
                else
                {
                    UlTrace(PARSER, (
                        "http!InitializeHttpUtil, "
                        "%x (%c) is not a legal DBCS character.\n",
                        i, i
                        ));
                }
            }
        }
    }

    // Build a lookup table that maps the 256 possible ANSI characters
    // in the system code page to Unicode

    for (i = 0;  i <= ANSI_HIGH_MAX;  ++i)
    {
        AnsiChar = (CHAR) i;

        Status = RtlMultiByteToUnicodeN(
                    &WideChar,
                    sizeof(WCHAR),
                    NULL,
                    (PCHAR) &AnsiChar,
                    1
                    );

        AnsiToUnicodeMap[i] = (NT_SUCCESS(Status) ? WideChar : 0);

        // Also, handle upcasing the first 256 chars
        FastUpcaseChars[i] = RtlUpcaseUnicodeChar((WCHAR) i);
    }

    //
    // Fast path for PopChar. 0 => special handling.
    //

    RtlZeroMemory(FastPopChars,   sizeof(FastPopChars));
    RtlZeroMemory(DummyPopChars,  sizeof(DummyPopChars));

    for (i = 0;  i <= ASCII_MAX;  ++i)
    {
        UCHAR c = (UCHAR)i;

        // (ALPHA | DIGIT | URL_LEGAL)  && !IS_URL_DIRTY
        if (IS_URL_TOKEN(c)  &&  !IS_URL_DIRTY(c))
            FastPopChars[i] = c;
    }

    // These characters are in the dirty set, so we need to set them explicitly
    FastPopChars['.']  = L'.';
    FastPopChars['/']  = L'/';

    //
    // Finally, initialize the UTF-8 data
    //

    HttpInitializeUtf8();

} // HttpCmnInitializeHttpCharsTable



#define MAX_ULONGLONG   18446744073709551615ui64
C_ASSERT(~0ui64 == MAX_ULONGLONG);

#define MAX_ULONG       0xFFFFFFFF
#define MAX_USHORT      0xFFFF


/***************************************************************************++

Routine Description:

    Converts an ANSI or Unicode string to a ULONGLONG.
    Fails on negative numbers, and assumes no preceding spaces.

Arguments:

    IsUnicode           Non-zero => pString is Unicode, otherwise it's ANSI.
    pString             The string to convert. Must point to the first digit.
    StringLength        Number of characters (ANSI or Unicode) in pString.
                        If zero, then the string must be NUL-terminated and
                        there may be non-digit characters before the
                        terminating NUL. Otherwise (counted string),
                        only digit characters may be present.
    LeadingZerosAllowed String can/cannot start with leading zeros
    Base                The base of the string; must be 10 or 16
    ppTerminator        Pointer to the end of the numeric string. May be NULL.
    pValue              The return value of the converted ULONGLONG

Return Value:

    STATUS_SUCCESS              Valid number
    STATUS_INVALID_PARAMETER    Bad digit
    STATUS_SECTION_TOO_BIG      Numeric overflow

    *ppTerminator always points to the string terminator, if it wasn't NULL
    on entry. *pValue is valid only for STATUS_SUCCESS.

--***************************************************************************/
NTSTATUS
HttpStringToULongLong(
    IN  BOOLEAN     IsUnicode,
    IN  PCVOID      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PVOID*      ppTerminator,
    OUT PULONGLONG  pValue
    )
{
    ULONGLONG   Value = 0;
    BOOLEAN     ZeroTerminated = (BOOLEAN) (0 == StringLength);
    BOOLEAN     Decimal = (BOOLEAN) (10 == Base);
    ULONG       Mask = (Decimal ? HTTP_DIGIT : HTTP_HEX);
    PCUCHAR     pAnsiString = (PCUCHAR) pString;
    PCWSTR      pWideString = (PCWSTR)  pString;
    PVOID       pLocalTerminator;
    ULONGLONG   OverflowLimit;
    ULONG       MaxLastDigit;
    ULONG       Index;
    ULONG       Char;

    // If you've failed to call HttpCmnInitializeHttpCharsTable(),
    // you'll hit this assertion
    ASSERT(IS_HTTP_DIGIT('0'));

    // If the caller doesn't care about the string terminator, just
    // make ppTerminator point to something valid, so that we don't have
    // to test it everywhere before assigning to it.
    if (NULL == ppTerminator)
        ppTerminator = &pLocalTerminator;

    // Initialize ppTerminator to the beginning of the string
    *ppTerminator = (PVOID) pString;

    // Check for obviously invalid data
    if (NULL == pString  ||  NULL == pValue  ||  (10 != Base  &&  16 != Base))
    {
        UlTraceError(PARSER, ("Invalid parameters\n"));
        RETURN(STATUS_INVALID_PARAMETER);
    }

    // First character must be a valid digit
    Char = (IsUnicode ? pWideString[0] : pAnsiString[0]);

    if (!IS_ASCII(Char)  ||  !IS_CHAR_TYPE(Char, Mask))
    {
        UlTraceError(PARSER, ("No digits\n"));
        RETURN(STATUS_INVALID_PARAMETER);
    }

    // Check for leading zeros
    if (!LeadingZerosAllowed  &&  '0' == Char)
    {
        // If leading zeros are not allowed and the first character is zero,
        // then it must be the only digit in the string.

        if (ZeroTerminated)
        {
            // Check second digit
            Char = (IsUnicode ? pWideString[1] : pAnsiString[1]);

            if (IS_ASCII(Char)  &&  IS_CHAR_TYPE(Char, Mask))
            {
                UlTraceError(PARSER, ("Second digit forbidden\n"));
                RETURN(STATUS_INVALID_PARAMETER);
            }
        }
        else
        {
            // A counted string must have exactly one digit (the zero)
            // in this case
            if (StringLength != 1)
            {
                UlTraceError(PARSER, ("Second digit forbidden\n"));
                RETURN(STATUS_INVALID_PARAMETER);
            }
        }
    }

    // The calculations are done this way in the hope that the compiler
    // will use compile-time constants
    if (Decimal)
    {
        OverflowLimit = (MAX_ULONGLONG / 10);
        MaxLastDigit   = MAX_ULONGLONG % 10;
    }
    else
    {
        ASSERT(16 == Base);
        OverflowLimit = (MAX_ULONGLONG >> 4);
        MaxLastDigit   = MAX_ULONGLONG & 0xF;
        ASSERT(0xF == MaxLastDigit);
    }

    ASSERT(OverflowLimit < Base * OverflowLimit);
    ASSERT(Base * OverflowLimit + MaxLastDigit == MAX_ULONGLONG);

    // Loop through the string

    for (Index = 0;  ZeroTerminated  ||  Index < StringLength;  ++Index)
    {
        ULONGLONG   NewValue;
        ULONG       Digit;

        // Update ppTerminator first, in case of error

        if (IsUnicode)
        {
            *ppTerminator = (PVOID) &pWideString[Index];
            Char = pWideString[Index];
        }
        else
        {
            *ppTerminator = (PVOID) &pAnsiString[Index];
            Char = pAnsiString[Index];
        }

        // Is Char is a valid digit?

        if (!IS_ASCII(Char)  ||  ! IS_CHAR_TYPE(Char, Mask))
        {
            if (ZeroTerminated)
            {
                // If the string is ultimately zero-terminated, but there
                // are some non-digit characters after the number, that is
                // not an error. Note: '\0' will fail the IS_CHAR_TYPE test.
                break;
            }
            else
            {
                // For counted strings, only digits may be present
                UlTraceError(PARSER, ("Invalid digit\n"));
                RETURN(STATUS_INVALID_PARAMETER);
            }
        }

        if (IS_HTTP_ALPHA(Char))
        {
            ASSERT(('A' <= Char  &&  Char <= 'F')
                    || ('a' <= Char  &&  Char <= 'f'));

            if (Decimal)
            {
                // Chars in the range [A-Fa-f] are invalid in decimal numbers

                if (ZeroTerminated)
                {
                    // Anything outside the range [0-9] terminates the loop
                    break;
                }
                else
                {
                    // For counted decimal strings, only decimal digits
                    // may be present
                    UlTraceError(PARSER, ("Non-decimal digit\n"));
                    RETURN(STATUS_INVALID_PARAMETER);
                }
            }

            Digit = 0xA + (UPCASE_CHAR(Char) - 'A');

            ASSERT(0xA <= Digit  &&  Digit <= 0xF);
        }
        else
        {
            ASSERT('0' <= Char  &&  Char <= '9');
            Digit = Char - '0';
        }

        ASSERT(Digit < Base);

        //
        // Guard against arithmetic overflow. We just got a valid digit,
        // but Value will (likely) overflow if we shift in another digit
        //

        if (Value >= OverflowLimit)
        {
            // Definite overflow
            if (Value > OverflowLimit)
            {
                UlTraceError(PARSER, ("Numeric overflow\n"));
                RETURN(STATUS_SECTION_TOO_BIG);
            }

            ASSERT(Value == OverflowLimit);

            // May be able to accommodate the last digit
            if (Digit > MaxLastDigit)
            {
                UlTraceError(PARSER, ("Numeric overflow\n"));
                RETURN(STATUS_SECTION_TOO_BIG);
            }
        }

        ASSERT(Value * Base <= MAX_ULONGLONG - Digit);
        ASSERT(Value < Value * Base  ||  0 == Value);

        if (Decimal)
            NewValue = (10 * Value)  +  Digit;
        else
            NewValue = (Value << 4)  |  Digit;

        ASSERT(NewValue > Value
                || (0 == Value && 0 == Digit
                    && (LeadingZerosAllowed || (0 == Index))));

        Value = NewValue;
    }

    // Must be a valid number if reached here
    ASSERT(ZeroTerminated  ?  Index > 0  :  Index == StringLength);

    // Make ppTerminator point to the end of the string
    if (IsUnicode)
        *ppTerminator = (PVOID) &pWideString[Index];
    else
        *ppTerminator = (PVOID) &pAnsiString[Index];

    *pValue = Value;

    return STATUS_SUCCESS;

}   // HttpStringToULongLong



NTSTATUS
HttpStringToULong(
    IN  BOOLEAN     IsUnicode,
    IN  PCVOID      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PVOID*      ppTerminator,
    OUT PULONG      pValue
    )
{
    ULONGLONG Value;
    NTSTATUS  Status;

    Status = HttpStringToULongLong(
                    IsUnicode,
                    pString,
                    StringLength,
                    LeadingZerosAllowed,
                    Base,
                    ppTerminator,
                    &Value
                    );

    if (NT_SUCCESS(Status))
    {
        if (Value > MAX_ULONG)
        {
            UlTraceError(PARSER, ("Numeric overflow\n"));
            RETURN(STATUS_SECTION_TOO_BIG);
        }
        else
        {
            *pValue = (ULONG) Value;
        }
    }

    return Status;

} // HttpStringToULong



NTSTATUS
HttpStringToUShort(
    IN  BOOLEAN     IsUnicode,
    IN  PCVOID      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PVOID*      ppTerminator,
    OUT PUSHORT     pValue
    )
{
    ULONGLONG Value;
    NTSTATUS  Status;

    Status = HttpStringToULongLong(
                    IsUnicode,
                    pString,
                    StringLength,
                    LeadingZerosAllowed,
                    Base,
                    ppTerminator,
                    &Value
                    );

    if (NT_SUCCESS(Status))
    {
        if (Value > MAX_USHORT)
        {
            UlTraceError(PARSER, ("Numeric overflow\n"));
            RETURN(STATUS_SECTION_TOO_BIG);
        }
        else
        {
            *pValue = (USHORT) Value;
        }
    }

    return Status;

} // HttpStringToUShort



#if DBG

VOID
HttpFillBufferTrap(
    VOID
    )
{
    ASSERT(! "HttpFillBufferTrap");
}



//
// Fill an output buffer with a known pattern. Helps detect buffer overruns.
//

VOID
HttpFillBuffer(
    PUCHAR pBuffer,
    SIZE_T BufferLength
    )
{
    union
    {
        ULONG_PTR   UlongPtr;
        UCHAR       Bytes[sizeof(ULONG_PTR)];
    } FillPattern;

    const ULONG_PTR Mask = sizeof(ULONG_PTR) - 1;

    ULONG_PTR   i;
    ULONG_PTR   OriginalBufferLength = BufferLength;
    PUCHAR      pOriginalBuffer = pBuffer;
    PULONG_PTR  pAlignedBuffer;

    ASSERT(NULL != pBuffer);
    ASSERT(BufferLength > 0);

    FillPattern.UlongPtr = (ULONG_PTR) &HttpFillBufferTrap;

    // Fill any unaligned bytes at the beginning of the buffer

    for (i = (ULONG_PTR) pBuffer;
         (i & Mask) != 0  &&  BufferLength > 0;
         ++i, --BufferLength
        )
    {
        *pBuffer++ = FillPattern.Bytes[i & Mask];
    }

    ASSERT(((ULONG_PTR) pBuffer & Mask) == 0);

    // Fill as much as possible of the buffer with ULONG_PTRs

    pAlignedBuffer = (PULONG_PTR) pBuffer;

    for (i = (BufferLength & ~Mask);  i > 0;  i -= sizeof(ULONG_PTR))
    {
        ASSERT((i & Mask) == 0);
        *pAlignedBuffer++ = FillPattern.UlongPtr;
    }

    // Fill any unaligned bytes at the tail of the buffer
    pBuffer = (PUCHAR) pAlignedBuffer;
    ASSERT(((ULONG_PTR) pBuffer & Mask) == 0);

    for (i = 0;  i != (BufferLength & Mask);  ++i)
    {
        *pBuffer++ = FillPattern.Bytes[i & Mask];
    }

    ASSERT(pOriginalBuffer + OriginalBufferLength == pBuffer);

} // HttpFillBuffer

#endif // DBG


//
// Convert an NTSTATUS to a string, for use in debug spew.
//

PCSTR
HttpStatusToString(
    NTSTATUS Status
    )
{
    static NTSTATUS s_KnownUnhandledStatus = 0;
    PCSTR  String;

    switch (Status)
    {
    default:
        // If you hit this, add the newly used status code below
        WriteGlobalStringLog("Unhandled NTSTATUS, 0x%08lX\n", Status);

        // Only assert once. If you've got two new NTSTATUSes, well, tough.
        if (Status != s_KnownUnhandledStatus)
        {
            ASSERT(! "Unhandled NTSTATUS");
            s_KnownUnhandledStatus = Status;
        }

        String = "<STATUS_???>";
        break;

#define STATUS_CASE(n, s)           \
    case s:                         \
    {                               \
        C_ASSERT((NTSTATUS) n == s);\
        String = #s;                \
        break;                      \
    }

    STATUS_CASE( 0xC0000022, STATUS_ACCESS_DENIED );
    STATUS_CASE( 0xC0000005, STATUS_ACCESS_VIOLATION );
    STATUS_CASE( 0xC000020A, STATUS_ADDRESS_ALREADY_EXISTS );
    STATUS_CASE( 0xC0000099, STATUS_ALLOTTED_SPACE_EXCEEDED );
    STATUS_CASE( 0x80000005, STATUS_BUFFER_OVERFLOW );
    STATUS_CASE( 0xC0000023, STATUS_BUFFER_TOO_SMALL );
    STATUS_CASE( 0xC0000120, STATUS_CANCELLED );
    STATUS_CASE( 0xC0000018, STATUS_CONFLICTING_ADDRESSES );
    STATUS_CASE( 0xC0000241, STATUS_CONNECTION_ABORTED );
    STATUS_CASE( 0xC000023B, STATUS_CONNECTION_ACTIVE );
    STATUS_CASE( 0xC000020C, STATUS_CONNECTION_DISCONNECTED );
    STATUS_CASE( 0xC000023A, STATUS_CONNECTION_INVALID );
    STATUS_CASE( 0xC0000236, STATUS_CONNECTION_REFUSED );
    STATUS_CASE( 0xC000020D, STATUS_CONNECTION_RESET );
    STATUS_CASE( 0xC00002C5, STATUS_DATATYPE_MISALIGNMENT_ERROR );
    STATUS_CASE( 0xC000021B, STATUS_DATA_NOT_ACCEPTED );
    STATUS_CASE( 0xC000003C, STATUS_DATA_OVERRUN );
    STATUS_CASE( 0xC000007F, STATUS_DISK_FULL );
    STATUS_CASE( 0xC00000BD, STATUS_DUPLICATE_NAME );
    STATUS_CASE( 0xC0000011, STATUS_END_OF_FILE );
    STATUS_CASE( 0xC0000098, STATUS_FILE_INVALID );
    STATUS_CASE( 0xC0000004, STATUS_INFO_LENGTH_MISMATCH );
    STATUS_CASE( 0xC000009A, STATUS_INSUFFICIENT_RESOURCES );
    STATUS_CASE( 0xC0000095, STATUS_INTEGER_OVERFLOW );
    STATUS_CASE( 0xC0000141, STATUS_INVALID_ADDRESS );
    STATUS_CASE( 0xC0000010, STATUS_INVALID_DEVICE_REQUEST );
    STATUS_CASE( 0xC0000184, STATUS_INVALID_DEVICE_STATE );
    STATUS_CASE( 0xC0000008, STATUS_INVALID_HANDLE );
    STATUS_CASE( 0xC0000084, STATUS_INVALID_ID_AUTHORITY );
    STATUS_CASE( 0xC00000C3, STATUS_INVALID_NETWORK_RESPONSE );
    STATUS_CASE( 0xC000005A, STATUS_INVALID_OWNER );
    STATUS_CASE( 0xC000000D, STATUS_INVALID_PARAMETER );
    STATUS_CASE( 0xC00000B5, STATUS_IO_TIMEOUT );
    STATUS_CASE( 0xC0000016, STATUS_MORE_PROCESSING_REQUIRED );
    STATUS_CASE( 0xC0000106, STATUS_NAME_TOO_LONG );
    STATUS_CASE( 0xC0000225, STATUS_NOT_FOUND );
    STATUS_CASE( 0xC0000002, STATUS_NOT_IMPLEMENTED );
    STATUS_CASE( 0xC00000BB, STATUS_NOT_SUPPORTED );
    STATUS_CASE( 0xC00002F1, STATUS_NO_IP_ADDRESSES );
    STATUS_CASE( 0xC0000017, STATUS_NO_MEMORY );
    STATUS_CASE( 0x8000001A, STATUS_NO_MORE_ENTRIES );
    STATUS_CASE( 0x80000006, STATUS_NO_MORE_FILES );
    STATUS_CASE( 0xC000000F, STATUS_NO_SUCH_FILE );
    STATUS_CASE( 0xC000029F, STATUS_NO_TRACKING_SERVICE );
    STATUS_CASE( 0xC000022B, STATUS_OBJECTID_EXISTS );
    STATUS_CASE( 0xC0000035, STATUS_OBJECT_NAME_COLLISION );
    STATUS_CASE( 0xC0000033, STATUS_OBJECT_NAME_INVALID );
    STATUS_CASE( 0xC0000034, STATUS_OBJECT_NAME_NOT_FOUND );
    STATUS_CASE( 0xC0000039, STATUS_OBJECT_PATH_INVALID );
    STATUS_CASE( 0xC000003A, STATUS_OBJECT_PATH_NOT_FOUND );
    STATUS_CASE( 0xC000003B, STATUS_OBJECT_PATH_SYNTAX_BAD );
    STATUS_CASE( 0x00000103, STATUS_PENDING );
    STATUS_CASE( 0xC00000D9, STATUS_PIPE_EMPTY );
    STATUS_CASE( 0xC0000037, STATUS_PORT_DISCONNECTED );
    STATUS_CASE( 0xC000022D, STATUS_RETRY );
    STATUS_CASE( 0xC0000059, STATUS_REVISION_MISMATCH );
    STATUS_CASE( 0xC0000040, STATUS_SECTION_TOO_BIG );
    STATUS_CASE( 0xC0000043, STATUS_SHARING_VIOLATION );
    STATUS_CASE( 0x00000000, STATUS_SUCCESS );
    STATUS_CASE( 0xC0000001, STATUS_UNSUCCESSFUL );
    STATUS_CASE( 0xC0000295, STATUS_WMI_GUID_NOT_FOUND );
    }

    return String;

} // HttpStatusToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\kernel\cmndbgk.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    CmnDbgK.c

Abstract:

    Implementation of driver-specific routines declared in HttpCmn.h

Author:

    George V. Reilly (GeorgeRe)     07-Dec-2001

Revision History:

--*/


#include "precomp.h"



PVOID
HttpCmnAllocate(
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumBytes,
    IN ULONG     PoolTag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber)
{
#if DBG
    return UlDbgAllocatePool(
                PoolType,
                NumBytes,
                PoolTag,
                pFileName,
                LineNumber,
                NULL);
#else // !DBG
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    return ExAllocatePoolWithTagPriority(
                PoolType,
                NumBytes,
                PoolTag,
                LowPoolPriority
                );
#endif // !DBG
} // HttpCmnAlloc


VOID
HttpCmnFree(
    IN PVOID   pMem,
    IN ULONG   PoolTag,
    IN PCSTR   pFileName,
    IN USHORT  LineNumber)
{
#if DBG
    UlDbgFreePool(
        pMem,
        PoolTag,
        pFileName,
        LineNumber,
        PagedPool,
        0,
        NULL
        );
#else // !DBG
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

# if USE_FREE_POOL_WITH_TAG
    ExFreePoolWithTag(pMem, PoolTag);
# else
    UNREFERENCED_PARAMETER(PoolTag);
    ExFreePool(pMem);
# endif
#endif // !DBG

} // HttpCmnFree
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\usermode\precomp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for CmnUser.lib

Author:

    George V. Reilly (GeorgeRe)     30-Jan-2002

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// We are willing to ignore the following warnings, as we need the DDK to 
// compile.
//

#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tdi.h>

#define HTTPAPI_LINKAGE
#include <Http.h>
#include <HttpP.h>
#include <HttpIoctl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <PoolTag.h>

#include <HttpCmn.h>
#include <Utf8.h>
#include <C14n.h>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\inc\c14n.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    C14n.h

Abstract:

    URL canonicalization (c14n) routines

Author:

    George V. Reilly (GeorgeRe)     10-Apr-2002

Revision History:

--*/

#ifndef _C14N_H_
#define _C14N_H_

#define DEFAULT_C14N_ENABLE_NON_UTF8_URL            TRUE
#define DEFAULT_C14N_FAVOR_UTF8_URL                 TRUE
#define DEFAULT_C14N_ENABLE_DBCS_URL                FALSE
#define DEFAULT_C14N_PERCENT_U_ALLOWED              TRUE
#define DEFAULT_C14N_ALLOW_RESTRICTED_CHARS         FALSE

// Maximum length of the AbsPath of a URL, in chars
#define DEFAULT_C14N_URL_MAX_LENGTH                 UNICODE_STRING_MAX_WCHAR_LEN

#ifndef MAX_PATH
 #define MAX_PATH    260
#endif

// Maximum length of an individual segment within a URL
#define DEFAULT_C14N_URL_SEGMENT_MAX_LENGTH         MAX_PATH
#define C14N_URL_SEGMENT_UNLIMITED_LENGTH       (0xFFFFFFFE - STRLEN_LIT("/"))

// Maximum number of path segments within a URL
#define DEFAULT_C14N_URL_SEGMENT_MAX_COUNT          255
#define C14N_URL_SEGMENT_UNLIMITED_COUNT       C14N_URL_SEGMENT_UNLIMITED_LENGTH

// Maximum length of a label within a hostname; e.g., "www.example.com"
// has three labels, with "example" being the longest at 7 octets.
#define DEFAULT_C14N_MAX_LABEL_LENGTH               63

// Maximum length of a hostname
#define DEFAULT_C14N_MAX_HOSTNAME_LENGTH            255


typedef enum _URL_PART
{
    UrlPart_Scheme,
    UrlPart_HostName,
    UrlPart_UserInfo,
    UrlPart_AbsPath,
    UrlPart_QueryString,
    UrlPart_Fragment

} URL_PART;

typedef enum _URL_DECODE_ORDER
{
    UrlDecode_Shift = 2,
    UrlDecode_Mask  = ((1 << UrlDecode_Shift) - 1),

#define URL_DECODE2(D1, D2) \
    ( UrlDecode_##D1 | (UrlDecode_##D2 << UrlDecode_Shift))

#define URL_DECODE3(D1, D2, D3) \
    ( URL_DECODE2(D1, D2) | (UrlDecode_##D3 << (2 * UrlDecode_Shift)))

    UrlDecode_None = 0,

    // The following are the only valid permutations

    UrlDecode_Ansi = 1,
    UrlDecode_Dbcs = 2,
    UrlDecode_Utf8 = 3,

    UrlDecode_Ansi_Else_Dbcs            = URL_DECODE2(Ansi, Dbcs),
    UrlDecode_Ansi_Else_Dbcs_Else_Utf8  = URL_DECODE3(Ansi, Dbcs, Utf8),

    UrlDecode_Ansi_Else_Utf8            = URL_DECODE2(Ansi, Utf8),
    UrlDecode_Ansi_Else_Utf8_Else_Dbcs  = URL_DECODE3(Ansi, Utf8, Dbcs),

    UrlDecode_Dbcs_Else_Ansi            = URL_DECODE2(Dbcs, Ansi),
    UrlDecode_Dbcs_Else_Ansi_Else_Utf8  = URL_DECODE3(Dbcs, Ansi, Utf8),

    UrlDecode_Dbcs_Else_Utf8            = URL_DECODE2(Dbcs, Utf8),
    UrlDecode_Dbcs_Else_Utf8_Else_Ansi  = URL_DECODE3(Dbcs, Utf8, Ansi),

    UrlDecode_Utf8_Else_Ansi            = URL_DECODE2(Utf8, Ansi),
    UrlDecode_Utf8_Else_Ansi_Else_Dbcs  = URL_DECODE3(Utf8, Ansi, Dbcs),

    UrlDecode_Utf8_Else_Dbcs            = URL_DECODE2(Utf8, Dbcs),
    UrlDecode_Utf8_Else_Dbcs_Else_Ansi  = URL_DECODE3(Utf8, Dbcs, Ansi),

    UrlDecode_MaxMask = URL_DECODE3(Mask, Mask, Mask)

#undef URL_DECODE2
#undef URL_DECODE3

    // UrlDecode_Utf8_Else_Dbcs_Else_Ansi means:
    // * First attempt to decode the URL as UTF-8.
    // * If that fails, attempt to decode it as DBCS.
    // * If that too fails, attempt to decode it as ANSI.

} URL_DECODE_ORDER, *PURL_DECODE_ORDER;


typedef enum _URL_ENCODING_TYPE
{
    UrlEncoding_Ansi = UrlDecode_Ansi,
    UrlEncoding_Dbcs = UrlDecode_Dbcs,
    UrlEncoding_Utf8 = UrlDecode_Utf8

} URL_ENCODING_TYPE, *PURL_ENCODING_TYPE;


typedef struct _URL_C14N_CONFIG
{
    URL_DECODE_ORDER    HostnameDecodeOrder;
    URL_DECODE_ORDER    AbsPathDecodeOrder;
    BOOLEAN             EnableNonUtf8;
    BOOLEAN             FavorUtf8;
    BOOLEAN             EnableDbcs;
    BOOLEAN             PercentUAllowed;
    BOOLEAN             AllowRestrictedChars;
    ULONG               CodePage;
    ULONG               UrlMaxLength;
    ULONG               UrlSegmentMaxLength;
    ULONG               UrlSegmentMaxCount;
    ULONG               MaxLabelLength;
    ULONG               MaxHostnameLength;

} URL_C14N_CONFIG, *PURL_C14N_CONFIG;


typedef enum
{
    HttpUrlSite_None = 0,
    HttpUrlSite_Name,            // named site
    HttpUrlSite_IP,              // IPv4 or IPv6 literal hostname
    HttpUrlSite_NamePlusIP,      // named site with Routing IP
    HttpUrlSite_WeakWildcard,    // hostname = '*'
    HttpUrlSite_StrongWildcard,  // hostname = '+'

    HttpUrlSite_Max
} HTTP_URL_SITE_TYPE, *PHTTP_URL_SITE_TYPE;


#define HTTP_PARSED_URL_SIGNATURE      MAKE_SIGNATURE('PUrl')
#define HTTP_PARSED_URL_SIGNATURE_X    \
    MAKE_FREE_SIGNATURE(HTTP_PARSED_URL_SIGNATURE)

#define IS_VALID_HTTP_PARSED_URL(p)    \
    ((p) && ((p)->Signature == HTTP_PARSED_URL_SIGNATURE))

typedef struct _HTTP_PARSED_URL
{
    ULONG               Signature;      // HTTP_PARSED_URL_SIGNATURE
    HTTP_URL_SITE_TYPE  SiteType;       // Name, IP, or Weak/StrongWildCard

    //
    // These strings all point into the same buffer, of the form
    // "http://hostname:port/abs/path/" or
    // "http://hostname:port:IP/abs/path/".
    //

    PWSTR               pFullUrl;       // points to "http" or "https"
    PWSTR               pHostname;      // point to "hostname"
    PWSTR               pPort;          // point to "port"
    PWSTR               pRoutingIP;     // point to "IP" or NULL
    PWSTR               pAbsPath;       // points to "/abs/path"

    USHORT              UrlLength;      // length of pFullUrl
    USHORT              HostnameLength; // length of pHostname
    USHORT              PortLength;     // length of pPort
    USHORT              RoutingIPLength;// length of pRoutingIP
    USHORT              AbsPathLength;  // length of pAbsPath

    USHORT              PortNumber;     // value of pPort
    BOOLEAN             Secure;         // http or httpS?
    BOOLEAN             Normalized;     // In normalized form?
    BOOLEAN             TrailingSlashReqd;  // If TRUE => directory prefix

    union
    {
        SOCKADDR        SockAddr;       // Look at SockAddr.sa_family
        SOCKADDR_IN     SockAddr4;      // set if == TDI_ADDRESS_TYPE_IP
        SOCKADDR_IN6    SockAddr6;      // set if == TDI_ADDRESS_TYPE_IP6
    };

    union
    {
        SOCKADDR        RoutingAddr;    // Look at RoutingAddr.sa_family
        SOCKADDR_IN     RoutingAddr4;   // set if == TDI_ADDRESS_TYPE_IP
        SOCKADDR_IN6    RoutingAddr6;   // set if == TDI_ADDRESS_TYPE_IP6
    };

} HTTP_PARSED_URL, *PHTTP_PARSED_URL;


typedef enum _HOSTNAME_TYPE
{
    Hostname_AbsUri = 1,    // from Request-line
    Hostname_HostHeader,    // from Host header
    Hostname_Transport      // synthesized from transport's local IP address

} HOSTNAME_TYPE, *PHOSTNAME_TYPE;



VOID
HttpInitializeDefaultUrlC14nConfig(
    PURL_C14N_CONFIG pCfg
    );

VOID
HttpInitializeDefaultUrlC14nConfigEncoding(
    PURL_C14N_CONFIG    pCfg,
    BOOLEAN             EnableNonUtf8,
    BOOLEAN             FavorUtf8,
    BOOLEAN             EnableDbcs
    );

NTSTATUS
HttpUnescapePercentHexEncoding(
    IN  PCUCHAR pSourceChar,
    IN  ULONG   SourceLength,
    IN  BOOLEAN PercentUAllowed,
    OUT PULONG  pOutChar,
    OUT PULONG  pBytesToSkip
    );

NTSTATUS
HttpValidateHostname(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      PCUCHAR             pHostname,
    IN      ULONG               HostnameLength,
    IN      HOSTNAME_TYPE       HostnameType,
    OUT     PSHORT              pAddressType
    );

NTSTATUS
HttpCopyHost(
    IN      PURL_C14N_CONFIG    pCfg,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PURL_ENCODING_TYPE  pUrlEncodingType
    );

NTSTATUS
HttpCopyUrl(
    IN      PURL_C14N_CONFIG    pCfg,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PURL_ENCODING_TYPE  pUrlEncoding
    );

NTSTATUS
HttpCleanAndCopyUrl(
    IN      PURL_C14N_CONFIG    pCfg,
    IN      URL_PART            UrlPart,
    OUT     PWSTR               pDestination,
    IN      PCUCHAR             pSource,
    IN      ULONG               SourceLength,
    OUT     PULONG              pBytesCopied,
    OUT     PWSTR *             ppQueryString OPTIONAL,
    OUT     PURL_ENCODING_TYPE  pUrlEncoding
    );

NTSTATUS
HttpFindUrlToken(
    IN  PURL_C14N_CONFIG    pCfg,
    IN  PCUCHAR             pBuffer,
    IN  ULONG               BufferLength,
    OUT PUCHAR*             ppTokenStart,
    OUT PULONG              pTokenLength,
    OUT PBOOLEAN            pRawUrlClean
    );

NTSTATUS
HttpParseUrl(
    IN  PURL_C14N_CONFIG    pCfg,
    IN  PCWSTR              pUrl,
    IN  ULONG               UrlLength,
    IN  BOOLEAN             TrailingSlashReqd,
    IN  BOOLEAN             ForceRoutingIP,
    OUT PHTTP_PARSED_URL    pParsedUrl
    );

NTSTATUS
HttpNormalizeParsedUrl(
    IN OUT PHTTP_PARSED_URL pParsedUrl,
    IN     PURL_C14N_CONFIG pCfg,
    IN     BOOLEAN          ForceCopy,
    IN     BOOLEAN          FreeOriginalUrl,
    IN     BOOLEAN          ForceRoutingIP,
    IN     POOL_TYPE        PoolType,
    IN     ULONG            PoolTag
    );

PCSTR
HttpSiteTypeToString(
    HTTP_URL_SITE_TYPE SiteType
    );

#endif // _C14N_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\inc\sockdecl.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    SockDecl.h

Abstract:

    Make SOCKADDR declarations available in the kernel

Author:

    George V. Reilly (GeorgeRe)     19-Nov-2001

Revision History:

--*/


#ifndef _SOCKDECL_H_
#define _SOCKDECL_H_

// BUGBUG: these should be present in kernel headers, such as <ipexport.h>
// Types adapted for compatibility with kernel types (u_short -> USHORT, etc).
//

#ifndef s_addr

struct in_addr {
        union {
                struct { UCHAR  s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; }           S_un_w;
                ULONG                                  S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

#endif // !s_addr


#ifndef s6_addr

struct in6_addr {
    union {
        UCHAR  Byte[16];
        USHORT Word[8];
    } u;
};

#define _S6_un     u
#define _S6_u8     Byte
#define s6_addr    _S6_un._S6_u8

#endif // s6_addr


typedef struct sockaddr {
    SHORT           sa_family;      // address family
    UCHAR           sa_data[14];    // up to 14 bytes of direct address
} SOCKADDR,    *PSOCKADDR;

typedef struct sockaddr_in {
    SHORT           sin_family;     // AF_INET or TDI_ADDRESS_TYPE_IP (2)
    USHORT          sin_port;       // Transport level port number
    struct in_addr  sin_addr;       // IPv6 address
    UCHAR           sin_zero[8];    // Padding. mbz.
} SOCKADDR_IN, *PSOCKADDR_IN;

typedef struct sockaddr_in6 {
    SHORT           sin6_family;    // AF_INET6 or TDI_ADDRESS_TYPE_IP6 (23)
    USHORT          sin6_port;      // Transport level port number
    ULONG           sin6_flowinfo;  // IPv6 flow information
    struct in6_addr sin6_addr;      // IPv6 address
    ULONG           sin6_scope_id;  // set of interfaces for a scope
} SOCKADDR_IN6,*PSOCKADDR_IN6;

#define SOCKADDR_ADDRESS_LENGTH_IP   sizeof(struct sockaddr_in)
#define SOCKADDR_ADDRESS_LENGTH_IP6  sizeof(struct sockaddr_in6)

/* Macro that works for both IPv4 and IPv6 */
#define SS_PORT(ssp) (((struct sockaddr_in*)(ssp))->sin_port)

#ifndef AF_INET
# define AF_INET  TDI_ADDRESS_TYPE_IP
# define AF_INET6 TDI_ADDRESS_TYPE_IP6
#endif

#endif // _SOCKDECL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\lib\precomp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for UL. It includes all other
    necessary header files for UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tdi.h>

#include <rtutils.h>

#define HTTPAPI_LINKAGE
#include <http.h>
#include <httpp.h>
#include <httpioctl.h>

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\inc\utf8.h ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    Utf8.h

Abstract:

    UTF-8 manipulation routines

Author:

    George V. Reilly (GeorgeRe)     01-Apr-2002

Revision History:

--*/


#ifndef __UTF_8_H__
#define __UTF_8_H__

//
//  Declarations for UTF-8 Encoding
//

extern  const UCHAR Utf8OctetCount[256];

#define UTF8_OCTET_COUNT(c)     (Utf8OctetCount[(UCHAR)(c)])

#define UTF8_1_MAX            0x00007f  // max UTF-8 1-byte sequence
#define UTF8_2_MAX            0x0007ff  // max UTF-8 2-byte sequence
#define UTF8_3_MAX            0x00ffff  // max UTF-8 3-byte sequence
#define UTF8_4_MAX            0x10ffff  // max UTF-8 4-byte sequence

#define UTF8_1ST_OF_2         0xc0    // 110x xxxx - 0xCn or 0xDn
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx - 0xEn
#define UTF8_1ST_OF_4         0xf0    // 1111 0xxx - 0xFn, 0 <= n <= 7
#define UTF8_TRAIL            0x80    // 10xx xxxx - 0x8n, 0x9n, 0xAn, or 0xBn

#define IS_UTF8_SINGLETON(ch)       (((UCHAR) (ch)) <= UTF8_1_MAX)
#define IS_UTF8_1ST_BYTE_OF_2(ch)   ((((UCHAR) (ch)) & 0xe0) == UTF8_1ST_OF_2)
#define IS_UTF8_1ST_BYTE_OF_3(ch)   ((((UCHAR) (ch)) & 0xf0) == UTF8_1ST_OF_3)
#define IS_UTF8_1ST_BYTE_OF_4(ch)   ((((UCHAR) (ch)) & 0xf8) == UTF8_1ST_OF_4)
#define IS_UTF8_TRAILBYTE(ch)       ((((UCHAR) (ch)) & 0xc0) == UTF8_TRAIL)

#define HIGHER_6_BIT(u)       (((u) & 0x3f000) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x00fc0) >> 6)
#define LOWER_6_BIT(u)        ((u)  & 0x0003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

#define HIGH_NONCHAR_START    0x0
#define HIGH_NONCHAR_END      0x10
#define LOW_NONCHAR_BOM       0xfffe
#define LOW_NONCHAR_BITS      0xffff
#define LOW_NONCHAR_START     0xfdd0
#define LOW_NONCHAR_END       0xfdef

#define IS_UNICODE_NONCHAR(c) \
    ( (((LOW_NONCHAR_BOM & (c)) == LOW_NONCHAR_BOM) &&              \
      (((c) >> 16) <= HIGH_NONCHAR_END))                            \
      || ((LOW_NONCHAR_START <= (c)) && ((c) <= LOW_NONCHAR_END)) )


VOID
HttpInitializeUtf8(
    VOID
    );

ULONG
HttpUnicodeToUTF8(
    IN  PCWSTR  lpSrcStr,
    IN  LONG    cchSrc,
    OUT LPSTR   lpDestStr,
    IN  LONG    cchDest
    );

NTSTATUS
HttpUTF8ToUnicode(
    IN     LPCSTR lpSrcStr,
    IN     LONG   cchSrc,
       OUT LPWSTR lpDestStr,
    IN OUT PLONG  pcchDest,
    IN     ULONG  dwFlags
    );

NTSTATUS
HttpUcs4toUtf16(
    IN  ULONG   UnicodeChar, 
    OUT PWCHAR  pHighSurrogate, 
    OUT PWCHAR  pLowSurrogate
    );

ULONG
HttpUnicodeToUTF8Count(
    IN LPCWSTR pwszIn,
    IN ULONG   dwInLen,
    IN BOOLEAN bEncode
    );

NTSTATUS
HttpUnicodeToUTF8Encode(
    IN  LPCWSTR pwszIn,
    IN  ULONG   dwInLen,
    OUT PUCHAR  pszOut,
    IN  ULONG   dwOutLen,
    OUT PULONG  pdwOutLen,
    IN  BOOLEAN bEncode
    );

NTSTATUS
HttpUtf8RawBytesToUnicode(
    IN  PCUCHAR pOctetArray,
    IN  ULONG   SourceLength,
    OUT PULONG  pUnicodeChar,
    OUT PULONG  pOctetsToSkip
    );

#endif // __UTF_8_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\common\usermode\cmndbgu.c ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    CmnDbgU.c

Abstract:

    Debug code for CmnUser.lib

Author:

    George V. Reilly (GeorgeRe)     16-Jan-2002

Revision History:

--*/


#include "precomp.h"


BOOLEAN g_UlVerboseErrors = TRUE;
BOOLEAN g_UlBreakOnError  = TRUE;
ULONGLONG g_UlDebug         = 0;

ULONG   g_BytesAllocated, g_BytesFreed;
ULONG   g_NumAllocs,      g_NumFrees;


PCSTR
HttpCmnpDbgFindFilePart(
    IN PCSTR pPath
    )
{
    // Strip off the path from the path.
    PCSTR pFilePart = strrchr( pPath, '\\' );

    return (pFilePart == NULL) ? pPath : pFilePart + 1;

}   // HttpCmnpDbgFindFilePart



VOID
__cdecl
HttpCmnDbgPrint(
    IN PCH Format,
    ...
    )
{
#define PRINTF_BUFFER_LEN 512
    va_list arglist;
    CHAR Buffer[PRINTF_BUFFER_LEN];
    int cb;

    va_start(arglist, Format);

    cb = _vsnprintf((char*) Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    if (cb < 0)
    {
        cb = sizeof(Buffer);
    }

    // _vsnprintf doesn't always NUL-terminate the buffer
    Buffer[DIMENSION(Buffer)-1] = '\0';

    OutputDebugStringA(Buffer);
} // HttpCmnDbgPrint


VOID
HttpCmnDbgAssert(
    PCSTR   pszAssert,
    PCSTR   pszFilename,
    ULONG   LineNumber
    )
{
    HttpCmnDbgPrint(
        "Assertion failed: %s:%lu: %s\n",
        HttpCmnpDbgFindFilePart( pszFilename ), LineNumber, pszAssert
        );

    DebugBreak();
} // HttpCmnDbgAssert



NTSTATUS
HttpCmnDbgStatus(
    NTSTATUS    Status,
    PCSTR       pszFilename,
    ULONG       LineNumber
    )
{
    if (!NT_SUCCESS(Status))
    {
        if (g_UlVerboseErrors)
        {
            HttpCmnDbgPrint(
                "HttpCmnDbgStatus: %s:%lu returning 0x%08lx\n",
                HttpCmnpDbgFindFilePart( pszFilename ),
                LineNumber,
                Status
                );
        }

        if (g_UlBreakOnError)
        {
            DebugBreak();
        }
    }

    return Status;

} // HttpCmnDbgStatus



VOID
HttpCmnDbgBreakOnError(
    PCSTR   pszFilename,
    ULONG   LineNumber
    )
{
    if (g_UlBreakOnError)
    {
        HttpCmnDbgPrint("HttpCmnDebugBreakOnError @ %s:%lu\n",
                HttpCmnpDbgFindFilePart( pszFilename ),
                LineNumber
                );
        DebugBreak();
    }
}

VOID
HttpCmnInitAllocator(
    VOID
    )
{
    g_BytesAllocated = g_BytesFreed = 0;
    g_NumAllocs = g_NumFrees = 0;
}



VOID
HttpCmnTermAllocator(
    VOID
    )
{
    // ASSERT(g_BytesAllocated == g_BytesFreed);
    ASSERT(g_NumAllocs == g_NumFrees);
}



PVOID
HttpCmnAllocate(
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumBytes,
    IN ULONG     PoolTag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber)
{
    PVOID pMem = HeapAlloc(GetProcessHeap(), 0, NumBytes);

    // CODEWORK: steal the debug header/trailer stuff from ..\sys\debug.c
    // or migrate it into ..\common

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(PoolTag);
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    if (NULL != pMem)
    {
        InterlockedExchangeAdd((PLONG) &g_BytesAllocated, (LONG) NumBytes);
        InterlockedIncrement((PLONG) &g_NumAllocs);
    }

//  UrlAclTrace("Allocated: %p\n", pMem);

    return pMem;
} // HttpCmnAllocate



VOID
HttpCmnFree(
    IN PVOID   pMem,
    IN ULONG   PoolTag,
    IN PCSTR   pFileName,
    IN USHORT  LineNumber)
{
    UNREFERENCED_PARAMETER(PoolTag);
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    if (NULL != pMem)
    {
        SIZE_T NumBytes = 0;    // BUGBUG

        InterlockedExchangeAdd((PLONG) &g_BytesFreed, (LONG) NumBytes);
        InterlockedIncrement((PLONG) &g_NumFrees);
    }

//  UrlAclTrace("Freed: %p\n", pMem);

    HeapFree(GetProcessHeap(), 0, pMem);
} // HttpCmnFree
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\inc\pooltag.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    PoolTag.h

Abstract:

    This module contains PoolTag definitions for Http.Sys

Author:

    George V. Reilly (GeorgeRe)       16-Jan-2002

Revision History:

--*/


#ifndef _POOLTAG_H_
#define _POOLTAG_H_

//
// A literal constant 'abcd' will show up as 'dcba' in a hex dump with dc
// Reverse the letters so they'll show up the right way in the dump.
//

#define REVERSE_CHAR_CONSTANT(tag)                  \
    ((ULONG) (  (( (tag) & 0xFF000000) >> 24)       \
              | (( (tag) & 0x00FF0000) >>  8)       \
              | (( (tag) & 0x0000FF00) <<  8)       \
              | (( (tag) & 0x000000FF) << 24) ) )

C_ASSERT((ULONG) 'dcba' == REVERSE_CHAR_CONSTANT('abcd'));

#ifndef MAKE_POOL_TAG
# define MAKE_POOL_TAG(tag)   ( REVERSE_CHAR_CONSTANT(tag) )
#endif


// Toggle the case of the first two letters from 'Ul'->'uL' or 'Uc'->'uC'
#define MAKE_FREE_TAG(Tag)  ((Tag) ^ 0x00002020u)

#define IS_VALID_TAG(Tag)   \
    (((Tag) & 0x0000ffff) == 'lU' || ((Tag) & 0x0000ffff) == 'cU')

//
// Make a free structure signature from a valid signature.
//

#define MAKE_SIGNATURE(sig)         REVERSE_CHAR_CONSTANT(sig)
#define MAKE_FREE_SIGNATURE(sig)    ((sig) ^ 0x20202020u)



//
// Pool Tags
//
// NOTE: Keep these reverse sorted by tag so it's easy to see dup's
//
// If you add, change, or remove a pool tag, please make the corresponding
// change to ..\sys\pooltag.txt
//

#define UC_AUTH_CACHE_POOL_TAG                  MAKE_POOL_TAG( 'Ucac' )

#define UC_CLIENT_CONNECTION_POOL_TAG           MAKE_POOL_TAG( 'UcCO' )
#define UC_HEADER_FOLDING_POOL_TAG              MAKE_POOL_TAG( 'Uchf' )
#define UC_MULTIPART_STRING_BUFFER_POOL_TAG     MAKE_POOL_TAG( 'Ucmp' )

#define UC_HTTP_RECEIVE_RESPONSE_POOL_TAG       MAKE_POOL_TAG( 'Ucre' )
#define UC_RESPONSE_APP_BUFFER_POOL_TAG         MAKE_POOL_TAG( 'Ucrp' )
#define UC_REQUEST_POOL_TAG                     MAKE_POOL_TAG( 'Ucrq' )

#define UC_PROCESS_SERVER_CONNECTION_POOL_TAG   MAKE_POOL_TAG( 'UcSC' )
#define UC_COMMON_SERVER_INFORMATION_POOL_TAG   MAKE_POOL_TAG( 'UcSc' )
#define SERVER_NAME_BUFFER_POOL_TAG             MAKE_POOL_TAG( 'UcSN' )
#define UC_PROCESS_SERVER_INFORMATION_POOL_TAG  MAKE_POOL_TAG('UcSP')
#define UC_SSPI_POOL_TAG                        MAKE_POOL_TAG( 'UcSp' )
#define UC_SSL_CERT_DATA_POOL_TAG               MAKE_POOL_TAG( 'UcSS' )
#define UC_SERVER_INFO_TABLE_POOL_TAG           MAKE_POOL_TAG( 'UcST' )

#define UC_TRANSPORT_ADDRESS_POOL_TAG           MAKE_POOL_TAG( 'Ucta' )
#define UC_RESPONSE_TDI_BUFFER_POOL_TAG         MAKE_POOL_TAG( 'Uctd' )
#define UC_ENTITY_POOL_TAG                      MAKE_POOL_TAG( 'Ucte' )
#define UC_TDI_OBJECTS_POOL_TAG                 MAKE_POOL_TAG( 'Ucto' )


#define UL_AUXILIARY_BUFFER_POOL_TAG            MAKE_POOL_TAG( 'UlAB' )
#define UL_APP_POOL_OBJECT_POOL_TAG             MAKE_POOL_TAG( 'UlAO' )
#define UL_APP_POOL_PROCESS_POOL_TAG            MAKE_POOL_TAG( 'UlAP' )

#define UL_BINARY_LOG_FILE_ENTRY_POOL_TAG       MAKE_POOL_TAG( 'UlBL' )
#define UL_BUFFER_IO_POOL_TAG                   MAKE_POOL_TAG( 'UlBO' )

#define UL_CONTROL_CHANNEL_POOL_TAG             MAKE_POOL_TAG( 'UlCC' )
#define UL_CG_TREE_ENTRY_POOL_TAG               MAKE_POOL_TAG( 'UlCE' )
#define UL_CG_TREE_HEADER_POOL_TAG              MAKE_POOL_TAG( 'UlCH' )
#define UL_CG_URL_INFO_POOL_TAG                 MAKE_POOL_TAG( 'UlCI' )
#define UL_CG_OBJECT_POOL_TAG                   MAKE_POOL_TAG( 'UlCJ' )
#define UL_CHUNK_TRACKER_POOL_TAG               MAKE_POOL_TAG( 'UlCK' )
#define UL_CG_LOGDIR_POOL_TAG                   MAKE_POOL_TAG( 'UlCL' )
#define UL_CONNECTION_REF_TRACE_LOG_POOL_TAG    MAKE_POOL_TAG( 'UlCl' )
#define UL_CONNECTION_POOL_TAG                  MAKE_POOL_TAG( 'UlCO' )
#define UL_CG_TIMESTAMP_POOL_TAG                MAKE_POOL_TAG( 'UlCT' )
#define UL_CONNECTION_COUNT_ENTRY_POOL_TAG      MAKE_POOL_TAG( 'UlCY' )

#define UL_DEBUG_POOL_TAG                       MAKE_POOL_TAG( 'UlDB' )
#define UL_DATA_CHUNK_POOL_TAG                  MAKE_POOL_TAG( 'UlDC' )
#define UL_DEBUG_MDL_POOL_TAG                   MAKE_POOL_TAG( 'UlDM' )
#define UL_DISCONNECT_OBJECT_POOL_TAG           MAKE_POOL_TAG( 'UlDO' )
#define UL_DEFERRED_REMOVE_ITEM_POOL_TAG        MAKE_POOL_TAG( 'UlDR' )
#define UL_DEBUG_THREAD_POOL_TAG                MAKE_POOL_TAG( 'UlDT' )

#define UL_ERROR_LOG_BUFFER_POOL_TAG            MAKE_POOL_TAG( 'UlEB' )
#define UL_ERROR_LOG_FILE_ENTRY_POOL_TAG        MAKE_POOL_TAG( 'UlEL' )
#define UL_ENDPOINT_POOL_TAG                    MAKE_POOL_TAG( 'UlEP' )

#define UL_FORCE_ABORT_ITEM_POOL_TAG            MAKE_POOL_TAG( 'UlFA' )
#define UL_FILE_CACHE_ENTRY_POOL_TAG            MAKE_POOL_TAG( 'UlFC' )
#define URI_FILTER_CONTEXT_POOL_TAG             MAKE_POOL_TAG( 'Ulfc' )
#define UL_NONCACHED_FILE_DATA_POOL_TAG         MAKE_POOL_TAG( 'UlFD' )
#define UL_COPY_SEND_DATA_POOL_TAG              MAKE_POOL_TAG( 'UlCP' )
#define UL_FILTER_PROCESS_POOL_TAG              MAKE_POOL_TAG( 'UlFP' )
#define UL_FILTER_RECEIVE_BUFFER_POOL_TAG       MAKE_POOL_TAG( 'UlFR' )
#define UL_FILTER_CHANNEL_POOL_TAG              MAKE_POOL_TAG( 'UlFT' )
#define UL_FULL_TRACKER_POOL_TAG                MAKE_POOL_TAG( 'UlFU' )
#define UX_FILTER_WRITE_TRACKER_POOL_TAG        MAKE_POOL_TAG( 'UlFW' )

#define UL_HTTP_CONNECTION_POOL_TAG             MAKE_POOL_TAG( 'UlHC' )
#define UL_HTTP_CONNECTION_REF_TRACE_LOG_POOL_TAG  MAKE_POOL_TAG( 'UlHc' )
#define UL_INTERNAL_REQUEST_REF_TRACE_LOG_POOL_TAG MAKE_POOL_TAG( 'UlHL' )
#define UL_INTERNAL_REQUEST_POOL_TAG            MAKE_POOL_TAG( 'UlHR' )
#define UL_HASH_TABLE_POOL_TAG                  MAKE_POOL_TAG( 'UlHT' )
#define HEADER_VALUE_POOL_TAG                   MAKE_POOL_TAG( 'UlHV' )

#define UL_IRP_CONTEXT_POOL_TAG                 MAKE_POOL_TAG( 'UlIC' )
#define UL_CONN_ID_TABLE_POOL_TAG               MAKE_POOL_TAG( 'UlID' )
#define UL_INTERNAL_RESPONSE_POOL_TAG           MAKE_POOL_TAG( 'UlIR' )

#define UL_LOCAL_ALLOC_POOL_TAG                 MAKE_POOL_TAG( 'UlLA' )
#define UL_LOG_FIELD_POOL_TAG                   MAKE_POOL_TAG( 'UlLD' )
#define UL_LOG_FILE_ENTRY_POOL_TAG              MAKE_POOL_TAG( 'UlLF' )
#define UL_LOG_GENERIC_POOL_TAG                 MAKE_POOL_TAG( 'UlLG' )
#define UL_LOG_FILE_HANDLE_POOL_TAG             MAKE_POOL_TAG( 'UlLH' )
#define UL_LOG_FILE_BUFFER_POOL_TAG             MAKE_POOL_TAG( 'UlLL' )
#define UL_ANSI_LOG_DATA_BUFFER_POOL_TAG        MAKE_POOL_TAG( 'UlLS' )
#define UL_BINARY_LOG_DATA_BUFFER_POOL_TAG      MAKE_POOL_TAG( 'UlLT' )
#define UL_LOG_VOLUME_QUERY_POOL_TAG            MAKE_POOL_TAG( 'UlLZ' )

#define UL_NSGO_POOL_TAG                        MAKE_POOL_TAG( 'UlNO' )
#define UL_NONPAGED_DATA_POOL_TAG               MAKE_POOL_TAG( 'UlNP' )

#define UL_OPAQUE_ID_TABLE_POOL_TAG             MAKE_POOL_TAG( 'UlOT' )

#define UL_APOOL_PROC_BINDING_POOL_TAG          MAKE_POOL_TAG( 'UlPB' )
#define UL_PIPELINE_POOL_TAG                    MAKE_POOL_TAG( 'UlPL' )
#define UL_PORT_SCHEME_TABLE_POOL_TAG           MAKE_POOL_TAG( 'UlPS' )

#define UL_TCI_FILTER_POOL_TAG                  MAKE_POOL_TAG( 'UlQF' )
#define UL_TCI_GENERIC_POOL_TAG                 MAKE_POOL_TAG( 'UlQG' )
#define UL_TCI_INTERFACE_POOL_TAG               MAKE_POOL_TAG( 'UlQI' )
#define UL_TCI_FLOW_POOL_TAG                    MAKE_POOL_TAG( 'UlQL' )
#define UL_TCI_INTERFACE_REF_TRACE_LOG_POOL_TAG MAKE_POOL_TAG( 'UlQR' )
#define UL_TCI_TRACKER_POOL_TAG                 MAKE_POOL_TAG( 'UlQT' )
#define UL_TCI_WMI_POOL_TAG                     MAKE_POOL_TAG( 'UlQW' )

#define UL_RCV_BUFFER_POOL_TAG                  MAKE_POOL_TAG( 'UlRB' )
#define UL_REGISTRY_DATA_POOL_TAG               MAKE_POOL_TAG( 'UlRD' )
#define UL_REQUEST_BODY_BUFFER_POOL_TAG         MAKE_POOL_TAG( 'UlRE' )
#define UL_REQUEST_BUFFER_POOL_TAG              MAKE_POOL_TAG( 'UlRP' )
#define UL_REF_REQUEST_BUFFER_POOL_TAG          MAKE_POOL_TAG( 'UlRR' )
#define UL_NONPAGED_RESOURCE_POOL_TAG           MAKE_POOL_TAG( 'UlRS' )
#define UL_REF_TRACE_LOG_POOL_TAG               MAKE_POOL_TAG( 'UlRT' )

#define SUB_AUTH_ARRAY_POOL_TAG                 MAKE_POOL_TAG( 'UlSa' )
#define UL_SSL_CERT_DATA_POOL_TAG               MAKE_POOL_TAG( 'UlSC' )
#define UL_SSL_INFO_POOL_TAG                    MAKE_POOL_TAG( 'UlSI' )
#define UL_SECURITY_DATA_POOL_TAG               MAKE_POOL_TAG( 'UlSD' )
#define SID_POOL_TAG                            MAKE_POOL_TAG( 'UlSd' )
#define UL_STRING_LOG_BUFFER_POOL_TAG           MAKE_POOL_TAG( 'UlSl' )
#define UL_STRING_LOG_POOL_TAG                  MAKE_POOL_TAG( 'UlSL' )
#define UL_SITE_COUNTER_ENTRY_POOL_TAG          MAKE_POOL_TAG( 'UlSO' )
#define UL_SIMPLE_STATUS_ITEM_POOL_TAG          MAKE_POOL_TAG( 'UlSS' )

#define UL_ADDRESS_POOL_TAG                     MAKE_POOL_TAG( 'UlTA' )
#define UL_TRANSPORT_ADDRESS_POOL_TAG           MAKE_POOL_TAG( 'UlTD' )
#define UL_THREAD_TRACKER_POOL_TAG              MAKE_POOL_TAG( 'UlTT' )

#define URL_BUFFER_POOL_TAG                     MAKE_POOL_TAG( 'UlUB' )
#define UL_URI_CACHE_ENTRY_POOL_TAG             MAKE_POOL_TAG( 'UlUC' )
#define HTTP_URL_NAMESPACE_ENTRY_POOL_TAG       MAKE_POOL_TAG( 'UlUE' )
#define UL_HTTP_UNKNOWN_HEADER_POOL_TAG         MAKE_POOL_TAG( 'UlUH' )
#define URL_POOL_TAG                            MAKE_POOL_TAG( 'UlUL' )
#define UL_URLMAP_POOL_TAG                      MAKE_POOL_TAG( 'UlUM' )
#define HTTP_URL_NAMESPACE_NODE_POOL_TAG        MAKE_POOL_TAG( 'UlUN' )
#define UL_UNICODE_STRING_POOL_TAG              MAKE_POOL_TAG( 'UlUS' )

#define UL_VIRTHOST_POOL_TAG                    MAKE_POOL_TAG( 'UlVH' )

#define UL_WORK_CONTEXT_POOL_TAG                MAKE_POOL_TAG( 'UlWC' )
#define UL_WORK_ITEM_POOL_TAG                   MAKE_POOL_TAG( 'UlWI' )

#endif // _POOLTAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\inc\httpcmn.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    HttpCmn.h

Abstract:

    Declare general routines that appear on both sides of the
    HTTP blood-brain barrier (i.e., in both http.sys and httpapi.dll),
    but are not exported.

Author:

    George V. Reilly (GeorgeRe)     11-Dec-2001

Revision History:

--*/

#ifndef _HTTPCMN_H_
#define _HTTPCMN_H_


#include <tuneprefix.h>

#define PREFAST_ASSUME(cond, reason)    PREFIX_ASSUME(cond, reason)
#define PREFAST_NOT_REACHED(reason)     PREFIX_NOT_REACHED(reason)


#if KERNEL_PRIV

# define HttpCmnDebugBreak()            DbgBreakPoint()
# define HttpCmnDebugBreakOnError()     UlDbgBreakOnError(__FILE__, __LINE__)

#else // !KERNEL_PRIV => usermode code

VOID
__cdecl
HttpCmnDbgPrint(
    IN PCH Format,
    ...
    );

VOID
HttpCmnDbgAssert(
    PCSTR   pszAssert,
    PCSTR   pszFilename,
    ULONG   LineNumber
    );

NTSTATUS
HttpCmnDbgStatus(
    NTSTATUS    Status,
    PCSTR       pszFilename,
    ULONG       LineNumber
    );

VOID
HttpCmnDbgBreakOnError(
    PCSTR   pszFilename,
    ULONG   LineNumber
    );

# define HttpCmnDebugBreak()            DebugBreak()
# define HttpCmnDebugBreakOnError()     \
    HttpCmnDbgBreakOnError(__FILE__, __LINE__)

# define WriteGlobalStringLog   HttpCmnDbgPrint

#if HTTPAPI
# define PAGED_CODE()           NOP_FUNCTION

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool
} POOL_TYPE;

#endif // HTTPAPI

#endif // !KERNEL_PRIV


#if DBG

//
// Debug spew control.
// If you change or add a flag, please update the FlagTable
// in ..\util\tul.c.
//

#define UL_DEBUG_OPEN_CLOSE                 0x0000000000000001ui64
#define UL_DEBUG_SEND_RESPONSE              0x0000000000000002ui64
#define UL_DEBUG_SEND_BUFFER                0x0000000000000004ui64
#define UL_DEBUG_TDI                        0x0000000000000008ui64

#define UL_DEBUG_FILE_CACHE                 0x0000000000000010ui64
#define UL_DEBUG_CONFIG_GROUP_FNC           0x0000000000000020ui64
#define UL_DEBUG_CONFIG_GROUP_TREE          0x0000000000000040ui64
#define UL_DEBUG_REFCOUNT                   0x0000000000000080ui64

#define UL_DEBUG_HTTP_IO                    0x0000000000000100ui64
#define UL_DEBUG_ROUTING                    0x0000000000000200ui64
#define UL_DEBUG_URI_CACHE                  0x0000000000000400ui64
#define UL_DEBUG_PARSER                     0x0000000000000800ui64

#define UL_DEBUG_SITE                       0x0000000000001000ui64
#define UL_DEBUG_WORK_ITEM                  0x0000000000002000ui64
#define UL_DEBUG_FILTER                     0x0000000000004000ui64
#define UL_DEBUG_LOGGING                    0x0000000000008000ui64

#define UL_DEBUG_TC                         0x0000000000010000ui64
#define UL_DEBUG_OPAQUE_ID                  0x0000000000020000ui64
#define UL_DEBUG_PERF_COUNTERS              0x0000000000040000ui64
#define UL_DEBUG_URL_ACL                    0x0000000000080000ui64

#define UL_DEBUG_TIMEOUTS                   0x0000000000100000ui64
#define UL_DEBUG_LIMITS                     0x0000000000200000ui64
#define UL_DEBUG_LARGE_MEM                  0x0000000000400000ui64
#define UL_DEBUG_IOCTL                      0x0000000000800000ui64

#define UL_DEBUG_LOGBYTES                   0x0000000001000000ui64
#define UL_DEBUG_ETW                        0x0000000002000000ui64
#define UL_DEBUG_AUTH_CACHE                 0x0000000004000000ui64
#define UL_DEBUG_SERVINFO                   0x0000000008000000ui64

#define UL_DEBUG_BINARY_LOGGING             0x0000000010000000ui64
#define UL_DEBUG_TDI_STATS                  0x0000000020000000ui64
#define UL_DEBUG_UL_ERROR                   0x0000000040000000ui64
#define UL_DEBUG_VERBOSE                    0x0000000080000000ui64

#define UL_DEBUG_ERROR_LOGGING              0x0000000100000000ui64
#define UL_DEBUG_LOG_UTIL                   0x0000000200000000ui64


#undef IF_DEBUG
#define IF_DEBUG(a)                 \
    if ( ((UL_DEBUG_ ## a) & g_UlDebug) != 0 )
#define IF_DEBUG2EITHER(a, b)       \
    if ( (((UL_DEBUG_ ## a) | (UL_DEBUG_ ## b)) & g_UlDebug) != 0 )
#define IF_DEBUG2BOTH(a, b)         \
    if ( (((UL_DEBUG_ ## a) | (UL_DEBUG_ ## b)) & g_UlDebug) \
         == ((UL_DEBUG_ ## a) | (UL_DEBUG_ ## b)) )


//
// Tracing.
//

extern ULONGLONG g_UlDebug;

// Do NOT call UlTrace(%S, %ws, %ls, %wZ, %wc, %lc, or %C)
// while a spinlock is held. The RtlUnicodeToMultiByte routines are
// pageable and you may bugcheck.

# define UlTrace(a, _b_)                                                    \
    do                                                                      \
    {                                                                       \
        IF_DEBUG(##a)                                                       \
        {                                                                   \
            WriteGlobalStringLog _b_ ;                                      \
        }                                                                   \
    } while (0, 0)

# define UlTrace2Either(a1, a2, _b_)                                        \
    do                                                                      \
    {                                                                       \
        IF_DEBUG2EITHER(##a1, ##a2)                                         \
        {                                                                   \
            WriteGlobalStringLog _b_ ;                                      \
        }                                                                   \
    } while (0, 0)

# define UlTrace2Both(a1, a2, _b_)                                          \
    do                                                                      \
    {                                                                       \
        IF_DEBUG2BOTH(##a1, ##a2)                                           \
        {                                                                   \
            WriteGlobalStringLog _b_ ;                                      \
        }                                                                   \
    } while (0, 0)

# define UlTraceVerbose(a, _b_)  UlTrace2Both(a, VERBOSE, _b_)

# define UlTraceError(a, _b_)                                               \
    do                                                                      \
    {                                                                       \
        IF_DEBUG2EITHER(##a, ##UL_ERROR)                                    \
        {                                                                   \
            WriteGlobalStringLog _b_ ;                                      \
            HttpCmnDebugBreakOnError();                                     \
        }                                                                   \
    } while (0, 0)

VOID
HttpFillBuffer(
    PUCHAR pBuffer,
    SIZE_T BufferLength
    );

# define HTTP_FILL_BUFFER(pBuffer, BufferLength)    \
    HttpFillBuffer((PUCHAR) pBuffer, BufferLength)

# if !KERNEL_PRIV

#  define RETURN(status)                                \
        return HttpCmnDbgStatus((status), __FILE__, __LINE__)

#  undef ASSERT
#  define ASSERT(x)                                     \
        ((void) ((x) || (HttpCmnDbgAssert(#x, __FILE__, __LINE__), 0) ))

# endif // !KERNEL_PRIV


#else  // !DBG

# undef  IF_DEBUG
# define IF_DEBUG(a)                    if (FALSE)
# define IF_DEBUG2EITHER(a, b)          if (FALSE)
# define IF_DEBUG2BOTH(a, b)            if (FALSE)

# define UlTrace(a, _b_)                NOP_FUNCTION
# define UlTrace2Either(a1, a2, _b_)    NOP_FUNCTION
# define UlTrace2Both(a1, a2, _b_)      NOP_FUNCTION
# define UlTrace3Any(a1, a2, a3, _b_)   NOP_FUNCTION
# define UlTrace3All(a1, a2, a3, _b_)   NOP_FUNCTION
# define UlTraceVerbose(a, _b_)         NOP_FUNCTION
# define UlTraceError(a, _b_)           NOP_FUNCTION

# define HTTP_FILL_BUFFER(pBuffer, BufferLength)    NOP_FUNCTION

# if !KERNEL_PRIV

#  define RETURN(status)    return (status)
#  undef ASSERT
#  define ASSERT(x)         NOP_FUNCTION

# endif // !KERNEL_PRIV

#endif // !DBG

PCSTR
HttpStatusToString(
    NTSTATUS Status
    );


typedef const UCHAR* PCUCHAR;
typedef const VOID*  PCVOID;


VOID
HttpCmnInitializeHttpCharsTable(
    BOOLEAN EnableDBCS
    );

char*
strnchr(
    const char* string,
    char        c,
    size_t      count
    );

wchar_t*
wcsnchr(
    const wchar_t* string,
    wint_t         c,
    size_t         count
    );

// 2^16-1 + '\0'
#define MAX_USHORT_STR          ((ULONG) sizeof("65535"))

// 2^32-1 + '\0'
#define MAX_ULONG_STR           ((ULONG) sizeof("4294967295"))

// 2^64-1 + '\0'
#define MAX_ULONGLONG_STR       ((ULONG) sizeof("18446744073709551615"))

NTSTATUS
HttpStringToULongLong(
    IN  BOOLEAN     IsUnicode,
    IN  PCVOID      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PVOID*      ppTerminator,
    OUT PULONGLONG  pValue
    );

__inline
NTSTATUS
HttpAnsiStringToULongLong(
    IN  PCUCHAR     pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PUCHAR*     ppTerminator,
    OUT PULONGLONG  pValue
    )
{
    return HttpStringToULongLong(
                FALSE,
                pString,
                StringLength,
                LeadingZerosAllowed,
                Base,
                (PVOID*) ppTerminator,
                pValue
                );
}

__inline
NTSTATUS
HttpWideStringToULongLong(
    IN  PCWSTR      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PWSTR*      ppTerminator,
    OUT PULONGLONG  pValue
    )
{
    return HttpStringToULongLong(
                TRUE,
                pString,
                StringLength,
                LeadingZerosAllowed,
                Base,
                (PVOID*) ppTerminator,
                pValue
                );
}

NTSTATUS
HttpStringToULong(
    IN  BOOLEAN     IsUnicode,
    IN  PCVOID      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PVOID*      ppTerminator,
    OUT PULONG      pValue
    );

__inline
NTSTATUS
HttpAnsiStringToULong(
    IN  PCUCHAR     pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PUCHAR*     ppTerminator,
    OUT PULONG      pValue
    )
{
    return HttpStringToULong(
                FALSE,
                pString,
                StringLength,
                LeadingZerosAllowed,
                Base,
                (PVOID*) ppTerminator,
                pValue
                );
}

__inline
NTSTATUS
HttpWideStringToULong(
    IN  PCWSTR      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PWSTR*      ppTerminator,
    OUT PULONG      pValue
    )
{
    return HttpStringToULong(
                TRUE,
                pString,
                StringLength,
                LeadingZerosAllowed,
                Base,
                (PVOID*) ppTerminator,
                pValue
                );
}

NTSTATUS
HttpStringToUShort(
    IN  BOOLEAN     IsUnicode,
    IN  PCVOID      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PVOID*      ppTerminator,
    OUT PUSHORT     pValue
    );

__inline
NTSTATUS
HttpAnsiStringToUShort(
    IN  PCUCHAR     pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PUCHAR*     ppTerminator,
    OUT PUSHORT     pValue
    )
{
    return HttpStringToUShort(
                FALSE,
                pString,
                StringLength,
                LeadingZerosAllowed,
                Base,
                (PVOID*) ppTerminator,
                pValue
                );
}

__inline
NTSTATUS
HttpWideStringToUShort(
    IN  PCWSTR      pString,
    IN  SIZE_T      StringLength,
    IN  BOOLEAN     LeadingZerosAllowed,
    IN  ULONG       Base,
    OUT PWSTR*      ppTerminator,
    OUT PUSHORT     pValue
    )
{
    return HttpStringToUShort(
                TRUE,
                pString,
                StringLength,
                LeadingZerosAllowed,
                Base,
                (PVOID*) ppTerminator,
                pValue
                );
}


//
// ASCII constants
//

#define HT              0x09    // aka TAB
#define LF              0x0A    // aka NL, New Line
#define VT              0x0B    // Vertical TAB
#define FF              0x0C    // Form Feed
#define CR              0x0D    // Carriage Return
#define SP              0x20    // Space
#define DOUBLE_QUOTE    0x22    // "
#define PERCENT         0x25    // %
#define STAR            0x2A    // *
#define HYPHEN          0x2D    // - aka Minus aka Dash
#define DOT             0x2E    // . aka Period aka Full Stop
#define FORWARD_SLASH   0x2F    // /
#define ZERO            0x30    // 0
#define COLON           0x3A    // :
#define SEMI_COLON      0x3B    // ;
#define EQUALS          0x3D    // =
#define QUESTION_MARK   0x3F    // ? aka Query
#define LEFT_BRACKET    0x5B    // [ aka Left Square Bracket
#define BACK_SLASH      0x5C    // \ aka Whack
#define RIGHT_BRACKET   0x5D    // ] aka Right Square Bracket


// Fast toupper() and tolower() macros that work for [A-Z] and [a-z] only

#if DBG

# define UPCASE_CHAR(c)                                             \
    ( (('a' <= (c) && (c) <= 'z')  ||  ('A' <= (c) && (c) <= 'Z'))  \
        ? ((UCHAR) ((c) & 0xdf))                                    \
        : (ASSERT(! "non-alpha UPCASE_CHAR"), 0) )

# define LOCASE_CHAR(c)                                             \
    ( (('A' <= (c) && (c) <= 'Z')  ||  ('a' <= (c) && (c) <= 'z'))  \
        ? ((UCHAR) ((c) | 0x20))                                    \
        : (ASSERT(! "non-alpha LOCASE_CHAR"), 0) )

#else  // !DBG

# define UPCASE_CHAR(c)  ((UCHAR) ((c) & 0xdf))
# define LOCASE_CHAR(c)  ((UCHAR) ((c) | 0x20))

#endif // !DBG

//
// Character classes for HTTP header and URL parsing.
// For header parsing, the definitions are taken from RFC 2616, "HTTP/1.1"
// For URL parsing, the definitions are from RFC 2396, "URI Generic Syntax"
// and RFC 2732, "IPv6 Literals in URLs".
//
// Per RFC 2616, section 2.2, "Basic Rules":
// OCTET = <any 8-bit sequence of data>
// CHAR  = <any US-ASCII character (octets 0 - 127)>
// TEXT  = <any OCTET except CTLs, but including LWS>

// CTL   = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
#define HTTP_CTL_SET                                                \
    "\x00"  "\x01"  "\x02"  "\x03"  "\x04"  "\x05"  "\x06"  "\x07"  \
    "\x08"  "\x09"  "\x0A"  "\x0B"  "\x0C"  "\x0D"  "\x0E"  "\x0F"  \
    "\x10"  "\x11"  "\x12"  "\x13"  "\x14"  "\x15"  "\x16"  "\x17"  \
    "\x18"  "\x19"  "\x1A"  "\x1B"  "\x1C"  "\x1D"  "\x1E"  "\x1F"  \
    "\x7F"

// In the Unicode ISO-10646 character set, these are also control chars
#define UNICODE_C1_SET                                              \
    "\x80"  "\x81"  "\x82"  "\x83"  "\x84"  "\x85"  "\x86"  "\x87"  \
    "\x88"  "\x89"  "\x8A"  "\x8B"  "\x8C"  "\x8D"  "\x8E"  "\x8F"  \
    "\x90"  "\x91"  "\x92"  "\x93"  "\x94"  "\x95"  "\x96"  "\x97"  \
    "\x98"  "\x99"  "\x9A"  "\x9B"  "\x9C"  "\x9D"  "\x9E"  "\x9F"

// UPALPHA = <any US-ASCII uppercase letter "A".."Z">
#define HTTP_UPALPHA_SET            \
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

// LOALPHA = <any US-ASCII lowercase letter "a".."z">
#define HTTP_LOALPHA_SET            \
    "abcdefghijklmnopqrstuvwxyz"

// ALPHA = (UPALPHA | LOALPHA)
#define HTTP_ALPHA_SET              \
    HTTP_UPALPHA_SET HTTP_LOALPHA_SET

// DIGIT = <any US-ASCII digit "0".."9">
#define HTTP_DIGITS_SET             \
    "0123456789"

// ALPHANUM = (ALPHA | DIGIT)
#define HTTP_ALPHANUM_SET           \
    HTTP_ALPHA_SET  HTTP_DIGITS_SET

// HEX = (DIGIT | "A".."F" | "a".."f")
#define HTTP_HEX_SET                \
    HTTP_DIGITS_SET  "ABCDEF"  "abcdef"

// SP = US-ASCII 32, the space character
#define HTTP_SPACE_SET              \
    "\x20"

// LWS = (SP | HT)      -- Linear White Space
// Note: Folding is handled specially
#define HTTP_LWS_SET                \
    HTTP_SPACE_SET  "\t"

// separators = characters that delimit tokens in HTTP headers
// token = 1*<any 7-bit CHAR except CTLs or separators>
#define HTTP_SEPARATORS_SET         \
        "("  ")"  "<"  ">"  "@"     \
        ","  ";"  ":"  "\""  "\\"   \
        "/"  "["  "]"  "?"  "="     \
        "{"  "}"  HTTP_LWS_SET

// Whitespace tokens: (CR | LF | SP | HT)
#define HTTP_WS_TOKEN_SET           \
    "\r"  "\n"  HTTP_LWS_SET

// IsWhite : (CTL | SP)
// this is used by the logger, not the parser.
// Removed the "\xA0", it will break foreign
// language multibyte utf8 sequences.
#define HTTP_ISWHITE_SET            \
    HTTP_CTL_SET  HTTP_SPACE_SET


//
// Now the URL character classes from RFC 2396, as modified by RFC 2732.
//

// Limited set of punctuation marks that can appear literally in URLs
#define URL_MARK_SET                \
    "-"  "_"  "."  "!"  "~"  "*"  "'"  "("  ")"

// Alphanumerics and marks can always appear literally in URLs
#define URL_UNRESERVED_SET          \
    HTTP_ALPHANUM_SET URL_MARK_SET

// RFC2396 describes these characters as `unwise' "because gateways and
// other transport agents are known to sometimes modify such characters,
// or they are used as delimiters".
//
// Note: RFC2732 removed "[" and "]" from the 'unwise' set and added
// them to the 'reserved' set, so that IPv6 literals could be
// expressed in URLs.
#define URL_UNWISE_SET              \
    "{"  "}"  "|"  "\\"  "^"  "`"

// These characters have special meanings if they appear unescaped in a URI
#define URL_RESERVED_SET                    \
    ";"  "/"  "?"  ":"  "@"  "&"  "="  "+"  \
    "$"  ","  "["  "]"

// The delimiters are excluded from URLs because they typically delimit URLs
// when they appear in other contexts.
#define URL_DELIMS_SET              \
    "<"  ">"  "#"  "%"  "\""

// BACK_SLASH, FORWARD_SLASH, PERCENT, DOT, and QUESTION_MARK are
// the "dirty" chars. These are used to determine if the host or URL
// are clean to take the fast path in converting them to Unicode.
// The delimiters are also considered dirty, to simplify the fast path.
// All octets above the US-ASCII range (i.e., >= 128) are also considered dirty
#define URL_DIRTY_SET               \
    "\\"  "/"  "."  "?"  URL_DELIMS_SET

// These characters are not valid in the abspath part of a URL after it has
// been canonicalized to Unicode. CODEWORK: What about '%' (double escaping)?
// According to MSDN, invalid characters in file and directory names are
//      < > : " / \ |
// CODEWORK: temporarily removed ":". Do this smarter.
#define URL_INVALID_SET             \
    HTTP_CTL_SET  UNICODE_C1_SET

// Valid characters in hostnames are letters, digits, and hyphens, per RFC 1034
// We also allow underscores.
#define URL_HOSTNAME_LABEL_LDH_SET  \
    HTTP_ALPHANUM_SET  "-"  "_"

// Characters that are illegal in an NT computer name, as taken from
// NetValidateName(): %sdxroot%\ds\netapi\netlib\nameval.c and
// %sdxroot%\public\internal\base\inc\validc.h
//      "  /  \  [  ]  :  |  <  >  +  =  ;  ,  ?  *   and CTL chars
// Also added " " (SP) and "%" to this list
#define URL_ILLEGAL_COMPUTERNAME_SET            \
    "\"" "/"  "\\" "["  "]"  ":"  "|"  " "  "%" \
    "<"  ">"  "+"  "="  ";"  ","  "?"  "*"      \
    HTTP_CTL_SET


//
// Bit flags in HttpChars[]
//

extern ULONG HttpChars[256];

#define HTTP_CHAR               (1 << 0x00)
#define HTTP_UPCASE             (1 << 0x01)
#define HTTP_LOCASE             (1 << 0x02)
#define HTTP_ALPHA              (HTTP_UPCASE | HTTP_LOCASE)
#define HTTP_DIGIT              (1 << 0x03)
#define HTTP_ALPHANUM           (HTTP_ALPHA | HTTP_DIGIT)
#define HTTP_CTL                (1 << 0x04)
#define HTTP_LWS                (1 << 0x05)
#define HTTP_HEX                (1 << 0x06)
#define HTTP_SEPARATOR          (1 << 0x07)
#define HTTP_TOKEN              (1 << 0x08)
#define HTTP_WS_TOKEN           (1 << 0x09)
#define HTTP_ISWHITE            (1 << 0x0A)
#define HTTP_PRINT              (1 << 0x0B)
#define HTTP_TEXT               (1 << 0x0C)
#define HTTP_DBCS_LEAD_BYTE     (1 << 0x0D)
#define URL_DIRTY               (1 << 0x0E)
#define URL_LEGAL               (1 << 0x0F)
#define URL_TOKEN               (HTTP_ALPHA | HTTP_DIGIT | URL_LEGAL)
#define URL_HOSTNAME_LABEL      (1 << 0x10)
#define URL_INVALID             (1 << 0x11)
#define URL_ILLEGAL_COMPUTERNAME (1 << 0x12)

// Use bits 31,30 in HttpChars[] to perform table lookup in URI canonicalizer
#define HTTP_CHAR_SHIFT         (0x1E)
#define HTTP_CHAR_SLASH         (1 << HTTP_CHAR_SHIFT)
#define HTTP_CHAR_DOT           (2 << HTTP_CHAR_SHIFT)
#define HTTP_CHAR_QM_HASH       (3 << HTTP_CHAR_SHIFT)


//
// These character type macros are safe for 8-bit data only.
// We cast the argument to a UCHAR, so you'll never overflow, but you'll
// get nonsense if you pass in an arbitrary Unicode character. For Unicode
// characters, only the first 128 values (the US-ASCII range) make sense.
//

#define IS_CHAR_TYPE(c, mask)       (HttpChars[(UCHAR)(c)] & (mask))

// CHAR  = <any US-ASCII character (octets 0 - 127)>
#define IS_HTTP_CHAR(c)             IS_CHAR_TYPE(c, HTTP_CHAR)

// HTTP_UPALPHA_SET = <any US-ASCII uppercase letter "A".."Z">
#define IS_HTTP_UPCASE(c)           IS_CHAR_TYPE(c, HTTP_UPCASE)

// HTTP_LOALPHA_SET = <any US-ASCII lowercase letter "a".."z">
#define IS_HTTP_LOCASE(c)           IS_CHAR_TYPE(c, HTTP_LOCASE)

// HTTP_ALPHA_SET = <"A".."Z", "a".."z">
#define IS_HTTP_ALPHA(c)            IS_CHAR_TYPE(c, HTTP_ALPHA)

// HTTP_DIGITS_SET = <any US-ASCII digit "0".."9">
#define IS_HTTP_DIGIT(c)            IS_CHAR_TYPE(c, HTTP_DIGIT)

// HTTP_ALPHANUM_SET = <"A".."Z", "a".."z", "0".."9">
#define IS_HTTP_ALPHANUM(c)         IS_CHAR_TYPE(c, HTTP_ALPHANUM)

// HTTP_CTL_SET = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
#define IS_HTTP_CTL(c)              IS_CHAR_TYPE(c, HTTP_CTL)

// HTTP_LWS_SET = (SP | HT)      -- Linear White Space
#define IS_HTTP_LWS(c)              IS_CHAR_TYPE(c, HTTP_LWS)

// HTTP_HEX_SET = <"0".."9", "A".."F", "a".."f">
#define IS_HTTP_HEX(c)              IS_CHAR_TYPE(c, HTTP_HEX)

// HTTP_SEPARATORS_SET =  (  )  <  >  @ ,  ;  :  "  \ /  [  ]  ?  = {  }  SP HT
#define IS_HTTP_SEPARATOR(c)        IS_CHAR_TYPE(c, HTTP_SEPARATOR)

// token = 1*<any 7-bit CHAR except CTLs or separators>
//   !  #  $  %  &  '  *  +  -  .  0..9  A..Z  ^  _  `  a..z  |  ~
#define IS_HTTP_TOKEN(c)            IS_CHAR_TYPE(c, HTTP_TOKEN)

// HTTP_WS_TOKEN_SET = (CR | LF | SP | HT)
#define IS_HTTP_WS_TOKEN(c)         IS_CHAR_TYPE(c, HTTP_WS_TOKEN)

// HTTP_ISWHITE_SET = (CTL | SP)
#define IS_HTTP_WHITE(c)            IS_CHAR_TYPE(c, HTTP_ISWHITE)

// PRINT = <any OCTET except CTLs, but including SP and HT>
#define IS_HTTP_PRINT(c)            IS_CHAR_TYPE(c, HTTP_PRINT)

// TEXT  = <any OCTET except CTLs, but including SP, HT, CR, and LF>
#define IS_HTTP_TEXT(c)             IS_CHAR_TYPE(c, HTTP_TEXT)

// DBCS lead bytes
#define IS_DBCS_LEAD_BYTE(c)        IS_CHAR_TYPE(c, HTTP_DBCS_LEAD_BYTE)

// URL_DIRTY_SET = \ / % . ?  |  URL_DELIMS_SET
#define IS_URL_DIRTY(c)             IS_CHAR_TYPE(c, URL_DIRTY)

// URL_TOKEN_SET = (HTTP_ALPHA_SET | HTTP_DIGITS_SET | URL_MARK_SET
//                  | URL_RESERVED_SET| URL_UNWISE_SET | % )
#define IS_URL_TOKEN(c)             IS_CHAR_TYPE(c, URL_TOKEN)

// URL_HOSTNAME_LABEL_LDH_SET = (HTTP_ALPHANUM_SET | - | _ )
#define IS_URL_HOSTNAME_LABEL(c)    IS_CHAR_TYPE(c, URL_HOSTNAME_LABEL)

// URL_INVALID_SET = (HTTP_CTL_SET | UNICODE_C1_SET)
#define IS_URL_INVALID(c)           IS_CHAR_TYPE(c, URL_INVALID)

// URL_ILLEGAL_COMPUTERNAME_SET =
//      "  /  \  [  ]  :  |  <  >  +  =  ;  ,  ?  *  and HTTP_CTL_SET
#define IS_URL_ILLEGAL_COMPUTERNAME(c) IS_CHAR_TYPE(c, URL_ILLEGAL_COMPUTERNAME)


#define ASCII_MAX       0x007f
#define ANSI_HIGH_MIN   0x0080
#define ANSI_HIGH_MAX   0x00ff

#define IS_ASCII(c)     ((unsigned) (c) <= ASCII_MAX)
#define IS_ANSI(c)      ((unsigned) (c) <= ANSI_HIGH_MAX)
#define IS_HIGH_ANSI(c) \
    (ANSI_HIGH_MIN <= (unsigned) (c) && (unsigned) (c) <= ANSI_HIGH_MAX)


//
// Other lookup tables
//

extern  WCHAR   FastPopChars[256];
extern  WCHAR   DummyPopChars[256];
extern  WCHAR   FastUpcaseChars[256];
extern  WCHAR   AnsiToUnicodeMap[256];

//
// Length of string literals in chars; e.g., WSCLEN_LIT(L"https://")
// Must NOT be used with char* pointers.
//

#define STRLEN_LIT(sz)        ((USHORT) (sizeof(sz) - sizeof(CHAR)))
#define WCSLEN_LIT_BYTES(wsz) ((USHORT) (sizeof(wsz) - sizeof(WCHAR)))
#define WCSLEN_LIT(wsz)       ((USHORT) (WCSLEN_LIT_BYTES(wsz) / sizeof(WCHAR)))


//
// Calculate the dimension of an array.
//

#define DIMENSION(x) ( sizeof(x) / sizeof(x[0]) )

//
// nice MIN/MAX macros
//

#define MIN(a,b) ( ((a) > (b)) ? (b) : (a) )
#define MAX(a,b) ( ((a) > (b)) ? (a) : (b) )

//
// These definitions allow for a trailing NUL in a counted string,
// such as a UNICODE_STRING, a HTTP_COOKED_URL, or a HTTP_KNOWN_HEADER.
//

#define UNICODE_STRING_MAX_WCHAR_LEN 0x7FFE
#define UNICODE_STRING_MAX_BYTE_LEN (UNICODE_STRING_MAX_WCHAR_LEN*sizeof(WCHAR))
#define ANSI_STRING_MAX_CHAR_LEN     0xFFFE


//
// Cache line requirement.
//

#ifdef _WIN64
# define UL_CACHE_LINE   64
#else
# define UL_CACHE_LINE   32
#endif


//
// The DIFF macro should be used around an expression involving pointer
// subtraction. The expression passed to DIFF is cast to a ULONG type.
// This is safe because we never handle buffers bigger than 4GB,
// even on Win64, and we guarantee that the argument is non-negative.
// DIFF_USHORT is the obvious USHORT variant.
//

#define DIFF(x)             ((ULONG)(x))
#define DIFF_USHORT(x)      ((USHORT)(x))
#define DIFF_ULONGPTR(x)    ((ULONG_PTR)(x))


// 2^16-1 = 65535 = 5 chars = 5 bytes
#define MAX_PORT_LENGTH                    5

// Max size of numeric form of IPv6 address (in chars)
// 1234:6789:1234:6789:1234:6789:123.123.123.123 + '\0'
#define INET6_RAWADDRSTRLEN                  46

// Maximum length of an IPv6 scoped address (in chars)
// INET6_RAWADDRSTRLEN + "%1234567890"
#define MAX_IP_ADDR_STRING_LEN            (INET6_RAWADDRSTRLEN + 11)

// Maximum length of an IPv6 scoped address (in chars)
// "[" + INET6_RAWADDRSTRLEN + "%1234567890" + "]"
#define MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN (MAX_IP_ADDR_STRING_LEN + 2)

// Maximum length of an IPv6 scoped address and port (in chars)
// "[" + MAX_IP_ADDR_STRING_LEN + ":65535]"
#define MAX_IP_ADDR_AND_PORT_STRING_LEN   (MAX_IP_ADDR_STRING_LEN + 8)



VOID
HttpCmnInitAllocator(
    VOID
    );

VOID
HttpCmnTermAllocator(
    VOID
    );

PVOID
HttpCmnAllocate(
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumBytes,
    IN ULONG     PoolTag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber);

VOID
HttpCmnFree(
    IN PVOID   pMem,
    IN ULONG   PoolTag,
    IN PCSTR   pFileName,
    IN USHORT  LineNumber);

#define HTTPP_ALLOC(PoolType, NumBytes, PoolTag)    \
    HttpCmnAllocate((PoolType), (NumBytes), (PoolTag), __FILE__, __LINE__)

#define HTTPP_FREE(pMem, PoolTag)                   \
    HttpCmnFree((pMem), (PoolTag), __FILE__, __LINE__)


#endif // _HTTPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\serviceconfig\makefile.inc ===
$(O)\nlstxt.mc: localmsg.mc
    copy localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\server\precomp.h ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4127)   // condition expression is constant

#include    <windows.h>
#include    <stdio.h>
#include    "http.h"


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\serviceconfig\iplisten.c ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#include "precomp.h"
#pragma hdrstop

//
// Private functions.
//

/***************************************************************************++

Routine Description:
    Prints a record in the IP Listen store.

Arguments:
    pOutput - A pointer to HTTP_SERVICE_CONFIG_URLACL_SET

Return Value:
    None.

--***************************************************************************/
void
PrintIpListenRecords(
    IN PUCHAR pOutput
    )
{
    PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY pListenQuery;
    ULONG                                i;
    DWORD                                Status = NO_ERROR;

    pListenQuery = (PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY) pOutput;

    for(i=0; i<pListenQuery->AddrCount; i++)
    {
        DWORD        dwSockAddrLength;
        WCHAR        IpAddr[MAX_PATH];
        DWORD        dwIpAddrLen;
        PSOCKADDR_IN pSockAddrIn;

        dwIpAddrLen = MAX_PATH * sizeof(WCHAR);

        pSockAddrIn = (PSOCKADDR_IN) 
                    &pListenQuery->AddrList[i];

        // Convert address to string.
        //

        if(pSockAddrIn->sin_family == AF_INET)
        {
            dwSockAddrLength = sizeof(SOCKADDR_IN);
        }
        else if(pSockAddrIn->sin_family == AF_INET6)
        {
            dwSockAddrLength = sizeof(SOCKADDR_IN6);
        }
        else
        {
            Status = ERROR_REGISTRY_CORRUPT;
            break; 
        }

        Status = WSAAddressToString(
                            (LPSOCKADDR)&pListenQuery->AddrList[i],
                            dwSockAddrLength,
                            NULL,
                            (LPWSTR) IpAddr,
                            &dwIpAddrLen
                            );

        if(SOCKET_ERROR == Status)
        {
            Status = WSAGetLastError();
            break;
        }
        else
        {
            NlsPutMsg(
                    HTTPCFG_SSL_IP,
                    IpAddr
                    );

            NlsPutMsg(
                    HTTPCFG_RECORD_SEPARATOR
                    );
        }
    }

    return;
}

/***************************************************************************++

Routine Description:
    Sets an IP Listen entry

Arguments:
    pIp - IP address to set.

Return Value:
    Success/Failure.

--***************************************************************************/
int DoIpSet(
    IN PWSTR pIp
    )
{
    HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM SetParam;
    DWORD                               Status;
    SOCKADDR_STORAGE                    TempSockAddr;

    // convert IP to a SOCKADDR.
    if((Status = GetAddress(pIp, 
                            &TempSockAddr,
                            sizeof(TempSockAddr)
                            )) != NO_ERROR)
    {
        NlsPutMsg(HTTPCFG_INVALID_IP, pIp);
        return Status;
    }

    SetParam.AddrLength = sizeof(TempSockAddr); 
    SetParam.pAddress   = (LPSOCKADDR)&TempSockAddr;

    // Call the API
    Status = HttpSetServiceConfiguration(
                NULL,
                HttpServiceConfigIPListenList,
                (PVOID)&SetParam,
                sizeof(SetParam),
                NULL
                );

    NlsPutMsg(HTTPCFG_SETSERVICE_STATUS, Status);
                
    return Status;
}

/***************************************************************************++

Routine Description:
    Queries for a URL ACL entry.

Arguments:
    None.

Return Value:
    Success/Failure.

--***************************************************************************/
int DoIpQuery(
    )
{
    DWORD    Status;
    PUCHAR   pOutput = NULL;
    DWORD    OutputLength = 0;
    DWORD    ReturnLength = 0;

    for(;;)
    {
        // First get the size of the output buffer that is required.
        //
        Status = HttpQueryServiceConfiguration(
                    NULL,
                    HttpServiceConfigIPListenList,
                    NULL,
                    0,
                    pOutput,
                    OutputLength,
                    &ReturnLength,
                    NULL
                    );

        if(ERROR_INSUFFICIENT_BUFFER == Status)
        {
            // If the API completes with ERROR_INSUFFICIENT_BUFFER, we'll
            // allocate memory for it & continue with the loop where we'll
            // call it again.
            
            if(pOutput)
            {
                // If there was an existing buffer, free it.
                LocalFree(pOutput);
            }

            // 
            // Allocate a new buffer.
            //
            pOutput = LocalAlloc(LMEM_FIXED, ReturnLength);
            if(!pOutput)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            OutputLength = ReturnLength;
        }
        else if(NO_ERROR == Status)
        {
            PrintIpListenRecords(pOutput);
            break;
        }
        else
        {
            //
            // Some other error, so we are done
            //
            NlsPutMsg(HTTPCFG_QUERYSERVICE_STATUS, Status);
            break;
        }
    }

    if(pOutput)
    {
        LocalFree(pOutput);
    }

    return Status;
}

int DoIpDelete(
    IN PWSTR pIp
    )
{
    HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM SetParam;
    DWORD                               Status;
    SOCKADDR_STORAGE                    TempSockAddr;

    if((Status = GetAddress(pIp, 
                            &TempSockAddr,
                            sizeof(TempSockAddr)
                            )) != NO_ERROR)
    {
        NlsPutMsg(HTTPCFG_INVALID_IP, pIp);
        return Status;
    }

    SetParam.AddrLength = sizeof(TempSockAddr); 
    SetParam.pAddress   = (LPSOCKADDR) &TempSockAddr;

    Status = HttpDeleteServiceConfiguration(
                NULL,
                HttpServiceConfigIPListenList,
                (PVOID)&SetParam,
                sizeof(SetParam),
                NULL
                );
                
    NlsPutMsg(HTTPCFG_DELETESERVICE_STATUS, Status);
    return Status;
}

//
// Public function.
//

int DoIpListen(
    int   argc, 
    WCHAR **argv, 
    HTTPCFG_TYPE Type
    )
{
    PWCHAR   pIp = NULL;

    while(argc>=2 && (argv[0][0] == '-' || argv[0][0]== '/'))
    {
        switch(toupper(argv[0][1]))
        {
            case 'I':
                pIp = argv[1];
                break;
    
            default:
                NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
                return ERROR_INVALID_PARAMETER;
        }
        argc -=2;
        argv +=2;
    }

    switch(Type)
    {
        case HttpCfgTypeSet:
            return DoIpSet(pIp);

        case HttpCfgTypeQuery:
            return DoIpQuery();

        case HttpCfgTypeDelete:
            return DoIpDelete(pIp);

        default: 
            NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
            return ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\serviceconfig\main.c ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************++

Routine Description:
    main routine.

Arguments:
    argc - # of command line arguments.
    argv - Arguments.

Return Value:
    Success/Failure.

--***************************************************************************/
int _cdecl wmain(int argc, LPWSTR argv[])
{
    DWORD           Status = NO_ERROR;
    HTTPCFG_TYPE    Type;
    HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_1;
    WORD            wVersionRequested;
    WSADATA         wsaData;

    // Parse command line parameters.

    if(argc < 3)
    {
        NlsPutMsg(HTTPCFG_USAGE, argv[0]);
        return 0;
    }

    argv++; argc --;

    //
    // First parse the type of operation.
    //
   
    if(_wcsicmp(argv[0], L"set") == 0)
    {
        Type = HttpCfgTypeSet;
    }
    else if(_wcsicmp(argv[0], L"query") == 0)
    {
        Type = HttpCfgTypeQuery;
    }
    else if(_wcsicmp(argv[0], L"delete") == 0)
    {
        Type = HttpCfgTypeDelete;
    }
    else if(_wcsicmp(argv[0], L"?") == 0)
    {
        NlsPutMsg(HTTPCFG_USAGE, argv[0]);
        return 0;
    }
    else
    {
        NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
        return ERROR_INVALID_PARAMETER;
    }
    argv++; argc--;

    //
    // Call HttpInitialize.
    //

    if((Status = HttpInitialize(
                    HttpApiVersion, 
                    HTTP_INITIALIZE_CONFIG, 
                    NULL)) != NO_ERROR)
    {
        NlsPutMsg(HTTPCFG_HTTPINITIALIZE, Status);
        return Status;
    }

    //
    // Call WSAStartup as we are using some winsock functions.
    //
    wVersionRequested = MAKEWORD( 2, 2 );

    if(WSAStartup( wVersionRequested, &wsaData ) != 0)
    {
        HttpTerminate(HTTP_INITIALIZE_CONFIG, NULL);
        return GetLastError();
    }

    //
    // Call the corresponding API.
    //

    if(_wcsicmp(argv[0], L"ssl") == 0)
    {
        argv++; argc--;
        Status = DoSsl(argc, argv, Type);
    }
    else if(_wcsicmp(argv[0], L"urlacl") == 0)
    {
        argv++; argc--;
        Status = DoUrlAcl(argc, argv, Type);
    }
    else if(_wcsicmp(argv[0], L"iplisten") == 0)
    {
        argv++; argc--;
        Status = DoIpListen(argc, argv, Type);
    }
    else 
    {
        NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
        Status = ERROR_INVALID_PARAMETER;
    }

    WSACleanup();
    HttpTerminate(HTTP_INITIALIZE_CONFIG, NULL);

    return Status;
}

/***************************************************************************++

Routine Description:
    Write output

Arguments:
    Handle    - Handle to write to.
    MsgNumber - The message number.
    ...       - Optional arguments.

Return Value:
    Success/Failure.

--***************************************************************************/
UINT 
NlsPutMsg (
    IN UINT MsgNumber, 
    IN ...
    )
{
    UINT    msglen;
    VOID    *vp;
    va_list arglist;

    va_start(arglist, MsgNumber);

    msglen = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | 
                FORMAT_MESSAGE_ALLOCATE_BUFFER,   // dwFlags.
                NULL,                             // lpSource. 
                MsgNumber,                        // dwMessageId. 
                0L,                               // dwLanguageId (default)
                (LPWSTR)&vp,
                0,
                &arglist
                );

    if(!msglen)
    {
        return 0;
    }

    wprintf(L"%ws", vp);

    LocalFree(vp);

    return msglen;
}

/***************************************************************************++

Routine Description:
    Given a WCHAR IP, this routine converts it to a SOCKADDR. 

Arguments:
    pIp     - IP address to covert.
    pBuffer - Buffer, must be == sizeof(SOCKADDR_STORAGE)
    Length  - Length of buffer

Return Value:
    Success/Failure.

--***************************************************************************/
DWORD
GetAddress(
    PWCHAR  pIp, 
    PVOID   pBuffer,
    ULONG   Length
    )
{
    DWORD Status;
    DWORD TempStatus;

    if(pIp == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // The address could be a v4 or a v6 address. First, let's try v4.
    //

    Status = WSAStringToAddress(
                pIp,
                AF_INET,
                NULL,
                pBuffer,
                (LPINT)&Length
                );

    if(Status != NO_ERROR)
    {
        //
        // Now, try v6
        //

        Status = WSAGetLastError();

        TempStatus = WSAStringToAddress(
                        pIp,
                        AF_INET6,
                        NULL,
                        pBuffer,
                        (LPINT)&Length
                        );

        //
        // If IPv6 also fails, then we want to return the original 
        // error.
        //
        // If it succeeds, we want to return NO_ERROR.
        //

        if(TempStatus == NO_ERROR)
        {
            Status = NO_ERROR;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\server\main.c ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#include "precomp.h"

//
// Macros.
//
#define INITIALIZE_HTTP_RESPONSE( resp, status, reason )                    \
    do                                                                      \
    {                                                                       \
        RtlZeroMemory( (resp), sizeof(*(resp)) );                           \
        (resp)->StatusCode = (status);                                      \
        (resp)->pReason = (reason);                                         \
        (resp)->ReasonLength = (USHORT) strlen(reason);                     \
    } while (FALSE)



#define ADD_KNOWN_HEADER(Response, HeaderId, RawValue)                      \
    do                                                                      \
    {                                                                       \
        (Response).Headers.KnownHeaders[(HeaderId)].pRawValue = (RawValue); \
        (Response).Headers.KnownHeaders[(HeaderId)].RawValueLength =        \
            (USHORT) strlen(RawValue);                                      \
    } while(FALSE)

#define ALLOC_MEM(cb) HeapAlloc(GetProcessHeap(), 0, (cb))
#define FREE_MEM(ptr) HeapFree(GetProcessHeap(), 0, (ptr))

//
// Prototypes.
//
DWORD
DoReceiveRequests(
    HANDLE hReqQueue
    );

DWORD
SendHttpResponse(
    IN HANDLE        hReqQueue,
    IN PHTTP_REQUEST pRequest,
    IN USHORT        StatusCode,
    IN PSTR          pReason,
    IN PSTR          pEntity
    );

DWORD
SendHttpPostResponse(
    IN HANDLE        hReqQueue,
    IN PHTTP_REQUEST pRequest
    );

/***************************************************************************++

Routine Description:
    main routine.

Arguments:
    argc - # of command line arguments.
    argv - Arguments.

Return Value:
    Success/Failure.

--***************************************************************************/
int __cdecl wmain(
        int argc, 
        wchar_t * argv[]
        )
{
    ULONG           retCode;
    int             i;
    HANDLE          hReqQueue      = NULL;
    int             UrlAdded       = 0;
    HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_1;

    if (argc < 2)
    {
        wprintf(L"%ws: <Url1> [Url2] ... \n", argv[0]);
        return -1;
    }

    //
    // Initialize HTTP APIs.
    //
    retCode = HttpInitialize( 
                HttpApiVersion,
                HTTP_INITIALIZE_SERVER,    // Flags
                NULL                       // Reserved
                );

    if (retCode != NO_ERROR)
    {
        wprintf(L"HttpInitialize failed with %lu \n", retCode);
        return retCode;
    }

    //
    // Create a Request Queue Handle
    //
    retCode = HttpCreateHttpHandle(
                &hReqQueue,        // Req Queue
                0                  // Reserved
                );

    if (retCode != NO_ERROR)
    {    
        wprintf(L"HttpCreateHttpHandle failed with %lu \n", retCode);
        goto CleanUp;
    }

    //
    // The command line arguments represent URIs that we want to listen on.
    // We will call HttpAddUrl for each of these URIs.
    //
    // The URI is a fully qualified URI and MUST include the terminating '/'
    //
    for (i = 1; i < argc; i++)
    {
        wprintf(
          L"we are listening for requests on the following url: %s\n", 
          argv[i]);

        retCode = HttpAddUrl(
                    hReqQueue,    // Req Queue
                    argv[i],      // Fully qualified URL
                    NULL          // Reserved
                    );

        if (retCode != NO_ERROR)
        {
            wprintf(L"HttpAddUrl failed with %lu \n", retCode);
            goto CleanUp;
        }
        else
        {
            //
            // Keep track of the URLs that we've currently added.
            //
            UrlAdded ++;
        }
    }

    // Loop while receiving requests
    for(;;)
    {
        retCode = DoReceiveRequests(hReqQueue);

        if(NO_ERROR == retCode)
        {
            wprintf(
                L"DoReceiveRequests failed with %lu \n", 
                retCode
                );

            break;
        }

    } // CTRL C to break out of loop

CleanUp:

    //
    // Call HttpRemoveUrl for all the URLs that we added.
    //
    for(i=1; i<=UrlAdded; i++)
    {
        HttpRemoveUrl(
              hReqQueue,     // Req Queue
              argv[i]        // Fully qualified URL
              );
    }

    //
    // Close the Request Queue handle.
    //
    if(hReqQueue)
    {
        CloseHandle(hReqQueue);
    }

    // 
    // Call HttpTerminate.
    //
    HttpTerminate(HTTP_INITIALIZE_SERVER, NULL);

    return retCode;
}

/***************************************************************************++

Routine Description:
    The routine to receive a request. This routine calls the corresponding 
    routine to deal with the response.

Arguments:
    hReqQueue - Handle to the request queue.

Return Value:
    Success/Failure.

--***************************************************************************/
DWORD
DoReceiveRequests(
    IN HANDLE hReqQueue
    )
{
    ULONG              result;
    HTTP_REQUEST_ID    requestId;
    DWORD              bytesRead;
    PHTTP_REQUEST      pRequest;
    PCHAR              pRequestBuffer;
    ULONG              RequestBufferLength;

    //
    // Allocate a 2K buffer. Should be good for most requests, we'll grow 
    // this if required. We also need space for a HTTP_REQUEST structure.
    //
    RequestBufferLength = sizeof(HTTP_REQUEST) + 2048;
    pRequestBuffer      = ALLOC_MEM( RequestBufferLength );

    if (pRequestBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRequest = (PHTTP_REQUEST)pRequestBuffer;

    //
    // Wait for a new request -- This is indicated by a NULL request ID.
    //

    HTTP_SET_NULL_ID( &requestId );

    for(;;)
    {
        RtlZeroMemory(pRequest, RequestBufferLength);

        result = HttpReceiveHttpRequest(
                    hReqQueue,          // Req Queue
                    requestId,          // Req ID
                    0,                  // Flags
                    pRequest,           // HTTP request buffer
                    RequestBufferLength,// req buffer length
                    &bytesRead,         // bytes received
                    NULL                // LPOVERLAPPED
                    );

        if(NO_ERROR == result)
        {
            //
            // Worked! 
            // 
            switch(pRequest->Verb)
            {
                case HttpVerbGET:
                    wprintf(L"Got a GET request for %ws \n", 
                            pRequest->CookedUrl.pFullUrl);

                    result = SendHttpResponse(
                                hReqQueue, 
                                pRequest, 
                                200,
                                "OK",
                                "Hey! You hit the server \r\n"
                                );
                    break;

                case HttpVerbPOST:

                    wprintf(L"Got a POST request for %ws \n", 
                            pRequest->CookedUrl.pFullUrl);

                    result = SendHttpPostResponse(hReqQueue, pRequest);
                    break;

                default:
                    wprintf(L"Got a unknown request for %ws \n", 
                            pRequest->CookedUrl.pFullUrl);

                    result = SendHttpResponse(
                                hReqQueue, 
                                pRequest,
                                503,
                                "Not Implemented",
                                NULL
                                );
                    break;
            }

            if(result != NO_ERROR)
            {
                break;
            }

            //
            // Reset the Request ID so that we pick up the next request.
            //
            HTTP_SET_NULL_ID( &requestId );
        }
        else if(result == ERROR_MORE_DATA)
        {
            //
            // The input buffer was too small to hold the request headers
            // We have to allocate more buffer & call the API again. 
            //
            // When we call the API again, we want to pick up the request
            // that just failed. This is done by passing a RequestID.
            //
            // This RequestID is picked from the old buffer.
            //
            requestId = pRequest->RequestId;

            //
            // Free the old buffer and allocate a new one.
            //
            RequestBufferLength = bytesRead;
            FREE_MEM( pRequestBuffer );
            pRequestBuffer = ALLOC_MEM( RequestBufferLength );

            if (pRequestBuffer == NULL)
            {
                result = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            pRequest = (PHTTP_REQUEST)pRequestBuffer;

        }
        else if(ERROR_CONNECTION_INVALID == result && 
                !HTTP_IS_NULL_ID(&requestId))
        {
            // The TCP connection got torn down by the peer when we were
            // trying to pick up a request with more buffer. We'll just move
            // onto the next request.
            
            HTTP_SET_NULL_ID( &requestId );
        }
        else
        {
            break;
        }

    } // for(;;)

    if(pRequestBuffer)
    {
        FREE_MEM( pRequestBuffer );
    }

    return result;
}

/***************************************************************************++

Routine Description:
    The routine sends a HTTP response.

Arguments:
    hReqQueue     - Handle to the request queue.
    pRequest      - The parsed HTTP request.
    StatusCode    - Response Status Code.
    pReason       - Response reason phrase.
    pEntityString - Response entity body.

Return Value:
    Success/Failure.

--***************************************************************************/
DWORD
SendHttpResponse(
    IN HANDLE        hReqQueue,
    IN PHTTP_REQUEST pRequest,
    IN USHORT        StatusCode,
    IN PSTR          pReason,
    IN PSTR          pEntityString
    )
{
    HTTP_RESPONSE   response;
    HTTP_DATA_CHUNK dataChunk;
    DWORD           result;
    DWORD           bytesSent;

    //
    // Initialize the HTTP response structure.
    //
    INITIALIZE_HTTP_RESPONSE(&response, StatusCode, pReason);

    //
    // Add a known header.
    //
    ADD_KNOWN_HEADER(response, HttpHeaderContentType, "text/html");
   
    if(pEntityString)
    {
        // 
        // Add an entity chunk
        //
        dataChunk.DataChunkType           = HttpDataChunkFromMemory;
        dataChunk.FromMemory.pBuffer      = pEntityString;
        dataChunk.FromMemory.BufferLength = (ULONG) strlen(pEntityString);

        response.EntityChunkCount         = 1;
        response.pEntityChunks            = &dataChunk;
    }

    // 
    // Since we are sending all the entity body in one call, we don't have 
    // to specify the Content-Length.
    //
    
    result = HttpSendHttpResponse(
                    hReqQueue,           // ReqQueueHandle
                    pRequest->RequestId, // Request ID
                    0,                   // Flags
                    &response,           // HTTP response
                    NULL,                // pReserved1
                    &bytesSent,          // bytes sent   (OPTIONAL)
                    NULL,                // pReserved2   (must be NULL)
                    0,                   // Reserved3    (must be 0)
                    NULL,                // LPOVERLAPPED (OPTIONAL)
                    NULL                 // pReserved4   (must be NULL)
                    );

    if(result != NO_ERROR)
    {
        wprintf(L"HttpSendHttpResponse failed with %lu \n", result);
    }

    return result;
}

/***************************************************************************++

Routine Description:
    The routine sends a HTTP response after reading the entity body.

Arguments:
    hReqQueue     - Handle to the request queue.
    pRequest      - The parsed HTTP request.

Return Value:
    Success/Failure.

--***************************************************************************/
DWORD
SendHttpPostResponse(
    IN HANDLE        hReqQueue,
    IN PHTTP_REQUEST pRequest
    )
{
    HTTP_RESPONSE   response;
    DWORD           result;
    DWORD           bytesSent;
    PUCHAR          pEntityBuffer;
    ULONG           EntityBufferLength;
    ULONG           BytesRead;
    ULONG           TempFileBytesWritten;
    HANDLE          hTempFile;
    TCHAR           szTempName[MAX_PATH + 1];
#define MAX_ULONG_STR ((ULONG) sizeof("4294967295"))
    CHAR            szContentLength[MAX_ULONG_STR];
    HTTP_DATA_CHUNK dataChunk;
    ULONG           TotalBytesRead = 0;

    BytesRead  = 0;
    hTempFile  = INVALID_HANDLE_VALUE;

    //
    // Allocate some space for an entity buffer. We'll grow this on demand.
    //
    EntityBufferLength = 2048;
    pEntityBuffer      = ALLOC_MEM( EntityBufferLength );

    if (pEntityBuffer == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        wprintf(L"Insufficient resources \n");
        goto Done;
    }

    //
    // Initialize the HTTP response structure.
    //
    INITIALIZE_HTTP_RESPONSE(&response, 200, "OK");

    //
    // For POST, we'll echo back the entity that we got from the client. 
    //
    // NOTE: If we had passed the HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    //       flag with HttpReceiveHttpRequest(), the entity would have
    //       been a part of HTTP_REQUEST (using the pEntityChunks field).
    //       Since we have not passed that flag, we can be assured that 
    //       there are no entity bodies in HTTP_REQUEST.
    //
   
    if(pRequest->Flags & HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS)
    {
        // The entity body is send over multiple calls. Let's collect all
        // of these in a file & send it back. We'll create a temp file 
        //

        if(GetTempFileName(
                L".", 
                L"New", 
                0, 
                szTempName
                ) == 0)
        {
            result = GetLastError();
            wprintf(L"GetTempFileName failed with %lu \n", result);
            goto Done;
        }

        hTempFile = CreateFile(
                        szTempName,
                        GENERIC_READ | GENERIC_WRITE, 
                        0,                             // don't share.
                        NULL,                          // no security descriptor
                        CREATE_ALWAYS,                 // overrwrite existing
                        FILE_ATTRIBUTE_NORMAL,         // normal file.
                        NULL
                        );

        if(hTempFile == INVALID_HANDLE_VALUE)
        {
            result = GetLastError();
            wprintf(L"Could not create temporary file. Error %lu \n", result);
            goto Done;
        }

        do
        {
            //
            // Read the entity chunk from the request.
            //
            BytesRead = 0; 
            result = HttpReceiveRequestEntityBody(
                        hReqQueue,
                        pRequest->RequestId,
                        0,
                        pEntityBuffer,
                        EntityBufferLength,
                        &BytesRead,
                        NULL
                        );

            switch(result)
            {
                case NO_ERROR:

                    if(BytesRead != 0)
                    {
                        TotalBytesRead += BytesRead;
                        WriteFile(
                                hTempFile, 
                                pEntityBuffer, 
                                BytesRead,
                                &TempFileBytesWritten,
                                NULL
                                );
                    }
                    break;

                case ERROR_HANDLE_EOF:

                    //
                    // We have read the last request entity body. We can send 
                    // back a response.
                    //
                    // To illustrate entity sends via 
                    // HttpSendResponseEntityBody, we will send the response 
                    // over multiple calls. This is achieved by passing the 
                    // HTTP_SEND_RESPONSE_FLAG_MORE_DATA flag.
                    
                    if(BytesRead != 0)
                    {
                        TotalBytesRead += BytesRead;
                        WriteFile(
                                hTempFile, 
                                pEntityBuffer, 
                                BytesRead,
                                &TempFileBytesWritten,
                                NULL
                                );
                    }

                    //
                    // Since we are sending the response over multiple API
                    // calls, we have to add a content-length. 
                    //
                    // Alternatively, we could have sent using chunked transfer
                    // encoding, by passing "Transfer-Encoding: Chunked".
                    //

                    // NOTE: Since we are accumulating the TotalBytesRead in 
                    //       a ULONG, this will not work for entity bodies that
                    //       are larger than 4 GB. For supporting large entity
                    //       bodies, we would have to use a ULONGLONG.
                    // 

                  
                    sprintf(szContentLength, "%lu", TotalBytesRead);

                    ADD_KNOWN_HEADER(
                            response, 
                            HttpHeaderContentLength, 
                            szContentLength
                            );

                    result = 
                        HttpSendHttpResponse(
                               hReqQueue,           // ReqQueueHandle
                               pRequest->RequestId, // Request ID
                               HTTP_SEND_RESPONSE_FLAG_MORE_DATA,
                               &response,           // HTTP response
                               NULL,                // pReserved1
                               &bytesSent,          // bytes sent (optional)
                               NULL,                // pReserved2
                               0,                   // Reserved3
                               NULL,                // LPOVERLAPPED
                               NULL                 // pReserved4
                               );

                    if(result != NO_ERROR)
                    {
                        wprintf(L"HttpSendHttpResponse failed with %lu \n", 
                                result);
                        goto Done;
                    }

                    //
                    // Send entity body from a file handle.
                    //
                    dataChunk.DataChunkType = 
                        HttpDataChunkFromFileHandle;

                    dataChunk.FromFileHandle.
                        ByteRange.StartingOffset.QuadPart = 0;

                    dataChunk.FromFileHandle.
                        ByteRange.Length.QuadPart = HTTP_BYTE_RANGE_TO_EOF;

                    dataChunk.FromFileHandle.FileHandle = hTempFile;

                    result = HttpSendResponseEntityBody(
                                hReqQueue,
                                pRequest->RequestId,
                                0,                    // This is the last send.
                                1,                    // Entity Chunk Count.
                                &dataChunk,
                                NULL,
                                NULL,
                                0,
                                NULL,
                                NULL
                                );

                    if(result != NO_ERROR)
                    {
                        wprintf(
                           L"HttpSendResponseEntityBody failed with %lu \n", 
                           result
                           );
                    }

                    goto Done;

                    break;
                       

                default:
                    wprintf(L"HttpReceiveRequestEntityBody failed with %lu \n", 
                            result);
                    goto Done;
            }

        } while(TRUE);
    }
    else
    {
        // This request does not have any entity body. 
        //
        
        result = HttpSendHttpResponse(
                   hReqQueue,           // ReqQueueHandle
                   pRequest->RequestId, // Request ID
                   0,
                   &response,           // HTTP response
                   NULL,                // pReserved1
                   &bytesSent,          // bytes sent (optional)
                   NULL,                // pReserved2
                   0,                   // Reserved3
                   NULL,                // LPOVERLAPPED
                   NULL                 // pReserved4
                   );
        if(result != NO_ERROR)
        {
            wprintf(L"HttpSendHttpResponse failed with %lu \n", result);
        }
    }

Done:

    if(pEntityBuffer)
    {
        FREE_MEM(pEntityBuffer);
    }

    if(INVALID_HANDLE_VALUE != hTempFile)
    {
        CloseHandle(hTempFile);
        DeleteFile(szTempName);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\lib\httpctrs.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    httpctrs.c

Abstract:

    This file contains array descriptions of counters
    that are needed for handling worker processes counters.

Author:

    Emily Kruglick (EmilyK)       19-Sept-2000

Revision History:

--*/


#include "precomp.h"


// 
// These are used by WAS to determine the size of the data
// that each counter has in the structure above and it's offset.
//

HTTP_PROP_DESC aIISULGlobalDescription[] =
{
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, CurrentUrisCached),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, CurrentUrisCached),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, TotalUrisCached),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, TotalUrisCached),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, UriCacheHits),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, UriCacheHits),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, UriCacheMisses),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, UriCacheMisses),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, UriCacheFlushes),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, UriCacheFlushes),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, TotalFlushedUris),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, TotalFlushedUris),
      FALSE }
};


//
// Used by WAS to figure out offset information and size
// of counter field in the above structure.
//
HTTP_PROP_DESC aIISULSiteDescription[] =
{
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, BytesSent),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, BytesSent),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, BytesReceived),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, BytesReceived),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, BytesTransfered),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, BytesTransfered),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, CurrentConns),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, CurrentConns),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, MaxConnections),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, MaxConnections),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, ConnAttempts),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, ConnAttempts),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, GetReqs),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, GetReqs),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, HeadReqs),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, HeadReqs),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, AllReqs),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, AllReqs),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, MeasuredIoBandwidthUsage),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, MeasuredIoBandwidthUsage),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, CurrentBlockedBandwidthBytes),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, CurrentBlockedBandwidthBytes),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, TotalBlockedBandwidthBytes),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, TotalBlockedBandwidthBytes),
      TRUE }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\serviceconfig\precomp.h ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#define NOGDI
#define NOMINMAX
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <io.h>
#include    <winsock2.h>
#include    <ws2tcpip.h>
#include    <ntddip6.h>
#include    <objbase.h>
#include    <wtypes.h>
#include    "http.h"
#include    "nlstxt.h"



typedef enum _HTTPCFG_TYPE
{
    HttpCfgTypeSet,
    HttpCfgTypeQuery,
    HttpCfgTypeDelete,
    HttpCfgTypeMax

} HTTPCFG_TYPE, *PHTTPCFG_TYPE;

int DoSsl(
    int          argc, 
    WCHAR        **argv, 
    HTTPCFG_TYPE Type
    );

int DoUrlAcl(
    int          argc, 
    WCHAR        **argv, 
    HTTPCFG_TYPE Type
    );

int DoIpListen(
    int          argc, 
    WCHAR        **argv, 
    HTTPCFG_TYPE Type
    );

DWORD
GetAddress(
    PWCHAR  pIp, 
    PVOID   pBuffer,
    ULONG   Length
    );

UINT 
NlsPutMsg (
    IN UINT MsgNumber, 
    IN ...
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\apool.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    apool.c

Abstract:

    Note that most of the routines in this module assume they are called
    at PASSIVE_LEVEL.

Author:

    Paul McDaniel (paulmcd)       28-Jan-1999

Revision History:

--*/


#include "precomp.h"
#include "apoolp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeAP )
#pragma alloc_text( PAGE, UlTerminateAP )

#pragma alloc_text( PAGE, UlGetPoolFromHandle )
#pragma alloc_text( PAGE, UlQueryAppPoolInformation )
#pragma alloc_text( PAGE, UlSetAppPoolInformation )
#pragma alloc_text( PAGE, UlCloseAppPoolProcess )

#pragma alloc_text( PAGE, UlCopyRequestToBuffer )
#pragma alloc_text( PAGE, UlCopyRequestToIrp )
#pragma alloc_text( PAGE, UlpCopyEntityBodyToBuffer )
#pragma alloc_text( PAGE, UlpRedeliverRequestWorker )
#endif  // ALLOC_PRAGMA

#if 0
#if REFERENCE_DEBUG
NOT PAGEABLE -- UlDereferenceAppPool
NOT PAGEABLE -- UlReferenceAppPool
#endif

NOT PAGEABLE -- UlAttachProcessToAppPool
NOT PAGEABLE -- UlDetachProcessFromAppPool
NOT PAGEABLE -- UlShutdownAppPoolProcess
NOT PAGEABLE -- UlReceiveHttpRequest
NOT PAGEABLE -- UlDeliverRequestToProcess
NOT PAGEABLE -- UlUnlinkRequestFromProcess
NOT PAGEABLE -- UlWaitForDisconnect

NOT PAGEABLE -- UlDequeueNewRequest
NOT PAGEABLE -- UlRequeuePendingRequest

NOT PAGEABLE -- UlpSetAppPoolState
NOT PAGEABLE -- UlpPopIrpFromProcess
NOT PAGEABLE -- UlpQueuePendingRequest
NOT PAGEABLE -- UlpQueueUnboundRequest
NOT PAGEABLE -- UlpUnbindQueuedRequests
NOT PAGEABLE -- UlDeleteAppPool
NOT PAGEABLE -- UlpPopNewIrp
NOT PAGEABLE -- UlpIsProcessInAppPool
NOT PAGEABLE -- UlpQueueRequest
NOT PAGEABLE -- UlpRemoveRequest
NOT PAGEABLE -- UlpDequeueRequest
NOT PAGEABLE -- UlpSetAppPoolControlChannelHelper

NOT PAGEABLE -- UlWaitForDemandStart
NOT PAGEABLE -- UlCompleteAllWaitForDisconnect
NOT PAGEABLE -- UlpCancelDemandStart
NOT PAGEABLE -- UlpCancelHttpReceive
NOT PAGEABLE -- UlpCancelWaitForDisconnect
NOT PAGEABLE -- UlpCancelWaitForDisconnectWorker

NOT PAGEABLE -- UlReferenceAppPoolProcess
NOT PAGEABLE -- UlDereferenceAppPoolProcess
NOT PAGEABLE -- UlpSetAppPoolQueueLength
#endif


//
// Globals
//

LIST_ENTRY  g_AppPoolListHead = {NULL, NULL};
BOOLEAN     g_InitAPCalled = FALSE;
LONG        g_RequestsQueued = 0;


/***************************************************************************++

Routine Description:

    Creates a new process object and attaches it to an apool.

    Called by handle create and returns the process object to attach to the
    handle.

Arguments:

    pName           - the name of the apool to attach to
                        N.B.  Since pName comes from IoMgr (tag IoNm),
                        we can safely reference it without extra playing.
    NameLength      - the byte count of pName
    Create          - whether or not a new apool should be created if pName
                        does not exist
    pAccessState    - the state of an access-in-progress
    DesiredAccess   - the desired access mask
    RequestorMode   - UserMode or KernelMode
    ppProcess       - returns the newly created PROCESS object

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAttachProcessToAppPool(
    IN PWCHAR                   pName OPTIONAL,
    IN USHORT                   NameLength,
    IN BOOLEAN                  Create,
    IN PACCESS_STATE            pAccessState,
    IN ACCESS_MASK              DesiredAccess,
    IN KPROCESSOR_MODE          RequestorMode,
    OUT PUL_APP_POOL_PROCESS *  ppProcess
    )
{
    NTSTATUS                Status;
    PUL_APP_POOL_OBJECT     pObject = NULL;
    PUL_APP_POOL_PROCESS    pProcess = NULL;
    LIST_ENTRY *            pEntry;
    KLOCK_QUEUE_HANDLE      LockHandle;
    BOOLEAN                 SecurityAssigned = FALSE;
    ULONG                   Index;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppProcess != NULL);

    Status = STATUS_SUCCESS;
    *ppProcess = NULL;

    ASSERT(NameLength < UL_MAX_APP_POOL_NAME_SIZE);

    //
    // WAS-type controller process can only be created not opened.
    //

    if (!Create && (DesiredAccess & WRITE_OWNER))
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Make sure the AppPool name if passed in doesn't contain '/' since
    // it is used as a deliminator of a fragment name.
    //

    for (Index = 0; Index < NameLength/sizeof(WCHAR); Index++)
    {
        if (L'/' == pName[Index])
        {
            return STATUS_OBJECT_NAME_INVALID;
        }
    }

    //
    // Try and find an existing app pool of this name; also potentially
    // pre-allocate the memory.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->AppPoolResource, TRUE);

    if (pName != NULL)
    {
        pEntry = g_AppPoolListHead.Flink;

        //
        // CODEWORK: use something faster than a linear search.
        // This won't scale well to hundreds of app pools.
        // On the other hand, this isn't something we'll be doing thousands
        // of times a second.
        //

        while (pEntry != &g_AppPoolListHead)
        {
            pObject = CONTAINING_RECORD(
                            pEntry,
                            UL_APP_POOL_OBJECT,
                            ListEntry
                            );

            if (pObject->NameLength == NameLength &&
                _wcsnicmp(pObject->pName, pName, NameLength/sizeof(WCHAR)) == 0)
            {
                //
                // Match.
                //

                break;
            }

            pEntry = pEntry->Flink;
        }

        //
        // Found 1?
        //

        if (pEntry == &g_AppPoolListHead)
        {
            pObject = NULL;
        }
    }

    //
    // Found 1?
    //

    if (pObject == NULL)
    {
        //
        // Nope, allowed to create?
        //

        if (!Create)
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto end;
        }

        //
        // Create it.  Allocate the object memory.
        //

        pObject = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_APP_POOL_OBJECT,
                        NameLength + sizeof(WCHAR),
                        UL_APP_POOL_OBJECT_POOL_TAG
                        );

        if (pObject == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlZeroMemory(
            pObject,
            NameLength + sizeof(WCHAR) +
            sizeof(UL_APP_POOL_OBJECT)
            );

        pObject->Signature  = UL_APP_POOL_OBJECT_POOL_TAG;
        pObject->RefCount   = 1;
        pObject->NameLength = NameLength;
        pObject->State      = HttpAppPoolDisabled_ByAdministrator;
        pObject->LoadBalancerCapability = HttpLoadBalancerBasicCapability;
        pObject->pControlChannel = NULL;

        InitializeListHead(&pObject->ProcessListHead);

        InitializeListHead(&pObject->NewRequestHead);
        pObject->RequestCount   = 0;
        pObject->MaxRequests    = DEFAULT_APP_POOL_QUEUE_MAX;

        UlInitializeSpinLock(&pObject->SpinLock, "AppPoolSpinLock");

        if (pName != NULL)
        {
            RtlCopyMemory(
                pObject->pName,
                pName,
                NameLength + sizeof(WCHAR)
                );
        }

        //
        // Set the security descriptor.
        //

        Status = UlAssignSecurity(
                        &pObject->pSecurityDescriptor,
                        pAccessState
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        SecurityAssigned = TRUE;

        WRITE_APP_POOL_TIME_TRACE_LOG(
            pObject,
            NULL,
            APP_POOL_TIME_ACTION_CREATE_APPOOL
            );

        UlTrace(REFCOUNT, (
            "http!UlAttachProcessToAppPool ap=%p refcount=%d\n",
            pObject,
            pObject->RefCount
            ));
    }
    else // if (pObject != NULL)
    {
        //
        // We found the named AppPool object in the list.  Reference it.
        //

        REFERENCE_APP_POOL(pObject);

        //
        // We found one.  Were we trying to create?
        //

        if (Create)
        {
            Status = STATUS_OBJECT_NAME_COLLISION;
            goto end;
        }

        //
        // Perform an access check against the app pool.
        //

        Status = UlAccessCheck(
                        pObject->pSecurityDescriptor,
                        pAccessState,
                        DesiredAccess,
                        RequestorMode,
                        pName
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }

    //
    // Create a process entry for it.
    //

    pProcess = UlCreateAppPoolProcess(pObject);

    if (pProcess == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    REFERENCE_APP_POOL_PROCESS(pProcess);

    //
    // Put the process in the app pool list.
    //

    UlAcquireInStackQueuedSpinLock(&pObject->SpinLock, &LockHandle);

    if (DesiredAccess & WRITE_OWNER)
    {
        pProcess->Controller = 1;
    }
    else
    {
        pObject->NumberActiveProcesses++;

       if (pObject->pControlChannel)
        {
            InterlockedIncrement(
                (PLONG)&pObject->pControlChannel->AppPoolProcessCount
                );
        }
    }

    InsertHeadList(&pObject->ProcessListHead, &pProcess->ListEntry);

    UlReleaseInStackQueuedSpinLock(&pObject->SpinLock, &LockHandle);

    WRITE_APP_POOL_TIME_TRACE_LOG(
        pObject,
        pProcess,
        APP_POOL_TIME_ACTION_CREATE_PROCESS
        );

    //
    // Insert AppPool into the global list if it has been created.
    //

    if (Create)
    {
        InsertHeadList(&g_AppPoolListHead, &pObject->ListEntry);
    }

    //
    // Return it.
    //

    *ppProcess = pProcess;

end:

    UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pObject != NULL)
        {
            if (SecurityAssigned)
            {
                UlDeassignSecurity(&pObject->pSecurityDescriptor);
            }

            DEREFERENCE_APP_POOL(pObject);
        }

        if (pProcess != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pProcess, UL_APP_POOL_PROCESS_POOL_TAG);
        }
    }

    return Status;

}   // UlAttachProcessToAppPool


/***************************************************************************++

Routine Description:

    This is called by UlCleanup when the handle count goes to 0.  It removes
    the PROCESS object from the apool, cancelling all i/o .

Arguments:

    pCleanupIrp     - the cleanup irp
    pCleanupIrpSp   - the current stack location of the cleanup irp

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDetachProcessFromAppPool(
    IN PIRP                 pCleanupIrp,
    IN PIO_STACK_LOCATION   pCleanupIrpSp
    )
{
    LIST_ENTRY              PendingRequestHead;
    PUL_APP_POOL_OBJECT     pAppPool;
    NTSTATUS                CancelStatus = STATUS_CANCELLED;
    PUL_INTERNAL_REQUEST    pRequest;
    KLOCK_QUEUE_HANDLE      LockHandle;
    PUL_APP_POOL_PROCESS    pProcess;
    BOOLEAN                 ListEmpty;
    PLIST_ENTRY             pEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pProcess = GET_APP_POOL_PROCESS(pCleanupIrpSp->FileObject);
    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    UlTrace(ROUTING, (
        "http!UlDetachProcessFromAppPool(%p, %S)\n",
        pProcess,
        pProcess->pAppPool->pName
        ));

    pAppPool = pProcess->pAppPool;
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    WRITE_APP_POOL_TIME_TRACE_LOG(
        pAppPool,
        pProcess,
        APP_POOL_TIME_ACTION_DETACH_PROCESS
        );

    //
    // Mark that this appool process is invalid for further
    // ioctls.
    //

    MARK_INVALID_APP_POOL(pCleanupIrpSp->FileObject);

    //
    // Shut down I/O on the handle.
    //

    UlShutdownAppPoolProcess(pProcess);

    //
    // Do final cleanup for the process.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->AppPoolResource, TRUE);

    //
    // Unlink from the App Pool list.
    //

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    RemoveEntryList(&pProcess->ListEntry);
    pProcess->ListEntry.Flink = pProcess->ListEntry.Blink = NULL;

    //
    // Move requests that have been passed up to the process to
    // a local list so their connections can be closed.
    //

    InitializeListHead(&PendingRequestHead);

    while (NULL != (pRequest = UlpDequeueRequest(
                                    pAppPool,
                                    &pProcess->PendingRequestHead
                                    )))
    {
        //
        // Move the entry to local list so we can close its
        // connection outside the app pool lock.
        //

        InsertTailList(&PendingRequestHead, &pRequest->AppPool.AppPoolEntry);
    }

    //
    // Adjust number of active processes.
    //

    if (!pProcess->Controller)
    {
        pAppPool->NumberActiveProcesses--;

        if (pAppPool->pControlChannel)
        {
            InterlockedDecrement(
                (PLONG)&pAppPool->pControlChannel->AppPoolProcessCount
                );
        }
    }

    ListEmpty = (BOOLEAN) IsListEmpty(&pAppPool->ProcessListHead);

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Remove the AppPool from the global list if this is the last process
    //

    if (ListEmpty)
    {
        RemoveEntryList(&pAppPool->ListEntry);
        pAppPool->ListEntry.Flink = pAppPool->ListEntry.Blink = NULL;

        //
        // Cleanup any security descriptor on the object.
        //

        UlDeassignSecurity(&pAppPool->pSecurityDescriptor);
    }

    UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

    //
    // Disable the AppPool to clean up the NewRequestQueue if we are the
    // last process on the AppPool.
    //

    if (ListEmpty)
    {
        UlpSetAppPoolState(pProcess, HttpAppPoolDisabled_ByAdministrator);
    }

    //
    // Close connections associated with the requests that
    // the process was handling.
    //

    while (!IsListEmpty(&PendingRequestHead))
    {        
        pEntry = RemoveHeadList(&PendingRequestHead);
        pEntry->Flink = pEntry->Blink = NULL;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        UlTrace(ROUTING, (
            "http!UlDetachProcessFromAppPool(%p, %S): tanking pending req=%p\n",
            pProcess,
            pAppPool->pName,
            pRequest
            ));

        //
        // Cancel any pending I/O related to this request.
        //

        UlAcquirePushLockExclusive(&pRequest->pHttpConn->PushLock);

        UlCancelRequestIo(pRequest);

        //
        // Try to log an entry to the error log file.
        // pHttpConn's request pointer could be null, (unlinked)
        // need to pass the pRequest separetely.
        //

        UlErrorLog(  pRequest->pHttpConn,
                     pRequest,
                     ERROR_LOG_INFO_FOR_APP_POOL_DETACH,
                     ERROR_LOG_INFO_FOR_APP_POOL_DETACH_SIZE,
                     TRUE
                     );

        UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

        //
        // Abort the connection this request is associated with.
        //

        (VOID) UlCloseConnection(
                    pRequest->pHttpConn->pConnection,
                    TRUE,
                    NULL,
                    NULL
                    );

        //
        // Drop our list's reference.
        //

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    ASSERT(IsListEmpty(&PendingRequestHead));

    //
    // Purge all zombie connections that belong to this process.
    //

    UlPurgeZombieConnections(
        &UlPurgeAppPoolProcess,
        (PVOID) pProcess
        );

    //
    // Cancel any remaining WaitForDisconnect IRPs.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->DisconnectResource, TRUE);

    UlNotifyAllEntries(
        UlpNotifyCompleteWaitForDisconnect,
        &pProcess->WaitForDisconnectHead,
        &CancelStatus
        );

    UlReleaseResource(&g_pUlNonpagedData->DisconnectResource);

    //
    // Kill any cache entries related to this process.
    //

    UlFlushCacheByProcess(pProcess);

    //
    // Mark the original cleanup irp pending and then deref and return.
    // When the refcount on pProcess reaches to zero it will complete
    // the cleanup irp.
    //

    IoMarkIrpPending(pCleanupIrp);

    pCleanupIrp->IoStatus.Status = STATUS_PENDING;

    //
    // Tell the process which Irp to complete once it's ready
    // to go away.
    //

    pProcess->pCleanupIrp = pCleanupIrp;

    //
    // Release our refcount on the pProcess.
    //

    DEREFERENCE_APP_POOL_PROCESS(pProcess);

    return STATUS_PENDING;

}   // UlDetachProcessFromAppPool


/***************************************************************************++

Routine Description:

    Cleans up outstanding I/O on an app pool process.  This function
    cancels all calls to HttpReceiveHttpRequest, and routes queued
    requests to other worker processes.  Outstanding send i/o is not
    affected.

Arguments:

    pProcess    - the process object to shut down

Return Value:

    None

--***************************************************************************/
VOID
UlShutdownAppPoolProcess(
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_APP_POOL_OBJECT     pAppPool;
    PUL_APP_POOL_OBJECT     pDemandStartAppPool;
    KLOCK_QUEUE_HANDLE      LockHandle;
    LIST_ENTRY              RequestList;
    PUL_INTERNAL_REQUEST    pRequest;
    PLIST_ENTRY             pEntry;
    PIRP                    pIrp;
    PUL_APP_POOL_PROCESS    pAppPoolProcess;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    pAppPool = pProcess->pAppPool;

    UlAcquireResourceExclusive(&g_pUlNonpagedData->AppPoolResource, TRUE);
    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    if (pProcess->InCleanup)
    {
        //
        // If we've already done this, get out.
        //

        UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);
        UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

        return;
    }

    //
    // Mark the process as InCleanup so new I/O won't be attached,
    // and so we won't try to clean it up again.
    //

    pProcess->InCleanup = 1;

    //
    // Cancel demand start IRP.
    //

    if (pProcess->Controller && pAppPool->pDemandStartIrp != NULL)
    {
        if (IoSetCancelRoutine(pAppPool->pDemandStartIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first, ok to just ignore this irp,
            // it's been pop'd off the queue and will be completed in the
            // cancel routine.  No need to complete it.
            //
        }
        else
        {
            pDemandStartAppPool = (PUL_APP_POOL_OBJECT)
                IoGetCurrentIrpStackLocation(pAppPool->pDemandStartIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer;

            ASSERT(pDemandStartAppPool == pAppPool);

            DEREFERENCE_APP_POOL(pAppPool);

            IoGetCurrentIrpStackLocation(pAppPool->pDemandStartIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pAppPool->pDemandStartIrp->IoStatus.Status = STATUS_CANCELLED;
            pAppPool->pDemandStartIrp->IoStatus.Information = 0;

            UlCompleteRequest(pAppPool->pDemandStartIrp, IO_NO_INCREMENT);
        }

        pAppPool->pDemandStartIrp = NULL;
        pAppPool->pDemandStartProcess = NULL;
    }

    //
    // Cancel pending HttpReceiveHttpRequest IRPs.
    //

    while (!IsListEmpty(&pProcess->NewIrpHead))
    {
        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pProcess->NewIrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // Pop the cancel routine.
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first, ok to just ignore this irp,
            // it's been pop'd off the queue and will be completed in the
            // cancel routine.  Keep looping.
            //

            pIrp = NULL;
        }
        else
        {
            //
            // Cancel it.  Even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pAppPoolProcess = (PUL_APP_POOL_PROCESS)
                IoGetCurrentIrpStackLocation(pIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer;

            ASSERT(pAppPoolProcess == pProcess);

            DEREFERENCE_APP_POOL_PROCESS(pAppPoolProcess);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);
            pIrp = NULL;
        }
    }

    //
    // Move requests that have been passed up to the process to a local list
    // so their pending HttpReceiveEntityBody IRPs can be canceled.
    //

    InitializeListHead(&RequestList);

    pEntry = pProcess->PendingRequestHead.Flink;
    while (pEntry != &pProcess->PendingRequestHead)
    {
        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        pEntry = pEntry->Flink;

        //
        // Take a short lived reference for the request so we can traverse
        // the list outside the AppPool lock.
        //

        UL_REFERENCE_INTERNAL_REQUEST(pRequest);

        InsertTailList(&RequestList, &pRequest->AppPool.ProcessEntry);
    }

    //
    // Unbind requests that haven't been passed up to this process so
    // they can be handled by other processes in the app pool.
    //

    UlpUnbindQueuedRequests(pProcess);

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);
    UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

    //
    // Cancel pending HttpReceiveEntityBody IRPs.
    //

    while (!IsListEmpty(&RequestList))
    {
        pEntry = RemoveHeadList(&RequestList);
        pEntry->Flink = pEntry->Blink = NULL;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.ProcessEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        //
        // Cancel any pending I/O related to this request.
        //

        UlAcquirePushLockExclusive(&pRequest->pHttpConn->PushLock);

        UlCancelRequestIo(pRequest);

        UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

        //
        // Drop the extra short lived reference we just added.
        //

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

}   // UlShutdownAppPoolProcess


#if REFERENCE_DEBUG

/***************************************************************************++

Routine Description:

    Increments the refcount.

Arguments:

    pAppPool    - the object to increment.

Return Value:

    None

--***************************************************************************/
VOID
UlReferenceAppPool(
    IN PUL_APP_POOL_OBJECT  pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG    RefCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    RefCount = InterlockedIncrement(&pAppPool->RefCount);
    ASSERT(RefCount > 0);

    WRITE_REF_TRACE_LOG(
        g_pAppPoolTraceLog,
        REF_ACTION_REFERENCE_APP_POOL,
        RefCount,
        pAppPool,
        pFileName,
        LineNumber
        );

    UlTrace(REFCOUNT, (
        "http!UlReferenceAppPool ap=%p refcount=%d\n",
        pAppPool,
        RefCount
        ));

}   // UlReferenceAppPool


/***************************************************************************++

Routine Description:

    Decrements the refcount.  If it hits 0, destruct's the apool, cancelling
    all i/o and dumping all queued requests.

Arguments:

    pAppPool    - the object to decrement.

Return Value:

    None

--***************************************************************************/
VOID
UlDereferenceAppPool(
    IN PUL_APP_POOL_OBJECT  pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG    RefCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    RefCount = InterlockedDecrement(&pAppPool->RefCount);
    ASSERT(RefCount >= 0);

    //
    // Tracing.
    //

    WRITE_REF_TRACE_LOG(
        g_pAppPoolTraceLog,
        REF_ACTION_DEREFERENCE_APP_POOL,
        RefCount,
        pAppPool,
        pFileName,
        LineNumber
        );

    UlTrace(REFCOUNT, (
        "http!UlDereferenceAppPool ap=%p refcount=%d\n",
        pAppPool,
        RefCount
        ));

    //
    // Clean up if necessary.
    //

    if (RefCount == 0)
    {
        DELETE_APP_POOL(pAppPool);
    }

}   // UlDereferenceAppPool


/***************************************************************************++

Routine Description:

    Increments the refcount on appool process.

Arguments:

    pAppPoolProcess - the object to increment

Return Value:

    None

--***************************************************************************/
VOID
UlReferenceAppPoolProcess(
    IN PUL_APP_POOL_PROCESS pAppPoolProcess
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG    RefCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_PROCESS(pAppPoolProcess));

    RefCount = InterlockedIncrement(&pAppPoolProcess->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pAppPoolProcessTraceLog,
        REF_ACTION_REFERENCE_APP_POOL_PROCESS,
        RefCount,
        pAppPoolProcess,
        pFileName,
        LineNumber
        );

    UlTrace(ROUTING,(
        "http!UlReferenceAppPoolProcess app=%p refcount=%d\n",
        pAppPoolProcess,
        RefCount
        ));

}   // UlReferenceAppPoolProcess


/***************************************************************************++

Routine Description:

    Decrements the refcount.  If it hits 0, it completes the pending cleanup
    irp for the process.  But does not free up the process structure itself.
    The structure get cleaned up when close on the process handle happens.

    FastIo path may call us at dispacth level, luckily pAppPoolProcess is
    from nonpaged pool and we queue a work item.

Arguments:

    pAppPoolProcess - the object to decrement

Return Value:

    None

--***************************************************************************/
VOID
UlDereferenceAppPoolProcess(
    IN PUL_APP_POOL_PROCESS pAppPoolProcess
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG    RefCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_PROCESS(pAppPoolProcess));

    RefCount = InterlockedDecrement(&pAppPoolProcess->RefCount);

    //
    // Tracing.
    //

    WRITE_REF_TRACE_LOG(
        g_pAppPoolProcessTraceLog,
        REF_ACTION_DEREFERENCE_APP_POOL_PROCESS,
        RefCount,
        pAppPoolProcess,
        pFileName,
        LineNumber
        );

    UlTrace(ROUTING, (
        "http!UlDereferenceAppPoolProcess app=%p refcount=%d\n",
        pAppPoolProcess,
        RefCount
        ));

    if (RefCount == 0)
    {
        ASSERT(pAppPoolProcess->pCleanupIrp);

        UlpCleanUpAppoolProcess(pAppPoolProcess);
    }

}   // UlDereferenceAppPoolProcess

#endif // REFERENCE_DEBUG


/***************************************************************************++

Routine Description:

    The actual cleanup routine to do the original cleanup Irp completion
    once the refcount on the process reaches to zero.

Arguments:

    pAppPoolProcess - the appool process

Return Value:

    None

--***************************************************************************/
VOID
UlpCleanUpAppoolProcess(
    IN PUL_APP_POOL_PROCESS pAppPoolProcess
    )
{
    PIRP    pIrp;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_PROCESS(pAppPoolProcess));
    ASSERT(pAppPoolProcess->RefCount == 0);

    pIrp = pAppPoolProcess->pCleanupIrp;

    ASSERT(pIrp);

    WRITE_APP_POOL_TIME_TRACE_LOG(
        pAppPoolProcess->pAppPool,
        pAppPoolProcess,
        APP_POOL_TIME_ACTION_DETACH_PROCESS_COMPLETE
        );

    pAppPoolProcess->pCleanupIrp = NULL;

    UlTrace(ROUTING,(
        "http!UlpCleanUpAppoolProcess: pAppPoolProcess %p pIrp %p\n",
        pAppPoolProcess,
        pIrp
        ));

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

}   // UlpCleanUpAppoolProcess


/***************************************************************************++

Routine Description:

    Destructs the apool object.

Arguments:

    pAppPool    - the object to destruct

Return Value:

    None

--***************************************************************************/
VOID
UlDeleteAppPool(
    IN PUL_APP_POOL_OBJECT pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
#if REFERENCE_DEBUG
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    ASSERT(0 == pAppPool->RefCount);

    //
    // There better not be any process objects hanging around.
    //

    ASSERT(IsListEmpty(&pAppPool->ProcessListHead));

    //
    // There better not be any pending requests hanging around.
    //

    ASSERT(IsListEmpty(&pAppPool->NewRequestHead));

    //
    // If we're holding a ref on a control channel, release it.
    //

    if (pAppPool->pControlChannel)
    {
        DEREFERENCE_CONTROL_CHANNEL(pAppPool->pControlChannel);
    }

    WRITE_APP_POOL_TIME_TRACE_LOG(
        pAppPool,
        NULL,
        APP_POOL_TIME_ACTION_DESTROY_APPOOL
        );

    UL_FREE_POOL_WITH_SIG(pAppPool, UL_APP_POOL_OBJECT_POOL_TAG);

}   // UlDeleteAppPool


/***************************************************************************++

Routine Description:

    Queries the app-pool queue length.

Arguments:

    pProcess            - the appool process
    InformationClass    - tells which information we want to query
    pAppPoolInformation - pointer to the buffer to return information
    Length              - length of the buffer to return information
    pReturnLength       - tells how many bytes we have returned

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryAppPoolInformation(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID                           pAppPoolInformation,
    IN  ULONG                           Length,
    OUT PULONG                          pReturnLength
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Length);

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pReturnLength);
    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));

    //
    // Do the action.
    //

    switch (InformationClass)
    {
    case HttpAppPoolQueueLengthInformation:
        *((PULONG) pAppPoolInformation) = pProcess->pAppPool->MaxRequests;

        *pReturnLength = sizeof(ULONG);
        break;

    case HttpAppPoolStateInformation:
        *((PHTTP_APP_POOL_ENABLED_STATE) pAppPoolInformation) =
                pProcess->pAppPool->State;

        *pReturnLength = sizeof(HTTP_APP_POOL_ENABLED_STATE);
        break;

    case HttpAppPoolLoadBalancerInformation:
        *((PHTTP_LOAD_BALANCER_CAPABILITIES) pAppPoolInformation) =
                pProcess->pAppPool->LoadBalancerCapability;

        *pReturnLength = sizeof(HTTP_LOAD_BALANCER_CAPABILITIES);
        break;

    default:
        //
        // Should have been caught in UlQueryAppPoolInformationIoctl.
        //

        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;

}   // UlQueryAppPoolInformation


/***************************************************************************++

Routine Description:

    Sets the app-pool queue length etc.

Arguments:

    pProcess            - the appool process
    InformationClass    - tells which information we want to set
    pAppPoolInformation - pointer to the buffer for the input information
    Length              - length of the buffer for the input information

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetAppPoolInformation(
    IN PUL_APP_POOL_PROCESS             pProcess,
    IN HTTP_APP_POOL_INFORMATION_CLASS  InformationClass,
    IN PVOID                            pAppPoolInformation,
    IN ULONG                            Length
    )
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    ULONG                           QueueLength;
    HTTP_APP_POOL_ENABLED_STATE     State;
    HTTP_LOAD_BALANCER_CAPABILITIES Capabilities;

    UNREFERENCED_PARAMETER(Length);

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(pAppPoolInformation);

    //
    // Do the action.
    //

    switch (InformationClass)
    {
    case HttpAppPoolQueueLengthInformation:
        QueueLength = *((PULONG) pAppPoolInformation);

        if (QueueLength > UL_MAX_REQUESTS_QUEUED ||
            QueueLength < UL_MIN_REQUESTS_QUEUED)
        {
            return STATUS_NOT_SUPPORTED;
        }
        else
        {
            Status = UlpSetAppPoolQueueLength(pProcess, QueueLength);
        }
        break;

    case HttpAppPoolStateInformation:
        State = *((PHTTP_APP_POOL_ENABLED_STATE) pAppPoolInformation);

        if (State < HttpAppPoolEnabled ||
            State >= HttpAppPoolEnabledMaximum)
        {
            Status = STATUS_NOT_SUPPORTED;
        }
        else
        {
            UlpSetAppPoolState(pProcess, State);
        }
        break;

    case HttpAppPoolLoadBalancerInformation:
        Capabilities =
            *((PHTTP_LOAD_BALANCER_CAPABILITIES) pAppPoolInformation);

        if (Capabilities != HttpLoadBalancerBasicCapability &&
            Capabilities != HttpLoadBalancerSophisticatedCapability)
        {
            Status = STATUS_NOT_SUPPORTED;
        }
        else
        {
            UlpSetAppPoolLoadBalancerCapability(pProcess, Capabilities);
        }
        break;

    case HttpAppPoolControlChannelInformation:
    {
        PHTTP_APP_POOL_CONTROL_CHANNEL pControlChannelInfo;
        PUL_CONTROL_CHANNEL pControlChannel;
        
        if (Length < sizeof(HTTP_APP_POOL_CONTROL_CHANNEL))
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            pControlChannelInfo = 
                (PHTTP_APP_POOL_CONTROL_CHANNEL) pAppPoolInformation;

            if (pControlChannelInfo->Flags.Present)
            {
                Status = UlGetControlChannelFromHandle(
                            pControlChannelInfo->ControlChannel,
                            UserMode,
                            &pControlChannel
                            );

                if (NT_SUCCESS(Status))
                {
                    UlpSetAppPoolControlChannelHelper(
                        pProcess,
                        pControlChannel
                        );
                }
            }
        }
    }
        break;

    default:
        //
        // Should have been caught in UlSetAppPoolInformationIoctl.
        //

        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;

}   // UlSetAppPoolInformation

/*++

Routine Description:

    Sets the app-pool control channel property.  Must be non-pageable
    because we need to take the app pool spin lock.

Arguments:

    pProcess            - the appool process
    pControlChannel     - the new control channel to set on the app pool

 --*/
VOID
UlpSetAppPoolControlChannelHelper(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    PUL_CONTROL_CHANNEL     pOldControlChannel;
    PUL_APP_POOL_OBJECT     pAppPool;
    KLOCK_QUEUE_HANDLE      LockHandle;

    // NOT_PAGEABLE

    pAppPool = pProcess->pAppPool;

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Get the old control channle (if any)
    //
    
    pOldControlChannel = pAppPool->pControlChannel;

    //
    // Set new control channel on app pool
    //
    
    pProcess->pAppPool->pControlChannel = pControlChannel;

    //
    // If we already have a control channel on the app pool,
    // remove this app pool's count & deref old control channel.
    //
    
    if (pOldControlChannel)
    {
        InterlockedExchangeAdd(
            (PLONG)&pOldControlChannel->AppPoolProcessCount,
            -((LONG)pProcess->pAppPool->NumberActiveProcesses)
            );
        
        DEREFERENCE_CONTROL_CHANNEL(pOldControlChannel);
    }

    //
    // add this AppPool's active process count to control channel.
    //
    
    InterlockedExchangeAdd(
        (PLONG)&pControlChannel->AppPoolProcessCount,
        pProcess->pAppPool->NumberActiveProcesses
        );

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    return;
}


/***************************************************************************++

Routine Description:

    Convert AppPoolEnabledState to ErrorCode.

Arguments:

    State   - AppPoolEnabledState

Return Value:

    ErrorCode

--***************************************************************************/
UL_HTTP_ERROR
UlpConvertAppPoolEnabledStateToErrorCode(
    IN HTTP_APP_POOL_ENABLED_STATE  State
    )
{
    UL_HTTP_ERROR   ErrorCode;

    ASSERT(State != HttpAppPoolEnabled);

    switch (State)
    {
    case HttpAppPoolDisabled_RapidFailProtection:
        ErrorCode = UlErrorRapidFailProtection;
        break;

    case HttpAppPoolDisabled_AppPoolQueueFull:
        ErrorCode = UlErrorAppPoolQueueFull;
        break;

    case HttpAppPoolDisabled_ByAdministrator:
        ErrorCode = UlErrorDisabledByAdmin;
        break;

    case HttpAppPoolDisabled_JobObjectFired:
        ErrorCode = UlErrorJobObjectFired;
        break;

    case HttpAppPoolEnabled:
    default:
        ASSERT(!"Invalid HTTP_APP_POOL_ENABLED_STATE");
        ErrorCode = UlErrorUnavailable;   // generic 503
        break;
    }

    return ErrorCode;

}   // UlpConvertAppPoolEnabledStateToErrorCode


/***************************************************************************++

Routine Description:

    Marks an app pool as active or inactive.  If setting to inactive,
    will return immediately 503 on all requests queued to app pool.

Arguments:

    pProcess    - the app pool process object with which the irp is associated
    State       - mark app pool as active or inactive

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetAppPoolState(
    IN PUL_APP_POOL_PROCESS         pProcess,
    IN HTTP_APP_POOL_ENABLED_STATE  State
    )
{
    PUL_APP_POOL_OBJECT     pAppPool;
    KLOCK_QUEUE_HANDLE      LockHandle;
    PUL_INTERNAL_REQUEST    pRequest;
    PUL_HTTP_CONNECTION     pHttpConn;
    ULONG                   Requests = 0;
    UL_HTTP_ERROR           ErrorCode = UlErrorUnavailable;
    LIST_ENTRY              NewRequestHead;
    PLIST_ENTRY             pEntry;

    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    pAppPool = pProcess->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    UlTrace(ROUTING, (
        "http!UlpSetAppPoolState(AppPool=%p, %lu).\n",
        pAppPool, (ULONG) State
        ));

    InitializeListHead(&NewRequestHead);

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    pAppPool->State = State;

    if (State != HttpAppPoolEnabled)
    {
        ErrorCode = UlpConvertAppPoolEnabledStateToErrorCode(State);

        WRITE_APP_POOL_TIME_TRACE_LOG(
            pAppPool,
            (PVOID) (ULONG_PTR) State,
            APP_POOL_TIME_ACTION_MARK_APPOOL_INACTIVE
            );

        while (NULL != (pRequest = UlpDequeueRequest(
                                        pAppPool,
                                        &pAppPool->NewRequestHead
                                        )))
        {
            //
            // Move the entry to a local list so we can process them
            // outside the app pool lock.
            //

            InsertTailList(&NewRequestHead, &pRequest->AppPool.AppPoolEntry);
        }
    }
    else
    {
        WRITE_APP_POOL_TIME_TRACE_LOG(
            pAppPool,
            NULL,
            APP_POOL_TIME_ACTION_MARK_APPOOL_ACTIVE
            );
    }

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Send 503 to all the requests we have removed from the queue.
    //

    while (!IsListEmpty(&NewRequestHead))
    {
        pEntry = RemoveHeadList(&NewRequestHead);
        pEntry->Flink = pEntry->Blink = NULL;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        pHttpConn = pRequest->pHttpConn;
        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

        UlAcquirePushLockExclusive(&pHttpConn->PushLock);

        if (pHttpConn->UlconnDestroyed)
        {
            ASSERT(NULL == pHttpConn->pRequest);
        }
        else
        {
            UlSetErrorCode(pRequest, ErrorCode, pAppPool);

            UlSendErrorResponse(pHttpConn);
        }

        UlReleasePushLockExclusive(&pHttpConn->PushLock);

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

        ++Requests;
    }

    if (State != HttpAppPoolEnabled)
    {
        UlTrace(ROUTING, (
            "%lu unhandled requests 503'd from AppPool %p.\n",
            Requests, pAppPool
            ));
    }

    return STATUS_SUCCESS;

}   // UlpSetAppPoolState


/***************************************************************************++

Routine Description:

    Sets the load balancer capabilities of an app pool to Basic
    or Sophisticated.

Arguments:

    pProcess                - the app pool process object with which the irp
                                is associated.
    LoadBalancerCapability  - new capability

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetAppPoolLoadBalancerCapability(
    IN PUL_APP_POOL_PROCESS            pProcess,
    IN HTTP_LOAD_BALANCER_CAPABILITIES LoadBalancerCapability
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    KLOCK_QUEUE_HANDLE  LockHandle;

    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    pAppPool = pProcess->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    UlTrace(ROUTING, (
        "http!UlpSetAppPoolLoadBalancerCapability(AppPool=%p, %lu).\n",
        pAppPool, (ULONG) LoadBalancerCapability
        ));

    UlAcquireInStackQueuedSpinLock(&pProcess->pAppPool->SpinLock, &LockHandle);

    pAppPool->LoadBalancerCapability = LoadBalancerCapability;

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    WRITE_APP_POOL_TIME_TRACE_LOG(
        pAppPool,
        (PVOID) (ULONG_PTR) LoadBalancerCapability,
        APP_POOL_TIME_ACTION_LOAD_BAL_CAPABILITY
        );

    return STATUS_SUCCESS;

}   // UlpSetAppPoolLoadBalancerCapability


/***************************************************************************++

Routine Description:

    Associates an irp with the apool that will be completed prior to any
    requests being queued.

Arguments:

    pProcess - the process object that is queueing this irp
    pIrp - the irp to associate.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDemandStart(
    IN  PUL_APP_POOL_PROCESS    pProcess,
    IN  PIRP                    pIrp
    )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;
    KLOCK_QUEUE_HANDLE  LockHandle;
    PEPROCESS           CurrentProcess = PsGetCurrentProcess();

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));
    ASSERT(pIrp != NULL);

    //
    // DemandStart IRPs can only come from controller processes.
    //

    if (!pProcess->Controller)
    {
        return STATUS_INVALID_ID_AUTHORITY;
    }

    UlAcquireInStackQueuedSpinLock(&pProcess->pAppPool->SpinLock, &LockHandle);

    //
    // Make sure we're not cleaning up the process
    //

    if (pProcess->InCleanup)
    {
        Status = STATUS_INVALID_HANDLE;
        goto end;
    }

    //
    // Already got one?
    //

    if (pProcess->pAppPool->pDemandStartIrp != NULL)
    {
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto end;
    }

    //
    // Anything waiting in the queue?
    //

    if (IsListEmpty(&pProcess->pAppPool->NewRequestHead))
    {
        //
        // Nope, pend the irp.
        //

        IoMarkIrpPending(pIrp);

        //
        // Give the irp a pointer to the app pool.
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer =
            pProcess->pAppPool;

        REFERENCE_APP_POOL(pProcess->pAppPool);

        //
        // The cancel routine better not see an irp if it runs immediately.
        //

        ASSERT(pProcess->pAppPool->pDemandStartIrp == NULL);

        IoSetCancelRoutine(pIrp, &UlpCancelDemandStart);

        //
        // Cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // Darn it, need to make sure the irp get's completed.
            //

            if (IoSetCancelRoutine(pIrp, NULL) != NULL)
            {
                //
                // We are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  Ioctl wrapper
                // will complete it.
                //

                DEREFERENCE_APP_POOL(pProcess->pAppPool);

                pIrp->IoStatus.Information = 0;

                UlUnmarkIrpPending(pIrp);
                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // Our cancel routine will run and complete the irp,
            // don't touch it.
            //
            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the irp.
            //

            Status = STATUS_PENDING;
            goto end;
        }


        //
        // Now we are safe to queue it.
        //

        pProcess->pAppPool->pDemandStartIrp = pIrp;
        pProcess->pAppPool->pDemandStartProcess = CurrentProcess;

        Status = STATUS_PENDING;
        goto end;
    }
    else
    {
        //
        // Something's in the queue, instant demand start.
        //

        IoMarkIrpPending(pIrp);

        pIrp->IoStatus.Status = STATUS_SUCCESS;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);

        Status = STATUS_PENDING;
        goto end;
    }

end:

    UlReleaseInStackQueuedSpinLock(&pProcess->pAppPool->SpinLock, &LockHandle);

    return Status;

}   // UlWaitForDemandStart


/***************************************************************************++

Routine Description:

    Receives a new http request into pIrp or pend the irp if no request
    is available.

Arguments:

    RequestId   - NULL for new requests, non-NULL for a specific request,
                    which must be on the special queue
    Flags       - ignored
    pProcess    - the process that wants the request
    pIrp        - the irp to receive the request

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveHttpRequest(
    IN  HTTP_REQUEST_ID         RequestId,
    IN  ULONG                   Flags,
    IN  PUL_APP_POOL_PROCESS    pProcess,
    IN  PIRP                    pIrp
    )
{
    NTSTATUS                Status;
    PUL_INTERNAL_REQUEST    pRequest = NULL;
    KLOCK_QUEUE_HANDLE      LockHandle;
    PIO_STACK_LOCATION      pIrpSp;

    UNREFERENCED_PARAMETER(Flags);

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));
    ASSERT(pIrp);
    ASSERT(pIrp->MdlAddress);

    UlAcquireInStackQueuedSpinLock(&pProcess->pAppPool->SpinLock, &LockHandle);

    //
    // Make sure we're not cleaning up the process.
    //

    if (pProcess->InCleanup)
    {
        Status = STATUS_INVALID_HANDLE;

        UlReleaseInStackQueuedSpinLock(
            &pProcess->pAppPool->SpinLock,
            &LockHandle
            );
        goto end;
    }

    //
    // Is this for a new request?
    //

    if (HTTP_IS_NULL_ID(&RequestId))
    {
        //
        // Do we have a queue'd new request?
        //

        Status = UlDequeueNewRequest(pProcess, 0, &pRequest);

        if (!NT_SUCCESS(Status) && STATUS_NOT_FOUND != Status)
        {
            UlReleaseInStackQueuedSpinLock(
                &pProcess->pAppPool->SpinLock,
                &LockHandle
                );
            goto end;
        }

        if (pRequest == NULL)
        {
            //
            // Nope, queue the irp up.
            //

            IoMarkIrpPending(pIrp);

            //
            // Give the irp a pointer to the app pool process.
            //

            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pProcess;

            REFERENCE_APP_POOL_PROCESS(pProcess);

            //
            // Set to these to null just in case the cancel routine runs.
            //

            pIrp->Tail.Overlay.ListEntry.Flink = NULL;
            pIrp->Tail.Overlay.ListEntry.Blink = NULL;

            IoSetCancelRoutine(pIrp, &UlpCancelHttpReceive);

            //
            // Cancelled?
            //

            if (pIrp->Cancel)
            {
                //
                // Darn it, need to make sure the irp get's completed.
                //

                if (IoSetCancelRoutine(pIrp, NULL) != NULL)
                {
                    //
                    // We are in charge of completion, IoCancelIrp didn't
                    // see our cancel routine (and won't).  Ioctl wrapper
                    // will complete it.
                    //

                    UlReleaseInStackQueuedSpinLock(
                        &pProcess->pAppPool->SpinLock,
                        &LockHandle
                        );

                    REFERENCE_APP_POOL_PROCESS(pProcess);

                    pIrp->IoStatus.Information = 0;

                    UlUnmarkIrpPending(pIrp);
                    Status = STATUS_CANCELLED;
                    goto end;
                }

                //
                // Our cancel routine will run and complete the irp,
                // don't touch it.
                //

                UlReleaseInStackQueuedSpinLock(
                    &pProcess->pAppPool->SpinLock,
                    &LockHandle
                    );

                //
                // STATUS_PENDING will cause the ioctl wrapper to
                // not complete (or touch in any way) the irp.
                //

                Status = STATUS_PENDING;
                goto end;
            }

            //
            // Now we are safe to queue it.
            //

            InsertTailList(
                &pProcess->NewIrpHead,
                &pIrp->Tail.Overlay.ListEntry
                );

            UlReleaseInStackQueuedSpinLock(
                &pProcess->pAppPool->SpinLock,
                &LockHandle
                );

            Status = STATUS_PENDING;
            goto end;
        }
        else // if (pRequest == NULL)
        {
            //
            // Have a queue'd request, serve it up!
            //
            // UlDequeueNewRequest gives ourselves a short-lived reference.
            //

            UlReleaseInStackQueuedSpinLock(
                &pProcess->pAppPool->SpinLock,
                &LockHandle
                );

            //
            // Copy it to the irp, the routine will take ownership
            // of pRequest if it is not able to copy it to the irp.
            //
            // It will also complete the irp so don't touch it later.
            //

            IoMarkIrpPending(pIrp);

            UlCopyRequestToIrp(pRequest, pIrp, TRUE, FALSE);
            pIrp = NULL;

            //
            // Let go our short-lived reference.
            //

            UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
            pRequest = NULL;

            Status = STATUS_PENDING;
            goto end;
        }
    }
    else // if (HTTP_IS_NULL_ID(&RequestId))
    {
        //
        // Need to grab the specific request from id.
        //

        pRequest = UlGetRequestFromId(RequestId, pProcess);

        if (!pRequest)
        {
            Status = STATUS_CONNECTION_INVALID;

            UlReleaseInStackQueuedSpinLock(
                &pProcess->pAppPool->SpinLock,
                &LockHandle
                );
            goto end;
        }

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        //
        // Let go the lock.
        //

        UlReleaseInStackQueuedSpinLock(
            &pProcess->pAppPool->SpinLock,
            &LockHandle
            );

        UlTrace(ROUTING, (
            "http!UlReceiveHttpRequest(ID = %I64x, pProcess = %p)\n"
            "    pAppPool = %p (%S)\n"
            "    Found pRequest = %p on PendingRequest queue\n",
            RequestId,
            pProcess,
            pProcess->pAppPool,
            pProcess->pAppPool->pName,
            pRequest
            ));

        //
        // Copy it to the irp, the routine will take ownership
        // of pRequest if it is not able to copy it to the irp.
        //

        IoMarkIrpPending(pIrp);

        UlCopyRequestToIrp(pRequest, pIrp, TRUE, FALSE);

        //
        // Let go our reference.
        //

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;

        Status = STATUS_PENDING;
        goto end;
    }

end:

    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;
    }

    //
    // At this point if Status != STATUS_PENDING, the ioctl wrapper will
    // complete pIrp.
    //

    return Status;

} // UlReceiveHttpRequest


/***************************************************************************++

Routine Description:

    Called by the http engine to deliver a request to an apool.

    This attempts to find a free irp from any process attached to the apool
    and copies the request to that irp.

    Otherwise it queues the request, without taking a refcount on it.  The
    request will remove itself from this queue if the connection is dropped.

Arguments:

    pAppPool        - the AppPool
    pRequest        - the request to deliver
    pIrpToComplete  - optionally provides a pointer of the irp to complete

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDeliverRequestToProcess(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest,
    OUT PIRP *              pIrpToComplete OPTIONAL
    )
{
    NTSTATUS                Status;
    PUL_APP_POOL_OBJECT     pDemandStartAppPool;
    PIRP                    pDemandStartIrp;
    PIRP                    pIrp = NULL;
    PUL_APP_POOL_PROCESS    pProcess = NULL;
    KLOCK_QUEUE_HANDLE      LockHandle;
    PVOID                   pUrl;
    ULONG                   UrlLength;
    PUL_CONTROL_CHANNEL     pControlChannel;
    BOOLEAN                 FailedDemandStart = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo));
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(!pIrpToComplete || !(*pIrpToComplete));

    UlTrace(ROUTING, (
        "http!UlDeliverRequestToProcess(pRequest = %p)\n"
        "    verb + path -> %d %S\n"
        "    pAppPool = %p (%S)\n",
        pRequest,
        pRequest->Verb,
        pRequest->CookedUrl.pUrl,
        pAppPool,
        pAppPool->pName
        ));

    //
    // Grab the lock!
    //

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    TRACE_TIME(
        pRequest->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_ROUTE_REQUEST
        );

    //
    // Was the app pool enabled yet?
    //

    if (pAppPool->State != HttpAppPoolEnabled)
    {
        UlSetErrorCode(
                pRequest,
                UlpConvertAppPoolEnabledStateToErrorCode(pAppPool->State),
                pAppPool
                );

        UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

        return STATUS_PORT_DISCONNECTED;
    }

    Status = STATUS_SUCCESS;

    //
    // Complete the demand start if this is the very first request so we can
    // do load balancing for web gardens, or if there is no worker process
    // being started in which case we have no choice.
    //

    if (pAppPool->pDemandStartIrp &&
        (pRequest->FirstRequest || !pAppPool->NumberActiveProcesses))
    {
        pControlChannel = pAppPool->pControlChannel;

        if (pControlChannel && 
            (pControlChannel->AppPoolProcessCount >= pControlChannel->DemandStartThreshold))
        {
            //
            // If we currently exceed our demand start threshold, do
            // not complete the demand start Irp AND fail the queuing of the
            // request (send back a 503).
            //
            
            ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
            
            FailedDemandStart = TRUE;
        }
        else
        {
            // Do the Irp Dance
            
            pDemandStartIrp = pAppPool->pDemandStartIrp;

            //
            // Pop the cancel routine.
            //

            if (IoSetCancelRoutine(pDemandStartIrp, NULL) == NULL)
            {
                //
                // IoCancelIrp pop'd it first.
                //
                // Ok to just ignore this irp, it's been pop'd off the queue
                // and will be completed in the cancel routine.
                //
                // No need to complete it.
                //
            }
            else
            if (pDemandStartIrp->Cancel)
            {
                //
                // We pop'd it first, but the irp is being cancelled
                // and our cancel routine will never run.
                //

                pDemandStartAppPool = (PUL_APP_POOL_OBJECT)
                    IoGetCurrentIrpStackLocation(pDemandStartIrp)->
                        Parameters.DeviceIoControl.Type3InputBuffer;

                ASSERT(pDemandStartAppPool == pAppPool);

                DEREFERENCE_APP_POOL(pDemandStartAppPool);

                IoGetCurrentIrpStackLocation(pDemandStartIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                pDemandStartIrp->IoStatus.Status = STATUS_CANCELLED;
                pDemandStartIrp->IoStatus.Information = 0;

                UlCompleteRequest(pDemandStartIrp, IO_NO_INCREMENT);
            }
            else
            {
                //
                // Free to use the irp.
                //

                pDemandStartAppPool = (PUL_APP_POOL_OBJECT)
                    IoGetCurrentIrpStackLocation(pDemandStartIrp)->
                        Parameters.DeviceIoControl.Type3InputBuffer;

                ASSERT(pDemandStartAppPool == pAppPool);

                DEREFERENCE_APP_POOL(pDemandStartAppPool);

                IoGetCurrentIrpStackLocation(pDemandStartIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                pDemandStartIrp->IoStatus.Status = STATUS_SUCCESS;
                pDemandStartIrp->IoStatus.Information = 0;

                UlCompleteRequest(pDemandStartIrp, IO_NETWORK_INCREMENT);
            }

            pAppPool->pDemandStartProcess = NULL;
            pAppPool->pDemandStartIrp = NULL;
        }
    }

    //
    // Hook up request references.
    //

    UL_REFERENCE_INTERNAL_REQUEST(pRequest);

    if (pAppPool->NumberActiveProcesses <= 1)
    {
        //
        // Bypass process binding if we have only one active process.
        //

        pProcess = NULL;
        pIrp = UlpPopNewIrp(pAppPool, pRequest, &pProcess);
    }
    else
    {
        //
        // Check for a process binding.
        //

        pProcess = UlQueryProcessBinding(pRequest->pHttpConn, pAppPool);

        if (UlpIsProcessInAppPool(pProcess, pAppPool))
        {
            //
            // We're bound to a valid process.
            // Try to get a free irp from that process.
            //

            pIrp = UlpPopIrpFromProcess(pProcess, pRequest);
        }
        else
        {
            //
            // Remove the binding if we were previously bound to a process.
            //

            if (pProcess)
            {
                UlBindConnectionToProcess(
                    pRequest->pHttpConn,
                    pAppPool,
                    NULL
                    );
            }

            //
            // We are unbound or bound to a process that went away.
            // Try and get an free irp from any process.
            //

            pProcess = NULL;
            pIrp = UlpPopNewIrp(pAppPool, pRequest, &pProcess);

            //
            // Establish a binding if we got something.
            //

            if (pIrp != NULL)
            {
                ASSERT(IS_VALID_AP_PROCESS(pProcess));

                Status = UlBindConnectionToProcess(
                            pRequest->pHttpConn,
                            pAppPool,
                            pProcess
                            );

                //
                // Is there anything special we should do on
                // failure? I don't think it should be fatal.
                //

                Status = STATUS_SUCCESS;
            }
        }
    }

    if (ETW_LOG_MIN())
    {
        pUrl = NULL;
        UrlLength = 0;

        //
        // Trace the URL optionally here in case we turned off ParseHook.
        //

        if (ETW_LOG_URL())
        {
            pUrl = pRequest->CookedUrl.pUrl;
            UrlLength = pRequest->CookedUrl.Length;
        }

        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_ULDELIVER,
            (PVOID) &pRequest,
            sizeof(PVOID),
            &pRequest->RequestIdCopy,
            sizeof(HTTP_REQUEST_ID),
            &pRequest->ConfigInfo.SiteId,
            sizeof(ULONG),
            pRequest->ConfigInfo.pAppPool->pName,
            pRequest->ConfigInfo.pAppPool->NameLength,
            pUrl,
            UrlLength,
            NULL,
            0
            );
    }

    //
    // If we have an IRP, complete it.  Otherwise queue the request.
    //

    if (pIrp != NULL)
    {
        ASSERT(pIrp->MdlAddress != NULL);
        ASSERT(pProcess->InCleanup == 0);

        //
        // We are all done and about to complete the irp, free the lock.
        //

        UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

        UlTrace(ROUTING, (
            "http!UlDeliverRequestToProcess(pRequest = %p, pProcess = %p)\n"
            "    queued pending request. pAppPool = %p (%S)\n",
            pRequest,
            pProcess,
            pProcess->pAppPool,
            pProcess->pAppPool->pName
            ));

        //
        // Copy it to the irp, the routine will take ownership
        // of pRequest if it is not able to copy it to the irp.
        //
        // It will also complete the irp, don't touch it later.
        //

        if (pIrpToComplete)
        {
            UlCopyRequestToIrp(pRequest, pIrp, FALSE, TRUE);
            *pIrpToComplete = pIrp;
        }
        else
        {
            UlCopyRequestToIrp(pRequest, pIrp, TRUE, TRUE);
        }
    }
    else
    {
        ASSERT(pIrp == NULL);

        if (FailedDemandStart)
        {
            UlTrace(ROUTING, (
                "http!UlDeliverRequestToProcess(pRequest = %p, pAppPool = %p)\n"
                "    Failing request because Demand Start Threshold exceeded.\n",
                pRequest,
                pAppPool
                ));

            UlSetErrorCode(  pRequest, UlErrorUnavailable, pAppPool);

            Status = STATUS_PORT_DISCONNECTED;
        }
        else
        {
            //
            // Either didn't find an IRP or there's stuff on the pending request
            // list, so queue this pending request.
            //

            Status = UlpQueueUnboundRequest(pAppPool, pRequest);
        }

        if (!NT_SUCCESS(Status))
        {
            //
            // Doh! We couldn't queue it, so let go of the request.
            //

            UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        }
        
        //
        // Now we finished queue'ing the request, free the lock.
        //

        UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);
    }

    return Status;

}   // UlDeliverRequestToProcess


/***************************************************************************++

Routine Description:

    Removes a request from any app pool lists.

Arguments:

    pAppPool    - the appool to unlink the request from
    pRequest    - the request to be unlinked

Return Value:

    None

--***************************************************************************/
VOID
UlUnlinkRequestFromProcess(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    KLOCK_QUEUE_HANDLE  LockHandle;
    BOOLEAN             NeedDeref = FALSE;

    //
    // Sanity check.
    //

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Remove from whatever queue we're on.
    //

    switch (pRequest->AppPool.QueueState)
    {
    case QueueDeliveredState:
        //
        // We're on the apool object new request queue.
        //

        UlpRemoveRequest(pAppPool, pRequest);
        pRequest->AppPool.QueueState = QueueUnlinkedState;

        NeedDeref = TRUE;
        break;

    case QueueCopiedState:
        //
        // We're on the apool process pending queue.
        //

        ASSERT(IS_VALID_AP_PROCESS(pRequest->AppPool.pProcess));
        ASSERT(pRequest->AppPool.pProcess->pAppPool == pAppPool);

        UlpRemoveRequest(pAppPool, pRequest);
        pRequest->AppPool.QueueState = QueueUnlinkedState;

        NeedDeref = TRUE;
        break;

    case QueueUnroutedState:
    case QueueUnlinkedState:
        //
        // It's not on our lists, so we don't do anything.
        //

        break;

    default:
        //
        // This shouldn't happen.
        //

        ASSERT(!"Invalid app pool queue state");
        break;
    }

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Clean up the references.
    //

    if (NeedDeref)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

}   // UlUnlinkRequestFromProcess


/***************************************************************************++

Routine Description:

    Initializes the AppPool module.

Arguments:

    None

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeAP(
    VOID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    ASSERT(!g_InitAPCalled);

    if (!g_InitAPCalled)
    {
        InitializeListHead(&g_AppPoolListHead);
        g_RequestsQueued = 0;

        Status = UlInitializeResource(
                        &g_pUlNonpagedData->AppPoolResource,
                        "AppPoolResource",
                        0,
                        UL_APP_POOL_RESOURCE_TAG
                        );

        if (NT_SUCCESS(Status))
        {
            Status = UlInitializeResource(
                            &g_pUlNonpagedData->DisconnectResource,
                            "DisconnectResource",
                            0,
                            UL_DISCONNECT_RESOURCE_TAG
                            );

            if (NT_SUCCESS(Status))
            {
                //
                // Finished, remember that we're initialized.
                //

                g_InitAPCalled = TRUE;
            }
            else
            {

                UlDeleteResource(&g_pUlNonpagedData->AppPoolResource);
            }
        }
    }

    return Status;

}   // UlInitializeAP


/***************************************************************************++

Routine Description:

    Terminates the AppPool module.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
VOID
UlTerminateAP(
    VOID
    )
{
    if (g_InitAPCalled)
    {
        (VOID) UlDeleteResource(&g_pUlNonpagedData->AppPoolResource);
        (VOID) UlDeleteResource(&g_pUlNonpagedData->DisconnectResource);

        g_InitAPCalled = FALSE;
    }

}   // UlTerminateAP


/***************************************************************************++

Routine Description:

    Allocates and initializes a UL_APP_POOL_PROCESS object.

Arguments:

    None

Return Value:

    NULL on failure, process object on success

--***************************************************************************/
PUL_APP_POOL_PROCESS
UlCreateAppPoolProcess(
    PUL_APP_POOL_OBJECT pObject
    )
{
    PUL_APP_POOL_PROCESS    pProcess;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pProcess = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_APP_POOL_PROCESS,
                    UL_APP_POOL_PROCESS_POOL_TAG
                    );

    if (pProcess)
    {
        RtlZeroMemory(pProcess, sizeof(UL_APP_POOL_PROCESS));

        pProcess->Signature = UL_APP_POOL_PROCESS_POOL_TAG;
        pProcess->pAppPool  = pObject;

        InitializeListHead(&pProcess->NewIrpHead);
        InitializeListHead(&pProcess->PendingRequestHead);

        //
        // Remember the current process (WP).
        //

        pProcess->pProcess = PsGetCurrentProcess();

        //
        // Initialize list of WaitForDisconnect IRPs.
        //

        UlInitializeNotifyHead(&pProcess->WaitForDisconnectHead, NULL);
    }

    return pProcess;

}   // UlCreateAppPoolProcess


/***************************************************************************++

Routine Description:

    Destroys a UL_APP_POOL_PROCESS object.

Arguments:

    pProcess    - object to destory

Return Value:

    None

--***************************************************************************/
VOID
UlCloseAppPoolProcess(
    PUL_APP_POOL_PROCESS pProcess
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(pProcess->InCleanup);
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));

    WRITE_APP_POOL_TIME_TRACE_LOG(
        pProcess->pAppPool,
        pProcess,
        APP_POOL_TIME_ACTION_DESTROY_APPOOL_PROCESS
        );

    //
    // Drop the AppPool reference.
    //

    DEREFERENCE_APP_POOL(pProcess->pAppPool);

    //
    // Free the pool.
    //

    UL_FREE_POOL_WITH_SIG(pProcess, UL_APP_POOL_PROCESS_POOL_TAG);

}   // UlCloseAppPoolProcess


/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to receive demand start
    notification.  This routine ALWAYS results in the irp being completed.

Arguments:

    pDeviceObject   - the device object
    pIrp            - the irp to cancel

Return Value:

    None

--***************************************************************************/
VOID
UlpCancelDemandStart(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    PIO_STACK_LOCATION  pIrpSp;
    KLOCK_QUEUE_HANDLE  LockHandle;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // Release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // Grab the app pool off the irp.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pAppPool = (PUL_APP_POOL_OBJECT)
                    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // Grab the lock protecting the queue'd irp.
    //

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Does it need to be dequeue'd?
    //

    if (pAppPool->pDemandStartIrp != NULL)
    {
        //
        // Remove it.
        //

        pAppPool->pDemandStartIrp = NULL;
        pAppPool->pDemandStartProcess = NULL;
    }

    //
    // Let the lock go.
    //

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    //
    // Let our reference go.
    //

    DEREFERENCE_APP_POOL(pAppPool);

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    //
    // Complete the irp.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

}   // UlpCancelDemandStart


/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to receive the http request.
    this routine ALWAYS results in the irp being completed.

Arguments:

    pDeviceObject   - the device object
    pIrp            - the irp to cancel

Return Value:

    None

--***************************************************************************/
VOID
UlpCancelHttpReceive(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
{
    PUL_APP_POOL_PROCESS    pProcess;
    PIO_STACK_LOCATION      pIrpSp;
    KLOCK_QUEUE_HANDLE      LockHandle;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // Release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // Grab the app pool off the irp.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pProcess = (PUL_APP_POOL_PROCESS)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    //
    // Grab the lock protecting the queue.
    //

    UlAcquireInStackQueuedSpinLock(&pProcess->pAppPool->SpinLock, &LockHandle);

    //
    // Does it need to be de-queue'd?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // Remove it.
        //

        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // Let the lock go.
    //

    UlReleaseInStackQueuedSpinLock(&pProcess->pAppPool->SpinLock, &LockHandle);

    //
    // Let our reference go.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_APP_POOL_PROCESS(pProcess);

    //
    // Complete the irp.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

}   // UlpCancelHttpReceive


/******************************************************************************

Routine Description:

    Copy an HTTP request to a buffer.

Arguments:

    pRequest        - pointer to this request
    pBuffer         - pointer to buffer where we'll copy
    BufferLength    - length of pBuffer
    Flags           - flags for HttpReceiveHttpRequest
    LockAcquired    - either called from UlDeliverRequestToProcess (TRUE)
                        or UlReceiveHttpRequest/UlpFastReceiveHttpRequest
    pBytesCopied    - actual bytes copied

Return Value:

    NTSTATUS - Completion status.

******************************************************************************/
NTSTATUS
UlCopyRequestToBuffer(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR               pKernelBuffer,
    IN PVOID                pUserBuffer,
    IN ULONG                BufferLength,
    IN ULONG                Flags,
    IN BOOLEAN              LockAcquired,
    OUT PULONG              pBytesCopied
    )
{
    PHTTP_REQUEST           pHttpRequest;
    PHTTP_UNKNOWN_HEADER    pUserCurrentUnknownHeader;
    HTTP_HEADER_ID          HeaderId;
    PUL_HTTP_UNKNOWN_HEADER pUnknownHeader;
    PUCHAR                  pCurrentBufferPtr;
    ULONG                   Index;
    ULONG                   BytesCopied;
    ULONG                   HeaderCount = 0;
    PUCHAR                  pLocalAddress;
    PUCHAR                  pRemoteAddress;
    USHORT                  AddressType;
    USHORT                  AddressLength;
    USHORT                  AlignedAddressLength;
    PHTTP_TRANSPORT_ADDRESS pAddress;
    PHTTP_COOKED_URL        pCookedUrl;
    PHTTP_DATA_CHUNK        pDataChunk;
    PLIST_ENTRY             pListEntry;
    PEPROCESS               pProcess;
    NTSTATUS                Status;
    PUCHAR                  pEntityBody;
    LONG                    EntityBodyLength;
    PCWSTR                  pFullUrl;
    PCWSTR                  pHost;
    PCWSTR                  pAbsPath;
    USHORT                  HostLength;
    USHORT                  AbsPathLength;
    HANDLE                  MappedToken = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(pKernelBuffer != NULL);
    ASSERT(pUserBuffer != NULL);
    ASSERT(BufferLength > sizeof(HTTP_REQUEST));

    Status = STATUS_SUCCESS;
    *pBytesCopied = 0;

    __try
    {
        //
        // Set up our pointers to the HTTP_REQUEST structure, the
        // header arrays we're going to fill in, and the pointer to
        // where we're going to start filling them in.
        //

        pHttpRequest = (PHTTP_REQUEST) pKernelBuffer;
        AddressType = pRequest->pHttpConn->pConnection->AddressType;

        if (TDI_ADDRESS_TYPE_IP == AddressType)
        {
            AddressLength = SOCKADDR_ADDRESS_LENGTH_IP;
        }
        else
        if (TDI_ADDRESS_TYPE_IP6 == AddressType)
        {
            AddressLength = SOCKADDR_ADDRESS_LENGTH_IP6;
        }
        else
        {
            ASSERT(!"Invalid AddressType");
            AddressLength = 0;
        }

        //
        // We've allocated enough space for two SOCKADDR_IN6s, so use that.
        //

        AlignedAddressLength =
            (USHORT) ALIGN_UP(SOCKADDR_ADDRESS_LENGTH_IP6, PVOID);
        pLocalAddress  = (PUCHAR) (pHttpRequest + 1);
        pRemoteAddress = pLocalAddress + AlignedAddressLength;

        pUserCurrentUnknownHeader =
            (PHTTP_UNKNOWN_HEADER) (pRemoteAddress + AlignedAddressLength);

        ASSERT((((ULONG_PTR) pUserCurrentUnknownHeader)
                & (TYPE_ALIGNMENT(PVOID) - 1)) == 0);

        pCurrentBufferPtr = (PUCHAR) (pUserCurrentUnknownHeader +
                                      pRequest->UnknownHeaderCount);

        //
        // Now fill in the HTTP request structure.
        //

        ASSERT(!HTTP_IS_NULL_ID(&pRequest->ConnectionId));
        ASSERT(!HTTP_IS_NULL_ID(&pRequest->RequestIdCopy));

        pHttpRequest->ConnectionId  = pRequest->ConnectionId;
        pHttpRequest->RequestId     = pRequest->RequestIdCopy;
        pHttpRequest->UrlContext    = pRequest->ConfigInfo.UrlContext;
        pHttpRequest->Version       = pRequest->Version;
        pHttpRequest->Verb          = pRequest->Verb;
        pHttpRequest->BytesReceived = pRequest->BytesReceived;

        pAddress = &pHttpRequest->Address;

        pAddress->pRemoteAddress = FIXUP_PTR(
                                        PVOID,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pRemoteAddress,
                                        BufferLength
                                        );
        CopyTdiAddrToSockAddr(
            AddressType,
            pRequest->pHttpConn->pConnection->RemoteAddress,
            (struct sockaddr *) pRemoteAddress
            );

        pAddress->pLocalAddress = FIXUP_PTR(
                                        PVOID,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pLocalAddress,
                                        BufferLength
                                        );

        CopyTdiAddrToSockAddr(
            AddressType,
            pRequest->pHttpConn->pConnection->LocalAddress,
            (struct sockaddr *) pLocalAddress
            );

        //
        // And now the cooked url sections.
        //

        //
        // Unicode strings must be at 2-byte boundaries.  All previous data
        // are structures, so the assertion should be true.
        //

        ASSERT(((ULONG_PTR) pCurrentBufferPtr % sizeof(WCHAR)) == 0);

        //
        // Make sure they are valid.
        //

        ASSERT(pRequest->CookedUrl.pUrl != NULL);
        ASSERT(pRequest->CookedUrl.pHost != NULL);
        ASSERT(pRequest->CookedUrl.pAbsPath != NULL);

        //
        // Do the full url.  Must be careful to put any computed values
        // that are subsequently needed on the RHS of expressions into
        // local stack variables before putting them into pCookedUrl.
        // In other words, we must not commit the cardinal sin of reading
        // from pCookedUrl after writing to it, because this is a buffer
        // that the user can overwrite at any instant.
        //

        pCookedUrl = &pHttpRequest->CookedUrl;
        pCookedUrl->FullUrlLength = (USHORT)(pRequest->CookedUrl.Length);

        pFullUrl = FIXUP_PTR(
                        PCWSTR,
                        pUserBuffer,
                        pKernelBuffer,
                        pCurrentBufferPtr,
                        BufferLength
                        );

        pCookedUrl->pFullUrl = pFullUrl;

        //
        // And the host.
        //

        HostLength = DIFF_USHORT(
                        (PUCHAR) pRequest->CookedUrl.pAbsPath -
                        (PUCHAR) pRequest->CookedUrl.pHost
                        );
        pCookedUrl->HostLength = HostLength;
        pHost = pFullUrl +
            DIFF_USHORT(pRequest->CookedUrl.pHost - pRequest->CookedUrl.pUrl);
        pCookedUrl->pHost = pHost;

        //
        // Is there a query string?
        //

        if (pRequest->CookedUrl.pQueryString != NULL)
        {
            AbsPathLength = DIFF_USHORT(
                                (PUCHAR) pRequest->CookedUrl.pQueryString -
                                (PUCHAR) pRequest->CookedUrl.pAbsPath
                                );
            pCookedUrl->AbsPathLength = AbsPathLength;

            pAbsPath = pHost + (HostLength / sizeof(WCHAR));
            pCookedUrl->pAbsPath = pAbsPath;

            pCookedUrl->QueryStringLength =
                (USHORT) (pRequest->CookedUrl.Length) -
                DIFF_USHORT(
                    (PUCHAR) pRequest->CookedUrl.pQueryString -
                    (PUCHAR) pRequest->CookedUrl.pUrl
                    );

            pCookedUrl->pQueryString =
                pAbsPath + (AbsPathLength / sizeof(WCHAR));
        }
        else
        {
            pCookedUrl->AbsPathLength =
                (USHORT) (pRequest->CookedUrl.Length) -
                DIFF_USHORT(
                    (PUCHAR) pRequest->CookedUrl.pAbsPath -
                    (PUCHAR) pRequest->CookedUrl.pUrl
                    );

            pCookedUrl->pAbsPath = pHost + (HostLength / sizeof(WCHAR));

            pCookedUrl->QueryStringLength = 0;
            pCookedUrl->pQueryString = NULL;
        }

        //
        // Copy the full url.
        //

        RtlCopyMemory(
            pCurrentBufferPtr,
            pRequest->CookedUrl.pUrl,
            pRequest->CookedUrl.Length
            );

        pCurrentBufferPtr += pRequest->CookedUrl.Length;

        //
        // Terminate it.
        //

        ((PWSTR) pCurrentBufferPtr)[0] = UNICODE_NULL;
        pCurrentBufferPtr += sizeof(WCHAR);

        //
        // Any raw verb?
        //

        if (pRequest->Verb == HttpVerbUnknown)
        {
            //
            // Need to copy in the raw verb for the client.
            //

            ASSERT(pRequest->RawVerbLength <= ANSI_STRING_MAX_CHAR_LEN);

            pHttpRequest->UnknownVerbLength =
                (pRequest->RawVerbLength * sizeof(CHAR));
            pHttpRequest->pUnknownVerb = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pKernelBuffer,
                                            pCurrentBufferPtr,
                                            BufferLength
                                            );

            RtlCopyMemory(
                pCurrentBufferPtr,
                pRequest->pRawVerb,
                pRequest->RawVerbLength
                );

            BytesCopied = pRequest->RawVerbLength * sizeof(CHAR);
            pCurrentBufferPtr += BytesCopied;

            //
            // Terminate it.
            //

            ((PSTR) pCurrentBufferPtr)[0] = ANSI_NULL;
            pCurrentBufferPtr += sizeof(CHAR);
        }
        else
        {
            pHttpRequest->UnknownVerbLength = 0;
            pHttpRequest->pUnknownVerb = NULL;
        }

        //
        // Copy the raw url.
        //

        ASSERT(pRequest->RawUrl.Length <= ANSI_STRING_MAX_CHAR_LEN);

        pHttpRequest->RawUrlLength = (USHORT) pRequest->RawUrl.Length;
        pHttpRequest->pRawUrl = FIXUP_PTR(
                                    PSTR,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pCurrentBufferPtr,
                                    BufferLength
                                    );

        RtlCopyMemory(
            pCurrentBufferPtr,
            pRequest->RawUrl.pUrl,
            pRequest->RawUrl.Length
            );

        BytesCopied = pRequest->RawUrl.Length;
        pCurrentBufferPtr += BytesCopied;

        //
        // Terminate it.
        //

        ((PSTR) pCurrentBufferPtr)[0] = ANSI_NULL;
        pCurrentBufferPtr += sizeof(CHAR);

        //
        // Copy in the known headers.
        //
        // Loop through the known header array in the HTTP connection,
        // and copy any that we have.
        //

        RtlZeroMemory(
            pHttpRequest->Headers.KnownHeaders,
            HttpHeaderRequestMaximum * sizeof(HTTP_KNOWN_HEADER)
            );

        for (Index = 0; Index < HttpHeaderRequestMaximum; Index++)
        {
            HeaderId = (HTTP_HEADER_ID) pRequest->HeaderIndex[Index];

            if (HeaderId == HttpHeaderRequestMaximum)
            {
                break;
            }

            //
            // Have a header here we need to copy in.
            //

            ASSERT(pRequest->HeaderValid[HeaderId]);
            ASSERT(pRequest->Headers[HeaderId].HeaderLength
                    <= ANSI_STRING_MAX_CHAR_LEN);

            //
            // Ok for HeaderLength to be 0, we will give usermode a pointer
            // pointing to a NULL string.  RawValueLength will be 0.
            //

            pHttpRequest->Headers.KnownHeaders[HeaderId].RawValueLength =
            (USHORT) (pRequest->Headers[HeaderId].HeaderLength * sizeof(CHAR));

            pHttpRequest->Headers.KnownHeaders[HeaderId].pRawValue =
                FIXUP_PTR(
                    PSTR,
                    pUserBuffer,
                    pKernelBuffer,
                    pCurrentBufferPtr,
                    BufferLength
                    );

            RtlCopyMemory(
                pCurrentBufferPtr,
                pRequest->Headers[HeaderId].pHeader,
                pRequest->Headers[HeaderId].HeaderLength
                );

            BytesCopied =
                pRequest->Headers[HeaderId].HeaderLength * sizeof(CHAR);
            pCurrentBufferPtr += BytesCopied;

            //
            // Terminate it.
            //

            ((PSTR) pCurrentBufferPtr)[0] = ANSI_NULL;
            pCurrentBufferPtr += sizeof(CHAR);
        }

        //
        // Now loop through the unknown headers, and copy them in.
        //

        pHttpRequest->Headers.UnknownHeaderCount = pRequest->UnknownHeaderCount;

        if (pRequest->UnknownHeaderCount == 0)
        {
            pHttpRequest->Headers.pUnknownHeaders = NULL;
        }
        else
        {
            pHttpRequest->Headers.pUnknownHeaders =
                FIXUP_PTR(
                    PHTTP_UNKNOWN_HEADER,
                    pUserBuffer,
                    pKernelBuffer,
                    pUserCurrentUnknownHeader,
                    BufferLength
                    );
        }

        pListEntry = pRequest->UnknownHeaderList.Flink;

        while (pListEntry != &pRequest->UnknownHeaderList)
        {
            pUnknownHeader = CONTAINING_RECORD(
                                pListEntry,
                                UL_HTTP_UNKNOWN_HEADER,
                                List
                                );

            pListEntry = pListEntry->Flink;

            HeaderCount++;
            ASSERT(HeaderCount <= pRequest->UnknownHeaderCount);

            //
            // First copy in the header name.
            //

            pUserCurrentUnknownHeader->NameLength =
                pUnknownHeader->HeaderNameLength * sizeof(CHAR);

            pUserCurrentUnknownHeader->pName =
                FIXUP_PTR(
                    PSTR,
                    pUserBuffer,
                    pKernelBuffer,
                    pCurrentBufferPtr,
                    BufferLength
                    );

            RtlCopyMemory(
                pCurrentBufferPtr,
                pUnknownHeader->pHeaderName,
                pUnknownHeader->HeaderNameLength
                );

            BytesCopied = pUnknownHeader->HeaderNameLength * sizeof(CHAR);
            pCurrentBufferPtr += BytesCopied;

            //
            // Terminate it.
            //

            ((PSTR) pCurrentBufferPtr)[0] = ANSI_NULL;
            pCurrentBufferPtr += sizeof(CHAR);

            //
            // Now copy in the header value.
            //

            ASSERT(pUnknownHeader->HeaderValue.HeaderLength <= 0x7fff);

            if (pUnknownHeader->HeaderValue.HeaderLength == 0)
            {
                pUserCurrentUnknownHeader->RawValueLength = 0;
                pUserCurrentUnknownHeader->pRawValue = NULL;
            }
            else
            {
                pUserCurrentUnknownHeader->RawValueLength = (USHORT)
                    (pUnknownHeader->HeaderValue.HeaderLength * sizeof(CHAR));

                pUserCurrentUnknownHeader->pRawValue =
                    FIXUP_PTR(
                        PSTR,
                        pUserBuffer,
                        pKernelBuffer,
                        pCurrentBufferPtr,
                        BufferLength
                        );

                RtlCopyMemory(
                    pCurrentBufferPtr,
                    pUnknownHeader->HeaderValue.pHeader,
                    pUnknownHeader->HeaderValue.HeaderLength
                    );

                BytesCopied =
                    pUnknownHeader->HeaderValue.HeaderLength * sizeof(CHAR);
                pCurrentBufferPtr += BytesCopied;

                //
                // Terminate it.
                //

                ((PSTR) pCurrentBufferPtr)[0] = ANSI_NULL;
                pCurrentBufferPtr += sizeof(CHAR);
            }

            //
            // Skip to the next header.
            //

            pUserCurrentUnknownHeader++;
        }

        //
        // Copy raw connection ID.
        //

        pHttpRequest->RawConnectionId = pRequest->RawConnectionId;

        //
        // Copy in SSL information.
        //

        if (pRequest->pHttpConn->SecureConnection == FALSE)
        {
            pHttpRequest->pSslInfo = NULL;
        }
        else
        {
            pCurrentBufferPtr =
                (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID);

            //
            // When a handling a request on a keepalive connection, it's
            // possible that we might be running on system process's context.
            // Therefore if we are copying over the user credentials we have
            // to duplicate the token on target worker process but not on the
            // system process again.
            //

            pProcess = pRequest->AppPool.pProcess->pProcess;

            Status = UlGetSslInfo(
                        &pRequest->pHttpConn->pConnection->FilterInfo,
                        BufferLength - DIFF(pCurrentBufferPtr - pKernelBuffer),
                        FIXUP_PTR(
                            PUCHAR,
                            pUserBuffer,
                            pKernelBuffer,
                            pCurrentBufferPtr,
                            BufferLength
                            ),
                        pProcess,
                        pCurrentBufferPtr,
                        &MappedToken,
                        &BytesCopied
                        );

            if (NT_SUCCESS(Status) && 0 != BytesCopied)
            {
                pHttpRequest->pSslInfo = FIXUP_PTR(
                                            PHTTP_SSL_INFO,
                                            pUserBuffer,
                                            pKernelBuffer,
                                            pCurrentBufferPtr,
                                            BufferLength
                                            );

                pCurrentBufferPtr += BytesCopied;
            }
            else
            {
                pHttpRequest->pSslInfo = NULL;
            }
        }

        //
        // Copy entity body.
        //

        if (pRequest->ContentLength > 0 || pRequest->Chunked == 1)
        {
            pEntityBody = (PUCHAR)ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID);
            EntityBodyLength = BufferLength - DIFF(pEntityBody - pKernelBuffer);

            if ((Flags & HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY) &&
                EntityBodyLength > 0 &&
                EntityBodyLength > sizeof(HTTP_DATA_CHUNK) &&
                pRequest->ChunkBytesToRead > 0 &&
                pRequest->ChunkBytesRead < pRequest->ChunkBytesParsed)
            {
                pCurrentBufferPtr = pEntityBody;

                //
                // We at least have 1 byte space for entity body so copy it.
                //

                pHttpRequest->EntityChunkCount = 1;
                pHttpRequest->pEntityChunks = FIXUP_PTR(
                                                PHTTP_DATA_CHUNK,
                                                pUserBuffer,
                                                pKernelBuffer,
                                                pCurrentBufferPtr,
                                                BufferLength
                                                );

                pDataChunk = (PHTTP_DATA_CHUNK)pCurrentBufferPtr;
                pCurrentBufferPtr += sizeof(HTTP_DATA_CHUNK);

                pDataChunk->DataChunkType = HttpDataChunkFromMemory;
                pDataChunk->FromMemory.pBuffer = FIXUP_PTR(
                                                    PVOID,
                                                    pUserBuffer,
                                                    pKernelBuffer,
                                                    pCurrentBufferPtr,
                                                    BufferLength
                                                    );

                //
                // Need to take the HttpConnection lock if this is called
                // from the receive I/O path, either fast or slow.  The lock is
                // already taken on the delivery path.
                //

                if (!LockAcquired)
                {
                    UlAcquirePushLockExclusive(&pRequest->pHttpConn->PushLock);
                }

                BytesCopied = UlpCopyEntityBodyToBuffer(
                                    pRequest,
                                    pCurrentBufferPtr,
                                    EntityBodyLength - sizeof(HTTP_DATA_CHUNK),
                                    &pHttpRequest->Flags
                                    );

                if (!LockAcquired)
                {
                    UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);
                }

                if (BytesCopied)
                {
                    pDataChunk->FromMemory.BufferLength = BytesCopied;
                    pCurrentBufferPtr += BytesCopied;
                }
                else
                {
                    //
                    // Be nice and reset EntityChunkCount and pEntityChunks if
                    // UlpCopyEntityBodyToBuffer doesn't copy anything, usually
                    // indicating an error has been hit.
                    //

                    pHttpRequest->EntityChunkCount = 0;
                    pHttpRequest->pEntityChunks = NULL;
                    pHttpRequest->Flags =
                        HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS;
                }
            }
            else
            {
                //
                // Either the app doesn't ask for entity body or we have nothing
                // or can't copy.  Let ReceiveEntityBody handle this.
                //

                pHttpRequest->EntityChunkCount = 0;
                pHttpRequest->pEntityChunks = NULL;
                pHttpRequest->Flags = HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS;
            }
        }
        else
        {
            //
            // This request doesn't have entity bodies.
            //

            pHttpRequest->EntityChunkCount = 0;
            pHttpRequest->pEntityChunks = NULL;
            pHttpRequest->Flags = 0;
        }

        //
        // Make sure we didn't use too much.
        //

        ASSERT(DIFF(pCurrentBufferPtr - pKernelBuffer) <= BufferLength);

        *pBytesCopied = DIFF(pCurrentBufferPtr - pKernelBuffer);
    }
     __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

    TRACE_TIME(
        pRequest->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_COPY_REQUEST
        );

    if (!NT_SUCCESS(Status) && MappedToken)
    {
        //
        // The only reason we can fail after getting a MappedToken is because
        // the code after that throws an exception, which is only possible
        // if UlCopyRequestToBuffer is called from the fast I/O path, which
        // guarantees we are the user's context.
        //

        ASSERT(g_pUlSystemProcess != (PKPROCESS)IoGetCurrentProcess());
        ZwClose(MappedToken);
    }

    return Status;

}   // UlCopyRequestToBuffer


/******************************************************************************

Routine Description:

    Copy as much as entity body as possible to the buffer provided.

Arguments:

    pRequest        - the request to copy the entity body from
    pBuffer         - the buffer to copy the entity body
    BufferLength    - the length of the buffer for the maximum we can copy
    pFlags          - tells if there are still more entity bodies

Return Value:

    Total number of bytes of entity body being copied

******************************************************************************/
ULONG
UlpCopyEntityBodyToBuffer(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR               pEntityBody,
    IN ULONG                EntityBodyLength,
    OUT PULONG              pFlags
    )
{
    ULONGLONG   ChunkBytesRead = pRequest->ChunkBytesRead;
    ULONG       TotalBytesRead;
    NTSTATUS    Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(NULL != pEntityBody);
    ASSERT(EntityBodyLength > 0);
    ASSERT(NULL != pFlags);
    ASSERT(UlDbgPushLockOwnedExclusive(&pRequest->pHttpConn->PushLock));

    UlTrace(ROUTING, (
        "http!UlpCopyEntityBodyToBuffer"
        " pRequest = %p, pEntityBody = %p, EntityBodyLength = %d\n",
        pRequest,
        pEntityBody,
        EntityBodyLength
        ));

    //
    // UlProcessBufferQueue needs to be called in a try/except because
    // pEntityBody can be user mode memory address when called from the
    // fast receive path.
    //

    __try
    {
        UlProcessBufferQueue(pRequest, pEntityBody, EntityBodyLength);
    }
     __except(UL_EXCEPTION_FILTER())
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        return 0;
    }

    if (pRequest->ParseState > ParseEntityBodyState &&
        pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
    {
        *pFlags = 0;
    }
    else
    {
        *pFlags = HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS;
    }

    TotalBytesRead = (ULONG)(pRequest->ChunkBytesRead - ChunkBytesRead);

    ASSERT(TotalBytesRead <= EntityBodyLength);

    return TotalBytesRead;

}   // UlpCopyEntityBodyToBuffer


/******************************************************************************

Routine Description:

    Find a pending IRP to deliver a request to.  This routine must
    be called with the lock on the apool held.

Arguments:

    pAppPool    - the apool to search for the irp
    pRequest    - the request that needs to pop the irp
    ppProcess   - the process that we got the irp from

Return Value:

    A pointer to an IRP if we've found one, or NULL if we didn't

******************************************************************************/
PIRP
UlpPopNewIrp(
    IN  PUL_APP_POOL_OBJECT     pAppPool,
    IN  PUL_INTERNAL_REQUEST    pRequest,
    OUT PUL_APP_POOL_PROCESS *  ppProcess
    )
{
    PUL_APP_POOL_PROCESS    pProcess;
    PIRP                    pIrp = NULL;
    PLIST_ENTRY             pEntry;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(UlDbgSpinLockOwned(&pAppPool->SpinLock));
    ASSERT(ppProcess != NULL);

    //
    // Start looking for a process with a free IRP.  We tend to always go to
    // the first one to try and prevent process thrashing.
    //

    pEntry = pAppPool->ProcessListHead.Flink;
    while (pEntry != &(pAppPool->ProcessListHead))
    {
        pProcess = CONTAINING_RECORD(
                        pEntry,
                        UL_APP_POOL_PROCESS,
                        ListEntry
                        );

        ASSERT(IS_VALID_AP_PROCESS(pProcess));

        //
        // Get an IRP from this process.
        //

        pIrp = UlpPopIrpFromProcess(pProcess, pRequest);

        //
        // Did we find one?
        //

        if (pIrp != NULL)
        {
            //
            // Save a pointer to the process.
            //

            *ppProcess = pProcess;

            //
            // Move the process to the end of the line
            // so that other processes get a chance
            // to process requests.
            //

            RemoveEntryList(pEntry);
            InsertTailList(&(pAppPool->ProcessListHead), pEntry);

            break;
        }

        //
        // Keep looking - move on to the next process entry.
        //

        pEntry = pProcess->ListEntry.Flink;
    }

    return pIrp;

}   // UlpPopNewIrp


/***************************************************************************++

Routine Description:

    Pulls an IRP off the given processes queue if there is one.

Arguments:

    pProcess    - a pointer to the process to search
    pRequest    - the request to pop the irp for

Return Value:

    A pointer to an IRP if we've found one, or NULL if we didn't

--***************************************************************************/
PIRP
UlpPopIrpFromProcess(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_APP_POOL_PROCESS    pAppPoolProcess;
    PLIST_ENTRY             pEntry;
    PIRP                    pIrp = NULL;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    ASSERT(UlDbgSpinLockOwned(&pProcess->pAppPool->SpinLock));
    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    if (!IsListEmpty(&pProcess->NewIrpHead))
    {
        pEntry = RemoveHeadList(&pProcess->NewIrpHead);

        //
        // Found a free irp!
        //

        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // Pop the cancel routine.
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first.
            //
            // Ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // Keep looking for a irp to use.
            //

            pIrp = NULL;
        }
        else
        if (pIrp->Cancel)
        {
            //
            // We pop'd it first, but the irp is being cancelled
            // and our cancel routine will never run.  Lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //

            pAppPoolProcess = (PUL_APP_POOL_PROCESS)
                IoGetCurrentIrpStackLocation(pIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer;

            ASSERT(pAppPoolProcess == pProcess);

            DEREFERENCE_APP_POOL_PROCESS(pAppPoolProcess);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);

            pIrp = NULL;
        }
        else
        {
            //
            // We are free to use this irp!
            //

            pAppPoolProcess = (PUL_APP_POOL_PROCESS)
                IoGetCurrentIrpStackLocation(pIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer;

            ASSERT(pAppPoolProcess == pProcess);

            DEREFERENCE_APP_POOL_PROCESS(pAppPoolProcess);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            //
            // Queue the request to the process's pending queue, and if we
            // can't, complete the IRP with error status.
            //

            Status = UlpQueuePendingRequest(pProcess, pRequest); 

            if (!NT_SUCCESS(Status))
            {
                pIrp->IoStatus.Status = Status;
                pIrp->IoStatus.Information = 0;

                UlCompleteRequest(pIrp, IO_NO_INCREMENT);
                pIrp = NULL;
            }
        }
    }

    return pIrp;

}   // UlpPopIrpFromProcess


/***************************************************************************++

Routine Description:

    Loops through an app pool's list of processes, looking for the specified
    process.

Arguments:

    pProcess    - the process to search for
    pAppPool    - the app pool to search

Return Value:

    TRUE if the process was found, FALSE otherwise

--***************************************************************************/
BOOLEAN
UlpIsProcessInAppPool(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_APP_POOL_OBJECT  pAppPool
    )
{
    BOOLEAN                 Found = FALSE;
    PLIST_ENTRY             pEntry;
    PUL_APP_POOL_PROCESS    pCurrentProc;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(UlDbgSpinLockOwned(&pAppPool->SpinLock));

    //
    // Only look if process isn't NULL.
    //

    if (pProcess != NULL)
    {
        //
        // Start looking for the process.
        //

        pEntry = pAppPool->ProcessListHead.Flink;
        while (pEntry != &(pAppPool->ProcessListHead))
        {
            pCurrentProc = CONTAINING_RECORD(
                                pEntry,
                                UL_APP_POOL_PROCESS,
                                ListEntry
                                );

            ASSERT(IS_VALID_AP_PROCESS(pCurrentProc));

            //
            // Did we find it?
            //

            if (pCurrentProc == pProcess)
            {
                Found = TRUE;
                break;
            }

            //
            // Keep looking - move on to the next process entry.
            //

            pEntry = pCurrentProc->ListEntry.Flink;
        }
    }

    return Found;

}   // UlpIsProcessInAppPool


/***************************************************************************++

Routine Description:

    Adds a request to the unbound queue.  These requests can be routed to
    any process in the app pool.

Arguments:

    pAppPool    - the pool which is getting the request
    pRequest    - the request to queue

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpQueueUnboundRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS                Status;
    PUL_TIMEOUT_INFO_ENTRY  pTimeoutInfo;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(UlDbgSpinLockOwned(&pAppPool->SpinLock));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Add the request to the NewRequestQueue.
    //

    Status = UlpQueueRequest(pAppPool, &pAppPool->NewRequestHead, pRequest);

    //
    // If it's in, change the queue state.
    //

    if (NT_SUCCESS(Status))
    {
        pRequest->AppPool.QueueState = QueueDeliveredState;

        //
        // Turn the connection idle timer back on so that it won't stay
        // on the queue forever and will also get purged under low
        // resource conditions.
        //

        pTimeoutInfo = &pRequest->pHttpConn->TimeoutInfo;

        UlAcquireSpinLockAtDpcLevel(&pTimeoutInfo->Lock);

        if (UlIsConnectionTimerOff(pTimeoutInfo, TimerAppPool))
        {
            UlSetConnectionTimer(pTimeoutInfo, TimerAppPool);
        }

        UlReleaseSpinLockFromDpcLevel(&pTimeoutInfo->Lock);

        UlEvaluateTimerState(pTimeoutInfo);
    }
    else
    {
        //
        // The queue is too full, return an error to the client.
        //

        UlTrace(ROUTING, (
            "http!UlpQueueUnboundRequest(pAppPool = %p, pRequest = %p)\n"
            "         Rejecting request. AppPool Queue is full (%d items)\n",
            pAppPool,
            pRequest,
            pAppPool->RequestCount
            ));

        UlSetErrorCode( pRequest, UlErrorAppPoolQueueFull, pAppPool); // 503
    }

    return Status;

}   // UlpQueueUnboundRequest


/***************************************************************************++

Routine Description:

    Searches request queues for a request available to the specified process.
    If a request is found, it is removed from the queue and returned.

Arguments:

    pProcess            - the process that will get the request
    RequestBufferLength - the optional buffer length for the request
    pRequest            - the request pointer to receive the request

Return Value:

    Pointer to an HTTP_REQUEST if one is found or NULL otherwise

--***************************************************************************/
NTSTATUS
UlDequeueNewRequest(
    IN PUL_APP_POOL_PROCESS     pProcess,
    IN ULONG                    RequestBufferLength,
    OUT PUL_INTERNAL_REQUEST *  pNewRequest
    )
{
    PLIST_ENTRY             pEntry;
    PUL_INTERNAL_REQUEST    pRequest = NULL;
    PUL_APP_POOL_OBJECT     pAppPool;
    PUL_TIMEOUT_INFO_ENTRY  pTimeoutInfo;
    NTSTATUS                Status = STATUS_NOT_FOUND;
    PUL_APP_POOL_PROCESS    pProcBinding;
    ULONG                   BytesNeeded;

    //
    // Sanity check.
    //

    ASSERT(UlDbgSpinLockOwned(&pProcess->pAppPool->SpinLock));
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    *pNewRequest = NULL;
    pAppPool = pProcess->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // Find a usable request.
    //

    pEntry = pAppPool->NewRequestHead.Flink;
    while (pEntry != &pAppPool->NewRequestHead)
    {
        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        if (pAppPool->NumberActiveProcesses <= 1)
        {
            //
            // Done if there is only one active process.
            //

            break;
        }

        //
        // Check the binding.
        //

        pProcBinding = UlQueryProcessBinding(
                            pRequest->pHttpConn,
                            pAppPool
                            );

        if (pProcBinding == pProcess)
        {
            //
            // Found a request bound to the correct process.
            //

            break;
        }
        else
        if (pProcBinding == NULL)
        {
            //
            // Found an unbound request.
            // Bind unbound request to this process.
            // Note: we're ignoring the return value of
            // UlBindConnectionToProcess because it's probably not a fatal
            // error.
            //

            UlBindConnectionToProcess(
                pRequest->pHttpConn,
                pAppPool,
                pProcess
                );

            break;
        }

        //
        // Try the next one.
        //

        pEntry = pEntry->Flink;
    }

    //
    // If we found something, remove it from the NewRequestQueue
    // and pend it onto the PendingRequestQuueue.
    //

    if (pRequest)
    {
        //
        // Let us check if this request can fit into a buffer with
        // RequestBufferLength.  Only check this if requested.
        //

        if (RequestBufferLength)
        {
            Status = UlComputeRequestBytesNeeded(pRequest, &BytesNeeded);

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }
            else
            if (BytesNeeded > RequestBufferLength)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }
        }

        //
        // We will return STATUS_SUCCESS from here on.
        //

        Status = STATUS_SUCCESS;

        //
        // Remove the request from the AppPool's NewRequestQueue and insert
        // it to the process's PendingRequestQueue.  There is no change in
        // the queue limit.
        //

        RemoveEntryList(&pRequest->AppPool.AppPoolEntry);

        InsertTailList(
            &pProcess->PendingRequestHead,
            &pRequest->AppPool.AppPoolEntry
            );

        //
        // Attach the request to this process.  This allows us to drop the
        // connection if the process dies in the middle of request
        // processing.
        //

        pRequest->AppPool.pProcess = pProcess;
        pRequest->AppPool.QueueState = QueueCopiedState;

        //
        // Add a reference to the process to ensure it stays around during
        // the send for the memory we lock.
        //

        REFERENCE_APP_POOL_PROCESS(pProcess);

        //
        // Add a reference to the request so as to allow unlink from
        // process to happen once we let go of the lock.
        //

        UL_REFERENCE_INTERNAL_REQUEST(pRequest);

        //
        // Stop the connection idle timer after the request is delivered.
        //

        pTimeoutInfo = &pRequest->pHttpConn->TimeoutInfo;

        UlAcquireSpinLockAtDpcLevel(&pTimeoutInfo->Lock);

        UlResetConnectionTimer(pTimeoutInfo, TimerAppPool);

        UlReleaseSpinLockFromDpcLevel(&pTimeoutInfo->Lock);

        UlEvaluateTimerState(pTimeoutInfo);
    }

    *pNewRequest = pRequest;

    return Status;

}   // UlDequeueNewRequest


/***************************************************************************++

Routine Description:

    Put the request back from the process's pending request queue to the
    AppPool's new request queue.

Arguments:

    pProcess    - the process that will dequeue the request
    pRequest    - the request to dequeue

Return Value:

    None

--***************************************************************************/
VOID
UlRequeuePendingRequest(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    KLOCK_QUEUE_HANDLE      LockHandle;
    PUL_TIMEOUT_INFO_ENTRY  pTimeoutInfo;

    UlAcquireInStackQueuedSpinLock(
        &pProcess->pAppPool->SpinLock,
        &LockHandle
        );

    if (!pProcess->InCleanup &&
        QueueCopiedState == pRequest->AppPool.QueueState)
    {
        //
        // Unset the request's AppPool info.
        //

        ASSERT( pRequest->AppPool.pProcess == pProcess );
        DEREFERENCE_APP_POOL_PROCESS(pProcess);

        pRequest->AppPool.pProcess = NULL;
        pRequest->AppPool.QueueState = QueueDeliveredState;

        //
        // Move the request back from the process's pending queue to the
        // AppPool's new request queue.  This doesn't affect queue count.
        //

        RemoveEntryList(&pRequest->AppPool.AppPoolEntry);

        InsertHeadList(
            &pProcess->pAppPool->NewRequestHead,
            &pRequest->AppPool.AppPoolEntry
            );

        //
        // Lastly, we have to turn back on the idle timer.
        //

        pTimeoutInfo = &pRequest->pHttpConn->TimeoutInfo;

        UlAcquireSpinLockAtDpcLevel(&pTimeoutInfo->Lock);

        if (UlIsConnectionTimerOff(pTimeoutInfo, TimerConnectionIdle))
        {
            UlSetConnectionTimer(pTimeoutInfo, TimerConnectionIdle);
        }

        UlReleaseSpinLockFromDpcLevel(&pTimeoutInfo->Lock);

        UlEvaluateTimerState(pTimeoutInfo);
    }

    UlReleaseInStackQueuedSpinLock(
        &pProcess->pAppPool->SpinLock,
        &LockHandle
        );

}   // UlRequeuePendingRequest


/***************************************************************************++

Routine Description:

    Takes all the queued requests bound to the given process and makes them
    available to all processes.

Arguments:

    pProcess    - the process whose requests are to be redistributed

Return Value:

    None

--***************************************************************************/
VOID
UlpUnbindQueuedRequests(
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PLIST_ENTRY             pEntry;
    PUL_INTERNAL_REQUEST    pRequest = NULL;
    PUL_APP_POOL_OBJECT     pAppPool;
    PUL_APP_POOL_PROCESS    pProcBinding;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(UlDbgSpinLockOwned(&pProcess->pAppPool->SpinLock));

    pAppPool = pProcess->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // Find a bound request.
    //

    pEntry = pAppPool->NewRequestHead.Flink;
    while (pEntry != &pAppPool->NewRequestHead)
    {
        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        //
        // Remember the next one.
        //

        pEntry = pEntry->Flink;

        //
        // Check the binding.
        //

        if (pAppPool->NumberActiveProcesses <= 1)
        {
            pProcBinding = pProcess;
        }
        else
        {
            pProcBinding = UlQueryProcessBinding(
                                pRequest->pHttpConn,
                                pAppPool
                                );
        }

        if (pProcBinding == pProcess)
        {
            //
            // Remove from the list.
            //

            UlpRemoveRequest(pAppPool, pRequest);

            //
            // Mark it as unrouted.
            //

            pRequest->AppPool.QueueState = QueueUnroutedState;

            UlTrace(ROUTING, (
                "STICKY KILL cid %I64x to proc %p\n",
                pRequest->ConnectionId,
                pProcess
                ));

            //
            // Kill the binding.
            //

            UlBindConnectionToProcess(
                pRequest->pHttpConn,
                pProcess->pAppPool,
                NULL
                );

            //
            // There may be an IRP for this newly unbound
            // request, so redeliver the request outside
            // the locks we're holding.
            //

            UL_QUEUE_WORK_ITEM(
                &pRequest->WorkItem,
                &UlpRedeliverRequestWorker
                );
        }
    }

}   // UlpUnbindQueuedRequests


/***************************************************************************++

Routine Description:

    Delivers the given request to an App Pool.  UlpUnbindQueuedRequests
    uses this routine to call into UlDeliverRequestToProcess outside
    of any locks.

Arguments:

    pWorkItem   - embedded in the request to deliver

Return Value:

    None

--***************************************************************************/
VOID
UlpRedeliverRequestWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    NTSTATUS                Status;
    PUL_INTERNAL_REQUEST    pRequest;

    pRequest = CONTAINING_RECORD(
                    pWorkItem,
                    UL_INTERNAL_REQUEST,
                    WorkItem
                    );

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo));
    ASSERT(pRequest->ConfigInfo.pAppPool);

    Status = UlDeliverRequestToProcess(
                    pRequest->ConfigInfo.pAppPool,
                    pRequest,
                    NULL
                    );

    //
    // Remove the extra reference added in UlpUnbindQueuedRequests.
    //

    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

}   // UlpRedeliverRequestWorker


/***************************************************************************++

Routine Description:

    Changes the maximum length of the incoming request queue on the app pool.

Arguments:

    pProcess    - App pool process object
    QueueLength - the new max length of the queue

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetAppPoolQueueLength(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG                QueueLength
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    KLOCK_QUEUE_HANDLE  LockHandle;

    pAppPool = pProcess->pAppPool;
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // Set the new value.
    //

    UlAcquireInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    pAppPool->MaxRequests = QueueLength;

    UlReleaseInStackQueuedSpinLock(&pAppPool->SpinLock, &LockHandle);

    UlTrace(ROUTING, (
        "http!UlpSetAppPoolQueueLength(pProcess = %p, QueueLength = %ld)\n"
        "        pAppPool = %p (%ws), Status = 0x%08x\n",
        pProcess,
        QueueLength,
        pAppPool,
        pAppPool->pName,
        STATUS_SUCCESS
        ));

    return STATUS_SUCCESS;

}   // UlpSetAppPoolQueueLength


/******************************************************************************

Routine Description:

    This copies a request into a free irp.

    If the request is too large, it queues to request onto the process and
    completes the irp, so that the process can come back later with a larger
    buffer.

Arguments:

    pRequest    - the request to copy
    pProcess    - the process that owns pIrp
    pIrp        - the irp to copy pRequest to

Return Value:

    None

******************************************************************************/
VOID
UlCopyRequestToIrp(
    IN PUL_INTERNAL_REQUEST     pRequest,
    IN PIRP                     pIrp,
    IN BOOLEAN                  CompleteIrp,
    IN BOOLEAN                  LockAcquired
    )
{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          pIrpSp = NULL;
    ULONG                       BytesNeeded;
    ULONG                       BytesCopied;
    PUCHAR                      pKernelBuffer;
    PVOID                       pUserBuffer;
    PHTTP_RECEIVE_REQUEST_INFO  pRequestInfo;
    PHTTP_REQUEST               pUserRequest;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(pIrp != NULL);
    ASSERT(NULL != pIrp->MdlAddress);

    //
    // Make sure this is big enough to handle the request, and
    // if so copy it in.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Calculate the size needed for the request, we'll need it below.
    //

    Status = UlComputeRequestBytesNeeded(pRequest, &BytesNeeded);

    if (!NT_SUCCESS(Status))
    {
        goto complete;
    }

    //
    // Make sure we've got enough space to handle the whole request.
    //

    if (BytesNeeded <=
        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength)
    {
        //
        // Get the addresses for the buffer.
        //

        pKernelBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                    pIrp->MdlAddress,
                                    NormalPagePriority
                                    );

        if (pKernelBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        //
        // Make sure we are properly aligned.
        //

        ASSERT(!(((ULONG_PTR) pKernelBuffer) & (TYPE_ALIGNMENT(PVOID) - 1)));

        pUserBuffer = MmGetMdlVirtualAddress(pIrp->MdlAddress);
        ASSERT(pUserBuffer != NULL);

        pRequestInfo =
            (PHTTP_RECEIVE_REQUEST_INFO)pIrp->AssociatedIrp.SystemBuffer;

        //
        // This request will fit in this buffer, so copy it.
        //

        Status = UlCopyRequestToBuffer(
                        pRequest,
                        pKernelBuffer,
                        pUserBuffer,
                        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                        pRequestInfo->Flags,
                        LockAcquired,
                        &BytesCopied
                        );

        if (NT_SUCCESS(Status))
        {
            pIrp->IoStatus.Information = BytesCopied;
        }
        else
        {
            goto complete;
        }
    }
    else
    {
        //
        // The user buffer is too small.
        //

        Status = STATUS_BUFFER_OVERFLOW;

        //
        // Is it big enough to hold the basic structure?
        //

        if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
            sizeof(HTTP_REQUEST))
        {
            pUserRequest = (PHTTP_REQUEST)MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                NormalPagePriority
                                );

            if (pUserRequest == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete;
            }

            //
            // Copy the request id into the output buffer.  Copy it from
            // the private copy that request holds.  Original opaque id
            // may get nulled if connection cleanup happens before we get
            // here.
            //

            ASSERT(!HTTP_IS_NULL_ID(&pRequest->RequestIdCopy));

            pUserRequest->RequestId     = pRequest->RequestIdCopy;
            pUserRequest->ConnectionId  = pRequest->ConnectionId;

            //
            // And tell how much we actually need.
            //

            pIrp->IoStatus.Information  = BytesNeeded;
        }
        else
        {
            //
            // Very bad, we can never get here as we check the length in
            // ioctl.c.
            //

            ASSERT(FALSE);

            pIrp->IoStatus.Information = 0;
        }
    }

complete:

    UlTrace(ROUTING, (
        "http!UlCopyRequestToIrp(\n"
        "        pRequest = %p,\n"
        "        pIrp = %p) Completing Irp\n"
        "    pAppPool                   = %p (%S)\n"
        "    pRequest->ConnectionId     = %I64x\n"
        "    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength = %d\n"
        "    pIrp->IoStatus.Status      = 0x%x\n"
        "    pIrp->IoStatus.Information = %Iu\n",
        pRequest,
        pIrp,
        pRequest->ConfigInfo.pAppPool,
        pRequest->ConfigInfo.pAppPool->pName,
        pRequest->ConnectionId,
        pIrpSp ? pIrpSp->Parameters.DeviceIoControl.OutputBufferLength : 0,
        Status,
        pIrp->IoStatus.Information
        ));

    pIrp->IoStatus.Status = Status;

    //
    // Complete the irp.
    //

    if (CompleteIrp)
    {
        //
        // Use IO_NO_INCREMENT to avoid the work thread being rescheduled.
        //

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

}   // UlCopyRequestToIrp


/******************************************************************************

Routine Description:

    This will return the apool object reference by this handle, bumping the
    refcount on the apool.

    This is called by UlSetConfigGroupInformation when user mode wants to
    associate an app pool to the config group by handle.

    The config group keeps a pointer to the apool.

Arguments:

    AppPool     - the handle of the apool
    AccessMode  - KernelMode or UserMode
    ppAppPool   - returns the apool object the handle represented.

Return Value:

    NTSTATUS - Completion status.

******************************************************************************/
NTSTATUS
UlGetPoolFromHandle(
    IN HANDLE                   AppPool,
    IN KPROCESSOR_MODE          AccessMode,
    OUT PUL_APP_POOL_OBJECT *   ppAppPool
    )
{
    NTSTATUS        Status;
    PFILE_OBJECT    pFileObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppAppPool != NULL);

    Status = ObReferenceObjectByHandle(
                    AppPool,
                    FILE_READ_ACCESS,           // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    AccessMode,                 // AccessMode
                    (PVOID *) &pFileObject,     // Object
                    NULL                        // HandleInformation
                    );

    if (NT_SUCCESS(Status) == FALSE)
    {
        goto end;
    }

    if (IS_APP_POOL_FO(pFileObject) == FALSE ||
        IS_VALID_AP_PROCESS(GET_APP_POOL_PROCESS(pFileObject)) == FALSE)
    {
        Status = STATUS_INVALID_HANDLE;
        goto end;
    }

    *ppAppPool = GET_APP_POOL_PROCESS(pFileObject)->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(*ppAppPool));

    REFERENCE_APP_POOL(*ppAppPool);

end:

    if (pFileObject != NULL)
    {
        ObDereferenceObject(pFileObject);
    }

    return Status;

}   // UlGetPoolFromHandle


/******************************************************************************

Routine Description:

    This routine is called to associate a HTTP_REQUEST with an apool
    process.

    This is basically always done (used to be for 2 [now 3] reasons):

        1) The process called ReceiveEntityBody and pended an IRP to the
        request.  If the process detaches from the apool (CloseHandle,
        ExitProcess) UlDetachProcessFromAppPool will walk the request queue
        and cancel all i/o.

        2) The request did not fit into a waiting irp, so the request is queued
        for a larger irp to come down and fetch it.

        3) The response has not been fully sent for the request.  The request
        is linked with the process so that the connection can be aborted
        if the process aborts.

Arguments:

    pProcess    - the process to associate the request with
    pRequest    - the request

Return Value:

    NTSTATUS - Completion status.

******************************************************************************/
NTSTATUS
UlpQueuePendingRequest(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS    Status;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(UlDbgSpinLockOwned(&pProcess->pAppPool->SpinLock));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // Put it on the list.
    //

    ASSERT(pRequest->AppPool.AppPoolEntry.Flink == NULL);

    Status = UlpQueueRequest(
                    pProcess->pAppPool,
                    &pProcess->PendingRequestHead,
                    pRequest
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // Save a pointer to the process in the object so we can confirm
        // that it's on our list.
        //

        pRequest->AppPool.pProcess = pProcess;
        pRequest->AppPool.QueueState = QueueCopiedState;

        //
        // Add a reference to the process to ensure it stays around during
        // the send for the memory we lock.
        //

        REFERENCE_APP_POOL_PROCESS(pProcess);
    }

    return Status;

}   // UlpQueuePendingRequest


/***************************************************************************++

Routine Description:

    Adds a request to the tail of the queue.
    App Pool queue lock must be held.

Arguments:

    pAppPool    - the AppPool to add
    pQueueList  - the queue list
    pRequest    - the request to be added

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpQueueRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PLIST_ENTRY          pQueueList,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    LONG    GlobalRequests;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(UlDbgSpinLockOwned(&pAppPool->SpinLock));
    ASSERT(pQueueList);
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // See if we've exceeded the global limit on requests queued and
    // the queue's limits.
    //

    GlobalRequests = InterlockedIncrement(&g_RequestsQueued);
    ASSERT(GlobalRequests > 0);

    if ((ULONG) GlobalRequests > g_UlMaxRequestsQueued ||
        pAppPool->RequestCount >= pAppPool->MaxRequests)
    {
        InterlockedDecrement(&g_RequestsQueued);
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    // Add to the end of the queue.
    //

    InsertTailList(pQueueList, &pRequest->AppPool.AppPoolEntry);

    pAppPool->RequestCount++;
    ASSERT(pAppPool->RequestCount >= 1);

    return STATUS_SUCCESS;

}   // UlpQueueRequest


/***************************************************************************++

Routine Description:

    Removes a particular request from the queue.
    App Pool queue lock must be held.

Arguments:

    pAppPool    - the AppPool to remove the request from
    pRequest    - the request to be removed

Return Value:

    None

--***************************************************************************/
VOID
UlpRemoveRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    LONG    GlobalRequests;

    ASSERT(UlDbgSpinLockOwned(&pAppPool->SpinLock));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(NULL != pRequest->AppPool.AppPoolEntry.Flink);
    ASSERT(pAppPool->RequestCount > 0);

    RemoveEntryList(&pRequest->AppPool.AppPoolEntry);
    pRequest->AppPool.AppPoolEntry.Flink = NULL;
    pRequest->AppPool.AppPoolEntry.Blink = NULL;

    pAppPool->RequestCount--;

    GlobalRequests = InterlockedDecrement(&g_RequestsQueued);
    ASSERT(GlobalRequests >= 0);

}   // UlpRemoveRequest


/***************************************************************************++

Routine Description:

    Removes a request from the head of a queue if there is one.
    App Pool queue lock must be held.

Arguments:

    pAppPool    - the AppPool to dequeue the request from
    pQueueList  - the queue list

Return values:

    Pointer to the request or NULL if the queue is empty.

--***************************************************************************/
PUL_INTERNAL_REQUEST
UlpDequeueRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PLIST_ENTRY          pQueueList
    )
{
    PLIST_ENTRY             pEntry;
    PUL_INTERNAL_REQUEST    pRequest = NULL;
    LONG                    GlobalRequests;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(UlDbgSpinLockOwned(&pAppPool->SpinLock));
    ASSERT(pQueueList);

    if (!IsListEmpty(pQueueList))
    {
        pEntry = RemoveHeadList(pQueueList);
        pEntry->Flink = pEntry->Blink = NULL;

        pAppPool->RequestCount--;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        pRequest->AppPool.QueueState = QueueUnlinkedState;

        GlobalRequests = InterlockedDecrement(&g_RequestsQueued);
        ASSERT(GlobalRequests >= 0);
    }

    return pRequest;

}   // UlpDequeueRequest


/***************************************************************************++

Routine Description:

    Determines if the specified connection has been disconnected.  If so,
    the IRP is completed immediately, otherwise the IRP is pended.

Arguments:

    pProcess    - the app pool process object with which the irp is associated
    pHttpConn   - supplies the connection to wait for
        N.B.  Since this connection was retrieved via a opaque ID, it has
        an outstanding reference for this request on the assumption the
        IRP will pend.  If this routine does not pend the IRP, the reference
        must be removed.
    pIrp        - supplies the IRP to either complete or pend

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDisconnect(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_HTTP_CONNECTION  pHttpConn,
    IN PIRP                 pIrp
    )
{
    PDRIVER_CANCEL          pCancelRoutine;
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpSp;
    PUL_DISCONNECT_OBJECT   pDisconnectObj;

    //
    // Acquire the lock protecting the disconnect data and determine
    // if we should queue the IRP or complete it immediately.
    //

    UlAcquirePushLockExclusive(&pHttpConn->PushLock);

    //
    // WaitForDisconnect is allowed only for the process that picked up
    // the current request.
    //

    if (!pHttpConn->pRequest ||
        pHttpConn->pRequest->AppPool.pProcess != pProcess)
    {
        UlReleasePushLockExclusive(&pHttpConn->PushLock);
        return STATUS_INVALID_ID_AUTHORITY;
    }

    if (pHttpConn->DisconnectFlag)
    {
        //
        // Connection already disconnected, complete the IRP immediately.
        //

        UlReleasePushLockExclusive(&pHttpConn->PushLock);

        IoMarkIrpPending(pIrp);
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        UlCompleteRequest(pIrp, IO_NO_INCREMENT);

        return STATUS_PENDING;
    }

    //
    // Allocate an object to associate the IRP with the connection
    // and the app pool.
    //

    pDisconnectObj = UlpCreateDisconnectObject(pIrp);

    if (!pDisconnectObj)
    {
        UlReleasePushLockExclusive(&pHttpConn->PushLock);
        return STATUS_NO_MEMORY;
    }

    UlAcquireResourceExclusive(&g_pUlNonpagedData->DisconnectResource, TRUE);

    //
    // Save a pointer to the disconnect object in the IRP so we
    // can find it inside our cancel routine.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pDisconnectObj;

    //
    // Make the IRP cancellable.
    //

    IoMarkIrpPending(pIrp);
    IoSetCancelRoutine(pIrp, &UlpCancelWaitForDisconnect);

    if (pIrp->Cancel)
    {
        //
        // The IRP has either already been cancelled IRP is in the
        // process of being cancelled.
        //

        pCancelRoutine = IoSetCancelRoutine(pIrp, NULL);

        if (pCancelRoutine == NULL)
        {
            //
            // The previous cancel routine was already NULL, meaning that
            // it has either already run or will run Real Soon Now, so
            // we can just ignore it.  Returning STATUS_PENDING causes
            // the IOCTL wrapper to not attempt to complete the IRP.
            //

            Status = STATUS_PENDING;
            goto end;
        }
        else
        {
            //
            // We have to cancel it ourselves, so we'll just complete
            // the IRP immediately with STATUS_CANCELLED.
            //

            Status = STATUS_CANCELLED;
            goto end;
        }
    }

    //
    // We have queued at least one WaitForDisconnect IRP.
    //

    pHttpConn->WaitForDisconnectFlag = 1;

    //
    // The IRP has not been cancelled yet.  Queue it on the connection
    // and return with the connection still referenced.  The reference
    // is removed when the IRP is dequeued & completed or cancelled.
    //
    // Also queue it on the app pool process in case the pool handle
    // gets closed before the connection does.
    //

    UlAddNotifyEntry(
        &pHttpConn->WaitForDisconnectHead,
        &pDisconnectObj->ConnectionEntry
        );

    UlAddNotifyEntry(
        &pProcess->WaitForDisconnectHead,
        &pDisconnectObj->ProcessEntry
        );

    UlReleaseResource(&g_pUlNonpagedData->DisconnectResource);
    UlReleasePushLockExclusive(&pHttpConn->PushLock);

    return STATUS_PENDING;

end:

    UlUnmarkIrpPending(pIrp);

    UlReleaseResource(&g_pUlNonpagedData->DisconnectResource);
    UlReleasePushLockExclusive(&pHttpConn->PushLock);

    UlpFreeDisconnectObject(pDisconnectObj);

    return Status;

}   // UlWaitForDisconnect


/***************************************************************************++

Routine Description:

    Cancels the pending "wait for disconnect" IRP.

Arguments:

    pDeviceObject   - supplies the device object for the request
    pIrp            - supplies the IRP to cancel

Return Value:

    None

--***************************************************************************/
VOID
UlpCancelWaitForDisconnect(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(pIrp != NULL);

    //
    // Release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // Queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP(pIrp),
        &UlpCancelWaitForDisconnectWorker
        );

}   // UlpCancelWaitForDisconnect


/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem   - the work item to process

Return Value:

    None

--***************************************************************************/
VOID
UlpCancelWaitForDisconnectWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;
    PUL_DISCONNECT_OBJECT   pDisconnectObj;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Grab the irp off the work item.
    //

    pIrp = UL_WORK_ITEM_TO_IRP(pWorkItem);

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Grab the disconnect object off the irp.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pDisconnectObj = (PUL_DISCONNECT_OBJECT)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_DISCONNECT_OBJECT(pDisconnectObj));

    //
    // Acquire the lock protecting the disconnect data, and remove the
    // IRP if necessary.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->DisconnectResource, TRUE);

    UlRemoveNotifyEntry(&pDisconnectObj->ConnectionEntry);
    UlRemoveNotifyEntry(&pDisconnectObj->ProcessEntry);

    UlReleaseResource(&g_pUlNonpagedData->DisconnectResource);

    //
    // Free the disconnect object and complete the IRP.
    //

    UlpFreeDisconnectObject(pDisconnectObj);

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

}   // UlpCancelWaitForDisconnectWorker


/***************************************************************************++

Routine Description:

    Completes all WaitForDisconnect IRPs attached to an http connection
    has been disconnected.

Arguments:

    pHttpConnection - the connection that's disconnected

Return Value:

    None

--***************************************************************************/
VOID
UlCompleteAllWaitForDisconnect(
    IN PUL_HTTP_CONNECTION  pHttpConnection
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->DisconnectResource, TRUE);

    //
    // Complete any pending "wait for disconnect" IRPs.
    //

    UlNotifyAllEntries(
        &UlpNotifyCompleteWaitForDisconnect,
        &pHttpConnection->WaitForDisconnectHead,
        &Status
        );

    UlReleaseResource(&g_pUlNonpagedData->DisconnectResource);

}   // UlCompleteAllWaitForDisconnect


/***************************************************************************++

Routine Description:

    Removes a UL_DISCONNECT_OBJECT from its lists and completes the IRP.

Arguments:

    pEntry  - the notify list entry
    pHost   - the UL_DISCONNECT_OBJECT
    pStatus - pointer to an NTSTATUS to be returned

Return Value:

    None

--***************************************************************************/
BOOLEAN
UlpNotifyCompleteWaitForDisconnect(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pStatus
    )
{
    PUL_DISCONNECT_OBJECT   pDisconnectObj;
    PIRP                    pIrp;
    PDRIVER_CANCEL          pCancelRoutine;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pEntry);
    ASSERT(pHost);
    ASSERT(pStatus);
    ASSERT(UlDbgResourceOwnedExclusive(&g_pUlNonpagedData->DisconnectResource));

    UNREFERENCED_PARAMETER(pEntry);

    pDisconnectObj = (PUL_DISCONNECT_OBJECT) pHost;
    ASSERT(IS_VALID_DISCONNECT_OBJECT(pDisconnectObj));

    //
    // Locate and try to complete the IRP.
    //

    pIrp = pDisconnectObj->pIrp;

    //
    // We'll be completing the IRP real soon, so make it
    // non-cancellable.
    //

    pCancelRoutine = IoSetCancelRoutine(pIrp, NULL);

    if (pCancelRoutine == NULL)
    {
        //
        // The cancel routine is already NULL, meaning that the
        // cancel routine will run Real Soon Now, so we can
        // just drop this IRP on the floor.
        //
    }
    else
    {
        //
        // Remove object from lists.
        //

        UlRemoveNotifyEntry(&pDisconnectObj->ConnectionEntry);
        UlRemoveNotifyEntry(&pDisconnectObj->ProcessEntry);

        //
        // Complete the IRP, then free the disconnect object.
        //

        pIrp->IoStatus.Status = *((PNTSTATUS) pStatus);
        pIrp->IoStatus.Information = 0;
        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        UlpFreeDisconnectObject(pDisconnectObj);
    }

    return TRUE;

}   // UlpNotifyCompleteWaitForDisconnect


/***************************************************************************++

Routine Description:

    Allocates and initializes a disconnect object.

Arguments:

    pIrp    - a UlWaitForDisconnect IRP

Return Value:

    PUL_DISCONNECT_OBJECT

--***************************************************************************/
PUL_DISCONNECT_OBJECT
UlpCreateDisconnectObject(
    IN PIRP pIrp
    )
{
    PUL_DISCONNECT_OBJECT   pObject;

    pObject = UL_ALLOCATE_STRUCT(
                    PagedPool,
                    UL_DISCONNECT_OBJECT,
                    UL_DISCONNECT_OBJECT_POOL_TAG
                    );

    if (pObject)
    {
        pObject->Signature = UL_DISCONNECT_OBJECT_POOL_TAG;
        pObject->pIrp = pIrp;

        UlInitializeNotifyEntry(&pObject->ProcessEntry, pObject);
        UlInitializeNotifyEntry(&pObject->ConnectionEntry, pObject);
    }

    return pObject;

}   // UlpCreateDisconnectObject


/***************************************************************************++

Routine Description:

    Gets rid of a disconnect object.

Arguments:

    pObject - the disconnect object to free

Return Value:

    None

--***************************************************************************/
VOID
UlpFreeDisconnectObject(
    IN PUL_DISCONNECT_OBJECT pObject
    )
{
    UL_FREE_POOL_WITH_SIG(pObject, UL_DISCONNECT_OBJECT_POOL_TAG);

}   // UlpFreeDisconnectObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\serviceconfig\ssl.c ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#include "precomp.h"
#pragma hdrstop

//
// Macros
//
#define MAX_HASH 20

#define CONVERT_WCHAR(ch, n)                                            \
    if(iswdigit((ch)))                                                  \
    {                                                                   \
        (n) = (UCHAR)((ch) - L'0');                                     \
    }                                                                   \
    else if(iswxdigit((ch)))                                            \
    {                                                                   \
        (n) = (UCHAR) ((ch) + 10 - (iswlower((ch))?L'a':L'A'));         \
    }                                                                   \
    else                                                                \
    {                                                                   \
        NlsPutMsg(HTTPCFG_INVALID_HASH, pHash);                         \
        return ERROR_INVALID_PARAMETER;                                 \
    }

//
// Private functions.
//

/***************************************************************************++

Routine Description:
    Prints a record in the SSL store.

Arguments:
    pOutput - A pointer to HTTP_SERVICE_CONFIG_SSL_SET

Return Value:
    None.

--***************************************************************************/
void
PrintSslRecord(
    IN PUCHAR pOutput
    )
{
    DWORD                        i;
    UNICODE_STRING               GuidString;
    WCHAR                        IpAddr[INET6_ADDRSTRLEN];
    DWORD                        dwIpAddrLen = INET6_ADDRSTRLEN;
    DWORD                        dwSockAddrLength;
    PUCHAR                       pStr;
    PSOCKADDR_IN                 pSockAddrIn;
    PHTTP_SERVICE_CONFIG_SSL_SET pSsl;
    DWORD                        Status;

    pSsl = (PHTTP_SERVICE_CONFIG_SSL_SET) pOutput;


    // Convert address to string.
    //

    pSockAddrIn = (PSOCKADDR_IN)  pSsl->KeyDesc.pIpPort;
    if(pSockAddrIn->sin_family == AF_INET)
    {
        dwSockAddrLength = sizeof(SOCKADDR_IN);
    }
    else if(pSockAddrIn->sin_family == AF_INET6)
    {
        dwSockAddrLength = sizeof(SOCKADDR_IN6);
    }
    else
    {
        // Status = ERROR_REGISTRY_CORRUPT;
        return;
    }

    Status = WSAAddressToString(pSsl->KeyDesc.pIpPort,
                       dwSockAddrLength,
                       NULL,
                       IpAddr,
                       &dwIpAddrLen
                       );

    if(NO_ERROR != Status)
    {
        return;
    }

    // Print the Key.
    NlsPutMsg(HTTPCFG_SSL_IP,   IpAddr);

    NlsPutMsg(HTTPCFG_SSL_HASH);

    
    pStr = (PUCHAR) pSsl->ParamDesc.pSslHash;
    for(i=0; i<pSsl->ParamDesc.SslHashLength; i++)
    {
        NlsPutMsg(HTTPCFG_CHAR,  pStr[i]);
    }

    NlsPutMsg(HTTPCFG_NEWLINE);

    Status = RtlStringFromGUID(&pSsl->ParamDesc.AppId, &GuidString);

    if(NO_ERROR != Status)
    {
        return;
    }

    NlsPutMsg(HTTPCFG_SSL_GUID, GuidString.Buffer);

    RtlFreeUnicodeString(&GuidString);

    NlsPutMsg(HTTPCFG_SSL_CERTSTORENAME, 
              pSsl->ParamDesc.pSslCertStoreName
              );

    NlsPutMsg(
              HTTPCFG_SSL_CERTCHECKMODE,   
              pSsl->ParamDesc.DefaultCertCheckMode
              );

    NlsPutMsg(
              HTTPCFG_SSL_REVOCATIONFRESHNESSTIME,   
              pSsl->ParamDesc.DefaultRevocationFreshnessTime
              );

    NlsPutMsg(
              HTTPCFG_SSL_REVOCATIONURLRETRIEVAL_TIMEOUT,   
              pSsl->ParamDesc.DefaultRevocationUrlRetrievalTimeout
              );

    NlsPutMsg(
              HTTPCFG_SSL_SSLCTLIDENTIFIER,   
              pSsl->ParamDesc.pDefaultSslCtlIdentifier
              );

    NlsPutMsg(
              HTTPCFG_SSL_SSLCTLSTORENAME,   
              pSsl->ParamDesc.pDefaultSslCtlStoreName
              );

    NlsPutMsg(
              HTTPCFG_SSL_FLAGS,   
              pSsl->ParamDesc.DefaultFlags
              );

    NlsPutMsg(
              HTTPCFG_RECORD_SEPARATOR   
              );
}

/***************************************************************************++

Routine Description:
    Sets a SSL entry.

Arguments:
    pIP            - The IP address.
    pGuid          - The GUID
    pHash          - Hash of the certificate.
    CertCheckMode  - CertCheckMode (Bit Field).
    Freshness      - DefaultRevocationFreshnessTime (seconds) 
    Timeout        - DefaultRevocationUrlRetrievalTimeout
    Flags          - DefaultFlags.
    pCtlIdentifier - List of issuers that we want to trust.
    pCtlStoreName  - Store name under LOCAL_MACHINE where pCtlIdentifier
                     can be found.
    pCertStoreName - Store name under LOCAL_MACHINE where certificate
                     can be found.
Return Value:
    Success/Failure.

--***************************************************************************/
int
DoSslSet(
    IN  PWCHAR pIp, 
    IN  PWCHAR pGuid, 
    IN  PWCHAR pHash, 
    IN  DWORD  CertCheckMode,
    IN  DWORD  Freshness,
    IN  DWORD  Timeout,
    IN  DWORD  Flags,
    IN  PWCHAR pCtlIdentifier,
    IN  PWCHAR pCtlStoreName,
    IN  PWCHAR pCertStoreName
    )
{
    HTTP_SERVICE_CONFIG_SSL_SET SetParam;
    UNICODE_STRING              GuidString;
    DWORD                       Status;
    SOCKADDR_STORAGE            TempSockAddr;
    USHORT                      HashLength;
    UCHAR                       BinaryHash[MAX_HASH];
    DWORD                       i, j;
    UCHAR                       n1, n2;

    ZeroMemory(&SetParam, sizeof(SetParam));

    SetParam.KeyDesc.pIpPort = (LPSOCKADDR)&TempSockAddr;

    //
    // Convert the string based IP into a SOCKADDR
    //
    if((Status = GetAddress(pIp, 
                            SetParam.KeyDesc.pIpPort,
                            sizeof(TempSockAddr)
                            )) != NO_ERROR)
    {
        NlsPutMsg(HTTPCFG_INVALID_IP, pIp);
        return Status;
    }

    //
    // Convert the string to a GUID.
    //
    if(pGuid)
    {
        GuidString.Length        = (USHORT)wcslen(pGuid) * sizeof(WCHAR);
        GuidString.MaximumLength = (USHORT)GuidString.Length+1;
        GuidString.Buffer        = pGuid;
        Status = RtlGUIDFromString(&GuidString, &SetParam.ParamDesc.AppId);

        if(Status != NO_ERROR)
        {
            NlsPutMsg(HTTPCFG_INVALID_GUID, pGuid);
            return Status;
        }
    }

    if(pHash)
    {
        HashLength = (USHORT) wcslen(pHash);

        for(i=0, j=0; i<MAX_HASH && HashLength >= 2; )
        {
            CONVERT_WCHAR(pHash[j], n1);
            CONVERT_WCHAR(pHash[j+1], n2);

            BinaryHash[i] = ((n1<<4) & 0xF0) | (n2 & 0x0F);

            // We've consumed 2 WCHARs
            HashLength -= 2;
            j += 2;

            // and used up one byte in BinaryHash
            i ++; 
        }

        if(HashLength != 0 || i != MAX_HASH)
        {
            NlsPutMsg(HTTPCFG_INVALID_HASH, pHash);
            return ERROR_INVALID_PARAMETER;
        }

        SetParam.ParamDesc.SslHashLength = i;
        SetParam.ParamDesc.pSslHash      = BinaryHash;
    }

    SetParam.ParamDesc.pSslCertStoreName                    = pCertStoreName;
    SetParam.ParamDesc.pDefaultSslCtlIdentifier             = pCtlIdentifier;
    SetParam.ParamDesc.pDefaultSslCtlStoreName              = pCtlStoreName;
    SetParam.ParamDesc.DefaultCertCheckMode                 = CertCheckMode;
    SetParam.ParamDesc.DefaultRevocationFreshnessTime       = Freshness;
    SetParam.ParamDesc.DefaultRevocationUrlRetrievalTimeout = Timeout;
    SetParam.ParamDesc.DefaultFlags                         = Flags;

    Status = HttpSetServiceConfiguration(
                NULL,
                HttpServiceConfigSSLCertInfo,
                &SetParam,
                sizeof(SetParam),
                NULL
                );

    NlsPutMsg(HTTPCFG_SETSERVICE_STATUS, Status);

    return Status;
}

/***************************************************************************++

Routine Description:
    Queries for a SSL entry.

Arguments:
    pIp - The IP address (if NULL, then enumerate the store).

Return Value:
    Success/Failure.

--***************************************************************************/
int DoSslQuery(
    IN PWCHAR pIp
    )
{
    DWORD                          Status;
    PUCHAR                         pOutput = NULL;
    DWORD                          OutputLength = 0;
    DWORD                          ReturnLength = 0;
    HTTP_SERVICE_CONFIG_SSL_QUERY  QueryParam;
    SOCKADDR_STORAGE               TempSockAddr;

    ZeroMemory(&QueryParam, sizeof(QueryParam));

    if(pIp)
    {
        // if an IP address is specified, we'll covert it to a SOCKADDR
        // and do an exact query.
        
        QueryParam.QueryDesc = HttpServiceConfigQueryExact;
        QueryParam.KeyDesc.pIpPort = (LPSOCKADDR)&TempSockAddr;

        if((Status = GetAddress(pIp, 
                                QueryParam.KeyDesc.pIpPort,
                                sizeof(TempSockAddr)
                                )) != NO_ERROR)
        {
            NlsPutMsg(HTTPCFG_INVALID_IP, pIp);
            return Status;
        }
    }
    else
    {
        // We are enumerating all the records in the SSL store.
        QueryParam.QueryDesc = HttpServiceConfigQueryNext;
    }

    for(;;)
    {
        // 
        // First, compute the bytes required to enumerate an entry.
        //
        Status = HttpQueryServiceConfiguration(
                    NULL,
                    HttpServiceConfigSSLCertInfo,
                    &QueryParam,
                    sizeof(QueryParam),
                    pOutput,
                    OutputLength,
                    &ReturnLength,
                    NULL
                    );

        if(Status == ERROR_INSUFFICIENT_BUFFER)
        {
            // If the API completes with ERROR_INSUFFICIENT_BUFFER, we'll
            // allocate memory for it & continue with the loop where we'll
            // call it again.
            
            if(pOutput)
            {
                // If there was an existing buffer, free it.
                LocalFree(pOutput);
            }

            // Allocate a new buffer
            
            pOutput = LocalAlloc(LMEM_FIXED, ReturnLength);
            if(!pOutput)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            OutputLength = ReturnLength;
        }
        else if(Status == NO_ERROR)
        {
            // The query succeeded! We'll print the record that we just
            // queried.
            //
            PrintSslRecord(pOutput);

            if(pIp != NULL)
            {
                //
                // If we are not enumerating, we are done.
                //
                break;
            }
            else    
            {
                //
                // Since we are enumerating, we'll move on to the next
                // record. This is done by incrementing the cursor, till 
                // we get ERROR_NO_MORE_ITEMS.
                //
                QueryParam.dwToken ++;
            }
        }
        else if(ERROR_NO_MORE_ITEMS == Status && !pIp)
        {
            // We are enumerating and we have reached the end. This is 
            // indicated by a ERROR_NO_MORE_ITEMS error code. 
            
            // This is not a real error, since it is used to indicate that
            // we've finished enumeration.
            
            Status = NO_ERROR;
            break;
        }
        else
        {
            //
            // Some other error, so we are done
            //
            NlsPutMsg(HTTPCFG_QUERYSERVICE_STATUS, Status);
            break;
        }
    } 

    if(pOutput)
    {
        LocalFree(pOutput);
    }
    
    return Status;
}


/***************************************************************************++

Routine Description:
    Deletes a SSL entry.

Arguments:
    pIP - The IP address of entry to be deleted.

Return Value:
    Success/Failure.

--***************************************************************************/
int DoSslDelete(
    IN PWCHAR pIp
    )
{
    HTTP_SERVICE_CONFIG_SSL_SET SetParam;
    DWORD                       Status;
    SOCKADDR_STORAGE            TempSockAddr;

    SetParam.KeyDesc.pIpPort = (LPSOCKADDR)&TempSockAddr;

    // Convert string IP address to a SOCKADDR structure
    Status = GetAddress(pIp, 
                        SetParam.KeyDesc.pIpPort,
                        sizeof(TempSockAddr)
                        );

    if(Status != NO_ERROR)
    {
        NlsPutMsg(HTTPCFG_INVALID_IP, pIp);
        return Status;
    }

    // Call the API.
    Status = HttpDeleteServiceConfiguration(
                NULL,
                HttpServiceConfigSSLCertInfo,
                &SetParam,
                sizeof(SetParam),
                NULL
                );
                
    NlsPutMsg(HTTPCFG_DELETESERVICE_STATUS, Status);
    return Status;
}

//
// Public functions.
//

/***************************************************************************++

Routine Description:
    The function that parses parameters specific to SSL
    calls Set, Query or Delete.

Arguments:
    argc - Count of arguments.
    argv - Pointer to command line arguments.
    Type - Type of operation to be performed.

Return Value:
    Success/Failure.

--***************************************************************************/
int DoSsl(
    int argc, 
    WCHAR **argv, 
    HTTPCFG_TYPE type
    )
{
    PWCHAR   pGuid             = NULL;
    PWCHAR   pHash             = NULL;
    PWCHAR   pCertStoreName    = NULL;
    PWCHAR   pCtlIdentifier    = NULL;
    PWCHAR   pCtlStoreName     = NULL;
    DWORD    CertCheckMode     = 0;
    DWORD    Freshness         = 0;
    DWORD    Timeout           = 0;
    DWORD    Flags             = 0;
    PWCHAR   pIp               = NULL;

    while(argc >= 2 && (argv[0][0] == L'-' || argv[0][0] == L'/'))
    {
        switch(toupper(argv[0][1]))
        {
            case 'I':
                pIp = argv[1];
                break;
    
            case 'C':
                pCertStoreName = argv[1];
                break;
        
            case 'N':
                pCtlStoreName = argv[1];
                break;

            case 'T':
                pCtlIdentifier = argv[1];
                break;

            case 'M':
                CertCheckMode = _wtoi(argv[1]);   
                break;

            case 'R':
                Freshness = _wtoi(argv[1]);   
                break;

            case 'X':
                Timeout = _wtoi(argv[1]);   
                break;

            case 'F':
                Flags = _wtoi(argv[1]);   
                break;

            case 'G':
                pGuid = argv[1];
                break;

            case 'H':
                pHash = argv[1];
                break;

            default:
                NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
                return ERROR_INVALID_PARAMETER;
        }

        argc -=2;
        argv +=2;
    }

    switch(type)
    {
        case HttpCfgTypeSet:
            return DoSslSet(
                        pIp, 
                        pGuid, 
                        pHash, 
                        CertCheckMode,
                        Freshness,
                        Timeout,
                        Flags,
                        pCtlIdentifier,
                        pCtlStoreName,
                        pCertStoreName
                        );

        case HttpCfgTypeQuery:
            return DoSslQuery(pIp);

        case HttpCfgTypeDelete:
            return DoSslDelete(pIp);

        default: 
            NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
            return ERROR_INVALID_PARAMETER;
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\bugcheck.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    bugcheck.c

Abstract:

    A few errors are so severe that our only option is to bugcheck.
    
Author:

    George V. Reilly  Jun-2001

Revision History:

--*/


#include <precomp.h>


VOID
UlBugCheckEx(
    IN ULONG_PTR HttpSysBugcheckSubCode,
    IN ULONG_PTR Param2,
    IN ULONG_PTR Param3,
    IN ULONG_PTR Param4
    )
{
    KeBugCheckEx(
        HTTP_DRIVER_CORRUPTED,
        HttpSysBugcheckSubCode,
        Param2,
        Param3,
        Param4
        );
} // UlBugCheckEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\apool.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    apool.h

Abstract:

    The public definition of app pool interfaces.

Author:

    Paul McDaniel (paulmcd)       28-Jan-1999


Revision History:

--*/


#ifndef _APOOL_H_
#define _APOOL_H_


//
// Kernel mode mappings to the user mode set defined in ulapi.h
//

//
// Constants.
//

#define UL_MAX_APP_POOL_NAME_SIZE   (MAX_PATH*sizeof(WCHAR))

#define UL_MAX_REQUESTS_QUEUED      0xFFFF
#define UL_MIN_REQUESTS_QUEUED      10


//
// Forwarders.
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;
typedef struct _UL_CONFIG_GROUP_OBJECT *PUL_CONFIG_GROUP_OBJECT;


//
// This structure represents an internal app pool object
//

#define IS_VALID_AP_OBJECT(pObject)                             \
    (HAS_VALID_SIGNATURE(pObject, UL_APP_POOL_OBJECT_POOL_TAG)  \
     && ((pObject)->RefCount > 0))

typedef struct _UL_APP_POOL_OBJECT
{
    //
    // NonPagedPool
    //

    //
    // Lock that protects NewRequestQueue and PendingRequestQueue
    // for each attached process and queue state of the request
    //
    // ensure it on cache-line and use InStackQueuedSpinLock for
    // better performance
    //
    UL_SPIN_LOCK            SpinLock;

    //
    // UL_APP_POOL_OBJECT_POOL_TAG
    //
    ULONG                   Signature;

    //
    // Ref count for this app pool
    //
    LONG                    RefCount;

    //
    // links all apool objects, anchored by g_AppPoolListHead
    //
    LIST_ENTRY              ListEntry;

    //
    // A apool wide new request list (when no irps are available)
    //
    LIST_ENTRY              NewRequestHead;
    ULONG                   RequestCount;
    ULONG                   MaxRequests;

    //
    // the demand start irp (OPTIONAL)
    //
    PIRP                    pDemandStartIrp;
    PEPROCESS               pDemandStartProcess;

    //
    // the control channel associated with this app pool
    //
    PUL_CONTROL_CHANNEL     pControlChannel;

    //
    // the list of processes bound to this app pool
    //
    LIST_ENTRY              ProcessListHead;

    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    //
    // the length of pName
    //
    USHORT                  NameLength;

    //
    // number of active processes in the AppPool, used to decide if binding
    // is necessary
    //
    ULONG                   NumberActiveProcesses;

    //
    // Only route requests to this AppPool if it's marked active
    //
    HTTP_APP_POOL_ENABLED_STATE State;

    //
    // How sophisticated is the load balancer routing requests to the apppool?
    //
    HTTP_LOAD_BALANCER_CAPABILITIES LoadBalancerCapability;

    //
    // the apool's name
    //
    WCHAR                   pName[0];

} UL_APP_POOL_OBJECT, *PUL_APP_POOL_OBJECT;


//
// The structure representing a process bound to an app pool.
//

#define IS_VALID_AP_PROCESS(pObject)                            \
    HAS_VALID_SIGNATURE(pObject, UL_APP_POOL_PROCESS_POOL_TAG)

typedef struct _UL_APP_POOL_PROCESS
{
    //
    // NonPagedPool
    //

    //
    // UL_APP_POOL_PROCESS_POOL_TAG
    //
    ULONG                   Signature;

    //
    // Ref count for this app pool process. This is more like an outstanding
    // io count rather than the refcount. The process is still get cleaned 
    // with ULClose call. But completion for the cleanup delays until all
    // send io exhaust on the process.
    //
    LONG                    RefCount;

    //
    // CleanUpIrp will be completed when all the IO exhaust on 
    // the cleanup pending process.
    //
    PIRP                    pCleanupIrp;

    //
    // set if we are in cleanup. You must check this flag before attaching
    // any IRPs to the process.
    //
    ULONG                   InCleanup : 1;

    //
    // set if process is attached with the HTTP_OPTION_CONTROLLER option
    //
    ULONG                   Controller : 1;

    //
    // used to link into the apool object
    //
    LIST_ENTRY              ListEntry;

    //
    // points to the app pool this process belongs
    //
    PUL_APP_POOL_OBJECT     pAppPool;

    //
    // a list of pending IRP(s) waiting to receive new requests
    //
    LIST_ENTRY              NewIrpHead;

    //
    // links requests that would not fit in a irp buffer and need to wait for
    // the larger buffer
    //
    // and
    //
    // requests that this process is working on and need
    // i/o cancellation if the process detaches from the apool
    //
    LIST_ENTRY              PendingRequestHead;

    //
    // Pointer to the actual process.
    //
    PEPROCESS               pProcess;

    //
    // List of pending "wait for disconnect" IRPs.
    //
    UL_NOTIFY_HEAD          WaitForDisconnectHead;

} UL_APP_POOL_PROCESS, *PUL_APP_POOL_PROCESS;


// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlAttachProcessToAppPool(
    IN  PWCHAR                          pName OPTIONAL,
    IN  USHORT                          NameLength,
    IN  BOOLEAN                         Create,
    IN  PACCESS_STATE                   pAccessState,
    IN  ACCESS_MASK                     DesiredAccess,
    IN  KPROCESSOR_MODE                 RequestorMode,
    OUT PUL_APP_POOL_PROCESS *          ppProcess
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlDetachProcessFromAppPool(
    IN PIRP pCleanupIrp,
    IN PIO_STACK_LOCATION pCleanupIrpSp
    );

VOID
UlShutdownAppPoolProcess(
    IN PUL_APP_POOL_PROCESS pProcess
    );

// IRQL == PASSIVE_LEVEL
//
#if REFERENCE_DEBUG
VOID
UlReferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
#else
__inline
VOID
UlReferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    )
{
    InterlockedIncrement(&pAppPool->RefCount);
}
#endif

#define REFERENCE_APP_POOL( papp )                                          \
    UlReferenceAppPool(                                                     \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

// IRQL == PASSIVE_LEVEL
//
VOID
UlDeleteAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DELETE_APP_POOL( papp )                                             \
    UlDeleteAppPool(                                                        \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#if REFERENCE_DEBUG
VOID
UlDereferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
#else
__inline
VOID
UlDereferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    )
{
    if (InterlockedDecrement(&pAppPool->RefCount) == 0)
    {
        UlDeleteAppPool(pAppPool);
    }
}
#endif

#define DEREFERENCE_APP_POOL( papp )                                        \
    UlDereferenceAppPool(                                                   \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

VOID
UlpCleanUpAppoolProcess(
    IN  PUL_APP_POOL_PROCESS pAppPoolProcess
    );

#if REFERENCE_DEBUG

VOID
UlReferenceAppPoolProcess(
    IN  PUL_APP_POOL_PROCESS pAppPoolProcess
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceAppPoolProcess(
    IN  PUL_APP_POOL_PROCESS pAppPoolProcess
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#else

__inline
VOID
UlReferenceAppPoolProcess(
    IN  PUL_APP_POOL_PROCESS pAppPoolProcess
    )
{
    InterlockedIncrement(&pAppPoolProcess->RefCount);
}

__inline
VOID
UlDereferenceAppPoolProcess(
    IN  PUL_APP_POOL_PROCESS pAppPoolProcess
    )
{
    if (InterlockedDecrement(&pAppPoolProcess->RefCount) == 0)
    {
        UlpCleanUpAppoolProcess(pAppPoolProcess);
    }
}
        
#endif

#define REFERENCE_APP_POOL_PROCESS( papp )                                  \
    UlReferenceAppPoolProcess(                                              \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )
        
#define DEREFERENCE_APP_POOL_PROCESS( papp )                                \
    UlDereferenceAppPoolProcess(                                            \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )
        

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlQueryAppPoolInformation(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID                           pAppPoolInformation,
    IN  ULONG                           Length,
    OUT PULONG                          pReturnLength
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlSetAppPoolInformation(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    IN  PVOID                           pAppPoolInformation,
    IN  ULONG                           Length
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlWaitForDemandStart(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  PIRP                            pIrp
    );


// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlReceiveHttpRequest(
    IN  HTTP_REQUEST_ID                 RequestId,
    IN  ULONG                           Flags,
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  PIRP                            pIrp
    );


// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlDeliverRequestToProcess(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest,
    OUT PIRP *pIrpToComplete OPTIONAL
    );

/***************************************************************************++

Routine Description:

    Gets the current app pool queue state of the request.

Arguments:

    pProcess - Request object
    return value - The current appool queue state of the request

--***************************************************************************/
__inline
BOOLEAN
UlCheckAppPoolState(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_APP_POOL_PROCESS pProcess;

    //
    // Check the AppPool queue state of the request.
    //

    if (QueueCopiedState != pRequest->AppPool.QueueState)
    {
        return FALSE;
    }

    //
    // Check if the process has been detached. Since we never unset
    // pRequest->AppPool.pProcess until the reference of the request
    // drops to 0, it is safe to use pProcess this way here.
    //

    pProcess = pRequest->AppPool.pProcess;
    ASSERT(!pProcess || IS_VALID_AP_PROCESS(pProcess));

    if (!pProcess || pProcess->InCleanup)
    {
        return FALSE;
    }

    return TRUE;
    
}

VOID
UlUnlinkRequestFromProcess(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlGetPoolFromHandle(
    IN HANDLE                           hAppPool,
    IN KPROCESSOR_MODE                  AccessMode,
    OUT PUL_APP_POOL_OBJECT *           ppAppPool
    );


NTSTATUS
UlInitializeAP(
    VOID
    );

VOID
UlTerminateAP(
    VOID
    );

PUL_APP_POOL_PROCESS
UlCreateAppPoolProcess(
    PUL_APP_POOL_OBJECT pObject
    );

VOID
UlCloseAppPoolProcess(
    PUL_APP_POOL_PROCESS pProcess
    );

NTSTATUS
UlWaitForDisconnect(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_HTTP_CONNECTION  pHttpConn,
    IN PIRP pIrp
    );

VOID
UlCompleteAllWaitForDisconnect(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlCopyRequestToIrp(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP                 pIrp,
    IN BOOLEAN              CompleteIrp,
    IN BOOLEAN              LockAcquired
    );

NTSTATUS
UlCopyRequestToBuffer(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR               pKernelBuffer,
    IN PVOID                pUserBuffer,
    IN ULONG                BufferLength,
    IN ULONG                Flags,
    IN BOOLEAN              LockAcquired,
    OUT PULONG              pBytesCopied
    );

NTSTATUS
UlDequeueNewRequest(
    IN PUL_APP_POOL_PROCESS     pProcess,
    IN ULONG                    RequestBufferLength,
    OUT PUL_INTERNAL_REQUEST *  pRequest
    );

VOID
UlRequeuePendingRequest(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest
    );

__inline
NTSTATUS
UlComputeRequestBytesNeeded(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PULONG pBytesNeeded
    )
{
    NTSTATUS Status;
    ULONG SslInfoSize;

    C_ASSERT(SOCKADDR_ADDRESS_LENGTH_IP6 >= SOCKADDR_ADDRESS_LENGTH_IP);

    //
    // Calculate the size needed for the request, we'll need it below.
    //

    *pBytesNeeded =
        sizeof(HTTP_REQUEST) +
        pRequest->TotalRequestSize +
        (pRequest->UnknownHeaderCount * sizeof(HTTP_UNKNOWN_HEADER));

    //
    // Include additional space for the local and remote addresses.
    //

    *pBytesNeeded += 2 * ALIGN_UP(SOCKADDR_ADDRESS_LENGTH_IP6, PVOID);

    //
    // Include space for any SSL information.
    //

    if (pRequest->pHttpConn->SecureConnection)
    {
        Status = UlGetSslInfo(
                        &pRequest->pHttpConn->pConnection->FilterInfo,
                        0,                      // BufferSize
                        NULL,                   // pUserBuffer
                        NULL,                   // pProcess (WP)
                        NULL,                   // pBuffer
                        NULL,                   // pMappedToken
                        &SslInfoSize            // pBytesNeeded
                        );

        if (NT_SUCCESS(Status))
        {
            //
            // Struct must be aligned; add some slop space
            //

            *pBytesNeeded = ALIGN_UP(*pBytesNeeded, PVOID);
            *pBytesNeeded += SslInfoSize;
        }
        else
        {
            return Status;
        }
    }

    return STATUS_SUCCESS;

} // UlComputeRequestBytesNeeded


#endif // _APOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\cache.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    Contains the HTTP response cache logic.

Author:

    Michael Courage (mcourage)      17-May-1999

Revision History:

--*/

#include    "precomp.h"
#include    "cachep.h"


BOOLEAN             g_InitUriCacheCalled;

//
// Global hash table
//

HASHTABLE           g_UriCacheTable;

LIST_ENTRY          g_ZombieListHead;

UL_URI_CACHE_CONFIG g_UriCacheConfig;
UL_URI_CACHE_STATS  g_UriCacheStats;

UL_SPIN_LOCK        g_UriCacheSpinLock;

//
// Turn on/off cache at runtime
//
LONG               g_CacheMemEnabled = TRUE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeUriCache )
#pragma alloc_text( PAGE, UlTerminateUriCache )

#pragma alloc_text( PAGE, UlCheckCachePreconditions )
#pragma alloc_text( PAGE, UlCheckCacheResponseConditions )
#pragma alloc_text( PAGE, UlCheckoutUriCacheEntry )
#pragma alloc_text( PAGE, UlCheckinUriCacheEntry )
#pragma alloc_text( PAGE, UlFlushCache )
#pragma alloc_text( PAGE, UlpFlushFilterAll )
#pragma alloc_text( PAGE, UlFlushCacheByProcess )
#pragma alloc_text( PAGE, UlpFlushFilterProcess )
#pragma alloc_text( PAGE, UlFlushCacheByUri )
#pragma alloc_text( PAGE, UlpFlushUri )
#pragma alloc_text( PAGE, UlAddCacheEntry )
#pragma alloc_text( PAGE, UlpFilteredFlushUriCache )
#pragma alloc_text( PAGE, UlpFilteredFlushUriCacheInline )
#pragma alloc_text( PAGE, UlpFilteredFlushUriCacheWorker )
#pragma alloc_text( PAGE, UlpAddZombie )
#pragma alloc_text( PAGE, UlpClearZombieList )
#pragma alloc_text( PAGE, UlpDestroyUriCacheEntry )
#pragma alloc_text( PAGE, UlPeriodicCacheScavenger )
#pragma alloc_text( PAGE, UlpFlushFilterPeriodicScavenger )
#pragma alloc_text( PAGE, UlTrimCache )
#pragma alloc_text( PAGE, UlpFlushFilterTrimCache )
#pragma alloc_text( PAGE, UlpQueryTranslateHeader )
#pragma alloc_text( PAGE, UlpQueryExpectHeader )

#pragma alloc_text( PAGE, UlAddFragmentToCache )
#pragma alloc_text( PAGE, UlReadFragmentFromCache )
#pragma alloc_text( PAGE, UlpCreateFragmentCacheEntry )
#pragma alloc_text( PAGE, UlAllocateCacheEntry )
#pragma alloc_text( PAGE, UlAddCacheEntry )
#pragma alloc_text( PAGE, UlDisableCache )
#pragma alloc_text( PAGE, UlEnableCache )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpCheckTableSpace
NOT PAGEABLE -- UlpCheckSpaceAndAddEntryStats
NOT PAGEABLE -- UlpRemoveEntryStats
#endif


/***************************************************************************++

Routine Description:

    Performs global initialization of the URI cache.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeUriCache(
    PUL_CONFIG pConfig
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( !g_InitUriCacheCalled );

    UlTrace(URI_CACHE, ("Http!UlInitializeUriCache\n"));

    if ( !g_InitUriCacheCalled )
    {
        PUL_URI_CACHE_CONFIG pUriConfig = &pConfig->UriConfig;

        g_UriCacheConfig.EnableCache        = pUriConfig->EnableCache;
        g_UriCacheConfig.MaxCacheUriCount   = pUriConfig->MaxCacheUriCount;
        g_UriCacheConfig.MaxCacheMegabyteCount =
            pUriConfig->MaxCacheMegabyteCount;

        g_UriCacheConfig.MaxCacheByteCount =
            (((ULONGLONG) g_UriCacheConfig.MaxCacheMegabyteCount)
                            << MEGABYTE_SHIFT);

        //
        // Don't want to scavenge more than once every ten seconds.
        // In particular, do not want to scavenge every 0 seconds, as the
        // machine will become completely unresponsive.
        //

        g_UriCacheConfig.ScavengerPeriod    =
            max(pUriConfig->ScavengerPeriod, 10);

        g_UriCacheConfig.MaxUriBytes        = pUriConfig->MaxUriBytes;
        g_UriCacheConfig.HashTableBits      = pUriConfig->HashTableBits;

        RtlZeroMemory(&g_UriCacheStats, sizeof(g_UriCacheStats));
        InitializeListHead(&g_ZombieListHead);

        UlInitializeSpinLock( &g_UriCacheSpinLock, "g_UriCacheSpinLock" );

        if (g_UriCacheConfig.EnableCache)
        {
            Status = UlInitializeResource(
                            &g_pUlNonpagedData->UriZombieResource,
                            "UriZombieResource",
                            0,
                            UL_ZOMBIE_RESOURCE_TAG
                            );

            if (NT_SUCCESS(Status))
            {
                Status = UlInitializeHashTable(
                        &g_UriCacheTable,
                        PagedPool, 
                        g_UriCacheConfig.HashTableBits
                        );

                if (NT_SUCCESS(Status))
                {
                    ASSERT(IS_VALID_HASHTABLE(&g_UriCacheTable));
                    
                    Status = UlInitializeScavengerThread();

                    g_InitUriCacheCalled = TRUE;
                }
            }
            else
            {

                UlDeleteResource(&g_pUlNonpagedData->UriZombieResource);
            }

        }
        else
        {
            UlTrace(URI_CACHE, ("URI Cache disabled.\n"));
            g_InitUriCacheCalled = TRUE;
        }

    }
    else
    {
        UlTrace(URI_CACHE, ("URI CACHE INITIALIZED TWICE!\n"));
    }

    return Status;
}   // UlInitializeUriCache


/***************************************************************************++

Routine Description:

    Performs global termination of the URI cache.

--***************************************************************************/
VOID
UlTerminateUriCache(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(URI_CACHE, ("Http!UlTerminateUriCache\n"));

    if (g_InitUriCacheCalled && g_UriCacheConfig.EnableCache)
    {
        // Must terminate the scavenger before destroying the hash table
        UlTerminateScavengerThread();

        UlTerminateHashTable(&g_UriCacheTable);

        Status = UlDeleteResource(&g_pUlNonpagedData->UriZombieResource);
        ASSERT(NT_SUCCESS(Status));
    }

    g_InitUriCacheCalled = FALSE;

}   // UlTerminateUriCache

/***************************************************************************++

Routine Description:

    This routine checks a request (and its connection) to see if it's
    ok to serve this request from the cache. Basically we only accept
    simple GET requests with no conditional headers.

Arguments:

    pHttpConn - The connection to be checked

Return Value:

    BOOLEAN - True if it's ok to serve from cache

--***************************************************************************/
BOOLEAN
UlCheckCachePreconditions(
    PUL_INTERNAL_REQUEST    pRequest,
    PUL_HTTP_CONNECTION     pHttpConn
    )
{
    URI_PRECONDITION Precondition = URI_PRE_OK;

    UNREFERENCED_PARAMETER(pHttpConn);

    //
    // Sanity check
    //
    PAGED_CODE();

    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConn) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

    if (!g_UriCacheConfig.EnableCache)
    {
        Precondition = URI_PRE_DISABLED;
    }

    else if (pRequest->ParseState != ParseDoneState)
    {
        Precondition = URI_PRE_ENTITY_BODY;
    }

    else if (pRequest->Verb != HttpVerbGET)
    {
        Precondition = URI_PRE_VERB;
    }

    else if (HTTP_NOT_EQUAL_VERSION(pRequest->Version, 1, 1)
                && HTTP_NOT_EQUAL_VERSION(pRequest->Version, 1, 0))
    {
        Precondition = URI_PRE_PROTOCOL;
    }

    // check for Translate: f (DAV)
    else if ( UlpQueryTranslateHeader(pRequest) )
    {
        Precondition = URI_PRE_TRANSLATE;
    }

    // check for non-100-continue expectation
    else if ( !UlpQueryExpectHeader(pRequest) )
    {
        Precondition = URI_PRE_EXPECTATION_FAILED;
    }

    // check for Authorization header
    else if (pRequest->HeaderValid[HttpHeaderAuthorization])
    {
        Precondition = URI_PRE_AUTHORIZATION;
    }

    //
    // check for some of the If-* headers
    // NOTE: See UlpCheckCacheControlHeaders for handling of other If-* headers
    //
    else if (pRequest->HeaderValid[HttpHeaderIfRange])
    {
        Precondition = URI_PRE_CONDITIONAL;
    }

    // CODEWORK: check for other evil headers
    else if (pRequest->HeaderValid[HttpHeaderRange])
    {
        Precondition = URI_PRE_OTHER_HEADER;
    }

    UlTrace(URI_CACHE,
            ("Http!UlCheckCachePreconditions(req = %p, '%ls', httpconn = %p)\n"
             "        OkToServeFromCache = %d, Precondition = %d\n",
             pRequest,
             pRequest->CookedUrl.pUrl,
             pHttpConn,
             (URI_PRE_OK == Precondition) ? 1 : 0,
             Precondition
             ));

    return (BOOLEAN) (URI_PRE_OK == Precondition);
} // UlCheckCachePreconditions


/***************************************************************************++

Routine Description:

    This routine checks a response to see if it's cacheable. Basically
    we'll take it if:

       * the cache policy is right
       * the size is small enough
       * there is room in the cache
       * we get the response all at once

Arguments:

    pHttpConn - The connection to be checked

Return Value:

    BOOLEAN - True if it's ok to serve from cache

--***************************************************************************/
BOOLEAN
UlCheckCacheResponseConditions(
    PUL_INTERNAL_REQUEST        pRequest,
    PUL_INTERNAL_RESPONSE       pResponse,
    ULONG                       Flags,
    HTTP_CACHE_POLICY           CachePolicy
    )
{
    URI_PRECONDITION Precondition = URI_PRE_OK;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE(pResponse) );

    if (pRequest->CachePreconditions == FALSE) {
        Precondition = URI_PRE_REQUEST;
    }

    // check policy
    else if (CachePolicy.Policy == HttpCachePolicyNocache) {
        Precondition = URI_PRE_POLICY;
    }

    // check if Date: header is valid (can affect If-Modified-Since handling)
    else if (!pResponse->GenDateHeader || (0L == pResponse->CreationTime.QuadPart)) {
        Precondition = URI_PRE_PROTOCOL;
    }

    // check size of response
    else if ((pResponse->ResponseLength - pResponse->HeaderLength) >
             g_UriCacheConfig.MaxUriBytes) {
        Precondition = URI_PRE_SIZE;
    }

    // check if the header length exceeds the limit
    else if (pResponse->HeaderLength > g_UlMaxFixedHeaderSize) {
        Precondition = URI_PRE_SIZE;
    }

    // check for full response
    else if (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) {
        Precondition = URI_PRE_FRAGMENT;
    }

    // check available cache table space
    else if (!UlpCheckTableSpace(pResponse->ResponseLength)) {
        Precondition = URI_PRE_NOMEMORY;
    }

    // Check for bogus responses
    else if ((pResponse->ResponseLength < 1) || (pResponse->ChunkCount < 2)) {
        Precondition = URI_PRE_BOGUS;
    }

    // FUTURE: check if multiple Content-Encodings are applied
    // else if ( /* multiple encodings */ )
    // {
    //      Precondition = URI_PRE_BOGUS;
    // }

    UlTrace(URI_CACHE,
            ("Http!UlCheckCacheResponseConditions("
             "pRequest = %p, '%ls', pResponse = %p)\n"
             "    OkToCache = %d, Precondition = %d\n",
             pRequest,
             pRequest->CookedUrl.pUrl,
             pResponse,
             (URI_PRE_OK == Precondition),
             Precondition
             ));

    return (BOOLEAN) (URI_PRE_OK == Precondition);
} // UlCheckCacheResponseConditions



/***************************************************************************++

Routine Description:

    This routine does a cache lookup to see if there is a valid entry
    corresponding to the request URI.

Arguments:

    pSearchKey - The -extended or normal- Uri Key

Return Value:

    PUL_URI_CACHE_ENTRY - Pointer to the entry, if found. NULL otherwise.
--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlCheckoutUriCacheEntry(
    PURI_SEARCH_KEY pSearchKey
    )
{
    PUL_URI_CACHE_ENTRY pUriCacheEntry = NULL;

    //
    // Sanity check
    //
    PAGED_CODE();

    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    ASSERT(IS_VALID_URI_SEARCH_KEY(pSearchKey));
        
    pUriCacheEntry = UlGetFromHashTable(
                        &g_UriCacheTable, 
                         pSearchKey
                         );

    if (pUriCacheEntry != NULL)
    {
        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

        //
        // see if entry has expired; if so, check it right back in
        // without touching the stats.  We expect the scavenger to 
        // deal with flushing this entry the next time it runs, so 
        // we can defer the flush.
        //
        if ( HttpCachePolicyTimeToLive == pUriCacheEntry->CachePolicy.Policy )
        {
            LARGE_INTEGER   Now;

            KeQuerySystemTime(&Now);

            if ( Now.QuadPart > pUriCacheEntry->ExpirationTime.QuadPart )
            {
                UlTrace(URI_CACHE,
                    ("Http!UlCheckoutUriCacheEntry: pUriCacheEntry %p is EXPIRED\n",
                    pUriCacheEntry
                    ));
                
                UlCheckinUriCacheEntry(pUriCacheEntry);
                pUriCacheEntry = NULL;

                goto end;
            }
        }
            

        pUriCacheEntry->HitCount++;

        // reset scavenger counter
        pUriCacheEntry->ScavengerTicks = 0;

        UlTrace(URI_CACHE,
                ("Http!UlCheckoutUriCacheEntry(pUriCacheEntry %p, '%ls') "
                 "refcount = %d\n",
                 pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
                 pUriCacheEntry->ReferenceCount
                 ));
    }
    else
    {
        UlTrace(URI_CACHE,
            ("Http!UlCheckoutUriCacheEntry(failed: Token:'%ls' '%ls' )\n",
             pSearchKey->Type == UriKeyTypeExtended  ? 
                pSearchKey->ExKey.pToken :
                L"",                
             pSearchKey->Type == UriKeyTypeExtended ? 
                pSearchKey->ExKey.pAbsPath :
                pSearchKey->Key.pUri
             ));
    }

  end:
    return pUriCacheEntry;
    
} // UlCheckoutUriCacheEntry



/***************************************************************************++

Routine Description:

    Decrements the refcount on a cache entry. Cleans up non-cached
    entries.

Arguments:

    pUriCacheEntry - the entry to deref

--***************************************************************************/
VOID
UlCheckinUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    LONG ReferenceCount;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    UlTrace(URI_CACHE,
            ("Http!UlCheckinUriCacheEntry(pUriCacheEntry %p, '%ls')\n",
             pUriCacheEntry, pUriCacheEntry->UriKey.pUri
             ));
    //
    // decrement count
    //

    ReferenceCount = DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CHECKIN);

    ASSERT(ReferenceCount >= 0);

} // UlCheckinUriCacheEntry



/***************************************************************************++

Routine Description:

    Temporarly disables the indexing mechanism in CB Logging.
    
    Removes all cache entries, unconditionally. 

    Writes a cache flush notification to the CB log file, and enables the 
    indexing mechanism back.

--***************************************************************************/
VOID
UlFlushCache(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    //
    // Sanity check
    //
    
    PAGED_CODE();
    
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    //
    // Caller needs to hold the CG Lock exclusive, the flushes needs to
    // be serialized.
    //

    ASSERT(UlDbgResourceOwnedExclusive(
                &g_pUlNonpagedData->ConfigGroupResource
                ));

    //
    // Nothing to do, if cache is disabled.    
    //
    
    if (g_UriCacheConfig.EnableCache)
    {
        UlTrace(URI_CACHE,("Http!UlFlushCache()\n"));

        // TODO: Need to notify every control channel

        //
        // This is to prevent any outstanding sends for the zombified
        // cache entries to refer to the obsolete indexes, in case the
        // sends get completed after we write the cache notification 
        // entry to the log file. The CB logging calls here must be 
        // preserved in this order and must be used while holding the
        // CG lock. Do not release the lock acquire it again and call
        // the other.
        //
        
        if (pControlChannel)
        {
            UlDisableIndexingForCacheHits(pControlChannel);                
        }        

        //
        // Unconditionally zombifies all of the uri cache entries.
        //
        
        UlpFilteredFlushUriCache(UlpFlushFilterAll, NULL, NULL, 0);

        //
        // HandleFlush will enable the (CB Logging) indexing, 
        // once it is done writting the notification record. 
        //
        
        if (pControlChannel)
        {
            UlHandleCacheFlushedNotification(pControlChannel);
        }
        
    }
    
} // UlFlushCache


/***************************************************************************++

Routine Description:

    A filter for UlFlushCache. Called by UlpFilteredFlushUriCache.

Arguments:

    pUriCacheEntry - the entry to check
    pContext - ignored

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterAll(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT  pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext == NULL );

    UlTrace(URI_CACHE, (
        "Http!UlpFlushFilterAll(pUriCacheEntry %p '%ls') refcount = %d\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
        pUriCacheEntry->ReferenceCount));

    //
    // Second BOOLEAN must * only * be true if the UlpFlushFilterAll is
    // called by UlFlushCache (since it writes a binary log file record
    // of flush).
    //
    
    return UlpZombifyEntry(
                TRUE,
                TRUE,
                pUriCacheEntry,
                pUriFilterContext
                );

} // UlpFlushFilterAll


/***************************************************************************++

Routine Description:

    Removes any cache entries that were created by the given process.

Arguments:

    pProcess - a process that is going away

--***************************************************************************/
VOID
UlFlushCacheByProcess(
    PUL_APP_POOL_PROCESS pProcess
    )
{
    //
    // sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    if (g_UriCacheConfig.EnableCache)
    {
        UlTrace(URI_CACHE, (
                    "Http!UlFlushCacheByProcess(proc = %p)\n",
                    pProcess
                    ));

        UlpFilteredFlushUriCache(UlpFlushFilterProcess, pProcess, NULL, 0);
    }
} // UlFlushCacheByProcess


/***************************************************************************++

Routine Description:

    If recursive flag has been picked this function removes the cache entries
    matching with the given prefix. (pUri)

    Otherwise removes the specific URL from the cache.

Arguments:

    pUri     - the uri prefix to match against
    Length   - length of the prefix, in bytes
    Flags    - HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE indicates a tree flush
    pProcess - the process that made the call

--***************************************************************************/
VOID
UlFlushCacheByUri(
    IN PWSTR pUri,
    IN ULONG Length,
    IN ULONG Flags,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    NTSTATUS    Status;
    BOOLEAN     Recursive;
    PWSTR       pCopiedUri;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT( !g_UriCacheConfig.EnableCache
            || IS_VALID_HASHTABLE(&g_UriCacheTable) );

    if (!g_UriCacheConfig.EnableCache)
    {
        return;
    }

    Status = STATUS_SUCCESS;
    Recursive = (BOOLEAN) (0 != (Flags & HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE));
    pCopiedUri = NULL;

    UlTrace(URI_CACHE, (
            "Http!UlFlushCacheByUri(\n"
            "    uri   = '%S'\n"
            "    len   = %d\n"
            "    flags = %08x, recursive = %d\n"
            "    proc  = %p\n",
            pUri,
            Length,
            Flags,
            (int) Recursive,
            pProcess
            ));

    //
    // Ensure pUri ends with a L'/' if Recursive flag is set.
    //

    if (Recursive &&
        pUri[(Length-sizeof(WCHAR))/sizeof(WCHAR)] != L'/')
    {
        //
        // Make a copy of the origianl URL and append a L'/' to it.
        //

        pCopiedUri = (PWSTR) UL_ALLOCATE_POOL(
                                PagedPool,
                                Length + sizeof(WCHAR) + sizeof(WCHAR),
                                UL_UNICODE_STRING_POOL_TAG
                                );

        if (!pCopiedUri)
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            RtlCopyMemory(
                pCopiedUri,
                pUri,
                Length
                );

            pCopiedUri[Length/sizeof(WCHAR)] = L'/';
            pCopiedUri[(Length+sizeof(WCHAR))/sizeof(WCHAR)] = UNICODE_NULL;

            pUri = pCopiedUri;
            Length += sizeof(WCHAR);
        }
    }

    if (NT_SUCCESS(Status))
    {
        if (Recursive)
        {
            //
            // When the recursive flag is set, we are supposed
            // to do prefix match with respect to provided URL.
            // Any cache entry matches with the prefix will be
            // flushed out from the cache.
            //
            
            UlpFilteredFlushUriCache(
                UlpFlushFilterUriRecursive,
                pProcess,
                pUri,
                Length
                );            
        }
        else 
        {
            UlpFlushUri(
                pUri,
                Length,
                pProcess
                );

            UlpClearZombieList();
        }
    }

    if (pCopiedUri)
    {
        UL_FREE_POOL(pCopiedUri, UL_UNICODE_STRING_POOL_TAG);
    }
    
} // UlFlushCacheByUri


/***************************************************************************++

Routine Description:

    Removes a single URI from the table if the name and process match an
    entry.

Arguments:


--***************************************************************************/
VOID
UlpFlushUri(
    IN PWSTR pUri,
    IN ULONG Length,
    PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry = NULL;
    URI_KEY                 Key;

    //
    // Sanity check
    //
    PAGED_CODE();

    //
    // find bucket
    //

    Key.Hash = HashRandomizeBits(HashStringNoCaseW(pUri, 0));
    Key.Length = Length;
    Key.pUri = pUri;
    Key.pPath = NULL;

    pUriCacheEntry = UlDeleteFromHashTable(&g_UriCacheTable, &Key, pProcess);

    if (NULL != pUriCacheEntry)
    {

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

        UlTrace(URI_CACHE, (
            "Http!UlpFlushUri(pUriCacheEntry %p '%ls') refcount = %d\n",
            pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
            pUriCacheEntry->ReferenceCount));

        DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, FLUSH);

        //
        // Perfmon counters
        //

        UlIncCounter(HttpGlobalCounterTotalFlushedUris);
    }

} // UlpFlushUri


/***************************************************************************++

Routine Description:

    A filter for UlFlushCacheByProcess. Called by UlpFilteredFlushUriCache.

Arguments:

    pUriCacheEntry - the entry to check
    pContext - pointer to the UL_APP_POOL_PROCESS that's going away

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterProcess(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT  pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;
    PUL_APP_POOL_PROCESS pProcess;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( IS_VALID_FILTER_CONTEXT(pUriFilterContext) 
            &&  pUriFilterContext->pCallerContext != NULL );
    
    pProcess = (PUL_APP_POOL_PROCESS) pUriFilterContext->pCallerContext;
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );

    return UlpZombifyEntry(
                (BOOLEAN) (pProcess == pUriCacheEntry->pProcess),
                FALSE,
                pUriCacheEntry,
                pUriFilterContext
                );

} // UlpFlushFilterProcess

/***************************************************************************++

Routine Description:

    A filter for UlpFilteredFlushUriCache. If the given cache entry has a
    URI which is prefix of the URI inside the filter context this function
    returns delete. Otherwise do not care.

Arguments:

    pUriCacheEntry - the entry to check
    pContext       - pointer to the filter context which holds the appool and
                     the URI key for the prefix matching.

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterUriRecursive(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT  pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;
    PUL_APP_POOL_PROCESS pProcess;
    BOOLEAN              bZombify = FALSE;
    UL_CACHE_PREDICATE   Predicate = ULC_NO_ACTION;

    //
    // Sanity check
    //
    
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( IS_VALID_FILTER_CONTEXT(pUriFilterContext) 
            &&  pUriFilterContext->pCallerContext != NULL );
    
    pProcess = (PUL_APP_POOL_PROCESS) pUriFilterContext->pCallerContext;
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );

    if ( pUriFilterContext->UriKey.pUri == NULL 
         || pUriFilterContext->UriKey.Length == 0 
         || pUriFilterContext->UriKey.Length > 
                pUriCacheEntry->UriKey.Length 
        )
    {
        return ULC_NO_ACTION;
    }

    bZombify =       
       (BOOLEAN) (pProcess == pUriCacheEntry->pProcess)
        &&
        UlPrefixUriKeys(&pUriFilterContext->UriKey,
                        &pUriCacheEntry->UriKey)
        ;
            
    Predicate = 
        UlpZombifyEntry(
                bZombify,
                FALSE,
                pUriCacheEntry,
                pUriFilterContext
                );

    //
    // Make sure that the Zombify function do not returns ULC_DELETE_STOP.
    // So that our caller proceeds with the search through the entire
    // cache table.
    //
    
    ASSERT( Predicate == ULC_DELETE || Predicate == ULC_NO_ACTION );

    return Predicate;

} // UlpFlushFilterUriRecursive

/***************************************************************************++

Routine Description:

    Checks the hash table to make sure there is room for one more
    entry of a given size.

Arguments:

    EntrySize - the size in bytes of the entry to be added

--***************************************************************************/
BOOLEAN
UlpCheckTableSpace(
    IN ULONGLONG EntrySize
    )
{
    ULONG UriCount;
    ULONGLONG ByteCount;

    //
    // CODEWORK: MaxCacheMegabyteCount of zero should mean adaptive limit,
    // but for now I'll take it to mean "no limit".
    //

    if (g_UriCacheConfig.MaxCacheMegabyteCount == 0)
        ByteCount = 0;
    else
        ByteCount = g_UriCacheStats.ByteCount + ROUND_TO_PAGES(EntrySize);

    //
    // MaxCacheUriCount of zero means no limit on number of URIs cached
    //

    if (g_UriCacheConfig.MaxCacheUriCount == 0)
        UriCount = 0;
    else
        UriCount = g_UriCacheStats.UriCount + 1;

    if (
        UriCount  <=  g_UriCacheConfig.MaxCacheUriCount &&
        ByteCount <=  g_UriCacheConfig.MaxCacheByteCount
        )
    {
        return TRUE;
    }
    else
    {
        UlTrace(URI_CACHE, (
                    "Http!UlpCheckTableSpace(%I64u) FALSE\n"
                    "    UriCount              = %lu\n"
                    "    ByteCount             = %I64u (%luMB)\n"
                    "    MaxCacheUriCount      = %lu\n"
                    "    MaxCacheMegabyteCount = %luMB\n"
                    "    MaxCacheByteCount     = %I64u\n",
                    EntrySize,
                    g_UriCacheStats.UriCount,
                    g_UriCacheStats.ByteCount,
                    (ULONG) (g_UriCacheStats.ByteCount >> MEGABYTE_SHIFT),
                    g_UriCacheConfig.MaxCacheUriCount,
                    g_UriCacheConfig.MaxCacheMegabyteCount,
                    g_UriCacheConfig.MaxCacheByteCount
                    ));

        return FALSE;
    }
} // UlpCheckTableSpace


/***************************************************************************++

Routine Description:

    Tries to add a cache entry to the hash table.

Arguments:

    pUriCacheEntry - the entry to be added

--***************************************************************************/
NTSTATUS
UlAddCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    NTSTATUS Status;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT(! pUriCacheEntry->Zombie);

    pUriCacheEntry->BucketEntry.Next = NULL;
    pUriCacheEntry->Cached = FALSE;

    // First, check if still has space for storing the cache entry

    if (UlpCheckSpaceAndAddEntryStats(pUriCacheEntry))
    {
        pUriCacheEntry->Cached = TRUE;

        //
        // Insert this record into the hash table
        // Check first to see if the key already presents
        //

       Status = UlAddToHashTable(&g_UriCacheTable, pUriCacheEntry);

       if (!NT_SUCCESS(Status))
       {
           // This can fail if it's a duplicate name
           UlpRemoveEntryStats(pUriCacheEntry);
           pUriCacheEntry->Cached = FALSE;
       }
    }
    else
    {
        Status = STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    UlTrace(URI_CACHE, (
                "Http!UlAddCacheEntry(urientry %p '%ls') %s added to table. "
                "RefCount=%d, lkrc=%d.\n",
                pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
                pUriCacheEntry->Cached ? "was" : "was not",
                pUriCacheEntry->ReferenceCount,
                Status
                ));

    return Status;

} // UlAddCacheEntry


/***************************************************************************++

Routine Description:

    Check to see if we have space to add this cache entry and if so update
    cache statistics to reflect the addition of an entry.  This has to be
    done together inside a lock.

Arguments:

    pUriCacheEntry - entry being added

--***************************************************************************/
BOOLEAN
UlpCheckSpaceAndAddEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    KIRQL OldIrql;
    ULONG EntrySize;

    //
    // Sanity check
    //

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    EntrySize = pUriCacheEntry->HeaderLength + pUriCacheEntry->ContentLength;


    UlAcquireSpinLock( &g_UriCacheSpinLock, &OldIrql );

    if (UlpCheckTableSpace(EntrySize))
    {
        g_UriCacheStats.UriCount++;
        g_UriCacheStats.UriAddedTotal++;

        g_UriCacheStats.UriCountMax = MAX(
                                        g_UriCacheStats.UriCountMax,
                                        g_UriCacheStats.UriCount
                                        );

        g_UriCacheStats.ByteCount += EntrySize;

        g_UriCacheStats.ByteCountMax = MAX(
                                        g_UriCacheStats.ByteCountMax,
                                        g_UriCacheStats.ByteCount
                                        );

        UlReleaseSpinLock( &g_UriCacheSpinLock, OldIrql );

        //
        // Update Uri's site binding info stats.
        //
        
        switch (pUriCacheEntry->ConfigInfo.SiteUrlType)
        {
            case HttpUrlSite_None:
                InterlockedIncrement((PLONG) &g_UriCacheStats.UriTypeNotSpecifiedCount); 
            break;

            case HttpUrlSite_Name:
                InterlockedIncrement((PLONG) &g_UriCacheStats.UriTypeHostBoundCount); 
            break;

            case HttpUrlSite_NamePlusIP:
                InterlockedIncrement((PLONG) &g_UriCacheStats.UriTypeHostPlusIpBoundCount); 
            break;

            case HttpUrlSite_IP:
                InterlockedIncrement((PLONG) &g_UriCacheStats.UriTypeIpBoundCount); 
            break;

            case HttpUrlSite_WeakWildcard:
                InterlockedIncrement((PLONG) &g_UriCacheStats.UriTypeWildCardCount); 
            break;
            
            default:
                ASSERT(!"Invalid url site binding type while adding to cache !"); 
            break;            
        }
        
        UlTrace(URI_CACHE, (
                "Http!UlpCheckSpaceAndAddEntryStats (urientry %p '%ls')\n",
                pUriCacheEntry, pUriCacheEntry->UriKey.pUri
                ));

        //
        // Perfmon counters
        //

        UlIncCounter(HttpGlobalCounterCurrentUrisCached);
        UlIncCounter(HttpGlobalCounterTotalUrisCached);

        return TRUE;
    }

    UlReleaseSpinLock( &g_UriCacheSpinLock, OldIrql );

    return FALSE;
} // UlpCheckSpaceAndAddEntryStats


/***************************************************************************++

Routine Description:

    Updates cache statistics to reflect the removal of an entry

Arguments:

    pUriCacheEntry - entry being removed

--***************************************************************************/
VOID
UlpRemoveEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    KIRQL OldIrql;
    ULONG EntrySize;

    //
    // Sanity check
    //

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriCacheEntry->Cached );
    ASSERT( 0 == pUriCacheEntry->ReferenceCount );

    EntrySize = pUriCacheEntry->HeaderLength + pUriCacheEntry->ContentLength;

    UlAcquireSpinLock( &g_UriCacheSpinLock, &OldIrql );

    g_UriCacheStats.UriCount--;
    g_UriCacheStats.ByteCount -= EntrySize;

    UlReleaseSpinLock( &g_UriCacheSpinLock, OldIrql );

    //
    // Update Uri's site binding info stats.
    //

    switch (pUriCacheEntry->ConfigInfo.SiteUrlType)
    {
        case HttpUrlSite_None:
            InterlockedDecrement((PLONG) &g_UriCacheStats.UriTypeNotSpecifiedCount); 
        break;

        case HttpUrlSite_Name:
            InterlockedDecrement((PLONG) &g_UriCacheStats.UriTypeHostBoundCount); 
        break;

        case HttpUrlSite_NamePlusIP:
            InterlockedDecrement((PLONG) &g_UriCacheStats.UriTypeHostPlusIpBoundCount); 
        break;

        case HttpUrlSite_IP:
            InterlockedDecrement((PLONG) &g_UriCacheStats.UriTypeIpBoundCount); 
        break;

        case HttpUrlSite_WeakWildcard:
            InterlockedDecrement((PLONG) &g_UriCacheStats.UriTypeWildCardCount); 
        break;
            
        default:
            ASSERT(!"Invalid url site binding type while adding to cache !"); 
        break;            
    }

    UlTrace(URI_CACHE, (
        "Http!UlpRemoveEntryStats (urientry %p '%ls')\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri
        ));

    //
    // Perfmon counters
    //

    UlDecCounter(HttpGlobalCounterCurrentUrisCached);
} // UlpRemoveEntryStats



/***************************************************************************++

Routine Description:

    Helper function for the filter callbacks indirectly invoked by
    UlpFilteredFlushUriCache. Adds deleteable entries to a temporary
    list.

Arguments:

    MustZombify - if TRUE, add entry to the private zombie list
    pUriCacheEntry - entry to zombify
    pUriFilterContext - contains private list

--***************************************************************************/
UL_CACHE_PREDICATE
UlpZombifyEntry(
    BOOLEAN                MustZombify,
    BOOLEAN                MustResetIndex,
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PURI_FILTER_CONTEXT pUriFilterContext
    )
{
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT(URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature);

    ASSERT(! pUriCacheEntry->Zombie);
    ASSERT(NULL == pUriCacheEntry->ZombieListEntry.Flink);

    if (MustZombify)
    {
        //
        // Temporarily bump the refcount up so that it won't go down
        // to zero when it's removed from the hash table, automatically
        // invoking UlpDestroyUriCacheEntry, which we are trying to defer.
        //
        pUriCacheEntry->ZombieAddReffed = TRUE;

        REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, ZOMBIFY);

        InsertTailList(
            &pUriFilterContext->ZombieListHead,
            &pUriCacheEntry->ZombieListEntry);

        pUriCacheEntry->Zombie = TRUE;

        //
        // Force Raw Logging code to generate an index record for the
        // cache entry, in case there's a send on the fly waiting for
        // completion. This is because a flush record will be written
        // before the actual record.
        //
        if (MustResetIndex)
        {
            InterlockedExchange(
                (PLONG) &pUriCacheEntry->BinaryIndexWritten, 
                0
                );
        }        
        
        //
        // reset timer so we can track how long an entry is on the list
        //
        pUriCacheEntry->ScavengerTicks = 0;

        ++ pUriFilterContext->ZombieCount;

        // now remove it from the hash table
        return ULC_DELETE;
    }

    // do not remove pUriCacheEntry from table
    return ULC_NO_ACTION;
} // UlpZombifyEntry



/***************************************************************************++

Routine Description:

    Adds a list of entries to the global zombie list, then calls
    UlpClearZombieList. This cleans up the list of deferred deletions
    built up by UlpFilteredFlushUriCache.
    Runs at passive level.

Arguments:

    pWorkItem - workitem within a URI_FILTER_CONTEXT containing private list

--***************************************************************************/
VOID
UlpZombifyList(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PURI_FILTER_CONTEXT pUriFilterContext;
    PLIST_ENTRY pContextHead;
    PLIST_ENTRY pContextTail;
    PLIST_ENTRY pZombieHead;

    PAGED_CODE();

    ASSERT(NULL != pWorkItem);

    pUriFilterContext
        = CONTAINING_RECORD(pWorkItem, URI_FILTER_CONTEXT, WorkItem);

    ASSERT(URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature);

    UlTrace(URI_CACHE, (
        "http!UlpZombifyList, ctxt = %p\n",
        pUriFilterContext
        ));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->UriZombieResource, TRUE);

    //
    // Splice the entire private list into the head of the Zombie list
    //

    ASSERT(! IsListEmpty(&pUriFilterContext->ZombieListHead));

    pContextHead = pUriFilterContext->ZombieListHead.Flink;
    pContextTail = pUriFilterContext->ZombieListHead.Blink;
    pZombieHead  = g_ZombieListHead.Flink;

    pContextTail->Flink = pZombieHead;
    pZombieHead->Blink  = pContextTail;

    g_ZombieListHead.Flink = pContextHead;
    pContextHead->Blink    = &g_ZombieListHead;

    // Update stats
    g_UriCacheStats.ZombieCount += pUriFilterContext->ZombieCount;
    g_UriCacheStats.ZombieCountMax = MAX(g_UriCacheStats.ZombieCount,
                                         g_UriCacheStats.ZombieCountMax);

#if DBG
    {
    PLIST_ENTRY pEntry;
    ULONG       ZombieCount;

    // Walk forwards through the zombie list and check that it contains
    // exactly as many valid zombied UriCacheEntries as we expect.
    for (pEntry =  g_ZombieListHead.Flink, ZombieCount = 0;
         pEntry != &g_ZombieListHead;
         pEntry =  pEntry->Flink, ++ZombieCount)
    {
        PUL_URI_CACHE_ENTRY pUriCacheEntry
            = CONTAINING_RECORD(pEntry, UL_URI_CACHE_ENTRY, ZombieListEntry);

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(pUriCacheEntry->Zombie);
        ASSERT(pUriCacheEntry->ZombieAddReffed
               ?  pUriCacheEntry->ScavengerTicks == 0
               :  pUriCacheEntry->ScavengerTicks > 0);
        ASSERT(ZombieCount < g_UriCacheStats.ZombieCount);
    }

    ASSERT(ZombieCount == g_UriCacheStats.ZombieCount);

    // And backwards too, like Ginger Rogers
    for (pEntry =  g_ZombieListHead.Blink, ZombieCount = 0;
         pEntry != &g_ZombieListHead;
         pEntry =  pEntry->Blink, ++ZombieCount)
    {
        PUL_URI_CACHE_ENTRY pUriCacheEntry
            = CONTAINING_RECORD(pEntry, UL_URI_CACHE_ENTRY, ZombieListEntry);

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(pUriCacheEntry->Zombie);
        ASSERT(pUriCacheEntry->ZombieAddReffed
               ?  pUriCacheEntry->ScavengerTicks == 0
               :  pUriCacheEntry->ScavengerTicks > 0);
        ASSERT(ZombieCount < g_UriCacheStats.ZombieCount);
    }

    ASSERT(ZombieCount == g_UriCacheStats.ZombieCount);
    }
#endif // DBG

    UlReleaseResource(&g_pUlNonpagedData->UriZombieResource);

    UL_FREE_POOL_WITH_SIG(pUriFilterContext, URI_FILTER_CONTEXT_POOL_TAG);

    // Now purge those entries, if there are no outstanding references
    UlpClearZombieList();

} // UlpZombifyList


/***************************************************************************++

Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    The function should conclude with a call to UlpZombifyEntry, passing
    in whether or not the item should be deleted. See sample usage
    elsewhere in this file. The deletion of the entries is deferred

Arguments:

    pFilterRoutine - A pointer to the filter function
    pCallerContext - a parameter to the filter function

--***************************************************************************/
VOID
UlpFilteredFlushUriCache(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext,
    IN PWSTR            pUri,
    IN ULONG            Length
    )
{
    UlpFilteredFlushUriCacheWorker( pFilterRoutine,
                                    pCallerContext,
                                    pUri,
                                    Length,
                                    FALSE );
} // UlpFilteredFlushUriCache

/***************************************************************************++

Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    The function should conclude with a call to UlpZombifyEntry, passing
    in whether or not the item should be deleted. See sample usage
    elsewhere in this file. The deletion of the entries is completed inline

Arguments:

    pFilterRoutine - A pointer to the filter function
    pCallerContext - a parameter to the filter function

--***************************************************************************/
VOID
UlpFilteredFlushUriCacheInline(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext,
    IN PWSTR            pUri,
    IN ULONG            Length
    )
{
    UlpFilteredFlushUriCacheWorker( pFilterRoutine,
                                    pCallerContext,
                                    pUri,
                                    Length,
                                    TRUE );
} // UlpFilteredFlushUriCacheInline


/***************************************************************************++

Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    The function should conclude with a call to UlpZombifyEntry, passing
    in whether or not the item should be deleted. See sample usage
    elsewhere in this file.

Arguments:

    pFilterRoutine - A pointer to the filter function
    pCallerContext - a parameter to the filter function
    InlineFlush - If FALSE, queue a work item to delete entries,
                  If TRUE, delete them now

--***************************************************************************/
VOID
UlpFilteredFlushUriCacheWorker(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext,
    IN PWSTR            pUri,
    IN ULONG            Length,
    IN BOOLEAN          InlineFlush
    )
{
    PURI_FILTER_CONTEXT pUriFilterContext;
    ULONG               ZombieCount = 0;

    //
    // sanity check
    //

    PAGED_CODE();
    ASSERT( NULL != pFilterRoutine );

    //
    // Perfmon counters
    //

    UlIncCounter(HttpGlobalCounterUriCacheFlushes);

    //
    // Short-circuit if the hashtable is empty. Traversing the entire
    // hashtable is expensive.
    //
    
    if (0 == g_UriCacheStats.UriCount)
    {
        UlTrace(URI_CACHE,
                ("Http!UlpFilteredFlushUriCache(filt=%p, caller ctxt=%p): "
                 "Not flushing because UriCount==0.\n",
                 pFilterRoutine, pCallerContext
                 ));

        return;
    }
    
    pUriFilterContext = UL_ALLOCATE_STRUCT(
                            NonPagedPool,
                            URI_FILTER_CONTEXT,
                            URI_FILTER_CONTEXT_POOL_TAG);

    if (pUriFilterContext == NULL)
        return;

    UlInitializeWorkItem(&pUriFilterContext->WorkItem);
    pUriFilterContext->Signature = URI_FILTER_CONTEXT_POOL_TAG;
    pUriFilterContext->ZombieCount = 0;
    InitializeListHead(&pUriFilterContext->ZombieListHead);
    pUriFilterContext->pCallerContext = pCallerContext;
    KeQuerySystemTime(&pUriFilterContext->Now);

    //
    // Store the Uri Info for the recursive Uri Flushes.
    //
    
    if (pUri && Length)
    {    
        pUriFilterContext->UriKey.Hash   = 0;
        pUriFilterContext->UriKey.Length = Length;
        pUriFilterContext->UriKey.pUri   = pUri;
        pUriFilterContext->UriKey.pPath  = NULL;
    }
    else
    {
        pUriFilterContext->UriKey.Hash   = 0;
        pUriFilterContext->UriKey.Length = 0;
        pUriFilterContext->UriKey.pUri   = NULL;
        pUriFilterContext->UriKey.pPath  = NULL;
    }
    

    UlTrace(URI_CACHE, (
                "Http!UlpFilteredFlushUriCache("
                "filt=%p, filter ctxt=%p, caller ctxt=%p)\n",
                pFilterRoutine, pUriFilterContext, pCallerContext
                ));

    if (IS_VALID_HASHTABLE(&g_UriCacheTable))
    {
        ZombieCount = UlFilterFlushHashTable(
                            &g_UriCacheTable,
                            pFilterRoutine,
                            pUriFilterContext
                            );
        
        ASSERT(ZombieCount == pUriFilterContext->ZombieCount);

        if (0 != ZombieCount)
        {
            UlAddCounter(HttpGlobalCounterTotalFlushedUris, ZombieCount);

            if( InlineFlush ) {
                UL_CALL_PASSIVE(
                    &pUriFilterContext->WorkItem,
                    UlpZombifyList
                    );
            } else {
                UL_QUEUE_WORK_ITEM(
                    &pUriFilterContext->WorkItem,
                    UlpZombifyList
                    );
            }

        }
        else
        {
            UL_FREE_POOL_WITH_SIG(pUriFilterContext,
                                  URI_FILTER_CONTEXT_POOL_TAG);
        }

        UlTrace(URI_CACHE, (
                    "Http!UlpFilteredFlushUriCache(filt=%p, caller ctxt=%p)"
                    " Zombified: %d\n",
                    pFilterRoutine,
                    pCallerContext,
                    ZombieCount
                    ));
    }

} // UlpFilteredFlushUriCacheWorker


/***************************************************************************++

Routine Description:

    Scans the zombie list for entries whose refcount has dropped to "zero".
    (The calling routine is generally expected to have added a reference
    (and set the ZombieAddReffed field within the entries), so that
    otherwise unreferenced entries will actually have a refcount of one. It
    works this way because we don't want the scavenger directly triggering
    calls to UlpDestroyUriCacheEntry)

--***************************************************************************/
VOID
UlpClearZombieList(
    VOID
    )
{
    ULONG               ZombiesFreed = 0;
    ULONG               ZombiesSpared = 0;
    PLIST_ENTRY         pCurrent;

    //
    // sanity check
    //
    PAGED_CODE();

    UlAcquireResourceExclusive(&g_pUlNonpagedData->UriZombieResource, TRUE);

    pCurrent = g_ZombieListHead.Flink;

    while (pCurrent != &g_ZombieListHead)
    {
        PUL_URI_CACHE_ENTRY pUriCacheEntry
            = CONTAINING_RECORD(pCurrent, UL_URI_CACHE_ENTRY, ZombieListEntry);

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(pUriCacheEntry->Zombie);

        //
        // get next entry now, because we might destroy this one
        //
        pCurrent = pCurrent->Flink;

        //
        // ReferenceCount is modified with interlocked ops, but in
        // this case we know the ReferenceCount can't go up on
        // a Zombie, and if an entry hits one just after we look
        // at it, we'll just get it on the next pass
        //
        if (pUriCacheEntry->ZombieAddReffed)
        {
            BOOLEAN LastRef = (BOOLEAN) (pUriCacheEntry->ReferenceCount == 1);

            if (LastRef)
            {
                RemoveEntryList(&pUriCacheEntry->ZombieListEntry);
                pUriCacheEntry->ZombieListEntry.Flink = NULL;
                ++ ZombiesFreed;

                ASSERT(g_UriCacheStats.ZombieCount > 0);
                -- g_UriCacheStats.ZombieCount;
            }
            else
            {
                // track age of zombie
                ++ pUriCacheEntry->ScavengerTicks;
                ++ ZombiesSpared;
            }

            pUriCacheEntry->ZombieAddReffed = FALSE;

            DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, UNZOMBIFY);
            // NOTE: ref can go to zero, so ZombiesSpared may be wrong.
        }
        else
        {
            ASSERT(pUriCacheEntry->ScavengerTicks > 0);

            // track age of zombie
            ++ pUriCacheEntry->ScavengerTicks;
            ++ ZombiesSpared;

            if (pUriCacheEntry->ScavengerTicks > ZOMBIE_AGE_THRESHOLD)
            {
                UlTrace(URI_CACHE, (
                            "Http!UlpClearZombieList()\n"
                            "    WARNING: %p '%ls' (refs = %d) "
                            "has been a zombie for %d ticks!\n",
                            pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
                            pUriCacheEntry->ReferenceCount,
                            pUriCacheEntry->ScavengerTicks
                            ));
            }
        }
    }

    ASSERT((g_UriCacheStats.ZombieCount == 0)
                == IsListEmpty(&g_ZombieListHead));

    UlReleaseResource(&g_pUlNonpagedData->UriZombieResource);

    UlTrace(URI_CACHE,
            ("Http!UlpClearZombieList(): Freed = %d, Remaining = %d.\n\n",
             ZombiesFreed,
             ZombiesSpared
             ));
} // UlpClearZombieList


/***************************************************************************++

Routine Description:

    Frees a URI entry to the pool. Removes references to other objects.

Arguments:

    pTracker - Supplies the UL_READ_TRACKER to manipulate.

--***************************************************************************/
VOID
UlpDestroyUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    NTSTATUS Status;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    // CODEWORK: real cleanup will need to release
    // config & process references.

    ASSERT(0 == pUriCacheEntry->ReferenceCount);

    UlTrace(URI_CACHE,
            ("Http!UlpDestroyUriCacheEntry: Entry %p, '%ls', Refs=%d\n",
             pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
             pUriCacheEntry->ReferenceCount
             ));

    //
    // Release the UL_URL_CONFIG_GROUP_INFO block
    //

    if (IS_RESPONSE_CACHE_ENTRY(pUriCacheEntry))
    {
        Status = UlConfigGroupInfoRelease(&pUriCacheEntry->ConfigInfo);
        ASSERT(NT_SUCCESS(Status));
    }
    else
    {
        ASSERT(IS_FRAGMENT_CACHE_ENTRY(pUriCacheEntry));
        ASSERT(!IS_VALID_URL_CONFIG_GROUP_INFO(&pUriCacheEntry->ConfigInfo));
    }

    //
    // Remove from g_ZombieListHead if neccessary
    //

    if (pUriCacheEntry->ZombieListEntry.Flink != NULL)
    {
        ASSERT(pUriCacheEntry->Zombie);
        ASSERT(! pUriCacheEntry->ZombieAddReffed);

        UlAcquireResourceExclusive(
            &g_pUlNonpagedData->UriZombieResource,
            TRUE);

        if (pUriCacheEntry->ZombieListEntry.Flink != NULL)
        {
            RemoveEntryList(&pUriCacheEntry->ZombieListEntry);

            ASSERT(g_UriCacheStats.ZombieCount > 0);
            -- g_UriCacheStats.ZombieCount;
        }

        UlReleaseResource(&g_pUlNonpagedData->UriZombieResource);
    }

    UlFreeCacheEntry( pUriCacheEntry );
} // UlpDestroyUriCacheEntry


/***************************************************************************++

Routine Description:

    Looks through the cache for expired entries to put on the zombie list,
    and then empties out the list. Increments ScavengerTicks of each entry

Arguments:

    Age - #Scavenger calls since last periodic cleanup

--***************************************************************************/
VOID
UlPeriodicCacheScavenger(
    ULONG Age
    )
{
    PAGED_CODE();
    UlpFilteredFlushUriCacheInline(UlpFlushFilterPeriodicScavenger,
                                   &Age, NULL, 0);

} // UlPeriodicScavenger

/***************************************************************************++

Routine Description:

    A filter for UlPeriodicCacheScavenger. Called by UlpFilteredFlushUriCache.
    Increments pUriCacheEntry->ScavengerTicks

Arguments:

    pUriCacheEntry - the entry to check
    pContext - Has pointer to the max age in the pCallerContext field

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterPeriodicScavenger(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;
    BOOLEAN ToZombify;
    ULONG Age;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext != NULL );

    Age = *((PULONG)pUriFilterContext->pCallerContext);

    ToZombify = (BOOLEAN) (pUriCacheEntry->ScavengerTicks > Age);

    pUriCacheEntry->ScavengerTicks = 1; // reset to 0 on cache hit

    //
    // Check for expiration time as well
    //
    if (!ToZombify && 
        HttpCachePolicyTimeToLive == pUriCacheEntry->CachePolicy.Policy )
    {
        ASSERT( 0 != pUriCacheEntry->ExpirationTime.QuadPart );
        
        ToZombify = 
           (BOOLEAN) (pUriFilterContext->Now.QuadPart > 
                      pUriCacheEntry->ExpirationTime.QuadPart);
    }
    
    return UlpZombifyEntry(
        ToZombify,
        FALSE,
        pUriCacheEntry,
        pUriFilterContext
        );

} // UlpFlushFilterPeriodicScavenger


/***************************************************************************++

Routine Description:

    Purges entries from the cache until a specified amount of memory is
    reclaimed

Arguments:

    Blocks - Number of 8-byte blocks to Reclaim
    Age    - # Scavenger calls since past periodic cleanup
--***************************************************************************/
VOID
UlTrimCache(
    IN ULONG_PTR Pages,
    IN ULONG Age
    )
{
    LONG_PTR PagesTarget;
    UL_CACHE_TRIM_FILTER_CONTEXT FilterContext;

    ASSERT((LONG)Pages > 0);
    ASSERT((LONG)Age > 0);

    PagesTarget = UlGetHashTablePages() - Pages;

    if(PagesTarget < 0) {
        PagesTarget = 0;
    }

    FilterContext.Pages = Pages;
    FilterContext.Age = Age;

    while((FilterContext.Pages > 0) && (FilterContext.Age >= 0)
          && ((ULONG)PagesTarget < UlGetHashTablePages())) {
        UlTraceVerbose(URI_CACHE, ("UlTrimCache: Age %d Target %d\n", FilterContext.Age, FilterContext.Pages));
        UlpFilteredFlushUriCacheInline( UlpFlushFilterTrimCache, &FilterContext, NULL, 0 );
        FilterContext.Age--;
    }

    UlTraceVerbose(URI_CACHE, ("UlTrimCache: Finished: Age %d Pages %d\n", FilterContext.Age, FilterContext.Pages));

    UlpFilteredFlushUriCacheInline( UlpFlushFilterIncScavengerTicks, NULL, NULL, 0 );

} // UlTrimCache


/***************************************************************************++

Routine Description:

    A filter for UlTrimCache. Called by UlpFilteredFlushUriCache.

Arguments:

    pUriCacheEntry - the entry to check
    pContext - Has a pointer to pCallerContext
                   pCallerContext[0] = Blocks to trim
                   pCallerContext[1] = Current Age

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterTrimCache(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;
    ULONG MinimumAge;
    ULONG_PTR PagesReclaimed;
    PUL_CACHE_TRIM_FILTER_CONTEXT FilterContext;
    UL_CACHE_PREDICATE ToZombify;

    // Sanity check
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext != NULL );
 
    FilterContext = (PUL_CACHE_TRIM_FILTER_CONTEXT) pUriFilterContext->pCallerContext;

    if(FilterContext->Pages <= 0) {
        return ULC_ABORT;
    }

    ASSERT( FilterContext->Pages > 0 );
    ASSERT( (LONG)FilterContext->Age >= 0 );

    MinimumAge = FilterContext->Age;

    ToZombify =  UlpZombifyEntry(
        (BOOLEAN) (pUriCacheEntry->ScavengerTicks >= MinimumAge),
        FALSE,
        pUriCacheEntry,
        pUriFilterContext
        );

    if(ToZombify == ULC_DELETE) {
        PagesReclaimed = pUriCacheEntry->NumPages;
        FilterContext->Pages -= PagesReclaimed;
    }

    return ToZombify;

} // UlpFlushFilterTrimCache


/***************************************************************************++

Routine Description:

    Increment Scavenger Ticks

Arguments:

    pUriCacheEntry - the entry to check
    pContext - ignored

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterIncScavengerTicks(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{

    PURI_FILTER_CONTEXT pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;

    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext == NULL );

    pUriCacheEntry->ScavengerTicks++;

    return UlpZombifyEntry(
        FALSE,
        FALSE,
        pUriCacheEntry,
        pUriFilterContext
        );
} // UlpFlushFilterIncScavengerTicks

/***************************************************************************++

Routine Description:

    Looks through the cache for centralized logged entries. Mark them all 
    NOT logged.

    This funtion is normally called when a binary log file is recycled
    or reconfigured.

Arguments:

    pContext - When we enable multiple binary logs, we must only mess with
               those cache entries logged to this specific binary log file
               until then discarted.

--***************************************************************************/

VOID
UlClearCentralizedLogged(
    IN PVOID pContext
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pContext);

    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    if (g_UriCacheConfig.EnableCache)
    {
        UlTrace2Either(BINARY_LOGGING, URI_CACHE,(
                "Http!UlClearCentralizedLogged()\n"));

        UlpFilteredFlushUriCache(
            UlpFlushFilterClearCentralizedLogged, 
            NULL, 
            NULL, 
            0
            );
    }

} // UlClearCentralizedLogged

/***************************************************************************++

Routine Description:

    Basically a fake filter, which will always returns FALSE. But it updates
    the CentralizedLogged flag on the entry.

Arguments:

    pUriCacheEntry - the entry to check
    pContext       - ignored

--***************************************************************************/

UL_CACHE_PREDICATE
UlpFlushFilterClearCentralizedLogged(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
#if DBG
    PURI_FILTER_CONTEXT pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;
#else
    UNREFERENCED_PARAMETER(pContext);
#endif

    //
    // Sanity check
    //
    
    PAGED_CODE();
    
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext == NULL );

    InterlockedExchange((PLONG) &pUriCacheEntry->BinaryIndexWritten, 0);

    //
    // Updated the flag. Just bail out.
    //

    return ULC_NO_ACTION;

} // UlpFlushFilterClearCentralizedLogged


/***************************************************************************++

Routine Description:

    Determine if the Translate header is present AND has a value of 'F' or 'f'.

Arguments:

    pRequest - Supplies the request to query.

Return Value:

    BOOLEAN - TRUE if "Translate: F", FALSE otherwise

--***************************************************************************/
BOOLEAN
UlpQueryTranslateHeader(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    BOOLEAN ret = FALSE;

    if ( pRequest->HeaderValid[HttpHeaderTranslate] )
    {
        PUCHAR pValue = pRequest->Headers[HttpHeaderTranslate].pHeader;

        ASSERT(NULL != pValue);

        if (('f' == pValue[0] || 'F' == pValue[0]) && '\0' == pValue[1])
        {
            ASSERT(pRequest->Headers[HttpHeaderTranslate].HeaderLength == 1);
            ret = TRUE;
        }
    }

    return ret;

} // UlpQueryTranslateHeader


/***************************************************************************++

Routine Description:

    Determine if the Expect header is present AND has a value 
    of EXACTLY "100-continue".

Arguments:

    pRequest - Supplies the request to check.

Return Value:

    BOOLEAN - TRUE if "Expect: 100-continue" or not present, FALSE otherwise

--***************************************************************************/
BOOLEAN
UlpQueryExpectHeader(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    BOOLEAN ret = TRUE;

    if ( pRequest->HeaderValid[HttpHeaderExpect] )
    {
        PCSTR pValue = (PCSTR) pRequest->Headers[HttpHeaderExpect].pHeader;

        ASSERT(NULL != pValue);

        if ((strlen(pValue) != HTTP_CONTINUE_LENGTH) ||
            (0 != strncmp(pValue, HTTP_100_CONTINUE, HTTP_CONTINUE_LENGTH)))
        {
            ret = FALSE;
        }
    }

    return ret;
} // UlQueryExpectHeader


/***************************************************************************++

Routine Description:

    Add a reference on a cache entry

Arguments:

    pUriCacheEntry - the entry to addref

--***************************************************************************/
LONG
UlAddRefUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG RefCount;

    UNREFERENCED_PARAMETER(Action);

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    RefCount = InterlockedIncrement(&pUriCacheEntry->ReferenceCount);

    WRITE_REF_TRACE_LOG(
        g_pUriTraceLog,
        Action,
        RefCount,
        pUriCacheEntry,
        pFileName,
        LineNumber
        );

    UlTrace(URI_CACHE, (
        "Http!UlAddRefUriCacheEntry: (%p, '%ls', refcount=%d)\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri, RefCount
        ));

    ASSERT(RefCount > 0);

    return RefCount;

} // UlAddRefUriCacheEntry



/***************************************************************************++

Routine Description:

    Release a reference on a cache entry

Arguments:

    pUriCacheEntry - the entry to release

--***************************************************************************/
LONG
UlReleaseUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG RefCount;

    UNREFERENCED_PARAMETER(Action);

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    RefCount = InterlockedDecrement(&pUriCacheEntry->ReferenceCount);

    WRITE_REF_TRACE_LOG(
        g_pUriTraceLog,
        Action,
        RefCount,
        pUriCacheEntry,
        pFileName,
        LineNumber
        );

    UlTrace(URI_CACHE, (
        "Http!UlReleaseUriCacheEntry: (%p, '%ls', refcount=%d)\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri, RefCount
        ));

    ASSERT(RefCount >= 0);

    if (RefCount == 0)
    {
        if (pUriCacheEntry->Cached)
            UlpRemoveEntryStats(pUriCacheEntry);

        UlpDestroyUriCacheEntry(pUriCacheEntry);
    }

    return RefCount;

} // UlReleaseUriCacheEntry



/***************************************************************************++

Routine Description:

    UL_URI_CACHE_ENTRY pseudo-constructor. Primarily used for
    AddRef and tracelogging.

Arguments:

    pUriCacheEntry - the entry to initialize
    Hash - Hash code of pUrl
    Length - Length (in bytes) of pUrl
    pUrl - Unicode URL to copy    
    pAbsPath - Points to the AbsPath of the Url.
    
    pRoutingToken - Optional
    RoutingTokenLength - Optional (in bytes)

--***************************************************************************/
VOID
UlInitCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    ULONG               Hash,
    ULONG               Length,
    PCWSTR              pUrl,
    PCWSTR              pAbsPath,
    PCWSTR              pRoutingToken,
    USHORT              RoutingTokenLength
    )
{
    pUriCacheEntry->Signature = UL_URI_CACHE_ENTRY_POOL_TAG;
    pUriCacheEntry->ReferenceCount = 0;
    pUriCacheEntry->HitCount = 1;
    pUriCacheEntry->Zombie = FALSE;
    pUriCacheEntry->ZombieAddReffed = FALSE;
    pUriCacheEntry->ZombieListEntry.Flink = NULL;
    pUriCacheEntry->ZombieListEntry.Blink = NULL;
    pUriCacheEntry->Cached = FALSE;
    pUriCacheEntry->ScavengerTicks = 0;
    pUriCacheEntry->UriKey.Hash = Hash;
    pUriCacheEntry->UriKey.Length = Length;

    pUriCacheEntry->UriKey.pUri = (PWSTR) ((PCHAR)pUriCacheEntry + 
        ALIGN_UP(sizeof(UL_URI_CACHE_ENTRY), PVOID));

    if (pRoutingToken)
    {
        PWSTR  pUri = pUriCacheEntry->UriKey.pUri;
            
        ASSERT(wcslen(pRoutingToken) * sizeof(WCHAR) == RoutingTokenLength);

        pUriCacheEntry->UriKey.Length += RoutingTokenLength;

        RtlCopyMemory(
            pUri,
            pRoutingToken,
            RoutingTokenLength
            );

        RtlCopyMemory(
           &pUri[RoutingTokenLength/sizeof(WCHAR)],
            pUrl,
            Length + sizeof(WCHAR)
            );

        ASSERT(wcslen(pUri) * sizeof(WCHAR) == pUriCacheEntry->UriKey.Length );
            
        pUriCacheEntry->UriKey.pPath = 
            pUri + (RoutingTokenLength /   sizeof(WCHAR));

        UlTrace(URI_CACHE, (
            "Http!UlInitCacheEntry Extended (%p = '%ls' + '%ls')\n",
            pUriCacheEntry, pRoutingToken, pUrl
            ));        
    }
    else
    {
        
        RtlCopyMemory(
            pUriCacheEntry->UriKey.pUri,
            pUrl,
            pUriCacheEntry->UriKey.Length + sizeof(WCHAR)
            );

        if (pAbsPath)
        {
            ASSERT( pAbsPath >= pUrl );
            ASSERT( DIFF(pAbsPath - pUrl) <= Length );

            pUriCacheEntry->UriKey.pPath = 
                pUriCacheEntry->UriKey.pUri + DIFF(pAbsPath - pUrl);
        }
        else
        {
            // Possibly a fragment cache entry.
            pUriCacheEntry->UriKey.pPath = NULL;            
        }        
        
        UlTrace(URI_CACHE, (
            "Http!UlInitCacheEntry (%p = '%ls')\n",
            pUriCacheEntry, pUriCacheEntry->UriKey.pUri
            ));        
    }    

    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CREATE);


} // UlInitCacheEntry


/***************************************************************************++

Routine Description:

    Adds a fragment cache entry to the response cache database.

Arguments:

    pProcess - process that is adding the fragment cache entry
    pFragmentName - key of the fragment cache entry
    pDataChunk - specifies the data chunk to be put into the cache entry
    pCachePolicy - specifies the policy of the new fragment cache entry

Return Value:

    NTSTATUS

--***************************************************************************/
NTSTATUS
UlAddFragmentToCache(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUNICODE_STRING pFragmentName,
    IN PHTTP_DATA_CHUNK pDataChunk,
    IN PHTTP_CACHE_POLICY pCachePolicy,
    IN KPROCESSOR_MODE RequestorMode
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    PWSTR pAppPoolName;
    PWSTR pEndName;
    ULONG AppPoolNameLength;
    PUL_URI_CACHE_ENTRY pCacheEntry;
    ULONGLONG Length;
    PFAST_IO_DISPATCH pFastIoDispatch;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    FILE_STANDARD_INFORMATION FileInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    PUCHAR pReadBuffer;
    PLARGE_INTEGER pOffset;
    HTTP_DATA_CHUNK LocalDataChunk;
    NTSTATUS Status;
    UNICODE_STRING FragmentName;
    UL_URL_CONFIG_GROUP_INFO UrlInfo;
    PWSTR pSanitizedUrl;
    HTTP_PARSED_URL ParsedUrl;
    HTTP_BYTE_RANGE ByteRange = {0,0};

    //
    // Validate if the data chunk can be put into the cache.
    //

    if (FALSE == g_UriCacheConfig.EnableCache)
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Use a local copy of DataChunk onwards to ensure fields inside won't
    // get changed.
    //

    LocalDataChunk = *pDataChunk;

    if (HttpDataChunkFromMemory != LocalDataChunk.DataChunkType &&
        HttpDataChunkFromFileHandle != LocalDataChunk.DataChunkType)
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    pCacheEntry = NULL;
    pFileObject = NULL;
    pReadBuffer = NULL;
    pSanitizedUrl = NULL;

    UlInitializeUrlInfo(&UrlInfo);

    //
    // Validate the AppPool name of the process matches the first portion
    // of the fragment name before "/".
    //

    __try
    {
        Status = 
            UlProbeAndCaptureUnicodeString(
                pFragmentName,
                RequestorMode,
                &FragmentName,
                0
                );
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
                            
        //
        // The fragment name convention is different for a transient app
        // (where AppPool name is "") and a normal WAS-type of app.  The
        // former starts with a URL that the AppPool listens, the latter
        // starts using the AppPool name itself.  The name validation has
        // to be done differently as well.
        //
        //

        pAppPool = pProcess->pAppPool;

        if (pAppPool->NameLength)
        {
            pAppPoolName = FragmentName.Buffer;
            pEndName = wcschr(pAppPoolName, L'/');
            if (!pEndName)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            AppPoolNameLength = DIFF((PUCHAR)pEndName - (PUCHAR)pAppPoolName);
            if (pAppPool->NameLength != AppPoolNameLength ||
                _wcsnicmp(
                    pAppPool->pName,
                    pAppPoolName,
                    AppPoolNameLength / sizeof(WCHAR)
                    ))
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }
        }
        else
        {
            //
            // Do a reverse-lookup to find out the AppPool that listens on the
            // URL/FragmentName passed in. Need to sanitize the URL because
            // of IP based URLs get internally expanded when stored in CG.
            // For instance, when stored, http://127.0.0.1:80/Test/ becomes
            // http://127.0.0.1:80:127.0.0.1/Test/.
            //

            Status = UlSanitizeUrl(
                        FragmentName.Buffer,
                        FragmentName.Length / sizeof(WCHAR),
                        FALSE,
                        &pSanitizedUrl,
                        &ParsedUrl
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            ASSERT(pSanitizedUrl);

            Status = UlGetConfigGroupInfoForUrl(
                        pSanitizedUrl,
                        NULL,
                        &UrlInfo
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            if (UrlInfo.pAppPool != pAppPool)
            {
                Status = STATUS_INVALID_ID_AUTHORITY;
                goto end;
            }
        }

        if (HttpDataChunkFromMemory == LocalDataChunk.DataChunkType)
        {
            //
            // Cache a FromMemory data chunk.  ContentLength is BufferLength.
            //

            Length = LocalDataChunk.FromMemory.BufferLength;
        }
        else
        {
            //
            // Cache a FromFileHandle data chunk.  ContentLength is the size
            // of the file.
            //

            Status = ObReferenceObjectByHandle(
                        LocalDataChunk.FromFileHandle.FileHandle,
                        FILE_READ_ACCESS,
                        *IoFileObjectType,
                        UserMode,
                        (PVOID *) &pFileObject,
                        NULL
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            //
            // Non-cached reads are not supported since they require
            // us to align both file offset and length.
            //

            if (!(pFileObject->Flags & FO_CACHE_SUPPORTED))
            {
                Status = STATUS_NOT_SUPPORTED;
                goto end;
            }

            pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
            pFastIoDispatch = pDeviceObject->DriverObject->FastIoDispatch;

            if (!pFastIoDispatch ||
                pFastIoDispatch->SizeOfFastIoDispatch <=
                 FIELD_OFFSET(FAST_IO_DISPATCH, FastIoQueryStandardInfo) ||
                !pFastIoDispatch->FastIoQueryStandardInfo ||
                !pFastIoDispatch->FastIoQueryStandardInfo(
                                    pFileObject,
                                    TRUE,
                                    &FileInfo,
                                    &IoStatusBlock,
                                    pDeviceObject
                                    ))
            {
                Status = ZwQueryInformationFile(
                            LocalDataChunk.FromFileHandle.FileHandle,
                            &IoStatusBlock,
                            &FileInfo,
                            sizeof(FILE_STANDARD_INFORMATION),
                            FileStandardInformation
                            );

                if (!NT_SUCCESS(Status))
                {
                    goto end;
                }
            }

            Status = UlSanitizeFileByteRange(
                        &LocalDataChunk.FromFileHandle.ByteRange,
                        &ByteRange,
                        FileInfo.EndOfFile.QuadPart
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            Length = ByteRange.Length.QuadPart;
        }

        //
        // It doesn't make sense to add a zero-length fragment.
        //

        if (!Length)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Enforce the MaxUriBytes limit.
        //

        if (Length > g_UriCacheConfig.MaxUriBytes)
        {
            Status = STATUS_NOT_SUPPORTED;
            goto end;
        }

        //
        // Build a fragment cache entry.
        //

        Status = UlpCreateFragmentCacheEntry(
                    pProcess,
                    FragmentName.Buffer,
                    FragmentName.Length,
                    (ULONG) Length,
                    pCachePolicy,
                    &pCacheEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        ASSERT(pCacheEntry);

        //
        // Fill up the content of the fragment cache entry.
        //

        if (HttpDataChunkFromMemory == LocalDataChunk.DataChunkType)
        {
            UlProbeForRead(
                LocalDataChunk.FromMemory.pBuffer,
                LocalDataChunk.FromMemory.BufferLength,
                sizeof(PVOID),
                RequestorMode
                );

            if (FALSE == UlCacheEntrySetData(
                            pCacheEntry,
                            (PUCHAR) LocalDataChunk.FromMemory.pBuffer,
                            (ULONG) Length,
                            0
                            ))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto end;
            }
        }
        else
        {
            pReadBuffer = (PUCHAR) MmMapLockedPagesSpecifyCache(
                                        pCacheEntry->pMdl,
                                        KernelMode,
                                        MmCached,
                                        NULL,
                                        FALSE,
                                        LowPagePriority
                                        );

            if (pReadBuffer)
            {
                pOffset = (PLARGE_INTEGER)
                    &LocalDataChunk.FromFileHandle.ByteRange.StartingOffset;

                //
                // CODEWORK: support async read for file handles opened as
                // non-buffered.
                //

                Status = ZwReadFile(
                            LocalDataChunk.FromFileHandle.FileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            pReadBuffer,
                            (ULONG) Length,
                            pOffset,
                            NULL
                            );

                MmUnmapLockedPages(pReadBuffer, pCacheEntry->pMdl);
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
        goto end;
    }

    //
    // Add the fragment cache entry.
    //

    Status = UlAddCacheEntry(pCacheEntry);

    //
    // Release the reference count of the cache entry because
    // UlAddCacheEntry adds an extra reference in the success case.
    //

    DEREFERENCE_URI_CACHE_ENTRY(pCacheEntry, CREATE);

    //
    // Reset pCacheEntry so we won't double-free if UlAddCacheEntry fails.
    //

    pCacheEntry = NULL;

end:

    UlFreeCapturedUnicodeString(&FragmentName);
    UlConfigGroupInfoRelease(&UrlInfo);
        
    if (pFileObject)
    {
        ObDereferenceObject(pFileObject);
    }

    if (!NT_SUCCESS(Status))
    {
        if (pCacheEntry)
        {
            UlFreeCacheEntry(pCacheEntry);
        }
    }

    if (pSanitizedUrl)
    {
        UL_FREE_POOL(pSanitizedUrl, URL_POOL_TAG);
    }

    return Status;

} // UlAddFragmentToCache


/***************************************************************************++

Routine Description:

    Creates a fragment cache entry.

Arguments:

    pProcess - process that is adding the fragment cache entry
    pFragmentName - key of the fragment cache entry
    FragmentNameLength - length of the fragment name
    pBuffer - data to be associated with the fragment cache entry
    BufferLength - length of the data
    pCachePolicy - specifies the policy of the new fragment cache entry

Return Value:

    NTSTATUS

--***************************************************************************/
NTSTATUS
UlpCreateFragmentCacheEntry(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PWSTR pFragmentName,
    IN ULONG FragmentNameLength,
    IN ULONG Length,
    IN PHTTP_CACHE_POLICY pCachePolicy,
    OUT PUL_URI_CACHE_ENTRY *ppCacheEntry
    )
{
    PUL_URI_CACHE_ENTRY pCacheEntry;
    ULONG Hash;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pCachePolicy);
    ASSERT(ppCacheEntry);

    if ( HttpCachePolicyTimeToLive == pCachePolicy->Policy 
        && 0 == pCachePolicy->SecondsToLive )
    {
        // A TTL of 0 seconds doesn't make sense.  Bail out.
        *ppCacheEntry = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    pCacheEntry = UlAllocateCacheEntry(
                        FragmentNameLength + sizeof(WCHAR),
                        Length
                  );

    if (pCacheEntry)
    {
        __try
        {
            //
            // Initialize the cache entry.
            //

            Hash = HashRandomizeBits(HashStringNoCaseW(pFragmentName, 0));

            UlInitCacheEntry(
                pCacheEntry,
                Hash,
                FragmentNameLength,
                pFragmentName,
                NULL,
                NULL,
                0
                );

            pCacheEntry->CachePolicy = *pCachePolicy;

            if (pCachePolicy->Policy == HttpCachePolicyTimeToLive)
            {
                ASSERT( 0 != pCachePolicy->SecondsToLive );
                
                KeQuerySystemTime(&pCacheEntry->ExpirationTime);

                if ( pCachePolicy->SecondsToLive > C_SECS_PER_YEAR )
                {
                    // Maximum TTL is 1 year
                    pCacheEntry->CachePolicy.SecondsToLive = C_SECS_PER_YEAR;
                }

                //
                // Convert seconds to 100 nanosecond intervals (x * 10^7).
                //

                pCacheEntry->ExpirationTime.QuadPart +=
                    pCacheEntry->CachePolicy.SecondsToLive * C_NS_TICKS_PER_SEC;
            }
            else
            {
                pCacheEntry->ExpirationTime.QuadPart = 0;
            }

            //
            // Remember who created us.
            //

            pCacheEntry->pProcess = pProcess;
            pCacheEntry->pAppPool = pProcess->pAppPool;

            //
            // Generate the content of the cache entry.
            //

            pCacheEntry->ContentLength = Length;

        }
        __except( UL_EXCEPTION_FILTER() )
        {
            Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        }
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(Status))
    {
        if (pCacheEntry)
        {
            UlFreeCacheEntry(pCacheEntry);

            pCacheEntry = NULL;
        }
    }

    *ppCacheEntry = pCacheEntry;

    return Status;

} // UlpCreateFragmentCacheEntry


/***************************************************************************++

Routine Description:

    Reads a fragment back from cache.

Arguments:

    pProcess - process that is reading the fragment
    pInputBuffer - points to a buffer that describes HTTP_READ_FRAGMENT_INFO
    InputBufferLength - length of the input buffer
    pOutputBuffer - points to a buffer to copy the data from the fragment
        cache entry
    OutputBufferLength - length of the buffer to copy
    pBytesRead - optionally tells how many bytes are copied or needed

Return Value:

    NTSTATUS

--***************************************************************************/
NTSTATUS
UlReadFragmentFromCache(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PVOID pInputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PULONG pBytesRead
    )
{
    PUL_URI_CACHE_ENTRY pCacheEntry;
    PMDL pMdl;
    HTTP_READ_FRAGMENT_INFO ReadInfo;
    PUNICODE_STRING pFragmentName;
    PHTTP_BYTE_RANGE pByteRange;
    PVOID pContentBuffer;
    ULONGLONG Offset;
    ULONGLONG Length;
    ULONGLONG ContentLength;
    ULONG ReadLength;
    NTSTATUS Status;
    UNICODE_STRING FragmentName;

    //
    // Validate pInputBuffer and InputBufferLength.
    //

    if (!pInputBuffer || InputBufferLength < sizeof(HTTP_READ_FRAGMENT_INFO))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialization.
    //

    pCacheEntry = NULL;
    pMdl = NULL;
    RtlInitEmptyUnicodeString(&FragmentName, NULL, 0);

    __try
    {
        //
        // Capture HTTP_READ_FRAGMENT_INFO into the local ReadInfo.
        //

        UlProbeForRead(
            pInputBuffer,
            sizeof(HTTP_READ_FRAGMENT_INFO),
            sizeof(PVOID),
            RequestorMode
            );

        ReadInfo = *((PHTTP_READ_FRAGMENT_INFO) pInputBuffer);
        pFragmentName = &ReadInfo.FragmentName;
        pByteRange = &ReadInfo.ByteRange;

        Status =  UlProbeAndCaptureUnicodeString(
                        pFragmentName,
                        RequestorMode,
                        &FragmentName,
                        0
                        );
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Check out the fragment cache entry based on key URL passed in.
        //

        Status = UlCheckoutFragmentCacheEntry(
                        FragmentName.Buffer,
                        FragmentName.Length,
                        pProcess,
                        &pCacheEntry
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        ASSERT(pCacheEntry);

        ContentLength = pCacheEntry->ContentLength;
        Offset = pByteRange->StartingOffset.QuadPart;

        //
        // Validate byte range for offset and length.
        //

        if (Offset >= ContentLength)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        if (pByteRange->Length.QuadPart == HTTP_BYTE_RANGE_TO_EOF)
        {
            Length = ContentLength - Offset;
        }
        else
        {
            Length = pByteRange->Length.QuadPart;
        }

        if (!Length || Length > ULONG_MAX || Length > (ContentLength - Offset))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        ASSERT((Length + Offset) <= ContentLength);
        ReadLength = (ULONG) Length;

        //
        // Check if we have enough buffer space, if not, tell the caller the
        // exact bytes needed to complete the read.
        //

        if (OutputBufferLength < ReadLength)
        {
            *pBytesRead = ReadLength;
            Status = STATUS_BUFFER_OVERFLOW;
            goto end;
        }

        //
        // Build a partial MDL to read the data.
        //

        pMdl = UlAllocateMdl(
                    (PCHAR) MmGetMdlVirtualAddress(pCacheEntry->pMdl) + Offset,
                    ReadLength,
                    FALSE,
                    FALSE,
                    NULL
                    );

        if (NULL == pMdl)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        IoBuildPartialMdl(
            pCacheEntry->pMdl,
            pMdl,
            (PCHAR) MmGetMdlVirtualAddress(pCacheEntry->pMdl) + Offset,
            ReadLength
            );

        pContentBuffer = MmGetSystemAddressForMdlSafe(
                            pMdl,
                            NormalPagePriority
                            );

        if (NULL == pContentBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        //
        // Copy the data from the cache entry back to the output buffer.
        // UlFreeMdl unmaps the data for partial MDLs so no need to unmap
        // if either copy succeeds or an exception is raised.
        //

        UlProbeForWrite(
            pOutputBuffer,
            ReadLength,
            sizeof(PVOID),
            RequestorMode
            );

        RtlCopyMemory(
            pOutputBuffer,
            pContentBuffer,
            ReadLength
            );

        //
        // Set how many bytes we have copied.
        //

        *pBytesRead = ReadLength;

        Status = STATUS_SUCCESS;

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

end:

    UlFreeCapturedUnicodeString(&FragmentName);

    if (pMdl)
    {
        UlFreeMdl(pMdl);
    }

    if (pCacheEntry)
    {
         UlCheckinUriCacheEntry(pCacheEntry);
    }

    return Status;

} // UlReadFragmentFromCache


// Memory allocator front end


/***************************************************************************++

Routine Description:

    Allocate a cache entry from paged pool + space for response
    from physical memory

Arguments:

    SpaceLength - Length of space for URI + ETag + LoggingData
    ResponseLength - Length of Response

Return Value:

    Pointer to allocated entry or NULL on failure

--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlAllocateCacheEntry(
    ULONG SpaceLength,
    ULONG ResponseLength
    )
{
    PUL_URI_CACHE_ENTRY pEntry;

    PAGED_CODE();

    if(!g_CacheMemEnabled)
        return NULL;

    // Allocate from LargeMem

    pEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
        PagedPool,
        UL_URI_CACHE_ENTRY,
        SpaceLength,
        UL_URI_CACHE_ENTRY_POOL_TAG
        );
        
    if( NULL == pEntry ) {
        return NULL;
        }

    RtlZeroMemory(pEntry, sizeof(UL_URI_CACHE_ENTRY));

    pEntry->pMdl = UlLargeMemAllocate(ResponseLength);
    
    if( NULL == pEntry->pMdl ) {
        UL_FREE_POOL_WITH_SIG( pEntry, UL_URI_CACHE_ENTRY_POOL_TAG );
        return NULL;
    }

    pEntry->NumPages = ROUND_TO_PAGES(ResponseLength) >> PAGE_SHIFT;
    return pEntry;

}

/***************************************************************************++

Routine Description:

    Free a cache entry

Arguments:

    pEntry - Cache Entry to be freed

Return Value:

    Nothing

--***************************************************************************/
VOID
UlFreeCacheEntry(
    PUL_URI_CACHE_ENTRY pEntry
    )
{
    PAGED_CODE();

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pEntry) );
    ASSERT( pEntry->pMdl != NULL );

    UlLargeMemFree( pEntry->pMdl );
    UL_FREE_POOL_WITH_SIG( pEntry, UL_URI_CACHE_ENTRY_POOL_TAG );
}

/***************************************************************************++

Routine Description:

    Turn off the UL cache

--***************************************************************************/
VOID
UlDisableCache(
    VOID
    )
{
    PAGED_CODE();
    InterlockedExchange(&g_CacheMemEnabled, FALSE);
} // UlDisableCache

/***************************************************************************++

Routine Description:

    Turn on the UL cache

--***************************************************************************/
VOID
UlEnableCache(
    VOID
    )
{
    PAGED_CODE();
    InterlockedExchange(&g_CacheMemEnabled, TRUE);
} // UlEnableCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\samples\serviceconfig\url.c ===
/*++
 Copyright (c) 2002 - 2002 Microsoft Corporation.  All Rights Reserved.

 THIS CODE AND INFORMATION IS PROVIDED "AS-IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.

 THIS CODE IS NOT SUPPORTED BY MICROSOFT. 

--*/

#include "precomp.h"
#pragma hdrstop

//
// Private functions.
//

/***************************************************************************++

Routine Description:
    Prints a record in the URL ACL store.

Arguments:
    pOutput - A pointer to HTTP_SERVICE_CONFIG_URLACL_SET

Return Value:
    None.

--***************************************************************************/
void
PrintUrlAclRecord(
    IN PUCHAR pOutput
    )
{
    PHTTP_SERVICE_CONFIG_URLACL_SET pSetParam;

    pSetParam = (PHTTP_SERVICE_CONFIG_URLACL_SET) pOutput;

    NlsPutMsg(
        HTTPCFG_URLACL_URL,
        pSetParam->KeyDesc.pUrlPrefix
        );

    NlsPutMsg(
              HTTPCFG_URLACL_ACL,
              pSetParam->ParamDesc.pStringSecurityDescriptor
              );

    NlsPutMsg(
            HTTPCFG_RECORD_SEPARATOR
            );
}

/***************************************************************************++

Routine Description:
    Sets an URL ACL entry.

Arguments:
    pUrl - The URL
    pAcl - The ACL specified as a SDDL string.

Return Value:
    Success/Failure.

--***************************************************************************/
int 
DoUrlAclSet(
    IN PWSTR pUrl,
    IN PWSTR pAcl
    )
{
    HTTP_SERVICE_CONFIG_URLACL_SET SetParam;
    DWORD                          Status;

    ZeroMemory(&SetParam, sizeof(SetParam));

    SetParam.KeyDesc.pUrlPrefix                  = pUrl;
    SetParam.ParamDesc.pStringSecurityDescriptor = pAcl;

    Status = HttpSetServiceConfiguration(
                NULL,
                HttpServiceConfigUrlAclInfo,
                &SetParam,
                sizeof(SetParam),
                NULL
                );

    NlsPutMsg(HTTPCFG_SETSERVICE_STATUS, Status);
                
    return Status;
}


/***************************************************************************++

Routine Description:
    Queries for a URL ACL entry.

Arguments:
    pUrl - The URL (if NULL, then enumerate the store).

Return Value:
    Success/Failure.

--***************************************************************************/
int DoUrlAclQuery(
    IN PWSTR pUrl
    )
{
    DWORD                             Status;
    PUCHAR                            pOutput = NULL;
    DWORD                             OutputLength = 0;
    DWORD                             ReturnLength = 0;
    HTTP_SERVICE_CONFIG_URLACL_QUERY  QueryParam;

    ZeroMemory(&QueryParam, sizeof(QueryParam));

    if(pUrl)
    {
        // If a URL is specified, we'll Query for an exact entry.
        // 
        QueryParam.QueryDesc = HttpServiceConfigQueryExact;
        QueryParam.KeyDesc.pUrlPrefix = pUrl;
    }
    else
    {
        //
        // No URL is specified, so enumerate the entire store. 
        // 
        QueryParam.QueryDesc = HttpServiceConfigQueryNext;
    }

    for(;;)
    {
        // 
        // First, compute bytes required for querying the first entry.
        //
        Status = HttpQueryServiceConfiguration(
                    NULL,
                    HttpServiceConfigUrlAclInfo,
                    &QueryParam,
                    sizeof(QueryParam),
                    pOutput,
                    OutputLength,
                    &ReturnLength,
                    NULL
                    );

        if(Status == ERROR_INSUFFICIENT_BUFFER)
        {
            // If the API completes with ERROR_INSUFFICIENT_BUFFER, we'll
            // allocate memory for it & continue with the loop where we'll
            // call it again.
            
            if(pOutput)
            {
                // If there was an existing buffer, free it.
                LocalFree(pOutput);
            }

            // Allocate a new buffer
            pOutput = LocalAlloc(LMEM_FIXED, ReturnLength);
            if(!pOutput)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            OutputLength = ReturnLength;
        }
        else if(Status == NO_ERROR)
        {

            // The query succeeded! We'll print the record that we just
            // queried.
            
            PrintUrlAclRecord(pOutput);

            if(pUrl)
            {
                //
                // If we are not enumerating, we are done.
                //
                break;
            }
            else
            {
                //
                // Since we are enumerating, we'll move on to the next
                // record. This is done by incrementing the cursor, till 
                // we get ERROR_NO_MORE_ITEMS.
                //
                QueryParam.dwToken ++;
            }
        }
        else if(ERROR_NO_MORE_ITEMS == Status && pUrl == NULL)
        {
            // We are enumerating and we have reached the end. This is 
            // indicated by a ERROR_NO_MORE_ITEMS error code. 
            
            // This is not a real error, since it is used to indicate that
            // we've finished enumeration.
            
            Status = NO_ERROR;
            break;
        } 
        else
        {
            //
            // Some other error, so we are done
            //
            NlsPutMsg(HTTPCFG_QUERYSERVICE_STATUS, Status);
            break;
        }
    } 
    
    if(pOutput)
    {
        LocalFree(pOutput);
    }

    return Status;
}

/***************************************************************************++

Routine Description:
    Deletes an URL ACL entry.

Arguments:
    pUrl - The URL

Return Value:
    Success/Failure.

--***************************************************************************/
int DoUrlAclDelete(
    IN PWSTR pUrl
    )
{
    HTTP_SERVICE_CONFIG_URLACL_SET SetParam;
    DWORD                          Status;

    SetParam.KeyDesc.pUrlPrefix = pUrl;
    Status = HttpDeleteServiceConfiguration(
                NULL,
                HttpServiceConfigUrlAclInfo,
                &SetParam,
                sizeof(SetParam),
                NULL
                );
                
    NlsPutMsg(HTTPCFG_DELETESERVICE_STATUS, Status);
    return Status;
}

//
// Public function.
//

/***************************************************************************++

Routine Description:
    The function that parses parameters specific to URL ACL & 
    calls Set, Query or Delete.

Arguments:
    argc - Count of arguments.
    argv - Pointer to command line arguments.
    Type - Type of operation to be performed.

Return Value:
    Success/Failure.

--***************************************************************************/
int 
DoUrlAcl(
    int          argc, 
    WCHAR      **argv, 
    HTTPCFG_TYPE Type
    )
{
    PWCHAR   pUrl             = NULL;
    PWCHAR   pAcl             = NULL;

    while(argc>=2 && (argv[0][0] == '-' || argv[0][0]== '/'))
    {
        switch(toupper(argv[0][1]))
        {
            case 'U':
                pUrl = argv[1];
                break;
    
            case 'A':
                pAcl = argv[1];
                break;
        
            default:
                NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
                return ERROR_INVALID_PARAMETER;
        }

        argc -=2;
        argv +=2;
    }

    switch(Type)
    {
        case HttpCfgTypeSet:
            return DoUrlAclSet(pUrl, pAcl);

        case HttpCfgTypeQuery:
            return DoUrlAclQuery(pUrl);

        case HttpCfgTypeDelete:
            return DoUrlAclDelete(pUrl);

        default: 
            NlsPutMsg(HTTPCFG_INVALID_SWITCH, argv[0]);
            return ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\bugcheck.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    bugcheck.h

Abstract:

    A few errors are so severe that our only option is to bugcheck.
    HTTP.SYS bugcheck codes are declared here.
    
Author:

    George V. Reilly  Jun-2001

Revision History:

--*/


#ifndef _BUGCHECK_H_
#define _BUGCHECK_H_

#include <bugcodes.h>


#ifndef HTTP_DRIVER_CORRUPTED
#define HTTP_DRIVER_CORRUPTED            ((ULONG)0x000000FAL)
#endif


//
// Parameter 1 subcodes
//


//
// A workitem is invalid. This will eventually result in corruption of
// the thread pool and an access violation.
// p2 = address of workitem, p3 = __FILE__, p4 = __LINE__.
//

#define HTTP_SYS_BUGCHECK_WORKITEM      0x01


//
// Public routines
//

VOID
UlBugCheckEx(
    IN ULONG_PTR HttpSysBugcheckSubCode,
    IN ULONG_PTR Param2,
    IN ULONG_PTR Param3,
    IN ULONG_PTR Param4
    );

#endif  // _BUGCHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\apoolp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    apoolp.h

Abstract:

    The private definitions of app pool module.

Author:

    Paul McDaniel (paulmcd)       28-Jan-1999


Revision History:

--*/


#ifndef _APOOLP_H_
#define _APOOLP_H_


//
// A structure for associating app pool processes with
// connections for UlWaitForDisconnect
//

#define IS_VALID_DISCONNECT_OBJECT(pObject)                     \
    HAS_VALID_SIGNATURE(pObject, UL_DISCONNECT_OBJECT_POOL_TAG)

typedef struct _UL_DISCONNECT_OBJECT
{
    ULONG               Signature;  // UL_DISCONNECT_OBJECT_POOL_TAG

    //
    // Lists for processes and connections
    //
    UL_NOTIFY_ENTRY     ProcessEntry;
    UL_NOTIFY_ENTRY     ConnectionEntry;

    //
    // The WaitForDisconnect IRP
    //
    PIRP                pIrp;

} UL_DISCONNECT_OBJECT, *PUL_DISCONNECT_OBJECT;

//
// The information will be logged when an app pool process 
// get detached while holding on to outstanding connection(s)
// This happens when a worker process crashes. And the error
// log file provides a way to track down the faulty request. 
//

#define ERROR_LOG_INFO_FOR_APP_POOL_DETACH       "Connection_Abandoned_By_AppPool"
#define ERROR_LOG_INFO_FOR_APP_POOL_DETACH_SIZE  \
            (sizeof(ERROR_LOG_INFO_FOR_APP_POOL_DETACH)-sizeof(CHAR))


//
// Internal helper functions used in the module
//

VOID
UlpCancelDemandStart(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

VOID
UlpCancelHttpReceive(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

PIRP
UlpPopNewIrp(
    IN PUL_APP_POOL_OBJECT      pAppPool,
    IN PUL_INTERNAL_REQUEST     pRequest,
    OUT PUL_APP_POOL_PROCESS *  ppProcess
    );

PIRP
UlpPopIrpFromProcess(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest
    );

BOOLEAN
UlpIsProcessInAppPool(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_APP_POOL_OBJECT  pAppPool
    );

NTSTATUS
UlpQueueUnboundRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    );

NTSTATUS
UlpQueuePendingRequest(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlpUnbindQueuedRequests(
    IN PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlpRedeliverRequestWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpSetAppPoolQueueLength(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG                QueueLength
    );

ULONG
UlpCopyEntityBodyToBuffer(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR               pEntityBody,
    IN ULONG                EntityBodyLength,
    OUT PULONG              pFlags
    );

NTSTATUS
UlpQueueRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,    
    IN PLIST_ENTRY          pQueueList,
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlpRemoveRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,    
    IN PUL_INTERNAL_REQUEST pRequest
    );

PUL_INTERNAL_REQUEST
UlpDequeueRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PLIST_ENTRY          pQueueList
    );

UL_HTTP_ERROR
UlpConvertAppPoolEnabledStateToErrorCode(
    IN HTTP_APP_POOL_ENABLED_STATE Enabled
    );

NTSTATUS
UlpSetAppPoolState(
    IN PUL_APP_POOL_PROCESS        pProcess,
    IN HTTP_APP_POOL_ENABLED_STATE Enabled
    );

NTSTATUS
UlpSetAppPoolLoadBalancerCapability(
    IN PUL_APP_POOL_PROCESS            pProcess,
    IN HTTP_LOAD_BALANCER_CAPABILITIES LoadBalancerCapability
    );

VOID
UlpCancelWaitForDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelWaitForDisconnectWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

BOOLEAN
UlpNotifyCompleteWaitForDisconnect(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    );

PUL_DISCONNECT_OBJECT
UlpCreateDisconnectObject(
    IN PIRP pIrp
    );

VOID
UlpFreeDisconnectObject(
    IN PUL_DISCONNECT_OBJECT pObject
    );

VOID
UlpSetAppPoolControlChannelHelper(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

#endif // _APOOLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\cache.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    cache.h

Abstract:

    The public definition of response cache interfaces.

Author:

    Michael Courage (mcourage)      17-May-1999

Revision History:

--*/


#ifndef _CACHE_H_
#define _CACHE_H_


//
// Forwards
//
typedef struct _UL_INTERNAL_RESPONSE *PUL_INTERNAL_RESPONSE;
typedef struct _UL_INTERNAL_DATA_CHUNK *PUL_INTERNAL_DATA_CHUNK;

//
// Cache configuration
//
typedef struct _UL_URI_CACHE_CONFIG {
    BOOLEAN     EnableCache;
    ULONG       MaxCacheUriCount;
    ULONG       MaxCacheMegabyteCount;
    ULONGLONG   MaxCacheByteCount;
    ULONG       ScavengerPeriod;
    ULONG       MaxUriBytes;
    LONG        HashTableBits;
} UL_URI_CACHE_CONFIG, *PUL_URI_CACHE_CONFIG;

extern UL_URI_CACHE_CONFIG g_UriCacheConfig;

//
// Cache statistics
//
typedef struct _UL_URI_CACHE_STATS {
    ULONG       UriCount;               // entries in hash table
    ULONG       UriCountMax;            // high water mark
    ULONGLONG   UriAddedTotal;          // total entries ever added

    ULONGLONG   ByteCount;              // memory used for cache
    ULONGLONG   ByteCountMax;           // high water

    ULONG       ZombieCount;            // length of zombie list
    ULONG       ZombieCountMax;         // high water

    ULONG       HitCount;               // table lookup succeeded
    ULONG       MissTableCount;         // entry not in table
    ULONG       MissPreconditionCount;  // request not cacheable
    ULONG       MissConfigCount;        // config invalidated

    ULONG       UriTypeNotSpecifiedCount;       // Uri's site binding is not applicable
    ULONG       UriTypeIpBoundCount;            // Uri's site binding is IP only
    ULONG       UriTypeHostPlusIpBoundCount;    // Uri's site binding is Host + IP
    ULONG       UriTypeHostBoundCount;          // Uri's site binding is Host only
    ULONG       UriTypeWildCardCount;           // Uri's site binding is wildcard
    
} UL_URI_CACHE_STATS, *PUL_URI_CACHE_STATS;

extern UL_URI_CACHE_STATS  g_UriCacheStats;

__inline
ULONG
UlGetIpBoundUriCacheCount()
{
    return g_UriCacheStats.UriTypeIpBoundCount;
}

__inline
ULONG
UlGetHostPlusIpBoundUriCacheCount()
{
    return g_UriCacheStats.UriTypeHostPlusIpBoundCount;
}

__inline
ULONG
UlGetHostBoundUriCacheCount()
{
    return g_UriCacheStats.UriTypeHostBoundCount;
}

    
//
// Structure of an HTTP cache table entry.
//

typedef enum _URI_KEY_TYPE
{
    UriKeyTypeNormal   = 0,
    UriKeyTypeExtended,
    UriKeyTypeMax
    
} URI_KEY_TYPE, *PURI_KEY_TYPE;

typedef  struct URI_KEY
{    
    ULONG        Hash;
    PWSTR        pUri;
    ULONG        Length;

    // Optional pointer which will point to 
    // the AbsPath of the pUri. Only set when 
    // the URI_KEY is used in the cache entry.

    PWSTR        pPath;
    
} URI_KEY, *PURI_KEY;

typedef struct EX_URI_KEY
{
    ULONG        Hash;
    PWSTR        pAbsPath;
    ULONG        AbsPathLength;
    PWSTR        pToken;
    ULONG        TokenLength;
    
} EX_URI_KEY, *PEX_URI_KEY;

typedef struct _URI_SEARCH_KEY
{
    URI_KEY_TYPE Type;

    union 
    {
        URI_KEY     Key;
        EX_URI_KEY  ExKey;
    };

} URI_SEARCH_KEY, *PURI_SEARCH_KEY;

#define IS_VALID_URI_SEARCH_KEY(pKey)     \
    ((pKey)->Type == UriKeyTypeNormal || (pKey)->Type == UriKeyTypeExtended)

//
// Structure for holding the split-up content type.  Assumes that types and
// subtypes will never be longer than MAX_TYPE_LEN.
//
#define MAX_TYPE_LENGTH     32
#define MAX_SUBTYPE_LENGTH  64

typedef struct _UL_CONTENT_TYPE
{
    ULONG       TypeLen;
    UCHAR       Type[MAX_TYPE_LENGTH];

    ULONG       SubTypeLen;
    UCHAR       SubType[MAX_SUBTYPE_LENGTH];

} UL_CONTENT_TYPE, *PUL_CONTENT_TYPE;


#define IS_VALID_URI_CACHE_ENTRY(pEntry)                        \
    HAS_VALID_SIGNATURE(pEntry, UL_URI_CACHE_ENTRY_POOL_TAG)

#define IS_RESPONSE_CACHE_ENTRY(pEntry)                         \
    (0 != (pEntry)->HeaderLength)

#define IS_FRAGMENT_CACHE_ENTRY(pEntry)                         \
    (0 == (pEntry)->HeaderLength)

typedef struct _UL_URI_CACHE_ENTRY  // CacheEntry
{
    //
    // PagedPool
    //

    ULONG                   Signature;      // UL_URI_CACHE_ENTRY_POOL_TAG

    LONG                    ReferenceCount;

    //
    // cache info
    //
    SINGLE_LIST_ENTRY       BucketEntry;

    URI_KEY                 UriKey;
        
    ULONG                   HitCount;

    LIST_ENTRY              ZombieListEntry;
    BOOLEAN                 Zombie;
    BOOLEAN                 ZombieAddReffed;

    BOOLEAN                 Cached;
    BOOLEAN                 ContentLengthSpecified; // hack
    USHORT                  StatusCode;
    HTTP_VERB               Verb;
    ULONG                   ScavengerTicks;

    HTTP_CACHE_POLICY       CachePolicy;
    LARGE_INTEGER           ExpirationTime;

    //
    // System time of Date that went out on original response
    //
    LARGE_INTEGER           CreationTime;

    //
    // ETag of original response
    //
    ULONG                   ETagLength; // Including NULL
    PUCHAR                  pETag;

    //
    // Content-Encoding of original response
    //
    ULONG                   ContentEncodingLength; //    Incl. NULL
    PUCHAR                  pContentEncoding;

    //
    // Content-Type of original response
    //
    UL_CONTENT_TYPE         ContentType;

    //
    // config and process data for invalidation
    //
    UL_URL_CONFIG_GROUP_INFO    ConfigInfo;

    PUL_APP_POOL_PROCESS    pProcess;
    PUL_APP_POOL_OBJECT     pAppPool;

    //
    // Response data
    //
    ULONG                   HeaderLength;
    ULONG                   ContentLength;
    PMDL                    pMdl;   // including content + header
    ULONG_PTR               NumPages; // # pages allocated in pMdl


    //
    // Logging Information. When enabled, logging info
    // follows the structure after etags.
    //

    BOOLEAN                 LoggingEnabled;
    BOOLEAN                 BinaryLogged;
    ULONG                   BinaryIndexWritten;    
    USHORT                  UsedOffset1;
    USHORT                  UsedOffset2;
    ULONG                   LogDataLength;
    PUCHAR                  pLogData;

    //
    // Followings are allocated at the end of the structure.
    //

    // WSTR                 Uri[];
    // UCHAR                ETag[];
    // UCHAR                LogData[];

} UL_URI_CACHE_ENTRY, *PUL_URI_CACHE_ENTRY;




//
// public functions
//
NTSTATUS
UlInitializeUriCache(
    PUL_CONFIG pConfig
    );

VOID
UlTerminateUriCache(
    VOID
    );

VOID
UlInitCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    ULONG               Hash,
    ULONG               Length,
    PCWSTR              pUrl,
    PCWSTR              pAbsPath,
    PCWSTR              pRoutingToken,
    USHORT              RoutingTokenLength
    );

NTSTATUS
UlAddCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

PUL_URI_CACHE_ENTRY
UlCheckoutUriCacheEntry(
    PURI_SEARCH_KEY  pSearchKey
    );

VOID
UlCheckinUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

VOID
UlFlushCache(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

VOID
UlFlushCacheByProcess(
    PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlFlushCacheByUri(
    IN PWSTR pUri,
    IN ULONG Length,
    IN ULONG Flags,
    PUL_APP_POOL_PROCESS pProcess
    );


//
// cachability test functions
//


BOOLEAN
UlCheckCachePreconditions(
    PUL_INTERNAL_REQUEST    pRequest,
    PUL_HTTP_CONNECTION     pHttpConn
    );

BOOLEAN
UlCheckCacheResponseConditions(
    PUL_INTERNAL_REQUEST        pRequest,
    PUL_INTERNAL_RESPONSE       pResponse,
    ULONG                       Flags,
    HTTP_CACHE_POLICY           CachePolicy
    );

// reference counting

LONG
UlAddRefUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

LONG
UlReleaseUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_URI_CACHE_ENTRY( pEntry, Action )                         \
    UlAddRefUriCacheEntry(                                                  \
        (pEntry),                                                           \
        (REF_ACTION_##Action##_URI_ENTRY)                                   \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define DEREFERENCE_URI_CACHE_ENTRY( pEntry, Action )                       \
    UlReleaseUriCacheEntry(                                                 \
        (pEntry),                                                           \
        (REF_ACTION_##Action##_URI_ENTRY)                                   \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

// Periodic Scavenger
VOID
UlPeriodicCacheScavenger(
    ULONG Age
    );

// Reclaim memory from cache
VOID
UlTrimCache(
    IN ULONG_PTR Pages,
    IN ULONG Age
    );

// fragment cache

NTSTATUS
UlAddFragmentToCache(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUNICODE_STRING pFullyQualifiedUrl,
    IN PHTTP_DATA_CHUNK pDataChunk,
    IN PHTTP_CACHE_POLICY pCachePolicy,
    IN KPROCESSOR_MODE RequestorMode
    );

NTSTATUS
UlReadFragmentFromCache(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PVOID pInputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PULONG pBytesRead
    );

VOID
UlClearCentralizedLogged(
    IN PVOID pContext
    );

//
// Wrappers to memory allocate routines
//

PUL_URI_CACHE_ENTRY
UlAllocateCacheEntry(
    ULONG SpaceLength,
    ULONG ResponseLength
    );

VOID
UlFreeCacheEntry(
    PUL_URI_CACHE_ENTRY pEntry
    );

/***************************************************************************++

Routine Description:

    Copy cache data to the specified entry starting from Offset.

--***************************************************************************/
__inline BOOLEAN
UlCacheEntrySetData(
    IN PUL_URI_CACHE_ENTRY pEntry,
    IN PUCHAR pBuffer,
    IN ULONG Length,
    IN ULONG Offset
    )
{
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pEntry) );
    ASSERT(pEntry->pMdl != NULL);
    ASSERT(Offset <= pEntry->pMdl->ByteCount);
    ASSERT(Length <= (pEntry->pMdl->ByteCount - Offset));

    return UlLargeMemSetData( pEntry->pMdl, pBuffer, Length, Offset );

} // UlCacheEntrySetData

//
// Enable/Disable cache at runtime. Used by scavenger.
//

VOID
UlDisableCache(
    VOID
    );

VOID
UlEnableCache(
    VOID
    );

#endif // _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\cachep.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    cachep.h

Abstract:

    The private definition of response cache interfaces.

Author:

    Michael Courage (mcourage)      17-May-1999

Revision History:

--*/


#ifndef _CACHEP_H_
#define _CACHEP_H_


//
// constants
//
#define CACHE_ENTRY_AGE_THRESHOLD   1
#define ZOMBIE_AGE_THRESHOLD        5

typedef enum _UL_CACHE_PREDICATE
{
    ULC_ABORT           = 1,            // Stop walking the table immediately
    ULC_NO_ACTION       = 2,            // No action, just keep walking
    ULC_DELETE          = 3,            // Delete record and keep walking
    ULC_DELETE_STOP     = 4,            // Delete record, then stop
} UL_CACHE_PREDICATE, *PUL_CACHE_PREDICATE;

//
// THIS enum is primarily for debugging.
// It tells you what precondition forced a cache miss.
//
typedef enum _URI_PRECONDITION
{
    URI_PRE_OK,                 // OK to serve
    URI_PRE_DISABLED,           // Cache disabled

    // request conditions
    URI_PRE_ENTITY_BODY = 10,   // There was an entity body
    URI_PRE_VERB,               // Verb wasn't GET
    URI_PRE_PROTOCOL,           // Wasn't 1.x request
    URI_PRE_TRANSLATE,          // Translate: f
    URI_PRE_AUTHORIZATION,      // Auth headers present
    URI_PRE_CONDITIONAL,        // Unhandled conditionals present
    URI_PRE_ACCEPT,             // Accept: mismatch
    URI_PRE_OTHER_HEADER,       // Other evil header present
    URI_PRE_EXPECTATION_FAILED, // Expect: 100-continue 

    // response conditions
    URI_PRE_REQUEST = 50,       // Problem with the request
    URI_PRE_POLICY,             // Policy was wrong
    URI_PRE_SIZE,               // Response too big
    URI_PRE_NOMEMORY,           // No space in cache
    URI_PRE_FRAGMENT,           // Didn't get whole response
    URI_PRE_BOGUS               // Bogus response
} URI_PRECONDITION;

//
// 100-continue token for Expect: header
//

#define HTTP_100_CONTINUE       "100-continue"
#define HTTP_CONTINUE_LENGTH    STRLEN_LIT(HTTP_100_CONTINUE)


BOOLEAN
UlpCheckTableSpace(
    IN ULONGLONG EntrySize
    );

BOOLEAN
UlpCheckSpaceAndAddEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

VOID
UlpRemoveEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

VOID
UlpAddZombie(
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    BOOLEAN             fTakeZombieLock
    );

VOID
UlpClearZombieList(
    VOID
    );

//
// Passed down to the filter callback functions by UlpFilteredFlushUriCache
//

typedef struct _URI_FILTER_CONTEXT
{
    UL_WORK_ITEM    WorkItem;       // for UlQueueWorkItem
    ULONG           Signature;      // URI_FILTER_CONTEXT_POOL_TAG
    ULONG           ZombieCount;    // for statistics
    LIST_ENTRY      ZombieListHead; // UL_URI_CACHE_ENTRYs to be zombified
    PVOID           pCallerContext; // context passed down by caller
    URI_KEY         UriKey;         // For recursive uri flushes.
    LARGE_INTEGER   Now;            // For checking Expire time
    
} URI_FILTER_CONTEXT, *PURI_FILTER_CONTEXT;

#define IS_VALID_FILTER_CONTEXT(context)                        \
    HAS_VALID_SIGNATURE(context, URI_FILTER_CONTEXT_POOL_TAG)


// filter function pointer
typedef
UL_CACHE_PREDICATE
(*PUL_URI_FILTER)(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pvUriFilterContext
    );

VOID
UlpFilteredFlushUriCache(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext,
    IN PWSTR            pUri,
    IN ULONG            Length    
    );

VOID
UlpFilteredFlushUriCacheInline(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext,
    IN PWSTR            pUri,
    IN ULONG            Length   
    );

VOID
UlpFilteredFlushUriCacheWorker(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext,
    IN PWSTR            pUri,
    IN ULONG            Length,
    IN BOOLEAN          InlineFlush
    );

UL_CACHE_PREDICATE
UlpFlushFilterAll(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    );

UL_CACHE_PREDICATE
UlpFlushFilterProcess(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    );

UL_CACHE_PREDICATE
UlpFlushFilterUriRecursive(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    );

VOID
UlpFlushUri(
    IN PWSTR pUri,
    IN ULONG Length,
    PUL_APP_POOL_PROCESS pProcess
    );

UL_CACHE_PREDICATE
UlpZombifyEntry(
    BOOLEAN                MustZombify,
    BOOLEAN                MustMarkEntry,    
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PURI_FILTER_CONTEXT pUriFilterContext
    );

VOID
UlpZombifyList(
    IN PUL_WORK_ITEM pWorkItem
    );

//
// Cache entry stuff
//

// CODEWORK: make this function (and put in cache.h header)
PUL_URI_CACHE_ENTRY
UlAllocateUriCacheEntry(
    // much stuff
    );

VOID
UlpDestroyUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );


//
// Scavenger stuff
//
UL_CACHE_PREDICATE
UlpFlushFilterPeriodicScavenger(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pvUriFilterContext
    );

//
// Low Memory Handling
//

// Used to pass parameters from UlTrimCache to UlpFlushFilterTrimCache
typedef struct _UL_CACHE_TRIM_FILTER_CONTEXT {
    LONG_PTR Pages;
    LONG Age;
} UL_CACHE_TRIM_FILTER_CONTEXT, *PUL_CACHE_TRIM_FILTER_CONTEXT;

UL_CACHE_PREDICATE
UlpFlushFilterTrimCache(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pUriFilterContext
    );

UL_CACHE_PREDICATE
UlpFlushFilterIncScavengerTicks(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pUriFilterContext
    );

//
// Fragment cache.
//

NTSTATUS
UlpCreateFragmentCacheEntry(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PWSTR pFragmentName,
    IN ULONG FragmentNameLength,
    IN ULONG Length,
    IN PHTTP_CACHE_POLICY pCachePolicy,
    OUT PUL_URI_CACHE_ENTRY *pCacheEntry
    );

//
// Other cache routines.
//

BOOLEAN
UlpQueryTranslateHeader(
    IN PUL_INTERNAL_REQUEST pRequest
    );

BOOLEAN
UlpQueryExpectHeader(
    IN PUL_INTERNAL_REQUEST pRequest
    );

UL_CACHE_PREDICATE
UlpFlushFilterClearCentralizedLogged(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    );

#endif // _CACHEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\cgroup.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    cgroup.c

Abstract:

    Note that most of the routines in this module assume they are called
    at PASSIVE_LEVEL.

    See end of file for somewhat dated design notes

Author:

    Paul McDaniel (paulmcd)       12-Jan-1999

Revision History:

    Anish Desai (anishd)           1-May-2002  Add Namespace reservation
                                               and registration support

--*/

#include "precomp.h"        // Project wide headers
#include "cgroupp.h"        // Private data structures

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeCG )
#pragma alloc_text( PAGE, UlTerminateCG )

#pragma alloc_text( PAGE, UlAddUrlToConfigGroup )
#pragma alloc_text( PAGE, UlConfigGroupFromListEntry )
#pragma alloc_text( PAGE, UlCreateConfigGroup )
#pragma alloc_text( PAGE, UlDeleteConfigGroup )
#pragma alloc_text( PAGE, UlGetConfigGroupInfoForUrl )
#pragma alloc_text( PAGE, UlQueryConfigGroupInformation )
#pragma alloc_text( PAGE, UlRemoveUrlFromConfigGroup )
#pragma alloc_text( PAGE, UlRemoveAllUrlsFromConfigGroup )
#pragma alloc_text( PAGE, UlSetConfigGroupInformation )
#pragma alloc_text( PAGE, UlNotifyOrphanedConfigGroup )
#pragma alloc_text( PAGE, UlSanitizeUrl )
#pragma alloc_text( PAGE, UlRemoveSite )

#pragma alloc_text( PAGE, UlpSetUrlInfoSpecial )
#pragma alloc_text( PAGE, UlpCreateConfigGroupObject )
#pragma alloc_text( PAGE, UlpCleanAllUrls )
#pragma alloc_text( PAGE, UlpDeferredRemoveSite )
#pragma alloc_text( PAGE, UlpDeferredRemoveSiteWorker )
#pragma alloc_text( PAGE, UlpSetUrlInfo )
#pragma alloc_text( PAGE, UlConfigGroupInfoRelease )
#pragma alloc_text( PAGE, UlConfigGroupInfoDeepCopy )
#pragma alloc_text( PAGE, UlpTreeFreeNode )
#pragma alloc_text( PAGE, UlpTreeDeleteRegistration )
#pragma alloc_text( PAGE, UlpTreeDeleteReservation )
#pragma alloc_text( PAGE, UlpTreeFindNode )
#pragma alloc_text( PAGE, UlpTreeFindNodeWalker )
#pragma alloc_text( PAGE, UlpTreeFindNodeHelper )
#pragma alloc_text( PAGE, UlpTreeFindReservationNode )
#pragma alloc_text( PAGE, UlpTreeFindRegistrationNode )
#pragma alloc_text( PAGE, UlpTreeBinaryFindEntry )
#pragma alloc_text( PAGE, UlpTreeCreateSite )
#pragma alloc_text( PAGE, UlpTreeFindSite )
#pragma alloc_text( PAGE, UlpTreeFindWildcardSite )
#pragma alloc_text( PAGE, UlpTreeFindSiteIpMatch )
#pragma alloc_text( PAGE, UlpTreeInsert )
#pragma alloc_text( PAGE, UlpTreeInsertEntry )
#pragma alloc_text( PAGE, UlLookupHostPlusIPSite )
#pragma alloc_text( PAGE, UlCGLockWriteSyncRemoveSite )
#pragma alloc_text( PAGE, UlpExtractSchemeHostPortIp )
#endif  // ALLOC_PRAGMA


//
// Globals
//

PUL_CG_URL_TREE_HEADER      g_pSites = NULL;
BOOLEAN                     g_InitCGCalled = FALSE;
KEVENT                      g_RemoveSiteEvent;
LONG                        g_RemoveSiteCount = 0;
LONG                        g_NameIPSiteCount = 0;
LIST_ENTRY                  g_ReservationListHead;

//
// Macro for uniformity with CG_LOCK_* macros.
//

#define CG_LOCK_WRITE_SYNC_REMOVE_SITE() UlCGLockWriteSyncRemoveSite()


/**************************************************************************++

Routine Description:

    This inline function waits for g_RemoveSiteCount to drop to zero and 
    acquires the CG lock exclusively.

Arguments:

    None.

Return Value:

    None.

--**************************************************************************/
__forceinline
VOID
UlCGLockWriteSyncRemoveSite(
    VOID
    )
{
    for(;;)
    {
        CG_LOCK_WRITE();

        if (InterlockedExchangeAdd(&g_RemoveSiteCount, 0))
        {
            CG_UNLOCK_WRITE();

            //
            // The wait has to be outside the CG lock or we can run into
            // a deadlock where DeferredRemoveSiteWorker waits for the
            // connections to go away but UlpHandleRequest is blocked on
            // the CG lock so the request never has a chance to release
            // its ref on the connection.
            //

            KeWaitForSingleObject(
                &g_RemoveSiteEvent,
                UserRequest,
                UserMode,
                FALSE,
                NULL
                );

            continue;
        }
        else
        {
            break;
        }
    }
}


/***************************************************************************++

Routine Description:

    Free's the node pEntry.  This funciton walks up and tree of parent entries
    and deletes them if they are supposed to free'd (dummy nodes) .

Arguments:

    IN PUL_CG_URL_TREE_ENTRY pEntry - the entry to free

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFreeNode(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    )
{
    NTSTATUS                Status;
    PUL_CG_URL_TREE_HEADER  pHeader;
    ULONG                   Index;
    PUL_CG_URL_TREE_ENTRY   pParent;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    Status = STATUS_SUCCESS;

    //
    // Loop!  we are going to walk up the tree deleting as much
    // as we can of this branch.
    //

    while (pEntry != NULL)
    {

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

        //
        // Init
        //

        pParent = NULL;

        UlTrace(
            CONFIG_GROUP_TREE, (
                "http!UlpTreeFreeNode - pEntry(%p, '%S', %d, %d, %S, %S%S)\n",
                pEntry,
                pEntry->pToken,
                (int) pEntry->Registration,
                (int) pEntry->Reservation,
                (pEntry->pChildren == NULL || pEntry->pChildren->UsedCount == 0)
                    ? L"no children" : L"children",
                pEntry->pParent == NULL ? L"no parent" : L"parent=",
                pEntry->pParent == NULL ? L"" : pEntry->pParent->pToken
                )
            );

        //
        // 1) might not be a "real" leaf - we are walking up the tree in this 
        // loop
        //
        // 2) also we clean this first because we might not be deleting
        // this node at all, if it has dependent children.
        //

        ASSERT(pEntry->Registration == FALSE);
        ASSERT(pEntry->pConfigGroup == NULL);
        ASSERT(pEntry->Reservation  == FALSE);
        ASSERT(pEntry->pSecurityDescriptor == NULL);
        ASSERT(pEntry->SiteAddedToEndpoint == FALSE);
        ASSERT(pEntry->pRemoveSiteWorkItem == NULL);

        //
        // do we have children?
        //

        if (pEntry->pChildren != NULL && pEntry->pChildren->UsedCount > 0)
        {
            //
            // can't delete it.  dependant children exist.
            // it's already be converted to a dummy node above.
            //
            // leave it.  it will get cleaned by a subsequent child.
            //

            break;
        }

        //
        // we are really deleting this one, remove it from the sibling list.
        //

        //
        // find our location in the sibling list
        //

        if (pEntry->pParent == NULL)
        {
            pHeader = g_pSites;
        }
        else
        {
            pHeader = pEntry->pParent->pChildren;
        }

        Status  = UlpTreeBinaryFindEntry(
                        pHeader,
                        pEntry->pToken,
                        pEntry->TokenLength,
                        &Index
                        );

        if (NT_SUCCESS(Status) == FALSE)
        {
            ASSERT(FALSE);
            goto end;
        }

        //
        // time to remove it
        //
        // if not the last one, shift left the array at Index
        //

        if (Index < (pHeader->UsedCount-1))
        {
            RtlMoveMemory(
                &(pHeader->pEntries[Index]),
                &(pHeader->pEntries[Index+1]),
                (pHeader->UsedCount - 1 - Index) * sizeof(UL_CG_HEADER_ENTRY)
                );
        }

        //
        // now we have 1 less
        //

        pHeader->UsedCount -= 1;

        //
        // update count for different site types
        //

        switch (pEntry->UrlType)
        {
            case HttpUrlSite_Name:
            {
                pHeader->NameSiteCount--;
                ASSERT(pHeader->NameSiteCount >= 0);
                break;
            }

            case HttpUrlSite_IP:
            {
                pHeader->IPSiteCount--;
                ASSERT(pHeader->IPSiteCount >= 0);
                break;
            }

            case HttpUrlSite_StrongWildcard:
            {
                pHeader->StrongWildcardCount--;
                ASSERT(pHeader->StrongWildcardCount >= 0);
                break;
            }

            case HttpUrlSite_WeakWildcard:
            {
                pHeader->WeakWildcardCount--;
                ASSERT(pHeader->WeakWildcardCount >= 0);
                break;
            }

            case HttpUrlSite_NamePlusIP:
            {
                pHeader->NameIPSiteCount--;
                InterlockedDecrement(&g_NameIPSiteCount);
                ASSERT(pHeader->NameIPSiteCount >= 0);
                break;
            }

            case HttpUrlSite_None:
            default:
            {
                ASSERT(FALSE);
                break;
            }
        }

        ASSERT(
            pHeader->UsedCount == (ULONG)
            (pHeader->NameSiteCount       +
             pHeader->IPSiteCount         +
             pHeader->WeakWildcardCount   +
             pHeader->StrongWildcardCount +
             pHeader->NameIPSiteCount
            ));

        //
        // need to clean parent entries that were here just for this leaf
        //

        if (pEntry->pParent != NULL)
        {
            //
            // Does this parent have any other children?
            //

            ASSERT(IS_VALID_TREE_HEADER(pEntry->pParent->pChildren));

            if (pEntry->pParent->pChildren->UsedCount == 0)
            {
                //
                // no more, time to clean the child list
                //

                UL_FREE_POOL_WITH_SIG(
                    pEntry->pParent->pChildren,
                    UL_CG_TREE_HEADER_POOL_TAG
                    );

                //
                // is the parent a real url entry?
                //

                if (pEntry->pParent->Registration == FALSE &&
                    pEntry->pParent->Reservation == FALSE)
                {
                    //
                    // nope .  let's scrub it.
                    //

                    pParent = pEntry->pParent;

                }
            }
            else
            {
                //
                // ouch.  siblings.  can't nuke parent.
                //
            }
        }

        //
        // Free the entry
        //

        UL_FREE_POOL_WITH_SIG(pEntry, UL_CG_TREE_ENTRY_POOL_TAG);

        //
        // Move on to the next one
        //

        pEntry = pParent;
    }

end:
    return Status;

} // UlpTreeFreeNode


/**************************************************************************++

Routine Description:

    This routine deletes a registration.  If the node is not a reservation
    node, it is physically deleted from the tree.

Arguments:

    pEntry - Supplies the entry of the registration to be deleted.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpTreeDeleteRegistration(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    //
    // delete registration.
    //

    ASSERT(pEntry->Registration == TRUE);

    //
    // remove it from the config group list.
    //

    RemoveEntryList(&(pEntry->ConfigGroupListEntry));
    pEntry->ConfigGroupListEntry.Flink = NULL;
    pEntry->ConfigGroupListEntry.Blink = NULL;
    pEntry->pConfigGroup = NULL;

    if (pEntry->SiteAddedToEndpoint)
    {
        //
        // the registration was added to the endpoint list, remove it.
        //

        ASSERT(pEntry->pRemoveSiteWorkItem != NULL);
        UlpDeferredRemoveSite(pEntry);
    }
    else
    {
        ASSERT(pEntry->pRemoveSiteWorkItem == NULL);
    }

    //
    // mark it as a non-registration node.
    //

    pEntry->Registration = FALSE;

    Status = STATUS_SUCCESS;

    //
    // clean up the node if necessary.
    //

    if (pEntry->Reservation == FALSE)
    {
        //
        // if it is not a reservation node, try to free it.
        // this will also remove it from endpoint if necessary.
        //

        Status = UlpTreeFreeNode(pEntry);
    }

    return Status;

} // UlpTreeDeleteRegistration


/**************************************************************************++

Routine Description:

    This routine delete a reservation.  If the node is not a registration
    node, it is physically deleted from the tree.

Arguments:

    pEntry - Supplies a pointer to the reservation to be deleted.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpTreeDeleteReservation(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_TREE_ENTRY(pEntry));
    ASSERT(pEntry->Reservation == TRUE);

    //
    // delete reservation.
    //

    ASSERT(pEntry->Reservation == TRUE);

    //
    // remove it from the list global reservation list.
    //

    RemoveEntryList(&pEntry->ReservationListEntry);
    pEntry->ReservationListEntry.Flink = NULL;
    pEntry->ReservationListEntry.Blink = NULL;

    //
    // mark it as non-reservation node.
    //

    pEntry->Reservation = FALSE;

    //
    // delete security descriptor.
    //

    ASSERT(pEntry->pSecurityDescriptor != NULL);

    SeReleaseSecurityDescriptor(
        pEntry->pSecurityDescriptor,
        KernelMode,  // always captured in kernel mode
        TRUE         // force capture
        );

    pEntry->pSecurityDescriptor = NULL;

    Status = STATUS_SUCCESS;

    //
    // if it is not a registration node, try to free it.
    //

    if (pEntry->Registration == FALSE)
    {
        Status = UlpTreeFreeNode(pEntry);
    }

    return Status;

} // UlpTreeDeleteReservation


/***************************************************************************++

Routine Description:

    Allocates and initializes a config group object.

Arguments:

    ppObject - gets a pointer to the object on success

--***************************************************************************/
NTSTATUS
UlpCreateConfigGroupObject(
    PUL_CONFIG_GROUP_OBJECT * ppObject
    )
{
    HTTP_CONFIG_GROUP_ID    NewId = HTTP_NULL_ID;
    PUL_CONFIG_GROUP_OBJECT pNewObject = NULL;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppObject != NULL);

    //
    // Create an empty config group object structure - PAGED
    //

    pNewObject = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_CONFIG_GROUP_OBJECT,
                        UL_CG_OBJECT_POOL_TAG
                        );

    if (pNewObject == NULL)
    {
        //
        // Oops.  Couldn't allocate the memory for it.
        //

        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory(pNewObject, sizeof(UL_CONFIG_GROUP_OBJECT));

    //
    // Create an opaque id for it
    //

    Status = UlAllocateOpaqueId(
                    &NewId,                     // pOpaqueId
                    UlOpaqueIdTypeConfigGroup,  // OpaqueIdType
                    pNewObject                  // pContext
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    UlTrace(CONFIG_GROUP_FNC,
            ("http!UlpCreateConfigGroupObject, obj=%p, ID=%I64x\n",
             pNewObject, NewId
             ));

    //
    // Fill in the structure
    //

    pNewObject->Signature                       = UL_CG_OBJECT_POOL_TAG;
    pNewObject->RefCount                        = 1;
    pNewObject->ConfigGroupId                   = NewId;

    pNewObject->AppPoolFlags.Present            = 0;
    pNewObject->pAppPool                        = NULL;

    pNewObject->MaxBandwidth.Flags.Present      = 0;
    pNewObject->MaxConnections.Flags.Present    = 0;
    pNewObject->State.Flags.Present             = 0;
    pNewObject->LoggingConfig.Flags.Present     = 0;
    pNewObject->pLogFileEntry                   = NULL;

    //
    // init the bandwidth throttling flow list
    //
    InitializeListHead(&pNewObject->FlowListHead);

    //
    // init notification entries & head
    //
    UlInitializeNotifyEntry(&pNewObject->HandleEntry, pNewObject);
    UlInitializeNotifyEntry(&pNewObject->ParentEntry, pNewObject);

    UlInitializeNotifyHead(
        &pNewObject->ChildHead,
        &g_pUlNonpagedData->ConfigGroupResource
        );

    //
    // init the url list
    //

    InitializeListHead(&pNewObject->UrlListHead);

    //
    // return the pointer
    //
    *ppObject = pNewObject;

end:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something failed. Let's clean up.
        //

        if (pNewObject != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pNewObject, UL_CG_OBJECT_POOL_TAG);
        }

        if (!HTTP_IS_NULL_ID(&NewId))
        {
            UlFreeOpaqueId(NewId, UlOpaqueIdTypeConfigGroup);
        }
    }

    return Status;

} // UlpCreateConfigGroupObject


/***************************************************************************++

Routine Description:

    This will clean all of the urls in the LIST_ENTRY for the config group

Arguments:

    IN PUL_CONFIG_GROUP_OBJECT pObject  the group to clean the urls for

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCleanAllUrls(
    IN PUL_CONFIG_GROUP_OBJECT pObject
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_CG_LOCK_OWNED_WRITE());

    ASSERT(pObject != NULL);

    UlTrace(CONFIG_GROUP_FNC,
            ("http!UlpCleanAllUrls, obj=%p\n",
             pObject
             ));

    Status = STATUS_SUCCESS;

    //
    // Remove all of the url's associated with this cfg group
    //

    //
    // walk the list
    //

    while (IsListEmpty(&pObject->UrlListHead) == FALSE)
    {
        PUL_CG_URL_TREE_ENTRY pTreeEntry;

        //
        // get the containing struct
        //
        pTreeEntry = CONTAINING_RECORD(
                            pObject->UrlListHead.Flink,
                            UL_CG_URL_TREE_ENTRY,
                            ConfigGroupListEntry
                            );

        ASSERT(IS_VALID_TREE_ENTRY(pTreeEntry) && pTreeEntry->Registration == TRUE);

        //
        // delete it - this unlinks it from the list
        //

        if (NT_SUCCESS(Status))
        {
            Status = UlpTreeDeleteRegistration(pTreeEntry);
        }
        else
        {
            //
            // just record the first error, but still attempt to free all
            //

            UlpTreeDeleteRegistration(pTreeEntry);
        }

    }

    // the list is empty now

    return Status;

} // UlpCleanAllUrls


/***************************************************************************++

Routine Description:

    Removes a site entry's url from the listening endpoint.

    We have to stop listening on another thread because otherwise there 
    will be a deadlock between the config group lock and http connection
    locks.

Arguments:

    pEntry - the site entry

--***************************************************************************/
VOID
UlpDeferredRemoveSite(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    )
{
    PUL_DEFERRED_REMOVE_ITEM pRemoveItem;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT( IS_CG_LOCK_OWNED_WRITE() );
    ASSERT( IS_VALID_TREE_ENTRY(pEntry) );
    ASSERT( pEntry->SiteAddedToEndpoint == TRUE );
    ASSERT( IS_VALID_DEFERRED_REMOVE_ITEM(pEntry->pRemoveSiteWorkItem) );

    pRemoveItem = pEntry->pRemoveSiteWorkItem;

    //
    // Update pEntry.
    //

    pEntry->pRemoveSiteWorkItem = NULL;
    pEntry->SiteAddedToEndpoint = FALSE;

    UlRemoveSite(pRemoveItem);

} // UlpDeferredRemoveSite


/***************************************************************************++

Routine Description:

    Removes a site entry's url from the listening endpoint.

    We have to stop listening on another thread because otherwise there 
    will be a deadlock between the config group lock and http connection
    locks.

Arguments:

    pRemoveItem - the worker item for the removal

--***************************************************************************/
VOID
UlRemoveSite(
    IN PUL_DEFERRED_REMOVE_ITEM pRemoveItem
    )
{
    ASSERT( IS_VALID_DEFERRED_REMOVE_ITEM(pRemoveItem) );

    //
    // Initialize the work item.
    //

    UlInitializeWorkItem(&pRemoveItem->WorkItem);

    //
    // REVIEW: Because UlRemoveSiteFromEndpointList can block
    // REVIEW: indefinitely while waiting for other work items
    // REVIEW: to complete, we must not queue it with UlQueueWorkItem.
    // REVIEW: (could lead to deadlock, esp. in a single-threded queue)
    //

    if (1 == InterlockedIncrement(&g_RemoveSiteCount))
    {
        UlTrace(CONFIG_GROUP_TREE, 
            ("http!UlRemoveSite: Clearing g_RemoveSiteEvent >>>\n" ));

        KeClearEvent(&g_RemoveSiteEvent);
    }

    UL_QUEUE_WAIT_ITEM(
        &pRemoveItem->WorkItem,
        &UlpDeferredRemoveSiteWorker
        );

} // UlRemoveSite


/***************************************************************************++

Routine Description:

    Removes a site entry's url from the listening endpoint.

Arguments:

    pWorkItem - in a UL_DEFERRED_REMOVE_ITEM struct with the endpoint name

--***************************************************************************/
VOID
UlpDeferredRemoveSiteWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS                      Status;
    PUL_DEFERRED_REMOVE_ITEM      pRemoveItem;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( pWorkItem );

    //
    // get the remove item
    //

    pRemoveItem = CONTAINING_RECORD(
                      pWorkItem,
                      UL_DEFERRED_REMOVE_ITEM,
                      WorkItem
                      );

    //
    // Remove the endpoint
    //

    Status = UlRemoveSiteFromEndpointList(
                 pRemoveItem->UrlSecure,
                 pRemoveItem->UrlPort
                 );

    if (!NT_SUCCESS(Status))
    {
        // c'est la vie
        UlTraceError(CONFIG_GROUP_TREE, (
            "http!UlpDeferredRemoveSiteWorker(%s, %d) failed %s\n",
            pRemoveItem->UrlSecure ? "https" : "http",
            pRemoveItem->UrlPort,
            HttpStatusToString(Status)
            ));

        //
        // This is not suppose to happend.  If an error occured, then we
        // could not drop the endpoint usage count.  The endpoint will
        // probably hang around because of it.
        //

        ASSERT(FALSE);
    }

    //
    // Signal we are clear for new endpoint creations.
    //

    if (0 == InterlockedDecrement(&g_RemoveSiteCount))
    {
        UlTrace(CONFIG_GROUP_TREE, 
            ("http!UlpDeferredRemoveSiteWorker: Setting g_RemoveSiteEvent <<<\n" ));

        KeSetEvent(
            &g_RemoveSiteEvent,
            0,
            FALSE
            );
    }

    UL_FREE_POOL_WITH_SIG(pRemoveItem, UL_DEFERRED_REMOVE_ITEM_POOL_TAG);

} // UlpDeferredRemoveSiteWorker


/***************************************************************************++

Routine Description:

    This will return a fresh buffer containing the url sanitized.  caller
    must free this from paged pool.

    CODEWORK: log errors to event log or error log

Arguments:

    IN PUNICODE_STRING pUrl,                    the url to clean

    OUT PWSTR * ppUrl                           the cleaned url

    OUT PUL_CG_URL_TREE_ENTRY_TYPE  pUrlType    Name, Ip, or WildCard site

Return Value:

    NTSTATUS - Completion status.

    STATUS_NO_MEMORY                    the memory alloc failed
    STATUS_INVALID_PARAMETER            malformed URL

--***************************************************************************/
NTSTATUS
UlSanitizeUrl(
    IN  PWCHAR              pUrl,
    IN  ULONG               UrlCharCount,
    IN  BOOLEAN             TrailingSlashRequired,
    OUT PWSTR*              ppUrl,
    OUT PHTTP_PARSED_URL    pParsedUrl
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(UrlCharCount > 0);
    ASSERT(ppUrl != NULL);
    ASSERT(pParsedUrl != NULL);

    *ppUrl = NULL;

    Status = HttpParseUrl(
                    &g_UrlC14nConfig,
                    pUrl,
                    UrlCharCount,
                    TrailingSlashRequired,
                    TRUE,       // Force routing IP to be same as IP literal
                    pParsedUrl
                    );

    if (NT_SUCCESS(Status))
    {
        Status = HttpNormalizeParsedUrl(
                        pParsedUrl,
                        &g_UrlC14nConfig,
                        TRUE,       // Force an allocation
                        FALSE,      // Don't free the original (pUrl->Buffer)
                        TRUE,       // Force routing IP to be same as IP literal
                        PagedPool,
                        URL_POOL_TAG
                        );

        if (NT_SUCCESS(Status))
        {
            *ppUrl = pParsedUrl->pFullUrl;

            ASSERT(NULL != ppUrl);
        }
    }

    RETURN(Status);

} // UlSanitizeUrl


/**************************************************************************++

Routine Description:

    This routine finds a node under a site in the config group tree.  Based
    on the criteria, it can find the longest matching reservation node, 
    longest matching registration node, or longest matching node that is 
    either a registration or a reservation.  This routine always finds the
    exact matching node.

Arguments:

    pSiteEntry - Supplies the site level tree entry.

    pNextToken - Supplies the remaining of the path to be searched.

    Criteria - Supplies the criteria (longest reservation, longest
        registration, or longest reservation or registration.)

    ppMatchEntry - Returns the entry matching the criteria.

    ppExactEntry - Returns the exact matching entry.
 
Return Value:

    STATUS_SUCCESS - if an exact matching entry is found.
    STATUS_OBJECT_NAME_NOT_FOUND - if no exact matching entry found.

Notes:

    If the return code is STATUS_SUCCESS or STATUS_OBJECT_NAME_NOT_FOUND, 
    ppMatchEntry returns a node matching the criteria.

--**************************************************************************/
NTSTATUS
UlpTreeFindNodeHelper(
    IN  PUL_CG_URL_TREE_ENTRY   pSiteEntry,
    IN  PWSTR                   pNextToken,
    IN  ULONG                   Criteria,
    OUT PUL_CG_URL_TREE_ENTRY * ppMatchEntry,
    OUT PUL_CG_URL_TREE_ENTRY * ppExactEntry
    )
{
    NTSTATUS              Status;
    PWSTR                 pToken;
    ULONG                 TokenLength;
    ULONG                 Index;
    PUL_CG_URL_TREE_ENTRY pEntry;
    PUL_CG_URL_TREE_ENTRY pMatch;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_TREE_ENTRY(pSiteEntry));
    ASSERT(pSiteEntry->pParent == NULL);
    ASSERT(pNextToken != NULL);
    ASSERT(ppMatchEntry != NULL || ppExactEntry != NULL);

    //
    // Initialize output arguments.
    //

    if (ppMatchEntry)
    {
        *ppMatchEntry = NULL;
    }

    if (ppExactEntry)
    {
        *ppExactEntry = NULL;
    }

    //
    // Initialize locals.
    //

    pEntry = pSiteEntry;
    pMatch = NULL;
    Status = STATUS_SUCCESS;

    for(;;)
    {
        //
        // A bonafide match?
        //

        if (pEntry->Registration)
        {
            if (Criteria & FNC_LONGEST_REGISTRATION)
            {
                //
                // found a longer registration entry
                //

                pMatch = pEntry;
            }
        }

        if (pEntry->Reservation)
        {
            if (Criteria & FNC_LONGEST_RESERVATION)
            {
                //
                // found a longer reservation entry
                //

                pMatch = pEntry;
            }
        }

        //
        // Are we already at the end of the url?
        //

        if (pNextToken == NULL || *pNextToken == UNICODE_NULL)
        {
            break;
        }

        //
        // find the next token
        //

        pToken = pNextToken;
        pNextToken = wcschr(pNextToken, L'/');

        //
        // can be null if this is a leaf
        //

        if (pNextToken != NULL)
        {
            //
            // replace the '/' with a null, we'll fix it later
            //

            pNextToken[0] = UNICODE_NULL;
            TokenLength = DIFF(pNextToken - pToken) * sizeof(WCHAR);
            pNextToken += 1;
        }
        else
        {
            TokenLength = (ULONG)(wcslen(pToken) * sizeof(WCHAR));
        }

        //
        // match?
        //

        Status = UlpTreeBinaryFindEntry(
                        pEntry->pChildren,
                        pToken,
                        TokenLength,
                        &Index
                        );

        if (pNextToken != NULL)
        {
            //
            // Fix the string, i replaced the '/' with a UNICODE_NULL
            //

            (pNextToken-1)[0] = L'/';
        }

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // it's a sorted tree, the first non-match means we're done
            //

            break;
        }

        //
        // other error?
        //

        if (NT_SUCCESS(Status) == FALSE)
        {
            goto end;
        }

        //
        // found a match, look for deeper matches.
        //

        pEntry = pEntry->pChildren->pEntries[Index].pEntry;

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    }

    //
    // Return results.
    //

    if (ppMatchEntry != NULL)
    {
        *ppMatchEntry = pMatch;
    }

    //
    // pEntry contains exact matching node when NT_SUCCESS(Status) is TRUE.
    //

    if (NT_SUCCESS(Status) && ppExactEntry != NULL)
    {
        *ppExactEntry = pEntry;
    }

 end:

    return Status;

} // UlpTreeFindNodeHelper


/***************************************************************************++

Routine Description:

    walks the tree and find's a matching entry for pUrl.  2 output options,
    you can get the entry back, or a computed URL_INFO with inheritence applied.
    you must free the URL_INFO from NonPagedPool.

Arguments:

    IN PUL_CG_URL_TREE_ENTRY pEntry,            the top of the tree

    IN PWSTR pNextToken,                        where to start looking under
                                                the tree

    IN OUT PUL_URL_CONFIG_GROUP_INFO * ppInfo,  [optional] the info to set,
                                                might have to grow it.

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry         [optional] returns the found
                                                entry

Return Value:

    NTSTATUS - Completion status.

        STATUS_OBJECT_NAME_NOT_FOUND    no entry found

--***************************************************************************/
NTSTATUS
UlpTreeFindNodeWalker(
    IN      PUL_CG_URL_TREE_ENTRY pEntry,
    IN      PWSTR pNextToken,
    IN OUT  PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT     PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    )
{
    NTSTATUS                    Status;
    PUL_CG_URL_TREE_ENTRY       pMatchEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));
    ASSERT(pNextToken != NULL);
    ASSERT(pInfo != NULL || ppEntry != NULL);

    //
    // Initialize locals.
    //

    pMatchEntry = NULL;
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Find a longest matching reservation or registration.
    //

    UlpTreeFindNodeHelper(
        pEntry,
        pNextToken,
        FNC_LONGEST_EITHER,
        &pMatchEntry,
        NULL
        );

    //
    // Return error if a longer reservation is found.
    //

    if (pMatchEntry != NULL && 
        pMatchEntry->Reservation == TRUE &&
        pMatchEntry->Registration == FALSE)
    {
        goto end;
    }

    //
    // did we find a match?
    //

    if (pMatchEntry != NULL)
    {
        ASSERT(pMatchEntry->Registration == TRUE);

        if (pInfo != NULL)
        {
            //
            // Go backwards from the last matched entry and call UlpSetUrlInfo
            // for each Registration entries along the way. If the last matched
            // entry is also the root, we can just reference the
            // UL_CONFIG_GROUP_OBJECT once.
            //

            pEntry = pMatchEntry;

            if (NULL == pEntry->pParent)
            {
                //
                // Special case, add one reference to pEntry->pConfigGroup.
                //

                Status = UlpSetUrlInfoSpecial(pInfo, pEntry);
                ASSERT(NT_SUCCESS(Status));
            }
            else
            {
                while (NULL != pEntry)
                {
                    if (pEntry->Registration == TRUE)
                    {
                        Status = UlpSetUrlInfo(pInfo, pEntry);
                        ASSERT(NT_SUCCESS(Status));
                    }

                    pEntry = pEntry->pParent;
                }
            }

            //
            // Adjust ConnectionTimeout to save an InterlockedCompareExchange64
            // per-request.
            //

            if (pInfo->ConnectionTimeout == g_TM_ConnectionTimeout)
            {
                pInfo->ConnectionTimeout = 0;
            }
        }

        Status = STATUS_SUCCESS;
        if (ppEntry != NULL)
        {
            *ppEntry = pMatchEntry;
        }
    }
    else
    {
        ASSERT(Status == STATUS_OBJECT_NAME_NOT_FOUND || NT_SUCCESS(Status));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

 end:

    UlTraceVerbose(CONFIG_GROUP_TREE,
            ("http!UlpTreeFindNodeWalker(Entry=%p, NextToken='%S', "
             "Info=%p): *ppEntry=%p, %s\n",
             pEntry, pNextToken, pInfo, (ppEntry ? *ppEntry : NULL),
             HttpStatusToString(Status)
            ));

    return Status;

} // UlpTreeFindNodeWalker


/***************************************************************************++

Routine Description:

    walks the tree and find's a matching entry for pUrl.  2 output options,
    you can get the entry back, or a computed URL_INFO with inheritence applied.
    you must free the URL_INFO from NonPagedPool.

Arguments:

    IN PWSTR pUrl,                              the entry to find

    pHttpConn                                   [optional] If non-NULL, use IP of
                                                server to find Node (if not found
                                                on first pass).  This search is done
                                                prior to the Wildcard search.

    OUT PUL_URL_CONFIG_GROUP_INFO * ppInfo,     [optional] will be alloced
                                                and generated.

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry         [optional] returns the found
                                                entry

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindNode(
    IN  PWSTR pUrl,
    IN  PUL_INTERNAL_REQUEST pRequest OPTIONAL,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    )
{
    NTSTATUS                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PWSTR                       pNextToken = NULL;
    PUL_CG_URL_TREE_ENTRY       pEntry = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(pRequest == NULL || UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(pInfo != NULL || ppEntry != NULL);

    //
    // get the strong wildcard match
    //

    if (g_pSites->StrongWildcardCount)
    {
        Status = UlpTreeFindWildcardSite(pUrl, TRUE, &pNextToken, &pEntry);

        if (NT_SUCCESS(Status))
        {
            //
            // and now check in the strong wildcard tree
            //

            Status = UlpTreeFindNodeWalker(pEntry, pNextToken, pInfo, ppEntry);
        }

        UlTrace(CONFIG_GROUP_FNC,
            ("Http!UlpTreeFindNode (StrongWildcardCount) "
             "pUrl:(%S) pNextToken: (%S) Matched (%s)\n",
              pUrl,
              pNextToken,
              NT_SUCCESS(Status) ? "Yes" : "No"
              ));

        //
        // If we found a match or an error (other than "not found") occured,
        // end the search.  Otherwise continue searching.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            goto end;
        }
    }

    //
    // get the Host + Port + IP match
    //

    if (pRequest != NULL && g_pSites->NameIPSiteCount)
    {
        //
        // There is an Name Plus IP Bound Site e.g.
        //     "http://site.com:80:1.1.1.1/"
        // Need to generate the routing token and do the special match.
        //

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        Status = UlGenerateRoutingToken(pRequest, FALSE);

        if (NT_SUCCESS(Status))
        {
            Status = UlpTreeFindSiteIpMatch(
                        pRequest,
                        &pEntry
                        );

            if (NT_SUCCESS(Status))
            {
                //
                // Does it exist in this tree?
                //

                pNextToken = pRequest->CookedUrl.pAbsPath;
                pNextToken++; // Skip the L'/' at the beginnig of Abs Path

                Status = UlpTreeFindNodeWalker(
                             pEntry, 
                             pNextToken,
                             pInfo,
                             ppEntry
                             );
            }

            UlTrace(CONFIG_GROUP_FNC,
                ("Http!UlpTreeFindNode (Host + Port + IP) "
                 "pRoutingToken:(%S) pAbsPath: (%S) Matched: (%s)\n",
                  pRequest->CookedUrl.pRoutingToken,
                  pRequest->CookedUrl.pAbsPath,
                  NT_SUCCESS(Status) ? "Yes" : "No"
                  ));
        }

        //
        // If we found a match or an error (other than "not found") occured,
        // end the search.  Otherwise continue searching.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            goto end;
        }
    }

    //
    // get the Host + Port match ( exact url match )
    //

    if (   g_pSites->NameSiteCount
        || g_pSites->NameIPSiteCount
        || g_pSites->IPSiteCount)
    {
        Status = UlpTreeFindSite(pUrl, &pNextToken, &pEntry);

        if (NT_SUCCESS(Status))
        {
            //
            // does it exist in this tree?
            //

            Status = UlpTreeFindNodeWalker(pEntry, pNextToken, pInfo, ppEntry);
        }

        UlTrace(CONFIG_GROUP_FNC,
            ("Http!UlpTreeFindNode (Host + Port ) "
             "pUrl:(%S) pNextToken: (%S) Matched: (%s)\n",
              pUrl,
              pNextToken,
              NT_SUCCESS(Status) ? "Yes" : "No"
              ));

        //
        // If we found a match or an error (other than "not found") occured,
        // end the search.  Otherwise continue searching.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            goto end;
        }
    }

    //
    // get the IP + Port + IP match
    //

    if (0 != g_pSites->IPSiteCount  &&  NULL != pRequest)
    {
        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        //
        // Didn't find it yet.  See if there is a binding for
        // the IP address & TCP Port on which the request was received.
        //

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        Status = UlGenerateRoutingToken(pRequest, TRUE);

        if (NT_SUCCESS(Status))
        {
            Status = UlpTreeFindSiteIpMatch(
                        pRequest,
                        &pEntry
                        );

            if (NT_SUCCESS(Status))
            {
                pNextToken = pRequest->CookedUrl.pAbsPath;
                pNextToken++; // Skip the L'/' at the beginnig of Abs Path

                //
                // does it exist in *this* tree?
                //

                Status = UlpTreeFindNodeWalker(
                             pEntry,
                             pNextToken,
                             pInfo,
                             ppEntry
                             );
            }
        }

        UlTrace(CONFIG_GROUP_FNC,
            ("Http!UlpTreeFindNode (IP + Port + IP) "
             "pRoutingToken:(%S) pNextToken: (%S) Matched: (%s)\n",
              pRequest->CookedUrl.pRoutingToken,
              pNextToken,
              NT_SUCCESS(Status) ? "Yes" : "No"
              ));

        //
        // If we found a match or an error (other than "not found") occured,
        // end the search.  Otherwise continue searching.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            goto end;
        }
    }

    //
    // shoot, didn't find a match.  let's check wildcards
    //

    if (g_pSites->WeakWildcardCount)
    {
        Status = UlpTreeFindWildcardSite(pUrl, FALSE, &pNextToken, &pEntry);
        if (NT_SUCCESS(Status))
        {
            //
            // and now check in the wildcard tree
            //

            Status = UlpTreeFindNodeWalker(pEntry, pNextToken, pInfo, ppEntry);

        }
        UlTrace(CONFIG_GROUP_FNC,
            ("Http!UlpTreeFindNode (WildcardCount) "
             "pUrl:(%S) pNextToken: (%S) Matched (%s)\n",
              pUrl,
              pNextToken,
              NT_SUCCESS(Status) ? "Yes" : "No"
              ));
    }

 end:
    //
    // all done.
    //

    if (pRequest != NULL && NT_SUCCESS(Status))
    {
        ASSERT(IS_VALID_TREE_ENTRY(pEntry));
        pRequest->ConfigInfo.SiteUrlType = pEntry->UrlType;
    }

    return Status;

} // UlpTreeFindNode


/**************************************************************************++

Routine Description:

    This routine finds a reservation node matching the given url.

Arguments:

    pUrl - Supplies the url.

    ppEntry - Returns the reservation node, if found.

Return Value:

    STATUS_SUCCESS - a matching reservation node is returned.
    STATUS_OBJECT_NAME_NOT_FOUND - no match found.

--**************************************************************************/
NTSTATUS
UlpTreeFindReservationNode(
    IN PWSTR                   pUrl,
    IN PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS              Status;
    PWSTR                 pNextToken;
    PUL_CG_URL_TREE_ENTRY pSiteEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pUrl != NULL);
    ASSERT(ppEntry != NULL);

    //
    // First find the matching site.
    //

    Status = UlpTreeFindSite(pUrl, &pNextToken, &pSiteEntry);

    if (NT_SUCCESS(Status))
    {
        //
        // Now, find a matching reservation entry
        //

        Status = UlpTreeFindNodeHelper(
                     pSiteEntry,
                     pNextToken,
                     FNC_DONT_CARE,
                     NULL,
                     ppEntry
                     );

        if (NT_SUCCESS(Status))
        {
            ASSERT(IS_VALID_TREE_ENTRY(*ppEntry));

            //
            // The node must be a reservation node.
            //

            if ((*ppEntry)->Reservation == FALSE)
            {
                *ppEntry = NULL;
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    }

    return Status;

} // UlpTreeFindReservationNode


/**************************************************************************++

Routine Description:

    This routine finds a matching registation entry for the given url.

Arguments:

    pUrl - Supplies the url to be searched.

    ppEntry - Returns the matching node, if any.

Return Value:

    STATUS_SUCCESS - success.
    STATUS_OBJECT_NAME_NOT_FOUND - no match found.

--**************************************************************************/
NTSTATUS
UlpTreeFindRegistrationNode(
    IN PWSTR                   pUrl,
    IN PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS              Status;
    PWSTR                 pNextToken;
    PUL_CG_URL_TREE_ENTRY pSiteEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pUrl != NULL);
    ASSERT(ppEntry != NULL);

    //
    // First find the site.
    //

    Status = UlpTreeFindSite(pUrl, &pNextToken, &pSiteEntry);

    if (NT_SUCCESS(Status))
    {
        //
        // Now, find the matching registration node.
        //

        Status = UlpTreeFindNodeHelper(
                     pSiteEntry,
                     pNextToken,
                     FNC_DONT_CARE,
                     NULL,
                     ppEntry);

        if (NT_SUCCESS(Status))
        {
            ASSERT(IS_VALID_TREE_ENTRY(*ppEntry));

            //
            // The node must be a registration node.
            //

            if ((*ppEntry)->Registration == FALSE)
            {
                *ppEntry = NULL;
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    }

    return Status;

} // UlpTreeFindRegistrationNode


/***************************************************************************++

Routine Description:

    finds any matching wildcard site in g_pSites for pUrl.

Arguments:

    IN PWSTR pUrl,                          the url to match

    OUT PWSTR * ppNextToken,                output's the next token after
                                            matching the url

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,    returns the entry

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindWildcardSite(
    IN  PWSTR                   pUrl,
    IN  BOOLEAN                 StrongWildcard,
    OUT PWSTR *                 ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS    Status;
    PWSTR       pNextToken;
    ULONG       TokenLength;
    ULONG       Index;
    PWSTR       pPortNum;
    ULONG       PortLength;
    WCHAR       WildSiteUrl[HTTPS_WILD_PREFIX_LENGTH + MAX_PORT_LENGTH + 1];

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(ppNextToken != NULL);
    ASSERT(ppEntry != NULL);

    //
    // find the port #, colon index + 1 (to skip ':') + 2 (to skip "//")
    //

    pPortNum = &pUrl[HTTP_PREFIX_COLON_INDEX + 3];

    if (pPortNum[0] == L'[' || pPortNum[1] == L'[')
    {
        pPortNum = wcschr(pPortNum, L']');

        if (pPortNum == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }
    }

    pPortNum = wcschr(pPortNum, L':');

    if (pPortNum == NULL)
    {
        //
        // ouch
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Skip the ':'
    //

    pPortNum += 1;

    //
    // find the trailing '/' after the port number
    //

    pNextToken = wcschr(pPortNum, L'/');
    if (pNextToken == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    if (DIFF(pNextToken - pPortNum) > MAX_PORT_LENGTH)
    {
        ASSERT(!"port length > MAX_PORT_LENGTH");

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }
    PortLength = DIFF(pNextToken - pPortNum) * sizeof(WCHAR);

    //
    // HTTPS or HTTP?
    //

    if (pUrl[HTTP_PREFIX_COLON_INDEX] == L':')
    {
        RtlCopyMemory(
            WildSiteUrl,
            (StrongWildcard ? HTTP_STRONG_WILD_PREFIX : HTTP_WILD_PREFIX),
            HTTP_WILD_PREFIX_LENGTH
            );

        TokenLength = HTTP_WILD_PREFIX_LENGTH + PortLength;
        ASSERT(TokenLength < (sizeof(WildSiteUrl)-sizeof(WCHAR)));

        RtlCopyMemory(
            &(WildSiteUrl[HTTP_WILD_PREFIX_LENGTH/sizeof(WCHAR)]),
            pPortNum,
            PortLength
            );

        WildSiteUrl[TokenLength/sizeof(WCHAR)] = UNICODE_NULL;
    }
    else
    {
        RtlCopyMemory(
            WildSiteUrl,
            (StrongWildcard ? HTTPS_STRONG_WILD_PREFIX : HTTPS_WILD_PREFIX),
            HTTPS_WILD_PREFIX_LENGTH
            );

        TokenLength = HTTPS_WILD_PREFIX_LENGTH + PortLength;
        ASSERT(TokenLength < (sizeof(WildSiteUrl)-sizeof(WCHAR)));

        RtlCopyMemory(
            &(WildSiteUrl[HTTPS_WILD_PREFIX_LENGTH/sizeof(WCHAR)]),
            pPortNum,
            PortLength
            );

        WildSiteUrl[TokenLength/sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // is there a wildcard entry?
    //

    Status = UlpTreeBinaryFindEntry(
                    g_pSites,
                    WildSiteUrl,
                    TokenLength,
                    &Index
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // return the spot right after the token we just ate
    //

    *ppNextToken = pNextToken + 1;

    //
    // and return the entry
    //

    *ppEntry = g_pSites->pEntries[Index].pEntry;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        *ppEntry = NULL;
        *ppNextToken = NULL;
    }

    return Status;

} // UlpTreeFindWildcardSite


/***************************************************************************++

Routine Description:

    Finds the matching Ip bound site in g_pSites for pUrl.
    It uses the entire pUrl as a site token. pUrl should be null terminated.

    Before you call this function, pRoutingToken in the request should be
    cooked already.

Arguments:

    IN PWSTR pUrl,                          the site to match

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,    returns the entry

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindSiteIpMatch(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG    Index = 0;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(ppEntry != NULL);

    //
    // Find the matching site
    //

    Status = UlpTreeBinaryFindEntry(
                g_pSites,
                pRequest->CookedUrl.pRoutingToken,
                pRequest->CookedUrl.RoutingTokenLength,
                &Index
                );

    if (!NT_SUCCESS(Status))
    {
        *ppEntry = NULL;
    }
    else
    {
        *ppEntry  = g_pSites->pEntries[Index].pEntry;
    }

    return Status;

} // UlpTreeFindSiteIpMatch


/***************************************************************************++

Routine Description:

    This routine finds a site that matches the url.

Arguments:

    pUrl - Supplies the url.

    ppNextToken - Returns a pointer to in the url to the first char after
                  "scheme://host:port:ip/" (including the last /).

    ppEntry - Returns the pointer to the matched site entry.

Return Value:

    NTSTATUS.

--***************************************************************************/
NTSTATUS
UlpTreeFindSite(
    IN  PWSTR                   pUrl,
    OUT PWSTR                 * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS Status;
    ULONG    CharCount;
    ULONG    Index;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pUrl != NULL);
    ASSERT(ppNextToken != NULL);
    ASSERT(ppEntry != NULL);

    //
    // Find the length of "scheme://host:port:ip" section of the url.
    //

    Status = UlpExtractSchemeHostPortIp(pUrl, &CharCount);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Null terminate.  We'll revert the change later.
    //

    ASSERT(pUrl[CharCount] == L'/');

    pUrl[CharCount] = L'\0';

    //
    // Try to find the site.
    //

    Status = UlpTreeBinaryFindEntry(
                 g_pSites,
                 pUrl,
                 CharCount * sizeof(WCHAR), // length in bytes
                 &Index
                 );

    //
    // Put back the slash.
    //

    ASSERT(pUrl[CharCount] == '\0');

    pUrl[CharCount] = L'/';

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    *ppNextToken = &pUrl[CharCount] + 1; // Skip first '/' in abspath.
    *ppEntry     = g_pSites->pEntries[Index].pEntry;

 end:

    if (!NT_SUCCESS(Status))
    {
        *ppNextToken = NULL;
        *ppEntry = NULL;
    }

    return Status;

} // UlpTreeFindSite


/***************************************************************************++

Routine Description:

    walks the sorted children array pHeader looking for a matching entry
    for pToken.

Arguments:

    IN PUL_CG_URL_TREE_HEADER pHeader,  The children array to look in

    IN PWSTR pToken,                    the token to look for

    IN ULONG TokenLength,               the length in bytes of pToken

    OUT ULONG * pIndex                  the found index.  or if not found
                                        the index of the place an entry
                                        with pToken should be inserted.

Return Value:

    NTSTATUS - Completion status.

        STATUS_OBJECT_NAME_NOT_FOUND    didn't find it

--***************************************************************************/
NTSTATUS
UlpTreeBinaryFindEntry(
    IN  PUL_CG_URL_TREE_HEADER pHeader      OPTIONAL,
    IN  PWSTR                  pToken,
    IN  ULONG                  TokenLength,
    OUT PULONG                 pIndex
    )
{
    NTSTATUS Status;
    LONG Index = 0;
    LONG StartIndex = 0;
    LONG EndIndex;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pHeader == NULL || IS_VALID_TREE_HEADER(pHeader));
    ASSERT(pIndex != NULL);

    if (TokenLength == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Assume we didn't find it
    //

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    ASSERT(TokenLength > 0 && pToken != NULL && pToken[0] != UNICODE_NULL);

    //
    // any siblings to search through?
    //

    if (pHeader != NULL)
    {
        //
        // Walk the sorted array looking for a match (binary search)
        //

        StartIndex = 0;
        EndIndex = pHeader->UsedCount - 1;

        while (StartIndex <= EndIndex)
        {
            Index = (StartIndex + EndIndex) / 2;

            ASSERT(IS_VALID_TREE_ENTRY(pHeader->pEntries[Index].pEntry));

            //
            // How does the length compare?
            //

            if (TokenLength == pHeader->pEntries[Index].pEntry->TokenLength)
            {
                //
                // double check with a strcmp just for fun
                //

                int Temp = _wcsnicmp(
                                pToken,
                                pHeader->pEntries[Index].pEntry->pToken,
                                TokenLength/sizeof(WCHAR)
                                );

                if (Temp == 0)
                {
                    //
                    // Found it
                    //
                    Status = STATUS_SUCCESS;
                    break;
                }
                else
                {
                    if (Temp < 0)
                    {
                        //
                        // Adjust StartIndex forward.
                        //
                        StartIndex = Index + 1;
                    }
                    else
                    {
                        //
                        // Adjust EndIndex backward.
                        //
                        EndIndex = Index - 1;
                    }
                }
            }
            else
            {
                if (TokenLength < pHeader->pEntries[Index].pEntry->TokenLength)
                {
                    //
                    // Adjust StartIndex forward.
                    //
                    StartIndex = Index + 1;
                }
                else
                {
                    //
                    // Adjust EndIndex backward.
                    //
                    EndIndex = Index - 1;
                }
            }
        }
    }

    //
    // If an entry was found, then Index is the place where it was present.
    // If no entry was found, then StartIndex is the place where it must
    // be added.
    //

    *pIndex = ((Status == STATUS_SUCCESS) ? Index : StartIndex);

    return Status;

} // UlpTreeBinaryFindEntry


/**************************************************************************++

Routine Description:

    This routine creates and initializes a site for the give url.  There 
    must not be any matching sites already present.

Arguments:

    pUrl - Supplies a url specifying the site to be created.

    UrlType - Supplies the type of the url.

    ppNextToken - Returns a pointer to the unparsed url.

    ppSiteEntry - Returns a pointer to the newly created site.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpTreeCreateSite(
    IN  PWSTR                       pUrl,
    IN  HTTP_URL_SITE_TYPE          UrlType,
    OUT PWSTR *                     ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY     * ppSiteEntry
    )
{
    NTSTATUS              Status;
    PWSTR                 pToken;
    PWSTR                 pNextToken = NULL;
    ULONG                 TokenLength;
    ULONG                 Index;
    ULONG                 CharCount;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(pUrl != NULL);
    ASSERT(ppNextToken != NULL);
    ASSERT(ppSiteEntry != NULL);

    //
    // Find the length of "scheme://host:port[:ip]" prefix in the url.
    //

    Status = UlpExtractSchemeHostPortIp(pUrl, &CharCount);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    pToken = pUrl;
    pNextToken = pUrl + CharCount;

    //
    // Null terminate pToken, we'll fix it later.
    //

    ASSERT(pNextToken[0] == L'/');

    pNextToken[0] = L'\0';

    TokenLength = DIFF(pNextToken - pToken) * sizeof(WCHAR);

    pNextToken += 1;

    //
    // Find the matching site.
    //

    Status = UlpTreeBinaryFindEntry(
                 g_pSites,
                 pToken,
                 TokenLength,
                 &Index
                 );

    if (NT_SUCCESS(Status))
    {
        //
        // We just found a matching site.  Can't create.
        //

        ASSERT(FALSE); // Catch this misuse.

        Status = STATUS_OBJECT_NAME_COLLISION;
        goto end;
    }
    else if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // Create the new site.
        //

        Status = UlpTreeInsertEntry(
                     &g_pSites,
                     NULL,
                     UrlType,
                     pToken,
                     TokenLength,
                     Index
                     );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }
    else if (!NT_SUCCESS(Status))
    {
        //
        // UlpTreeBinaryFindEntry returned an error other than
        // "not found". Bail out.
        //

        goto end;
    }


    //
    // set returns
    //

    *ppSiteEntry = g_pSites->pEntries[Index].pEntry;
    *ppNextToken = pNextToken;


end:

    if (pNextToken != NULL)
    {
        //
        // Fix the string, i replaced the '/' with a UNICODE_NULL
        //

        (pNextToken-1)[0] = L'/';
    }

    if (!NT_SUCCESS(Status))
    {
        *ppSiteEntry = NULL;
        *ppNextToken = NULL;
    }

    return Status;

} // UlpTreeCreateSite


/***************************************************************************++

Routine Description:

    inserts a new entry storing pToken as a child in the array ppHeader.
    it will grow/allocate ppHeader as necessary.

Arguments:

    IN OUT PUL_CG_URL_TREE_HEADER * ppHeader,   the children array (might change)

    IN PUL_CG_URL_TREE_ENTRY pParent,           the parent to set this child to

    IN HTTP_URL_SITE_TYPE        UrlType,       the type of the Url

    IN PWSTR pToken,                            the token of the new entry

    IN ULONG TokenLength,                       token length

    IN ULONG Index                              the index to insert it at.
                                                it will shuffle the array
                                                if necessary.

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY                        allocation failed

--***************************************************************************/
NTSTATUS
UlpTreeInsertEntry(
    IN OUT PUL_CG_URL_TREE_HEADER * ppHeader,
    IN PUL_CG_URL_TREE_ENTRY pParent OPTIONAL,
    IN HTTP_URL_SITE_TYPE        UrlType,
    IN PWSTR pToken,
    IN ULONG TokenLength,
    IN ULONG Index
    )
{
    NTSTATUS Status;
    PUL_CG_URL_TREE_HEADER pHeader = NULL;
    PUL_CG_URL_TREE_ENTRY  pEntry = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_CG_LOCK_OWNED_WRITE());

    ASSERT(ppHeader != NULL);
    ASSERT(pParent == NULL || IS_VALID_TREE_ENTRY(pParent));
    ASSERT(pToken != NULL);
    ASSERT(TokenLength > 0);
    ASSERT(
        (*ppHeader == NULL) ?
        Index == 0 :
        IS_VALID_TREE_HEADER(*ppHeader) && (Index <= (*ppHeader)->UsedCount)
        );

    pHeader = *ppHeader;

    //
    // any existing siblings?
    //

    if (pHeader == NULL)
    {
        //
        // allocate a sibling array
        //

        pHeader = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        PagedPool,
                        UL_CG_URL_TREE_HEADER,
                        sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH,
                        UL_CG_TREE_HEADER_POOL_TAG
                        );

        if (pHeader == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlZeroMemory(
            pHeader,
            sizeof(UL_CG_URL_TREE_HEADER) +
                sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH
            );

        pHeader->Signature = UL_CG_TREE_HEADER_POOL_TAG;
        pHeader->AllocCount = UL_CG_DEFAULT_TREE_WIDTH;

    }
    else if ((pHeader->UsedCount + 1) > pHeader->AllocCount)
    {
        PUL_CG_URL_TREE_HEADER pNewHeader;

        //
        // Grow a bigger array
        //

        pNewHeader = UL_ALLOCATE_STRUCT_WITH_SPACE(
                            PagedPool,
                            UL_CG_URL_TREE_HEADER,
                            sizeof(UL_CG_HEADER_ENTRY) * (pHeader->AllocCount * 2),
                            UL_CG_TREE_HEADER_POOL_TAG
                            );

        if (pNewHeader == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlCopyMemory(
            pNewHeader,
            pHeader,
            sizeof(UL_CG_URL_TREE_HEADER) +
                sizeof(UL_CG_HEADER_ENTRY) * pHeader->AllocCount
            );

        RtlZeroMemory(
            ((PUCHAR)pNewHeader) + sizeof(UL_CG_URL_TREE_HEADER) +
                sizeof(UL_CG_HEADER_ENTRY) * pHeader->AllocCount,
            sizeof(UL_CG_HEADER_ENTRY) * pHeader->AllocCount
            );

        pNewHeader->AllocCount *= 2;

        pHeader = pNewHeader;

    }

    //
    // Allocate an entry
    //

    pEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    UL_CG_URL_TREE_ENTRY,
                    TokenLength + sizeof(WCHAR),
                    UL_CG_TREE_ENTRY_POOL_TAG
                    );

    if (pEntry == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory(
        pEntry,
        sizeof(UL_CG_URL_TREE_ENTRY) +
        TokenLength + sizeof(WCHAR)
        );

    pEntry->Signature           = UL_CG_TREE_ENTRY_POOL_TAG;
    pEntry->pParent             = pParent;
    pEntry->UrlType             = UrlType;
    pEntry->SiteAddedToEndpoint = FALSE;
    pEntry->TokenLength         = TokenLength;

    RtlCopyMemory(pEntry->pToken, pToken, TokenLength + sizeof(WCHAR));

    //
    // need to shuffle things around?
    //

    if (Index < pHeader->UsedCount)
    {
        //
        // shift right the chunk at Index
        //

        RtlMoveMemory(
            &(pHeader->pEntries[Index+1]),
            &(pHeader->pEntries[Index]),
            (pHeader->UsedCount - Index) * sizeof(UL_CG_HEADER_ENTRY)
            );
    }

    pHeader->pEntries[Index].pEntry = pEntry;
    pHeader->UsedCount += 1;

    //
    // update count for different site types
    //

    switch (UrlType)
    {
        case HttpUrlSite_Name:
        {
            pHeader->NameSiteCount++;
            ASSERT(pHeader->NameSiteCount > 0);
            break;
        }

        case HttpUrlSite_IP:
        {
            pHeader->IPSiteCount++;
            ASSERT(pHeader->IPSiteCount > 0);
            break;
        }

        case HttpUrlSite_StrongWildcard:
        {
            pHeader->StrongWildcardCount++;
            ASSERT(pHeader->StrongWildcardCount > 0);
            break;
        }

        case HttpUrlSite_WeakWildcard:
        {
            pHeader->WeakWildcardCount++;
            ASSERT(pHeader->WeakWildcardCount > 0);
            break;
        }

        case HttpUrlSite_NamePlusIP:
        {
            pHeader->NameIPSiteCount++;
            InterlockedIncrement(&g_NameIPSiteCount);
            ASSERT(pHeader->NameIPSiteCount > 0);
            break;
        }

        case HttpUrlSite_None:
        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

    ASSERT(
        pHeader->UsedCount == (ULONG)
        (pHeader->NameSiteCount       +
         pHeader->IPSiteCount         +
         pHeader->StrongWildcardCount +
         pHeader->WeakWildcardCount   +
         pHeader->NameIPSiteCount
        ));

    Status = STATUS_SUCCESS;

    UlTraceVerbose(
        CONFIG_GROUP_TREE, (
            "http!UlpTreeInsertEntry('%S', %lu) %S%S\n",
            pToken, Index,
            (Index < (pHeader->UsedCount - 1)) ? L"[shifted]" : L"",
            (*ppHeader == NULL) ? L"[alloc'd siblings]" : L""
            )
        );

end:
    if (NT_SUCCESS(Status) == FALSE)
    {
        if (*ppHeader != pHeader && pHeader != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pHeader, UL_CG_TREE_HEADER_POOL_TAG);
        }
        if (pEntry != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pEntry, UL_CG_TREE_ENTRY_POOL_TAG);
        }

    }
    else
    {
        //
        // return a new buffer to the caller ?
        //

        if (*ppHeader != pHeader)
        {
            if (*ppHeader != NULL)
            {
                //
                // free the old one
                //

                UL_FREE_POOL_WITH_SIG(*ppHeader, UL_CG_TREE_HEADER_POOL_TAG);

            }

            *ppHeader = pHeader;
        }
    }

    return Status;

} // UlpTreeInsertEntry


/***************************************************************************++

Routine Description:

    Inserts pUrl into the url tree.  returns the inserted entry.

Arguments:

    IN PWSTR pUrl,                          the url to insert

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry     the new entry

Return Value:

    NTSTATUS - Completion status.

        STATUS_ADDRESS_ALREADY_EXISTS       this url is already in the tree

--***************************************************************************/
NTSTATUS
UlpTreeInsert(
    IN  PWSTR                       pUrl,
    IN  HTTP_URL_SITE_TYPE          UrlType,
    IN  PWSTR                       pNextToken,
    IN  PUL_CG_URL_TREE_ENTRY       pEntry,
    OUT PUL_CG_URL_TREE_ENTRY     * ppEntry
    )
{
    NTSTATUS                Status;
    PWSTR                   pToken;
    ULONG                   TokenLength;
    ULONG                   Index;

    UNREFERENCED_PARAMETER(pUrl);

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(g_pSites != NULL);
    ASSERT(IS_CG_LOCK_OWNED_WRITE());

    ASSERT(pUrl != NULL);
    ASSERT(pNextToken != NULL);
    ASSERT(IS_VALID_TREE_ENTRY(pEntry));
    ASSERT(ppEntry != NULL);

    //
    // any abs_path to add also?
    //

    while (pNextToken != NULL && pNextToken[0] != UNICODE_NULL)
    {
        pToken = pNextToken;

        pNextToken = wcschr(pNextToken, L'/');

        //
        // can be null if this is a leaf
        //

        if (pNextToken != NULL)
        {
            pNextToken[0] = UNICODE_NULL;
            TokenLength = DIFF(pNextToken - pToken) * sizeof(WCHAR);
            pNextToken += 1;
        }
        else
        {
            TokenLength = (ULONG)(wcslen(pToken) * sizeof(WCHAR));
        }

        //
        // insert this token as a child
        //

        Status = UlpTreeBinaryFindEntry(
                        pEntry->pChildren,
                        pToken,
                        TokenLength,
                        &Index
                        );

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // no match, let's add this new one
            //

            Status = UlpTreeInsertEntry(
                         &pEntry->pChildren,
                         pEntry,
                         UrlType,
                         pToken,
                         TokenLength,
                         Index
                         );
        }

        if (pNextToken != NULL)
        {
            //
            // fixup the UNICODE_NULL from above
            //

            (pNextToken-1)[0] = L'/';
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        //
        // dive down deeper !
        //

        pEntry = pEntry->pChildren->pEntries[Index].pEntry;

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

        //
        // loop!
        //
    }

    //
    // all done
    //

    Status = STATUS_SUCCESS;

 end:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something failed. Need to clean up the partial branch
        //

        if (pEntry != NULL && pEntry->Registration == FALSE &&
            pEntry->Reservation == FALSE)
        {
            NTSTATUS TempStatus;

            TempStatus = UlpTreeFreeNode(pEntry);
            ASSERT(NT_SUCCESS(TempStatus));
        }

        *ppEntry = NULL;
    }
    else
    {
        *ppEntry = pEntry;
    }

    return Status;

} // UlpTreeInsert


/***************************************************************************++

Routine Description:

    init code.  not re-entrant.

Arguments:

    none.

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY                allocation failed

--***************************************************************************/
NTSTATUS
UlInitializeCG(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( g_InitCGCalled == FALSE );

    if (g_InitCGCalled == FALSE)
    {
        //
        // init our globals
        //

        //
        // Alloc our site array
        //

        g_pSites = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        PagedPool,
                        UL_CG_URL_TREE_HEADER,
                        sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH,
                        UL_CG_TREE_HEADER_POOL_TAG
                        );

        if (g_pSites == NULL)
            return STATUS_NO_MEMORY;

        RtlZeroMemory(
            g_pSites,
            sizeof(UL_CG_URL_TREE_HEADER) +
            sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH
            );

        g_pSites->Signature  = UL_CG_TREE_HEADER_POOL_TAG;
        g_pSites->AllocCount = UL_CG_DEFAULT_TREE_WIDTH;

        g_pSites->NameSiteCount       = 0;
        g_pSites->IPSiteCount         = 0;
        g_pSites->StrongWildcardCount = 0;
        g_pSites->WeakWildcardCount   = 0;
        g_pSites->NameIPSiteCount     = 0;
        g_NameIPSiteCount = 0;

        //
        // init our non-paged entries
        //

        Status = UlInitializeResource(
                        &(g_pUlNonpagedData->ConfigGroupResource),
                        "ConfigGroupResource",
                        0,
                        UL_CG_RESOURCE_TAG
                        );

        if (NT_SUCCESS(Status) == FALSE)
        {
            UL_FREE_POOL_WITH_SIG(g_pSites, UL_CG_TREE_HEADER_POOL_TAG);
            return Status;
        }

        KeInitializeEvent(
            &g_RemoveSiteEvent,
            NotificationEvent,
            FALSE
            );

        //
        // Initialize reservation list.
        //

        InitializeListHead(&g_ReservationListHead);

        g_InitCGCalled = TRUE;
    }

    return STATUS_SUCCESS;

} // UlInitializeCG


/***************************************************************************++

Routine Description:

    termination code

Arguments:

    none.

Return Value:

    none.

--***************************************************************************/
VOID
UlTerminateCG(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_InitCGCalled)
    {
        //
        // Delete all reservation entries.
        //

        CG_LOCK_WRITE();

        while(!IsListEmpty(&g_ReservationListHead))
        {
            PLIST_ENTRY           pListEntry;
            PUL_CG_URL_TREE_ENTRY pTreeEntry;
            NTSTATUS              TempStatus;

            pListEntry = g_ReservationListHead.Flink;

            pTreeEntry = CONTAINING_RECORD(
                             pListEntry,
                             UL_CG_URL_TREE_ENTRY,
                             ReservationListEntry
                             );

            TempStatus = UlpTreeDeleteReservation(pTreeEntry);
            ASSERT(NT_SUCCESS(TempStatus));
        }

        CG_UNLOCK_WRITE();

        Status = UlDeleteResource(&(g_pUlNonpagedData->ConfigGroupResource));
        ASSERT(NT_SUCCESS(Status));

        if (g_pSites != NULL)
        {
            ASSERT( g_pSites->UsedCount == 0 );

            //
            // Nuke the header.
            //

            UL_FREE_POOL_WITH_SIG(
                g_pSites,
                UL_CG_TREE_HEADER_POOL_TAG
                );
        }

        //
        // The tree should be gone, all handles have been closed
        //

        ASSERT(g_pSites == NULL || g_pSites->UsedCount == 0);

        g_InitCGCalled = FALSE;
    }
} // UlTerminateCG


/***************************************************************************++

Routine Description:

    creates a new config group and returns the id

Arguments:

    OUT PUL_CONFIG_GROUP_ID pConfigGroupId      returns the new id

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY                        allocation failed

--***************************************************************************/
NTSTATUS
UlCreateConfigGroup(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroupId
    )
{
    PUL_CONFIG_GROUP_OBJECT pNewObject = NULL;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pControlChannel != NULL);
    ASSERT(pConfigGroupId != NULL);

    UlTrace(CONFIG_GROUP_FNC, ("http!UlCreateConfigGroup\n"));

    __try
    {
        //
        // Create an empty config group object structure - PAGED
        //
        Status = UlpCreateConfigGroupObject(&pNewObject);

        if (!NT_SUCCESS(Status)) {
            goto end;
        }

        //
        // Link it into the control channel
        //

        UlAddNotifyEntry(
            &pControlChannel->ConfigGroupHead,
            &pNewObject->HandleEntry
            );

        //
        // remember the control channel
        //

        REFERENCE_CONTROL_CHANNEL(pControlChannel);
        pNewObject->pControlChannel = pControlChannel;

        //
        // Return the new id.
        //

        *pConfigGroupId = pNewObject->ConfigGroupId;
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }


end:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something failed. Let's clean up.
        //

        HTTP_SET_NULL_ID(pConfigGroupId);

        if (pNewObject != NULL)
        {
            UlDeleteConfigGroup(pNewObject->ConfigGroupId);
        }
    }

    return Status;

} // UlCreateConfigGroup


/***************************************************************************++

Routine Description:

    returns the config group id that matches the config group object linked
    in list_entry

Arguments:

    IN PLIST_ENTRY pControlChannelEntry - the listentry for this config group

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
HTTP_CONFIG_GROUP_ID
UlConfigGroupFromListEntry(
    IN PLIST_ENTRY pControlChannelEntry
    )
{
    PUL_CONFIG_GROUP_OBJECT pObject;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pControlChannelEntry != NULL);

    pObject = CONTAINING_RECORD(
                    pControlChannelEntry,
                    UL_CONFIG_GROUP_OBJECT,
                    ControlChannelEntry
                    );

    ASSERT(IS_VALID_CONFIG_GROUP(pObject));

    return pObject->ConfigGroupId;

} // UlConfigGroupFromListEntry


/***************************************************************************++

Routine Description:

    deletes the config group ConfigGroupId cleaning all of it's urls.

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId     the group to delete

Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER               bad config group id

--***************************************************************************/
NTSTATUS
UlDeleteConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    NTSTATUS Status;
    PUL_CONFIG_GROUP_OBJECT pObject;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(CONFIG_GROUP_FNC,
            ("http!UlDeleteConfigGroup(%I64x)\n",
             ConfigGroupId
             ));

    CG_LOCK_WRITE();

    //
    // Get ConfigGroup from opaque id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)
                UlGetObjectFromOpaqueId(
                    ConfigGroupId,
                    UlOpaqueIdTypeConfigGroup,
                    UlReferenceConfigGroup
                    );

    if (pObject == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    ASSERT(IS_VALID_CONFIG_GROUP(pObject));

    HTTP_SET_NULL_ID(&(pObject->ConfigGroupId));

    //
    // Drop the extra reference as a result of the successful get
    //

    DEREFERENCE_CONFIG_GROUP(pObject);

    //
    // Unlink it from the control channel and parent
    //

    UlRemoveNotifyEntry(&pObject->HandleEntry);
    UlRemoveNotifyEntry(&pObject->ParentEntry);

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache(pObject->pControlChannel);

    //
    // unlink any urls below us
    //
    UlNotifyAllEntries(
        UlNotifyOrphanedConfigGroup,
        &pObject->ChildHead,
        NULL
        );

    //
    // Unlink all of the url's in the config group
    //

    Status = UlpCleanAllUrls(pObject);

    //
    // let the error fall through ....
    //

    //
    // In this case, the config group is going away, which means this site
    // counter block should no longer be returned to the perfmon counters, nor
    // should it prevent addition of another site counter block with the same
    // ID.  Decouple it explicitly here.
    //

    UlDecoupleSiteCounterEntry( pObject );

    //
    // remove the opaque id and its reference
    //

    UlFreeOpaqueId(ConfigGroupId, UlOpaqueIdTypeConfigGroup);

    DEREFERENCE_CONFIG_GROUP(pObject);

    //
    // all done
    //

end:

    CG_UNLOCK_WRITE();
    return Status;

} // UlDeleteConfigGroup


/***************************************************************************++

Routine Description:

    Addref's the config group object

Arguments:

    pConfigGroup - the object to add ref

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlReferenceConfigGroup(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    PUL_CONFIG_GROUP_OBJECT pConfigGroup = (PUL_CONFIG_GROUP_OBJECT) pObject;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    refCount = InterlockedIncrement(&pConfigGroup->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pConfigGroupTraceLog,
        REF_ACTION_REFERENCE_CONFIG_GROUP,
        refCount,
        pConfigGroup,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "http!UlReferenceConfigGroup cgroup=%p refcount=%ld\n",
            pConfigGroup,
            refCount)
        );

} // UlReferenceConfigGroup


/***************************************************************************++

Routine Description:

    Releases the config group object

Arguments:

    pConfigGroup - the object to deref

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDereferenceConfigGroup(
    PUL_CONFIG_GROUP_OBJECT pConfigGroup
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    refCount = InterlockedDecrement( &pConfigGroup->RefCount );

    WRITE_REF_TRACE_LOG(
        g_pConfigGroupTraceLog,
        REF_ACTION_DEREFERENCE_CONFIG_GROUP,
        refCount,
        pConfigGroup,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "http!UlDereferenceConfigGroup cgroup=%p refcount=%ld\n",
            pConfigGroup,
            refCount)
        );

    if (refCount == 0)
    {
        //
        // now it's time to free the object
        //

        // If OpaqueId is non-zero, then refCount should not be zero
        ASSERT(HTTP_IS_NULL_ID(&pConfigGroup->ConfigGroupId));

#if INVESTIGATE_LATER

        //
        // Release the opaque id
        //

        UlFreeOpaqueId(pConfigGroup->ConfigGroupId, UlOpaqueIdTypeConfigGroup);
#endif

        //
        // let the control channel go
        //

        DEREFERENCE_CONTROL_CHANNEL(pConfigGroup->pControlChannel);
        pConfigGroup->pControlChannel = NULL;

        //
        // Release the app pool
        //

        if (pConfigGroup->AppPoolFlags.Present == 1)
        {
            if (pConfigGroup->pAppPool != NULL)
            {
                DEREFERENCE_APP_POOL(pConfigGroup->pAppPool);
                pConfigGroup->pAppPool = NULL;
            }

            pConfigGroup->AppPoolFlags.Present = 0;
        }

        //
        // Release the entire object
        //

        if (pConfigGroup->LoggingConfig.Flags.Present &&
            pConfigGroup->LoggingConfig.LogFileDir.Buffer != NULL)
        {
            UlRemoveLogEntry(pConfigGroup);
        }
        else
        {
            ASSERT( NULL == pConfigGroup->pLogFileEntry );
        }


        //
        // Remove any qos flows for this site. This settings should
        // only exists for the root app's cgroup.
        //

        if (!IsListEmpty(&pConfigGroup->FlowListHead))
        {
            ASSERT(pConfigGroup->MaxBandwidth.Flags.Present);
            UlTcRemoveFlows( pConfigGroup, FALSE );
        }

        // Deref the connection limit stuff
        if (pConfigGroup->pConnectionCountEntry)
        {
            DEREFERENCE_CONNECTION_COUNT_ENTRY(pConfigGroup->pConnectionCountEntry);
        }

        // Check Site Counters object (should have been cleaned up by now)
        ASSERT(!pConfigGroup->pSiteCounters);

        UL_FREE_POOL_WITH_SIG(pConfigGroup, UL_CG_OBJECT_POOL_TAG);
    }
} // UlDereferenceConfigGroup


/***************************************************************************++

Routine Description:

    adds pUrl to the config group ConfigGroupId.

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,    the cgroup id

    IN PUNICODE_STRING pUrl,                  the url. must be null terminated.

    IN HTTP_URL_CONTEXT UrlContext            the context to associate


Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER               bad config group id

--***************************************************************************/
NTSTATUS
UlAddUrlToConfigGroup(
    IN PHTTP_CONFIG_GROUP_URL_INFO pInfo,
    IN PUNICODE_STRING             pUrl,
    IN PACCESS_STATE               AccessState,
    IN ACCESS_MASK                 AccessMask,
    IN KPROCESSOR_MODE             RequestorMode
    )
{
    HTTP_URL_CONTEXT            UrlContext;
    HTTP_CONFIG_GROUP_ID        ConfigGroupId;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_CONFIG_GROUP_OBJECT     pObject = NULL;
    PWSTR                       pNewUrl = NULL;
    BOOLEAN                     LockTaken = FALSE;
    HTTP_PARSED_URL             ParsedUrl;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pInfo != NULL);

    ConfigGroupId = pInfo->ConfigGroupId;
    UrlContext    = pInfo->UrlContext;

    __try
    {
        ASSERT(pUrl != NULL && pUrl->Length > 0 && pUrl->Buffer != NULL);
        ASSERT(pUrl->Buffer[pUrl->Length / sizeof(WCHAR)] == UNICODE_NULL);

        UlTrace(CONFIG_GROUP_FNC,
            ("http!UlAddUrlToConfigGroup('%S' -> %I64x)\n",
             pUrl->Buffer, ConfigGroupId));

        //
        // Clean up the url
        //

        Status = UlSanitizeUrl(
                     pUrl->Buffer,
                     pUrl->Length / sizeof(WCHAR),
                     TRUE,
                     &pNewUrl,
                     &ParsedUrl
                     );

        if (NT_SUCCESS(Status) == FALSE)
        {
            UlTraceError(CONFIG_GROUP_FNC,
                ("http!UlAddUrlToConfigGroup Sanitized Url:'%S' FAILED !\n",
                 pUrl->Buffer));

            goto end;
        }

        UlTrace(CONFIG_GROUP_FNC,
                ("http!UlAddUrlToConfigGroup Sanitized Url:'%S' \n", pNewUrl));

        //
        // Wait for all calls of UlpDeferredRemoveSiteWorker to complete
        // before we add a new Endpoint so we won't run into conflicts
        //

        CG_LOCK_WRITE_SYNC_REMOVE_SITE();
        LockTaken = TRUE;

        if(pInfo->UrlType == HttpUrlOperatorTypeRegistration)
        {
            //
            // Get the object ptr from id
            //

            pObject = (PUL_CONFIG_GROUP_OBJECT)(
                            UlGetObjectFromOpaqueId(
                                ConfigGroupId,
                                UlOpaqueIdTypeConfigGroup,
                                UlReferenceConfigGroup
                                )
                            );

            if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            Status = UlpRegisterUrlNamespace(
                                 &ParsedUrl,
                                 UrlContext,
                                 pObject,
                                 AccessState,
                                 AccessMask,
                                 RequestorMode
                                 );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }
        else if(pInfo->UrlType == HttpUrlOperatorTypeReservation)
        {
            Status = UlpAddReservationEntry(
                         &ParsedUrl,
                         pInfo->pSecurityDescriptor,
                         pInfo->SecurityDescriptorLength,
                         AccessState,
                         AccessMask,
                         RequestorMode,
                         TRUE
                         );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }
        else
        {
            //
            // Unknown operator type.  This should have been caught before.
            //

            ASSERT(FALSE);
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // flush the URI cache.
        // CODEWORK: if we were smarter we could make this more granular
        //

        UlFlushCache(pObject ? pObject->pControlChannel : NULL);
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    if (LockTaken)
    {
        CG_UNLOCK_WRITE();
    }

    if (pNewUrl != NULL)
    {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
        pNewUrl = NULL;
    }

    RETURN(Status);

} // UlAddUrlToConfigGroup


/***************************************************************************++

Routine Description:

    removes pUrl from the url tree (and thus the config group) .

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,    the cgroup id.  ignored.

    IN PUNICODE_STRING pUrl,                the url. must be null terminated.


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveUrlFromConfigGroup(
    IN PHTTP_CONFIG_GROUP_URL_INFO pInfo,
    IN PUNICODE_STRING             pUrl,
    IN PACCESS_STATE               AccessState,
    IN ACCESS_MASK                 AccessMask,
    IN KPROCESSOR_MODE             RequestorMode
    )
{
    NTSTATUS                    Status;
    PUL_CG_URL_TREE_ENTRY       pEntry;
    PWSTR                       pNewUrl = NULL;
    PUL_CONFIG_GROUP_OBJECT     pObject = NULL;
    BOOLEAN                     LockTaken = FALSE;
    HTTP_CONFIG_GROUP_ID        ConfigGroupId;
    HTTP_PARSED_URL             ParsedUrl;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pInfo != NULL);

    ConfigGroupId = pInfo->ConfigGroupId;

    __try
    {
        ASSERT(pUrl != NULL && pUrl->Buffer != NULL && pUrl->Length > 0);
        ASSERT(pUrl->Buffer[pUrl->Length / sizeof(WCHAR)] == UNICODE_NULL);

        UlTrace(CONFIG_GROUP_FNC,
                ("http!UlRemoveUrlFromConfigGroup(%I64x)\n",
                 ConfigGroupId));

        //
        // Cleanup the passed in url
        //

        Status = UlSanitizeUrl(
                     pUrl->Buffer,
                     pUrl->Length / sizeof(WCHAR),
                     TRUE,
                     &pNewUrl,
                     &ParsedUrl
                     );

        if (!NT_SUCCESS(Status))
        {
            //
            // no goto end, resource not grabbed
            //

            UlTraceError(CONFIG_GROUP_FNC,
                ("http!UlRemoveUrlFromConfigGroup: "
                 "Sanitized Url:'%S' FAILED !\n",
                 pUrl->Buffer));

            return Status;
        }

        //
        // grab the lock
        //

        CG_LOCK_WRITE_SYNC_REMOVE_SITE();
        LockTaken = TRUE;

        if (pInfo->UrlType == HttpUrlOperatorTypeRegistration)
        {
            //
            // Lookup the entry in the tree
            //

            Status = UlpTreeFindRegistrationNode(pNewUrl, &pEntry);

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            ASSERT(IS_VALID_TREE_ENTRY(pEntry));

            //
            // Get the object ptr from id
            //

            pObject = (PUL_CONFIG_GROUP_OBJECT)(
                       UlGetObjectFromOpaqueId(
                            ConfigGroupId,
                            UlOpaqueIdTypeConfigGroup,
                            UlReferenceConfigGroup
                            )
                        );

            if (!IS_VALID_CONFIG_GROUP(pObject))
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // Does this tree entry match this config group?
            //

            if (pEntry->pConfigGroup != pObject)
            {
                Status = STATUS_INVALID_OWNER;
                goto end;
            }

            //
            // Everything looks good, free the node!
            //

            Status = UlpTreeDeleteRegistration(pEntry);

            if (!NT_SUCCESS(Status))
            {
                ASSERT(FALSE);
                goto end;
            }

            //
            // flush the URI cache.
            // CODEWORK: if we were smarter we could make this more granular
            //
            UlFlushCache(pObject->pControlChannel);

            //
            // When there are no URLs attached to the cgroup, disable the 
            // logging, if there was logging config for this cgroup.
            //

            if (IsListEmpty(&pObject->UrlListHead) &&
                IS_LOGGING_ENABLED(pObject))
            {
                UlDisableLogEntry(pObject->pLogFileEntry);
            }
        }
        else if (pInfo->UrlType == HttpUrlOperatorTypeReservation)
        {
            //
            // Delete reservation.  No need to flush cache in this case.
            //

            Status = UlpDeleteReservationEntry(
                         &ParsedUrl,
                         AccessState,
                         AccessMask,
                         RequestorMode
                         );
        }
        else
        {
            //
            // Unknown operator type.  This should have been caught before.
            //

            ASSERT(FALSE);
            Status = STATUS_INVALID_PARAMETER;
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }
    //
    // NOTE:  don't do any more cleanup here... put it in freenode.
    // otherwise it won't get cleaned on handle closes.
    //

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    if (LockTaken)
    {
        CG_UNLOCK_WRITE();
    }

    if (pNewUrl != NULL)
    {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
        pNewUrl = NULL;
    }

    return Status;

} // UlRemoveUrlFromConfigGroup


/***************************************************************************++

Routine Description:

    Removes all URLS from the config group.

Arguments:

    ConfigGroupId - Supplies the config group ID.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveAllUrlsFromConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    NTSTATUS                Status;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(CONFIG_GROUP_FNC,
            ("http!UlRemoveAllUrlsFromConfigGroup(%I64x)\n",
             ConfigGroupId
             ));

    //
    // grab the lock
    //

    CG_LOCK_WRITE();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache(pObject->pControlChannel);

    //
    // Clean it.
    //

    Status = UlpCleanAllUrls( pObject );

    if (NT_SUCCESS(Status))
    {
        //
        // When there are no URLs attached to the cgroup, disable the
        // logging, If there was logging config for this cgroup.
        //

        if (IS_LOGGING_ENABLED(pObject))
        {
            UlDisableLogEntry(pObject->pLogFileEntry);
        }
    }

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_WRITE();

    return Status;

} // UlRemoveAllUrlsFromConfigGroup


/***************************************************************************++

Routine Description:

    allows query information for cgroups.  see uldef.h

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,  cgroup id

    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,  what to fetch

    IN PVOID pConfigGroupInformation,       output buffer

    IN ULONG Length,                        length of pConfigGroupInformation

    OUT PULONG pReturnLength OPTIONAL       how much was copied into the
                                            output buffer


Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER            bad cgroup id

        STATUS_BUFFER_OVERFLOW             output buffer too small

        STATUS_INVALID_PARAMETER            invalid infoclass

--***************************************************************************/
NTSTATUS
UlQueryConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;

    UNREFERENCED_PARAMETER(Length);

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pReturnLength != NULL);
    ASSERT(pConfigGroupInformation != NULL);

    //
    // If no buffer is supplied, we are being asked to return the length needed
    //

    if (pConfigGroupInformation == NULL && pReturnLength == NULL)
        return STATUS_INVALID_PARAMETER;

    CG_LOCK_READ();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {
    case HttpConfigGroupBandwidthInformation:
        *((PHTTP_CONFIG_GROUP_MAX_BANDWIDTH)pConfigGroupInformation) = 
                    pObject->MaxBandwidth;

        *pReturnLength = sizeof(HTTP_CONFIG_GROUP_MAX_BANDWIDTH);
        break;

    case HttpConfigGroupConnectionInformation:
        *((PHTTP_CONFIG_GROUP_MAX_CONNECTIONS)pConfigGroupInformation) = 
                    pObject->MaxConnections;

        *pReturnLength = sizeof(HTTP_CONFIG_GROUP_MAX_CONNECTIONS);
        break;

    case HttpConfigGroupStateInformation:
        *((PHTTP_CONFIG_GROUP_STATE)pConfigGroupInformation) = 
                    pObject->State;

        *pReturnLength = sizeof(HTTP_CONFIG_GROUP_STATE);
        break;

    case HttpConfigGroupConnectionTimeoutInformation:
        *((ULONG *)pConfigGroupInformation) =
                    (ULONG)(pObject->ConnectionTimeout / C_NS_TICKS_PER_SEC);

        *pReturnLength = sizeof(ULONG);
        break;

    case HttpConfigGroupAppPoolInformation:
        //
        // this is illegal
        //

        Status = STATUS_INVALID_PARAMETER;
        break;

    default:        
        //
        // Should have been caught in UlQueryConfigGroupIoctl.
        //
        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
        break;

    }

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_READ();
    return Status;

} // UlQueryConfigGroupInformation


/***************************************************************************++

Routine Description:

    allows you to set info for the cgroup.  see uldef.h

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,  cgroup id

    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,  what to fetch

    IN PVOID pConfigGroupInformation,       input buffer

    IN ULONG Length,                        length of pConfigGroupInformation


Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER            bad cgroup id

        STATUS_BUFFER_TOO_SMALL             input buffer too small

        STATUS_INVALID_PARAMETER            invalid infoclass

--***************************************************************************/
NTSTATUS
UlSetConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length,
    IN KPROCESSOR_MODE RequestorMode
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;
    HTTP_CONFIG_GROUP_LOGGING LoggingInfo;
    PHTTP_CONFIG_GROUP_MAX_BANDWIDTH pMaxBandwidth;
    BOOLEAN FlushCache = FALSE;
    PUL_CONTROL_CHANNEL pControlChannel = NULL;

    UNREFERENCED_PARAMETER(Length);

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pConfigGroupInformation);

    CG_LOCK_WRITE();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {
    case HttpConfigGroupAppPoolInformation:
        {
            PHTTP_CONFIG_GROUP_APP_POOL pAppPoolInfo;
            PUL_APP_POOL_OBJECT         pOldAppPool;

            pAppPoolInfo = (PHTTP_CONFIG_GROUP_APP_POOL)pConfigGroupInformation;

            //
            // remember the old app pool if there is one, so we can deref it
            // if we need to
            //
            if (pObject->AppPoolFlags.Present == 1 && pObject->pAppPool != NULL)
            {
                pOldAppPool = pObject->pAppPool;
            }
            else
            {
                pOldAppPool = NULL;
            }

            if (pAppPoolInfo->Flags.Present == 1)
            {
                //
                // ok, were expecting a handle to the file object for the app pool
                //
                // let's open it
                //

                Status = UlGetPoolFromHandle(
                                pAppPoolInfo->AppPoolHandle,
                                UserMode,
                                &pObject->pAppPool
                                );

                if (NT_SUCCESS(Status) == FALSE)
                {
                    goto end;
                }

                pObject->AppPoolFlags.Present = 1;

            }
            else
            {
                pObject->AppPoolFlags.Present = 0;
                pObject->pAppPool = NULL;
            }

            //
            // deref the old app pool
            //
            if (pOldAppPool) {
                DEREFERENCE_APP_POOL(pOldAppPool);
            }

            FlushCache = TRUE;
        }
        break;

    case HttpConfigGroupLogInformation:
        {
            UNICODE_STRING LogFileDir;

            //
            // This CG property is for admins only.
            //
            Status = UlThreadAdminCheck(
                            FILE_WRITE_DATA,
                            RequestorMode,
                            HTTP_CONTROL_DEVICE_NAME
                            );

            if(!NT_SUCCESS(Status))
            {
                goto end;
            }

            pControlChannel = pObject->pControlChannel;
            ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

            //
            // Discard normal logging settings if binary logging is configured.
            // No support for both types working at the same time.
            //

            if (pControlChannel->BinaryLoggingConfig.Flags.Present)
            {
                Status = STATUS_NOT_SUPPORTED;
                goto end;
            }            
            
            RtlInitEmptyUnicodeString(&LogFileDir, NULL, 0);
            RtlZeroMemory(&LoggingInfo, sizeof(LoggingInfo));
                
            __try
            {
                // Copy the input buffer into a local variable. We may
                // overwrite some of the fields.

                LoggingInfo =
                    (*((PHTTP_CONFIG_GROUP_LOGGING)
                                pConfigGroupInformation));

                //
                // Do the range check for the configuration params.
                //

                Status = UlCheckLoggingConfig(NULL, &LoggingInfo);
                if (!NT_SUCCESS(Status))
                {                
                    goto end;
                }

                //
                // If the logging is -being- turned off. Fields other than the
                // LoggingEnabled are discarded. And the directory string might
                // be null, therefore we should only probe it if the logging is
                // enabled.
                //

                if (LoggingInfo.LoggingEnabled)
                {
                    Status =
                        UlProbeAndCaptureUnicodeString(
                            &LoggingInfo.LogFileDir,
                            RequestorMode,
                            &LogFileDir,
                            MAX_PATH
                            );

                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Validity check for the logging directory.
                        //
                        
                        if (!UlIsValidLogDirectory(
                                &LogFileDir,
                                 TRUE,        // UncSupport
                                 FALSE        // SystemRootSupport
                                 ))
                        {
                            Status = STATUS_INVALID_PARAMETER;
                            UlFreeCapturedUnicodeString(&LogFileDir);
                        }    
                    }
                }

            }
            __except( UL_EXCEPTION_FILTER() )
            {
                Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
            }

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            // Now reinit the unicode_strings in LoggingInfo struct
            // to point to the captured one.

            LoggingInfo.LogFileDir = LogFileDir;

            if (pObject->LoggingConfig.Flags.Present)
            {
                // Log settings are being reconfigured

                Status = UlReConfigureLogEntry(
                            pObject,
                            &pObject->LoggingConfig,  // The old config
                            &LoggingInfo              // The new config
                            );
            }
            else
            {
                // Delay the creation until it becomes enabled.

                if (LoggingInfo.LoggingEnabled)
                {
                    Status = UlCreateLogEntry(
                                pObject,
                                &LoggingInfo
                                );
                }                
            }

            // Cleanup the captured LogFileDir.

            UlFreeCapturedUnicodeString(&LogFileDir);
                        
            if ( NT_SUCCESS(Status) )
            {
                FlushCache = TRUE;
            }
        }
        break;

    case HttpConfigGroupBandwidthInformation:
        {
            //
            // This CG property is for admins only.
            //
            Status = UlThreadAdminCheck(
                            FILE_WRITE_DATA,
                            RequestorMode,
                            HTTP_CONTROL_DEVICE_NAME
                            );

            if(!NT_SUCCESS(Status))
            {
                goto end;
            }
            
            pMaxBandwidth = (PHTTP_CONFIG_GROUP_MAX_BANDWIDTH) pConfigGroupInformation;

            //
            // Rate can not be lower than the min allowed.
            //
            if (pMaxBandwidth->MaxBandwidth < HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // Interpret the ZERO as HTTP_LIMIT_INFINITE
            //
            if (pMaxBandwidth->MaxBandwidth == 0)
            {
                pMaxBandwidth->MaxBandwidth = HTTP_LIMIT_INFINITE;
            }

            //
            // But check to see if PSched is installed or not before proceeding.
            // By returning an error here, WAS will raise an event warning but
            // proceed w/o terminating the web server
            //
            if (!UlTcPSchedInstalled())
            {
                NTSTATUS TempStatus;

                if (pMaxBandwidth->MaxBandwidth == HTTP_LIMIT_INFINITE)
                {
                    // By default Config Store has HTTP_LIMIT_INFINITE. Therefore
                    // return success for non-actions to prevent unnecessary event
                    // warnings.

                    Status = STATUS_SUCCESS;
                    goto end;
                }

                //
                // Try to wake up psched state.
                //

                TempStatus = UlTcInitPSched();

                if (!NT_SUCCESS(TempStatus))
                {
                    // There's a BWT limit coming down but PSched is not installed

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    goto end;
                }
            }

            //
            // Create the flow if this is the first time we see Bandwidth set
            // otherwise call reconfiguration for the existing flow. The case
            // that the limit is infinite can be interpreted as BTW  disabled
            //
            if (pObject->MaxBandwidth.Flags.Present &&
                pObject->MaxBandwidth.MaxBandwidth != HTTP_LIMIT_INFINITE)
            {
                //
                // See if there is really a change.
                //                
                if (pMaxBandwidth->MaxBandwidth != pObject->MaxBandwidth.MaxBandwidth)
                {
                    if (pMaxBandwidth->MaxBandwidth != HTTP_LIMIT_INFINITE)
                    {
                        Status = UlTcModifyFlows(
                                    (PVOID) pObject,                // for this site
                                    pMaxBandwidth->MaxBandwidth,    // the new bandwidth
                                    FALSE                           // not global flows
                                    );
                        if (!NT_SUCCESS(Status))
                            goto end;
                    }
                    else
                    {
                        //
                        // Handle BTW disabling by removing the existing flows.
                        //
                        
                        UlTcRemoveFlows((PVOID) pObject, FALSE);
                    }

                    //
                    // Update the config in case of success.
                    //
                    pObject->MaxBandwidth.MaxBandwidth = pMaxBandwidth->MaxBandwidth;
                }
            }
            else
            {
                //
                // Its about time to add the flows for the site entry.
                //
                if (pMaxBandwidth->MaxBandwidth != HTTP_LIMIT_INFINITE)
                {
                    Status = UlTcAddFlows(
                                (PVOID) pObject,
                                pMaxBandwidth->MaxBandwidth,
                                FALSE
                                );

                    if (!NT_SUCCESS(Status))
                        goto end;
                }

                //
                // Success! Remember the bandwidth limit inside the cgroup
                //
                pObject->MaxBandwidth = *pMaxBandwidth;
                pObject->MaxBandwidth.Flags.Present = 1;

                //
                // When the last reference to this  cgroup  released,   corresponding
                // flows are going to be removed.Alternatively flows might be removed
                // by explicitly setting the bandwidth  throttling  limit to infinite
                // or reseting the  flags.present.The latter case  is  handled  above
                // Look at the deref config group for the former.
                //
            }
        }
        break;

    case HttpConfigGroupConnectionInformation:

        //
        // This CG property is for admins only.
        //
        Status = UlThreadAdminCheck(
                        FILE_WRITE_DATA,
                        RequestorMode,
                        HTTP_CONTROL_DEVICE_NAME 
                        );

        if(!NT_SUCCESS(Status))
        {
            goto end;
        }

        pObject->MaxConnections =
            *((PHTTP_CONFIG_GROUP_MAX_CONNECTIONS)pConfigGroupInformation);

        if (pObject->pConnectionCountEntry)
        {
            // Update
            UlSetMaxConnections(
                &pObject->pConnectionCountEntry->MaxConnections,
                 pObject->MaxConnections.MaxConnections
                 );
        }
        else
        {
            // Create
            Status = UlCreateConnectionCountEntry(
                        pObject,
                        pObject->MaxConnections.MaxConnections
                        );
        }
        break;

    case HttpConfigGroupStateInformation:
        {
            PHTTP_CONFIG_GROUP_STATE pCGState =
                ((PHTTP_CONFIG_GROUP_STATE) pConfigGroupInformation);
            HTTP_ENABLED_STATE NewState = pCGState->State;

            if ((NewState != HttpEnabledStateActive)
                && (NewState != HttpEnabledStateInactive))
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }
            else
            {
                pObject->State = *pCGState;

                UlTrace(ROUTING,
                        ("UlSetConfigGroupInfo(StateInfo): obj=%p, "
                         "Flags.Present=%lu, State=%sactive.\n",
                         pObject,
                         (ULONG) pObject->State.Flags.Present,
                         (NewState == HttpEnabledStateActive) ? "" : "in"
                         )); 
            }
        }
        break;

    case HttpConfigGroupSiteInformation:
        {
            PHTTP_CONFIG_GROUP_SITE  pSite;

            if ( pObject->pSiteCounters )
            {
                // ERROR: Site Counters already exist.  Bail out.
                Status = STATUS_OBJECTID_EXISTS;
                goto end;
            }

            pSite = (PHTTP_CONFIG_GROUP_SITE)pConfigGroupInformation;

            Status = UlCreateSiteCounterEntry(
                            pObject,
                            pSite->SiteId
                            );
        }
        break;

    case HttpConfigGroupConnectionTimeoutInformation:
        {
            LONGLONG Timeout;

            Timeout = *((ULONG *)pConfigGroupInformation);

            //
            // NOTE: setting to Zero is OK, since this means 
            // "revert to using control channel default"
            //
            if ( Timeout < 0L || Timeout > 0xFFFF )
            {
                // ERROR: Invalid Connection Timeout value
                // NOTE: 64K seconds ~= 18.2 hours
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // Set the per site Connection Timeout limit override
            //
            pObject->ConnectionTimeout = Timeout * C_NS_TICKS_PER_SEC;
        }
        break;

    default:
        //
        // Should have been caught in UlSetConfigGroupIoctl.
        //
        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //

    if (FlushCache)
    {
        ASSERT(IS_VALID_CONFIG_GROUP(pObject));
        UlFlushCache(pObject->pControlChannel);
    }

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_WRITE();
    return Status;

} // UlSetConfigGroupInformation


/***************************************************************************++

Routine Description:

    applies the inheritence, gradually setting the information from pMatchEntry
    into pInfo.  it only copies present info from pMatchEntry.

    also updates the timestamp info in pInfo.  there MUST be enough space for
    1 more index prior to calling this function.

Notes:
    IMPORTANT: The calling function is walking the tree from bottom to top;
    In order to do inheritance correctly, we should only pickup configuration
    info ONLY if it has not been set in the pInfo object already.

Arguments:

    IN PUL_URL_CONFIG_GROUP_INFO pInfo,     the place to set the info

    IN PUL_CG_URL_TREE_ENTRY pMatchEntry    the entry to use to set it

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetUrlInfo(
    IN OUT PUL_URL_CONFIG_GROUP_INFO pInfo,
    IN PUL_CG_URL_TREE_ENTRY pMatchEntry
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pInfo != NULL && IS_VALID_URL_CONFIG_GROUP_INFO(pInfo));
    ASSERT(IS_VALID_TREE_ENTRY(pMatchEntry));
    ASSERT(pMatchEntry->Registration == TRUE);
    ASSERT(IS_VALID_CONFIG_GROUP(pMatchEntry->pConfigGroup));

    //
    // set the control channel. The current level might
    // not have one (if it's transient), but in that
    // case a parent should have had one.
    //

    if (pMatchEntry->pConfigGroup->pControlChannel) 
    {
        if (!pInfo->pControlChannel)
        {
            pInfo->pControlChannel = 
                pMatchEntry->pConfigGroup->pControlChannel;
        }
    }
    ASSERT(pInfo->pControlChannel);

    if (pMatchEntry->pConfigGroup->AppPoolFlags.Present == 1)
    {
        if (pInfo->pAppPool == NULL)
        {
            pInfo->pAppPool = pMatchEntry->pConfigGroup->pAppPool;
            REFERENCE_APP_POOL(pInfo->pAppPool);
        }
    }

    //
    // url context
    //

    if (!pInfo->UrlInfoSet)
    {
        pInfo->UrlContext   = pMatchEntry->UrlContext;
    }

    if (pMatchEntry->pConfigGroup->MaxBandwidth.Flags.Present == 1)
    {
        if (!pInfo->pMaxBandwidth)
        {
            pInfo->pMaxBandwidth = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pMaxBandwidth);
        }
    }

    if (pMatchEntry->pConfigGroup->MaxConnections.Flags.Present == 1)
    {
        if (!pInfo->pMaxConnections)
        {
            ASSERT(!pInfo->pConnectionCountEntry);
            
            pInfo->pMaxConnections = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pMaxConnections);

            pInfo->pConnectionCountEntry = pMatchEntry->pConfigGroup->pConnectionCountEntry;
            REFERENCE_CONNECTION_COUNT_ENTRY(pInfo->pConnectionCountEntry);
        }
    }

    //
    // Logging Info config can only be set from the Root App of
    // the site. We do not need to keep updating it down the tree
    // Therefore its update is slightly different.
    //

    if (pMatchEntry->pConfigGroup->LoggingConfig.Flags.Present == 1 &&
        pMatchEntry->pConfigGroup->LoggingConfig.LoggingEnabled == TRUE)
    {
        if (!pInfo->pLoggingConfig)
        {
            pInfo->pLoggingConfig = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pLoggingConfig);
        }
    }

    //
    // Site Counter Entry
    //
    if (pMatchEntry->pConfigGroup->pSiteCounters)
    {
        // the pSiteCounters entry will only be set on
        // the "Site" ConfigGroup object.
        if (!pInfo->pSiteCounters)
        {
            UlTrace(PERF_COUNTERS,
                    ("http!UlpSetUrlInfo: pSiteCounters %p set on pInfo %p for SiteId %lu\n",
                    pMatchEntry->pConfigGroup->pSiteCounters,
                    pInfo,
                    pMatchEntry->pConfigGroup->pSiteCounters->Counters.SiteId
                    ));

            pInfo->pSiteCounters = pMatchEntry->pConfigGroup->pSiteCounters;
            pInfo->SiteId = pInfo->pSiteCounters->Counters.SiteId;

            REFERENCE_SITE_COUNTER_ENTRY(pInfo->pSiteCounters);
        }
    }

    //
    // Connection Timeout (100ns Ticks)
    //
    if (0 == pInfo->ConnectionTimeout &&
        pMatchEntry->pConfigGroup->ConnectionTimeout)
    {
        pInfo->ConnectionTimeout = pMatchEntry->pConfigGroup->ConnectionTimeout;
    }

    //
    // Enabled State
    //
    if (pMatchEntry->pConfigGroup->State.Flags.Present == 1)
    {
        if (!pInfo->pCurrentState)
        {
            pInfo->pCurrentState = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pCurrentState);

            //
            // and a copy
            //

            pInfo->CurrentState = pInfo->pCurrentState->State.State;
        }
    }

    UlTraceVerbose(CONFIG_GROUP_TREE, (
            "http!UlpSetUrlInfo: Matching entry(%S) points to cfg group(%p)\n",
            pMatchEntry->pToken,
            pMatchEntry->pConfigGroup
            )
        );

    pInfo->UrlInfoSet = TRUE;

    return STATUS_SUCCESS;

} // UlpSetUrlInfo


/***************************************************************************++

Routine Description:

    Setting the information from pMatchEntry into pInfo.  It only add 1
    reference of pConfigGroup from pMatchEntry without referencing each
    individual fields inside it.

Arguments:

    IN PUL_URL_CONFIG_GROUP_INFO pInfo,     the place to set the info

    IN PUL_CG_URL_TREE_ENTRY pMatchEntry    the entry to use to set it

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetUrlInfoSpecial(
    IN OUT PUL_URL_CONFIG_GROUP_INFO pInfo,
    IN PUL_CG_URL_TREE_ENTRY pMatchEntry
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pInfo != NULL && IS_VALID_URL_CONFIG_GROUP_INFO(pInfo));
    ASSERT(IS_VALID_TREE_ENTRY(pMatchEntry));
    ASSERT(pMatchEntry->Registration == TRUE);
    ASSERT(IS_VALID_CONFIG_GROUP(pMatchEntry->pConfigGroup));

    //
    // set the control channel. The current level might
    // not have one (if it's transient), but in that
    // case a parent should have had one.
    //

    if (pMatchEntry->pConfigGroup->pControlChannel) {
        pInfo->pControlChannel = pMatchEntry->pConfigGroup->pControlChannel;
    }
    ASSERT(pInfo->pControlChannel);

    if (pMatchEntry->pConfigGroup->AppPoolFlags.Present == 1)
    {
        pInfo->pAppPool = pMatchEntry->pConfigGroup->pAppPool;
        REFERENCE_APP_POOL(pInfo->pAppPool);
    }

    //
    // url context
    //

    pInfo->UrlContext   = pMatchEntry->UrlContext;

    //

    if (pMatchEntry->pConfigGroup->MaxBandwidth.Flags.Present == 1)
    {
        pInfo->pMaxBandwidth = pMatchEntry->pConfigGroup;
    }

    if (pMatchEntry->pConfigGroup->MaxConnections.Flags.Present == 1)
    {
        pInfo->pMaxConnections = pMatchEntry->pConfigGroup;
        pInfo->pConnectionCountEntry = pMatchEntry->pConfigGroup->pConnectionCountEntry;
        REFERENCE_CONNECTION_COUNT_ENTRY(pInfo->pConnectionCountEntry);
    }

    //
    // Logging Info config can only be set from the Root App of
    // the site. We do not need to keep updating it down the tree
    // Therefore its update is slightly different.
    //

    if (pMatchEntry->pConfigGroup->LoggingConfig.Flags.Present == 1 &&
        pMatchEntry->pConfigGroup->LoggingConfig.LoggingEnabled == TRUE)
    {
        pInfo->pLoggingConfig = pMatchEntry->pConfigGroup;
    }

    //
    // Site Counter Entry
    //
    if (pMatchEntry->pConfigGroup->pSiteCounters)
    {
        // the pSiteCounters entry will only be set on
        // the "Site" ConfigGroup object.
        UlTrace(PERF_COUNTERS,
                ("http!UlpSetUrlInfoSpecial: pSiteCounters %p set on pInfo %p for SiteId %lu\n",
                pMatchEntry->pConfigGroup->pSiteCounters,
                pInfo,
                pMatchEntry->pConfigGroup->pSiteCounters->Counters.SiteId
                ));

        pInfo->pSiteCounters = pMatchEntry->pConfigGroup->pSiteCounters;
        pInfo->SiteId = pInfo->pSiteCounters->Counters.SiteId;
        REFERENCE_SITE_COUNTER_ENTRY(pInfo->pSiteCounters);
    }

    //
    // Connection Timeout (100ns Ticks)
    //
    if (pMatchEntry->pConfigGroup->ConnectionTimeout)
    {
        pInfo->ConnectionTimeout = pMatchEntry->pConfigGroup->ConnectionTimeout;
    }

    if (pMatchEntry->pConfigGroup->State.Flags.Present == 1)
    {
        pInfo->pCurrentState = pMatchEntry->pConfigGroup;

        //
        // and a copy
        //

        pInfo->CurrentState = pInfo->pCurrentState->State.State;
    }

    UlTraceVerbose(CONFIG_GROUP_TREE, (
            "http!UlpSetUrlInfoSpecial: Matching entry(%S) points to cfg group(%p)\n",
            pMatchEntry->pToken,
            pMatchEntry->pConfigGroup
            )
        );

    //
    // Add a ref to the ConfigGroup if it has been used
    //

    if (pInfo->pMaxBandwidth ||
        pInfo->pMaxConnections ||
        pInfo->pCurrentState ||
        pInfo->pLoggingConfig)
    {
        pInfo->pConfigGroup = pMatchEntry->pConfigGroup;
        REFERENCE_CONFIG_GROUP(pInfo->pConfigGroup);
    }

    pInfo->UrlInfoSet = TRUE;

    return STATUS_SUCCESS;

} // UlpSetUrlInfoSpecial


/***************************************************************************++

Routine Description:

    Caller may asks for config group info for a Url (PWSTR) , this could be in
    an existing request. Then UlpTreeFindNode walks the url tree and builds
    the URL_INFO for the caller.

    When there are IP bound sites in the config group, the routing token
    in the cooked url of the request will be used for cgroup lookup as well
    as the original cooked url in the request.

Arguments:

    IN PWSTR    The Url to fetch the cgroup info for.

    IN PUL_INTERNAL_REQUEST The request to fetch the cgroup info for.OPTIONAL

    OUT PUL_URL_CONFIG_GROUP_INFO The result cgroup info.

    When a pRequest is passed in, it must have a proper pHttpConn.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetConfigGroupInfoForUrl(
    IN  PWSTR pUrl,
    IN  PUL_INTERNAL_REQUEST pRequest,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pInfo != NULL);
    ASSERT(pUrl != NULL);
    ASSERT(pRequest == NULL || UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    UlTrace(CONFIG_GROUP_FNC,
        ("Http!UlGetConfigGroupInfoForUrl pUrl:(%S), pRequest=%p\n",
          pUrl, pRequest
          ));

    //
    // Hold the CG Lock while walking the cgroup tree.
    //

    CG_LOCK_READ();

    Status = UlpTreeFindNode(pUrl, pRequest, pInfo, NULL);

    CG_UNLOCK_READ();

    return Status;

} // UlGetConfigGroupInfoForUrl


/***************************************************************************++

Routine Description:

    Attemtps to see if there's a host plus ip site configured and passed in
    request's url matches with the site.

Arguments:

    pRequest - Request for the lookup

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlLookupHostPlusIPSite(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PUL_CG_URL_TREE_ENTRY pSiteEntry = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // Return quickly if there is not an Host Plus IP Site configured.
    // Don't try to access g_pSites outside of the CG Lock, it may get 
    // freed-up. Use another global counter instead. We need to avoid
    // to acquire the CG lock if there is not any host plus ip site.
    //

    if (g_NameIPSiteCount > 0)
    {        
        if (pRequest->CookedUrl.pQueryString != NULL)
        {
            ASSERT(pRequest->CookedUrl.pQueryString[0] == L'?');
            pRequest->CookedUrl.pQueryString[0] = UNICODE_NULL;
        }

        ASSERT(pRequest->Verb == HttpVerbGET);

        CG_LOCK_READ();

        if (g_pSites->NameIPSiteCount)
        {
            //
            // There is an Name Plus IP Bound Site e.g.
            // "http://site.com:80:1.1.1.1/"
            // Need to generate the routing token and do the special match.
            //

            Status = UlGenerateRoutingToken(pRequest, FALSE);

            if (NT_SUCCESS(Status))
            {
                Status = UlpTreeFindSiteIpMatch(pRequest, &pSiteEntry);

                if (NT_SUCCESS(Status))
                {
                    ASSERT(IS_VALID_TREE_ENTRY(pSiteEntry));

                    if (pSiteEntry->UrlType == HttpUrlSite_NamePlusIP)
                    {
                        UlTrace(CONFIG_GROUP_FNC,
                            ("Http!UlLookupHostPlusIPSite (Host + Port + IP) "
                             "pRoutingToken:(%S) Found: (%s)\n",
                              pRequest->CookedUrl.pRoutingToken,
                              NT_SUCCESS(Status) ? "Yes" : "No"
                              ));
                    }
                    else
                    {
                        //
                        // It's possible that the request may have a host header
                        // identical to an IP address on which a site is
                        // listening to. In that case we should not match this
                        // request with IP based site.
                        //

                        Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    }
                }
            }
        }

        CG_UNLOCK_READ();

        if (pRequest->CookedUrl.pQueryString != NULL)
        {
            pRequest->CookedUrl.pQueryString[0] = L'?';
        }
    }

    return Status;

} // UlLookupHostPlusIPSite


/***************************************************************************++

Routine Description:

    must be called to free the info buffer.

Arguments:

    IN PUL_URL_CONFIG_GROUP_INFO pInfo      the info to free

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlConfigGroupInfoRelease(
    IN PUL_URL_CONFIG_GROUP_INFO pInfo
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if (!IS_VALID_URL_CONFIG_GROUP_INFO(pInfo))
    {
        return STATUS_INVALID_PARAMETER;
    }

    UlTrace(CONFIG_GROUP_FNC, ("http!UlConfigGroupInfoRelease(%p)\n", pInfo));

    if (pInfo->pAppPool != NULL)
    {
        DEREFERENCE_APP_POOL(pInfo->pAppPool);
    }

    if (pInfo->pConfigGroup)
    {
        DEREFERENCE_CONFIG_GROUP(pInfo->pConfigGroup);
    }
    else
    {
        if (pInfo->pMaxBandwidth != NULL)
        {
            DEREFERENCE_CONFIG_GROUP(pInfo->pMaxBandwidth);
        }

        if (pInfo->pMaxConnections != NULL)
        {
            DEREFERENCE_CONFIG_GROUP(pInfo->pMaxConnections);
        }

        if (pInfo->pCurrentState != NULL)
        {
            DEREFERENCE_CONFIG_GROUP(pInfo->pCurrentState);
        }

        if (pInfo->pLoggingConfig != NULL)
        {
            DEREFERENCE_CONFIG_GROUP(pInfo->pLoggingConfig);
        }
    }

    if (pInfo->pSiteCounters != NULL)
    {
        DEREFERENCE_SITE_COUNTER_ENTRY(pInfo->pSiteCounters);
    }

    if (pInfo->pConnectionCountEntry != NULL)
    {
        DEREFERENCE_CONNECTION_COUNT_ENTRY(pInfo->pConnectionCountEntry);
    }

    return STATUS_SUCCESS;

} // UlConfigGroupInfoRelease


/***************************************************************************++

Routine Description:

    Rough equivalent of the asignment operator for safely copying the
    UL_URL_CONFIG_GROUP_INFO object and all of its contained pointers.

Arguments:

    IN pOrigInfo      the info to copy from
    IN OUT pNewInfo   the destination object

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlConfigGroupInfoDeepCopy(
    IN const PUL_URL_CONFIG_GROUP_INFO pOrigInfo,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pNewInfo
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(CONFIG_GROUP_FNC,
            ("http!UlConfigGroupInfoDeepCopy(Orig: %p, New: %p)\n",
            pOrigInfo,
            pNewInfo
            ));

    ASSERT( pOrigInfo != NULL && pNewInfo != NULL );


    if (pOrigInfo->pAppPool != NULL)
    {
        REFERENCE_APP_POOL(pOrigInfo->pAppPool);
    }

    if (pOrigInfo->pMaxBandwidth != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pMaxBandwidth);
    }

    if (pOrigInfo->pMaxConnections != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pMaxConnections);
    }

    if (pOrigInfo->pCurrentState != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pCurrentState);
    }

    if (pOrigInfo->pLoggingConfig != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pLoggingConfig);
    }

    // UL_SITE_COUNTER_ENTRY
    if (pOrigInfo->pSiteCounters != NULL)
    {
        REFERENCE_SITE_COUNTER_ENTRY(pOrigInfo->pSiteCounters);
    }

    if (pOrigInfo->pConnectionCountEntry != NULL)
    {
        REFERENCE_CONNECTION_COUNT_ENTRY(pOrigInfo->pConnectionCountEntry);
    }

    //
    // Copy the old stuff over
    //

    RtlCopyMemory(
        pNewInfo,
        pOrigInfo,
        sizeof(UL_URL_CONFIG_GROUP_INFO)
        );

    //
    // Make sure we unset pConfigGroup since we have referenced all individual
    // fields inside UL_CONFIG_GROUP_OBJECT.
    //

    pNewInfo->pConfigGroup = NULL;

    return STATUS_SUCCESS;

} // UlConfigGroupInfoDeepCopy


/***************************************************************************++

Routine Description:

    This function gets called when a static config group's control channel
    goes away, or when a transient config group's app pool or static parent
    goes away.

    Deletes the config group.

Arguments:

    pEntry - A pointer to HandleEntry or ParentEntry.
    pHost - Pointer to the config group
    pv - unused

--***************************************************************************/
BOOLEAN
UlNotifyOrphanedConfigGroup(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    )
{
    PUL_CONFIG_GROUP_OBJECT pObject = (PUL_CONFIG_GROUP_OBJECT) pHost;

    UNREFERENCED_PARAMETER(pEntry);
    UNREFERENCED_PARAMETER(pv);

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pEntry);
    ASSERT(IS_VALID_CONFIG_GROUP(pObject));

    UlDeleteConfigGroup(pObject->ConfigGroupId);

    return TRUE;

} // UlNotifyOrphanedConfigGroup


/**************************************************************************++

Routine Description:

    It returns the number of characters that form the
    "scheme://host:port:ip" portion of the input url.  The ip component
    is optional.  Even though the routine does minimal checking of the url,
    the caller must sanitize the url before calling this function.

Arguments:

    pUrl - Supplies the url to parse.
    pCharCount - Returns the number of chars that form the prefix.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpExtractSchemeHostPortIp(
    IN  PWSTR  pUrl,
    OUT PULONG pCharCount
    )
{
    PWSTR pToken;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pUrl != NULL);
    ASSERT(pCharCount != NULL);

    //
    // Initialize output argument.
    //

    *pCharCount = 0;

    //
    // Find the "://" after scheme name.
    //

    pToken = wcschr(pUrl, L':');

    if (pToken == NULL || pToken[1] != L'/' || pToken[2] != L'/')
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Skip "://".
    //

    pToken += 3;

    //
    // Find the closing '/'.
    //

    pToken = wcschr(pToken, L'/');

    if (pToken == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *pCharCount = (ULONG)(pToken - pUrl);

    return STATUS_SUCCESS;

} // UlpExtractSchemeHostPort


/***************************************************************************++

[design notes]


[url format]

url format = http[s]://[ ip-address|hostname|* :port-number/ [abs_path] ]

no escaping is allowed.

[caching cfg group info]
the tree was designed for quick lookup, but it is still costly to do the
traversal.  so the cfg info for an url was designed to be cached and stored
in the actual response cache, which will be able to be directly hashed into.

this is the fast fast path.

in order to do this, the buffer for is allocated in non-paged pool.  the
timestamp for each cfg group used to build the info (see building the url
info) is remembered in the returned struct.  actually just indexes into the
global timestamp array are kept.  the latest timestamp is then stored in the
struct itself.

later, if a cfg group is updated, the timestamp for that cfg group (in the
global array) is updated to current time.

if a request comes in, and we have a resposne cache hit, the driver will
check to see if it's cfg group info is stale.  this simple requires scanning
the global timestamp array to see if any stamps are greater than the stamp
in the struct.  this is not expensive .  1 memory lookup per level of url
depth.

this means that the passive mode code + dispatch mode code contend for the
timestamp spinlock.  care is made to not hold this lock long.  memory
allocs + frees are carefully moved outside the spinlocks.

care is also made as to the nature of tree updates + invalidating cached
data.  to do this, the parent cfg group (non-dummy) is marked dirty.  this
is to prevent the case that a new child cfg group is added that suddenly
affects an url it didn't effect before.  image http://paul.com:80/ being
the only registered cfg group.  a request comes in for /images/1.jpg.
the matching cfg group is that root one.  later, a /images cfg group
is created.  it now is a matching cfg group for that url sitting in the
response cache.  thus needs to be invalidated.


[paging + irq]
the entire module assumes that it is called at IRQ==PASSIVE except for the
stale detection code.

this code accesses the timestamp array (see caching cfg group info) which
is stored in non-paged memory and synch'd with passive level access
using a spinlock.


[the tree]

the tree is made up of headers + entries.  headers represent a group of entries
that share a parent.  it's basically a length prefixed array of entries.

the parent pointer is in the entry not the header, as the entry does not really
now it's an element in an array.

entries have a pointer to a header that represents it's children.  a header is
all of an entries children.  headers don't link horizontally.  they dyna-grow.
if you need to add a child to an entry, and his children header is full, boom.
gotta realloc to grow .

each node in the tree represents a token in a url, the things between the '/'
characters.

the entries in a header array are sorted.  today they are sorted by their hash
value.  this might change if the tokens are small enough, it's probably more
expensive to compute the hash value then just strcmp.  the hash is 2bytes.  the
token length is also 2bytes so no tokens greater than 32k.

i chose an array at first to attempt to get rid of right-left pointers.  it
turned out to be futile as my array is an array of pointers.  it has to be
an array of pointers as i grow + shrink it to keep it sorted.  so i'm not
saving memory.  however, as an array of pointers, it enables a binary search
as the array is sorted.  this yields log(n) perf on a width search.

there are 2 types of entries in the tree.  dummy entries and full url entries.
a full url is the leaf of an actual entry to UlAddUrl... dummy nodes are ones
that are there only to be parents to full url nodes.

dummy nodes have 2 ptrs + 2 ulongs.
full urls nodes have an extra 4 ptrs.

both store the actual token along with the entry. (unicode baby.  2 bytes per char).

at the top of the tree are sites.  these are stored in a global header as siblings
in g_pSites.  this can grow quite wide.

adding a full url entry creates the branch down to the entry.

deleting a full entry removes as far up the branch as possible without removing other
entries parents.

delete is also careful to not actually delete if other children exist.  in this case
the full url entry is converted to a dummy node entry.

it was attempted to have big string url stored in the leaf node and the dummy nodes
simply point into this string for it's pToken.  this doesn't work as the dummy nodes
pointers become invalid if the leaf node is later deleted.  individual ownership of
tokens is needed to allow shared parents in the tree, with arbitrary node deletion.

an assumption throughout this code is that the tree is relatively static.  changes
don't happen that often.  basically inserts only on boot.  and deletes only on
shutdown.  this is why single clusters of siblings were chosen, as opposed to linked
clusters.  children group width will remain fairly static meaning array growth is
rare.

[is it a graph or a tree?]
notice that the cfg groups are stored as a simple list with no relationships.  its
the urls that are indexed with their relations.

so the urls build a tree, however do to the links from url to cfg group, it kind
of builds a graph also.   2 urls can be in the same cfg group.  1 url's child
can be in the same cfg group as the original url's parent.

when you focus on the actual url tree, it becomes less confusing.  it really is a
tree.  there can even be duplicates in the inheritence model, but the tree cleans
everything.

example of duplicates:

cgroup A = a/b + a/b/c/d
cgroup B = a/b/c

this walking the lineage branch for a/b/c/d you get A, then B, and A again.  nodes
lower in the tree override parent values, so in this case A's values override B's .

[recursion]



[a sample tree]

server runs sites msw and has EVERY directory mapped to a cfg groups (really obscene)

<coming later>



[memory assumptions with the url tree]

[Paged]
    a node per token in the url.  2 types.  dummy nodes + leaf nodes.

    (note: when 2 sizes are given, the second size is the sundown size)

    dummy node = 4/6 longs
    leaf node  = 8/14 longs
    + each node holds 2 * TokenLength+1 for the token.
    + each cluster of siblings holds 2 longs + 1/2 longs per node in the cluster.

[NonPaged]

    2 longs per config group


[assume]
    sites
        max 100k
        average <10
        assume 32 char hostname

    max apps per site
        in the max case : 2 (main + admin)
        in the avg case : 10
        max apps        : 1000s (in 1 site)
        assume 32 char app name

(assume just hostheader access for now)

[max]

    hostname strings = 100000*((32+1)*2)   =  6.6 MB
    cluster entries  = 100000*8*4          =  3.2 MB
    cluster header   = 1*(2+(1*100000))*4  =   .4 MB
    total                                  = 10.2 MB

    per site:
    app strings      = 2*((32+1)*2)        =  132 B
    cluster entries  = 2*8*4               =   64 B
    cluster header   = 1*(2+(1*2))*4       =   16 B
                     = 132 + 64 + 16       =  212 B
    total            = 100000*(212)        = 21.2 MB

    Paged Total      = 10.2mb + 21.2mb     = 31.4 MB
    NonPaged Total   = 200k*2*4            =  1.6 MB

[avg]

    hostname strings = 10*((32+1)*2)       =  660 B
    cluster entries  = 10*8*4              =  320 B
    cluster header   = 1*(2+(1*10))*4      =   48 B
    total                                  = 1028 B

    per site:
    app strings      = 10*((32+1)*2)       =  660 B
    cluster entries  = 10*8*4              =  320 B
    cluster header   = 1*(2+(1*10))*4      =   48 B
    total            = 10*(1028)           = 10.2 KB

    Paged Total      = 1028b + 10.2lKB     = 11.3 KB
    NonPaged Total   = 110*2*4             =  880 B

note: can we save space by refcounting strings.  if all of these
100k have apps with the same name, we save massive string space.
~13MB .

[efficiency of the tree]

    [lookup]

    [insert]

    [delete]

    [data locality]

[alterates investigated to the tree]

hashing - was pretty much scrapped due to the longest prefix match issue.
basically to hash, we would have to compute a hash for each level in
the url, to see if there is a match.  then we have the complete list
of matches.  assuming an additive hash, the hash expense could be
minimized, but the lookup still requires cycles.


alpha trie  - was expense for memory.  however the tree we have though
is very very similar to a trie.  each level of the tree is a token,
however, not a letter.


[building the url info]

the url info is actually built walking down the tree.  for each match
node, we set the info.  this allows for the top-down inheritence.
we also snapshot the timestamp offsets for each matching node in the
tree as we dive down it (see caching) .

this dynamic building of an urls' match was chosen over precomputing
every possible config through the inheritence tree.  each leaf node
could have stored a cooked version of this, but it would have made
updates a bear.  it's not that expensive to build it while we walk down
as we already visit each node in our lineage branch.

[locking]

2 locks are used in the module.  a spinlock to protect the global
timestamp array, and a resource to protect both the cgroup objects
and the url tree (which links to the cgroup objects) .

the spinlock is sometimes acquired while the resource is locked,
but never vice-versa.  also, while the spinlock is held, very
little is done, and definetly no other locks are contended.

1 issue here is granularity of contention.  currently the entire
tree + object list is protected with 1 resource, which is reader
writer.  if this is a perf issue, we can look into locking single
lineage branches (sites) .


[legal]
> 1 cfg groups in an app pool
children cfg groups with no app pool (they inherit)
children cfg groups with no max bandwitdth (they inherit)
children cfg groups with no max connections (they inherit)
* for a host name
fully qualified url of for http[s]://[host|*]:post/[abs_path]/
must have trailing slash if not pting to a file
only 1 cfg group for the site AND the root url.  e.g. http://foo.com:80/
allow you to set config on http:// and https:// for "root" config info

[not legal]
an url in > 1 cfg group
> 1 app pools for 1 cfg group
> 1 root cfg group
* embedded anywhere in the url other than replacing a hostname
query strings in url's.
url's not ending in slash.




--***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\cgroup.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    cgroup.h

Abstract:

    The public definition of config group interfaces.

Author:

    Paul McDaniel (paulmcd)       11-Jan-1999


Revision History:

--*/


#ifndef _CGROUP_H_
#define _CGROUP_H_


//
// Forwarders.
//

typedef struct _UL_CONNECTION_COUNT_ENTRY   *PUL_CONNECTION_COUNT_ENTRY;
typedef struct _UL_CG_URL_TREE_HEADER       *PUL_CG_URL_TREE_HEADER;
typedef struct _UL_CG_URL_TREE_ENTRY        *PUL_CG_URL_TREE_ENTRY;
typedef struct _UL_CONTROL_CHANNEL          *PUL_CONTROL_CHANNEL;
typedef struct _UL_APP_POOL_OBJECT          *PUL_APP_POOL_OBJECT;
typedef struct _UL_INTERNAL_RESPONSE        *PUL_INTERNAL_RESPONSE;
typedef struct _UL_LOG_FILE_ENTRY           *PUL_LOG_FILE_ENTRY;
typedef struct _UL_SITE_COUNTER_ENTRY       *PUL_SITE_COUNTER_ENTRY;
typedef struct _UL_HTTP_CONNECTION          *PUL_HTTP_CONNECTION;
typedef struct _UL_INTERNAL_REQUEST         *PUL_INTERNAL_REQUEST;

//
// Kernel mode mappings to the user mode set defined in HttpP.w
//

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlCreateConfigGroup(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    OUT HTTP_CONFIG_GROUP_ID * pConfigGroupId
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlDeleteConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlAddUrlToConfigGroup(
    IN PHTTP_CONFIG_GROUP_URL_INFO pInfo,
    IN PUNICODE_STRING             pUrl,
    IN PACCESS_STATE               pAccessState,
    IN ACCESS_MASK                 AccessMask,
    IN KPROCESSOR_MODE             RequestorMode
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlRemoveUrlFromConfigGroup(
    IN PHTTP_CONFIG_GROUP_URL_INFO pInfo,
    IN PUNICODE_STRING             pUrl,
    IN PACCESS_STATE               AccessState,
    IN ACCESS_MASK                 AccessMask,
    IN KPROCESSOR_MODE             RequestorMode
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlRemoveAllUrlsFromConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlQueryConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlSetConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length,
    IN KPROCESSOR_MODE RequestorMode
    );

//
// This structure represents an internal cfg group object.  These are linked
// and owned by control channels via a LIST_ENTRY list.
//

#define IS_VALID_CONFIG_GROUP(pObject)                  \
    HAS_VALID_SIGNATURE(pObject, UL_CG_OBJECT_POOL_TAG)


typedef struct _UL_CONFIG_GROUP_OBJECT
{

    //
    // PagedPool
    //

    ULONG                           Signature;          // UL_CG_OBJECT_POOL_TAG

    LONG                            RefCount;

    HTTP_CONFIG_GROUP_ID            ConfigGroupId;

    ULONG                           SiteId;

    UL_NOTIFY_ENTRY                 HandleEntry;        // Links us to an apool or
                                                        // control channel handle

    UL_NOTIFY_ENTRY                 ParentEntry;        // Links transient groups
                                                        // to their static parents

    UL_NOTIFY_HEAD                  ChildHead;          // Links transient children
                                                        // into this group

    LIST_ENTRY                      ControlChannelEntry;// Links into the
                                                        // control channel

    PUL_CONTROL_CHANNEL             pControlChannel;    // the control channel

    LIST_ENTRY                      UrlListHead;        // Links UL_CG_URL_TREE_ENTRY
                                                        // into this group

    HTTP_PROPERTY_FLAGS             AppPoolFlags;
    PUL_APP_POOL_OBJECT             pAppPool;           // Maps to our app
                                                        // pool.

    HTTP_CONFIG_GROUP_MAX_BANDWIDTH MaxBandwidth;       // Applies all the flows below

    LIST_ENTRY                      FlowListHead;       // Links our flows to us so we can
                                                        // do a faster lookup and cleanup.

    HTTP_CONFIG_GROUP_MAX_CONNECTIONS MaxConnections;

    PUL_CONNECTION_COUNT_ENTRY      pConnectionCountEntry;

    HTTP_CONFIG_GROUP_STATE         State;              // The current state
                                                        // (active, etc.)

    HTTP_CONFIG_GROUP_LOGGING       LoggingConfig;      // logging config for the
                                                        // sites root app.                                                            

    PUL_LOG_FILE_ENTRY              pLogFileEntry;



    PUL_SITE_COUNTER_ENTRY          pSiteCounters;      // Perfmon Counters (ref'd)

    LONGLONG                        ConnectionTimeout;  // Connection Timeout override
                                                        // in 100ns ticks


} UL_CONFIG_GROUP_OBJECT, *PUL_CONFIG_GROUP_OBJECT;

//
// Public functions for config group objects:
//

//
// IRQL == PASSIVE_LEVEL
//

VOID
UlReferenceConfigGroup(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_CONFIG_GROUP( pConfigGroup )                              \
    UlReferenceConfigGroup(                                                 \
        (pConfigGroup)                                                      \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// IRQL == PASSIVE_LEVEL
//

VOID
UlDereferenceConfigGroup(
    PUL_CONFIG_GROUP_OBJECT pConfigGroup
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_CONFIG_GROUP( pConfigGroup )                            \
    UlDereferenceConfigGroup(                                               \
        (pConfigGroup)                                                      \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// IRQL == PASSIVE_LEVEL
//
HTTP_CONFIG_GROUP_ID
UlConfigGroupFromListEntry(
    IN PLIST_ENTRY pControlChannelEntry
    );



//
// This info is built for an URL, and returned from UlGetConfigGroupForUrl
//

#define IS_VALID_URL_CONFIG_GROUP_INFO(pInfo)               \
    HAS_VALID_SIGNATURE(pInfo, UL_CG_URL_INFO_POOL_TAG)

typedef struct _UL_URL_CONFIG_GROUP_INFO
{
    //
    // NonPagedPool
    //

    //
    // UL_CG_URL_INFO_POOL_TAG
    //

    ULONG                       Signature;

    //
    // Set if we have applied UlpSetUrlInfo on this object.
    //

    BOOLEAN                     UrlInfoSet;

    //
    // used by the http engine routing to the app pool, no
    // need to be live.  copies work great.
    //

    HTTP_ENABLED_STATE          CurrentState;   // a copy of the above, for
                                                // callers that don't need
                                                // live access
    PUL_CONTROL_CHANNEL         pControlChannel;

    HTTP_URL_CONTEXT            UrlContext;     // The context for the url.
                                                // NULL = not set

    PUL_APP_POOL_OBJECT         pAppPool;       // Points the app pool
                                                // associated with this url

    //
    // The matching UL_CONFIG_GROUP_OBJECT. If pConfigGroup is not NULL,
    // this means we only take 1 reference of pConfigGroup but no individual
    // references are taken for pMaxBandwidth, pMaxConnections, pCurrentState
    // and pLoggingConfig.
    //

    PUL_CONFIG_GROUP_OBJECT     pConfigGroup;

    //
    // used by the cache mgr and need to be live from the
    // real config group objects
    //

    PUL_CONFIG_GROUP_OBJECT     pMaxBandwidth;
    PUL_CONFIG_GROUP_OBJECT     pMaxConnections;
    PUL_CONFIG_GROUP_OBJECT     pCurrentState;
    PUL_CONFIG_GROUP_OBJECT     pLoggingConfig;

    PUL_CONNECTION_COUNT_ENTRY  pConnectionCountEntry;

    //
    // Site Counters (ref'd)
    //

    ULONG                       SiteId;
    PUL_SITE_COUNTER_ENTRY      pSiteCounters;

    //
    // Connection Timeout (100ns Ticks)
    //

    LONGLONG                    ConnectionTimeout;

    //
    // Used to determine the binding type of the site that this request
    // is being routed to.
    //
    
    HTTP_URL_SITE_TYPE          SiteUrlType;
    

} UL_URL_CONFIG_GROUP_INFO, *PUL_URL_CONFIG_GROUP_INFO;

//
// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlGetConfigGroupInfoForUrl(
    IN  PWSTR pUrl,  
    IN  PUL_INTERNAL_REQUEST pRequest,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo
    );

//
// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlInitializeCG(
    VOID
    );

VOID
UlTerminateCG(
    VOID
    );

BOOLEAN
UlNotifyOrphanedConfigGroup(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    );

//
// IRQL == PASSIVE_LEVEL
//
__inline
VOID
UlInitializeUrlInfo(
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo
    )
{
    ASSERT(pInfo != NULL);

    RtlZeroMemory(
        (PCHAR)pInfo,
        sizeof(UL_URL_CONFIG_GROUP_INFO)
        );

    pInfo->Signature    = UL_CG_URL_INFO_POOL_TAG;
    pInfo->CurrentState = HttpEnabledStateInactive;
}

NTSTATUS
UlConfigGroupInfoRelease(
    IN PUL_URL_CONFIG_GROUP_INFO pInfo
    );

NTSTATUS
UlConfigGroupInfoDeepCopy(
    IN const PUL_URL_CONFIG_GROUP_INFO pOrigInfo,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pNewInfo
    );

NTSTATUS
UlLookupHostPlusIPSite(
    IN PUL_INTERNAL_REQUEST pRequest
    );

NTSTATUS
UlSanitizeUrl(
    IN  PWCHAR              pUrl,
    IN  ULONG               UrlCharCount,
    IN  BOOLEAN             TrailingSlashRequired,
    OUT PWSTR*              ppUrl,
    OUT PHTTP_PARSED_URL    pParsedUrl
    );

//
// This entry is used to remove a url from endpoint list.
//

typedef struct _UL_DEFERRED_REMOVE_ITEM
{
    ULONG        Signature;

    //
    // Url scheme and port to remove from endpoint.
    // CODEWORK: Change BOOLEAN for scheme when more protocols are supported.
    //

    BOOLEAN      UrlSecure;
    USHORT       UrlPort;

    // Actual work item.
    UL_WORK_ITEM WorkItem;

} UL_DEFERRED_REMOVE_ITEM, *PUL_DEFERRED_REMOVE_ITEM;

#define IS_VALID_DEFERRED_REMOVE_ITEM(p) \
    ((p) && (p)->Signature == UL_DEFERRED_REMOVE_ITEM_POOL_TAG)

VOID
UlRemoveSite(
    IN PUL_DEFERRED_REMOVE_ITEM pRemoveItem
    );

//
// Small macro which tells whether bandwidth throttling is enabled or not.
//

#define BWT_ENABLED_FOR_CGROUP(pCGroup)                             \
    ((pCGroup) != NULL &&                                           \
     (pCGroup)->MaxBandwidth.Flags.Present != 0 &&                  \
     (pCGroup)->MaxBandwidth.MaxBandwidth != HTTP_LIMIT_INFINITE)


#endif // _CGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\clientconnp.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    clientconnp.h

Abstract:

    Contains the private definitions for the client connection structure.

Author:

    Henry Sanders (henrysa)         10-Aug-2000

Revision History:

--*/

#ifndef _CLIENTCONN_P_H_
#define _CLIENTCONN_P_H_
                                       
//
// Forward references.
//


//
// Private constants.
//


//
// Private types.
//

//
// Private prototypes.
//




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\clientconn.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    clientconn.c

Abstract:

    Contains the code for the client-side HTTP connection stuff.
    
Author:
    
    Henry  Sanders  (henrysa)     14-Aug-2000
    Rajesh Sundaram (rajeshsu)    01-Oct-2000

Revision History:

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, UcInitializeClientConnections )
#pragma alloc_text( PAGE, UcTerminateClientConnections )
#pragma alloc_text( PAGE, UcpTerminateClientConnectionsHelper )
#pragma alloc_text( PAGE, UcOpenClientConnection )

#pragma alloc_text( PAGEUC, UcSendRequestOnConnection )
#pragma alloc_text( PAGEUC, UcCancelSentRequest )
#pragma alloc_text( PAGEUC, UcRestartMdlSend )
#pragma alloc_text( PAGEUC, UcpRestartEntityMdlSend )
#pragma alloc_text( PAGEUC, UcIssueRequests )
#pragma alloc_text( PAGEUC, UcIssueEntities )
#pragma alloc_text( PAGEUC, UcpCleanupConnection )
#pragma alloc_text( PAGEUC, UcRestartClientConnect )
#pragma alloc_text( PAGEUC, UcpCancelPendingRequest )
#pragma alloc_text( PAGEUC, UcSendEntityBody )
#pragma alloc_text( PAGEUC, UcReferenceClientConnection )
#pragma alloc_text( PAGEUC, UcDereferenceClientConnection )
#pragma alloc_text( PAGEUC, UcpConnectionStateMachineWorker )
#pragma alloc_text( PAGEUC, UcKickOffConnectionStateMachine )
#pragma alloc_text( PAGEUC, UcComputeHttpRawConnectionLength )
#pragma alloc_text( PAGEUC, UcGenerateHttpRawConnectionInfo )
#pragma alloc_text( PAGEUC, UcServerCertificateInstalled )
#pragma alloc_text( PAGEUC, UcConnectionStateMachine )
#pragma alloc_text( PAGEUC, UcpInitializeConnection )
#pragma alloc_text( PAGEUC, UcpOpenTdiObjects )
#pragma alloc_text( PAGEUC, UcpFreeTdiObject )
#pragma alloc_text( PAGEUC, UcpAllocateTdiObject )
#pragma alloc_text( PAGEUC, UcpPopTdiObject )
#pragma alloc_text( PAGEUC, UcpPushTdiObject )
#pragma alloc_text( PAGEUC, UcpCheckForPipelining )
#pragma alloc_text( PAGEUC, UcClearConnectionBusyFlag )
#pragma alloc_text( PAGEUC, UcAddServerCertInfoToConnection )
#pragma alloc_text( PAGEUC, UcpCompareServerCert )
#pragma alloc_text( PAGEUC, UcpFindRequestToFail )

#endif

//
// Cache of UC_CLIENT_CONNECTIONS
//

#define NUM_ADDRESS_TYPES  2
#define ADDRESS_TYPE_TO_INDEX(addrtype)  ((addrtype) == TDI_ADDRESS_TYPE_IP6)


LIST_ENTRY      g_ClientTdiConnectionSListHead[NUM_ADDRESS_TYPES];
#define G_CLIENT_TDI_CONNECTION_SLIST_HEAD(addrtype)  \
            (g_ClientTdiConnectionSListHead[ADDRESS_TYPE_TO_INDEX(addrtype)])


UL_SPIN_LOCK    g_ClientConnSpinLock[NUM_ADDRESS_TYPES];
#define G_CLIENT_CONN_SPIN_LOCK(addrtype) \
            (g_ClientConnSpinLock[ADDRESS_TYPE_TO_INDEX(addrtype)])

USHORT g_ClientConnListCount[NUM_ADDRESS_TYPES];
#define G_CLIENT_CONN_LIST_COUNT(addrtype) \
            (&g_ClientConnListCount[ADDRESS_TYPE_TO_INDEX(addrtype)])


TA_IP_ADDRESS      g_LocalAddressIP;
TA_IP6_ADDRESS     g_LocalAddressIP6;
PTRANSPORT_ADDRESS g_LocalAddresses[NUM_ADDRESS_TYPES];
#define G_LOCAL_ADDRESS(addrtype) \
            (g_LocalAddresses[ADDRESS_TYPE_TO_INDEX(addrtype)])


ULONG   g_LocalAddressLengths[NUM_ADDRESS_TYPES];
#define G_LOCAL_ADDRESS_LENGTH(addrtype) \
            (g_LocalAddressLengths[ADDRESS_TYPE_TO_INDEX(addrtype)])

NPAGED_LOOKASIDE_LIST   g_ClientConnectionLookaside;
BOOLEAN                 g_ClientConnectionInitialized;


/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcInitializeClientConnections(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize our various free lists etc.
    //

    InitializeListHead(
        &G_CLIENT_TDI_CONNECTION_SLIST_HEAD(TDI_ADDRESS_TYPE_IP)
        );

    InitializeListHead(
        &G_CLIENT_TDI_CONNECTION_SLIST_HEAD(TDI_ADDRESS_TYPE_IP6)
        );

    UlInitializeSpinLock(
        &G_CLIENT_CONN_SPIN_LOCK(TDI_ADDRESS_TYPE_IP),
        "g_ClientConnSpinLock"
        );
    UlInitializeSpinLock(
        &G_CLIENT_CONN_SPIN_LOCK(TDI_ADDRESS_TYPE_IP6),
        "g_ClientConnSpinLock"
        );

    //
    // Initialize the client lookaside list.
    //

    ExInitializeNPagedLookasideList(
        &g_ClientConnectionLookaside,
        NULL,
        NULL,
        0,
        sizeof(UC_CLIENT_CONNECTION),
        UC_CLIENT_CONNECTION_POOL_TAG,
        0
        );

    g_ClientConnectionInitialized = TRUE;


    //
    // Initialize our local address object. This is an addrss object with
    // a wildcard address (0 IP, 0 port) that we use for outgoing requests.
    //

    g_LocalAddressIP.TAAddressCount                 = 1;
    g_LocalAddressIP.Address[0].AddressLength       = TDI_ADDRESS_LENGTH_IP;
    g_LocalAddressIP.Address[0].AddressType         = TDI_ADDRESS_TYPE_IP;
    g_LocalAddressIP.Address[0].Address[0].sin_port = 0;
    g_LocalAddressIP.Address[0].Address[0].in_addr  = 0;

    g_LocalAddressIP6.TAAddressCount                 = 1;
    g_LocalAddressIP6.Address[0].AddressLength       = TDI_ADDRESS_LENGTH_IP6;
    g_LocalAddressIP6.Address[0].AddressType         = TDI_ADDRESS_TYPE_IP6;
    RtlZeroMemory(&g_LocalAddressIP6.Address[0].Address[0],
                  sizeof(TDI_ADDRESS_IP6));

    G_LOCAL_ADDRESS(TDI_ADDRESS_TYPE_IP) =
        (PTRANSPORT_ADDRESS)&g_LocalAddressIP;
    G_LOCAL_ADDRESS(TDI_ADDRESS_TYPE_IP6) =
        (PTRANSPORT_ADDRESS)&g_LocalAddressIP6;

    G_LOCAL_ADDRESS_LENGTH(TDI_ADDRESS_TYPE_IP) = sizeof(g_LocalAddressIP);
    G_LOCAL_ADDRESS_LENGTH(TDI_ADDRESS_TYPE_IP6) = sizeof(g_LocalAddressIP6);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Performs termination of a Client TDI connections slist.

Return Value:

   None.

--***************************************************************************/
VOID
UcpTerminateClientConnectionsHelper(
    IN USHORT           AddressType
    )
{
    PLIST_ENTRY      pListHead;
    PUC_TDI_OBJECTS  pTdiObject;
    PLIST_ENTRY      pListEntry;

    pListHead =  &G_CLIENT_TDI_CONNECTION_SLIST_HEAD(AddressType);

    //
    // Sanity check.
    //

    PAGED_CODE();

    // 
    // Since this is called from the unload thread, there can't be any other
    // thread, so we don't have to take the spin lock.
    //

    while(!IsListEmpty(pListHead))
    {
        pListEntry = RemoveHeadList(pListHead);

        pTdiObject = CONTAINING_RECORD(
                            pListEntry,
                            UC_TDI_OBJECTS,
                            Linkage
                            );

        (*G_CLIENT_CONN_LIST_COUNT(AddressType))--;

        UcpFreeTdiObject(pTdiObject);
    }

    ASSERT(*G_CLIENT_CONN_LIST_COUNT(AddressType) == 0);
}


/***************************************************************************++

Routine Description:

    Performs global termination of this module.

Return Value:

    None.

--***************************************************************************/
VOID
UcTerminateClientConnections(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if(g_ClientConnectionInitialized)
    {
        UcpTerminateClientConnectionsHelper(
            TDI_ADDRESS_TYPE_IP
            );

        UcpTerminateClientConnectionsHelper(
            TDI_ADDRESS_TYPE_IP6
            );

        ExDeleteNPagedLookasideList(&g_ClientConnectionLookaside);
    }
}
                                                                               

/***************************************************************************++

Routine Description:

    Opens an HTTP connection. The HTTP connection will have a TDI connection
    object associated with it and that object will itself be associated
    with our address object. 

Arguments:

    pHttpConnection     - Receives a pointer to the HTTP connection object.
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcOpenClientConnection(
    IN  PUC_PROCESS_SERVER_INFORMATION pInfo,
    OUT PUC_CLIENT_CONNECTION         *pUcConnection
    )
{
    NTSTATUS                  Status;
    PUC_CLIENT_CONNECTION     pConnection;
                                                                               
    //                                                                         
    // Sanity check.                                                           
    //                                                                         
                                                                               
    PAGED_CODE();                                                              

    *pUcConnection = NULL;

                                                                               
    //
    // Try to snag a connection from the global pool.                          
    //

    pConnection = (PUC_CLIENT_CONNECTION)
                    ExAllocateFromNPagedLookasideList(
                        &g_ClientConnectionLookaside
                        );

    if(pConnection)
    {
        //
        // One time connection initialization.
        //

        pConnection->Signature  = UC_CLIENT_CONNECTION_SIGNATURE;
    
        UlInitializeSpinLock(&pConnection->SpinLock, "Uc Connection Spinlock");
    
        InitializeListHead(&pConnection->PendingRequestList);
        InitializeListHead(&pConnection->SentRequestList);
        InitializeListHead(&pConnection->ProcessedRequestList);

        UlInitializeWorkItem(&pConnection->WorkItem);
        pConnection->bWorkItemQueued  = 0;
    
        pConnection->RefCount         = 0;
        pConnection->Flags            = 0;
        pConnection->pEvent           = NULL;

        // Server Cert Info initialization
        RtlZeroMemory(&pConnection->ServerCertInfo,
                      sizeof(pConnection->ServerCertInfo));

        CREATE_REF_TRACE_LOG( pConnection->pTraceLog, 
                              96 - REF_TRACE_OVERHEAD, 
                              0,
                              TRACELOG_LOW_PRIORITY,
                              UL_REF_TRACE_LOG_POOL_TAG );


        //
        // Initialize this connection.
        //

        Status = UcpInitializeConnection(pConnection, pInfo);

        if(!NT_SUCCESS(Status))
        {
            DESTROY_REF_TRACE_LOG( pConnection->pTraceLog,
                                   UL_REF_TRACE_LOG_POOL_TAG);

            ExFreeToNPagedLookasideList(
                        &g_ClientConnectionLookaside,
                        pConnection
                        );

            return Status;
        }

        pConnection->ConnectionState = UcConnectStateConnectIdle;
        pConnection->SslState        = UcSslStateNoSslState;
        pConnection->pTdiObjects     = NULL;

        REFERENCE_CLIENT_CONNECTION(pConnection);
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
        
    *pUcConnection = pConnection;
    
    return Status;
}


/***************************************************************************++

Routine Description:

    Checks if we can pipeline.

Arguments:

    pConnection     - Receives a pointer to the HTTP connection object.
    
Return Value:

    TRUE  - Yes, we can send the next request.
    FALSE - No, cannot.

--***************************************************************************/
BOOLEAN
UcpCheckForPipelining(
    IN PUC_CLIENT_CONNECTION pConnection
    )
{
    PUC_HTTP_REQUEST    pPendingRequest, pSentRequest;
    PLIST_ENTRY         pSentEntry, pPendingEntry;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );
    ASSERT( UlDbgSpinLockOwned(&pConnection->SpinLock) );
    ASSERT( !IsListEmpty(&pConnection->PendingRequestList) );

    // If the remote server supports pipeling and this request does also 
    // or the sent request list is empty, go ahead and send it.

    if( IsListEmpty(&pConnection->SentRequestList) )
    {
        // Sent List is empty, we can send.

        return TRUE;
    }
    else 
    {
        pPendingEntry = pConnection->PendingRequestList.Flink;
    
        pPendingRequest = CONTAINING_RECORD(pPendingEntry,
                                            UC_HTTP_REQUEST,
                                            Linkage
                                            );
        pSentEntry = pConnection->SentRequestList.Flink;
    
        pSentRequest = CONTAINING_RECORD(pSentEntry,
                                         UC_HTTP_REQUEST,
                                         Linkage
                                         );
        
        ASSERT(UC_IS_VALID_HTTP_REQUEST(pPendingRequest));
        ASSERT(UC_IS_VALID_HTTP_REQUEST(pSentRequest));

        if(pConnection->pServerInfo->pNextHopInfo->Version11 &&
           pPendingRequest->RequestFlags.PipeliningAllowed &&
           pSentRequest->RequestFlags.PipeliningAllowed
           )
        {
            ASSERT(pSentRequest->RequestFlags.NoRequestEntityBodies);
            ASSERT(pPendingRequest->RequestFlags.NoRequestEntityBodies);
            ASSERT(pSentRequest->DontFreeMdls == 0);

            return TRUE;
        }
    }

    return FALSE;
}


/***************************************************************************++

Routine Description:

    Send a request on a client connection. We've given a connection (which 
    must be referenced when we're called) and a request. The connection may
    or may not be established. We'll queue the request to the connection, then
    figure out the state of the connection. If it's not connected we'll get 
    a connection going. If it is connected then we determine if it's ok to
    send the request now or not.
                        
Arguments:

    pConnection         - Pointer to the connection structure on which we're
                            sending.
    
    pRequest            - Pointer to the request we're sending.                            
Return Value:

    NTSTATUS - Status of attempt to send the request.


--***************************************************************************/
NTSTATUS
UcSendRequestOnConnection(
    PUC_CLIENT_CONNECTION   pConnection, 
    PUC_HTTP_REQUEST        pRequest,
    KIRQL                   OldIrql)
{
    BOOLEAN             RequestCancelled;
    PUC_HTTP_REQUEST    pHeadRequest;
    PLIST_ENTRY         pEntry;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    pEntry = pConnection->PendingRequestList.Flink;

    pHeadRequest = CONTAINING_RECORD(pEntry,
                                     UC_HTTP_REQUEST,
                                     Linkage);
    
    ASSERT(UC_IS_VALID_HTTP_REQUEST(pHeadRequest));

    //
    // We will call UcSendRequestOnConnection only if 
    //  a. The request is not buffered OR
    //  b. The request is buffered & we've seen the last entity.
    //
    // For case a, we might not have seen all the entity body. 
    // but we still want to send since we know the content-length.

    ASSERT(!pRequest->RequestFlags.RequestBuffered ||
           (pRequest->RequestFlags.RequestBuffered && 
            pRequest->RequestFlags.LastEntitySeen));

    // Check the state. If it's connected, we may be able to send the request
    // right now. We can send only if we are the "head" request on the list.

    if (
        // Connection is still active
        pConnection->ConnectionState == UcConnectStateConnectReady 

        &&

        // No one else is sending
        !(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY) 

        &&

        // We are the head request on this list
        (pRequest == pHeadRequest) 

        && 
    
        // pipelining is OK
        UcpCheckForPipelining(pConnection) 

        )
    {
        // It's OK to send now.

        IoMarkIrpPending(pRequest->RequestIRP);

        UcIssueRequests(pConnection, OldIrql);

        return STATUS_PENDING;
    }

    // 
    // We can't send now, so leave it queued. Since we're leaving this request 
    // queued set it up for cancelling now. 
    //

    RequestCancelled = UcSetRequestCancelRoutine(
                        pRequest, 
                        UcpCancelPendingRequest
                        );

    if (RequestCancelled)
    {
        
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_CANCELLED,
            pConnection,
            pRequest,
            pRequest->RequestIRP,
            UlongToPtr((ULONG)STATUS_CANCELLED)
            );

        IoMarkIrpPending(pRequest->RequestIRP);

        pRequest->RequestIRP = NULL;

        //
        // Remove this request from the pending list, so that other threads
        // don't land up sending it.
        //
        RemoveEntryList(&pRequest->Linkage);
        InitializeListHead(&pRequest->Linkage);
    
        //
        // Make sure that any new API calls for this request ID are failed.
        //

        UcSetFlag(&pRequest->RequestFlags.Value, UcMakeRequestCancelledFlag());
    
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        return STATUS_PENDING;
    }

    IoMarkIrpPending(pRequest->RequestIRP);

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_QUEUED,
        pConnection,
        pRequest,
        pRequest->RequestIRP,
        UlongToPtr((ULONG)STATUS_PENDING)
        );

    //
    // If connection is not ready & if we are the "head" request, then
    // we kick off the connection state machine.
    //

    if (pConnection->ConnectionState != UcConnectStateConnectReady && 
        pRequest == pHeadRequest
        )
    {
        UcConnectionStateMachine(pConnection, OldIrql);
    }
    else
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }
    
    return STATUS_PENDING;
}


/***************************************************************************++

Routine Description:

    Cancel a pending request that caused a connection. This routine is called
    when we're canceling a request that's on the pending list and we've got a
    connect IRP outstanding.

Arguments:

    pDeviceObject           - Pointer to device object.
    Irp                     - Pointer to IRP being canceled.

Return Value:



--***************************************************************************/
VOID
UcCancelSentRequest(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    )
{   
    PUC_HTTP_REQUEST       pRequest;
    PUC_CLIENT_CONNECTION  pConnection;
    KIRQL                  OldIrql;
    LONG                   OldReceiveBusy;

    UNREFERENCED_PARAMETER(pDeviceObject);

    // Release the cancel spin lock, since we're not using it.

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Retrieve the pointers we need. The request pointer is stored inthe
    // driver context array, and a back pointer to the connection is stored
    // in the request. Whoever set the cancel routine is responsible for
    // referencing the connection for us.

    pRequest = (PUC_HTTP_REQUEST) Irp->Tail.Overlay.DriverContext[0];

    pConnection = pRequest->pConnection;

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    OldReceiveBusy = InterlockedExchange(
                         &pRequest->ReceiveBusy,
                         UC_REQUEST_RECEIVE_CANCELLED
                         );

    if(OldReceiveBusy == UC_REQUEST_RECEIVE_BUSY ||
       OldReceiveBusy == UC_REQUEST_RECEIVE_CANCELLED)
    {
        // The cancel routine fired when the request was being parsed. We'll
        // just postpone the cancel - The receive thread will pick it up 
        // later.

        pRequest->RequestIRP = Irp;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_CLEAN_PENDED,
            pConnection,
            pRequest,
            Irp,
            UlongToPtr((ULONG)STATUS_CANCELLED)
            );

        return;
    }

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_CANCELLED,
        pConnection,
        pRequest,
        Irp,
        UlongToPtr((ULONG)STATUS_CANCELLED)
        );

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    //
    // IF we are here, then we are guaranteed that our send has completed.
    // But, the app could have asked us not to free the MDL chain (because of 
    // SSPI auth). In such cases, we have to free it here.
    //
    // If the SSPI worker thread kicks in, then we'll just fail it.
    //

    UcFreeSendMdls(pRequest->pMdlHead);

    pRequest->pMdlHead = NULL;
    pRequest->RequestIRP = NULL;

    //
    // Note: We cannot just call UcFailRequest from here. UcFailRequest
    // is supposed to be called when a request is failed (e.g. parseer
    // error) or canceled (HttpCancelRequest API) & hence has code to 
    // not double complete the IRP if the cancel routine kicked in.
    // 
    // Since we are the IRP cancel routine,  we  have to manually
    // complete the IRP. An IRP in this state has not hit the wire.
    // so, we just free send MDLs & cancel it. Note that we call 
    // UcFailRequest to handle common IRP cleanup.  
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->RequestorMode   = pRequest->AppRequestorMode;
    Irp->MdlAddress      = pRequest->AppMdl;

    UcSetFlag(&pRequest->RequestFlags.Value,  UcMakeRequestCancelledFlag());

    UcFailRequest(pRequest, STATUS_CANCELLED, OldIrql);

    // For the IRP
    UC_DEREFERENCE_REQUEST(pRequest);

    UlCompleteRequest(Irp, IO_NO_INCREMENT);
}


/*********************************************************************++

Routine Description:

    This is our send request complete routine. 
            
Arguments:

    pDeviceObject           - The device object we called.
    pIrp                    - The IRP that is completing.
    Context                 - Our context value, a pointer to a request 
                                structure.
    
Return Value:

    NTSTATUS - MORE_PROCESSING_REQUIRED if this isn't to be completed now,
                SUCCESS otherwise.
                
--*********************************************************************/
VOID
UcRestartMdlSend(
    IN PVOID      pCompletionContext,
    IN NTSTATUS   Status,
    IN ULONG_PTR  Information
    )
{
    PUC_HTTP_REQUEST          pRequest;
    PUC_CLIENT_CONNECTION     pConnection;
    KIRQL                     OldIrql;
    BOOLEAN                   RequestCancelled;
    PIRP                      pIrp;

    UNREFERENCED_PARAMETER(Information);

    pRequest      = (PUC_HTTP_REQUEST) pCompletionContext;
    pConnection   = pRequest->pConnection;


    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_SEND_COMPLETE,
        pConnection,
        pRequest,
        pRequest->RequestIRP,
        UlongToPtr(Status)
        );

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    //
    // If the send complete failed, or if we had pended a request cleanup
    // we'll pick them up now.
    //

    if(!NT_SUCCESS(Status) || pRequest->RequestFlags.CleanPended)
    {
        if(!NT_SUCCESS(Status))
        {
            pRequest->RequestStatus = Status;
            pRequest->RequestState  = UcRequestStateDone;
        }
        else
        {
            switch(pRequest->RequestState)
            {
                case UcRequestStateSent:
                    pRequest->RequestState = UcRequestStateSendCompleteNoData;
                    break;

                case UcRequestStateNoSendCompletePartialData:
                    pRequest->RequestState = 
                         UcRequestStateSendCompletePartialData;
                    break;

                case UcRequestStateNoSendCompleteFullData:
                    pRequest->RequestState = UcRequestStateResponseParsed;
                    break;
            }

            Status = pRequest->RequestStatus;
        }

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_CLEAN_RESUMED,
            pConnection,
            pRequest,
            UlongToPtr(pRequest->RequestState),
            UlongToPtr(pConnection->ConnectionState)
            );

        UcCompleteParsedRequest(pRequest, 
                                Status, 
                                TRUE, 
                                OldIrql
                                );

        return;
    }

    switch(pRequest->RequestState)
    {
        case UcRequestStateSent:

            pRequest->RequestState = UcRequestStateSendCompleteNoData;

            if(!pRequest->RequestFlags.ReceiveBufferSpecified)
            {
                if(!pRequest->DontFreeMdls)
                {
                    // The app has not supplied any receive buffers. If
                    // we are not doing SSPI auth (that requires a re-negotiate)
                    // we can complete the IRP.

                    pIrp = UcPrepareRequestIrp(pRequest, Status);
    
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
                    if(pIrp)
                    {
                        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                    }
                }
                else
                {   
                    // The app has not passed any receive buffers, but we are
                    // doing SSPI auth. We cannot free the MDL chain or complete
                    // the IRP, because we might have to re-negotiate. 
                    //
                    // We'll insert a cancel routine in the IRP.

                    if(pRequest->RequestIRP != NULL)
                    {
                        UC_WRITE_TRACE_LOG(
                            g_pUcTraceLog,
                            UC_ACTION_REQUEST_SET_CANCEL_ROUTINE,
                            pConnection,
                            pRequest,
                            pRequest->RequestIRP,
                            0
                            );
            
                        RequestCancelled =  UcSetRequestCancelRoutine(
                                                 pRequest, 
                                                 UcCancelSentRequest
                                                );
        
                        if(RequestCancelled)
                        {
                            // Make sure that any new API calls for this 
                            // request ID are failed.
                    
                            UcSetFlag(&pRequest->RequestFlags.Value, 
                                      UcMakeRequestCancelledFlag());
                        

                            UC_WRITE_TRACE_LOG(
                                g_pUcTraceLog,
                                UC_ACTION_REQUEST_CANCELLED,
                                pConnection,
                                pRequest,
                                pRequest->RequestIRP,
                                UlongToPtr((ULONG)STATUS_CANCELLED)
                                );

                            pRequest->RequestIRP = NULL;
                        }
                    }
                    
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                }
            }
            else
            {
                // The app has specified a receive buffer. We will not complete
                // the IRP from here, as we have to wait till the receive
                // buffer gets filled up.

                if(!pRequest->DontFreeMdls)
                {
                    // If we are not doing SSPI auth, we can free the MDL
                    // chain.

                    UcFreeSendMdls(pRequest->pMdlHead);

                    pRequest->pMdlHead = NULL;
                }

                if(pRequest->RequestIRP != NULL)
                {
                    UC_WRITE_TRACE_LOG(
                        g_pUcTraceLog,
                        UC_ACTION_REQUEST_SET_CANCEL_ROUTINE,
                        pConnection,
                        pRequest,
                        pRequest->RequestIRP,
                        0
                        );
        
                    RequestCancelled =  UcSetRequestCancelRoutine(
                                             pRequest, 
                                             UcCancelSentRequest
                                            );
    
                    if(RequestCancelled)
                    {
                        // Make sure that any new API calls for this 
                        // request ID are failed.
                
                        UcSetFlag(&pRequest->RequestFlags.Value, 
                                  UcMakeRequestCancelledFlag());

                        UC_WRITE_TRACE_LOG(
                            g_pUcTraceLog,
                            UC_ACTION_REQUEST_CANCELLED,
                            pConnection,
                            pRequest,
                            pRequest->RequestIRP,
                            UlongToPtr((ULONG)STATUS_CANCELLED)
                            );

                        pRequest->RequestIRP = NULL;
                    }
                }

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            }

            break;

        case UcRequestStateNoSendCompletePartialData:

            //
            // We got a send complete after receiving some response.
            //

            pRequest->RequestState = UcRequestStateSendCompletePartialData;

            if(!pRequest->RequestFlags.ReceiveBufferSpecified)
            {
                if(!pRequest->DontFreeMdls)
                {
                    // The app has not supplied any receive buffers. If
                    // we are not doing SSPI auth (that requires a re-negotiate)
                    // we can complete the IRP.

                    pIrp = UcPrepareRequestIrp(pRequest, Status);
    
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
                    if(pIrp)
                    {
                        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                    }
                }
                else
                {   
                    // The app has not passed any receive buffers, but we are
                    // doing SSPI auth. We cannot free the MDL chain or complete
                    // the IRP, because we might have to re-negotiate. 
                    //
                    // We'll insert a cancel routine in the IRP.

                    if(pRequest->RequestIRP != NULL)
                    {
                        UC_WRITE_TRACE_LOG(
                            g_pUcTraceLog,
                            UC_ACTION_REQUEST_SET_CANCEL_ROUTINE,
                            pConnection,
                            pRequest,
                            pRequest->RequestIRP,
                            0
                            );
            
                        RequestCancelled =  UcSetRequestCancelRoutine(
                                                 pRequest, 
                                                 UcCancelSentRequest
                                                );
        
                        if(RequestCancelled)
                        {
                            // Make sure that any new API calls for this 
                            // request ID are failed.
                    
                            UcSetFlag(&pRequest->RequestFlags.Value, 
                                      UcMakeRequestCancelledFlag());

                            UC_WRITE_TRACE_LOG(
                                g_pUcTraceLog,
                                UC_ACTION_REQUEST_CANCELLED,
                                pConnection,
                                pRequest,
                                pRequest->RequestIRP,
                                UlongToPtr((ULONG)STATUS_CANCELLED)
                                );

                            pRequest->RequestIRP = NULL;
                        }
                    }

                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                }
            }
            else
            {
                // The app has specified a receive buffer. If it's been 
                // fully written, we can complete the IRP.

                if(pRequest->RequestIRPBytesWritten)
                {
                    pIrp = UcPrepareRequestIrp(pRequest, Status);
    
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
                    if(pIrp)
                    {
                        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                    }

                    break;
                }

                if(!pRequest->DontFreeMdls)
                {
                    // If we are not doing SSPI auth, we can free the MDL
                    // chain.

                    UcFreeSendMdls(pRequest->pMdlHead);

                    pRequest->pMdlHead = NULL;
                }

                if(pRequest->RequestIRP != NULL)
                {
                    UC_WRITE_TRACE_LOG(
                        g_pUcTraceLog,
                        UC_ACTION_REQUEST_SET_CANCEL_ROUTINE,
                        pConnection,
                        pRequest,
                        pRequest->RequestIRP,
                        0
                        );
        
                    RequestCancelled = UcSetRequestCancelRoutine(
                                             pRequest, 
                                             UcCancelSentRequest
                                            );
    
                    if(RequestCancelled)
                    {
                        // Make sure that any new API calls for this 
                        // request ID are failed.
                
                        UcSetFlag(&pRequest->RequestFlags.Value, 
                                  UcMakeRequestCancelledFlag());

                        UC_WRITE_TRACE_LOG(
                            g_pUcTraceLog,
                            UC_ACTION_REQUEST_CANCELLED,
                            pConnection,
                            pRequest,
                            pRequest->RequestIRP,
                            UlongToPtr((ULONG)STATUS_CANCELLED)
                            );

                        pRequest->RequestIRP = NULL;
                    }
                }

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            }

            break;

        case UcRequestStateNoSendCompleteFullData:

            // The send complete happened after the response was parsed.
            // We don't have to free the MDLs here or complete the IRP,
            // as these will be handled by UcCompleteParsedRequest.
            // 

            pRequest->RequestState = UcRequestStateResponseParsed;

            UcCompleteParsedRequest(pRequest, Status, TRUE, OldIrql);
            break;

        default:
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            ASSERT(0);
            break;
    }
}


/*********************************************************************++

Routine Description:

    This is our send request complete routine for entity bodies.
            
Arguments:

    pDeviceObject           - The device object we called.
    pIrp                    - The IRP that is completing.
    Context                 - Our context value, a pointer to a request 
                                structure.
    
Return Value:

    NTSTATUS - MORE_PROCESSING_REQUIRED if this isn't to be completed now,
                SUCCESS otherwise.
                
--*********************************************************************/
VOID
UcpRestartEntityMdlSend(
    IN PVOID        pCompletionContext,
    IN NTSTATUS     Status,
    IN ULONG_PTR    Information
    )
{
    PUC_HTTP_SEND_ENTITY_BODY pEntity;
    PUC_HTTP_REQUEST          pRequest;
    PUC_CLIENT_CONNECTION     pConnection;
    KIRQL                     OldIrql;
    BOOLEAN                   bCancelRoutineCalled;
    PIRP                      pIrp;

    UNREFERENCED_PARAMETER(Information);

    pEntity     = (PUC_HTTP_SEND_ENTITY_BODY) pCompletionContext;
    pRequest    = pEntity->pRequest;
    pConnection = pRequest->pConnection;
    pIrp        = pEntity->pIrp;

    ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    //
    // Free the send MDLs. We want to do this as soon as we can, so we 
    // do it when the send-completes.
    //

    ASSERT(pRequest->DontFreeMdls == 0);
    ASSERT(pRequest->RequestFlags.RequestBuffered == 0);
    UcFreeSendMdls(pEntity->pMdlHead);

    //
    // If the send complete failed, we have to fail this send, even though
    // it might have succeeded
    //

    if(!NT_SUCCESS(pRequest->RequestStatus))
    {
        Status = pRequest->RequestStatus;
    }
    
    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    RemoveEntryList(&pEntity->Linkage);
    
    //
    // try to remove the cancel routine in the IRP
    //
    bCancelRoutineCalled = UcRemoveEntityCancelRoutine(pEntity);

    //
    // If we are pending a cleanup, now's the time to complete it.
    //

    if(pEntity->pRequest->RequestFlags.CleanPended && 
       IsListEmpty(&pRequest->SentEntityList))
    {
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_CLEAN_RESUMED,
            pConnection,
            pRequest,
            UlongToPtr(pRequest->RequestState),
            UlongToPtr(pConnection->ConnectionState)
            );

        UcCompleteParsedRequest(pRequest, 
                                pRequest->RequestStatus, 
                                TRUE, 
                                OldIrql
                                );

    }
    else
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }

    if(!bCancelRoutineCalled)
    {
        pIrp->RequestorMode = pEntity->AppRequestorMode;
        pIrp->MdlAddress    = pEntity->AppMdl;
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }

    UL_FREE_POOL_WITH_QUOTA(
                 pEntity, 
                 UC_ENTITY_POOL_TAG,
                 NonPagedPool,
                 pEntity->BytesAllocated,
                 pRequest->pServerInfo->pProcess
                 );

    UC_DEREFERENCE_REQUEST(pRequest);
}


/***************************************************************************++

Routine Description:

    Issue requests on a connection. This routine is called when another routine
    determines that requests need to be issued on the connection. We'll loop,
    issuing requests as long as we can. The connection we're given must be both
    referenced and have the spin lock held when we're called. Also, the send
    busy flag must be set.
                        
Arguments:

    pConnection         - Pointer to the connection structure on which requests
                            are to be issued.
    
    OldIrql             - The IRQL to be restored when the lock is freed.

Return Value:


--***************************************************************************/
VOID
UcIssueRequests(
    PUC_CLIENT_CONNECTION         pConnection, 
    KIRQL                         OldIrql
    )
{
    PLIST_ENTRY                 pEntry;
    PUC_HTTP_REQUEST            pRequest;
    NTSTATUS                    Status;
    BOOLEAN                     bCloseConnection = FALSE;
 

    ASSERT( UlDbgSpinLockOwned(&pConnection->SpinLock) );
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    //
    // We cannot cleanup the connection when we are still sending requests.
    // So, we pend connection cleanup when our Send thread is active. 
    //
    // Such pended cleanups will get picked up at the end of this routine.
    //

    ASSERT(!(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY));
    pConnection->Flags |= CLIENT_CONN_FLAG_SEND_BUSY;

    // We know it's OK to send when we're first called or we wouldn't have 
    // been called. Get a pointer to the first entry on the pending list
    // and send it. Then we'll keep looping while there's still stuff
    // on the pending list that can be sent and the connection is still
    // alive.
    //
    
    ASSERT(!IsListEmpty(&pConnection->PendingRequestList));
    pEntry = pConnection->PendingRequestList.Flink;
    
    for (;;)
    {
        BOOLEAN bCancelled;

        // Remove the current entry from the list, and get a pointer to the 
        // containing request. We know we're going to send this one if we're
        // here, so remove a cancel routine if there is one. If the request
        // is already cancelled, skip it, otherwise move it to the sent 
        // list.

        pRequest = CONTAINING_RECORD(
                                     pEntry,
                                     UC_HTTP_REQUEST,
                                     Linkage);

        ASSERT( UC_IS_VALID_HTTP_REQUEST(pRequest) );

        //
        // Can't send something that is still buffered.
        //

        if(pRequest->RequestFlags.RequestBuffered && 
           !pRequest->RequestFlags.LastEntitySeen)
        {
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_BUFFERED,
                pConnection,
                pRequest,
                pRequest->RequestIRP,
                0
                );

            break;
        }

        RemoveEntryList(pEntry);

        // See if there was a cancel routine set on this request, and if there
        // was remove it. If it's already gone, the request is cancelled.

        bCancelled = UcRemoveRequestCancelRoutine(pRequest);

        if (bCancelled)
        {
            ASSERT(pRequest->RequestState == UcRequestStateCaptured);

            // If the cancel routine was already null, this request is in the 
            // process of being cancelled. In that case just initialize the 
            // linkage on the request (so the cancel routine can't pull it
            // from the list again), and continue on.

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_CANCELLED,
                pConnection,
                pRequest,
                pRequest->RequestIRP,
                UlongToPtr((ULONG)STATUS_CANCELLED)
                );

            InitializeListHead(pEntry);
        }
        else
        {
            UC_REFERENCE_REQUEST(pRequest);

            // Either there wasn't a cancel routine or it was removed 
            // successfully. In either case put this request on the sent
            // list and send it.
   
            InsertTailList(&pConnection->SentRequestList, pEntry);

            pRequest->RequestState = UcRequestStateSent;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_SENT,
                pConnection,
                pRequest,
                pRequest->RequestIRP,
                0
                );

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            // Send it, saving the status for later return.

            Status = UcSendData(pConnection,    
                                pRequest->pMdlHead,
                                pRequest->BytesBuffered,
                                &UcRestartMdlSend,
                                (PVOID)pRequest,
                                pRequest->RequestIRP,
                                FALSE
                                );

    
            if(STATUS_PENDING != Status)
            {
                 UcRestartMdlSend(pRequest, Status, 0);
            }

            // Acquire the spinlock so we can check again.
    
            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            if(pRequest->RequestStatus == STATUS_SUCCESS &&
               pConnection->ConnectionState == UcConnectStateConnectReady) 
            {
                if(UcIssueEntities(pRequest, pConnection, &OldIrql) == FALSE)
                {
                    // We have not sent all of the data for this request.
                    // Additional requests will be blocked from being sent out
                    // because there will be a request on the SentRequestList
                    // that still hasn't sent out all of its entities.
                    //

                    UC_WRITE_TRACE_LOG(
                        g_pUcTraceLog,
                        UC_ACTION_REQUEST_MORE_ENTITY_NEEDED,
                        pConnection,
                        pRequest,
                        pRequest->RequestIRP,
                        0
                        );

                    UC_DEREFERENCE_REQUEST(pRequest);

                    break;
                }

                //
                // If we have sent out all the entity for this request, see
                // if we have to close the connection.
                //
    
                if(pRequest->RequestConnectionClose)
                {
                    bCloseConnection = TRUE;
                    UC_DEREFERENCE_REQUEST(pRequest);
                    break;
                }
            }
            else
            {
                //
                // The send failed or the connection is torn down.
                // If the send failed, we don't necessarily have to tear the
                // connection down. If the connection is torn down, we'll
                // exit (see below).
            }

            UC_DEREFERENCE_REQUEST(pRequest);
        }

        //
        // If the pending list is empty or the connection is not active, we 
        // can't send.
        //

        if (IsListEmpty(&pConnection->PendingRequestList) || 
            pConnection->ConnectionState != UcConnectStateConnectReady 
            )
        {
            break;
        }

        //  
        // We have at least one request to send out. See if we can pipeline.
        // 

        if(UcpCheckForPipelining(pConnection) == FALSE)
        {
            break;
        }
    
        // We still have something on the list and we might be able to send it.
        // Look at it to see if it's OK.

        pEntry = pConnection->PendingRequestList.Flink;
    }

    UcClearConnectionBusyFlag(
        pConnection,
        CLIENT_CONN_FLAG_SEND_BUSY,
        OldIrql,
        bCloseConnection
        );

}


/***************************************************************************++

Routine Description:

    Issue entities on a connection. This routine is called after we send the
    original request, or from the context of the send-entity IOCTL handler.

Arguments:

    pRequest     - pointer to the request that got sent out.

    pConnection  - Pointer to the connection structure

    OldIrql      - The IRQL to be restored when the lock is freed.

Return Value:
    
    TRUE  - We are done with this request & all of it's entities.
    FALSE - More entities to come.


--***************************************************************************/

BOOLEAN
UcIssueEntities(
    PUC_HTTP_REQUEST              pRequest, 
    PUC_CLIENT_CONNECTION         pConnection, 
    PKIRQL                        OldIrql
    )
{
    PLIST_ENTRY                 pEntry;
    PUC_HTTP_SEND_ENTITY_BODY   pEntity;
    NTSTATUS                    Status;
    BOOLEAN                     bLast;

    bLast = (0 == pRequest->RequestFlags.LastEntitySeen) ? FALSE : TRUE;

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    ASSERT(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY);

    // We know it's OK to send when we're first called or we wouldn't have 
    // been called. Get a pointer to the first entry on the pending list
    // and send it. Then we'll keep looping while there's still stuff
    // on the pending list that can be sent and the connection is still
    // alive.
    //

    
    while(!IsListEmpty(&pRequest->PendingEntityList))
    {
        BOOLEAN bCancelled;

        //
        // We don't add buffered entities to the PendingEntityList
        //
        ASSERT(!pRequest->RequestFlags.RequestBuffered);

        // Remove the current entry from the list, and get a pointer to the 
        // containing request. We know we're going to send this one if we're
        // here, so remove a cancel routine if there is one. If the request
        // is already cancelled, skip it, otherwise move it to the sent 
        // list.
        
        pEntry = RemoveHeadList(&pRequest->PendingEntityList);

        pEntity = CONTAINING_RECORD(pEntry,
                                    UC_HTTP_SEND_ENTITY_BODY,
                                    Linkage);

        bLast = pEntity->Last;

        if(pEntity->pIrp)
        {
            // See if there was a cancel routine set on this request, and if 
            // there was remove it. If it's already gone, the request is 
            // cancelled.
            
            bCancelled = UcRemoveEntityCancelRoutine(pEntity);
            
            if (bCancelled)
            {
                // If the cancel routine was already null, this request is in 
                // the process of being cancelled. In that case just 
                // initialize the linkage on the request (so the cancel routine 
                // can't pull it from the list again), and continue on.
                
                InitializeListHead(pEntry);
            }
            else
            {
                
                // Either there wasn't a cancel routine or it was removed 
                // successfully. In either case put this request on the sent
                // list and send it.
    
                InsertTailList(&pRequest->SentEntityList, &pEntity->Linkage);
                
                
                // Send it, saving the status for later return.

                UC_WRITE_TRACE_LOG(
                    g_pUcTraceLog,
                    UC_ACTION_ENTITY_SENT,
                    pConnection,
                    pRequest,
                    pEntity,
                    pEntity->pIrp
                    );
        