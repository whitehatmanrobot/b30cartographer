       && xleftdrop) || !xrightdrop) {
                xLeft = ppopupmenu->spwndPopupMenu->rcWindow.left +
                    pItem->xItem - cxPopup;
                    ppopupmenuHierarchy->iDropDir = PAS_LEFT;
            } else if (xrightdrop) {
                xLeft = ppopupmenu->spwndPopupMenu->rcWindow.left +
                    pItem->xItem + pItem->cxItem;
                    ppopupmenuHierarchy->iDropDir = PAS_RIGHT;
            }

            /*
             * If we're going to show the menu off the screen, move it to the
             * right of the cursor. This might result in part of the
             * menu being shown offscreen, but it's better then the entire
             * thing being hidden (and will also ensure that the popup is not
             * placed under the cursor). See bug #55045.
             */
            if (xLeft <= pMonitor->rcMonitor.left) {
                xLeft = rcParent.right;
                ppopupmenuHierarchy->iDropDir = PAS_LEFT;
            }
        }
    }

    /*
     * Take care of fDropNextPopup (menu bar) or fDroppedLeft (popups)
     * Set animation flag
     */
    if (ppopupmenu->fIsMenuBar) {
        /*
         * Only the first popup being dropped off the menu bar
         * is animated.
         */
        if (!ppopupmenu->fDropNextPopup) {
            ppopupmenuHierarchy->iDropDir |= PAS_OUT;
        }

        /*
         * Propagate right-to-left direction.
         */
        if (ppopupmenu->fDroppedLeft || (ppopupmenuHierarchy->iDropDir == PAS_LEFT)) {
            ppopupmenuHierarchy->fDroppedLeft = TRUE;
        }
        /*
         * Once a popup is dropped from the menu bar, moving to the next
         *  item on the menu bar should drop the popup.
         */
        ppopupmenu->fDropNextPopup = TRUE;
    } else {
        /*
         * Submenus always animate.
         */
        ppopupmenuHierarchy->iDropDir |= PAS_OUT;

        /*
         * Is this popup a lefty?
         */
        if (ppopupmenuHierarchy->iDropDir == PAS_LEFT) {
            ppopupmenuHierarchy->fDroppedLeft = TRUE;
        }
    }

    /*
     * The previous active dude must be visible
     */
    UserAssert((ppopupmenu->ppopupmenuRoot->spwndActivePopup == NULL)
            || TestWF(ppopupmenu->ppopupmenuRoot->spwndActivePopup, WFVISIBLE));

    /*
     * This is the new active popup
     */
    Lock(&(ppopupmenu->ppopupmenuRoot->spwndActivePopup), pwndHierarchy);

    /*
     * Paint the owner window before the popup menu comes up so that
     * the proper bits are saved.
     */
    if (ppopupmenuHierarchy->spwndNotify != NULL) {
        ThreadLockAlways(ppopupmenuHierarchy->spwndNotify, &tlpwndT);
        xxxUpdateWindow(ppopupmenuHierarchy->spwndNotify);
        ThreadUnlock(&tlpwndT);
    }

    /*
     * If this is a drag and drop menu, then we need to register the window
     *  as a drop target.
     */
    if (pMenuState->fDragAndDrop) {
        if (!NT_SUCCESS(xxxClientRegisterDragDrop(HW(pwndHierarchy)))) {
            RIPMSG1(RIP_ERROR, "xxxMNOpenHierarchy: xxxClientRegisterDragDrop failed:%#p", pwndHierarchy);
        }
    }

    /*
     * Show the window. Modeless menus are not topmost and get activated.
     *  Modal menus are topmost but don't get activated.
     */
    PlayEventSound(USER_SOUND_MENUPOPUP);

    xxxSetWindowPos(pwndHierarchy,
                    (pMenuState->fModelessMenu ? PWND_TOP : PWND_TOPMOST),
                    xLeft, yTop, 0, 0,
                    SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOOWNERZORDER
                    | (pMenuState->fModelessMenu ? 0 : SWP_NOACTIVATE));

    xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPSTART, pwndHierarchy, OBJID_CLIENT, INDEXID_CONTAINER, 0);

    /*
     * Select the first item IFF we're in keyboard mode. This fixes a
     * surprising number of compatibility problems with keyboard macros,
     * scripts, etc.
     */
    if (pMenuState->mnFocus == KEYBDHOLD) {
        xxxSendMessage(pwndHierarchy, MN_SELECTITEM, 0, 0L);
    }

    /*
     * This is needed so that popup menus are properly drawn on sys
     * modal dialog boxes.
     */
    xxxUpdateWindow(pwndHierarchy);

    ret = pwndHierarchy;
    ThreadUnlock(&tlpwndHierarchy);

Exit:
    /*
     * send matching WM_UNINITMENUPOPUP if needed (i.e, something
     *  failed).
     */
    if (fSendUninit
            && (ppopupmenu->spwndNotify != NULL)) {

        ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndT);
        xxxSendMessage(ppopupmenu->spwndNotify, WM_UNINITMENUPOPUP,
            (WPARAM)hmenuInit,
             MAKELONG(0, (ppopupmenu->fIsSysMenu ? MF_SYSMENU : 0)));
        ThreadUnlock(&tlpwndT);
    }

    return ret;
}

/***************************************************************************\
* xxxMNHideNextHierarchy
*
* Closes any submenu coming off of this popup.
\***************************************************************************/
BOOL xxxMNHideNextHierarchy(
    PPOPUPMENU ppopup)
{
    if (ppopup->spwndNextPopup != NULL) {
        TL tlpwndT;

        ThreadLockAlways(ppopup->spwndNextPopup, &tlpwndT);
        if (ppopup->spwndNextPopup != ppopup->spwndActivePopup)
            xxxSendMessage(ppopup->spwndNextPopup, MN_CLOSEHIERARCHY, 0, 0L);

        xxxSendMessage(ppopup->spwndNextPopup, MN_SELECTITEM, (WPARAM)-1, 0L);
        ThreadUnlock(&tlpwndT);
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* xxxMNCloseHierarchy
*
* Close all hierarchies from this window down.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNCloseHierarchy(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState)
{
    TL           tlpwndNext;
    TL           tlpwnd;
    TL           tlpopup;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOP     pdesk;
    PWND         pwndNext;

    Validateppopupmenu(ppopupmenu);

    /*
     * Terminate any animation
     */
    MNAnimate(pMenuState, FALSE);

    /*
     * If a hierarchy exists, close all childen below us. Do it in reversed
     * order so savebits work out.
     */
    if  (!ppopupmenu->fHierarchyDropped) {
        /*
         * Assert that there's no next or it might not get closed
         */
        UserAssert(ppopupmenu->spwndNextPopup == NULL);
        return;
    }

    if (ppopupmenu->fHideTimer)
    {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNHIDE);
        ppopupmenu->fHideTimer = FALSE;
    }

    pwndNext = ppopupmenu->spwndNextPopup;
    if (pwndNext != NULL) {

        ThreadLockAlways(pwndNext, &tlpwndNext);
        xxxSendMessage(pwndNext, MN_CLOSEHIERARCHY, 0, 0);

        /*
         * If modeless menu, activate the this popup since we're about
         *  to destroy the current active one. We want to keep activation
         *  on a menu window so we can get the keys. Also, modeless menus
         *  are canceled when a non-menu window is activated in their queue
         */
        if (pMenuState->fModelessMenu
                && pMenuState->fInsideMenuLoop
                && !ppopupmenu->fIsMenuBar) {

            ThreadLockAlways(ppopupmenu->spwndPopupMenu, &tlpwnd);
            xxxActivateThisWindow(ppopupmenu->spwndPopupMenu, 0, 0);
            ThreadUnlock(&tlpwnd);
        }

        xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPEND, pwndNext, OBJID_CLIENT, INDEXID_CONTAINER, 0);

        /*
         * If the current thread is not in the right pdesk, then that could
         *  be the cause of the stuck menu bug.
         * In other words, are we nuking this menu out of context?
         */
        UserAssert(ptiCurrent->pMenuState != NULL);
        pdesk = ptiCurrent->rpdesk;

        if (ThreadUnlock(&tlpwndNext)) {
            xxxDestroyWindow(pwndNext);
        }

        Unlock(&ppopupmenu->spwndNextPopup);
        ppopupmenu->fHierarchyDropped = FALSE;
    }

    if (ppopupmenu->fIsMenuBar) {
        Unlock(&ppopupmenu->spwndActivePopup);
    } else {
        Lock(&(ppopupmenu->ppopupmenuRoot->spwndActivePopup),
                ppopupmenu->spwndPopupMenu);
    }

    if (pMenuState->fInsideMenuLoop &&
            (ppopupmenu->posSelectedItem != MFMWFP_NOITEM)) {
        /*
         * Send a menu select as if this item had just been selected. This
         * allows people to easily update their menu status bars when a
         * hierarchy from this item has been closed.
         */
        PWND pwnd = ppopupmenu->ppopupmenuRoot->spwndNotify;
        if (pwnd) {
            ThreadLockAlways(pwnd, &tlpwnd);
            ThreadLockAlways(ppopupmenu->spwndPopupMenu, &tlpopup);
            xxxSendMenuSelect(pwnd, ppopupmenu->spwndPopupMenu,
                    ppopupmenu->spmenu, ppopupmenu->posSelectedItem);
            ThreadUnlock(&tlpopup);
            ThreadUnlock(&tlpwnd);
        }
    }

}

/***************************************************************************\
* xxxMNDoubleClick
*
* If an item isn't a hierarchical, then the double-click works just like
* single click did. Otherwise, we traverse the submenu hierarchy to find
* a valid default element. If we reach a submenu that has no valid default
* subitems and it itself has a valid ID, that becomes the valid default
* element.
*
* Note:   This function does not remove the double click message
*         from the message queue, so the caller must do so.
*
* BOGUS
* How about opening the hierarchies if we don't find anything?
*
* Returns TRUE if handled.
\***************************************************************************/
BOOL xxxMNDoubleClick(
    PMENUSTATE pMenuState,
    PPOPUPMENU ppopup,
    int idxItem)
{
    PMENU  pMenu;
    PITEM  pItem;
    MSG   msg;
    UINT uPos;

    /*
     * This code to swallow double clicks isn't executed! MNLoop will
     * swallow all double clicks for us. Swallow the up button for the
     * double dude instead. Word will not be happy if they get a spurious
     * WM_LBUTTONUP on the menu bar if their code to close the MDI child
     * doesn't swallow it soon enough.
     */

    /*
     * Eat the click.
     */
    if (xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD)) {
        if ((msg.message == WM_LBUTTONUP) ||
            (msg.message == WM_NCLBUTTONUP)) {
           xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
        }
#if DBG
        else if (msg.message == WM_LBUTTONDBLCLK ||
            msg.message == WM_NCLBUTTONDBLCLK)
        {
            UserAssertMsg0(FALSE, "xxxMNDoubleClick found a double click");
        }
#endif
    }

    /*
     * Get current item.
     */
    pMenu = ppopup->spmenu;
    if ((pMenu==NULL) || ((UINT)idxItem >= pMenu->cItems)) {
        xxxMNDoScroll(ppopup, ppopup->posSelectedItem, FALSE);
        goto Done;
    }

    pItem = pMenu->rgItems + idxItem;
    uPos = idxItem;

    /*
     * Do nothing if item is disabled.
     */
    if (pItem->fState & MFS_GRAYED) {
        goto Done;
    }

    /*
     * Traverse the hierarchy down as far as possible.
     */
    do
    {
        if (pItem->spSubMenu != NULL) {
            /*
             * The item is a popup menu, so continue traversing.
             */
            pMenu = pItem->spSubMenu;
            idxItem = (UINT)_GetMenuDefaultItem(pMenu, MF_BYPOSITION, 0);

            if (idxItem != -1) {
                pItem = pMenu->rgItems + idxItem;
                uPos = idxItem;
                continue;
            } else /* if (lpItem->wID == -1) How do we know this popup has an ID? */
                break;
        }

        /*
         * We've found a leaf node of some kind, either a MFS_DEFAULT popup
         * with a valid cmd ID that has no valid MFS_DEFAULT children, or
         * a real cmd with MFS_DEFAULT style.
         *
         * Exit menu mode and send command ID.
         */

        /*
         * For old apps we need to generate a WM_MENUSELECT message first.
         * Old apps, esp. Word 6.0, can't handle double-clicks on maximized
         * child sys menus because they never get a WM_MENUSELECT for the
         * item, unlike with normal keyboard/mouse choosing. We need to
         * fake it so they won't fault. Several VB apps have a similar
         * problem.
         */
        if (!TestWF(ppopup->ppopupmenuRoot->spwndNotify, WFWIN40COMPAT)) {
            TL tlpwndNotify, tlpopup;

            ThreadLock(ppopup->ppopupmenuRoot->spwndNotify, &tlpwndNotify);
            ThreadLock(ppopup->spwndPopupMenu, &tlpopup);
            xxxSendMenuSelect(ppopup->ppopupmenuRoot->spwndNotify,
                    ppopup->spwndPopupMenu, pMenu, idxItem);
            ThreadUnlock(&tlpopup);
            ThreadUnlock(&tlpwndNotify);
        }

        xxxMNDismissWithNotify(pMenuState, pMenu, pItem, uPos, 0);
        return TRUE;
    } while (TRUE);

Done:
    return FALSE;
}


/***************************************************************************\
* xxxMNSelectItem
*
* Unselects the old selection, selects the item at itemPos and highlights it.
*
* MFMWFP_NOITEM if no item is to be selected.
*
* Returns the item flags of the item being selected.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
PITEM xxxMNSelectItem(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT itemPos)
{
    PITEM pItem = NULL;
    TL tlpwndNotify;
    TL tlpwndPopup;
    TL tlpmenu;
    PWND pwndNotify;
    PMENU pmenu;

    if (ppopupmenu->posSelectedItem == itemPos) {

        /*
         * If this item is already selectected, just return its flags.
         */
        if ((itemPos != MFMWFP_NOITEM) && (itemPos < ppopupmenu->spmenu->cItems)) {
            return &(ppopupmenu->spmenu->rgItems[itemPos]);
        }
        return NULL;
    }

    /*
     * Terminate any animation
     */
    MNAnimate(pMenuState, FALSE);

    if (ppopupmenu->fShowTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNSHOW);
        ppopupmenu->fShowTimer = FALSE;
    }

    ThreadLock(pmenu = ppopupmenu->spmenu, &tlpmenu);
    ThreadLock(pwndNotify = ppopupmenu->spwndNotify, &tlpwndNotify);

    if (ppopupmenu->fAboutToHide) {
        PPOPUPMENU ppopupPrev = ((PMENUWND)(ppopupmenu->spwndPrevPopup))->ppopupmenu;

        _KillTimer(ppopupPrev->spwndPopupMenu, IDSYS_MNHIDE);
        ppopupPrev->fHideTimer = FALSE;
        if (ppopupPrev->fShowTimer) {
            _KillTimer(ppopupPrev->spwndPopupMenu, IDSYS_MNSHOW);
            ppopupPrev->fShowTimer = FALSE;
        }

        if (ppopupPrev->posSelectedItem != ppopupPrev->posDropped) {
            TL tlpmenuPopupMenuPrev;
            ThreadLock(ppopupPrev->spmenu, &tlpmenuPopupMenuPrev);
            if (ppopupPrev->posSelectedItem != MFMWFP_NOITEM) {
                xxxMNInvertItem(ppopupPrev, ppopupPrev->spmenu,
                        ppopupPrev->posSelectedItem, ppopupPrev->spwndNotify, FALSE);
            }

            ppopupPrev->posSelectedItem = ppopupPrev->posDropped;

            xxxMNInvertItem(ppopupPrev, ppopupPrev->spmenu,
                        ppopupPrev->posDropped, ppopupPrev->spwndNotify, TRUE);
            ThreadUnlock(&tlpmenuPopupMenuPrev);
        }

        ppopupmenu->fAboutToHide = FALSE;
        Lock(&ppopupmenu->ppopupmenuRoot->spwndActivePopup, ppopupmenu->spwndPopupMenu);
    }

    if (MNIsItemSelected(ppopupmenu)) {
        /*
         * Something else is selected so we need to unselect it.
         */
        if (ppopupmenu->spwndNextPopup) {
            if (ppopupmenu->fIsMenuBar) {
                xxxMNCloseHierarchy(ppopupmenu, pMenuState);
            } else {
                MNSetTimerToCloseHierarchy(ppopupmenu);
            }
        }

        goto DeselectItem;
    } else if (MNIsScrollArrowSelected(ppopupmenu)) {
            _KillTimer(ppopupmenu->spwndPopupMenu, ppopupmenu->posSelectedItem);
DeselectItem:

            xxxMNInvertItem(ppopupmenu, pmenu,
                    ppopupmenu->posSelectedItem, pwndNotify, FALSE);
    }

    ppopupmenu->posSelectedItem = itemPos;

    if (itemPos != MFMWFP_NOITEM) {
        /*
         * If an item is selected, no autodismiss plus this means
         *  that the mouse is on the menu
         */
        pMenuState->fAboutToAutoDismiss =
        pMenuState->fMouseOffMenu = FALSE;

        if (pMenuState->fButtonDown) {
            xxxMNDoScroll(ppopupmenu, itemPos, TRUE);
        }

        pItem = xxxMNInvertItem(ppopupmenu, pmenu,
                itemPos, pwndNotify, TRUE);
        ThreadUnlock(&tlpwndNotify);
        ThreadUnlock(&tlpmenu);
        return pItem;

    } else {
        /*
         * Notify that nothing is now focused in this menu.
         */
        xxxWindowEvent(EVENT_OBJECT_FOCUS, ppopupmenu->spwndPopupMenu,
               ((ppopupmenu->spwndNotify != ppopupmenu->spwndPopupMenu) ? OBJID_CLIENT :
               (ppopupmenu->fIsSysMenu ? OBJID_SYSMENU : OBJID_MENU)), 0, 0);
    }

    ThreadUnlock(&tlpwndNotify);
    ThreadUnlock(&tlpmenu);

    if (ppopupmenu->spwndPrevPopup != NULL) {
        PPOPUPMENU pp;

        /*
         * Get the popupMenu data for the previous menu
         * Use the root popupMenu if the previous menu is the menu bar
         */
        if (ppopupmenu->fHasMenuBar && (ppopupmenu->spwndPrevPopup ==
                ppopupmenu->spwndNotify)) {
            pp = ppopupmenu->ppopupmenuRoot;
        } else {
#ifdef HAVE_MN_GETPPOPUPMENU
            TL tlpwndPrevPopup;
            ThreadLock(ppopupmenu->spwndPrevPopup, &tlpwndPrevPopup);
            pp = (PPOPUPMENU)xxxSendMessage(ppopupmenu->spwndPrevPopup,
                    MN_GETPPOPUPMENU, 0, 0L);
            ThreadUnlock(&tlpwndPrevPopup);
#else
            pp = ((PMENUWND)ppopupmenu->spwndPrevPopup)->ppopupmenu;
#endif
        }

        /*
         * Generate a WM_MENUSELECT for the previous menu to re-establish
         * it's current item as the SELECTED item
         */
        ThreadLock(pp->spwndNotify, &tlpwndNotify);
        ThreadLock(pp->spwndPopupMenu, &tlpwndPopup);
        xxxSendMenuSelect(pp->spwndNotify, pp->spwndPopupMenu, pp->spmenu, pp->posSelectedItem);
        ThreadUnlock(&tlpwndPopup);
        ThreadUnlock(&tlpwndNotify);
    }

    return NULL;
}

/***************************************************************************\
* MNItemHitTest
*
* Given a hMenu and a point in screen coordinates, returns the position
* of the item the point is in. Returns -1 if no item exists there.
*
\***************************************************************************/
UINT MNItemHitTest(
    PMENU pMenu,
    PWND pwnd,
    POINT pt)
{
    PITEM  pItem;
    UINT    iItem;
    RECT    rect;

    PTHREADINFO ptiCurrent = PtiCurrent();

    if (pMenu->cItems == 0)
        return MFMWFP_NOITEM;


    /*
     * This point is screen-relative. Menu bar coordinates relative
     * to the window. But popup menu coordinates are relative to the client.
     */
    if (TestMF(pMenu, MFISPOPUP)) {

        /*
         * Bail if it's outside rcWindow
         */
        CopyInflateRect(&rect, &(pwnd->rcWindow),
                -SYSMET(CXFIXEDFRAME), -SYSMET(CYFIXEDFRAME));

        if (!PtInRect(&rect, pt)) {
            return MFMWFP_NOITEM;
        }

        /* ScreenToClient */
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            pt.x = pwnd->rcClient.right - pt.x;
        } else {
            pt.x -= pwnd->rcClient.left;
        }
        pt.y -= pwnd->rcClient.top;

        /*
         * If on the non client area, then it's on the scroll arrows
         */
        if (pt.y < 0) {
            return MFMWFP_UPARROW;
        } else if (pt.y > (int)pMenu->cyMenu) {
            return MFMWFP_DOWNARROW;
        }

    } else {
        /* ScreenToWindow */
        if (TestWF(pwnd, WEFLAYOUTRTL) &&
            (
             (ptiCurrent->pq->codeCapture == SCREEN_CAPTURE) || (ptiCurrent->pq->codeCapture == NO_CAP_SYS)
            )
           ) {
            pt.x = pwnd->rcWindow.right - pt.x;
        } else {
            pt.x -= pwnd->rcWindow.left;
        }
        pt.y -= pwnd->rcWindow.top;
    }

    /*
     * Step through all the items in the menu.
     * If scrollable menu
     */
    if (pMenu->dwArrowsOn != MSA_OFF) {
        UserAssert(TestMF(pMenu, MFISPOPUP));
        pItem = MNGetToppItem(pMenu);
        rect.left = rect.top = 0;
        rect.right = pItem->cxItem;
        rect.bottom = pItem->cyItem;
        for (iItem = pMenu->iTop; (iItem < (int)pMenu->cItems) && (rect.top < (int)pMenu->cyMenu); iItem++) {

            if (PtInRect(&rect, pt)) {
                return iItem;
            }

            pItem++;
            rect.top = rect.bottom;
            rect.bottom += pItem->cyItem;
        }
    } else {
        /*
         * No scroll bars.
         */
        for (iItem = 0, pItem = pMenu->rgItems; iItem < pMenu->cItems; iItem++, pItem++) {
            /* Is the mouse inside this item's rectangle? */
            rect.left       = pItem->xItem;
            rect.top        = pItem->yItem;
            rect.right      = pItem->xItem + pItem->cxItem;
            rect.bottom     = pItem->yItem + pItem->cyItem;

            if (PtInRect(&rect, pt)) {
                return iItem;
            }
        }
    }

    return MFMWFP_NOITEM;
}

/***************************************************************************\
* LockMFMWFPWindow
*
* This function is called when we need to save the return value of
* xxxMNFindWindowFromPoint.
*
* History:
* 11/14/96  GerardoB  Created
\***************************************************************************/
VOID LockMFMWFPWindow(
    PULONG_PTR puHitArea,
    ULONG_PTR uNewHitArea)
{
    /*
     * Bail if there is nothing to do.
     */
    if (*puHitArea == uNewHitArea) {
        return;
    }

    /*
     * Unlock current hit area
     */
    UnlockMFMWFPWindow(puHitArea);

    /*
     * Lock new hit area
     */
    if (IsMFMWFPWindow(uNewHitArea)) {
        Lock(puHitArea, (PWND)uNewHitArea);
    } else {
        *puHitArea = uNewHitArea;
    }
}

/***************************************************************************\
* UnlockMFMWFPWindow
*
* You must call this if you ever called LockMFMWFPWindow.
*
* History:
* 11/14/96  GerardoB  Created
\***************************************************************************/
VOID UnlockMFMWFPWindow(
    PULONG_PTR puHitArea)
{
    if (IsMFMWFPWindow(*puHitArea)) {
        Unlock(puHitArea);
    } else {
        *puHitArea = MFMWFP_OFFMENU;
    }
}

/***************************************************************************\
* IsMFMWFPWindow
*
* Test whether or not the return value of xxxMNFindWindowFromPoint is
* a window. Not that uHitArea could be an HWND or a PWND.
*
* History:
*   10-02-96 GerardoB   Created
\***************************************************************************/
BOOL IsMFMWFPWindow(
    ULONG_PTR uHitArea)
{
    switch(uHitArea) {
        case MFMWFP_OFFMENU:
        case MFMWFP_NOITEM:
        case MFMWFP_ALTMENU:
            return FALSE;

        default:
            return TRUE;
    }
}

/***************************************************************************\
* xxxMNFindWindowFromPoint
*
* Determines in which window the point lies.
*
* Returns
*   - PWND of the hierarchical menu the point is on,
*   - MFMWFP_ALTMENU if point lies on the alternate popup menu.
*   - MFMWFP_NOITEM if there is no item at that point on the menu or the
*      point lies on the menu bar.
*   - MFMWFP_OFFMENU if point lies elsewhere.
*
* Returns in pIndex
*   - the index of the item hit,
*   - MFMWFP_NOITEM if there is no item at that point on the menu or
*      point lies on the menu bar.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
*  8-11-92 Sanfords added MFMWFP_ constants
\***************************************************************************/
LONG_PTR xxxMNFindWindowFromPoint(
    PPOPUPMENU ppopupmenu,
    PUINT pIndex,
    POINTS screenPt)
{
    POINT pt;
    RECT rect;
    LONG_PTR longHit;
    UINT itemHit;
    PWND pwnd;
    TL tlpwndT;
    int cx;


    *pIndex = 0;

    if (ppopupmenu->spwndNextPopup) {

        /*
         * Check if this point is on any of our children before checking if it
         * is on ourselves.
         */
        ThreadLockAlways(ppopupmenu->spwndNextPopup, &tlpwndT);
        longHit = xxxSendMessage(ppopupmenu->spwndNextPopup,
                MN_FINDMENUWINDOWFROMPOINT, (WPARAM)&itemHit,
                MAKELONG(screenPt.x, screenPt.y));
        ThreadUnlock(&tlpwndT);

        /*
         * If return value is an hwnd, convert to pwnd.
         */
        if (IsMFMWFPWindow(longHit)) {
            longHit = (LONG_PTR)RevalidateHwnd((HWND)longHit);
        }

        if (longHit) {

            /*
             * Hit occurred on one of our children.
             */

            *pIndex = itemHit;
            return longHit;
        }
    }

    if (ppopupmenu->fIsMenuBar) {
        int cBorders;

         /*
          * Check if this point is on the menu bar
          */
        pwnd = ppopupmenu->spwndNotify;
        if (pwnd == NULL) {
            return MFMWFP_OFFMENU;
        }

        pt.x = screenPt.x;
        pt.y = screenPt.y;

        if (ppopupmenu->fIsSysMenu) {

            if (!_HasCaptionIcon(pwnd)) {
                /*
                 * no system menu rect to click in if it doesn't have an icon
                 */
                return 0L;
            }

            /*
             * Check if this is a click on the system menu icon.
             */
            if (TestWF(pwnd, WFMINIMIZED)) {

                /*
                 * If the window is minimized, then check if there was a hit in
                 * the client area of the icon's window.
                 */

/*
 * Mikehar 5/27
 * Don't know how this ever worked. If we are the system menu of an icon
 * we want to punt the menus if the click occurs ANYWHERE outside of the
 * menu.
 * Johnc 03-Jun-1992 the next 4 lines were commented out for Mike's
 * problem above but that made clicking on a minimized window with
 * the system menu already up, bring down the menu and put it right
 * up again (bug 10951) because the mnloop wouldn't swallow the mouse
 * down click message. The problem Mike mentions no longer shows up.
 */

                if (PtInRect(&(pwnd->rcWindow), pt)) {
                    return MFMWFP_NOITEM;
                }

                /*
                 * It's an iconic window, so can't be hitting anywhere else.
                 */
                return MFMWFP_OFFMENU;
            }

            /*
             * Check if we are hitting on the system menu rectangle on the top
             * left of windows.
             */
            rect.top = rect.left = 0;
            rect.right  = SYSMET(CXSIZE);
            rect.bottom = SYSMET(CYSIZE);

            cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

            OffsetRect(&rect, pwnd->rcWindow.left + cBorders*SYSMET(CXBORDER),
                pwnd->rcWindow.top + cBorders*SYSMET(CYBORDER));
            /*
             * Mirror the rect because the buttons in the left hand side of the window if it mirrored
             */
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                cx         = rect.right - rect.left;
                rect.right = pwnd->rcWindow.right - (rect.left - pwnd->rcWindow.left);
                rect.left  = rect.right - cx;
            }

            if (PtInRect(&rect, pt)) {
                *pIndex = 0;
                return MFMWFP_NOITEM;
            }
            /*
             * Check if we hit in the alternate menu if available.
             */
            if (ppopupmenu->spmenuAlternate) {
                itemHit = MNItemHitTest(ppopupmenu->spmenuAlternate, pwnd, pt);
                if (itemHit != MFMWFP_NOITEM) {
                    *pIndex = itemHit;
                    return MFMWFP_ALTMENU;
                }
            }
            return MFMWFP_OFFMENU;
        } else {
            if (TestWF(ppopupmenu->spwndNotify, WFMINIMIZED)) {

                /*
                 * If we are minimized, we can't hit on the main menu bar.
                 */
                return MFMWFP_OFFMENU;
            }
        }
    } else {
        pwnd = ppopupmenu->spwndPopupMenu;

        /*
         * else this is a popup window and we need to check if we are hitting
         * anywhere on this popup window.
         */
        pt.x = screenPt.x;
        pt.y = screenPt.y;
        if (!PtInRect(&pwnd->rcWindow, pt)) {

            /*
             * Point completely outside the popup menu window so return 0.
             */
            return MFMWFP_OFFMENU;
        }
    }

    pt.x = screenPt.x;
    pt.y = screenPt.y;

    itemHit = MNItemHitTest(ppopupmenu->spmenu, pwnd, pt);

    if (ppopupmenu->fIsMenuBar) {

        /*
         * If hit is on menu bar but no item is there, treat it as if the user
         * hit nothing.
         */
        if (itemHit == MFMWFP_NOITEM) {

            /*
             * Check if we hit in the alternate menu if available.
             */
            if (ppopupmenu->spmenuAlternate) {
                itemHit = MNItemHitTest(ppopupmenu->spmenuAlternate, pwnd, pt);
                if (itemHit != MFMWFP_NOITEM) {
                    *pIndex = itemHit;
                    return MFMWFP_ALTMENU;
                }
            }
            return MFMWFP_OFFMENU;
        }

        *pIndex = itemHit;
        return MFMWFP_NOITEM;
    } else {

        /*
         * If hit is on popup menu but no item is there, itemHit
         * will be MFMWFP_NOITEM
         */
        *pIndex = itemHit;
        return (LONG_PTR)pwnd;
    }
    return MFMWFP_OFFMENU;
}

/***************************************************************************\
* xxxMNCancel
*
* Should only be sent to the top most ppopupmenu/menu window in the
* hierarchy.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNCancel(
    PMENUSTATE pMenuState,
    UINT uMsg,
    UINT cmd,
    LPARAM lParam)
{
    PPOPUPMENU ppopupmenu = pMenuState->pGlobalPopupMenu;
    BOOL fSynchronous   = ppopupmenu->fSynchronous;
    BOOL fTrackFlagsSet = ppopupmenu->fIsTrackPopup;
    BOOL fIsSysMenu     = ppopupmenu->fIsSysMenu;
    BOOL fIsMenuBar     = ppopupmenu->fIsMenuBar;
    BOOL fNotify        = !ppopupmenu->fNoNotify;
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndPopupMenu;

    Validateppopupmenu(ppopupmenu);

    pMenuState->fInsideMenuLoop = FALSE;
    pMenuState->fButtonDown = FALSE;
    /*
     * Mark the popup as destroyed so people will not use it anymore.
     * This means that root popups can be marked as destroyed before
     * actually being destroyed (nice and confusing).
     */
    ppopupmenu->fDestroyed = TRUE;

    /*
     * Only the menu loop owner can destroy the menu windows (i.e, xxxMNCloseHierarchy)
     */
    if (PtiCurrent() != pMenuState->ptiMenuStateOwner) {
        RIPMSG1(RIP_WARNING, "xxxMNCancel: Thread %#p doesn't own the menu loop", PtiCurrent());
        return;
    }

    /*
     * If the menu loop is running on a thread different than the thread
     *  that owns spwndNotify, we can have two threads trying to cancel
     *  this popup at the same time.
     */
    if (ppopupmenu->fInCancel) {
        RIPMSG1(RIP_WARNING, "xxxMNCancel: already in cancel. ppopupmenu:%#p", ppopupmenu);
        return;
    }
    ppopupmenu->fInCancel = TRUE;

    ThreadLock(ppopupmenu->spwndPopupMenu, &tlpwndPopupMenu);

    /*
     * Close all hierarchies from this point down.
     */
    xxxMNCloseHierarchy(ppopupmenu, pMenuState);

    /*
     * Unselect any items on this top level window
     */
    xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);

    pMenuState->fMenuStarted = FALSE;

    pwndT = ppopupmenu->spwndNotify;

    ThreadLock(pwndT, &tlpwndT);

    xxxMNReleaseCapture();

    if (fTrackFlagsSet) {
        /*
         * Send a POPUPEND so people watching see them paired
         */
        xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPEND, ppopupmenu->spwndPopupMenu, OBJID_CLIENT, 0, 0);

        xxxDestroyWindow(ppopupmenu->spwndPopupMenu);
    }

    if (pwndT == NULL) {
        ThreadUnlock(&tlpwndT);
        ThreadUnlock(&tlpwndPopupMenu);
        return;
    }

    /*
     * SMS_NOMENU hack so we can send MenuSelect messages with
     * (loword(lparam) = -1) when
     * the menu pops back up for the CBT people. In 3.0, all WM_MENUSELECT
     * messages went through the message filter so go through the function
     * SendMenuSelect. We need to do this in 3.1 since WordDefect for Windows
     * depends on this.
     */
    xxxSendMenuSelect(pwndT, NULL, SMS_NOMENU, MFMWFP_NOITEM);

    xxxWindowEvent(EVENT_SYSTEM_MENUEND, pwndT, (fIsSysMenu ?
        OBJID_SYSMENU : (fIsMenuBar ? OBJID_MENU : OBJID_WINDOW)),
        INDEXID_CONTAINER, 0);

    if (fNotify) {
    /*
     * Notify app we are exiting the menu loop. Mainly for WinOldApp 386.
     * wParam is 1 if a TrackPopupMenu else 0.
     */
        xxxSendMessage(pwndT, WM_EXITMENULOOP,
            ((fTrackFlagsSet && !fIsSysMenu)? 1 : 0), 0);
    }

    if (uMsg != 0) {
        PlayEventSound(USER_SOUND_MENUCOMMAND);
        pMenuState->cmdLast = cmd;
        if (!fSynchronous) {
            if (!fIsSysMenu && fTrackFlagsSet && !TestWF(pwndT, WFWIN31COMPAT)) {
                xxxSendMessage(pwndT, uMsg, cmd, lParam);
            } else {
                _PostMessage(pwndT, uMsg, cmd, lParam);
            }
        }
    } else
        pMenuState->cmdLast = 0;

    ThreadUnlock(&tlpwndT);

    ThreadUnlock(&tlpwndPopupMenu);

}
/***************************************************************************\
* xxxMNButtonDown
*
* Handles a mouse down on the menu associated with ppopupmenu at item index
* posItemHit. posItemHit could be MFMWFP_NOITEM if user hit on a menu where
* no item exists.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNButtonDown(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT posItemHit, BOOL fClick)
{
    PITEM  pItem;
    BOOL   fOpenHierarchy;

    /*
     * A different item was hit than is currently selected, so select it
     * and drop its menu if available. Make sure we toggle click state.
     */
    if (ppopupmenu->posSelectedItem != posItemHit) {
        /*
         * We are clicking on a new item, not moving the mouse over to it.
         * So reset cancel toggle state. We don't want button up from
         * this button down to cancel.
         */
        if (fClick) {
            fOpenHierarchy = TRUE;
            ppopupmenu->fToggle = FALSE;
        }
        else
        {
            fOpenHierarchy = (ppopupmenu->fDropNextPopup != 0);
        }


        /*
         * If the item has a popup and isn't disabled, open it. Note that
         * selecting this item will cancel any hierarchies associated with
         * the previously selected item.
         */
        pItem = xxxMNSelectItem(ppopupmenu, pMenuState, posItemHit);
        if (MNIsPopupItem(pItem) && fOpenHierarchy) {
            /* Punt if menu was destroyed. */
            if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1) {
                return;
            }
        }
    } else {
        /*
         * We are moving over to the already-selected item. If we are
         * clicking for real, reset cancel toggle state. We want button
         * up to cancel if on same item. Otherwise, do nothing if just
         * moving...
         */
        if (fClick) {
            ppopupmenu->fToggle = TRUE;
        }

        if (!xxxMNHideNextHierarchy(ppopupmenu) && fClick && xxxMNOpenHierarchy(ppopupmenu, pMenuState))
            ppopupmenu->fToggle = FALSE;
    }

    if (fClick) {
        pMenuState->fButtonDown = TRUE;
        xxxMNDoScroll(ppopupmenu, posItemHit, TRUE);
    }
}

/***************************************************************************\
* MNSetTimerToAutoDissmiss
*
* History:
*  11/14/96 GerardoB  Created
\***************************************************************************/
VOID MNSetTimerToAutoDismiss(
    PMENUSTATE pMenuState,
    PWND pwnd)
{
    if (pMenuState->fAutoDismiss && !pMenuState->fAboutToAutoDismiss) {
        if (_SetTimer(pwnd, IDSYS_MNAUTODISMISS, 16 * gdtMNDropDown, NULL)) {
            pMenuState->fAboutToAutoDismiss = TRUE;
        } else {
            RIPMSG0(RIP_WARNING, "xxxMNMouseMove: Failed to set autodismiss timer");
        }
    }
}

/***************************************************************************\
* xxxMNMouseMove
*
* Handles a mouse move to the given point.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNMouseMove(
    PPOPUPMENU ppopup,
    PMENUSTATE pMenuState,
    POINTS ptScreen)
{
    LONG_PTR cmdHitArea;
    UINT uFlags;
    UINT cmdItem;
    PWND pwnd;
    TL tlpwndT;


    if (!IsRootPopupMenu(ppopup)) {
        RIPMSG0(RIP_ERROR,
            "MenuMouseMoveHandler() called for a non top most menu");
        return;
    }

    /*
     * Ignore mouse moves that aren't really moves. MSTEST jiggles
     * the mouse for some reason. And windows coming and going will
     * force mouse moves, to reset the cursor.
     */
    if ((ptScreen.x == pMenuState->ptMouseLast.x) && (ptScreen.y == pMenuState->ptMouseLast.y))
        return;

    pMenuState->ptMouseLast.x = ptScreen.x;
    pMenuState->ptMouseLast.y = ptScreen.y;

    /*
     * Find out where this mouse move occurred.
     */
    cmdHitArea = xxxMNFindWindowFromPoint(ppopup, &cmdItem, ptScreen);

    /*
     * If coming from an IDropTarget call out, remember the hit test
     */
    if (pMenuState->fInDoDragDrop) {
        xxxMNUpdateDraggingInfo(pMenuState, cmdHitArea, cmdItem);
    }

    if (pMenuState->mnFocus == KEYBDHOLD) {
        /*
         * Ignore mouse moves when in keyboard mode if the mouse isn't over any
         * menu at all. Also ignore mouse moves if over minimized window,
         * because we pretend that its entire window is like system menu.
         */
        if ((cmdHitArea == MFMWFP_OFFMENU) ||
            ((cmdHitArea == MFMWFP_NOITEM) && TestWF(ppopup->spwndNotify, WFMINIMIZED))) {
            return;
        }

        pMenuState->mnFocus = MOUSEHOLD;
    }

    if (cmdHitArea == MFMWFP_ALTMENU) {
        /*
         * User clicked in the other menu so switch to it ONLY IF
         * MOUSE IS DOWN. Usability testing proves that people frequently
         * get kicked into the system menu accidentally when browsing the
         * menu bar. We support the Win3.1 behavior when the mouse is
         * down however.
         */
        if (pMenuState->fButtonDown) {
            xxxMNSwitchToAlternateMenu(ppopup);
            cmdHitArea = MFMWFP_NOITEM;
        } else
            goto OverNothing;
    }

    if (cmdHitArea == MFMWFP_NOITEM) {
        /*
         * Mouse move occurred to an item in the main menu bar. If the item
         * is different than the one already selected, close up the current
         * one, select the new one and drop its menu. But if the item is the
         * same as the one currently selected, we need to pull up any popups
         * if needed and just keep the current level visible. Hey, this is
         * the same as a mousedown so lets do that instead.
         */
        xxxMNButtonDown(ppopup, pMenuState, cmdItem, FALSE);
        return;
    } else if (cmdHitArea != 0) {
        /* This is a popup window we moved onto. */
        pwnd = (PWND)(cmdHitArea);
        ThreadLock(pwnd, &tlpwndT);

        UserAssert(TestWF(pwnd, WFVISIBLE));

        /*
         * Modeless menus don't capture the mouse, so track it to know
         *  when it leaves the popup.
         */
        ppopup = ((PMENUWND)pwnd)->ppopupmenu;
        if (pMenuState->fModelessMenu
                && !pMenuState->fInDoDragDrop
                && !ppopup->fTrackMouseEvent) {

            TRACKMOUSEEVENT tme;

            /* tme.cbSize = sizeof(TRACKMOUSEEVENT); Not checked on kernel side */
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = PtoH(pwnd);
            TrackMouseEvent(&tme);
            ppopup->fTrackMouseEvent = TRUE;

            /*
             * We just entered this window so make sure the cursor
             *  is properly set.
             */
            xxxSendMessage(pwnd, WM_SETCURSOR, (WPARAM)HWq(pwnd), MAKELONG(MSGF_MENU, 0));

        }

        /*
         * Select the item.
         */
        uFlags = (UINT)xxxSendMessage(pwnd, MN_SELECTITEM, (WPARAM)cmdItem, 0L);
        if ((uFlags & MF_POPUP) && !(uFlags & MFS_GRAYED)) {
           /*
            * User moved back onto an item with a hierarchy. Hide the
            * the dropped popup.
            */
           if (!xxxSendMessage(pwnd, MN_SETTIMERTOOPENHIERARCHY, 0, 0L)) {
                xxxMNHideNextHierarchy(ppopup);
           }
        }
        ThreadUnlock(&tlpwndT);
    } else
OverNothing:
    {
        /* We moved off all menu windows... */
        if (ppopup->spwndActivePopup != NULL) {
            pwnd = ppopup->spwndActivePopup;

            ThreadLock(pwnd, &tlpwndT);
            xxxSendMessage(pwnd, MN_SELECTITEM, MFMWFP_NOITEM, 0L);
            MNSetTimerToAutoDismiss(pMenuState, pwnd);
            ThreadUnlock(&tlpwndT);
        } else {
            xxxMNSelectItem(ppopup, pMenuState, MFMWFP_NOITEM);
        }

    }
}


/***************************************************************************\
* xxxMNButtonUp
*
*  Handles a mouse button up at the given point.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNButtonUp(
    PPOPUPMENU ppopup,
    PMENUSTATE pMenuState,
    UINT posItemHit,
    LPARAM lParam)
{
    PITEM pItem;

    if (!pMenuState->fButtonDown) {

        /*
         * Ignore if button was never down... Really shouldn't happen...
         */
        return;
    }

    if (posItemHit == MFMWFP_NOITEM) {
        RIPMSG0(RIP_WARNING, "button up on no item");
        goto ExitButtonUp;
    }

    if (ppopup->posSelectedItem != posItemHit) {
        goto ExitButtonUp;
    }

    if (ppopup->fIsMenuBar) {

        /*
         * Handle button up in menubar specially.
         */
        if (ppopup->fHierarchyDropped) {
            if (!ppopup->fToggle) {
                goto ExitButtonUp;
            } else {
                /*
                 * Cancel menu now.
                 */
                ppopup->fToggle = FALSE;
                xxxMNDismiss(pMenuState);
                return;
            }
        }
    } else if (ppopup->fShowTimer) {
        ppopup->fToggle = FALSE;

        /*
         * Open hierarchy on popup
         */
        xxxMNOpenHierarchy(ppopup, pMenuState);

        goto ExitButtonUp;
    }

    /*
     * If nothing is selected, get out. This occurs mainly on unbalanced
     * multicolumn menus where one of the columns isn't completely full.
     */
    if (ppopup->posSelectedItem == MFMWFP_NOITEM)
        goto ExitButtonUp;

    if (ppopup->posSelectedItem >= ppopup->spmenu->cItems)
        goto ExitButtonUp;

    /*
     * Get a pointer to the currently selected item in this menu.
     */
    pItem = &(ppopup->spmenu->rgItems[ppopup->posSelectedItem]);

    /*
     * Kick out of menu mode if user clicked on a non-separator, enabled,
     * non-hierarchical item.
     *
     * BOGUS
     * Why doesn't MFS_GRAYED check work for separators now?  Find out later.
     */
    if (!(pItem->fType & MFT_SEPARATOR)
            && !(pItem->fState & MFS_GRAYED)
            && (pItem->spSubMenu == NULL)) {

        xxxMNDismissWithNotify(pMenuState, ppopup->spmenu, pItem,
                               ppopup->posSelectedItem, lParam);
        return;
    }

ExitButtonUp:
    pMenuState->fButtonDown =
    pMenuState->fButtonAlwaysDown = FALSE;
}


/***************************************************************************\
*UINT MenuSetTimerToOpenHierarchy(PPOPUPMENU ppopupmenu)
* Given the current selection, set a timer to show this hierarchy if
* valid else return 0. If a timer should be set but couldn't return -1.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
UINT MNSetTimerToOpenHierarchy(
    PPOPUPMENU ppopup)
{
    PITEM pItem;

    /*
     * No selection so fail
     */
    if (ppopup->posSelectedItem == MFMWFP_NOITEM) {
        return 0;
    }

    if (ppopup->posSelectedItem >= ppopup->spmenu->cItems) {
        return 0;
    }

    /*
     * Is item an enabled popup?
     * Get a pointer to the currently selected item in this menu.
     */
    pItem = ppopup->spmenu->rgItems + ppopup->posSelectedItem;
    if ((pItem->spSubMenu == NULL) || (pItem->fState & MFS_GRAYED)) {
        return 0;
    }

    if (ppopup->fShowTimer
        || (ppopup->fHierarchyDropped
            && (ppopup->posSelectedItem == ppopup->posDropped))) {

        /*
         * A timer is already set or the hierarchy is already opened.
         */
        return 1;
    }

    if (!_SetTimer(ppopup->spwndPopupMenu, IDSYS_MNSHOW, gdtMNDropDown, NULL)) {
        return (UINT)-1;
    }

    ppopup->fShowTimer = TRUE;

    return 1;
}


/***************************************************************************\
* MNSetTimerToCloseHierarchy
*
\***************************************************************************/
UINT MNSetTimerToCloseHierarchy(
    PPOPUPMENU ppopup)
{

    if (!ppopup->fHierarchyDropped) {
        return 0;
    }

    if (ppopup->fHideTimer) {
        return 1;
    }

    if (!_SetTimer(ppopup->spwndPopupMenu, IDSYS_MNHIDE, gdtMNDropDown, NULL)) {
        return (UINT)-1;
    }

    ppopup->fHideTimer = TRUE;

    ppopup = ((PMENUWND)(ppopup->spwndNextPopup))->ppopupmenu;
    ppopup->fAboutToHide = TRUE;

    return 1;
}


/***************************************************************************\
* xxxCallHandleMenuMessages
*
* Modeless menus don't have a modal loop so we don't see the messages until
* they are dispatched to xxxMenuWindowProc. So we call this function to
* process the message just like we would in the modal case, only that
* the message has already been pulled out of the queue.
*
* This is also calledfrom xxxScanSysQueue to pass mouse messages on the menu
* bar or from xxxMNDragOver to upadate the mouse position when being draged over.
*
* History:
* 10/25/96 GerardoB  Created
\***************************************************************************/
BOOL xxxCallHandleMenuMessages(
    PMENUSTATE pMenuState,
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled;
    MSG msg;

    CheckLock(pwnd);

    UserAssert(pMenuState->fModelessMenu || pMenuState->fInDoDragDrop);

    /*
     * Since modeless menus don't capture the mouse, then we need to
     *  keep checking on the mouse button when the mouse is off the
     *  menu.
     * Note that we do not set fMouseOffMenu if fInDoDragDrop is set
     */
    if (pMenuState->fMouseOffMenu && pMenuState->fButtonDown) {
        UserAssert(!pMenuState->fInDoDragDrop && pMenuState->fModelessMenu);
        MNCheckButtonDownState(pMenuState);
    }

    /*
     * Setup the msg structure
     */
    msg.hwnd = HW(pwnd);
    msg.message = message;
    msg.wParam = wParam;

    /*
     * xxxHandleMenuMessages expects screen coordinates
     */
    if ((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST)) {
        msg.lParam = MAKELONG(GET_X_LPARAM(lParam) + pwnd->rcClient.left,
                              GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
    } else {
        msg.lParam = lParam;
    }

    /*
     * Not used by xxxHandleMenuMessages
     */
    msg.time = 0;
    msg.pt.x = msg.pt.x = 0;


    UserAssert(pMenuState->pGlobalPopupMenu != NULL);

    pMenuState->fInCallHandleMenuMessages = TRUE;
    fHandled = xxxHandleMenuMessages(&msg, pMenuState, pMenuState->pGlobalPopupMenu);
    pMenuState->fInCallHandleMenuMessages = FALSE;

    /*
     * If the message was handled and this is a modeless menu,
     *  check to see if it's time to go.
     */
    if (fHandled
            && pMenuState->fModelessMenu
            && ExitMenuLoop (pMenuState, pMenuState->pGlobalPopupMenu)) {

        xxxEndMenuLoop (pMenuState, pMenuState->pGlobalPopupMenu);
        xxxMNEndMenuState(TRUE);
    }

    return fHandled;
}

/***************************************************************************\
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
*  08-12-96 jparsons Catch NULL lParam on WM_CREATE [51986]
\***************************************************************************/
LRESULT xxxMenuWindowProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fIsRecursedMenu;
    LRESULT lRet;
    PAINTSTRUCT ps;
    PPOPUPMENU ppopupmenu;
    PMENUSTATE pMenuState;
    PMENU      pmenu;
    PITEM      pItem;
    TL tlpmenu;
    TL tlpwndNotify;
    PDESKTOP pdesk = pwnd->head.rpdesk;
    POINT ptOrg;
    HDC hdcAni;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, FNID_MENU, WM_NCCREATE);

    /*
     * If we're not in menu mode or this window is just being created,
     *  there are only few messages we care about.
     */
    pMenuState = GetpMenuState(pwnd);
    ppopupmenu = ((PMENUWND)pwnd)->ppopupmenu;
    pmenu = (ppopupmenu != NULL ? ppopupmenu->spmenu : NULL);
    if ((pMenuState == NULL) || (pmenu == NULL)) {
        switch (message) {
            case WM_NCCREATE:
            case WM_FINALDESTROY:
                break;

            case MN_SETHMENU:
                if (ppopupmenu != NULL) {
                    break;
                } else {
                    return 0;
                }

            default:
                goto CallDWP;
        }
    } else {
        /*
         * TPM_RECURSE support: make sure we grab the proper pMenuState.
         */
        fIsRecursedMenu = ((ppopupmenu->ppopupmenuRoot != NULL)
                            && IsRecursedMenuState(pMenuState, ppopupmenu));
        if (fIsRecursedMenu) {
            while (IsRecursedMenuState(pMenuState, ppopupmenu)
                    && (pMenuState->pmnsPrev != NULL)) {
                pMenuState = pMenuState->pmnsPrev;
            }
            UserAssert(pMenuState->pGlobalPopupMenu == ppopupmenu->ppopupmenuRoot);
        }

        Validateppopupmenu(ppopupmenu);

        /*
         * If this is a modeless menu, give xxxHandleMenuMessages the first
         *  shot at the message
         */
        if (pMenuState->fModelessMenu && !pMenuState->fInCallHandleMenuMessages) {
            /*
             * If this is a recursed menu, we don't want to process any
             *  input for it until the current menu goes away.
             */
            if (fIsRecursedMenu) {
                if (((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST))
                        || ((message >= WM_KEYFIRST) && (message <= WM_KEYLAST))
                        || ((message >= WM_NCMOUSEFIRST) && (message <= WM_NCMOUSELAST))) {

                    goto CallDWP;
                }
            } else {
                if (xxxCallHandleMenuMessages(pMenuState, pwnd, message, wParam, lParam)) {
                    return 0;
                }
            }
        }
    }

    switch (message) {
    case WM_NCCREATE:
        /*
         * Ignore evil messages to prevent leaks.
         * Use RIP_ERROR for a while to make sure to see if we're getting here
         */
        if (((PMENUWND)pwnd)->ppopupmenu != NULL) {
            RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: evil WM_NCCREATE. already initialized. pwnd:%p", pwnd);
            return FALSE;
        }
        ppopupmenu = MNAllocPopup(TRUE);
        if (ppopupmenu == NULL) {
            return FALSE;
        }

        ((PMENUWND)pwnd)->ppopupmenu = ppopupmenu;
        ppopupmenu->posSelectedItem = MFMWFP_NOITEM;
        Lock(&(ppopupmenu->spwndPopupMenu), pwnd);
        return TRUE;

    case WM_NCCALCSIZE:
        xxxDefWindowProc(pwnd, message, wParam, lParam);
        if (pmenu->dwArrowsOn != MSA_OFF) {
            InflateRect((PRECT)lParam, 0, -gcyMenuScrollArrow);
        }
        break;

    case WM_ERASEBKGND:
        if (pmenu->hbrBack != NULL) {
            MNEraseBackground ((HDC) wParam, pmenu,
                    0, 0,
                    pwnd->rcClient.right - pwnd->rcClient.left,
                    pwnd->rcClient.bottom - pwnd->rcClient.top);
            return TRUE;
        } else {
            goto CallDWP;
        }
        break;

    case WM_PRINT:
         /*
          * default processing of WM_PRINT does not handle custom non-
          * client painting -- which scrollable menus have -- so take
          * care of drawing nonclient area and then let DefWindowProc
          * handle the rest
          */
        if ((lParam & PRF_NONCLIENT) && (pmenu->dwArrowsOn != MSA_OFF)) {
            BOOL   bMirrorThisDC = (wParam && TestWF(pwnd, WEFLAYOUTRTL) && !MIRRORED_HDC((HDC)wParam));
            DWORD  dwOldLayout;

            if (bMirrorThisDC) {
                dwOldLayout = GreSetLayout((HDC)wParam , pwnd->rcWindow.right - pwnd->rcWindow.left, LAYOUT_RTL);
            }

            MNDrawFullNC(pwnd, (HDC)wParam, ppopupmenu);

            if (bMirrorThisDC) {
                GreSetLayout((HDC)wParam , pwnd->rcWindow.right - pwnd->rcWindow.left, dwOldLayout);
            }

            GreGetWindowOrg((HDC)wParam, &ptOrg);
            GreSetWindowOrg((HDC)wParam,
                  ptOrg.x - MNXBORDER,
                  ptOrg.y - MNYBORDER - gcyMenuScrollArrow,
                  NULL);
            xxxDefWindowProc(pwnd, message, wParam, lParam & ~PRF_NONCLIENT);
            GreSetWindowOrg((HDC)wParam, ptOrg.x, ptOrg.y, NULL);

        } else {
            if (MNIsFlatMenu()) {
                /*
                 * Need to have DWP draw first so that WM_PRINTCLIENT gets sent
                 * to fill in the inside. After this is done, come back and
                 * redraw over the frame with the correct menu edge.
                 */
                lRet = xxxDefWindowProc(pwnd, message, wParam, lParam);
                MNDrawEdge(pmenu, (HDC)wParam, &pwnd->rcWindow, 0);
                return lRet;
            } else {
                goto CallDWP;
            }
        }
        break;

    case WM_WINDOWPOSCHANGING:
        if (!(((LPWINDOWPOS)lParam)->flags & SWP_SHOWWINDOW))
            goto CallDWP;

        if (!TestEffectUP(MENUANIMATION) || !(ppopupmenu->iDropDir & PAS_OUT)
            || (glinp.dwFlags & (LINP_KEYBOARD | LINP_JOURNALLING))
            || (GetAppCompatFlags2(VER40) & GACF2_ANIMATIONOFF)) {
NoAnimation:
            ppopupmenu->iDropDir &= ~PAS_OUT;
            goto CallDWP;
        }

        /*
         * Create the animation bitmap.
         */
        pMenuState->cxAni = pwnd->rcWindow.right - pwnd->rcWindow.left;
        pMenuState->cyAni = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        if (TestALPHA(MENUFADE)) {
            if ((hdcAni = CreateFade(pwnd, NULL, CMS_MENUFADE,
                    FADE_SHOW | FADE_MENU)) == NULL) {
                goto NoAnimation;
            }
        } else {

            if (!MNCreateAnimationBitmap(pMenuState, pMenuState->cxAni,
                    pMenuState->cyAni)) {
                goto NoAnimation;
            }

            /*
             * We shouldn't be animating at this time.
             */
            UserAssert(pMenuState->hdcWndAni == NULL);

            /*
             * This window must be the active popup
             */
            UserAssert(pMenuState->pGlobalPopupMenu->spwndActivePopup == pwnd);

            /*
             * Initialize animation info
             */
            pMenuState->hdcWndAni = _GetDCEx(pwnd, HRGN_FULL, DCX_WINDOW | DCX_USESTYLE | DCX_INTERSECTRGN);
            pMenuState->iAniDropDir = ppopupmenu->iDropDir;
            pMenuState->ixAni = (pMenuState->iAniDropDir & PAS_HORZ) ? 0 : pMenuState->cxAni;
            pMenuState->iyAni = (pMenuState->iAniDropDir & PAS_VERT) ? 0 : pMenuState->cyAni;
            hdcAni = pMenuState->hdcAni;
        }

        /*
         * MFWINDOWDC is used by MNEraseBackground to determine where the
         *  brush org should be set.
         */
        SetMF(pmenu, MFWINDOWDC);

        xxxSendMessage(pwnd, WM_PRINT, (WPARAM)hdcAni, PRF_CLIENT | PRF_NONCLIENT | PRF_ERASEBKGND);

        ClearMF(pmenu, MFWINDOWDC);

        /*
         * While the window is still hidden, load the first fade animation
         * frame to avoid flicker when the window is actually shown.
         *
         * There would still be flicker with slide animations, though. It
         * could be fixed by using the window region, similar to
         * AnimateWindow. For now, too many functions would become xxx, so
         * let's not do it, unless it becomes a big issue.
         */
        if (TestFadeFlags(FADE_MENU)) {
            ShowFade();
        }
        goto CallDWP;

    case WM_WINDOWPOSCHANGED:
        if (!(((LPWINDOWPOS)lParam)->flags & SWP_SHOWWINDOW))
            goto CallDWP;

        /*
         * If not animating, nothing else to do here.
         */
        if (!(ppopupmenu->iDropDir & PAS_OUT))
            goto CallDWP;

        /*
         * Start the animation cycle now.
         */
        if (TestFadeFlags(FADE_MENU)) {
            StartFade();
        } else {
            pMenuState->dwAniStartTime = NtGetTickCount();
            _SetTimer(pwnd, IDSYS_MNANIMATE, 1, NULL);
        }
        ppopupmenu->iDropDir &= ~PAS_OUT;
        goto CallDWP;

    case WM_NCPAINT:
        if (ppopupmenu->iDropDir & PAS_OUT) {

            /*
             * When animating, validate itself to ensure no further drawing
             * that is not related to the animation.
             */
            xxxValidateRect(pwnd, NULL);
        } else {

            /*
             * If we have scroll bars, draw them
             */
            if (pmenu->dwArrowsOn != MSA_OFF) {

                HDC hdc = _GetDCEx(pwnd, (HRGN)wParam,
                        DCX_USESTYLE | DCX_WINDOW | DCX_INTERSECTRGN | DCX_NODELETERGN | DCX_LOCKWINDOWUPDATE);
                MNDrawFullNC(pwnd, hdc, ppopupmenu);
                _ReleaseDC(hdc);
            } else {
                if (MNIsFlatMenu()) {
                    HDC hdc;
                    hdc = _GetDCEx(pwnd, (HRGN)wParam,
                            DCX_USESTYLE | DCX_WINDOW | DCX_INTERSECTRGN | DCX_NODELETERGN | DCX_LOCKWINDOWUPDATE);
                    MNDrawEdge(pmenu, hdc, &pwnd->rcWindow, 0);
                    _ReleaseDC(hdc);
                } else {
                    goto CallDWP;
                }
            }
        }
        break;

    case WM_PRINTCLIENT:
        ThreadLock(pmenu, &tlpmenu);
        xxxMenuDraw((HDC)wParam, pmenu);
        ThreadUnlock(&tlpmenu);
        break;

      case WM_FINALDESTROY:
        /*
         * If we're animating, we must haved been killed in a rude way....
         */
        UserAssert((pMenuState == NULL) || (pMenuState->hdcWndAni == NULL));

        /*
         * If this is a drag and drop menu, then call RevokeDragDrop.
         */
        if ((pMenuState != NULL) && pMenuState->fDragAndDrop) {
            if (!SUCCEEDED(xxxClientRevokeDragDrop(HW(pwnd)))) {
                RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: xxxClientRevokeRegisterDragDrop failed:%#p", pwnd);
            }
        }

        xxxMNDestroyHandler(ppopupmenu);
        return 0;


      case WM_PAINT:
        ThreadLock(pmenu, &tlpmenu);
        xxxBeginPaint(pwnd, &ps);
        xxxMenuDraw(ps.hdc, pmenu);
        xxxEndPaint(pwnd, &ps);
        ThreadUnlock(&tlpmenu);
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        xxxMNChar(ppopupmenu, pMenuState, (UINT)wParam);
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        xxxMNKeyDown(ppopupmenu, pMenuState, (UINT)wParam);
        break;

    case WM_TIMER:
        switch (wParam) {
            case IDSYS_MNSHOW:
                /*
                 * Open the window and kill the show timer.
                 *
                 * Cancel any toggle state we might have. We don't
                 * want to dismiss this on button up if shown from
                 * button down.
                 */
                ppopupmenu->fToggle = FALSE;
                xxxMNOpenHierarchy(ppopupmenu, pMenuState);
                break;

            case IDSYS_MNHIDE:
                ppopupmenu->fToggle = FALSE;
                xxxMNCloseHierarchy(ppopupmenu,pMenuState);
                break;

            case IDSYS_MNUP:
            case IDSYS_MNDOWN:
                if (pMenuState->fButtonDown) {
                    xxxMNDoScroll(ppopupmenu, (UINT)wParam, FALSE);
                } else {
                    _KillTimer(pwnd, (UINT)wParam);
                }
                break;

            case IDSYS_MNANIMATE:
                if (pMenuState->hdcWndAni != NULL) {
                    MNAnimate(pMenuState, TRUE);
                } else {
                    /*
                     * This timer shouldn't be set. Left over in msg queue?
                     */
                    UserAssert(pMenuState->hdcWndAni != NULL);
                }
                break;

            case IDSYS_MNAUTODISMISS:
                /*
                 * This is a one shot timer, so kill it.
                 * Dismiss the popup if the flag hasn't been reset.
                 */
                _KillTimer(pwnd, IDSYS_MNAUTODISMISS);
                if (pMenuState->fAboutToAutoDismiss) {
                    goto EndMenu;
                }
        }
        break;

    /*
     * Menu messages.
     */
    case MN_SETHMENU:

         /*
          * wParam - new hmenu to associate with this menu window
          * Don't let them set the spmenu to NULL of we have to deal with
          *  that all over. Use RIP_ERROR for a while to make sure this is OK
          */
        if (wParam != 0) {
            if ((wParam = (WPARAM)ValidateHmenu((HMENU)wParam)) == 0) {
                break;
            }
            LockPopupMenu(ppopupmenu, &(ppopupmenu->spmenu), (PMENU)wParam);
        } else {
            RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: MN_SETHMENU ignoring NULL wParam. pwnd:%p", pwnd);
        }
        break;

    case MN_GETHMENU:

        /*
         * returns the hmenu associated with this menu window
         */
        return (LRESULT)PtoH(pmenu);

    case MN_SIZEWINDOW:
        {

            /*
             * Computes the size of the menu associated with this window and resizes
             * it if needed. Size is returned x in loword, y in highword. wParam
             * is 0 to just return new size. wParam is non zero if we should also resize
             * window.
             * When called by xxxMNUpdateShownMenu, we might need to redraw the
             *  frame (i.e, the scrollbars). So we check for MNSW_DRAWFRAME in wParam.
             *  If some app is sending this message and that bit is set, then we'll
             *  do some extra work, but I think everything should be cool.
             */
            int         cx, cy;
            PMONITOR    pMonitor;

            /*
             * Call menucomputeHelper directly since this is the entry point for
             * non toplevel menu bars.
             */
            if (pmenu == NULL)
                break;

            ThreadLockAlways(pmenu, &tlpmenu);
            ThreadLock(ppopupmenu->spwndNotify, &tlpwndNotify);
            UserAssert(pmenu->spwndNotify == ppopupmenu->spwndNotify);
            xxxMNCompute(pmenu, ppopupmenu->spwndNotify, 0, 0, 0, 0);
            ThreadUnlock(&tlpwndNotify);
            ThreadUnlock(&tlpmenu);

            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
            cx = pmenu->cxMenu;
            cy = MNCheckScroll(pmenu, pMonitor);

            /*
             * Size the window?
             */
            if (wParam != 0) {
                LONG    lPos;
                int     x, y;
                DWORD   dwFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOOWNERZORDER;

                /*
                 * Need to redraw the frame?
                 */
                if (wParam & MNSW_DRAWFRAME) {
                    dwFlags |= SWP_DRAWFRAME;
                }

                /*
                 * If the window is visible, it's being resized while
                 *  shown. So make sure that it still fits on the screen
                 *  (i.e, move it to the best pos).
                 */
                if (TestWF(pwnd, WFVISIBLE)) {
                    lPos = FindBestPos(
                            pwnd->rcWindow.left,
                            pwnd->rcWindow.top,
                            cx,
                            cy,
                            NULL,
                            0,
                            ppopupmenu,
                            pMonitor);

                    x = GET_X_LPARAM(lPos);
                    y = GET_Y_LPARAM(lPos);
                } else {
                    dwFlags |= SWP_NOMOVE;
                }

                xxxSetWindowPos(
                        pwnd,
                        PWND_TOP,
                        x,
                        y,
                        cx + 2 * SYSMET(CXFIXEDFRAME),    /* For shadow */
                        cy + 2 * SYSMET(CYFIXEDFRAME),    /* For shadow */
                        dwFlags);

            }

            return MAKELONG(cx, cy);
        }

    case MN_OPENHIERARCHY:
        {
            PWND pwndT;
            /*
             * Opens one level of the hierarchy at the selected item, if
             * present. Return 0 if error, else hwnd of opened hierarchy.
             */
            pwndT = xxxMNOpenHierarchy(ppopupmenu, pMenuState);
            return (LRESULT)HW(pwndT);
        }

    case MN_CLOSEHIERARCHY:
        xxxMNCloseHierarchy(ppopupmenu, pMenuState);
        break;

    case MN_SELECTITEM:
        /*
         * wParam - the item to select. Must be a valid
         * Returns the item flags of the wParam (0 if failure)
         */
        if ((wParam >= pmenu->cItems) && (wParam < MFMWFP_MINVALID)) {
            UserAssertMsg1(FALSE, "Bad wParam %x for MN_SELECTITEM", wParam);
            break;
        }

        pItem = xxxMNSelectItem(ppopupmenu, pMenuState, (UINT)wParam);
        if (pItem != NULL) {
            return((LONG)(DWORD)(WORD)(pItem->fState |
                ((pItem->spSubMenu != NULL) ? MF_POPUP : 0)));
        }

        break;

    case MN_SELECTFIRSTVALIDITEM:
        {
            UINT item;

            item = MNFindNextValidItem(pmenu, -1, 1, TRUE);
            xxxSendMessage(pwnd, MN_SELECTITEM, item, 0L);
            return (LONG)item;
        }

    case MN_CANCELMENUS:

        /*
         * Cancels all menus, unselects everything, destroys windows, and cleans
         * everything up for this hierarchy. wParam is the command to send and
         * lParam says if it is valid or not.
         */
        xxxMNCancel(pMenuState, (UINT)wParam, (BOOL)LOWORD(lParam), 0);
        break;

    case MN_FINDMENUWINDOWFROMPOINT:
        /*
         * lParam is point to search for from this hierarchy down.
         * returns MFMWFP_* value or a pwnd.
         */
        lRet = xxxMNFindWindowFromPoint(ppopupmenu, (PUINT)wParam, MAKEPOINTS(lParam));

        /*
         * Convert return value to a handle.
         */
        if (IsMFMWFPWindow(lRet)) {
            return (LRESULT)HW((PWND)lRet);
        } else {
            return lRet;
        }


    case MN_SHOWPOPUPWINDOW:
        /*
         * Forces the dropped down popup to be visible and if modeless, also active.
         */
        PlayEventSound(USER_SOUND_MENUPOPUP);
        xxxShowWindow(pwnd, (pMenuState->fModelessMenu ? SW_SHOW : SW_SHOWNOACTIVATE));
        break;

    case MN_ACTIVATEPOPUP:
        /*
         * Activates a popup. This messages is posted in response to WM_ACTIVATEAPP
         *  or WM_ACTIVATE
         */
        UserAssert(pMenuState->fModelessMenu);
        xxxActivateThisWindow(pwnd, 0, 0);
        break;

    case MN_ENDMENU:
        /*
         * End the menu. This message is posted to avoid ending the menu
         *  at randmom moments. By posting the message, the request is
         *  queued after any pending/current processing.
         */
EndMenu:
        xxxEndMenuLoop(pMenuState, pMenuState->pGlobalPopupMenu);
        if (pMenuState->fModelessMenu) {
            UserAssert(!pMenuState->fInCallHandleMenuMessages);
            xxxMNEndMenuState(TRUE);
        }
        return 0;

     case MN_DODRAGDROP:
        /*
         * Let the app know that the user is dragging.
         */
        if (pMenuState->fDragging
                && (ppopupmenu->spwndNotify != NULL)
                && IsMFMWFPWindow(pMenuState->uButtonDownHitArea)) {
            /*
             * Get the pmenu that contains the item being dragged
             */
             pmenu = (((PMENUWND)pMenuState->uButtonDownHitArea)->ppopupmenu)->spmenu;
            /*
             * If this is a modal menu, release the capture lock so
             *  DoDragDrop (if called) can get it.
             */
            if (!pMenuState->fModelessMenu) {
                UserAssert(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED);
                PtiCurrent()->pq->QF_flags &= ~QF_CAPTURELOCKED;
            }

            LockMenuState(pMenuState);
            ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndNotify);

            /*
             * Give them a chance to call DoDragDrop
             */
            pMenuState->fInDoDragDrop = TRUE;
            lRet = xxxSendMessage(ppopupmenu->spwndNotify, WM_MENUDRAG,
                                  pMenuState->uButtonDownIndex, (LPARAM)PtoH(pmenu));
            pMenuState->fInDoDragDrop = FALSE;

            if (lRet == MND_ENDMENU) {
                /*
                 * Go away.
                 */
                ThreadUnlock(&tlpwndNotify);
                if (!xxxUnlockMenuState(pMenuState)) {
                    goto EndMenu;
                } else {
                    return 0;
                }
                break;
             } else {
                 /*
                  * If the user starts dragging, we always
                  *  ignore the following button up
                  */
                 pMenuState->fIgnoreButtonUp = TRUE;
             }

            /*
             * Check the button state since we might have not seen the button up
             * If so, this will cancel the dragging state
             */
            MNCheckButtonDownState(pMenuState);

            /*
             * If this is a modal menu, make sure we recover capture
             */
            if (!pMenuState->fModelessMenu) {
                xxxMNSetCapture(ppopupmenu);
            }

            ThreadUnlock(&tlpwndNotify);
            xxxUnlockMenuState(pMenuState);
        }
        return 0;

    case MN_BUTTONDOWN:

        /*
         * wParam is position (index) of item the button was clicked on.
         * Must be a valid
         */
        if ((wParam >= pmenu->cItems) && (wParam < MFMWFP_MINVALID)) {
            UserAssertMsg1(FALSE, "Bad wParam %x for MN_BUTTONDOWN", wParam);
            break;
        }
        xxxMNButtonDown(ppopupmenu, pMenuState, (UINT)wParam, TRUE);
        break;

    case MN_MOUSEMOVE:

        /*
         * lParam is mouse move coordinate wrt screen.
         */
        xxxMNMouseMove(ppopupmenu, pMenuState, MAKEPOINTS(lParam));
        break;

    case MN_BUTTONUP:

        /*
         * wParam is position (index) of item the button was up clicked on.
         */
        if ((wParam >= pmenu->cItems) && (wParam < MFMWFP_MINVALID)) {
            UserAssertMsg1(FALSE, "Bad wParam %x for MN_BUTTONUP", wParam);
            break;
        }
        xxxMNButtonUp(ppopupmenu, pMenuState, (UINT)wParam, lParam);
        break;

    case MN_SETTIMERTOOPENHIERARCHY:

        /*
         * Given the current selection, set a timer to show this hierarchy if
         * valid else return 0.
         */
        return (LONG)(WORD)MNSetTimerToOpenHierarchy(ppopupmenu);

    case MN_DBLCLK:
            //
            // User double-clicked on item. wParamLo is the item.
            //
        xxxMNDoubleClick(pMenuState, ppopupmenu, (int)wParam);
        break;

    case WM_MOUSELEAVE:
        UserAssert(pMenuState->fModelessMenu);
        /*
         * If we're in DoDragDrop loop, we don't track the mouse
         *  when it goes off the menu window
         */
        pMenuState->fMouseOffMenu = !pMenuState->fInDoDragDrop;
        ppopupmenu->fTrackMouseEvent = FALSE;
        /*
         * See if we need to set the timer to autodismiss
         */
        MNSetTimerToAutoDismiss(pMenuState, pwnd);
        /*
         * If we left the active popup, remove the selection
         */
        if (ppopupmenu->spwndPopupMenu == pMenuState->pGlobalPopupMenu->spwndActivePopup) {
            xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);
        }
        break;

    case WM_ACTIVATEAPP:
        if (pMenuState->fModelessMenu
                && (pwnd == pMenuState->pGlobalPopupMenu->spwndActivePopup)) {
            /*
             * If the application is getting activated,  we post a message
             *  to let the dust settle and then re-activate spwndPopupActive
             */
            if (wParam) {
                _PostMessage(pwnd, MN_ACTIVATEPOPUP, 0, 0);
                /*
                 * If we're not in the foregruond queue, we want to keep
                 *  the frame off.
                 * This flag will also tell us that if we lose activation
                 *  while coming to the foregrund (later), we don't want
                 *  to dismiss the menu.
                 */
                 pMenuState->fActiveNoForeground = (gpqForeground != PtiCurrent()->pq);
            }

            /*
             * Make the notification window frame show that we're active/inactive.
             * If the application is inactive but the user moves the mouse
             *  over the menu, then we can get this message when the first
             *  window in the app gets activated (i.e., the move causes a popup to
             *  be closed/opened). So turn on the frame only if we're in
             *  the foreground.
             */
            if (ppopupmenu->spwndNotify != NULL) {
                ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndNotify);
                xxxDWP_DoNCActivate(ppopupmenu->spwndNotify,
                                    ((wParam && !pMenuState->fActiveNoForeground) ? NCA_ACTIVE : NCA_FORCEFRAMEOFF),
                                    HRGN_FULL);
                ThreadUnlock(&tlpwndNotify);
            }
        }
        break;

     case WM_ACTIVATE:
         if (pMenuState->fModelessMenu) {
             /*
              * If activation is NOT going to a menu window or
              *  it's going to a recursed menu, bail
              */
             if ((LOWORD(wParam) == WA_INACTIVE)
                    && !pMenuState->fInCallHandleMenuMessages
                    && !pMenuState->pGlobalPopupMenu->fInCancel) {

                 lParam = (LPARAM)RevalidateHwnd((HWND)lParam);
                 if ((lParam != 0)
                     && ((GETFNID((PWND)lParam) != FNID_MENU)
                         || IsRecursedMenuState(pMenuState, ((PMENUWND)lParam)->ppopupmenu))) {
                     /*
                      * If we're just coming to the foreground, then
                      *  activate the popup later and stay up.
                      */
                     if (pMenuState->fActiveNoForeground
                            && (gpqForeground == PtiCurrent()->pq)) {

                         pMenuState->fActiveNoForeground = FALSE;
                         _PostMessage(pwnd, MN_ACTIVATEPOPUP, 0, 0);
                     } else {
                         /*
                          * Since the menu window is active, ending the menu
                          *  now would set a new active window, messing the
                          *  current activation that sent us this message.
                          *  so end the menu later.
                          */
                         _PostMessage(pwnd, MN_ENDMENU, 0, 0);
                         break;
                     }
                 }
             }
             goto CallDWP;
         }

       /*
        * We must make sure that the menu window does not get activated.
        * Powerpoint 2.00e activates it deliberately and this causes problems.
        * We try to activate the previously active window in such a case.
        * Fix for Bug #13961 --SANKAR-- 09/26/91--
        */
       /*
        * In Win32, wParam has other information in the hi 16bits, so to
        * prevent infinite recursion, we need to mask off those bits
        * Fix for NT bug #13086 -- 23-Jun-1992 JonPa
        *
        */

       if (LOWORD(wParam)) {
            TL tlpwnd;
            /*
             * This is a super bogus hack. Let's start failing this for 5.0 apps.
             */
            if (Is500Compat(PtiCurrent()->dwExpWinVer)) {
                RIPMSGF1(RIP_WARNING, "Menu window 0x%p activated", pwnd);
                _PostMessage(pwnd, MN_ENDMENU, 0, 0);
                break;
            }

#if 0
           /*
            * Activate the previously active wnd
            */
           xxxActivateWindow(pwnd, AW_SKIP2);
#else
            /*
             * Try the previously active window.
             */
            if ((gpqForegroundPrev != NULL) &&
                    !FBadWindow(gpqForegroundPrev->spwndActivePrev) &&
                    !ISAMENU(gpqForegroundPrev->spwndActivePrev)) {
                pwnd = gpqForegroundPrev->spwndActivePrev;
            } else {

                /*
                 * Find a new active window from the top-level window list.
                 * Bug 78131: Make sure we don't loop for ever. This is a pretty
                 *  unusual scenario (in addtion, normally we should not hit this code path)
                 *  So let's use a counter to rule out the possibility that another
                 *  weird window configuration is going to make us loop for ever
                 */
                PWND pwndMenu = pwnd;
                UINT uCounter = 0;
                do {
                    pwnd = NextTopWindow(PtiCurrent(), pwnd, NULL, 0);
                    if (pwnd && !FBadWindow(pwnd->spwndLastActive) &&
                        !ISAMENU(pwnd->spwndLastActive)) {
                        pwnd = pwnd->spwndLastActive;
                        uCounter = 0;
                        break;
                    }
                } while ((pwnd != NULL) && (uCounter++ < 255));
                /*
                 * If we couldn't find a window, just bail.
                 */
                if (uCounter != 0) {
                    RIPMSG0(RIP_ERROR, "xxxMenuWindowProc: couldn't fix active window");
                    _PostMessage(pwndMenu, MN_ENDMENU, 0, 0);
                    break;
                }
            }

            if (pwnd != NULL) {
                PTHREADINFO pti = PtiCurrent();
                ThreadLockAlwaysWithPti(pti, pwnd, &tlpwnd);

                /*
                 * If GETPTI(pwnd) isn't pqCurrent this is a AW_SKIP* activation
                 * we'll want to a do a xxxSetForegroundWindow().
                 */
                if (GETPTI(pwnd)->pq != pti->pq) {

                    /*
                     * Only allow this if we're on the current foreground queue.
                     */
                    if (gpqForeground == pti->pq) {
                        xxxSetForegroundWindow(pwnd, FALSE);
                    }
                } else {
                    xxxActivateThisWindow(pwnd, 0, ATW_SETFOCUS);
                }

                ThreadUnlock(&tlpwnd);
            }
#endif
       }
       break;

     case WM_SIZE:
     case WM_MOVE:
       /*
        * When a popup has been sized/moved, we need to make
        *  sure any dropped hierarchy is moved accordingly.
        */
       if (ppopupmenu->spwndNextPopup != NULL) {
           pItem = MNGetpItem(ppopupmenu, ppopupmenu->posDropped);
           if (pItem != NULL) {
               int      x, y;
               PMONITOR pMonitorDummy;

               /*
                * If the dropped hierarchy needs to be recomputed, do it
                */
#define pmenuNext (((PMENUWND)ppopupmenu->spwndNextPopup)->ppopupmenu->spmenu)
              if (pmenuNext->cxMenu == 0) {
                  xxxSendMessage(ppopupmenu->spwndNextPopup, MN_SIZEWINDOW, MNSW_RETURNSIZE, 0L);
              }

              /*
               * Find out the new position
               */
              xxxMNPositionHierarchy(ppopupmenu, pItem,
                                     pmenuNext->cxMenu + (2 * SYSMET(CXFIXEDFRAME)),
                                     pmenuNext->cyMenu + (2 * SYSMET(CXFIXEDFRAME)),
                                     &x, &y, &pMonitorDummy);

              /*
               * Move it
               */
              ThreadLockAlways(ppopupmenu->spwndNextPopup, &tlpwndNotify);
              xxxSetWindowPos(ppopupmenu->spwndNextPopup, NULL,
                              x, y, 0, 0,
                              SWP_NOSIZE | SWP_NOZORDER | SWP_NOSENDCHANGING);
              ThreadUnlock(&tlpwndNotify);
#undef pmenuNext
           }
       }
       break;

     case WM_NCHITTEST:
        /*
         * Since modeless menus don't capture the mouse, we
         *  process this message to make sure that we always receive
         *  a mouse move when the mouse in our window.
         * This also causes us to receive the WM_MOUSELEAVE only when
         *  the mouse leaves the window and not just the  client area.
         */
        if (pMenuState->fModelessMenu) {
            ptOrg.x = GET_X_LPARAM(lParam);
            ptOrg.y = GET_Y_LPARAM(lParam);
            if (PtInRect(&pwnd->rcWindow, ptOrg)) {
                return HTCLIENT;
            } else {
                return HTNOWHERE;
            }
        } else {
            goto CallDWP;
        }


    default:
CallDWP:
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\miscutil.c ===
/****************************************************************************\
* Module Name: minmax.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Misc util functions
*
* 10-25-90 MikeHar      Ported from Windows.
* 14-Feb-1991 mikeke    Added Revalidation code (None)
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop


VOID ZapActiveAndFocus(
    VOID)
{
   PQ pq = PtiCurrent()->pq;

   Unlock(&pq->spwndActive);
   Unlock(&pq->spwndFocus);
}

VOID SetDialogPointer(
    PWND pwnd,
    LONG_PTR lPtr)
{

    if (pwnd->cbwndExtra < DLGWINDOWEXTRA ||
        TestWF(pwnd, WFSERVERSIDEPROC) ||
        PpiCurrent() != GETPTI(pwnd)->ppi) {
        RIPMSG1(RIP_WARNING, "SetDialogPointer: Unexpected pwnd 0x%p", pwnd);
        return;
    }

    ((PDIALOG)pwnd)->pdlg = (PDLG)lPtr;

    if (lPtr == 0) {
        pwnd->fnid |= FNID_CLEANEDUP_BIT;
        ClrWF(pwnd, WFDIALOGWINDOW);
    } else {
        if (pwnd->fnid == 0) {
            pwnd->fnid = FNID_DIALOG;
        }
        SetWF(pwnd, WFDIALOGWINDOW);
    }
}

BOOL _SetProgmanWindow(
    PWND pwnd)
{
    PDESKTOPINFO pdeskinfo = GETDESKINFO(PtiCurrent());

    if (pwnd != NULL) {
        /*
         * Fail the call if another progman window exists.
         */
        if (pdeskinfo->spwndProgman != NULL) {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_WARNING,
                    "Progman window already set");
            return FALSE;
        }
    }

    Lock(&pdeskinfo->spwndProgman, pwnd);

    return TRUE;
}

BOOL _SetTaskmanWindow(
    PWND pwnd)
{
    PDESKTOPINFO pdeskinfo = GETDESKINFO(PtiCurrent());

    if (pwnd != NULL) {
        /*
         * Fail the call if another taskman window exists.
         */
        if (pdeskinfo->spwndTaskman != NULL) {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_WARNING,
                    "Taskman window already set");
            return FALSE;
        }
    }

    Lock(&pdeskinfo->spwndTaskman, pwnd);

    return TRUE;
}

/***************************************************************************\
* SetShellWindow
*
* Returns true if shell window is successfully set. Note that we return
* FALSE if a shell window already exists. I.E., this works on a first come,
* first served basis.
*
* We also do NOT allow child windows to be shell windows. Other than that,
* it's up to the caller to size the window appropriately.
*
* The pwndBkGnd is provided for the explorer shell. Since the shellwnd and
* the window which does the drawing of background wallpapers are different,
* we need to provide means by which we can draw directly on the background
* window during hung-app drawing. The pwnd and pwndBkGnd will be identical
* if called through the SetShellWindow() api.
\***************************************************************************/
BOOL xxxSetShellWindow(
    PWND pwnd,
    PWND pwndBkGnd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOPINFO pdeskinfo = GETDESKINFO(ptiCurrent);
    PPROCESSINFO ppiShellProcess;

    UserAssert(pwnd);

    /*
     * Fail the call if another shell window exists.
     */
    if (pdeskinfo->spwndShell != NULL) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "A shellwindow has already been set");
        return FALSE;
    }

    /*
     * The shell window must be
     *      (1) Top-level
     *      (2) Unowned
     *      (3) Not topmost
     */
    if (TestwndChild(pwnd) ||
        pwnd->spwndOwner != NULL ||
        TestWF(pwnd, WEFTOPMOST)) {

        RIPERR0(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "xxxSetShellWindow: Invalid type of window");
        return FALSE;
    }

    /*
     * Chicago has a totally different input model which has special code
     * that checks for Ctrl-Esc and sends it to the shell.  We can get
     * the same functionality, without totally re-writing our input model
     * by just automatically installing the Ctrl-Esc as a hotkey for the
     * shell window.  The hotkey delivery code has a special case which
     * turns this into a WM_SYSCOMMAND message instead of a WM_HOTKEY
     * message.
     *
     * We don't both checking for failure.  Somebody could already have
     * a Ctrl-Esc handler installed.
     */
    _RegisterHotKey(pwnd,SC_TASKLIST,MOD_CONTROL,VK_ESCAPE);

    /*
     * This is the shell window wright.
     * So get the process id for the shell.
     */
    ppiShellProcess = GETPTI(pwnd)->ppi;

    /*
     * Set the shell process id to the desktop only if it's the first instance
     */
    if ((ppiShellProcess != NULL) && (pdeskinfo->ppiShellProcess == NULL)) {
        pdeskinfo->ppiShellProcess = ppiShellProcess;
    }

    Lock(&pdeskinfo->spwndShell, pwnd);
    Lock(&pdeskinfo->spwndBkGnd, pwndBkGnd);

    /*
     * Push window to bottom of stack.
     */
    SetWF(pdeskinfo->spwndShell, WFBOTTOMMOST);
    xxxSetWindowPos(pdeskinfo->spwndShell,
                    PWND_BOTTOM,
                    0,
                    0,
                    0,
                    0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    return TRUE;
}




/***************************************************************************\
* _InitPwSB
*
* History:
* 10-23-90 MikeHar Ported from WaWaWaWindows.
* 11-28-90 JimA    Changed to int *
* 01-21-91 IanJa   Prefix '_' denoting exported function (although not API)
\***************************************************************************/
PSBINFO _InitPwSB(
    PWND pwnd)
{
    if (pwnd->pSBInfo) {

        /*
         * If memory is already allocated, don't bother to do it again.
         */
        return pwnd->pSBInfo;
    }

    pwnd->pSBInfo = (PSBINFO)DesktopAlloc(pwnd->head.rpdesk,
                                          sizeof(SBINFO),
                                          DTAG_SBINFO);
    if (pwnd->pSBInfo != NULL) {
        pwnd->pSBInfo->Vert.posMax = 100;
        pwnd->pSBInfo->Horz.posMax = 100;
    }

    return pwnd->pSBInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\misc.c ===
/****************************** Module Header ******************************\
* Module Name: misc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains citrix code.
*
\***************************************************************************/


#include "precomp.h"
#pragma hdrstop

USHORT gPreviousProtocolType = PROTOCOL_CONSOLE;
LPCWSTR G_DisconnectDisplayDriverName = L"TSDDD\0";

extern HANDLE ghSwitcher;

HDEV DrvGetHDEV(PUNICODE_STRING pusDeviceName);
VOID DrvReleaseHDEV(PUNICODE_STRING pstrDeviceName);

NTSTATUS xxxRequestOutOfFullScreenMode(
    VOID);

NTSTATUS xxxRemoteConsoleShadowStart(
    IN PDOCONNECTDATA pDoConnectData,
    IN PWCHAR DisplayDriverName);

NTSTATUS xxxRemoteConsoleShadowStop(
    VOID);

/*
 * FindMirrorDriver
 *
 * Helper function that searches for the named driver as a mirror device
 * and fills in pDisplayDevice
 *
 * Returns TRUE if successful; FALSE otherwise.
 */
NTSTATUS FindMirrorDriver(
    IN PCWSTR pwszDispDriverName,
    OUT PDISPLAY_DEVICEW pDisplayDevice)
{
    DWORD          iDevNum = 0;
    BOOLEAN        fFound = FALSE;
    WCHAR          Buffer[256];
    WCHAR          Service[128];
    PWCHAR         pCurr = NULL;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING DrvNameString;

    RtlInitUnicodeString(&DrvNameString, pwszDispDriverName);

    pDisplayDevice->cb = sizeof(DISPLAY_DEVICEW);

    while (NT_SUCCESS(DrvEnumDisplayDevices(NULL,
                                            gpDispInfo->pMonitorPrimary->hDev,
                                            iDevNum++,
                                            pDisplayDevice,
                                            0,
                                            KernelMode))) {
        if (!(pDisplayDevice->StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)) {
            continue;
        }

        RtlZeroMemory(Buffer, sizeof(Buffer));

        wcsncpy(Buffer, pDisplayDevice->DeviceKey, 250);

        pCurr = Buffer + wcslen(Buffer) - 1;

        while ((pCurr > Buffer) && (*pCurr != L'\\')) {
            pCurr--;
        }

        if (*pCurr == L'\\') {
            RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
                { NULL,
                  RTL_QUERY_REGISTRY_DIRECT,
                  L"Service",
                  &UnicodeString,
                  REG_NONE,
                  NULL,
                  0
                },

                { 0, 0, 0, 0, 0, 0, 0 }
            };

            pCurr++;

            wcscpy(pCurr, L"Video");

            RtlZeroMemory(Service, sizeof(Service));

            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = sizeof(Service);
            UnicodeString.Buffer = Service;

            if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                  Buffer,
                                                  QueryTable,
                                                  NULL,
                                                  NULL))) {

                if (RtlCompareUnicodeString(&UnicodeString,
                                            &DrvNameString,
                                            TRUE) == 0) {

                    fFound = TRUE;
                    break;
                }
            }
        }
    }

    return (fFound ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

/*
 * All of the following are gotten from ICASRV.
 */
CACHE_STATISTICS ThinWireCache;

BOOL DrvSetGraphicsDevices(
    LPCWSTR pDisplayDriverName);

BOOL AttachInputDevices(BOOL bLocalDevices);

VOID RemoveInputDevices(
    VOID);

VOID CloseLocalGraphicsDevices(
    VOID);

VOID OpenLocalGraphicsDevices(
    VOID);

extern PKTIMER gptmrWD;


/*
 * Read current power policy from Kernel, and set our variables.
 */
VOID ReadCurrentPowerSettting(
    VOID)
{
    SYSTEM_POWER_POLICY PowerPolicy;
    BOOL bGotPowerPolicy;

    LeaveCrit();
    bGotPowerPolicy = (STATUS_SUCCESS == ZwPowerInformation(SystemPowerPolicyCurrent, NULL, 0, &PowerPolicy, sizeof(PowerPolicy)));
    EnterCrit();

    if (bGotPowerPolicy) {
        xxxSystemParametersInfo(SPI_SETLOWPOWERTIMEOUT,
                                PowerPolicy.VideoTimeout,
                                0,
                                0);
        xxxSystemParametersInfo(SPI_SETPOWEROFFTIMEOUT,
                                PowerPolicy.VideoTimeout,
                                0,
                                0);
    }
}



BOOL IsSessionSwitchBlocked(
    VOID)
{
    return gfSessionSwitchBlock;
}


/*
 * This function blocks session switch from happening paired with
 * UserSessionSwitchBlock_End.
 */
NTSTATUS UserSessionSwitchBlock_Start(
    VOID)
{
    NTSTATUS Status;

    EnterCrit();

    if (!gfSwitchInProgress && SharedUserData->ActiveConsoleId == gSessionId && !gfSessionSwitchBlock) {
        gfSessionSwitchBlock = TRUE;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_CTX_NOT_CONSOLE;
    }

    LeaveCrit();

    return Status;
}

/*
 * This function removes the block on session switch initiated via
 * UserSessionSwitchBlock_Start().
 */
VOID UserSessionSwitchBlock_End(
    VOID)
{
    EnterCrit();
    UserAssert(SharedUserData->ActiveConsoleId == gSessionId);
    UserAssert(IsSessionSwitchBlocked());

    gfSessionSwitchBlock = FALSE;
    LeaveCrit();
}

NTSTATUS UserSessionSwitchEnterCrit(
    VOID)
{
    /*
     * This is intended for code that needs synchronization with session
     * switching from local to remote or remote to local.
     *
     * If a session switch is in progress fail, otherwise return with the
     * USER critical section held. The call must call
     * UserSessionSwitchLeaveCrit() to release the USER critical section.
     */

    EnterCrit();
    if (!gfSwitchInProgress) {
        return STATUS_SUCCESS;
    } else{
        LeaveCrit();
        return STATUS_UNSUCCESSFUL;
    }
}

VOID UserSessionSwitchLeaveCrit(
    VOID)
{
    LeaveCrit();
}

VOID UserGetDisconnectDeviceResolutionHint(
    PDEVMODEW pDevmodeInformation)
{
    /*
     * When switching to the disconnected DD it is better using the current
     * display resolution in order to avoid apps to move on the desktop as
     * a result of the resize. DrvGetDisplayDriverParameters() calls this
     * function for the disconnected display.
     */
    if (gProtocolType == PROTOCOL_DISCONNECT) {
        pDevmodeInformation->dmFields     = DM_PELSWIDTH | DM_PELSHEIGHT;
        pDevmodeInformation->dmPelsWidth  = gpsi->aiSysMet[SM_CXVIRTUALSCREEN];
        pDevmodeInformation->dmPelsHeight = gpsi->aiSysMet[SM_CYVIRTUALSCREEN];
    }
}

NTSTATUS RemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWCHAR pSep;

    //
    // This API is Also used to initialize the console shadow by loading
    // the console shadow mirroring Display driver.
    //
    if (pDoConnectData->fConsoleShadowFlag) {
        Status = xxxRemoteConsoleShadowStart(pDoConnectData, DisplayDriverName);
        return Status;
    }

    TRACE_HYDAPI(("RemoteConnect: display %ws\n", DisplayDriverName));

    HYDRA_HINT(HH_REMOTECONNECT);

    UserAssert(ISCSRSS());


    /*
     * Indicate that a protocol switch is pending.
     */
    UserAssert(!gfSwitchInProgress);

    /*
     * If we are asked to block session switch, don't proceed.
     */
    if (gfSessionSwitchBlock) {
        return STATUS_UNSUCCESSFUL;
    }

    SetConsoleSwitchInProgress(TRUE);

    gpThinWireCache = &ThinWireCache;

    ghRemoteMouseChannel = pDoConnectData->IcaMouseChannel;
    ghRemoteVideoChannel = pDoConnectData->IcaVideoChannel;
    ghRemoteBeepChannel = pDoConnectData->IcaBeepChannel;
    ghRemoteKeyboardChannel = pDoConnectData->IcaKeyboardChannel;
    ghRemoteThinwireChannel = pDoConnectData->IcaThinwireChannel;
    gProtocolType = pDoConnectData->drProtocolType;
    gPreviousProtocolType =  pDoConnectData->drProtocolType;
    gRemoteClientKeyboardType = pDoConnectData->ClientKeyboardType;
    gbClientDoubleClickSupport = pDoConnectData->fClientDoubleClickSupport;
    gfEnableWindowsKey = pDoConnectData->fEnableWindowsKey;

    RtlCopyMemory(gWinStationInfo.ProtocolName, pDoConnectData->ProtocolName,
                  WPROTOCOLNAME_LENGTH * sizeof(WCHAR));

    RtlCopyMemory(gWinStationInfo.AudioDriverName, pDoConnectData->AudioDriverName,
                  WAUDIONAME_LENGTH * sizeof(WCHAR));

    RtlZeroMemory(gstrBaseWinStationName,
                  WINSTATIONNAME_LENGTH * sizeof(WCHAR));

    RtlCopyMemory(gstrBaseWinStationName, pDoConnectData->WinStationName,
                  min(WINSTATIONNAME_LENGTH * sizeof(WCHAR), sizeof(pDoConnectData->WinStationName)));

    if (pSep = wcschr(gstrBaseWinStationName, L'#')) {
        *pSep = UNICODE_NULL;
    }

    gbConnected = TRUE;



    /*
     * WinStations must have the video device handle passed to them.
     */
    if (!gVideoFileObject) {
        PFILE_OBJECT pFileObject;
        PDEVICE_OBJECT pDeviceObject;

        //
        // Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        Status = ObReferenceObjectByHandle(ghRemoteVideoChannel,
                                           0,
                                           NULL,
                                           KernelMode,
                                           (PVOID*)&pFileObject,
                                           NULL);
        if (NT_SUCCESS(Status)) {
            gVideoFileObject = pFileObject;

            //
            // Get a pointer to the device object for this file.
            //
            pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
            Status = ObReferenceObjectByHandle(ghRemoteThinwireChannel,
                                               0,
                                               NULL,
                                               KernelMode,
                                               (PVOID*)&gThinwireFileObject,
                                               NULL);

            /*
             * This must be done before any thinwire data.
             */
            if (NT_SUCCESS(Status)) {

                if (!GreMultiUserInitSession(ghRemoteThinwireChannel,
                                             (PBYTE)gpThinWireCache,
                                             gVideoFileObject,
                                             gThinwireFileObject,
                                             DisplayDriverNameLength,
                                             DisplayDriverName)) {
                    RIPMSG0(RIP_WARNING, "UserInit: GreMultiUserInitSession failed");
                    Status = STATUS_UNSUCCESSFUL;
                } else {
                    if (IsRemoteConnection()) {
                        DWORD BytesReturned;

                        Status = GreDeviceIoControl(pDeviceObject,
                                                    IOCTL_VIDEO_ICA_ENABLE_GRAPHICS,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    0,
                                                    &BytesReturned);
                        if (!NT_SUCCESS(Status)) {
                            RIPMSG1(RIP_WARNING,
                                    "UserInit: Enable graphics status 0x%x",
                                    Status);
                        }
                    }

                }
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "RemoteConnect failed");
        goto Exit;
    }

    Status = ObReferenceObjectByHandle(ghRemoteBeepChannel,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&gpRemoteBeepDevice,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "Bad Remote Beep Channel, Status = 0x%x",
                Status);
        goto Exit;
    }


    /*
     * For session 0 we are done, since the initialization below
     * has already been taken care of.
     */
    if (!gbRemoteSession) {
        TRACE_INIT(("RemoteConnect Is OK for session %d\n", gSessionId));
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if (InitVideo(FALSE) == NULL) {
        gbConnected = FALSE;
        RIPMSG0(RIP_WARNING, "InitVideo failed");
        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    if (!LW_BrushInit()) {
        RIPMSG0(RIP_WARNING, "LW_BrushInit failed");
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    InitLoadResources();

    /*
     * Create and initialize a timer object
     * and pass a pointer to this object via the display driver to the WD.
     * The RIT will do a KeWaitForObject() on this timer object.
     * When the WD calls KeSetTimer() it will NOT specify a DPC routine.
     * When the timer goes off the RIT will get signaled and will make the
     * appropriate call to the display driver to flush the frame buffer.
     */

    gptmrWD = UserAllocPoolNonPagedNS(sizeof(KTIMER), TAG_SYSTEM);
    if (gptmrWD == NULL) {
        Status = STATUS_NO_MEMORY;
        RIPMSG0(RIP_WARNING, "RemoteConnect failed to create gptmrWD");
        goto Exit;
    }
    KeInitializeTimerEx(gptmrWD, SynchronizationTimer);


    /*
     * Video is initialized at this point.
     */
    gbVideoInitialized = TRUE;
Exit:
    if (Status == STATUS_SUCCESS) {
        if (gProtocolType == PROTOCOL_CONSOLE) {
           SharedUserData->ActiveConsoleId = gSessionId;
        }
    }

    SetConsoleSwitchInProgress(FALSE);

    if (Status == STATUS_SUCCESS) {
        if (gbRemoteSession && gProtocolType == PROTOCOL_CONSOLE) {

            /*
             * For session 0 we receive power event callouts for us to
             * intitialize our power vars, but not for other sessions.
             * Thus, we have to read the power settings from kernel, and
             * initialize our variables. We do it only for PROTOCOL_CONSOLE
             * since, monitor power settings does not make sense to other
             * (non-console) sesssions.
             */
            ReadCurrentPowerSettting();
        }
    }

    return Status;
}

NTSTATUS xxxRemoteConsoleShadowStop(
    VOID)
{
    DEVMODEW devmodeInformation = {0};
    DISPLAY_DEVICEW displayDevice;
    WCHAR *pwszDeviceName = &displayDevice.DeviceName[0];
    UNICODE_STRING strDeviceName;
    NTSTATUS Status;
    LONG lResult;

    TRACE_HYDAPI(("xxxRemoteConsoleShadowStop\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    ASSERT(gfRemotingConsole == TRUE);
    ASSERT(gConsoleShadowhDev != NULL);

    if (gConsoleShadowhDev == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Tell thinwire driver about the disconnect.
     */
    bDrvDisconnect(gConsoleShadowhDev,
                   ghConsoleShadowThinwireChannel,
                   gConsoleShadowThinwireFileObject);

    DrvGetHdevName(gConsoleShadowhDev, pwszDeviceName);

    RtlInitUnicodeString(&strDeviceName, pwszDeviceName);

    /*
     * Free up resources.
     */
    DrvReleaseHDEV(&strDeviceName);
    gfRemotingConsole = FALSE;

    /*
     * Set up the dev mode info.
     */
    devmodeInformation.dmSize = sizeof(devmodeInformation);
    devmodeInformation.dmFields = DM_POSITION | DM_PELSWIDTH | DM_PELSHEIGHT;

    /*
     * Width and height of zero mean detach.
     */
    TRACE_HYDAPI(("Unloading Chained DD"));

    /*
     * Like the load, this is in two stages - update the registry...
     */
    lResult = xxxUserChangeDisplaySettings(&strDeviceName,
                                           &devmodeInformation,
                                           NULL,
                                           CDS_UPDATEREGISTRY | CDS_NORESET,
                                           NULL,
                                           KernelMode);
    if (lResult == DISP_CHANGE_SUCCESSFUL) {
        /*
         * ... and force the change to be applied.
         */
        xxxUserChangeDisplaySettings(NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     KernelMode);

        GreConsoleShadowStop();
    }

    if (lResult != DISP_CHANGE_SUCCESSFUL) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_SUCCESS;
    }

    if (gConsoleShadowVideoFileObject != NULL) {
        ObDereferenceObject(gConsoleShadowVideoFileObject);
        gConsoleShadowVideoFileObject = NULL;
    }

    if (gConsoleShadowThinwireFileObject != NULL) {
        ObDereferenceObject(gConsoleShadowThinwireFileObject);
        gConsoleShadowThinwireFileObject = NULL;
    }

    if (gpConsoleShadowBeepDevice != NULL) {
        ObDereferenceObject(gpConsoleShadowBeepDevice);
        gpConsoleShadowBeepDevice = NULL;
    }

    if (gpConsoleShadowDisplayChangeEvent != NULL) {
        ObDereferenceObject(gpConsoleShadowDisplayChangeEvent);
        gpConsoleShadowDisplayChangeEvent = NULL;
    }

    gConsoleShadowhDev = NULL;

    /*
     * NB - Don't set console session state to disconnected or we won't
     * be able to shadow it again.
     */

    return Status;
}

NTSTATUS xxxRemoteConsoleShadowStart(
    IN PDOCONNECTDATA pDoConnectData,
    IN PWCHAR DisplayDriverName)
{
    NTSTATUS          Status = STATUS_SUCCESS;
    LONG              lResult;
    PFILE_OBJECT      pFileObject;
    PDEVICE_OBJECT    pDeviceObject;
    DEVMODEW          devmodeInformation = {0};
    DISPLAY_DEVICEW   displayDevice = {0};
    UNICODE_STRING    strDeviceName;
    BOOL              fResult;

    TRACE_HYDAPI(("xxxRemoteConsoleShadowStart\n"));

    /*
     * we must be connected the local console.
     */

    ASSERT(gbConnected);
    ASSERT(!IsRemoteConnection());
    if (!gbConnected || IsRemoteConnection()) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(ISCSRSS());

    ASSERT(gfRemotingConsole == FALSE);
    ASSERT(gConsoleShadowhDev == NULL);



    gfRemotingConsole = FALSE;
    gConsoleShadowhDev = NULL;

    gpConsoleShadowThinWireCache = &ThinWireCache;

    ghConsoleShadowMouseChannel = pDoConnectData->IcaMouseChannel;
    ghConsoleShadowVideoChannel = pDoConnectData->IcaVideoChannel;
    ghConsoleShadowBeepChannel = pDoConnectData->IcaBeepChannel;
    ghConsoleShadowKeyboardChannel = pDoConnectData->IcaKeyboardChannel;
    ghConsoleShadowThinwireChannel = pDoConnectData->IcaThinwireChannel;
    gConsoleShadowProtocolType = pDoConnectData->drProtocolType;


    gRemoteClientKeyboardType = pDoConnectData->ClientKeyboardType;

    gbClientDoubleClickSupport = pDoConnectData->fClientDoubleClickSupport;

    gfEnableWindowsKey = pDoConnectData->fEnableWindowsKey;


    /*
     * WinStations must have the video device handle passed to them.
     */

    //
    // Dereference the file handle
    // and obtain a pointer to the device object for the handle.
    //

    Status = ObReferenceObjectByHandle(pDoConnectData->DisplayChangeEvent,
                                       EVENT_MODIFY_STATE,
                                       *ExEventObjectType,
                                       KernelMode,
                                       (PVOID*)&gpConsoleShadowDisplayChangeEvent,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = ObReferenceObjectByHandle(ghConsoleShadowVideoChannel,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&pFileObject,
                                       NULL);
    if (NT_SUCCESS(Status)) {

        gConsoleShadowVideoFileObject = pFileObject;

        //
        // Get a pointer to the device object for this file.
        //
        pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
        Status = ObReferenceObjectByHandle(ghConsoleShadowThinwireChannel,
                                           0,
                                           NULL,
                                           KernelMode,
                                           (PVOID*)&gConsoleShadowThinwireFileObject,
                                           NULL);

            /*
             * This must be done before any thinwire data.
             */
        if (NT_SUCCESS(Status)) {

            if (!GreConsoleShadowStart(ghConsoleShadowThinwireChannel,
                                         (PBYTE)gpConsoleShadowThinWireCache,
                                         gConsoleShadowVideoFileObject,
                                         gConsoleShadowThinwireFileObject)) {
                RIPMSG0(RIP_WARNING, "UserInit: GreMultiUserInitSession failed");
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = ObReferenceObjectByHandle(ghConsoleShadowBeepChannel,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&gpConsoleShadowBeepDevice,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    /*
     * Find our DD from the list of possible devices
     */
    Status = FindMirrorDriver(DisplayDriverName, &displayDevice);
    if (!NT_SUCCESS(Status))
    {
        TRACE_INIT(("xxxRemoteConsoleShadowStart - FindMirrorDriver failed\n"));
        ASSERT(gfRemotingConsole == FALSE);
        goto exit;
    }

    RtlInitUnicodeString(&strDeviceName, &displayDevice.DeviceName[0]);

    /*
     * Set up the dev mode info.
     */
    devmodeInformation.dmSize       = sizeof(devmodeInformation);
    devmodeInformation.dmFields     = DM_POSITION | DM_BITSPERPEL |
                                             DM_PELSWIDTH | DM_PELSHEIGHT;
    devmodeInformation.dmBitsPerPel = pDoConnectData->drBitsPerPel;

    /*
     * The position and size are be set up to overlap the whole logical
     * desktop so that any secondary displays are included.
     */
    devmodeInformation.dmPosition.x = gpsi->aiSysMet[SM_XVIRTUALSCREEN];
    devmodeInformation.dmPosition.y = gpsi->aiSysMet[SM_YVIRTUALSCREEN];
    devmodeInformation.dmPelsWidth  = gpsi->aiSysMet[SM_CXVIRTUALSCREEN];
    devmodeInformation.dmPelsHeight = gpsi->aiSysMet[SM_CYVIRTUALSCREEN];

    /*
     * Now load it - first pass sets up the registry
     */

    lResult = xxxUserChangeDisplaySettings(&strDeviceName,
                                           &devmodeInformation,
                                           NULL,
                                           CDS_UPDATEREGISTRY | CDS_NORESET,
                                           NULL,
                                           KernelMode);

    if (lResult == DISP_CHANGE_SUCCESSFUL) {
        /*
         * This pass actually updates the system.
         */
        lResult = xxxUserChangeDisplaySettings(NULL,
                                               NULL,
                                               NULL,
                                               0,
                                               NULL,
                                               KernelMode);
        if (lResult == DISP_CHANGE_SUCCESSFUL) {
            /*
             * The chained DD should be loaded by now; open the hdev to it
             * which we will use later to actually call the various connect
             * functions.
             */
            gConsoleShadowhDev = DrvGetHDEV(&strDeviceName);
            if (gConsoleShadowhDev) {
                gfRemotingConsole = TRUE;

                /*
                 * In case the display driver has not been unloaded at the end
                 * of the previous shadow, reconnect to it.
                 */
                fResult = bDrvReconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                                        gConsoleShadowThinwireFileObject, FALSE);

                /*
                 * This is normally done in the RIT but for the console, the
                 * RIT has already started before the DD is loaded...
                 *
                 * Pass a pointer to the timer to the WD via the display driver
                 */

                if (fResult) {
                    HDXDrvEscape(gConsoleShadowhDev,
                                 ESC_SET_WD_TIMEROBJ,
                                 (PVOID)gptmrWD,
                                 sizeof(gptmrWD));
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                }
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (lResult != DISP_CHANGE_SUCCESSFUL) {
        Status = STATUS_UNSUCCESSFUL;
    }

exit:
    if (!NT_SUCCESS(Status)) {
        if (gConsoleShadowVideoFileObject != NULL) {
            ObDereferenceObject(gConsoleShadowVideoFileObject);
            gConsoleShadowVideoFileObject = NULL;
        }
        if (gConsoleShadowThinwireFileObject != NULL) {
            ObDereferenceObject(gConsoleShadowThinwireFileObject);
            gConsoleShadowThinwireFileObject = NULL;
        }
        if (gpConsoleShadowBeepDevice != NULL) {
            ObDereferenceObject(gpConsoleShadowBeepDevice);
            gpConsoleShadowBeepDevice = NULL;
        }
        if (gpConsoleShadowDisplayChangeEvent != NULL) {
            ObDereferenceObject(gpConsoleShadowDisplayChangeEvent);
            gpConsoleShadowDisplayChangeEvent = NULL;
        }
    }

    return Status;
}

NTSTATUS
xxxRemoteSetDisconnectDisplayMode(
    VOID)
{
    NTSTATUS Status;
    USHORT prevProtocolType = gProtocolType;
    LONG lResult;

    /*
     * We rely on the GDI driver load : in the disconnected mode, the only
     * valid display driver to load is the one with the disconnect attribute.
     *
     */
    gProtocolType = PROTOCOL_DISCONNECT;
    lResult = xxxUserChangeDisplaySettings(NULL,
                                           NULL,
                                           grpdeskRitInput,
                                           CDS_RAWMODE,
                                           NULL,
                                           KernelMode);
    if (lResult != DISP_CHANGE_SUCCESSFUL) {
        Status = STATUS_UNSUCCESSFUL;
        gProtocolType = prevProtocolType;
    } else {
        Status = STATUS_SUCCESS;
        if (prevProtocolType == PROTOCOL_CONSOLE) {
           SharedUserData->ActiveConsoleId = -1;
        }
    }

    if (!NT_SUCCESS(Status)) {
        TRACE_INIT(("xxxRemoteSetDisconnectDisplayMode - Couldn't load Disconnect DD - lResult %x\n", lResult));
        RIPMSGF1(RIP_WARNING,
                 "Couldn't load Disconnect DD - lResult 0x%x",
                 lResult);
    }

    return Status;
}


NTSTATUS
xxxRemoteDisconnect(
    VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER li;
    USHORT ProtocolType = gProtocolType;
    BOOL bCurrentPowerOn, SwitchedToDisconnectDesktop = FALSE;

    TRACE_HYDAPI(("xxxRemoteDisconnect\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    if (!IsRemoteConnection()) {
        /*
         * Let's loop until the system has settled down and no mode switch
         * is currently occuring.
         */
        while (ghSwitcher != NULL) {
            xxxSleepThread(0, 1, FALSE);
        }
    }

    /*
     * If preparing for a disconnect from the console we need to exit fullscreen mode
     * if we are in full screen mode.
     */
    if (!IsRemoteConnection() && gbFullScreen == FULLSCREEN) {
        Status = xxxRequestOutOfFullScreenMode();
        if (!NT_SUCCESS(Status)) {
            RIPMSGF1(RIP_WARNING,
                     "xxxRequestOutOfFullScreenMode failed, Status 0x%x",
                     Status);
            return Status;
        }

    }

    HYDRA_HINT(HH_REMOTEDISCONNECT);

    RtlZeroMemory(gstrBaseWinStationName,
                  WINSTATIONNAME_LENGTH * sizeof(WCHAR));

    UserAssert(gbConnected);

    /*
     * Indicate that a protocol switch is pending.
     */
    UserAssert(!gfSwitchInProgress);

    /*
     * If we are asked to block session switch, don't go ahead.
     */
    if (gfSessionSwitchBlock) {
        return STATUS_UNSUCCESSFUL;
    }

    SetConsoleSwitchInProgress(TRUE);

    /*
     * If we are on the console and PsW32GdiOff happens, we want to bring
     * the display back before doing any display change otherwise we'll
     * confuse GDI by disabling an already disabled MDEV.
     */
    if (!IsRemoteConnection()) {
        bCurrentPowerOn = DrvQueryMDEVPowerState(gpDispInfo->pmdev);
        if (!bCurrentPowerOn) {
            SafeEnableMDEV();
            DrvSetMDEVPowerState(gpDispInfo->pmdev, TRUE);
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        }
    }


    if (!IsRemoteConnection() && gbSnapShotWindowsAndMonitors && IsMultimon()) {
        SnapShotMonitorsAndWindowsRects();
    }

    if (gspdeskDisconnect == NULL) {
        /*
         * Convert dwMilliseconds to a relative-time(i.e.  negative)
         * LARGE_INTEGER.  NT Base calls take time values in 100 nanosecond
         * units. Timeout after 5 minutes.
         */
        li.QuadPart = Int32x32To64(-10000, 300000);

        KeWaitForSingleObject(gpEventDiconnectDesktop,
                              WrUserRequest,
                              KernelMode,
                              FALSE,
                              &li);
    }


    /*
     * Setup to shutdown screen saver and exit video power down mode on disconnect
     */
    if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
        /*
         * Call video driver here to exit power down mode.
         */
        TAGMSG0(DBGTAG_Power, "Exit video power down mode");
        DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
    }
    glinp.dwFlags = (glinp.dwFlags & ~LINP_INPUTTIMEOUTS);

    /*
     * If the disconnected desktop has not yet be setup.  Do not do any
     * disconnect processing.  It's better for the thinwire driver to try
     * and write rather than for the transmit buffers to be freed (trap).
     */
    if (gspdeskDisconnect) {

        /*
         * Blank the screen
         *
         * No need to stop graphics mode for disconnects
         */
        Status = xxxRemoteStopScreenUpdates();
        if (!NT_SUCCESS(Status)) {
            RIPMSGF1(RIP_WARNING,
                     "xxxRemoteStopScreenUpdates failed with Status 0x%x",
                     Status);
            goto done;
        } else {
            SwitchedToDisconnectDesktop = TRUE;
        }

        /*
         * If there are any shadow connections, then redraw the screen now.
         */
        if (gnShadowers)
            RemoteRedrawScreen();
    } else {
        RIPMSG0(RIP_WARNING, "xxxRemoteDisconnect failed. The disconnect desktop was not created");
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    /*
     * Tell thinwire driver about this
     */

    if (IsRemoteConnection()) {
        bDrvDisconnect(gpDispInfo->hDev,
                       ghRemoteThinwireChannel,
                       gThinwireFileObject);
    }  else {
        /*
         * For a locally connected session, unload current display driver
         * and load disconnect DD.
         */
       Status = xxxRemoteSetDisconnectDisplayMode();

       /*
        * If are we disconnecting from local console, detach console input
        * devices and attach remote input devices (remote input devices are
        * 'empty handles' at this point but that is OK. Also free the
        * Scancode Map.
        */
       if (NT_SUCCESS(Status)) {
           CloseLocalGraphicsDevices();

           if (gpScancodeMap != 0) {
               UserFreePool(gpScancodeMap);
               gpScancodeMap = NULL;
           }

       }
    }

    /*
     * If we are disconnecting from the local console we need to detach
     * input devices and unregister for CDROM notifications. Do all this
     * only if the disconnect was successful so far.
     */
    if (NT_SUCCESS(Status) && ((gPreviousProtocolType = ProtocolType) == PROTOCOL_CONSOLE)) {
        xxxUnregisterDeviceClassNotifications();
        RemoveInputDevices();
    }

    if (NT_SUCCESS(Status)) {
        gbConnected = FALSE;
    }

done:

    /*
     * If we did not succeed for some reason switch back to the orginal
     * desktop from the Disconnected desktop.
     */
    if (!NT_SUCCESS(Status) && SwitchedToDisconnectDesktop) {
        /*
         * Following call will revert to whatever desktop was present
         * before the Disconnect.
         */
        RemoteRedrawScreen();
    }

    if (!NT_SUCCESS(Status) && !IsRemoteConnection()) {
        CleanupMonitorsAndWindowsSnapShot();
    }

    /*
     * If we disconnected from the console we need to switch away from the
     * local graphics device, otherwise applications using CreateDC could
     * access the local devices.
     */
    if (NT_SUCCESS(Status) && ProtocolType == PROTOCOL_CONSOLE) {
        DrvSetGraphicsDevices(G_DisconnectDisplayDriverName);
    }
    SetConsoleSwitchInProgress(FALSE);

    return Status;
}


NTSTATUS xxxRemoteReconnect(
    IN PDORECONNECTDATA pDoReconnectData)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fResult;
    PWCHAR pSep;
    BOOL bSwitchingFromDisconectDD = FALSE;
    BOOL bChangedDisplaySettings = FALSE;
    BOOL bDisplayReconnected = FALSE;
    BOOL bRegisteredCDRomNotifications = FALSE;
    BOOL bOpenedLocalGraphicsDevices = FALSE;
    int iMouseTrails = gMouseTrails + 1;
    TL tlPool;
    PMONITORRECTS pmr = NULL;
    BOOL bSwitchGraphicsDeviceList = FALSE;
    BOOL bSwitchedProtocoltype = FALSE;
    USHORT protocolType = gProtocolType;
    DORECONNECTDATA CapturedDoReconnectData;

    TRACE_HYDAPI(("xxxRemoteReconnect\n"));

    /*
     * Only allow CSRSS to do this.
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    HYDRA_HINT(HH_REMOTERECONNECT);

    /*
     * Indicate that a protocol switch is pending.
     */
    UserAssert(!gfSwitchInProgress);

    try {
        CapturedDoReconnectData = ProbeAndReadStructure(pDoReconnectData,
                                                        DORECONNECTDATA);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * If we are asked to block session switch, don't continue on this path.
     */
    if (gfSessionSwitchBlock) {
        return STATUS_UNSUCCESSFUL;
    }

    SetConsoleSwitchInProgress(TRUE);

    /*
     * Kill the mouse trails timer if any.
     */
    SetMouseTrails(0);

    gRemoteClientKeyboardType = CapturedDoReconnectData.ClientKeyboardType;
    gbClientDoubleClickSupport = CapturedDoReconnectData.fClientDoubleClickSupport;
    gfEnableWindowsKey = CapturedDoReconnectData.fEnableWindowsKey;

    RtlCopyMemory(gstrBaseWinStationName,
                  CapturedDoReconnectData.WinStationName,
                  min(WINSTATIONNAME_LENGTH * sizeof(WCHAR), sizeof(CapturedDoReconnectData.WinStationName)));

    RtlCopyMemory(gWinStationInfo.ProtocolName,
                  CapturedDoReconnectData.ProtocolName,
                  WPROTOCOLNAME_LENGTH * sizeof(WCHAR));

    RtlCopyMemory(gWinStationInfo.AudioDriverName,
                  CapturedDoReconnectData.AudioDriverName,
                  WAUDIONAME_LENGTH * sizeof(WCHAR));

    if (pSep = wcschr(gstrBaseWinStationName, L'#')) {
        *pSep = UNICODE_NULL;
    }

    if (gnShadowers) {
        xxxRemoteStopScreenUpdates();
    }

    if (CapturedDoReconnectData.drProtocolType != gPreviousProtocolType && gPreviousProtocolType != PROTOCOL_CONSOLE) {
        Status = xxxRemoteSetDisconnectDisplayMode();
        if (!NT_SUCCESS(Status)) {
            goto done;
        }
    }

    /*
     * Call thinwire driver to check for thinwire mode compatibility.
     */
    gProtocolType=CapturedDoReconnectData.drProtocolType;

    bSwitchedProtocoltype = TRUE;

    if (gProtocolType != PROTOCOL_CONSOLE && gProtocolType == gPreviousProtocolType) {
        fResult = bDrvReconnect(gpDispInfo->hDev,
                                ghRemoteThinwireChannel,
                                gThinwireFileObject,
                                TRUE);
        bDisplayReconnected = fResult;
    } else {
        bSwitchingFromDisconectDD = TRUE;
        if (!IsRemoteConnection()) {
            OpenLocalGraphicsDevices();
            bOpenedLocalGraphicsDevices = TRUE;

            if (gpScancodeMap == NULL) {
                InitKeyboard();
            }
        }

        fResult = DrvSetGraphicsDevices(CapturedDoReconnectData.DisplayDriverName);
        bSwitchGraphicsDeviceList = TRUE;
    }

    if (!fResult) {
        if (gnShadowers) {
            RemoteRedrawScreen();
        }

        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    /*
     * If instructed to do so, change Display mode before Reconnecting. Use
     * display resolution information from Reconnect data.
     */
    if (CapturedDoReconnectData.fChangeDisplaySettings || gProtocolType != gPreviousProtocolType) {
        LONG lResult;

        /*
         * Remeber monitor positions now (it would be too late after changing
         * the display settings, since monitors will have new positions).
         * This is necssary because the fisrt pass of windows positions
         * recalculations, done in xxxUserChangeDisplaySettings, is done
         * while the current desktop is the disconnected desktop and will
         * not correctly position windows in the application desktop. We
         * need to do a second pass once we have switched to application
         * desktop. But for xxxDesktopRecalc to correctly position
         * fullscreen windows, we need to remember what the monitor rects
         * where before changing display settings.
         */
        pmr = SnapshotMonitorRects();
        if (pmr != NULL) {
            ThreadLockPool(ptiCurrent, pmr, &tlPool);
        }

        lResult = xxxUserChangeDisplaySettings(NULL,
                                               NULL,
                                               grpdeskRitInput,
                                               CDS_RAWMODE,
                                               NULL,
                                               KernelMode);
        if (lResult != DISP_CHANGE_SUCCESSFUL) {
            Status = STATUS_UNSUCCESSFUL;
        } else {
            Status = STATUS_SUCCESS;
        }

        /*
         * If Display settings change fails, let us disconnect the display
         * driver as the reconnect is going to be failed anyway.
         */
        if (!NT_SUCCESS(Status)) {
            TRACE_INIT(("xxxRemoteReconnect - Failed  ChangeDisplaySettings\n"));
            goto done;
        } else {
            bChangedDisplaySettings = TRUE;
        }
    }

    UserAssert(gptmrWD  != NULL);

    /*
     * When reconnecting, we have to attach the input devices when
     * necessary. The input device are only detached when we disconnect from
     * the console. In that case, if we later reconnect localy, we attach
     * the local input devices, and if we reconnect remotly, we attach the
     * remote devices. When we disconnect a remote session, the bet is that
     * we will reconnect remotely so we don't go through the overhead of
     * detaching input devices at disconnect and re-attaching them at
     * reconnect. If the prediction was wrong (i.e., we reconnect locally
     * after disconnecting remotely) then at reconnect time we need to
     * detach the remote input devices before attaching the local input
     * devices.
     */
    if (IsRemoteConnection()) {
        if (bSwitchingFromDisconectDD) {
            BOOL fSuccess;

            fSuccess = !!HDXDrvEscape(gpDispInfo->hDev,
                                      ESC_SET_WD_TIMEROBJ,
                                      (PVOID)gptmrWD,
                                      sizeof(gptmrWD));
            if (!fSuccess) {
                Status = STATUS_UNSUCCESSFUL;
                RIPMSGF0(RIP_WARNING,
                         "Failed to pass gptmrWD to display driver");
            }
        }

        if (gPreviousProtocolType == PROTOCOL_CONSOLE) {
            AttachInputDevices(FALSE);
        }
    } else {
        if (gPreviousProtocolType != PROTOCOL_CONSOLE) {
            RemoveInputDevices();

        }

        AttachInputDevices(TRUE);

        LeaveCrit();
        RegisterCDROMNotify();
        bRegisteredCDRomNotifications = TRUE;
        EnterCrit();
    }


    /*
     * Now we can switch out from disconnected desktop, to normal desktop,
     * in order to reenable screen update.
     */
    RemoteRedrawScreen();

    /*
     * At this point we need to update the windows sizes and positions on
     * the desktop. This is necessary for the case where we reconnect with a
     * smaller resolution. When calling this API, the
     * TerminalServerRequestThread (a CSRSS thread) is using the
     * disconnected desktop as its temporary desktop. That's why the
     * xxxUserChangeDisplaySettings call above does not resize windows for
     * the default desktop. The solution is to set the default desktop as
     * the temporary desktop, after we switch to it in RemoteRedrawScreen
     * and to call xxxDesktopRecalc.
     */
    if (bChangedDisplaySettings) {
        USERTHREAD_USEDESKTOPINFO utudi;
        NTSTATUS tempstatus;

        utudi.hThread = NULL;
        utudi.drdRestore.pdeskRestore = NULL;
        tempstatus = xxxSetCsrssThreadDesktop(grpdeskRitInput, &utudi.drdRestore);
        if (NT_SUCCESS(tempstatus)) {
            if (pmr != NULL) {
                UpdateMonitorRectsSnapShot(pmr);
                xxxDesktopRecalc(pmr);
            }

            if (!IsRemoteConnection() && gbSnapShotWindowsAndMonitors) {
                RestoreMonitorsAndWindowsRects();
            }

            xxxSetInformationThread(NtCurrentThread(), UserThreadUseDesktop, &utudi, sizeof(utudi));
        }

    }


    /*
     * Re-init'ing the keyboard may not be as neccessary. Possibly the keyboard
     * attributes have changed.
     */
    InitKeyboard();

    /*
     * This is neccessary to sync up the client and the host.
     */
    UpdateKeyLights(FALSE);

    SetPointer(TRUE);

    gbConnected = TRUE;

done:
    /*
     * Recreate the mouse trails timer if there is need for it.
     */
    SetMouseTrails(iMouseTrails);

    /*
     * If we failed after after the Display driver was reconnected, we need
     * to disconnect it now, otherwise we have an inconsitancy beetween the
     * disconnected state of Win32k and the connected state of the display driver.
     */
    if (!NT_SUCCESS(Status) && bDisplayReconnected) {
        bDrvDisconnect(gpDispInfo->hDev,
                       ghRemoteThinwireChannel,
                       gThinwireFileObject);
    }

    if (Status == STATUS_SUCCESS && !IsRemoteConnection()) {
        SharedUserData->ActiveConsoleId = gSessionId;
    }

    SetConsoleSwitchInProgress(FALSE);

    /*
     * In the failure of reconnect - unregister the CDROM notifications
     * if they were registered.
     */
    if (!NT_SUCCESS(Status)) {
        if (bRegisteredCDRomNotifications) {
            xxxUnregisterDeviceClassNotifications();
        }
        if (bOpenedLocalGraphicsDevices) {
            CloseLocalGraphicsDevices();
        }
        if (bSwitchedProtocoltype) {
            gProtocolType = protocolType;
        }
        if (bSwitchGraphicsDeviceList) {
            fResult = DrvSetGraphicsDevices(CapturedDoReconnectData.DisplayDriverName);
        }
    }

    if (pmr != NULL) {
        ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
    }

    return Status;
}


NTSTATUS xxxRemoteNotify(
    IN PDONOTIFYDATA pDoNotifyData)
{
    LRESULT lResult;
    DONOTIFYDATA CapturedDoNotifyData;

    /*
     * Only allow CSRSS to do this.
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    try {
        CapturedDoNotifyData = ProbeAndReadStructure(pDoNotifyData, DONOTIFYDATA);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_UNSUCCESSFUL;
    }

    switch (CapturedDoNotifyData.NotifyEvent) {
    case Notify_DisableScrnSaver:
        /*
         * Tell winlogon about the session shadow state
         */
        ASSERT(gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_DISABLESCRNSAVER, 0);
        }
        break;

    case Notify_EnableScrnSaver:
        /*
         * Tell winlogon about the session shadow state
         */
        ASSERT(gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_ENABLESCRNSAVER, 0);
        }
        break;

    case Notify_Disconnect:

        /*
         * Tell winlogon about the disconnect
         */
        ASSERT(!gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_DISCONNECTED, 0);
        }
        break;

    case Notify_SyncDisconnect:

        /*
         * Synchronously tell winlogon about the disconnect.
         */
        UserAssert(!gbConnected);
        if (gspwndLogonNotify != NULL) {
            TL tlpwnd;

            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
            xxxSendMessageTimeout(gspwndLogonNotify,
                                  WM_LOGONNOTIFY,
                                  SESSION_DISCONNECTED,
                                  0,
                                  SMTO_NORMAL,
                                  60 * 1000,
                                  &lResult);
            ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_Reconnect:
        /*
         * Tell winlogon about the reconnect.
         */
        UserAssert(gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify,
                         WM_LOGONNOTIFY,
                         SESSION_RECONNECTED,
                         0);
        }
        break;

    case Notify_PreReconnect:

        /*
         * Tell winlogon that the session is about to be reconnected.
         */
        if (gspwndLogonNotify != NULL) {
           TL tlpwnd;

           ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
           xxxSendMessageTimeout(gspwndLogonNotify,
                                 WM_LOGONNOTIFY,
                                 SESSION_PRERECONNECT,
                                 0,
                                 SMTO_NORMAL,
                                 60 * 1000,
                                 &lResult);
           ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_HelpAssistantShadowStart:

        /*
         * Tell winlogon that a Help Assistant is about to begin shadowing.
         */
        if (gspwndLogonNotify != NULL) {
           TL tlpwnd;

           ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
           xxxSendMessageTimeout(gspwndLogonNotify,
                                 WM_LOGONNOTIFY,
                                 SESSION_HELPASSISTANTSHADOWSTART,
                                 0,
                                 SMTO_NORMAL,
                                 60 * 1000,
                                 &lResult);
           ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_HelpAssistantShadowFinish:

        /*
         * Tell winlogon that a Help Assistant has just finished shadowing.
         */
        if (gspwndLogonNotify != NULL) {
           _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                        SESSION_HELPASSISTANTSHADOWFINISH, 0);
        }
        break;

    case Notify_PreReconnectDesktopSwitch:

        /*
         * Tell winlogon that the reconnected session is about to have its
         * desktop switched.
         */
        if (gspwndLogonNotify != NULL) {
           TL tlpwnd;

           ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
           if (!xxxSendMessageTimeout(gspwndLogonNotify,
                                      WM_LOGONNOTIFY,
                                      SESSION_PRERECONNECTDESKTOPSWITCH,
                                      0,
                                      SMTO_NORMAL,
                                      10 * 1000,
                                      &lResult)) {
                /*
                 * Message timed out, and wasn't sent, so let's post this
                 * message and return.
                 */
                _PostMessage(gspwndLogonNotify,
                             WM_LOGONNOTIFY,
                             SESSION_PRERECONNECTDESKTOPSWITCH,
                             0);

           }

           ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_StopReadInput:
        /*
         * Set the global variable indicating that we should stop reading
         * input.
         */
        gbStopReadInput = TRUE;
        break;

    case Notify_DisconnectPipe:
        /*
         * Tell winlogon to disconnect the auto logon named pipe.
         */
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify,
                         WM_LOGONNOTIFY,
                         SESSION_DISCONNECTPIPE,
                         0);
        }
        break;


    default:
        ASSERT(FALSE);
    }

    return STATUS_SUCCESS;
}

/*
 * This allows ICASRV to cleanly logoff the user. We send a message to
 * winlogon and let him do it. We used to call ExitWindowsEx() directly, but
 * that caused too many problems when it was called from CSRSS.
 */
NTSTATUS RemoteLogoff(
    VOID)
{
    TRACE_HYDAPI(("RemoteLogoff\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    HYDRA_HINT(HH_REMOTELOGOFF);

    UserAssert(ISCSRSS());

    /*
     * Tell winlogon about the logoff
     */
    if (gspwndLogonNotify != NULL) {
        _PostMessage(gspwndLogonNotify,
                     WM_LOGONNOTIFY,
                     SESSION_LOGOFF,
                     EWX_LOGOFF | EWX_FORCE);
    }

    return STATUS_SUCCESS;
}


NTSTATUS xxxRemoteStopScreenUpdates(
    VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SaveStatus = STATUS_SUCCESS;
    WORD NewButtonState;

    TRACE_HYDAPI(("xxxRemoteStopScreenUpdates"));

    CheckCritIn();

    UserAssert(ISCSRSS());

    /*
     * No need to do this multiple times.
     */
    if (gbFreezeScreenUpdates) {
        return STATUS_SUCCESS;
    }

    /*
     * This could be called directly from the command channel.
     */
    if (!gspdeskDisconnect) {
        return STATUS_SUCCESS;
    }

    /*
     * If not connected, forget it.
     */
    if (ghRemoteVideoChannel == NULL) {
        return STATUS_NO_SUCH_DEVICE;
    }

    /*
     * Mouse buttons up (ensures no mouse buttons are left in a down state).
     */
    NewButtonState = gwMKButtonState & ~gwMKCurrentButton;

    if ((NewButtonState & MOUSE_BUTTON_LEFT) != (gwMKButtonState & MOUSE_BUTTON_LEFT)) {
        xxxButtonEvent(MOUSE_BUTTON_LEFT,
                       gptCursorAsync,
                       TRUE,
                       NtGetTickCount(),
                       0L,
#ifdef GENERIC_INPUT
                       NULL,
                       NULL,
#endif
                       0L,
                       FALSE);
    }

    if ((NewButtonState & MOUSE_BUTTON_RIGHT) != (gwMKButtonState & MOUSE_BUTTON_RIGHT)) {
        xxxButtonEvent(MOUSE_BUTTON_RIGHT,
                       gptCursorAsync,
                       TRUE,
                       NtGetTickCount(),
                       0L,
#ifdef GENERIC_INPUT
                       NULL,
                       NULL,
#endif
                       0L,
                       FALSE);
    }
    gwMKButtonState = NewButtonState;

    /*
     * Send shift key breaks to win32 (ensures no shift keys are left on).
     */

    // { 0, 0xb8, KEY_BREAK, 0, 0 },           // L alt
    xxxPushKeyEvent(VK_LMENU, 0xb8, KEYEVENTF_KEYUP, 0);

    // { 0, 0xb8, KEY_BREAK | KEY_E0, 0, 0 },  // R alt
    xxxPushKeyEvent(VK_RMENU, 0xb8, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);

    // { 0, 0x9d, KEY_BREAK, 0, 0 },           // L ctrl
    xxxPushKeyEvent(VK_LCONTROL, 0x9d, KEYEVENTF_KEYUP, 0);

    // { 0, 0x9d, KEY_BREAK | KEY_E0, 0, 0 },  // R ctrl
    xxxPushKeyEvent(VK_RCONTROL, 0x9d, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);

    // { 0, 0xaa, KEY_BREAK, 0, 0 },           // L shift
    xxxPushKeyEvent(VK_LSHIFT, 0xaa, KEYEVENTF_KEYUP, 0);

    // { 0, 0xb6, KEY_BREAK, 0, 0 }            // R shift
    xxxPushKeyEvent(VK_RSHIFT, 0xb6, KEYEVENTF_KEYUP, 0);

    Status = RemoteDisableScreen();
    if (!NT_SUCCESS(Status)) {
       return STATUS_NO_SUCH_DEVICE;
    }

    UserAssert(gspdeskDisconnect != NULL && grpdeskRitInput == gspdeskDisconnect);

    gbFreezeScreenUpdates = TRUE;

    return Status;
}

/*
 * Taken from Internal Key Event.
 * Minus any permissions checking.
 */
VOID xxxPushKeyEvent(
    BYTE  bVk,
    BYTE  bScan,
    DWORD dwFlags,
    DWORD dwExtraInfo)
{
    USHORT usFlaggedVK;

    usFlaggedVK = (USHORT)bVk;

    if (dwFlags & KEYEVENTF_KEYUP)
        usFlaggedVK |= KBDBREAK;

    // IanJa: not all extended keys are numpad, but this seems to work.
    if (dwFlags & KEYEVENTF_EXTENDEDKEY)
        usFlaggedVK |= KBDNUMPAD | KBDEXT;

    xxxKeyEvent(usFlaggedVK, bScan, NtGetTickCount(), dwExtraInfo,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);
}


NTSTATUS
RemoteThinwireStats(
    OUT PVOID Stats)
{
    DWORD sThinwireStatsLength = sizeof(CACHE_STATISTICS);

    TRACE_HYDAPI(("RemoteThinwireStats\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());


    if (gpThinWireCache != NULL) {
        try {
            ProbeForWrite(Stats, sThinwireStatsLength, sizeof(BYTE));
            RtlCopyMemory(Stats, gpThinWireCache, sThinwireStatsLength);

        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            return GetExceptionCode();
        }

        
        return STATUS_SUCCESS;
    }
    return STATUS_NO_SUCH_DEVICE;
}


NTSTATUS
RemoteNtSecurity(
    VOID)
{
    TRACE_HYDAPI(("RemoteNtSecurity\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());

    UserAssert(gspwndLogonNotify != NULL);

    if (gspwndLogonNotify != NULL) {
        _PostMessage(gspwndLogonNotify, WM_HOTKEY, 0, 0);
    }
    return STATUS_SUCCESS;
}


NTSTATUS
xxxRemoteShadowSetup(
    VOID)
{
    TRACE_HYDAPI(("xxxRemoteShadowSetup\n"));

    /*
     * Only allow CSRSS to do this.
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * Blank the screen.
     */
    if (gnShadowers || gbConnected) {
        xxxRemoteStopScreenUpdates();
    }

    gnShadowers++;

    return STATUS_SUCCESS;
}


NTSTATUS
RemoteShadowStart(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength)
{
    BOOL fResult;
    PUCHAR pCapturedThinWireData = NULL;


    TRACE_HYDAPI(("RemoteShadowStart\n"));

    /*
     * Only allow CSRSS to do this.
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * Probe all read arguments.
     */
    try {
        ProbeForRead(pThinwireData, ThinwireDataLength, sizeof(BYTE));
        pCapturedThinWireData = UserAllocPoolWithQuota(ThinwireDataLength, TAG_SYSTEM);

        if (pCapturedThinWireData) {
            RtlCopyMemory(pCapturedThinWireData, pThinwireData, ThinwireDataLength);
        } else {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        if (pCapturedThinWireData) {
            UserFreePool(pCapturedThinWireData);
        }
        return  GetExceptionCode();
    }


    /*
     * Call thinwire driver and check for thinwire mode compatibility
     */
    fResult = bDrvShadowConnect(GETCONSOLEHDEV(),
                                pCapturedThinWireData,
                                ThinwireDataLength);


    if (pCapturedThinWireData) {
        UserFreePool(pCapturedThinWireData);
    }

    /*
     * Although originally defined as BOOL, allow more meaningful return
     * codes.
     */

    if (!fResult) {
        return STATUS_CTX_BAD_VIDEO_MODE;
    } else if (fResult != TRUE) {
        return fResult;
    }

    RemoteRedrawScreen();

    SetPointer(TRUE);

    SETSYSMETBOOL(REMOTECONTROL, TRUE);

    return STATUS_SUCCESS;
}


NTSTATUS
xxxRemoteShadowStop(
    VOID)
{
    TRACE_HYDAPI(("xxxRemoteShadowStop\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * Blank the screen.
     */
    xxxRemoteStopScreenUpdates();

    return STATUS_SUCCESS;
}


NTSTATUS
RemoteShadowCleanup(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength)
{

    PUCHAR pCapturedThinWireData = NULL;

    TRACE_HYDAPI(("RemoteShadowCleanup\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * Probe all read arguments.
     */
    try {
        ProbeForRead(pThinwireData, ThinwireDataLength, sizeof(BYTE));
        pCapturedThinWireData = UserAllocPoolWithQuota(ThinwireDataLength, TAG_SYSTEM);

        if (pCapturedThinWireData) {
            RtlCopyMemory(pCapturedThinWireData, pThinwireData, ThinwireDataLength);
        } else {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        if (pCapturedThinWireData) {
            UserFreePool(pCapturedThinWireData);
        }
        return GetExceptionCode();
    }


    /*
     * Tell the Thinwire driver about it.
     */
    bDrvShadowDisconnect(GETCONSOLEHDEV(),
                         pCapturedThinWireData,
                         ThinwireDataLength);

    if (pCapturedThinWireData) {
        UserFreePool(pCapturedThinWireData);
    }

    if (gnShadowers > 0) {
        gnShadowers--;
    }

    if (gnShadowers || gbConnected) {
        RemoteRedrawScreen();
    }

    SetPointer(TRUE);

    if (gnShadowers == 0) {
        SETSYSMETBOOL(REMOTECONTROL, FALSE);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
xxxRemotePassthruEnable(
    VOID)
{
    IO_STATUS_BLOCK IoStatus;
    static BOOL KeyboardType101;

    TRACE_HYDAPI(("xxxRemotePassthruEnable\n"));

    /*
     * Only allow CSRSS to do this.
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(gbConnected);
    UserAssert(gnShadowers == 0);

    KeyboardType101 = !(gapulCvt_VK == gapulCvt_VK_84);

    ZwDeviceIoControlFile(ghRemoteKeyboardChannel, NULL, NULL, NULL,
                          &IoStatus, IOCTL_KEYBOARD_ICA_TYPE,
                          &KeyboardType101, sizeof(KeyboardType101),
                          NULL, 0);

    if (guKbdTblSize != 0) {
        ZwDeviceIoControlFile(ghRemoteKeyboardChannel, NULL, NULL, NULL,
                              &IoStatus, IOCTL_KEYBOARD_ICA_LAYOUT,
                              ghKbdTblBase, guKbdTblSize,
                              gpKbdTbl, 0);
    }

    xxxRemoteStopScreenUpdates();

    /*
     * Tell thinwire driver about this.
     */
    if (gfRemotingConsole) {
        ASSERT(gConsoleShadowhDev != NULL);
        bDrvDisconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                       gConsoleShadowThinwireFileObject);
    } else {
        bDrvDisconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                       gThinwireFileObject);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RemotePassthruDisable(
    VOID)
{
    BOOL fResult;

    TRACE_HYDAPI(("RemotePassthruDisable\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(gnShadowers == 0);
    UserAssert(ISCSRSS());

    if (gfRemotingConsole) {
        ASSERT(gConsoleShadowhDev != NULL);
        fResult = bDrvReconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                                gConsoleShadowThinwireFileObject, TRUE);
    } else {
        fResult = bDrvReconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                                gThinwireFileObject, TRUE);
    }

    if (!fResult) {
        return STATUS_CTX_BAD_VIDEO_MODE;
    }

    if (gbConnected) {
        RemoteRedrawScreen();
        UpdateKeyLights(FALSE); // Make sure LED's are correct
    }

    return STATUS_SUCCESS;
}


NTSTATUS
CtxDisplayIOCtl(
    ULONG  DisplayIOCtlFlags,
    PUCHAR pDisplayIOCtlData,
    ULONG  cbDisplayIOCtlData)
{
    BOOL fResult;

    TRACE_HYDAPI(("CtxDisplayIOCtl\n"));

    fResult = bDrvDisplayIOCtl(GETCONSOLEHDEV(), pDisplayIOCtlData, cbDisplayIOCtlData);

    if (!fResult) {
        return STATUS_CTX_BAD_VIDEO_MODE;
    }

    if ((DisplayIOCtlFlags & DISPLAY_IOCTL_FLAG_REDRAW)) {
        RemoteRedrawRectangle(0,0,0xffff,0xffff);
    }

    return STATUS_SUCCESS;
}


/*
 * This is for things like user32.dll init routines that don't want to use
 * winsta.dll for queries.
 */
DWORD
RemoteConnectState(
    VOID)
{
    DWORD state;

    if (!gbRemoteSession) {
        state = CTX_W32_CONNECT_STATE_CONSOLE;
    } else if (!gbVideoInitialized) {
        state = CTX_W32_CONNECT_STATE_IDLE;
    } else if (gbExitInProgress) {
        state = CTX_W32_CONNECT_STATE_EXIT_IN_PROGRESS;
    } else if (gbConnected) {
        state = CTX_W32_CONNECT_STATE_CONNECTED;
    } else {
        state = CTX_W32_CONNECT_STATE_DISCONNECTED;
    }

    return state;
}

BOOL
_GetWinStationInfo(
    PWSINFO pWsInfo)
{
    CheckCritIn();

    try {
        ProbeForWrite(pWsInfo, sizeof(gWinStationInfo), DATAALIGN);
        RtlCopyMemory(pWsInfo, &gWinStationInfo, sizeof(gWinStationInfo));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnaccel.c ===
/**************************** Module Header ********************************\
* Module Name: mnaccel.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Keyboard Accelerator Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
*
* History:
\***************************************************************************/

int ItemContainingSubMenu(
    PMENU pmainMenu,
    ULONG_PTR wID)
{
    int i;
    PITEM pItem;

    if ((i = pmainMenu->cItems - 1) == -1)
        return -1;

    pItem = &pmainMenu->rgItems[i];

    /*
     * Scan through mainMenu's items (bottom up) until an item is found
     * that either has subMenu or an ancestor of subMenu as it's drop
     * down menu
     */

    /*
     * Make sure this works for new apps that set IDs for popup items that
     * aren't the same as the HMENU_16 value of the submenu.  Accelerators
     * for disabled items will get generated otherwise, like in Exchange.
     */
    while (i >= 0)
    {
        if (pItem->spSubMenu == NULL)
        {
            //
            // Does this command match?
            //
            if (pItem->wID == wID)
                break;
        }
        else
        {
            //
            // Does this popup match?
            //
            if (pItem->spSubMenu == (PMENU)wID)
                break;

            //
            // Go recurse through this popup and see if we have a match on
            // one of our children.
            //
            if (ItemContainingSubMenu(pItem->spSubMenu, wID) != -1)
                break;
        }

        i--;
        pItem--;
    }

    return i;
}

/***************************************************************************\
* UT_FindTopLevelMenuIndex
*
* !
*
* History:
\***************************************************************************/

int UT_FindTopLevelMenuIndex(
    PMENU pMenu,
    UINT cmd)
{
    PMENU pMenuItemIsOn;
    PITEM  pItem;

    /*
     * Get a pointer to the item we are searching for.
     */
    pItem = MNLookUpItem(pMenu, cmd, FALSE, &pMenuItemIsOn);
    if ((pItem == NULL) || (pItem->spSubMenu != NULL))
        return(-1);

    /*
     * We want to search for the item that contains pMenuItemIsOn,
     * unless this is a top-level item without a dropdown, in which
     * case we want to search for cmd.
     */
    return ItemContainingSubMenu(pMenu,
                    pMenuItemIsOn != pMenu ? (ULONG_PTR)pMenuItemIsOn : cmd);
}

/***************************************************************************\
* xxxHiliteMenuItem
*
* !
*
* History:
\***************************************************************************/

BOOL xxxHiliteMenuItem(
    PWND pwnd,
    PMENU pMenu,
    UINT cmd,
    UINT flags)
{

    if (!(flags & MF_BYPOSITION))
        cmd = (UINT)UT_FindTopLevelMenuIndex(pMenu, cmd);

    if (!TestMF(pMenu, MFISPOPUP))
        xxxMNRecomputeBarIfNeeded(pwnd, pMenu);

    xxxMNInvertItem(NULL, pMenu, cmd, pwnd, (flags & MF_HILITE));

    return TRUE;
}

/***************************************************************************\
* xxxTA_AccelerateMenu
*
* !
*
* History:
\***************************************************************************/

#define TA_DISABLED 1

UINT xxxTA_AccelerateMenu(
    PWND pwnd,
    PMENU pMenu,
    UINT cmd,
    HMENU *phmenuInit)
{
    int i;
    PITEM pItem;
    BOOL fDisabledTop;
    BOOL fDisabled;
    UINT rgfItem;
    PMENU pMenuItemIsOn;

    CheckLock(pwnd);
    CheckLock(pMenu);

    rgfItem = 0;
    if (pMenu != NULL) {
        if ((i = UT_FindTopLevelMenuIndex(pMenu, cmd)) != -1) {

            /*
             * 2 means we found an item
             */
            rgfItem = 2;

            xxxSendMessage(pwnd, WM_INITMENU, (WPARAM)PtoHq(pMenu), 0L);
            if ((UINT)i >= pMenu->cItems)
                return 0;

            pItem = &pMenu->rgItems[i];
            if (pItem->spSubMenu != NULL) {
                *phmenuInit = PtoHq(pItem->spSubMenu);
                xxxSendMessage(pwnd, WM_INITMENUPOPUP, (WPARAM)*phmenuInit,
                        (DWORD)i);
                if ((UINT)i >= pMenu->cItems)
                    return 0;
                fDisabledTop = TestMFS(pItem,MFS_GRAYED);
            } else {
                fDisabledTop = FALSE;
            }

            pItem = MNLookUpItem(pMenu, cmd, FALSE, &pMenuItemIsOn);

            /*
             * If the item was removed by the app in response to either of
             * the above messages, pItem will be NULL.
             */
            if (pItem == NULL) {
                rgfItem = 0;
            } else {
                fDisabled = TestMFS(pItem,MFS_GRAYED);

                /*
                 * This 1 bit means it's disabled or it's 'parent' is disabled.
                 */
                if (fDisabled || fDisabledTop)
                    rgfItem |= TA_DISABLED;
            }
        }
    }

    return rgfItem;
}

/***************************************************************************\
* _CreateAcceleratorTable
*
* History:
* 05-01-91 ScottLu      Changed to work client/server
* 02-26-91 mikeke       Created.
\***************************************************************************/

HANDLE APIENTRY _CreateAcceleratorTable(
    LPACCEL ccxpaccel,
    int cbAccel)
{
    LPACCELTABLE pat;
    int size;

    size = cbAccel + sizeof(ACCELTABLE) - sizeof(ACCEL);

    pat = (LPACCELTABLE)HMAllocObject(PtiCurrent(), NULL, TYPE_ACCELTABLE, size);
    if (pat == NULL)
        return NULL;

    try {
        RtlCopyMemory(pat->accel, ccxpaccel, cbAccel);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        HMFreeObject(pat);
        return NULL;
    }

    pat->cAccel = cbAccel / sizeof(ACCEL);
    pat->accel[pat->cAccel - 1].fVirt |= FLASTKEY;

    return pat;
}

/***************************************************************************\
* xxxTranslateAccelerator
*
* !
*
* History:
\***************************************************************************/

int xxxTranslateAccelerator(
    PWND pwnd,
    LPACCELTABLE pat,
    LPMSG lpMsg)
{
    UINT cmd;
    BOOL fVirt;
    PMENU pMenu;
    BOOL fFound;
    UINT flags;
    UINT keystate;
    UINT message;
    UINT rgfItem;
    BOOL fDisabled;
    BOOL fSystemMenu;
    LPACCEL paccel;
    TL tlpMenu;
    int vkAlt, vkCtrl;
    HMENU hmenuInit = NULL;

    CheckLock(pwnd);
    CheckLock(pat);

    if (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) {
        return FALSE;
    }

    paccel = pat->accel;

    fFound = FALSE;

    message = SystoChar(lpMsg->message, lpMsg->lParam);

    switch (message) {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        fVirt = TRUE;
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        fVirt = FALSE;
        break;

    default:
        return FALSE;
    }

    /*
     * Many kbd layouts use the r.h. Alt key like a shift key to generate some
     * additional chars: this r.h. Alt (or "AltGr") key synthesizes a left Ctrl
     * (for backward compatibility with 84-key kbds), so when the AltGr key is
     * down neither the left Ctrl nor the right Alt should be counted as part
     * of the keystate.
     * Note: Don't expect spklActive == NULL (winlogon should have loaded kbd
     * layouts already), but test it  anyway to be robust. #99321)
     */
    keystate = 0;
    UserAssert(PtiCurrent()->spklActive != NULL);   // #99321
    if (PtiCurrent()->spklActive &&
            (PtiCurrent()->spklActive->spkf->pKbdTbl->fLocaleFlags & KLLF_ALTGR) &&
            (_GetKeyState(VK_RMENU) & 0x8000)) {
        /*
         * count only right hand Ctrl as a Ctrl keystate
         * count only left hand Alt as a Alt keystate
         */
        vkCtrl = VK_RCONTROL;
        vkAlt = VK_LMENU;
    } else {
        /*
         * count left or right hand Ctrl as a Ctrl keystate
         * count left or right hand Alt as a Alt keystate
         */
        vkAlt = VK_MENU;
        vkCtrl = VK_CONTROL;
    }

    if (_GetKeyState(vkCtrl) & 0x8000) {
        keystate |= FCONTROL;
    }
    if (_GetKeyState(vkAlt) & 0x8000) {
        keystate |= FALT;
    }
    if (_GetKeyState(VK_SHIFT) & 0x8000) {
        keystate |= FSHIFT;
    }

    do
    {
        flags = paccel->fVirt;
        if ( (DWORD)paccel->key != lpMsg->wParam ||
             ((fVirt != 0) != ((flags & FVIRTKEY) != 0))) {
            goto Next;
        }

        if (fVirt && ((keystate & (FSHIFT | FCONTROL)) != (flags & (FSHIFT | FCONTROL)))) {
            goto Next;
        }

        if ((keystate & FALT) != (flags & FALT)) {
            goto Next;
        }

        fFound = TRUE;
        fSystemMenu = 0;
        rgfItem = 0;

        cmd = paccel->cmd;
        if (cmd != 0) {

            /*
             * The order of these next two if's is important for default
             * situations.  Also, just check accelerators in the system
             * menu of child windows passed to TranslateAccelerator.
             */
            pMenu = pwnd->spmenu;
            rgfItem = 0;

            if (!TestWF(pwnd, WFCHILD)) {
                ThreadLock(pMenu, &tlpMenu);
                rgfItem = xxxTA_AccelerateMenu(pwnd, pMenu, cmd, &hmenuInit);
                ThreadUnlock(&tlpMenu);
            }

            if (TestWF(pwnd, WFCHILD) || rgfItem == 0) {
                UserAssert(hmenuInit == NULL);
                pMenu = pwnd->spmenuSys;
                if (pMenu == NULL && TestWF(pwnd, WFSYSMENU)) {

                    /*
                     * Change owner so this app can access this menu.
                     */
                    pMenu = pwnd->head.rpdesk->spmenuSys;
                    if (pMenu == NULL) {
#ifdef LAME_BUTTON
                        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU, pwnd);
#else
                        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU);
#endif // LAME_BUTTON
                    }
                    ThreadLock(pMenu, &tlpMenu);
                    /*
                     * Must reset the system menu for this window.
                     */
                    xxxSetSysMenu(pwnd);
                } else {
                    ThreadLock(pMenu, &tlpMenu);
                }

                if ((rgfItem = xxxTA_AccelerateMenu(pwnd, pMenu, cmd, &hmenuInit)) != 0) {
                    fSystemMenu = TRUE;
                }
                ThreadUnlock(&tlpMenu);
            }
        }

        fDisabled = TestWF(pwnd, WFDISABLED);

        /*
         * Send only if:  1.  The Item is not disabled, AND
         *                2.  The Window's not being captured AND
         *                3.  The Window's not minimzed, OR
         *                4.  The Window's minimized but the Item is in
         *                   the System Menu.
         */
        if (!(rgfItem & TA_DISABLED) &&
                !(rgfItem && TestWF(pwnd, WFICONIC) && !fSystemMenu)) {
            if (!(rgfItem != 0 && (PtiCurrent()->pq->spwndCapture != NULL ||
                    fDisabled))) {

                if (fSystemMenu) {
                    xxxSendMessage(pwnd, WM_SYSCOMMAND, cmd, 0x00010000L);
                } else {
                    xxxSendMessage(pwnd, WM_COMMAND, MAKELONG(cmd, 1), 0);
                }

                /*
                 * Get outta here
                 */
                flags = FLASTKEY;
            }
        }

        /*
         * Send matching WM_UNINITMENUPOPUP if needed
         */
        if (hmenuInit != NULL) {
            xxxSendMessage(pwnd, WM_UNINITMENUPOPUP, (WPARAM)hmenuInit, 0);
            hmenuInit = NULL;
        }

    Next:
        paccel++;

    } while (!(flags & FLASTKEY) && !fFound);


    return fFound;
}

/***************************************************************************\
* SystoChar
*
* EXIT: If the message was not made with the ALT key down, convert
*       the message from a WM_SYSKEY* to a WM_KEY* message.
*
* IMPLEMENTATION:
*     The 0x2000 bit in the hi word of lParam is set if the key was
*     made with the ALT key down.
*
* History:
*   11/30/90 JimA       Ported.
\***************************************************************************/

UINT SystoChar(
    UINT message,
    LPARAM lParam)
{
    if (CheckMsgFilter(message, WM_SYSKEYDOWN, WM_SYSDEADCHAR) &&
            !(HIWORD(lParam) & SYS_ALTERNATE))
        return (message - (WM_SYSKEYDOWN - WM_KEYDOWN));

    return message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnapi.c ===
/**************************** Module Header ********************************\
* Module Name: mnapi.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Rarely Used Menu API Functions
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revaliodation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxSetMenu
*
* Sets the given window's menu to the menu specified by the pMenu
* parameter.  If pMenu is Null, the window's current menu is removed (but
* not destroyed).
*
* History:
\***************************************************************************/

BOOL xxxSetMenu(
    PWND  pwnd,
    PMENU pMenu,
    BOOL  fRedraw)
{
    CheckLock(pwnd);
    CheckLock(pMenu);

    if (!TestwndChild(pwnd)) {

        LockWndMenu(pwnd, &pwnd->spmenu, pMenu);

        /*
         * only redraw the frame if the window is non-minimized --
         * even if it's not visible, we need RedrawFrame to recalc the NC size
         *
         * Added a check for (redraw) since the MDISetMenu() only needs to
         * set the menu and not perform any redraws.
         */
        if (!TestWF(pwnd, WFMINIMIZED) && fRedraw)
            xxxRedrawFrame(pwnd);

        return TRUE;
    }

    RIPERR0(ERROR_CHILD_WINDOW_MENU, RIP_VERBOSE, "");
    return FALSE;
}


/***************************************************************************\
* xxxSetSystemMenu
*
* !
*
* History:
\***************************************************************************/

BOOL xxxSetSystemMenu(
    PWND pwnd,
    PMENU pMenu)
{
    CheckLock(pwnd);
    CheckLock(pMenu);

    if (TestWF(pwnd, WFSYSMENU)) {
        PMENU pmenuT = pwnd->spmenuSys;
        if (LockWndMenu(pwnd, &pwnd->spmenuSys, pMenu))
            _DestroyMenu(pmenuT);

        MNPositionSysMenu(pwnd, pMenu);

        return TRUE;
    }

    RIPERR0(ERROR_NO_SYSTEM_MENU, RIP_VERBOSE, "");
    return FALSE;
}


/***************************************************************************\
* xxxSetDialogSystemMenu
*
* !
*
* History:
\***************************************************************************/

BOOL xxxSetDialogSystemMenu(
    PWND pwnd)
{
    PMENU pMenu;

    CheckLock(pwnd);

    pMenu = pwnd->head.rpdesk->spmenuDialogSys;
    if (pMenu == NULL) {
#ifdef LAME_BUTTON
        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuDialogSys, ID_DIALOGSYSMENU, pwnd);
#else
        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuDialogSys, ID_DIALOGSYSMENU);
#endif // LAME_BUTTON
    }

    LockWndMenu(pwnd, &pwnd->spmenuSys, pMenu);

    return (pMenu != NULL);
}

/***************************************************************************\
* xxxEndMenu
*
* !
* Revalidation notes:
* o  xxxEndMenu must be called with a valid non-NULL pwnd.
* o  Revalidation is not required in this routine: pwnd is used at the start
*    to obtain pMenuState, and not used again.
*
* History:
\***************************************************************************/

void xxxEndMenu(
    PMENUSTATE pMenuState)
{
    BOOL fMenuStateOwner;
    PPOPUPMENU  ppopup;
    PTHREADINFO ptiCurrent;

    if ((ppopup = pMenuState->pGlobalPopupMenu) == NULL) {

        /*
         * We're not really in menu mode. This can happen
         *  if we are forced out of menu loop too soon; i.e, from
         *  inside xxxMNGetPopup or xxxTrackPopupMenuEx.
         */
         UserAssert(!pMenuState->fInsideMenuLoop && !pMenuState->fMenuStarted);
        return;
    }



    pMenuState->fInsideMenuLoop = FALSE;
    pMenuState->fMenuStarted = FALSE;
    /*
     * Mark the popup as destroyed so people will not use it anymore.
     * This means that root popups can be marked as destroyed before
     * actually being destroyed (nice and confusing).
     */
    ppopup->fDestroyed = TRUE;

    /*
     * Determine if this is the menu loop owner before calling back.
     * Only the owner can destroy the menu windows
     */
   ptiCurrent = PtiCurrent();
   fMenuStateOwner = (ptiCurrent == pMenuState->ptiMenuStateOwner);

    /*
     * Release mouse capture if we got it in xxxStartMenuState
     */
    if (ptiCurrent->pq->spwndCapture == pMenuState->pGlobalPopupMenu->spwndNotify) {
        xxxMNReleaseCapture();
    }

    /*
     * Bail if this is not the menu loop owner
     */
    if (!fMenuStateOwner) {
        RIPMSG1(RIP_WARNING, "xxxEndMenu: Thread %#p doesn't own the menu loop", ptiCurrent);
        return;
    }
    /*
     * If the menu loop is running on a thread different than the thread
     *  that owns spwndNotify, we can have two threads trying to end
     *  this menu at the same time.
     */
    if (pMenuState->fInEndMenu) {
        RIPMSG1(RIP_WARNING, "xxxEndMenu: already in EndMenu. pMenuState:%#p", pMenuState);
        return;
    }
    pMenuState->fInEndMenu = TRUE;

    if (pMenuState->pGlobalPopupMenu->spwndNotify != NULL) {
        if (!pMenuState->pGlobalPopupMenu->fInCancel) {
            xxxMNDismiss(pMenuState);
        }
    } else {
        BOOL    fTrackedPopup = ppopup->fIsTrackPopup;

        /*
         * This should do the same stuff as MenuCancelMenus but not send any
         * messages...
         */
        xxxMNCloseHierarchy(ppopup, pMenuState);

        if (fTrackedPopup) {
            xxxDestroyWindow(ppopup->spwndPopupMenu);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnchange.c ===
/**************************** Module Header ********************************\
* Module Name: mnchange.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Change Menu Routine
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Allocation/deallocation increments.  Make them
 * different to avoid possible thrashing when an item
 * is repeatedly added and removed.
 */
#define CMENUITEMALLOC 8
#define CMENUITEMDEALLOC 10

BOOL xxxSetLPITEMInfo(PMENU pMenu, PITEM pItem, LPMENUITEMINFOW lpmii, PUNICODE_STRING pstr);
typedef BOOL (*MENUAPIFN)(PMENU, UINT, BOOL, LPMENUITEMINFOW);


#if DBG
VOID RelocateMenuLockRecords(
    PITEM pItem,
    int cItem,
    LONG_PTR cbMove)
{
    while (cItem > 0) {
        if (pItem->spSubMenu != NULL) {
            HMRelocateLockRecord(&(pItem->spSubMenu), cbMove);
        }
        pItem++;
        cItem--;
    }
}
#endif

/***************************************************************************\
* UnlockSubMenu
*
* Unlocks the pSubMenu and removes the MENULIST element corresponding to pMenu
*
* History:
*  Nov-20-98    MCostea
\***************************************************************************/
PMENU UnlockSubMenu(
    PMENU pMenu,
    PMENU* ppSubMenu)
{
    PMENULIST* pp;
    PMENULIST pMLFound;

    if (*ppSubMenu == NULL) {
        return NULL;
    }
    /*
     * Remove the item from pMenu's pParentsList
     */
    for (pp = &(*ppSubMenu)->pParentMenus; *pp != NULL; pp = &(*pp)->pNext) {
        if ((*pp)->pMenu == pMenu) {
            pMLFound = *pp;
            *pp = (*pp)->pNext;
            DesktopFree(pMenu->head.rpdesk, pMLFound);
            break;
        }
    }
    return Unlock(ppSubMenu);
}

#define NESTED_MENU_LIMIT 25
/***************************************************************************\
* GetMenuDepth
*
* Returns the menu depth (how many nested submenus this menu has).
* This helps catch loops in the menu hierarchy or deep evil apps.
*
* History:
*  Sept-22-98    MCostea
\***************************************************************************/
CHAR GetMenuDepth(PMENU pMenu, UINT uMaxAllowedDepth)
{
    UINT uItems, uMaxDepth = 0, uSubMenuDepth;
    PITEM pItem;

    /*
     * This will prevent us from getting trapped in loops
     */
    if (uMaxAllowedDepth == 0) {
        return NESTED_MENU_LIMIT;
    }
    pItem = pMenu->rgItems;
    for (uItems = pMenu->cItems; uItems--; pItem++) {
        if (pItem->spSubMenu != NULL) {
            uSubMenuDepth = GetMenuDepth(pItem->spSubMenu, uMaxAllowedDepth-1);
            if (uSubMenuDepth > uMaxDepth) {
                /*
                 * Don't walk the other submenus if a deep branch was found
                 */
                if (uSubMenuDepth >= NESTED_MENU_LIMIT) {
                    return NESTED_MENU_LIMIT;
                }
                uMaxDepth = uSubMenuDepth;
            }
        }
    }
    return uMaxDepth + 1;
}

/***************************************************************************\
* GetMenuAncestors
*
* Returns the maximum number of levels above pMenu in the menu hierarchy.
* Walking the "parent" tree should not be expensive as it is pretty unusual
* for menus to appear in different places in the hierarchy.  The tree is
* usualy a simple linked list.
*
* History:
*  Nov-10-98    MCostea
\***************************************************************************/
CHAR GetMenuAncestors(PMENU pMenu)
{
    PMENULIST pParentMenu;
    CHAR uParentAncestors;
    CHAR retVal = 0;

    for (pParentMenu = pMenu->pParentMenus; pParentMenu; pParentMenu = pParentMenu->pNext) {
        uParentAncestors = GetMenuAncestors(pParentMenu->pMenu);
        if (uParentAncestors > retVal) {
            retVal = uParentAncestors;
        }
    }
    return retVal+1;
}

/**********************************************
*   Global Insert/Append/Set client/server interface
*
*   01-13-94  FritzS  Created
***********************************************/
BOOL xxxSetMenuItemInfo(
    PMENU pMenu,
    UINT wIndex,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{

    PITEM pItem;

    CheckLock(pMenu);

    pItem = MNLookUpItem(pMenu, wIndex, fByPosition,NULL);
    if (pItem == NULL) {
        /*
         * Word doesn't like not finding SC_TASKLIST -- so it that's what
         * they're looking for, let's pretend we changed it.
         */
        if (!fByPosition && (wIndex == SC_TASKLIST))
            return TRUE;

        /*
         * Item not found.  Return false.
         */
        RIPERR0(ERROR_MENU_ITEM_NOT_FOUND, RIP_WARNING, "ModifyMenu: Menu item not found");
        return FALSE;
    }
    /*
     * we need to treat MFT_RIGHTORDER separately as this is propogated down
     * to the entire menu not just to this item so that we stay in ssync. This
     * is pretty similar to the use of MFT_RIGHTJUST, we actually do the
     * propogation because we need the flag in all sorts of places, not just
     * in MBC_RightJustifyMenu()
     */

    /*
     * See ValidateMENUITEMINFO in client\clmenu.c will add more flags to fMask if it use to be MIIM_TYPE
     * Then fMask will not be any more == MIIM_TYPE.
     */

    if (lpmii->fMask & MIIM_TYPE) {
        BOOL bRtoL = (lpmii->fType & MFT_RIGHTORDER) ? TRUE : FALSE;

        if (bRtoL || TestMF(pMenu, MFRTL)) {
            MakeMenuRtoL(pMenu, bRtoL);
        }
    }
    return xxxSetLPITEMInfo(pMenu, pItem, lpmii, pstrItem);
}

/***************************************************************************\
* xxxSetMenuInfo (API)
*
*
* History:
* 12-Feb-1996 JudeJ     Ported from Memphis
* 23-Jun-1996 GerardoB  Fixed up for 5.0
\***************************************************************************/
BOOL xxxSetMenuInfo(PMENU pMenu, LPCMENUINFO lpmi)
{
    PPOPUPMENU  ppopup;
    BOOL        fRecompute = FALSE;
    BOOL        fRedraw    = FALSE;
    UINT        uFlags     = MNUS_DEFAULT;
    PITEM       pItem;
    UINT        uItems;
    TL          tlSubMenu;

    CheckLock(pMenu);

    if (lpmi->fMask & MIM_STYLE) {
        pMenu->fFlags ^= (pMenu->fFlags ^ lpmi->dwStyle) & MNS_VALID;
        fRecompute = TRUE;
    }

    if (lpmi->fMask & MIM_MAXHEIGHT) {
        pMenu->cyMax = lpmi->cyMax;
        fRecompute = TRUE;
    }

    if (lpmi->fMask & MIM_BACKGROUND) {
        pMenu->hbrBack = lpmi->hbrBack;
        fRedraw = TRUE;
        if (pMenu->dwArrowsOn != MSA_OFF) {
            uFlags |= MNUS_DRAWFRAME;
        }
    }

    if (lpmi->fMask & MIM_HELPID) {
        pMenu->dwContextHelpId = lpmi->dwContextHelpID;
    }

    if (lpmi->fMask & MIM_MENUDATA) {
        pMenu->dwMenuData = lpmi->dwMenuData;
    }

    /*
     * Do we need to set this for all submenus?
     */
    if (lpmi->fMask & MIM_APPLYTOSUBMENUS) {
        pItem = pMenu->rgItems;
        for (uItems = pMenu->cItems; uItems--; pItem++) {
            if (pItem->spSubMenu != NULL) {
                ThreadLock(pItem->spSubMenu, &tlSubMenu);
                xxxSetMenuInfo(pItem->spSubMenu, lpmi);
                ThreadUnlock(&tlSubMenu);
            }
        }
    }


    if (fRecompute) {
        // Set the size of this menu to be 0 so that it gets recomputed with this
        // new item...
        pMenu->cyMenu = pMenu->cxMenu = 0;
    }

    if (fRecompute || fRedraw) {
        if (ppopup = MNGetPopupFromMenu(pMenu, NULL)) {
            // this menu is currently being displayed -- redisplay the menu,
            // recomputing if necessary
            xxxMNUpdateShownMenu(ppopup, NULL, uFlags);
        }
    }

    return TRUE;
}
/***************************************************************************\
* MNDeleteAdjustIndex
*
* History:
* 11/19/96 GerardoB  Created
\***************************************************************************/
void NNDeleteAdjustIndex (UINT * puAdjustIndex, UINT uDelIndex)
{
    if (*puAdjustIndex == uDelIndex) {
        *puAdjustIndex = MFMWFP_NOITEM;
    } else if ((int)*puAdjustIndex > (int)uDelIndex) {
        (*puAdjustIndex)--;
    }
}
/***************************************************************************\
* MNDeleteAdjustIndexes
*
* This function is called when an item on an active menu is about
*  to be deleted. It makes sure that other indexes like posSelectedItem,
*  uButtonDownIndex and uDraggingIndex are adjusted to reflect the change
* It "clears" the index if it is AT the point of deletion or
*  decrements it if it is after the point of deletion
*
* History:
* 01/16/97 GerardoB  Created
\***************************************************************************/
void MNDeleteAdjustIndexes (PMENUSTATE pMenuState, PPOPUPMENU ppopup, UINT uiPos)
{
    /*
     * Adjust the index of the selected item and the dropped popup, if needed.
     */
    NNDeleteAdjustIndex(&ppopup->posSelectedItem, uiPos);
    if (ppopup->fHierarchyDropped) {
        NNDeleteAdjustIndex(&ppopup->posDropped, uiPos);
    }

    /*
     * Adjust uButtonDownIndex and uDraggingIndex if needed
     */
    if (pMenuState->uButtonDownHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
        NNDeleteAdjustIndex(&pMenuState->uButtonDownIndex, uiPos);
    }
    if (pMenuState->uDraggingHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
        NNDeleteAdjustIndex(&pMenuState->uDraggingIndex, uiPos);
    }
}
/***************************************************************************\
* xxxInsertMenuItem
*
\***************************************************************************/
BOOL xxxInsertMenuItem(
    PMENU pMenu,
    UINT wIndex,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{
    BOOL            fRet = TRUE;
    PITEM           pItem;
    PMENU           pMenuItemIsOn;
    PMENUSTATE      pMenuState;
    PITEM           pNewItems;
    PPOPUPMENU      ppopup = NULL;
    TL              tlMenu;
    UINT            uiPos;

    CheckLock(pMenu);

// Find out where the item we are inserting should go.
    if (wIndex != MFMWFP_NOITEM) {
        pItem = MNLookUpItem(pMenu, wIndex, fByPosition, &pMenuItemIsOn);

        if (pItem != NULL) {
            pMenu = pMenuItemIsOn;
        } else {
            wIndex = MFMWFP_NOITEM;
        }
    } else {
        pItem = NULL;
    }
    /*
     * keep normal menu items between the MDI system bitmap items
     */
    if (!TestMF(pMenu, MFISPOPUP)
            && (pMenu->cItems != 0)
            && (!(lpmii->fMask & MIIM_BITMAP)
                || (lpmii->hbmpItem > HBMMENU_MBARLAST)
                || (lpmii->hbmpItem == 0)
                    )) {

        UINT wSave, w;
        PITEM  pItemWalk;
        wSave = w = wIndex;

        if (pItem && !fByPosition) {
            w = MNGetpItemIndex(pMenu, pItem);
            w = (UINT)((PBYTE)pItem - (PBYTE)(pMenu->rgItems)) / sizeof(ITEM);
        }

        if (!w) {
            pItemWalk = pMenu->rgItems;
            if ((pItemWalk->hbmp == HBMMENU_SYSTEM)) {
                wIndex = 1;
            }
        } else {
            if (w == MFMWFP_NOITEM) {
                w = pMenu->cItems;
            }

            w--;
            pItemWalk = pMenu->rgItems + w;
            while (w && (pItemWalk->hbmp) && (pItemWalk->hbmp < HBMMENU_MBARLAST)) {
                wIndex = w--;
                pItemWalk--;
            }
        }

        if (wIndex != wSave) {
            pItem = pMenu->rgItems + wIndex;
        }
    }

    // LATER -- we currently realloc every 10 items.  investigate the
    // performance hit/gain we get from this and adjust accordingly.
    if (pMenu->cItems >= pMenu->cAlloced) {
        if (pMenu->rgItems) {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk,
                    (pMenu->cAlloced + CMENUITEMALLOC) * sizeof(ITEM),
                                            DTAG_MENUITEM);
            if (pNewItems) {
                RtlCopyMemory(pNewItems, pMenu->rgItems,
                        pMenu->cAlloced * sizeof(ITEM));
#if DBG
                if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
                    RelocateMenuLockRecords(pNewItems, pMenu->cItems,
                        ((PBYTE)pNewItems) - (PBYTE)(pMenu->rgItems));
                }
#endif
                DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);
            }
        } else {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk,
                    sizeof(ITEM) * CMENUITEMALLOC, DTAG_MENUITEM);
        }

        if (pNewItems == NULL) {
            return FALSE;
        }

        pMenu->cAlloced += CMENUITEMALLOC;
        pMenu->rgItems = pNewItems;

        /*
         * Now look up the item again since it probably moved when we realloced the
         * memory.
         */
        if (wIndex != MFMWFP_NOITEM)
            pItem = MNLookUpItem(pMenu, wIndex, fByPosition, &pMenuItemIsOn);

    }


    /*
     * If this menu is being displayed right now and we're not appending
     *  an item, then we need to adjust the positions we keep track of.
     * We want to do this before moving the items to accomodate the
     *  new one, in case we need to clear the insertion bar
     */
    if ((pItem != NULL)
        && (ppopup = MNGetPopupFromMenu(pMenu, &pMenuState))) {
        /*
         * This menu is active. Adjust the index the selected
         *  item and the dropped popup, if needed
         */
        uiPos = MNGetpItemIndex(pMenu, pItem);
        if (ppopup->posSelectedItem >= (int)uiPos) {
            ppopup->posSelectedItem++;
        }
        if (ppopup->fHierarchyDropped && (ppopup->posDropped >= (int)uiPos)) {
            ppopup->posDropped++;
        }

        /*
         * Adjust uButtonDownIndex and uDraggingIndex if needed
         */
        if (pMenuState->uButtonDownHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
            if ((int)pMenuState->uButtonDownIndex >= (int)uiPos) {
                pMenuState->uButtonDownIndex++;
            }
        }
        if (pMenuState->uDraggingHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
            /*
             * Check to see if an item is inserted right on the insertion
             *  bar. If so, clean up any present insertion bar state
             */
            if (((int)pMenuState->uDraggingIndex == (int)uiPos)
                    && (pMenuState->uDraggingFlags & MNGOF_TOPGAP)) {

                xxxMNSetGapState(pMenuState->uDraggingHitArea,
                              pMenuState->uDraggingIndex,
                              pMenuState->uDraggingFlags,
                              FALSE);
            }

            if ((int)pMenuState->uDraggingIndex >= (int)uiPos) {
                pMenuState->uDraggingIndex++;
            }
        }
    }

    pMenu->cItems++;
    if (pItem != NULL) {
        // Move this item up to make room for the one we want to insert.
        RtlMoveMemory(pItem + 1, pItem, (pMenu->cItems - 1) *
                sizeof(ITEM) - ((char *)pItem - (char *)pMenu->rgItems));
#if DBG
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            RelocateMenuLockRecords(pItem + 1,
                    (int)(&(pMenu->rgItems[pMenu->cItems]) - (pItem + 1)),
                    sizeof(ITEM));
        }
#endif
    } else {

        // If lpItem is null, we will be inserting the item at the end of the
        // menu.
        pItem = pMenu->rgItems + pMenu->cItems - 1;
    }

    // Need to zero these fields in case we are inserting this item in the
    // middle of the item list.
    pItem->fType           = 0;
    pItem->fState          = 0;
    pItem->wID             = 0;
    pItem->spSubMenu       = NULL;
    pItem->hbmpChecked     = NULL;
    pItem->hbmpUnchecked   = NULL;
    pItem->cch             = 0;
    pItem->dwItemData      = 0;
    pItem->xItem           = 0;
    pItem->yItem           = 0;
    pItem->cxItem          = 0;
    pItem->cyItem          = 0;
    pItem->hbmp            = NULL;
    pItem->cxBmp           = MNIS_MEASUREBMP;
    pItem->lpstr           = NULL;

    /*
     * We might have reassigned pMenu above, so lock it
     */
    ThreadLock(pMenu, &tlMenu);
    if (!xxxSetLPITEMInfo(pMenu, pItem, lpmii, pstrItem)) {

        /*
         * Reset any of the indexes we might have adjusted above
         */
        if (ppopup != NULL) {
            MNDeleteAdjustIndexes(pMenuState, ppopup, uiPos);
        }

        MNFreeItem(pMenu, pItem, TRUE);


        // Move things up since we removed/deleted the item
        RtlMoveMemory(pItem, pItem + 1, pMenu->cItems * (UINT)sizeof(ITEM) +
            (UINT)((char *)&pMenu->rgItems[0] - (char *)(pItem + 1)));
#if DBG
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            RelocateMenuLockRecords(pItem,
                    (int)(&(pMenu->rgItems[pMenu->cItems - 1]) - pItem),
                    -(int)sizeof(ITEM));
        }
#endif
        pMenu->cItems--;
        fRet = FALSE;
    } else {
       /*
        * Like MFT_RIGHTJUSTIFY, this staggers down the menu,
        *    (but we inherit, to make localisation etc MUCH easier).
        *
        * MFT_RIGHTORDER is the same value as MFT_SYSMENU.  We distinguish
        * between the two by also looking for MFT_BITMAP.
        */
        if (TestMF(pMenu, MFRTL) ||
            (pItem && TestMFT(pItem, MFT_RIGHTORDER) && !TestMFT(pItem, MFT_BITMAP))) {
            pItem->fType |= (MFT_RIGHTORDER | MFT_RIGHTJUSTIFY);
            if (pItem->spSubMenu) {
                MakeMenuRtoL(pItem->spSubMenu, TRUE);
            }
        }
    }

    ThreadUnlock(&tlMenu);
    return fRet;

}

/***************************************************************************\
* FreeItemBitmap
*
* History:
*  07-23-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
void FreeItemBitmap(PITEM pItem)
{
    // Free up hItem unless it's a bitmap handle or nonexistent.
    // Apps are responsible for freeing their bitmaps.
     if ((pItem->hbmp != NULL) && !TestMFS(pItem, MFS_CACHEDBMP)) {
            /*
             * Assign ownership of the bitmap to the process that is
             * destroying the menu to ensure that bitmap will
             * eventually be destroyed.
             */
        GreSetBitmapOwner((HBITMAP)(pItem->hbmp), OBJECT_OWNER_CURRENT);
    }

    // Zap this pointer in case we try to free or reference it again
    pItem->hbmp  = NULL;
}
/***************************************************************************\
* FreeItemString
*
* History:
*  07-23-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/

void FreeItemString(PMENU pMenu, PITEM pItem)
{
    // Free up Item's string
    if ((pItem->lpstr != NULL)) {
        DesktopFree(pMenu->head.rpdesk, pItem->lpstr);
    }
    // Zap this pointer in case we try to free or reference it again
    pItem->lpstr  = NULL;
}

/***************************************************************************\
* FreeItem
*
* Free a menu item and its associated resources.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

void MNFreeItem(
    PMENU pMenu,
    PITEM pItem,
    BOOL fFreeItemPopup)
{
    PMENU pSubMenu;

    FreeItemBitmap(pItem);
    FreeItemString(pMenu, pItem);

    pSubMenu = UnlockSubMenu(pMenu, &(pItem->spSubMenu));
    if (pSubMenu) {
        if (fFreeItemPopup) {
            _DestroyMenu(pSubMenu);
        }
    }
}
/***************************************************************************\
* RemoveDeleteMenuHelper
*
* This removes the menu item from the given menu.  If
* fDeleteMenuItem, the memory associted with the popup menu associated with
* the item being removed is freed and recovered.
*
* History:
\***************************************************************************/

BOOL xxxRemoveDeleteMenuHelper(
    PMENU pMenu,
    UINT nPosition,
    DWORD wFlags,
    BOOL fDeleteMenu)
{
    PITEM  pItem;
    PITEM  pNewItems;
    PMENU  pMenuSave;
    PMENUSTATE pMenuState;
    PPOPUPMENU ppopup;
    UINT       uiPos;

    CheckLock(pMenu);

    pMenuSave = pMenu;

    pItem = MNLookUpItem(pMenu, nPosition, (BOOL) (wFlags & MF_BYPOSITION), &pMenu);
    if (pItem == NULL) {

        /*
         * Hack for apps written for Win95. In Win95 the prototype for
         * this function was with 'WORD nPosition' and because of this
         * the HIWORD(nPosition) got set to 0.
         * We are doing this just for system menu commands.
         */
        if (nPosition >= 0xFFFFF000 && !(wFlags & MF_BYPOSITION)) {
            nPosition &= 0x0000FFFF;
            pMenu = pMenuSave;
            pItem = MNLookUpItem(pMenu, nPosition, FALSE, &pMenu);

            if (pItem == NULL)
                return FALSE;
        } else
            return FALSE;
    }

    if (ppopup = MNGetPopupFromMenu(pMenu, &pMenuState)) {
        /*
         * This menu is active; since we're about to insert an item,
         *  make sure that any of the positions we've stored are
         *  adjusted properly
         */
        uiPos = MNGetpItemIndex(pMenu, pItem);
        MNDeleteAdjustIndexes(pMenuState, ppopup, uiPos);
    }
    MNFreeItem(pMenu, pItem, fDeleteMenu);

    /*
     * Reset the menu size so that it gets recomputed next time.
     */
    pMenu->cyMenu = pMenu->cxMenu = 0;

    if (pMenu->cItems == 1) {
        DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);
        pMenu->cAlloced = 0;
        pNewItems = NULL;
    } else {
        /*
         * Move things up since we removed/deleted the item.
         */

        RtlMoveMemory(pItem, pItem + 1, pMenu->cItems * (UINT)sizeof(ITEM) +
                (UINT)((char *)&pMenu->rgItems[0] - (char *)(pItem + 1)));
#if DBG
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            RelocateMenuLockRecords(pItem,
                    (int)(&(pMenu->rgItems[pMenu->cItems - 1]) - pItem),
                    -(int)sizeof(ITEM));
        }
#endif

        /*
         * We're shrinking so if localalloc fails, just leave the mem as is.
         */
        UserAssert(pMenu->cAlloced >= pMenu->cItems);
        if ((pMenu->cAlloced - pMenu->cItems) >= CMENUITEMDEALLOC - 1) {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk,
                    (pMenu->cAlloced - CMENUITEMDEALLOC) * sizeof(ITEM),
                                            DTAG_MENUITEM);
            if (pNewItems != NULL) {

                RtlCopyMemory(pNewItems, pMenu->rgItems,
                        (pMenu->cAlloced - CMENUITEMDEALLOC) * sizeof(ITEM));
#if DBG
                if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
                    RelocateMenuLockRecords(pNewItems, pMenu->cItems - 1,
                        ((PBYTE)pNewItems) - (PBYTE)(pMenu->rgItems));
                }
#endif
                DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);
                pMenu->cAlloced -= CMENUITEMDEALLOC;
            } else {
                pNewItems = pMenu->rgItems;
            }
        } else {
            pNewItems = pMenu->rgItems;
        }
    }

    pMenu->rgItems = pNewItems;
    pMenu->cItems--;

    if (ppopup != NULL) {
        /*
         * this menu is currently being displayed -- redisplay the menu with
         * this item removed
         */
        xxxMNUpdateShownMenu(ppopup, pMenu->rgItems + uiPos, MNUS_DELETE);
    }
    return TRUE;
}

/***************************************************************************\
* RemoveMenu
*
* Removes and item but doesn't delete it. Only useful for items with
* an associated popup since this will remove the item from the menu with
* destroying the popup menu handle.
*
* History:
\***************************************************************************/

BOOL xxxRemoveMenu(
    PMENU pMenu,
    UINT nPosition,
    UINT wFlags)
{
    return xxxRemoveDeleteMenuHelper(pMenu, nPosition, wFlags, FALSE);
}

/***************************************************************************\
* DeleteMenu
*
* Deletes an item. ie. Removes it and recovers the memory used by it.
*
* History:
\***************************************************************************/

BOOL xxxDeleteMenu(
    PMENU pMenu,
    UINT nPosition,
    UINT wFlags)
{
    return xxxRemoveDeleteMenuHelper(pMenu, nPosition, wFlags, TRUE);
}

/***************************************************************************\
* xxxSetLPITEMInfo
*
* History:
*  07-23-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL NEAR xxxSetLPITEMInfo(
    PMENU pMenu,
    PITEM pItem,
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{

    HANDLE hstr;
    UINT cch;
    BOOL fRecompute = FALSE;
    BOOL fRedraw = FALSE;
    PPOPUPMENU ppopup;

    CheckLock(pMenu);

    if (lpmii->fMask & MIIM_FTYPE) {
        pItem->fType &= ~MFT_MASK;
        pItem->fType |= lpmii->fType;
        if (lpmii->fType & MFT_SEPARATOR ) {
            pItem->fState |= MFS_DISABLED ;
        }
        fRecompute = TRUE;
        fRedraw = (lpmii->fType & MFT_OWNERDRAW);
    }

    if (lpmii->fMask & MIIM_STRING) {
        if (pstrItem->Buffer != NULL) {
            hstr = (HANDLE)DesktopAlloc(pMenu->head.rpdesk,
                    pstrItem->Length + sizeof(UNICODE_NULL), DTAG_MENUTEXT);

            if (hstr == NULL) {
                return FALSE;
            }

            try {
                RtlCopyMemory(hstr, pstrItem->Buffer, pstrItem->Length);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                DesktopFree(pMenu->head.rpdesk, hstr);
                return FALSE;
            }
            cch = pstrItem->Length / sizeof(WCHAR);
            /*
             * We don't need to null terminate the string, since DesktopAlloc
             * zero-fills for us.
             */
        } else {
            cch = 0;
            hstr = NULL;
        }
        FreeItemString(pMenu,pItem);
        pItem->cch = cch;
        pItem->lpstr = hstr;
        fRecompute = TRUE;
        fRedraw = TRUE;
    }

    if (lpmii->fMask & MIIM_BITMAP) {
        FreeItemBitmap(pItem);
        pItem->hbmp = lpmii->hbmpItem;
        fRecompute = TRUE;
        fRedraw = TRUE;
        pItem->cxBmp = MNIS_MEASUREBMP;
        /*
         * If this is one of the special bitmaps, mark it as such
         */
        if ((pItem->hbmp > HBMMENU_MIN) && (pItem->hbmp < HBMMENU_MAX)) {
            SetMFS(pItem, MFS_CACHEDBMP);
        } else {
            ClearMFS(pItem, MFS_CACHEDBMP);
        }
    }

    if (lpmii->fMask & MIIM_ID) {
        pItem->wID = lpmii->wID;
    }

    if (lpmii->fMask & MIIM_DATA) {
        pItem->dwItemData = lpmii->dwItemData;
    }

    if (lpmii->fMask & MIIM_STATE) {
        /*
         * Preserve private bits (~MFS_MASK).
         * Also preserve MFS_HILITE | MFS_DEFAULT if already set; if not set,
         *  let the caller turn them on.
         */
        UserAssert(!(lpmii->fState & ~MFS_MASK));
        pItem->fState &= ~MFS_MASK | MFS_HILITE | MFS_DEFAULT;
        pItem->fState |= lpmii->fState;
        if (pItem->fType & MFT_SEPARATOR)
            pItem->fState |= MFS_DISABLED;
        fRedraw = TRUE;
    }

    if (lpmii->fMask & MIIM_CHECKMARKS) {
        pItem->hbmpChecked     = lpmii->hbmpChecked;
        pItem->hbmpUnchecked   = lpmii->hbmpUnchecked;
        fRedraw = TRUE;
    }

    if (lpmii->fMask & MIIM_SUBMENU) {
        PMENU pSubMenu = NULL;

        if (lpmii->hSubMenu != NULL) {
            pSubMenu = ValidateHmenu(lpmii->hSubMenu);
        }

        // Free the popup associated with this item, if any and if needed.
        if (pItem->spSubMenu != pSubMenu) {
            if (pItem->spSubMenu != NULL) {
                _DestroyMenu(pItem->spSubMenu);
            }
            if (pSubMenu != NULL) {

                BOOL bMenuCreated = FALSE;
                /*
                 * Fix MSTest that sets a submenu to itself by giving it a different handle.
                 * So the loop is broken and we won't fail their call later
                 * MCostea #243374
                 */
                if (pSubMenu == pMenu) {
                    pSubMenu = _CreateMenu();
                    if (!pSubMenu) {
                        return FALSE;
                    }
                    bMenuCreated = TRUE;
                }
                /*
                 * Link the submenu and then check for loops
                 */
                Lock(&(pItem->spSubMenu), pSubMenu);
                SetMF(pItem->spSubMenu, MFISPOPUP);
                /*
                 * We just added a submenu.  Check to see if the menu tree is not
                 * unreasonable deep and there is no loop forming.
                 * This will prevent us from running out of stack
                 * MCostea #226460
                 */
                if (GetMenuDepth(pSubMenu, NESTED_MENU_LIMIT) + GetMenuAncestors(pMenu) >= NESTED_MENU_LIMIT) {
FailInsertion:
                    RIPMSG1(RIP_WARNING, "The menu hierarchy is very deep or has a loop %#p", pMenu);
                    ClearMF(pItem->spSubMenu, MFISPOPUP);
                    Unlock(&(pItem->spSubMenu));
                    if (bMenuCreated) {
                        _DestroyMenu(pSubMenu);
                    }
                    return FALSE;
                }
                /*
                 * Add pMenu to the pSubMenu->pParentMenus list
                 */
                {
                    PMENULIST pMenuList = DesktopAlloc(pMenu->head.rpdesk,
                                            sizeof(MENULIST),
                                            DTAG_MENUITEM);
                    if (!pMenuList) {
                        goto FailInsertion;
                    }
                    pMenuList->pMenu = pMenu;
                    pMenuList->pNext = pSubMenu->pParentMenus;
                    pSubMenu->pParentMenus = pMenuList;
                }
            } else {
                UnlockSubMenu(pMenu, &(pItem->spSubMenu));
            }
            fRedraw = TRUE;
        }
    }

    // For support of the old way of defining a separator i.e. if it is not a string
    // or a bitmap or a ownerdraw, then it must be a separator.
    // This should prpbably be moved to MIIOneWayConvert -jjk
    if (!(pItem->fType & (MFT_OWNERDRAW | MFT_SEPARATOR))
         && (pItem->lpstr == NULL)
         && (pItem->hbmp == NULL)) {

        pItem->fType = MFT_SEPARATOR;
        pItem->fState|=MFS_DISABLED;
    }

    if (fRecompute) {
        pItem->dxTab   = 0;
        pItem->ulX     = UNDERLINE_RECALC;
        pItem->ulWidth = 0;

        // Set the size of this menu to be 0 so that it gets recomputed with this
        // new item...
        pMenu->cyMenu = pMenu->cxMenu = 0;


        if (fRedraw) {
            if (ppopup = MNGetPopupFromMenu(pMenu, NULL)) {
                // this menu is currently being displayed -- redisplay the menu,
                // recomputing if necessary
                xxxMNUpdateShownMenu(ppopup, pItem, MNUS_DEFAULT);
            }
        }

    }

    return TRUE;
}

BOOL _SetMenuContextHelpId(PMENU pMenu, DWORD dwContextHelpId)
{

    // Set the new context help Id;
    pMenu->dwContextHelpId = dwContextHelpId;

    return TRUE;
}

BOOL _SetMenuFlagRtoL(PMENU pMenu)
{

    // This is a right-to-left menu being created;
    SetMF(pMenu, MFRTL);

    return TRUE;
}

/***************************************************************************\
* MNGetPopupFromMenu
*
*  checks to see if the given hMenu is currently being shown in a popup.
*  returns the PPOPUPMENU associated with this hMenu if it is being shown;
*  NULL if the hMenu is not currently being shown
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
PPOPUPMENU MNGetPopupFromMenu(PMENU pMenu, PMENUSTATE *ppMenuState)
{
    PPOPUPMENU  ppopup;
    PMENUSTATE pMenuState;

    /*
     * If this menu doesn't have a notification window, then
     *  it cannot be in menu mode
     */
   if (pMenu->spwndNotify == NULL) {
       return NULL;
   }

   /*
    * If no pMenuState, no menu mode
    */
   pMenuState = GetpMenuState(pMenu->spwndNotify);
   if (pMenuState == NULL) {
       return NULL;
   }

   /*
    * If not in the menu loop, not yet or no longer in menu mode
    */
  if (!pMenuState->fInsideMenuLoop) {
      return NULL;
  }

  /*
   * return pMenuState if requested
   */
  if (ppMenuState != NULL) {
      *ppMenuState = pMenuState;
  }


    /*
     * Starting from the root popup, find the popup associated to this menu
     */
    ppopup = pMenuState->pGlobalPopupMenu;
    while (ppopup != NULL) {
        /*
         * found?
         */
        if (ppopup->spmenu == pMenu) {
            if (ppopup->fIsMenuBar) {
                return NULL;
            }
            /*
             * Since the menu is being modified, let's kill any animation.
             */
            MNAnimate(pMenuState, FALSE);
            return ppopup;
        }
        /*
         * If no more popups, bail
         */
        if (ppopup->spwndNextPopup == NULL) {
            return NULL;
        }

        /*
         * Next popup
         */
        ppopup = ((PMENUWND)ppopup->spwndNextPopup)->ppopupmenu;
    }

    return NULL;
}

/***************************************************************************\
* xxxMNUpdateShownMenu
*
*  updates a given ppopup menu window to reflect the inserting, deleting,
*  or altering of the given lpItem.
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
void xxxMNUpdateShownMenu(PPOPUPMENU ppopup, PITEM pItem, UINT uFlags)
{
    RECT rc;
    PWND pwnd = ppopup->spwndPopupMenu;
    PMENU pMenu = ppopup->spmenu;
    TL tlpwnd;
    TL tlpmenu;

    /*
     * The popup might get destroyed while we callback, so lock this pwnd.
     */
    ThreadLock(pwnd, &tlpwnd);
    ThreadLock(ppopup->spmenu, &tlpmenu);

    _GetClientRect(pwnd, &rc);

    /*
     * If we need to resize menu window
     */
    if (pMenu->cxMenu == 0) {
        RECT rcScroll = rc;
        int cySave = rc.bottom;
        int cxSave = rc.right;
        DWORD dwSize;
        DWORD dwArrowsOnBefore;

        dwArrowsOnBefore = pMenu->dwArrowsOn;
        UserAssert(uFlags != 0);
        dwSize = (DWORD)xxxSendMessage(pwnd, MN_SIZEWINDOW, uFlags, 0L);
        uFlags &= ~MNUS_DRAWFRAME;
        /*
         * If scroll arrows appeared or disappeared,  redraw entire client
         */
        if (dwArrowsOnBefore ^ pMenu->dwArrowsOn) {
            goto InvalidateAll;
        }

        rc.right = LOWORD(dwSize);
        if (pItem != NULL) {
            if (rc.right != cxSave) {
                /*
                 * The width changed, so redraw everything.
                 * NOTE -- This could be tuned to just redraw items with
                 * submenus and/or accelerator fields.
                 */
                goto InvalidateAll;
            } else {
                rc.bottom = pMenu->cyMenu;
                if (pMenu->dwArrowsOn != MSA_OFF) {
                    if (rc.bottom <= cySave) {
                        rc.top = pItem->yItem - MNGetToppItem(pMenu)->yItem;
                        goto InvalidateRest;
                    }

                    _GetClientRect(pwnd, &rcScroll);
                }

                rc.top = rcScroll.top = pItem->yItem - MNGetToppItem(pMenu)->yItem;
                if ((rc.top >= 0) && (rc.top < (int)pMenu->cyMenu)) {
                    xxxScrollWindowEx(pwnd, 0, rc.bottom - cySave, &rcScroll, &rc, NULL, NULL, SW_INVALIDATE | SW_ERASE);
                }
            } /* else of if (rc.right != cxSave) */
        } /* if (pItem != NULL) */
    } /* if (pMenu->cxMenu == 0) */

    if (!(uFlags & MNUS_DELETE)) {
        if (pItem != NULL) {
            rc.top = pItem->yItem - MNGetToppItem(pMenu)->yItem;
            rc.bottom = rc.top + pItem->cyItem;
InvalidateRest:
            if ((rc.top >= 0) && (rc.top < (int)pMenu->cyMenu)) {
                xxxInvalidateRect(pwnd, &rc, TRUE);
            }
        } else {
InvalidateAll:
            xxxInvalidateRect(pwnd, NULL, TRUE);
        }
        if (uFlags & MNUS_DRAWFRAME) {
            xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0,
             SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE
             | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
        }
    }

    ThreadUnlock(&tlpmenu);
    ThreadUnlock(&tlpwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mncomput.c ===
/**************************** Module Header ********************************\
* Module Name: mncomput.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Layout Calculation Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


DWORD MNRecalcTabStrings(HDC hdc, PMENU pMenu, UINT iBeg, UINT iEnd,
                         DWORD xTab, DWORD hCount);

/***************************************************************************\
* xxxMNGetBitmapSize
*
* Returns TRUE if measureitem was sent and FALSE if not
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
BOOL xxxMNGetBitmapSize(
    LPITEM pItem,
    PWND pwndNotify)
{
    MEASUREITEMSTRUCT mis;

    if (pItem->cxBmp != MNIS_MEASUREBMP) {
        return FALSE;
    }

    // Send a measure item message to the owner
    mis.CtlType = ODT_MENU;
    mis.CtlID = 0;
    mis.itemID  = pItem->wID;
    mis.itemWidth = 0;
// After scrollable menus
//    mis32.itemHeight= gcyMenuFontChar;
    mis.itemHeight= (UINT)gpsi->cySysFontChar;
    mis.itemData = pItem->dwItemData;

    xxxSendMessage(pwndNotify, WM_MEASUREITEM, 0, (LPARAM)&mis);

    pItem->cxBmp = mis.itemWidth;
    pItem->cyBmp = mis.itemHeight;

    return TRUE;
}

/***************************************************************************\
* xxxItemSize
*
* Calc the dimensions of bitmaps and strings. Loword of returned
* value contains width, high word contains height of item.
*
* History:
*  07-23-96 GerardoB - fixed up for 5.0
\***************************************************************************/
BOOL xxxMNItemSize(
    PMENU pMenu,
    PWND pwndNotify,
    HDC hdc,
    PITEM pItem,
    BOOL fPopup,
    LPPOINT lppt)
{
    BITMAP bmp;
    int width = 0;
    int height = 0;
    DWORD xRightJustify;
    LPWSTR lpMenuString;
    HFONT               hfnOld;
    int                 tcExtra;

    UNREFERENCED_PARAMETER(pMenu);

    CheckLock(pMenu);
    CheckLock(pwndNotify);

    if (!fPopup) {

        /*
         * Save off the height of the top menu bar since we will used this often
         * if the pItem is not in a popup. (ie. it is in the top level menu bar)
         */
        height = SYSMET(CYMENUSIZE);
    }

    hfnOld = NULL;
    if (TestMFS(pItem, MFS_DEFAULT)) {
        if (ghMenuFontDef)
            hfnOld = GreSelectFont(hdc, ghMenuFontDef);
        else {
            tcExtra = GreGetTextCharacterExtra(hdc);
            GreSetTextCharacterExtra(hdc, tcExtra + 1 + (gcxMenuFontChar / gpsi->cxSysFontChar));
        }
    }

    /*
     * Compute bitmap dimensions if needed
     */
    if (pItem->hbmp != NULL)  {
        if (pItem->hbmp == HBMMENU_CALLBACK) {
            xxxMNGetBitmapSize(pItem, pwndNotify);
        } else if (pItem->cxBmp == MNIS_MEASUREBMP) {
            if (TestMFS(pItem, MFS_CACHEDBMP)) {
                pItem->cxBmp = SYSMET(CXMENUSIZE);
                pItem->cyBmp = SYSMET(CYMENUSIZE);
                if (pItem->hbmp == HBMMENU_SYSTEM) {
                    pItem->cxBmp += SYSMET(CXEDGE);
                    /*
                     * Chicago/Memphis only stretch the width,
                     * not the height. NT Bug 124779. FritzS
                     */
                 //  pItem->cyBmp += SYSMET(CXEDGE);
                }
            } else {
                if (GreExtGetObjectW(pItem->hbmp, sizeof(BITMAP), (LPSTR)&bmp)) {
                    pItem->cxBmp = bmp.bmWidth;
                    pItem->cyBmp = bmp.bmHeight;
                } else {
                    /*
                     * If the bitmap is not useable, this is as good a default
                     * as any.
                     */
                    pItem->cxBmp = SYSMET(CXMENUSIZE);
                    pItem->cyBmp = SYSMET(CYMENUSIZE);
                }
            }
        }
        width = pItem->cxBmp;
        /*
         * Remember the max bitmap width to align the text in all items.
         */
        pMenu->cxTextAlign = max(pMenu->cxTextAlign, (DWORD)width);
        /*
         * In menu bars, we force the item to be at least CYMNSIZE.
         * Fixes many, many problems w/ apps that fake own MDI.
         */
        if (fPopup) {
            height = pItem->cyBmp;
        } else {
            height = max((int)pItem->cyBmp, height);
        }
    } else if (TestMFT(pItem, MFT_OWNERDRAW)) {
        // This is an ownerdraw item -- the width and height are stored in
        // cxBmp and cyBmp
        xxxMNGetBitmapSize(pItem, pwndNotify);
        width = pItem->cxBmp;
        //
        // Ignore height with menu bar now--that's set by user.
        //
        if (fPopup) {
            height = pItem->cyBmp;
            // If this item has a popup (hierarchical) menu associated with it, then
            // reserve room for the bitmap that tells the user that a hierarchical
            // menu exists here.
            // B#2966, t-arthb

            UserAssert(fPopup == (TestMF(pMenu, MFISPOPUP) != 0));

            width = width + (gcxMenuFontChar << 1);
        }
    }

    if ((pItem->lpstr != NULL) && (!TestMFT(pItem, MFT_OWNERDRAW)) ) {
        SIZE size;

        /*
         * This menu item contains a string
         */

        /*
         * We want to keep the menu bar height if this isn't a popup.
         */
        if (fPopup) {
            /* The thickness of mnemonic underscore is CYBORDER and the gap
             * between the characters and the underscore is another CYBORDER
             */
            height = max(height, gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE));
        }

        lpMenuString = TextPointer(pItem->lpstr);
        xRightJustify = FindCharPosition(lpMenuString, TEXT('\t'));

        xxxPSMGetTextExtent(hdc, lpMenuString, xRightJustify, &size);

        if (width) {
            width += MNXSPACE + size.cx;
        } else {
            width =  size.cx;
        }
    }

    if (fPopup && !TestMFT(pItem, MFT_OWNERDRAW)) {
        /*
         *  Add on space for checkmark, then horz spacing for default & disabled
         *   plus some left margin.
         */
        if (TestMF(pMenu, MNS_CHECKORBMP) || !TestMF(pMenu, MNS_NOCHECK)) {
            width += gpsi->oembmi[OBI_MENUCHECK].cx;
        }
        width += MNXSPACE + MNLEFTMARGIN + 2;
        height += 2;
    }

    if (TestMFS(pItem, MFS_DEFAULT)) {
        if (hfnOld)
            GreSelectFont(hdc, hfnOld);
        else
            GreSetTextCharacterExtra(hdc, tcExtra);
    }

    /*
     * Loword contains width, high word contains height of item.
     */
    lppt->x = width;
    lppt->y = height;

    return(TestMFT(pItem, MFT_OWNERDRAW));
}

/***************************************************************************\
* xxxMNCompute
*
* !
*
* History:
\***************************************************************************/
int xxxMNCompute(
    PMENU pMenu,
    PWND pwndNotify,
    DWORD yMenuTop,
    DWORD xMenuLeft,
    DWORD cxMax,
    LPDWORD lpdwMenuHeight)
{
    UINT         cItem;
    DWORD        cxItem;
    DWORD        cyItem;
    DWORD        cyItemKeep;
    DWORD        yPopupTop;
    INT          cMaxWidth;
    DWORD        cMaxHeight;
    UINT         cItemBegCol;
    DWORD        temp;
    PITEM        pCurItem;
    POINT        ptMNItemSize;
    BOOL         fOwnerDrawItems;
    BOOL         fMenuBreak;
    LPWSTR       lpsz;
    BOOL         fPopupMenu;
    DWORD        menuHeight = 0;
    HDC          hdc;
    HFONT        hOldFont;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    BOOL         fStringAndBitmapItems;

    CheckLock(pMenu);
    CheckLock(pwndNotify);

    /*
     * Whoever computes the menu, becomes the owner.
     */
    if (pwndNotify != pMenu->spwndNotify) {
        Lock(&pMenu->spwndNotify, pwndNotify);
    }


    if (lpdwMenuHeight != NULL) {
        menuHeight = *lpdwMenuHeight;
    }

    /*
     * Empty menus have a height of zero.
     */
    if (pMenu->cItems == 0) {
        return 0;
    }

    hdc = _GetDCEx(NULL, NULL, DCX_WINDOW | DCX_CACHE);
    hOldFont = GreSelectFont(hdc, ghMenuFont);

    /*
     * Try to make a non-multirow menu first.
     */
    pMenu->fFlags &= (~MFMULTIROW);

    fPopupMenu = TestMF(pMenu, MFISPOPUP);

    if (fPopupMenu) {
        /*
         * Reset the menu bar height to 0 if this is a popup since we are
         * being called from menu.c MN_SIZEWINDOW.
         */
        menuHeight = 0;
    } else if (pwndNotify != NULL) {
        pMenu->cxMenu = cxMax;
    }

    /*
     * Initialize the computing variables.
     */
    cMaxWidth = cyItemKeep = 0L;
    cItemBegCol = 0;

    cyItem = yPopupTop = yMenuTop;
    cxItem = xMenuLeft;

    pCurItem = (PITEM)&pMenu->rgItems[0];
    /*
     * cxTextAlign is used to align the text in all items; this is useful
     *  in popup menus that mix text only items with bitmap-text items. It's
     *  set to the max bitmap width plus some spacing.
     * Do this for new menus wich use string AND bitmaps on the same item
     */
    fStringAndBitmapItems = FALSE;
    pMenu->cxTextAlign = 0;

    /*
     * Process each item in the menu.
     */
    fOwnerDrawItems = FALSE;
    for (cItem = 0; cItem < pMenu->cItems; cItem++) {

        /*
         * If it's not a separator, find the dimensions of the object.
         */
        if (TestMFT(pCurItem, MFT_SEPARATOR) &&
                ( !TestMFT(pCurItem, MFT_OWNERDRAW) ||
                  (LOWORD(ptiCurrent->dwExpWinVer) < VER40)) ) {
            /*
            * If version is less than 4.0  don't test the MFT_OWNERDRAW
            * flag. Bug 21922; App MaxEda has both separator and Ownerdraw
            * flags on. In 3.51 we didn't test the OwnerDraw flag
            */

            //
            // This is a separator. It's drawn as wide as the menu area,
            // leaving some space above and below. Since the menu area is
            // the max of the items' widths, we set our width to 0 so as not
            // to affect the result.
            //
            pCurItem->cxItem = 0;
            pCurItem->cyItem = SYSMET(CYMENUSIZE) / 2;


        } else {
            /*
             * Are we using NT5 strings and bitmaps?
             */
            fStringAndBitmapItems |= ((pCurItem->hbmp != NULL) && (pCurItem->lpstr != NULL));
            /*
             * Get the item's X and Y dimensions.
             */
            if (xxxMNItemSize(pMenu, pwndNotify, hdc, pCurItem, fPopupMenu, &ptMNItemSize))
                fOwnerDrawItems = TRUE;

            pCurItem->cxItem = ptMNItemSize.x;
            pCurItem->cyItem = ptMNItemSize.y;
            if (!fPopupMenu && ((pCurItem->hbmp == NULL) || (pCurItem->lpstr != NULL))) {
                pCurItem->cxItem += gcxMenuFontChar * 2;
            }
        }

        if (menuHeight != 0)
            pCurItem->cyItem = menuHeight;

        /*
         * If this is the first item, initialize cMaxHeight.
         */
        if (cItem == 0)
            cMaxHeight = pCurItem->cyItem;

        /*
         * Is this a Pull-Down menu?
         */
        if (fPopupMenu) {

            /*
             * If this item has a break or is the last item...
             */
            if ((fMenuBreak = TestMFT(pCurItem, MFT_BREAK)) ||
                pMenu->cItems == cItem + (UINT)1) {

                /*
                 * Keep cMaxWidth around if this is not the last item.
                 */
                temp = cMaxWidth;
                if (pMenu->cItems == cItem + (UINT)1) {
                    if ((int)(pCurItem->cxItem) > cMaxWidth)
                        temp = pCurItem->cxItem;
                }

                /*
                 * Get new width of string from RecalcTabStrings.
                 */
                temp = MNRecalcTabStrings(hdc, pMenu, cItemBegCol,
                        (UINT)(cItem + (fMenuBreak ? 0 : 1)), temp, cxItem);

                /*
                 * If this item has a break, account for it.
                 */
                if (fMenuBreak) {
                    //
                    // Add on space for the etch and a border on either side.
                    // NOTE:  For old apps that do weird stuff with owner
                    // draw, keep 'em happy by adding on the same amount
                    // of space we did in 3.1.
                    //
                    if (fOwnerDrawItems && !TestWF(pwndNotify, WFWIN40COMPAT))
                        cxItem = temp + SYSMET(CXBORDER);
                    else
                        cxItem = temp + 2 * SYSMET(CXEDGE);

                    /*
                     * Reset the cMaxWidth to the current item.
                     */
                    cMaxWidth = pCurItem->cxItem;

                    /*
                     * Start at the top.
                     */
                    cyItem = yPopupTop;

                    /*
                     * Save the item where this column begins.
                     */
                    cItemBegCol = cItem;

                    /*
                     * If this item is also the last item, recalc for this
                     * column.
                     */
                    if (pMenu->cItems == (UINT)(cItem + 1)) {
                        temp = MNRecalcTabStrings(hdc, pMenu, cItem,
                                (UINT)(cItem + 1), cMaxWidth, cxItem);
                    }
                }

                /*
                 * If this is the last entry, supply the width.
                 */
                if (pMenu->cItems == cItem + (UINT)1)
                    pMenu->cxMenu = temp;
            }

            pCurItem->xItem = cxItem;
            pCurItem->yItem = cyItem;

            cyItem += pCurItem->cyItem;

            if (cyItemKeep < cyItem) {
                cyItemKeep = cyItem;
            }
        } else {
            /*
             * This a Top Level menu, not a Pull-Down.
             */

            /*
             * Adjust right aligned items before testing for multirow
             */
            if (pCurItem->lpstr != NULL) {
                lpsz = TextPointer(pCurItem->lpstr);
                if ((lpsz != NULL) && (*lpsz == CH_HELPPREFIX)) {
                    pCurItem->cxItem -= gcxMenuFontChar;
                }
            }


            /*
             * If this is a new line or a menu break.
             */
            if ((TestMFT(pCurItem, MFT_BREAK)) ||
                    (((cxItem + pCurItem->cxItem + gcxMenuFontChar) >
                    (xMenuLeft + pMenu->cxMenu)) && (cItem != 0))) {
                cyItem += cMaxHeight;

                cxItem = xMenuLeft;
                cMaxHeight = pCurItem->cyItem;
                pMenu->fFlags |= MFMULTIROW;
            }

            pCurItem->yItem = cyItem;

            pCurItem->xItem = cxItem;
            cxItem += pCurItem->cxItem;
        }

        if (cMaxWidth < (int)(pCurItem->cxItem)) {
            cMaxWidth = pCurItem->cxItem;
        }

        if (cMaxHeight != pCurItem->cyItem) {
            if (cMaxHeight < pCurItem->cyItem)
                cMaxHeight = pCurItem->cyItem;

            if (!fPopupMenu) {
                menuHeight = cMaxHeight;
            }
        }

        if (!fPopupMenu) {
            cyItemKeep = cyItem + cMaxHeight;
        }

        pCurItem++;
    }

    /*
     * Determine where the strings should be drawn so they are aligned.
     * The alignment is only for popup (vertical) menus (see
     * xxxRealDrawMenuItem). The actual space depends on the MNS_NOCHECK
     * and MNS_CHECKORBMP styles Multicolumn menus don't get aligment (now 
     * that we have scrollbars, multicolumn is out).
     */
    if (!fStringAndBitmapItems || (cItemBegCol != 0)) {
        pMenu->cxTextAlign = 0;
    } else if (TestMF(pMenu, MNS_NOCHECK)) {
        pMenu->cxTextAlign += MNXSPACE;
    } else if (TestMF(pMenu, MNS_CHECKORBMP)) {
        pMenu->cxTextAlign = max(pMenu->cxTextAlign, (UINT)gpsi->oembmi[OBI_MENUCHECK].cx);
        pMenu->cxTextAlign += MNXSPACE;
    } else {
        pMenu->cxTextAlign += gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE;
    }

    /*
     * Add the left margin
     */
    if (pMenu->cxTextAlign != 0) {
        pMenu->cxTextAlign += MNLEFTMARGIN;
    }


    if (cItemBegCol && pMenu->cItems &&
        TestMFT(((PITEM)&pMenu->rgItems[0]), MFT_RIGHTJUSTIFY)) {
        //
        // multi-column, if we are in RtoL mode, reverse the columns
        //
        pCurItem = &pMenu->rgItems[0];

        for (cItem = 0; cItem < pMenu->cItems; cItem++, pCurItem++) {
            pCurItem->xItem = pMenu->cxMenu -
                              (pCurItem->xItem + pCurItem->cxItem);
        }
    }

    GreSelectFont(hdc, hOldFont);
    _ReleaseDC(hdc);

    pMenu->cyMenu = cyItemKeep - yMenuTop;

    if (lpdwMenuHeight != NULL) {
        *lpdwMenuHeight = menuHeight;
    }

    return pMenu->cyMenu;
}

/***************************************************************************\
* MBC_RightJustifyMenu
*
* !
*
* History:
\***************************************************************************/
VOID MBC_RightJustifyMenu(
    PMENU pMenu)
{
    PITEM pItem;
    int cItem;
    int iFirstRJItem = MFMWFP_NOITEM;
    DWORD xMenuPos;
    DWORD  yPos;
    DWORD  xPosStart;
    DWORD  xPosEnd;
    int    cItemEnd;
    int    cItemStart;
    BOOL   bIsWin95;

    //
    // Need to compensate for MDI menus. Need to do all here as Win31/Hebrew did
    // this. Also messed up computation, anything non-text was not moved.
    //
    if (pMenu->cItems == 0) {
        return;
    }

    pItem = (PITEM)&pMenu->rgItems[0];
    cItemStart = 0;

    if (TestMF(pMenu,MFRTL)) {
        bIsWin95 = TestWF(pMenu->spwndNotify, WFWIN40COMPAT);

        while (cItemStart < (int)pMenu->cItems) {
            if (bIsWin95) {
                //
                // deal with fake MDI dude.
                //
                if (!cItemStart && IsMDIItem(pItem)) {
                    goto StillFindStart;
                } else {
                    break;
                }
            }

            if (TestMFT(pItem, MFT_BITMAP)) {
                if (pItem->hbmp > HBMMENU_MAX) {
                    break;
                } else {
                    goto StillFindStart;
                }
            }

            if (!TestMFT(pItem, MFT_OWNERDRAW)) {
                break;
            }

StillFindStart:
            cItemStart++;
            pItem = pMenu->rgItems + cItemStart;
        }

        //
        // Anything before cItems should be left where it is. Now need to find
        // the last item to fool with.
        //
        cItemEnd = pMenu->cItems - 1;
        pItem = pMenu->rgItems + cItemEnd;

        while (cItemEnd > cItemStart) {
            if (bIsWin95) {
                //
                // fake mdi dudes
                //
                if (IsMDIItem(pItem)) {
                    goto StillFindEnd;
                } else {
                    break;
                }
            }

            if (!TestMFT(pItem, MFT_BITMAP) && !TestMFT(pItem, MFT_OWNERDRAW)) {
                break;
            }
StillFindEnd:
            cItemEnd--;
            pItem = pMenu->rgItems + cItemEnd;
        }

        yPos      = pMenu->rgItems[0].yItem;
        xMenuPos  = pMenu->cxMenu ;
        xPosStart = xMenuPos;              // for 2nd row onward
        xPosEnd   = pMenu->rgItems[cItemStart].xItem ;

        for (cItem = pMenu->cItems-1; cItem > cItemEnd; cItem--) {
            //
            // Force any MDI dudes back to the top line again.
            //
            pItem        = pMenu->rgItems + cItem;
            xMenuPos     = pItem->xItem = xMenuPos - pItem->cxItem;
            pItem->yItem = yPos;
        }

        for (cItem = cItemStart; cItem <= cItemEnd; cItem++) {
            pItem = pMenu->rgItems + cItem;
            if (xMenuPos - pItem->cxItem > xPosEnd) {
                xMenuPos -= pItem->cxItem;
            } else {
                xMenuPos = xPosStart - pItem->cxItem;
                yPos     += pItem->cyItem;
                xPosEnd  = 0;
            }
            pItem->xItem = xMenuPos;
            pItem->yItem = yPos;
        }
    } else {
        // B#4055
        // Use signed arithmetic so comparison cItem >= iFirstRJItem won't
        // cause underflow.
        for (cItem = 0; cItem < (int)pMenu->cItems; cItem++) {
            // Find the first item which is right justified.
            if (TestMFT((pMenu->rgItems + cItem), MFT_RIGHTJUSTIFY)) {
                iFirstRJItem = cItem;
                xMenuPos = pMenu->cxMenu + pMenu->rgItems[0].xItem;
                for (cItem = (int)pMenu->cItems - 1; cItem >= iFirstRJItem; cItem--) {
                    pItem = pMenu->rgItems + cItem;
                    xMenuPos -= pItem->cxItem;
                    if (pItem->xItem < xMenuPos)
                        pItem->xItem = xMenuPos;
                }
                return;
            }
        }
    }
}

/***************************************************************************\
* xxxMenuBarCompute
*
* Returns the height of the menubar menu. yMenuTop, xMenuLeft, and
* cxMax are used when computing the height/width of top level menu bars in
* windows.
*
*
* History:
\***************************************************************************/
int xxxMenuBarCompute(
    PMENU pMenu,
    PWND pwndNotify,
    DWORD yMenuTop,
    DWORD xMenuLeft,
    int cxMax)
{
    int size;
    /* menuHeight is set by MNCompute when dealing with a top level menu and
     * not all items in the menu bar have the same height. Thus, by setting
     * menuHeight, MNCompute is called a second time to set every item to the
     * same height. The actual value stored in menuHeight is the maximum
     * height of all the menu bar items
     */
    DWORD menuHeight = 0;

    CheckLock(pwndNotify);
    CheckLock(pMenu);

    size = xxxMNCompute(pMenu, pwndNotify, yMenuTop, xMenuLeft, cxMax, &menuHeight);

    if (!TestMF(pMenu, MFISPOPUP)) {
        if (menuHeight != 0) {

            /*
             * Add a border for the multi-row case.
             */
            size = xxxMNCompute(pMenu, pwndNotify, yMenuTop, xMenuLeft,
                    cxMax, &menuHeight);
        }

        /*
         * Right justification of HELP items is only needed on top level
         * menus.
         */
        MBC_RightJustifyMenu(pMenu);
    }

    /*
     * There's an extra border underneath the menu bar, if it's not empty!
     */
    return(size ? size + SYSMET(CYBORDER) : size);
}

/***************************************************************************\
* xxxMNRecomputeBarIfNeeded
*
* !
*
* History:
\***************************************************************************/
VOID xxxMNRecomputeBarIfNeeded(
    PWND pwndNotify,
    PMENU pMenu)
{
    int cxFrame;
    int cyFrame;

    UserAssert(!TestMF(pMenu, MFISPOPUP));

    CheckLock(pwndNotify);
    CheckLock(pMenu);

    if (!TestMF(pMenu, MFSYSMENU)
        && ((pMenu->spwndNotify != pwndNotify) || !pMenu->cxMenu || !pMenu->cyMenu)) {
        int cBorders;

        cBorders = GetWindowBorders(pwndNotify->style, pwndNotify->ExStyle, TRUE, FALSE);
        cxFrame = cBorders * SYSMET(CXBORDER);
        cyFrame = cBorders * SYSMET(CYBORDER);

        cyFrame += GetCaptionHeight(pwndNotify);

        // The width passed in this call was larger by cxFrame;
        // Fix for Bug #11466 - Fixed by SANKAR - 01/06/92 --
        xxxMenuBarCompute(pMenu, pwndNotify, cyFrame, cxFrame,
                (pwndNotify->rcWindow.right - pwndNotify->rcWindow.left) - cxFrame * 2);
    }
}

/***************************************************************************\
* RecalcTabStrings
*
* !
*
* History:
*   10-11-90 JimA       Translated from ASM
\***************************************************************************/
DWORD MNRecalcTabStrings(
    HDC hdc,
    PMENU pMenu,
    UINT iBeg,
    UINT iEnd,
    DWORD xTab,
    DWORD hCount)
{
    UINT i;
    UINT    cOwnerDraw;
    int adx;
    int     maxWidth = 0;
    int     cx;
    PITEM pItem;
    CheckLock(pMenu);

    xTab += hCount;

    if ((iBeg >= pMenu->cItems) || (iBeg > iEnd))
        goto SeeYa;

    cOwnerDraw = 0;

    for (i = iBeg, pItem = pMenu->rgItems + iBeg; i < iEnd; pItem++, i++) {
        adx = 0;

        /*
         * Subtract hCount to make dxTab relative to start of column for
         * multi-column menus.
         */

        pItem->dxTab = xTab - hCount;

        // Skip non-string or empty string items
        if ((pItem->lpstr != NULL) && !TestMFT(pItem, MFT_OWNERDRAW)) {
            LPWSTR   lpString = TextPointer(pItem->lpstr);
            int     tp;
            SIZE size;

            // Are there any tabs?
            tp = FindCharPosition(lpString, TEXT('\t'));
            if (tp < (int) pItem->cch) {
                PTHREADINFO ptiCurrent = PtiCurrentShared();

                if (CALL_LPK(ptiCurrent)) {
                    xxxClientGetTextExtentPointW(hdc, lpString + tp + 1,
                          pItem->cch - tp - 1, &size);
                } else {
                    GreGetTextExtentW(hdc, lpString + tp + 1,
                          pItem->cch - tp - 1, &size, GGTE_WIN3_EXTENT);
                }
                adx = gcxMenuFontChar + size.cx;
            }
        } else if (TestMFT(pItem, MFT_OWNERDRAW))
            cOwnerDraw++;

        adx += xTab;

        if (adx > maxWidth)
            maxWidth = adx;

    }

    /*
     * Add on space for hierarchical arrow. So basically, popup menu items
     * can have 4 columns:
     *      (1) Checkmark
     *      (2) Text
     *      (3) Tabbed text for accel
     *      (4) Hierarchical arrow
     *
     * But, we only do this if at least one item isn't ownerdraw
     *  and if there's at least one submenu in the popup.
     */
    if (cOwnerDraw != (iEnd - iBeg)) {
        maxWidth += gcxMenuFontChar + gpsi->oembmi[OBI_MENUCHECK].cx;
    }

    cx = maxWidth - hCount;

    for (i = iBeg, pItem = pMenu->rgItems + iBeg; i < iEnd; pItem++, i++)
        pItem->cxItem = cx;

SeeYa:
    return(maxWidth);
}

/***************************************************************************\
* GetMenuPwnd
*
* This function is used by xxxGetMenuItemRect and xxxMenuItemFromPoint
* which expect a pointer to the menu window for popup menus.
*
* In 4.0, apps had to go the extra mile to find the menu window; but this
* is bogus since menu windows are an internally thing not directly exposed
* to applications.
*
* 08/19/97  GerardoB    Created
\***************************************************************************/
PWND GetMenuPwnd(
    PWND pwnd,
    PMENU pmenu)
{
    if (TestMF(pmenu, MFISPOPUP)) {
        if ((pwnd == NULL) || (GETFNID(pwnd) != FNID_MENU)) {
            PPOPUPMENU ppopup = MNGetPopupFromMenu(pmenu, NULL);
            if (ppopup != NULL) {
                UserAssert(ppopup->spmenu == pmenu);
                pwnd = ppopup->spwndPopupMenu;
            }
        }
    }

    return pwnd;
}

/***************************************************************************\
* GetMenuItemRect
\***************************************************************************/
BOOL xxxGetMenuItemRect(
    PWND pwnd,
    PMENU pMenu,
    UINT uIndex,
    LPRECT lprcScreen)
{
    PITEM  pItem;
    int    dx, dy;
    BOOL fRTL;

    CheckLock(pwnd);
    CheckLock(pMenu);

    SetRectEmpty(lprcScreen);

    if (uIndex >= pMenu->cItems) {
        return FALSE;
    }

    /*
     * Raid #315084: Compatiblity with NT4/Win95/98
     *
     * WordPerfect does a long complex way to calc the menu rect
     * by calling this API. It calls GetMenuItemRect() with the app's
     * window.
     */
    if (pwnd == NULL || TestWF(pwnd, WFWIN50COMPAT)) {
        pwnd = GetMenuPwnd(pwnd, pMenu);
    }

    /*
     * If no pwnd, no go.
     * IMPORTANT: For MFISPOPUP we might get a different pwnd but we don't lock
     * it because we won't call back.
     */
    if (pwnd == NULL) {
        return FALSE;
    }

    fRTL = TestWF(pwnd, WEFLAYOUTRTL);
    
    if (TestMF(pMenu, MFISPOPUP)) {
        if (fRTL) {
            dx = pwnd->rcClient.right;            
        } else {
            dx = pwnd->rcClient.left;
        }
        dy = pwnd->rcClient.top;
    } else {
        xxxMNRecomputeBarIfNeeded(pwnd, pMenu);
        if (fRTL) {
            dx = pwnd->rcWindow.right;
        } else {
            dx = pwnd->rcWindow.left;
        }
        dy = pwnd->rcWindow.top;
    }

    if (uIndex >= pMenu->cItems) {
        return FALSE;
    }

    pItem = pMenu->rgItems + uIndex;

    lprcScreen->right   = pItem->cxItem;
    lprcScreen->bottom  = pItem->cyItem;
 
    if (fRTL) {
        dx -= (pItem->cxItem + pItem->xItem);
    } else {
        dx += pItem->xItem;
    }
    dy += pItem->yItem;
    OffsetRect(lprcScreen, dx, dy);
  
    return TRUE;
}

/***************************************************************************\
* xxxMenuItemFromPoint
\***************************************************************************/
int xxxMenuItemFromPoint(
    PWND pwnd,
    PMENU pMenu,
    POINT ptScreen)
{
    CheckLock(pwnd);
    CheckLock(pMenu);

    /*
     * If no pwnd, no go.
     *
     * IMPORTANT: For MFISPOPUP we might get a different pwnd but we don't lock
     * it because we won't call back.
     */
    pwnd = GetMenuPwnd(pwnd, pMenu);
    if (pwnd == NULL) {
        return MFMWFP_NOITEM;
    }

    if (!TestMF(pMenu, MFISPOPUP)) {
        xxxMNRecomputeBarIfNeeded(pwnd, pMenu);
    }

    return MNItemHitTest(pMenu, pwnd, ptScreen);
}


PMENU MakeMenuRtoL(
    PMENU pMenu,
    BOOL bRtoL)
{
    PITEM  pItem;
    int    cItem;

    if (bRtoL) {
        SetMF(pMenu,MFRTL);
    } else {
        ClearMF(pMenu,MFRTL);
    }

    for (cItem = 0; cItem < (int)pMenu->cItems; cItem++) {
        pItem = pMenu->rgItems + cItem;
        if (bRtoL) {
            SetMFT(pItem, MFT_RIGHTJUSTIFY);
            SetMFT(pItem, MFT_RIGHTORDER);
        } else {
            ClearMFT(pItem, MFT_RIGHTJUSTIFY);
            ClearMFT(pItem, MFT_RIGHTORDER);
        }

        if (pItem->spSubMenu) {
            MakeMenuRtoL(pItem->spSubMenu, bRtoL);
        }
    }

    return pMenu;
}

/***************************************************************************\
* xxxCalcMenuBar
*
* 3/8/2000  vadimg      created
\***************************************************************************/
UINT xxxCalcMenuBar(
    PWND pwnd,
    int iLeftOffset,
    int iRightOffset,
    int iTopOffset,
    LPCRECT prcWnd)
{
    PMENU pMenu;
    UINT cyMenu, cxMenuMax;
    TL tlpMenu;

    CheckLock(pwnd);

    pMenu = pwnd->spmenu;

    if (TestwndChild(pwnd) || pMenu == NULL) {
        return 0;
    }

    ThreadLockMenuNoModify(pMenu, &tlpMenu);

    cxMenuMax = (prcWnd->right - iRightOffset) - (prcWnd->left + iLeftOffset);

    xxxMenuBarCompute(pMenu, pwnd, iTopOffset, iLeftOffset, cxMenuMax);

    cyMenu = pMenu->cyMenu;
    ThreadUnlockMenuNoModify(&tlpMenu);

    return cyMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mncreate.c ===
/****************************** Module Header ******************************\
*
* Module Name: mncreate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Creation routines for menus
*
* Public Functions:
*
* _CreateMenu()
* _CreatePopupMenu()
*
* History:
* 09-24-90 mikeke    from win30
* 02-11-91 JimA      Added access checks.
* 03-18-91 IanJa     Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* InternalCreateMenu
*
* Creates and returns a handle to an empty menu structure. Returns
* NULL if unsuccessful in allocating the memory.  If PtiCurrent() ==
* NULL, create an unowned menu, probably the system menu.
*
* History:
* 28-Sep-1990 mikeke     from win30
* 02-11-91 JimA         Added access checks.
\***************************************************************************/

PMENU InternalCreateMenu(
    BOOL fPopup)
{
    PMENU pmenu;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOP pdesk = NULL;

    /*
     * If the windowstation has been initialized, allocate from
     * the current desktop.
     */
    pdesk = ptiCurrent->rpdesk;
    /*
     * Just like in xxxCreateWindowEx, bypass the security check if hdesk is NULL
     * This allows CSR worker threads (ie harderror boxes) to do what they need to
     */
    if (ptiCurrent->hdesk != NULL) {
        RETURN_IF_ACCESS_DENIED(ptiCurrent->amdesk, DESKTOP_CREATEMENU, NULL);
    } else {
        UserAssert(ptiCurrent->TIF_flags & TIF_CSRSSTHREAD);
    }

    pmenu = HMAllocObject(ptiCurrent, pdesk, TYPE_MENU, sizeof(MENU));

    if (pmenu != NULL) {
        if (fPopup) {
            pmenu->fFlags = MFISPOPUP;
        }
    }
    return pmenu;
}


/***************************************************************************\
* CreateMenu
*
* Creates and returns a handle to an empty menu structure. Returns
* NULL if unsuccessful in allocating the memory.  If PtiCurrent() ==
* NULL, create an unowned menu, probably the system menu.
*
* History:
* 28-Sep-1990 mikeke     from win30
* 02-11-91 JimA         Added access checks.
\***************************************************************************/

PMENU _CreateMenu()
{
    return InternalCreateMenu(FALSE);
}


/***************************************************************************\
* CreatePopupMenu
*
* Creates and returns a handle to an empty POPUP menu structure. Returns
* NULL if unsuccessful in allocating the memory.
*
* History:
* 28-Sep-1990 mikeke     from win30
\***************************************************************************/

PMENU _CreatePopupMenu()
{
    return InternalCreateMenu(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mndstry.c ===
/**************************** Module Header ********************************\
* Module Name: mndstry.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Destruction Routines
*
* History:
* 10-10-90 JimA       Created.
* 02-11-91 JimA       Added access checks.
* 03-18-91 IanJa      Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DestroyMenu
*
* Destroy a menu and free its memory.
*
* History:
* 10-11-90 JimA         Translated from ASM.
* 02-11-91 JimA         Added access checks.
\***************************************************************************/

BOOL _DestroyMenu(
    PMENU pMenu)
{
    PITEM pItem;
    int i;
    PDESKTOP rpdeskLock;

    if (pMenu == NULL)
        return FALSE;

    /*
     * If the object is locked, just mark it for destroy and don't
     * free it yet.
     */
    if (!HMMarkObjectDestroy(pMenu))
        return TRUE;

    /*
     * Go down the item list and free the items
     */
    pItem = pMenu->rgItems;
    for (i = pMenu->cItems; i--; ++pItem)
        MNFreeItem(pMenu, pItem, TRUE);

    /*
     * free the menu items
     */
    if (pMenu->rgItems)
        DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);

    /*
     * Because menus are the only objects on the desktop owned
     * by the process and process cleanup is done after thread
     * cleanup, this may be the last reference to the desktop.
     * We must lock the desktop before unlocking
     * the parent desktop reference and freeing the menu to
     * ensure that the desktop will not be freed until after
     * the menu is freed.  Don't use static locks because
     * the pti for this thread will not be valid during
     * process cleanup.
     */
    rpdeskLock = NULL;
    LockDesktop(&rpdeskLock, pMenu->head.rpdesk, LDL_FN_DESTROYMENU, (ULONG_PTR)PtiCurrent());

    /*
     * Unlock all menu objects.
     */
    Unlock(&pMenu->spwndNotify);

    HMFreeObject(pMenu);

    UnlockDesktop(&rpdeskLock, LDU_FN_DESTROYMENU, (ULONG_PTR)PtiCurrent());

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnkey.c ===
/**************************** Module Header ********************************\
* Module Name: mnkey.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Keyboard Handling Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

int xxxClientFindMnemChar(
    PUNICODE_STRING pstrSrc,
    WCHAR ch,
    BOOL fFirst,
    BOOL fPrefix);

/* MenuSwitch commands */
#define CMDSWITCH   1
#define CMDQUERY    2

/***************************************************************************\
* FindNextValidMenuItem
*
* !
*
* History:
\***************************************************************************/

UINT MNFindNextValidItem(
    PMENU pMenu,
    int i,
    int dir,
    UINT flags)
{
    int iStart;
    BOOL cont = TRUE;
    int cItems = pMenu->cItems;
    PITEM pItem;

    if ((i < 0) && (dir > 0))
        // going forward from beginning -- stop after last menu item
        i = iStart = cItems;
    else if ((i >= cItems) && (dir < 0))
        // going backward from end -- stop after first menu item
        i = iStart = -1;
    else
        iStart = i;

    if (!cItems)
        return(MFMWFP_NOITEM);

    // b#8997 - if we have these conditions and enter
    // loop will go blistic ( infin )
    // fix: jump over code and come loop to i == iStart will now stop us
    if ( ( i == 0 ) && ( cItems == 1 ) && ( dir > 0 ) )
    {
        dir = 0;
        goto artsquickndirtybugfix;
    }

    //
    // Loop thru menu items til (1) we find a valid item
    //                       or (2) we make it back to the start item (iStart)
    while (TRUE) {
        i += dir;

        if ((i == iStart) || (dir == 0))
            // we made it back to start item -- return NOT FOUND
            return MFMWFP_NOITEM;

        // keep 'i' in the range: 0 <= i < cItems
        if (i >= cItems) {
            i = -1;
            continue;
        }
        else if (i < 0) {
            i = cItems;
            continue;
        }

artsquickndirtybugfix:
        pItem = pMenu->rgItems + i;

        // skip ownerdraw - seperators even though there not NULL
        if (TestMFT(pItem, MFT_SEPARATOR)) {
            //
            // Skip non-separator (if asked) empty items.  With hot-tracking,
            // it is acceptable for them to be selected.  In truth, it was possible
            // in Win3.1 too, but less likely.
            //
            if (!(flags & MNF_DONTSKIPSEPARATORS)) {
                continue;
            }
        } else if ((pItem->hbmp >= HBMMENU_MBARFIRST) && (pItem->hbmp <= HBMMENU_MBARLAST)) {
            /*
             * Skip close & minimize & restore buttons
             */
            continue;
        }

        // return index of found item
        return(i);
    }

    //
    // We should never get here!
    //
    UserAssert(FALSE);
}

/***************************************************************************\
* MKF_FindMenuItemInColumn
*
* Finds closest item in the pull-down menu's next "column".
*
* History:
\***************************************************************************/

UINT MNFindItemInColumn(
    PMENU pMenu,
    UINT idxB,
    int dir,
    BOOL fRoot)
{
    int dxMin;
    int dyMin;
    int dxMax;
    int dyMax;
    int xB;
    int yB;
    UINT idxE;
    UINT idxR;
    UINT cItems;
    PITEM pItem;

    cItems = pMenu->cItems;
    idxR = MFMWFP_NOITEM;
    idxE = MNFindNextValidItem(pMenu, MFMWFP_NOITEM, dir, 0);
    if (idxE == -1)
        goto End;

    dxMin = dyMin = 20000;

    if (idxB >= pMenu->cItems)
        return idxR;

    pItem = &pMenu->rgItems[idxB];
    xB = pItem->xItem;
    yB = pItem->yItem;

    while (cItems-- > 0 &&
            (idxB = MNFindNextValidItem(pMenu, idxB, dir, 0)) != idxE &&
            (idxB != MFMWFP_NOITEM)) {
        pItem = &pMenu->rgItems[idxB];
        dxMax = xB - pItem->xItem;
        dyMax = yB - pItem->yItem;

        if (dxMax < 0)
            dxMax = (-dxMax);
        if (dyMax < 0)
            dyMax = (-dyMax);

        // See if this item is nearer than the last item found
        // --------------------------------------------------------
        // (fRoot || dxMax) -- this condition means that if it's
        // not the actual menu bar menu that we're dealing with,
        // then the item below/above (same X value as) the selected
        // item is not a valid one to move to
        if ((dyMax < dyMin) && (fRoot || dxMax) && dxMax <= dxMin) {
            dxMin = dxMax;
            dyMin = dyMax;
            idxR = idxB;
        }
    }

End:
    return idxR;
}

/***************************************************************************\
* MKF_FindMenuChar
*
* Translates Virtual cursor key movements into pseudo-ascii values.  Maps a
* character to an item number.
*
* History:
\***************************************************************************/

UINT xxxMNFindChar(
    PMENU pMenu,
    UINT ch,
    int idxC,
    LPINT lpr)       /* Put match type here */
{
    int idxFirst = MFMWFP_NOITEM;
    int idxB;
    int idxF;
    int rT;
    LPWSTR lpstr;
    PITEM pItem;

    if (ch == 0)
        return 0;

    /*
     * First time thru go for the very first menu.
     */
    idxF = MFMWFP_NOITEM;
    rT = 0;
    idxB = idxC;

    if (idxB < 0)
//    if (idxB & 0x8000)
        idxB = MNFindNextValidItem(pMenu, pMenu->cItems, MFMWFP_NOITEM, MNF_DONTSKIPSEPARATORS);

    do {
        INT idxPrev;

        idxPrev = idxC;
        idxC = MNFindNextValidItem(pMenu, idxC, 1, MNF_DONTSKIPSEPARATORS);
        if (idxC == MFMWFP_NOITEM || idxC == idxFirst)
            break;
        if (idxFirst == MFMWFP_NOITEM)
            idxFirst = idxC;

        pItem = &pMenu->rgItems[idxC];

        if (pItem->lpstr != NULL) {
            if (pItem->cch != 0) {
                UNICODE_STRING strMnem;

                lpstr = TextPointer(pItem->lpstr);
                if (*lpstr == CH_HELPPREFIX) {

                    /*
                     * Skip help prefix if it is there so that we can mnemonic
                     * to the first character of a right justified string.
                     */
                    lpstr++;
                }

                RtlInitUnicodeString(&strMnem, lpstr);
                if (((rT = (UINT)xxxClientFindMnemChar(&strMnem,
                        (WCHAR)ch, TRUE, TRUE)) == 0x0080) &&
                        (idxF == MFMWFP_NOITEM))
                    idxF = idxC;
            }
        }
        if (idxC == idxPrev) {
            break;  // no progress - break inf. loop
        }
    } while (rT != 1 && idxB != idxC);

    *lpr = rT;

    if (rT == 1)
        return idxC;

    return idxF;
}


/***************************************************************************\
* xxxMenuKeyFilter
*
* !
*
* Revalidation notes:
* o Routine assumes it is called with pMenuState->hwndMenu non-NULL and valid.
* o If one or more of the popup menu windows is unexpectedly destroyed, this is
*   detected in xxxMenuWndProc(), which sets pMenuState->fSabotaged and calls
*   xxxKillMenuState().  Therefore, if we return from an xxxRoutine with
*   pMenuState->fSabotaged set, we must abort immediately.
* o If pMenuState->hwndMenu is unexpectedly destroyed, we abort only if we
*   need to use the corresponding pwndMenu.
* o pMenuState->hwndMenu may be supplied as a parameter to various routines
*   (eg:  xxxNextItem), whether valid or not.
* o Any label preceded with xxx (eg: xxxMKF_UnlockAndExit) may be reached with
*   pMenuState->hwndMenu invalid.
* o If this routine is not called while in xxxMenuLoop(), then it must
*   clear pMenuState->fSabotaged before returning.
*
* History:
\***************************************************************************/

void xxxMNKeyFilter(
    PPOPUPMENU ppopupMenu,
    PMENUSTATE pMenuState,
    UINT ch)
{
    BOOL fLocalInsideMenuLoop = pMenuState->fInsideMenuLoop;

    if (pMenuState->fButtonDown) {

        /*
         * Ignore keystrokes while the mouse is pressed (except ESC).
         */
        return;
    }

    if (!pMenuState->fInsideMenuLoop) {

        /*
         * Need to send the WM_INITMENU message before we pull down the menu.
         */
        if (!xxxMNStartMenu(ppopupMenu, KEYBDHOLD)) {
            return;
        }
        pMenuState->fInsideMenuLoop = TRUE;
    }


    switch (ch) {
    case 0:

        /*
         * If we get a WM_KEYDOWN alt key and then a KEYUP alt key, we need to
         * activate the first item on the menu.  ie.  user hits and releases alt
         * key so just select first item.  USER sends us a SC_KEYMENU with
         * lParam 0 when the user does this.
         */
        xxxMNSelectItem(ppopupMenu, pMenuState, 0);
        break;

    case MENUCHILDSYSMENU:
        if (!TestwndChild(ppopupMenu->spwndNotify)) {

            /*
             * Change made to fix MDI problem: child window gets a keymenu,
             * and pops up sysmenu of frame when maximized.  Need to act like
             * MENUCHAR if hwndMenu is a top-level.
             */
            goto MenuCharHandler;
        }

        /*
         * else fall through.
         */

    case MENUSYSMENU:
        if (!TestWF(ppopupMenu->spwndNotify, WFSYSMENU)) {
            xxxMessageBeep(0);
            goto MenuCancel;
        }

        /*
         * Popup any hierarchies we have.
         */
        xxxMNCloseHierarchy(ppopupMenu, pMenuState);
        if (!ppopupMenu->fIsSysMenu && ppopupMenu->spmenuAlternate)
            xxxMNSwitchToAlternateMenu(ppopupMenu);
        if (!ppopupMenu->fIsSysMenu) {
            /*
             * If no system menu, get out.
             */
            goto MenuCancel;
        }

        MNPositionSysMenu(ppopupMenu->spwndPopupMenu, ppopupMenu->spmenu);
        xxxMNSelectItem(ppopupMenu, pMenuState, 0);
        xxxMNOpenHierarchy(ppopupMenu, pMenuState);
        ppopupMenu->fToggle = FALSE;
        break;


    default:

        /*
         * Handle ALT-Character sequences for items on top level menu bar.
         * Note that fInsideMenuLoop may be set to false on return from this
         * function if the app decides to return 1 to the WM_MENUCHAR message.
         * We detect this and not enter MenuLoop if fInsideMenuLoop is reset
         * to false.
         */
MenuCharHandler:
        xxxMNChar(ppopupMenu, pMenuState, ch);
        if (ppopupMenu->posSelectedItem == MFMWFP_NOITEM) {
            /*
             * No selection found.
             */
            goto MenuCancel;
        }
        break;
    }

    if (!fLocalInsideMenuLoop && pMenuState->fInsideMenuLoop) {
        xxxMNLoop(ppopupMenu, pMenuState, 0, FALSE);
    }

    return;


MenuCancel:
    pMenuState->fModelessMenu = FALSE;
    if (!ppopupMenu->fInCancel) {
        xxxMNDismiss(pMenuState);
    }
    UserAssert(!pMenuState->fInsideMenuLoop && !pMenuState->fMenuStarted);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mngray.c ===
/**************************** Module Header ********************************\
* Module Name: mngray.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server-side version of DrawState.
*
* History:
* 06-Jan-1993 FritzS    Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
 *
 * CreateCompatiblePublicDC
 *
 * This is used in several callback routines to the lpk(s).  We can't
 * pass G_TERM(pDispInfo)->hdcGray, HDCBITS() or gfade.hdc to the client since
 * they are public DCs.
 * We can't just change the owner since we're about to leave the
 * critical section.  Some other thread may enter before we return
 * and use hdcGray, HDCBITS() or gfade.hdc. Instead, we create a compatible
 * dc with the same font and bitmap that are currently selected in hdcGray, 
 * HDCBITS() or gfade.hdc).  Pass that to the client lpk.
 *
 * If the function returns successfully , then the dc and bitmap object are
 * guaranteed to be successfully created.
 *
 * History:
 *
 * Dec-16-1997  Samer Arafeh  [samera]
 * Jan-20-1998  Samer Arafeh  [samera] Add support for both hdcGray and HDCBITS()
 * May-05-2000  MHamid                 Add support for gfade.hdc
 *
\***************************************************************************/
HDC CreateCompatiblePublicDC(
    HDC      hdcPublic,
    HBITMAP *pbmPublicDC)
{
    HDC     hdcCompatible = 0;
    HBITMAP hbmCompatible, hbm = NULL;
    BITMAP  bmBits;
    HFONT   hFont;

    /*
     * If it is not public DC just return it.
     */
    if(GreGetObjectOwner((HOBJ)hdcPublic, DC_TYPE) != OBJECT_OWNER_PUBLIC) {
        return hdcPublic;
    }

    if ((hdcCompatible = GreCreateCompatibleDC(hdcPublic)) == NULL) {
        RIPMSG1(RIP_WARNING, "CreateCompatiblePublicDC: GreCreateCompatibleDC Failed %lX", hdcPublic);
        return (HDC)NULL;
    }

    if (!GreSetDCOwner(hdcCompatible, OBJECT_OWNER_CURRENT)) {
        RIPMSG1(RIP_WARNING, "CreateCompatiblePublicDC: SetDCOwner Failed %lX", hdcCompatible);
        GreDeleteDC(hdcCompatible);
        return (HDC)NULL;
    }

    hbm = NtGdiGetDCObject(hdcPublic, LO_BITMAP_TYPE);

    GreExtGetObjectW(hbm, sizeof(BITMAP), &bmBits);

    hbmCompatible = GreCreateCompatibleBitmap(hdcPublic,
                                              bmBits.bmWidth,
                                              bmBits.bmHeight);

    //
    // Check whether bitmap couldn't be created or can't
    // be set to OBJECT_OWNER_CURRENT, then fail and
    // do necessary cleanup now!
    //

    if( (hbmCompatible == NULL) ||
        (!GreSetBitmapOwner(hbmCompatible, OBJECT_OWNER_CURRENT)) ) {

        RIPMSG1(RIP_WARNING, "CreateCompatiblePublicDC: GreCreateCompatibleBitmap Failed %lX", hbmCompatible);
        GreDeleteDC( hdcCompatible );

        if( hbmCompatible ) {
            GreDeleteObject( hbmCompatible );
        }

        return (HDC)NULL;
    }

    GreSelectBitmap(hdcCompatible, hbmCompatible);
    /*
     * Make sure we use the same font and text alignment.
     */
    hFont = GreSelectFont(hdcPublic, ghFontSys);
    GreSelectFont(hdcPublic, hFont);
    GreSelectFont(hdcCompatible, hFont);
    GreSetTextAlign(hdcCompatible, GreGetTextAlign(hdcPublic));
    /*
     * Copy any information already written into G_TERM(pDispInfo)->hdcGray.
     */

    //
    // Mirror the created DC if the hdcGray is currently mirrored,
    // so that TextOut won't get mirrored on User Client DCs
    //
    if (GreGetLayout(hdcPublic) & LAYOUT_RTL) {
        GreSetLayout(hdcCompatible, bmBits.bmWidth - 1, LAYOUT_RTL);
    }
    GreBitBlt(hdcCompatible, 0, 0, bmBits.bmWidth, bmBits.bmHeight, hdcPublic, 0, 0, SRCCOPY, 0);

    *pbmPublicDC = hbmCompatible ;      // for later deletion, by the server side

    return hdcCompatible;
}



/***************************************************************************\
*
*  xxxDrawState()
*
*  Generic state drawing routine.  Does simple drawing into same DC if
*  normal state;  uses offscreen bitmap otherwise.
*
*  We do drawing for these simple types ourselves:
*      (1) Text
*          lData is string pointer.
*          wData is string length
*      (2) Icon
*          LOWORD(lData) is hIcon
*      (3) Bitmap
*          LOWORD(lData) is hBitmap
*      (4) Glyph (internal)
*          LOWORD(lData) is OBI_ value, one of
*              OBI_CHECKMARK
*              OBI_BULLET
*              OBI_MENUARROW
*          right now
*
*  Other types are required to draw via the callback function, and are
*  allowed to stick whatever they want in lData and wData.
*
*  We apply the following effects onto the image:
*      (1) Normal      (nothing)
*      (2) Default     (drop shadow)
*      (3) Union       (gray string dither)
*      (4) Disabled    (embossed)
*
*  Note that we do NOT stretch anything.  We just clip.
*
\***************************************************************************/
BOOL xxxDrawState(
    HDC           hdcDraw,
    HBRUSH        hbrFore,
    LPARAM        lData,
    int           x,
    int           y,
    int           cx,
    int           cy,
    UINT          uFlags)
{
    HFONT   hFont;
    HFONT   hFontSave = NULL;
    HDC     hdcT;
    HBITMAP hbmpT;
    POINT   ptOrg;
    BOOL    fResult;
    int     oldAlign;
    DWORD   dwOldLayout=0;

    /*
     * These require monochrome conversion
     *
     * Enforce monochrome: embossed doesn't look great with 2 color displays
     */
    if ((uFlags & DSS_DISABLED) &&
        ((gpsi->BitCount == 1) || SYSMET(SLOWMACHINE))) {

        uFlags &= ~DSS_DISABLED;
        uFlags |= DSS_UNION;
    }

    if (uFlags & (DSS_INACTIVE | DSS_DISABLED | DSS_DEFAULT | DSS_UNION))
        uFlags |= DSS_MONO;

    /*
     * Validate flags - we only support DST_COMPLEX in kernel
     */
    if ((uFlags & DST_TYPEMASK) != DST_COMPLEX) {
        RIPMSG1(RIP_ERROR, "xxxDrawState: invalid DST_ type %x", (uFlags & DST_TYPEMASK));
        return FALSE;
    }

    /*
     * Optimize:  nothing to draw
     */
    if (!cx || !cy) {
        return TRUE;
    }

    /*
     * Setup drawing dc
     */
    if (uFlags & DSS_MONO) {

        hdcT = gpDispInfo->hdcGray;
        /*
         * First turn off mirroring on hdcGray if any.
         */
        GreSetLayout(hdcT, -1, 0);
        /*
         * Set the hdcGray layout to be equal to the screen hdcDraw layout.
         */
        dwOldLayout = GreGetLayout(hdcDraw);
        if (dwOldLayout != GDI_ERROR) {
            GreSetLayout(hdcT, cx, dwOldLayout);
        }

        /*
         * Is our scratch bitmap big enough?  We need potentially
         * cx+1 by cy pixels for default etc.
         */
        if ((gpDispInfo->cxGray < cx + 1) || (gpDispInfo->cyGray < cy)) {

            if (hbmpT = GreCreateBitmap(max(gpDispInfo->cxGray, cx + 1), max(gpDispInfo->cyGray, cy), 1, 1, 0L)) {

                HBITMAP hbmGray;

                hbmGray = GreSelectBitmap(gpDispInfo->hdcGray, hbmpT);
                GreDeleteObject(hbmGray);

                GreSetBitmapOwner(hbmpT, OBJECT_OWNER_PUBLIC);

                gpDispInfo->cxGray = max(gpDispInfo->cxGray, cx + 1);
                gpDispInfo->cyGray = max(gpDispInfo->cyGray, cy);

            } else {
                cx = gpDispInfo->cxGray - 1;
                cy = gpDispInfo->cyGray;
            }
        }

        GrePatBlt(gpDispInfo->hdcGray,
                  0,
                  0,
                  gpDispInfo->cxGray,
                  gpDispInfo->cyGray,
                  WHITENESS);

        GreSetTextCharacterExtra(gpDispInfo->hdcGray,
                                 GreGetTextCharacterExtra(hdcDraw));

        oldAlign = GreGetTextAlign(hdcT);
        GreSetTextAlign(hdcT, (oldAlign & ~(TA_RTLREADING |TA_CENTER |TA_RIGHT))
                     | (GreGetTextAlign(hdcDraw) & (TA_RTLREADING |TA_CENTER |TA_RIGHT)));
        /*
         * Setup font
         */
        if (GreGetHFONT(hdcDraw) != ghFontSys) {
            hFont = GreSelectFont(hdcDraw, ghFontSys);
            GreSelectFont(hdcDraw, hFont);
            hFontSave = GreSelectFont(gpDispInfo->hdcGray, hFont);
        }
    } else {
        hdcT = hdcDraw;
        /*
         * Adjust viewport
         */
        GreGetViewportOrg(hdcT, &ptOrg);
        GreSetViewportOrg(hdcT, ptOrg.x+x, ptOrg.y+y, NULL);

    }

    /*
     * Now, draw original image
     */
    fResult = xxxRealDrawMenuItem(hdcT, (PGRAYMENU)lData, cx, cy);

    /*
     * The callbacks could have altered the attributes of hdcGray
     */
    if (hdcT == gpDispInfo->hdcGray) {
        GreSetBkColor(gpDispInfo->hdcGray, RGB(255, 255, 255));
        GreSetTextColor(gpDispInfo->hdcGray, RGB(0, 0, 0));
        GreSelectBrush(gpDispInfo->hdcGray, ghbrBlack);
        GreSetBkMode(gpDispInfo->hdcGray, OPAQUE);
    }

    /*
     * Clean up
     */
    if (uFlags & DSS_MONO) {

        /*
         * Reset font
         */
        if (hFontSave)
            GreSelectFont(hdcT, hFontSave);
        GreSetTextAlign(hdcT, oldAlign);
    } else {
        /*
         * Reset DC.
         */
        GreSetViewportOrg(hdcT, ptOrg.x, ptOrg.y, NULL);
        return TRUE;
    }

    /*
     * UNION state
     * Dither over image
     * We want white pixels to stay white, in either dest or pattern.
     */
    if (uFlags & DSS_UNION) {

         POLYPATBLT PolyData;

         PolyData.x         = 0;
         PolyData.y         = 0;
         PolyData.cx        = cx;
         PolyData.cy        = cy;
         PolyData.BrClr.hbr = gpsi->hbrGray;

         GrePolyPatBlt(gpDispInfo->hdcGray, PATOR, &PolyData, 1, PPB_BRUSH);
    }

    if (uFlags & DSS_INACTIVE) {

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else if (uFlags & DSS_DISABLED) {

        /*
         * Emboss
         * Draw over-1/down-1 in hilight color, and in same position in shadow.
         */

        BltColor(hdcDraw,
                 SYSHBR(3DHILIGHT),
                 gpDispInfo->hdcGray,
                 x+1,
                 y+1,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else if (uFlags & DSS_DEFAULT) {

        BltColor(hdcDraw,
                 hbrFore,
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        BltColor(hdcDraw,
                 hbrFore,
                 gpDispInfo->hdcGray,
                 x+1,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else {

        BltColor(hdcDraw,
                 hbrFore,
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);
    }


    if ((uFlags & DSS_MONO)){
        /*
         * Set the hdcGray layout to 0, it is a public DC.
         */
       GreSetLayout(hdcT, -1, 0);
    }
    return fResult;
}

/***************************************************************************\
* BltColor
*
* <brief description>
*
* History:
* 13-Nov-1990 JimA      Ported from Win3.
\***************************************************************************/

VOID BltColor(
    HDC    hdc,
    HBRUSH hbr,
    HDC    hdcSrce,
    int    xO,
    int    yO,
    int    cx,
    int    cy,
    int    xO1,
    int    yO1,
    UINT   uBltFlags)
{
    HBRUSH hbrSave;
    DWORD  textColorSave;
    DWORD  bkColorSave;
    DWORD  ROP;

    /*
     * Set the Text and Background colors so that bltColor handles the
     * background of buttons (and other bitmaps) properly.
     * Save the HDC's old Text and Background colors.  This causes problems
     * with Omega (and probably other apps) when calling GrayString which
     * uses this routine...
     */
    textColorSave = GreSetTextColor(hdc, 0x00000000L);
    bkColorSave = GreSetBkColor(hdc, 0x00FFFFFFL);

    if (hbr != NULL)
        hbrSave = GreSelectBrush(hdc, hbr);
    if (uBltFlags & BC_INVERT)
        ROP = 0xB8074AL;
    else
        ROP = 0xE20746L;

    if (uBltFlags & BC_NOMIRROR)
        ROP |= NOMIRRORBITMAP;

    GreBitBlt(hdc,
              xO,
              yO,
              cx,
              cy,
              hdcSrce ? hdcSrce : gpDispInfo->hdcGray,
              xO1,
              yO1,
              ROP,
              0x00FFFFFF);

    if (hbr != NULL)
        GreSelectBrush(hdc, hbrSave);

    /*
     * Restore saved colors
     */
    GreSetTextColor(hdc, textColorSave);
    GreSetBkColor(hdc, bkColorSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mndraw.c ===
/**************************** Module Header ********************************\
* Module Name: mndraw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Painting Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define SRCSTENCIL          0x00B8074AL
#define MENU_STRLEN 255

/***************************************************************************\
* MNIsCachedBmpOnly
*
* 04/02/97 GerardoB Created
\***************************************************************************/
__inline BOOL MNIsCachedBmpOnly(
    PITEM pItem)
{
    return TestMFS(pItem, MFS_CACHEDBMP) && (pItem->lpstr == NULL);
}


/***************************************************************************\
* MNDrawHilite
*
* Don't draw the hilite if:
*   The insertion bar is on (MFS_GAPDROP)
*   or this is a cached bitmap (close, min, max, etc) with no text
*
* 08/12/96 GerardoB Ported From Memphis.
\***************************************************************************/
BOOL MNDrawHilite(
    PITEM pItem)
{
    return TestMFS(pItem, MFS_HILITE)
            && !TestMFS(pItem, MFS_GAPDROP)
            && !MNIsCachedBmpOnly(pItem);
}


/***************************************************************************\
* MNDrawMenu3DHotTracking
*
* 03/10/97  yutakas  created
* 04/07/97  vadimg   ported from Memphis
\***************************************************************************/
VOID MNDrawMenu3DHotTracking(
    HDC hdc,
    PMENU pMenu,
    PITEM pItem)
{
    HBRUSH hbrTopLeft, hbrBottomRight;
    BOOL fDrawEdge;

    UserAssertMsg0(!MNIsFlatMenu(), "3D Hot Tracking not valid for flat menus");

    if (pItem->hbmp && TestMFS(pItem, MFS_CACHEDBMP)) {
        return;
    }

    fDrawEdge = FALSE;

    if (!TestMF(pMenu, MFISPOPUP)) {
        if (TestMFS(pItem, MFS_HILITE)) {
            hbrTopLeft = SYSHBR(3DSHADOW);
            hbrBottomRight = SYSHBR(3DHILIGHT);
            SetMFS(pItem, MFS_HOTTRACKDRAWN);
            fDrawEdge = TRUE;
        } else if (TestMFS(pItem, MFS_HOTTRACK)) {
            hbrTopLeft = SYSHBR(3DHILIGHT);
            hbrBottomRight = SYSHBR(3DSHADOW);
            SetMFS(pItem, MFS_HOTTRACKDRAWN);
            fDrawEdge = TRUE;
        } else if (TestMFS(pItem, MFS_HOTTRACKDRAWN)) {
            if (pMenu->hbrBack == NULL) {
                hbrTopLeft = SYSHBR(MENU);
                hbrBottomRight = SYSHBR(MENU);
            } else {
                hbrTopLeft = pMenu->hbrBack;
                hbrBottomRight = pMenu->hbrBack;
            }

            ClearMFS(pItem, MFS_HOTTRACKDRAWN);
            fDrawEdge = TRUE;
        }
    }
    if (fDrawEdge) {
        int x = pItem->xItem, y = pItem->yItem;
        int cx = pItem->cxItem, cy = pItem->cyItem;
        HBRUSH hbrOld = GreSelectBrush(hdc, hbrTopLeft);
        GrePatBlt(hdc, x, y, cx - CXMENU3DEDGE, CYMENU3DEDGE, PATCOPY);
        GrePatBlt(hdc, x, y, CXMENU3DEDGE, cy - CYMENU3DEDGE, PATCOPY);
        GreSelectBrush(hdc, hbrBottomRight);
        GrePatBlt(hdc, x, y + cy - CYMENU3DEDGE, cx - CXMENU3DEDGE, CYMENU3DEDGE, PATCOPY);
        GrePatBlt(hdc, x + cx - CYMENU3DEDGE, y, CXMENU3DEDGE, cy, PATCOPY);
        GreSelectBrush(hdc, hbrOld);
    }
}


/***************************************************************************\
* MNDrawArrow
*
* Redraws the specified arrow (uArrow) in a scrollable menu (ppopup) to reflect
* its current state of enabled or disabled, drawing it in HOTLIGHT if fOn is
* TRUE.
*
* 08/12/96 GerardoB Ported From Memphis.
\***************************************************************************/
VOID MNDrawArrow(
    HDC hdcIn,
    PPOPUPMENU ppopup,
    UINT uArrow)
{
    PWND    pwnd = ppopup->spwndPopupMenu;
    HDC     hdc;
    int     x, y;
    DWORD   dwBmp;
    DWORD   dwAtCheck;
    DWORD   dwState;

    if (ppopup->spmenu->dwArrowsOn == MSA_OFF) {
        return;
    }

    if (hdcIn == NULL) {
        hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE);
    } else {
        hdc = hdcIn;
    }

    x = SYSMET(CXFIXEDFRAME);
    if (!TestMF(ppopup->spmenu, MNS_NOCHECK)) {
       /*
        * Win9x:  x += MNByteAlignItem(oemInfo.bm[OBI_MENUCHECK].cx);
        */
        x += gpsi->oembmi[OBI_MENUCHECK].cx;
    } else {
        x += SYSMET(CXEDGE) * 2;
    }

    if (uArrow == MFMWFP_UPARROW) {
        y = SYSMET(CXFIXEDFRAME);
        dwBmp = OBI_MENUARROWUP;
        dwAtCheck = MSA_ATTOP;
        dwState = DFCS_MENUARROWUP;
    } else {
        y = pwnd->rcWindow.bottom - pwnd->rcWindow.top - SYSMET(CYFIXEDFRAME) - gcyMenuScrollArrow;
        dwBmp = OBI_MENUARROWDOWN;
        dwAtCheck = MSA_ATBOTTOM;
        dwState = DFCS_MENUARROWDOWN;
    }

    if (ppopup->spmenu->dwArrowsOn == dwAtCheck) {
        /*
         * go 2 ahead to inactive state bitmap
         */
        dwBmp += 2;
        dwState |= DFCS_INACTIVE;
    }

    if (ppopup->spmenu->hbrBack != NULL) {
        /*
         * For menus with background brushes, we can't do a straight blt
         * of the scroll arrows 'cause the background wouldn't be right;
         * need to call DrawFrameControl with DFCS_TRANSPARENT instead.
         */
        RECT rc;
        rc.top = y;
        rc.left = x;
        rc.right  = x + gpsi->oembmi[OBI_MENUARROWUP].cx;
        rc.bottom = y + gpsi->oembmi[OBI_MENUARROWUP].cy;
        DrawFrameControl(hdc, &rc, DFC_MENU, dwState | DFCS_TRANSPARENT);
    } else {
        BitBltSysBmp(hdc, x, y, dwBmp);
        BitBltSysBmp(hdc, x, y, dwBmp);
    }

    if (hdcIn == NULL) {
        _ReleaseDC(hdc);
    }
}


/***************************************************************************\
* DrawOutline
*
* Draws an outline of a specified thickness using a given brush.
*
* History:
*  03-03-00 JStall - Created
\***************************************************************************/
VOID DrawOutline(
    HDC hdc,
    int x, 
    int y,
    int w,
    int h,
    int nThick,
    HBRUSH hbrFill)
{
    POLYPATBLT rgPPB[4];

    /* Left */
    rgPPB[0].x         = x;
    rgPPB[0].y         = y;
    rgPPB[0].cx        = nThick;
    rgPPB[0].cy        = h;
    rgPPB[0].BrClr.hbr = hbrFill;

    /* Top */
    rgPPB[1].x         = x;
    rgPPB[1].y         = y;
    rgPPB[1].cx        = w;
    rgPPB[1].cy        = nThick;
    rgPPB[1].BrClr.hbr = hbrFill;

    /* Right */
    rgPPB[2].x         = x + w - nThick;
    rgPPB[2].y         = y;
    rgPPB[2].cx        = nThick;
    rgPPB[2].cy        = h;
    rgPPB[2].BrClr.hbr = hbrFill;

    /* Bottom */
    rgPPB[3].x         = x;
    rgPPB[3].y         = y + h - nThick;
    rgPPB[3].cx        = w;
    rgPPB[3].cy        = nThick;
    rgPPB[3].BrClr.hbr = hbrFill;

    GrePolyPatBlt(hdc, PATCOPY, rgPPB, 4, PPB_BRUSH);
}


/***************************************************************************\
* MNDrawEdge
*
* Draws the edge of the menu for flat-menus.  The given rectangle can
* optionally be modified to exclude the drawn area.
*
* History:
*  03-03-00 JStall - Created
\***************************************************************************/
VOID MNDrawEdge(
    PMENU pmenu,
    HDC hdc,
    RECT *prcDraw,
    UINT nFlags)
{
    int nWidth, nHeight, nBorder, nTemp;
    HBRUSH hbr;

    UserAssertMsg0(MNIsFlatMenu(), "Should only be called for flat menus");

    nWidth = prcDraw->right - prcDraw->left;
    nHeight = prcDraw->bottom - prcDraw->top;
    nBorder = SYSMET(CXBORDER);

    /*
     * Draw the flat outline around the menu
     */
    DrawOutline(hdc, 0, 0, nWidth, nHeight, nBorder, SYSHBR(BTNSHADOW));

    /*
     * Draw inside the menu
     */
    nTemp = 2 * nBorder;
    if (pmenu->hbrBack == NULL) {
        hbr = SYSHBR(MENU);
    } else {
        hbr = pmenu->hbrBack;
    }

    DrawOutline(hdc, nBorder, nBorder, nWidth - nTemp, nHeight - nTemp, nTemp, hbr);

    /*
     * Adjust the given rectangle from the equivalent calls for 3D-menus
     * when the non-client area is drawn by DefWindowProc.  DrawEdge will
     * inset the rectangle 2 times. (once for the inner and once for the
     * outer)  With the additional InflateRect() the rectangle gets
     * insetted 3 times total.
     */
    if (nFlags == BF_ADJUST) {
        nTemp = -3 * nBorder;
        InflateRect(prcDraw, nTemp, nTemp);
    }
}


/***************************************************************************\
*  MNDrawFullNC
*
*  Performs the custom nonclient painting needed for scrollable menus.
*  Assumes that the given menu is a scrollable menu.
*
* History:
*  08-14-96 GerardoB - Ported from Memphis
\***************************************************************************/
VOID MNDrawFullNC(
    PWND pwnd,
    HDC hdcIn,
    PPOPUPMENU ppopup)
{
    RECT rc;
    HDC hdc;
    HBRUSH hbrOld;
    int yTop, yBottom;
    POINT ptOrg;

    if (hdcIn == NULL) {
        hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE);
    } else {
        hdc = hdcIn;
    }

    rc.left = rc.top = 0;
    rc.right = pwnd->rcWindow.right - pwnd->rcWindow.left;
    rc.bottom = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    if (MNIsFlatMenu()) {
        MNDrawEdge(ppopup->spmenu, hdcIn, &rc, BF_ADJUST);
    } else {
        DrawEdge(hdc, &rc, EDGE_RAISED, (BF_RECT | BF_ADJUST));
        DrawFrame(hdc, &rc, 1, DF_3DFACE);
        InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));
    }

    yTop = rc.top;
    yBottom = rc.bottom - gcyMenuScrollArrow;

    GreGetBrushOrg(hdc, &ptOrg);
    if (ppopup->spmenu->hbrBack != NULL) {
        GreSetBrushOrg(hdc, 0,
                -(int)MNGetToppItem(ppopup->spmenu)->yItem, NULL);
        hbrOld = GreSelectBrush(hdc, ppopup->spmenu->hbrBack);
    } else {
        hbrOld = GreSelectBrush(hdc, SYSHBR(MENU));
    }

    rc.right -= rc.left;
    GrePatBlt(hdc, rc.left, yTop, rc.right, gcyMenuScrollArrow, PATCOPY);
    MNDrawArrow(hdc, ppopup, MFMWFP_UPARROW);
    GrePatBlt(hdc, rc.left, yBottom, rc.right, gcyMenuScrollArrow, PATCOPY);
    MNDrawArrow(hdc, ppopup, MFMWFP_DOWNARROW);

    GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    GreSelectBrush(hdc, hbrOld);

    if (hdcIn == NULL) {
        _ReleaseDC(hdc);
    }
}

/***************************************************************************\
* MNEraseBackground
*
* Erases the background making sure that the background pattern (i.e, watermark)
*  aligns with the pattern in the nonclient area.
*
* History:
*  08-23-96 GerardoB - Created
\***************************************************************************/
VOID MNEraseBackground(
    HDC hdc,
    PMENU pmenu,
    int x,
    int y,
    int cx,
    int cy)
{
    BOOL fSetOrg;
    HBRUSH hbrOld;
    POINT ptOrg;

    UserAssert(pmenu->hbrBack != NULL);

    fSetOrg = TRUE;
    GreGetBrushOrg(hdc, &ptOrg);
    /*
     * If we have scrollbars
     */
    if (pmenu->dwArrowsOn != MSA_OFF) {
        /*
         * If not drawing on the client area only
         */
        if (TestMF(pmenu, MFWINDOWDC)) {
            ptOrg.x = 0;
            ptOrg.y = -(int)MNGetToppItem(pmenu)->yItem;
        } else {
            ptOrg.x = -MNXBORDER;
            ptOrg.y = -MNYBORDER - gcyMenuScrollArrow - MNGetToppItem(pmenu)->yItem;
        }
    } else {
        if (TestMF(pmenu, MFWINDOWDC)) {
            ptOrg.x = MNXBORDER;
            ptOrg.y = MNYBORDER;
        } else {
            fSetOrg = FALSE;
        }
    }

    if (fSetOrg) {
        GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, &ptOrg);
    }
    hbrOld = GreSelectBrush(hdc, pmenu->hbrBack);

    GrePatBlt(hdc, x, y, cx, cy, PATCOPY);

    if (fSetOrg) {
        GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    }
    GreSelectBrush(hdc, hbrOld);
}

/***************************************************************************\
* MNAnimate
*
* If fIterate is TRUE, then perform the next iteration in the menu animation
* sequence. If fIterate is FALSE, terminate the animation sequence.
*
* History:
*  07-23-96 GerardoB - fixed up for 5.0
\***************************************************************************/
VOID MNAnimate(
    PMENUSTATE pMenuState,
    BOOL fIterate)
{
    DWORD   dwTimeElapsed;
    int     x, y, xOff, yOff, xLast, yLast;

    if (TestFadeFlags(FADE_MENU)) {
        if (!fIterate) {
            StopFade();
        }
        return;
    }

    /*
     * If we're not animating, bail
     */
    if (pMenuState->hdcWndAni == NULL) {
        return;
    }

    /*
     * The active popup must be visible. It's supposed to be the
     *  window we're animating
     */
    UserAssert(TestWF(pMenuState->pGlobalPopupMenu->spwndActivePopup, WFVISIBLE));

    /*
     * End animation if asked to do so, if it's taking too long
     *  or someone is waiting for the critical section
     */
    dwTimeElapsed = NtGetTickCount() - pMenuState->dwAniStartTime;
    if (!fIterate
            || (dwTimeElapsed > CMS_QANIMATION)
            || (ExGetExclusiveWaiterCount(gpresUser) > 0)
            || (ExGetSharedWaiterCount(gpresUser) > 0)) {

        GreBitBlt(pMenuState->hdcWndAni, 0, 0, pMenuState->cxAni, pMenuState->cyAni, pMenuState->hdcAni,
            0, 0, SRCCOPY | NOMIRRORBITMAP, 0xFFFFFF);

        goto AnimationCompleted;
    }

    /*
     * Remember current animation point and calculate new one
     */
    xLast = pMenuState->ixAni;
    yLast = pMenuState->iyAni;
    if (pMenuState->iAniDropDir & PAS_HORZ) {
        pMenuState->ixAni = MultDiv(gcxMenuFontChar, dwTimeElapsed, CMS_QANIMATION / 20);
        if (pMenuState->ixAni > pMenuState->cxAni) {
            pMenuState->ixAni = pMenuState->cxAni;
        }
    }

    if (pMenuState->iAniDropDir & PAS_VERT) {
        pMenuState->iyAni = MultDiv(gcyMenuFontChar, dwTimeElapsed, CMS_QANIMATION / 10);
        if (pMenuState->iyAni > pMenuState->cyAni) {
            pMenuState->iyAni = pMenuState->cyAni;
        }
    }

     /*
      * if no change -- bail out
      */
    if ((pMenuState->ixAni == xLast) && (pMenuState->iyAni == yLast)) {
        return;
    }

    /*
     * Calculate source and dest coordinates
     */
    if (pMenuState->iAniDropDir & PAS_LEFT) {
        x = pMenuState->cxAni - pMenuState->ixAni;
        xOff = 0;
    } else {
        xOff = pMenuState->cxAni - pMenuState->ixAni;
        x = 0;
    }

    if (pMenuState->iAniDropDir & PAS_UP) {
        y = pMenuState->cyAni - pMenuState->iyAni;
        yOff = 0;
    } else {
        yOff = pMenuState->cyAni - pMenuState->iyAni;
        y = 0;
    }

    /*
     * Do it
     */
    GreBitBlt(pMenuState->hdcWndAni, x, y, pMenuState->ixAni, pMenuState->iyAni,
              pMenuState->hdcAni, xOff, yOff, SRCCOPY | NOMIRRORBITMAP, 0xFFFFFF);

    /*
     * Check if we're done
     */
    if ((pMenuState->cxAni == pMenuState->ixAni)
            && (pMenuState->cyAni == pMenuState->iyAni)) {

AnimationCompleted:

        MNDestroyAnimationBitmap(pMenuState);
        _ReleaseDC(pMenuState->hdcWndAni);
        pMenuState->hdcWndAni = NULL;
        _KillTimer(pMenuState->pGlobalPopupMenu->spwndActivePopup, IDSYS_MNANIMATE);
    }

}

/***************************************************************************\
* DrawMenuItemCheckMark() -
*
* Draws the proper check mark for the given item.  Note that ownerdraw
* items should NOT be passed to this procedure, otherwise we'd draw a
* checkmark for them when they are already going to take care of it.
*
* Returns TRUE is a bitmap was drawn (or at least we attempted to draw it).
*
* History:
\***************************************************************************/
BOOL DrawMenuItemCheckMark(
    HDC hdc,
    PITEM pItem,
    int xPos)
{
    int     yCenter;
    HBITMAP hbm;
    DWORD   textColorSave;
    DWORD   bkColorSave;
    BOOL    fChecked;
    POEMBITMAPINFO  pOem;
    BOOL fRet = TRUE;
    DWORD dwFlags = BC_INVERT;

    UserAssert(hdc != ghdcMem2);
    pOem = gpsi->oembmi + OBI_MENUCHECK;
    yCenter = pItem->cyItem - pOem->cy;
    if (yCenter < 0)
        yCenter = 0;
    yCenter /= 2;

    fChecked = TestMFS(pItem, MFS_CHECKED);

    if (hbm = (fChecked) ? pItem->hbmpChecked : pItem->hbmpUnchecked) {
        HBITMAP hbmSave;

        // Use the app supplied bitmaps.
        if (hbmSave = GreSelectBitmap(ghdcMem2, hbm)) {

            textColorSave = GreSetTextColor(hdc, 0x00000000L);
            bkColorSave   = GreSetBkColor  (hdc, 0x00FFFFFFL);

            if (TestMFT(pItem, MFT_RIGHTORDER))
                xPos = pItem->cxItem - pOem->cx;

            GreBitBlt(hdc,
                      xPos,
                      yCenter,
                      pOem->cx,
                      pOem->cy,
                      ghdcMem2,
                      0,
                      0,
                      SRCSTENCIL,
                      0x00FFFFFF);

            GreSetTextColor(hdc, textColorSave);
            GreSetBkColor(hdc, bkColorSave);

            GreSelectBitmap(ghdcMem2, hbmSave);
        }

    } else if (fChecked) {

        if (TestMFT(pItem, MFT_RADIOCHECK))
            pOem = gpsi->oembmi + OBI_MENUBULLET;

        if (TestMFT(pItem, MFT_RIGHTORDER))
            xPos = pItem->cxItem - pOem->cx;

        // 389917: Mirror active menu's check mark if hdc is mirroed.
        if ((GreGetLayout(hdc) & LAYOUT_RTL) && (hdc != gpDispInfo->hdcGray)) {
            dwFlags |= BC_NOMIRROR;
        }
        BltColor(hdc,
                 NULL,
                 HDCBITS(),
                 xPos,
                 yCenter,
                 pOem->cx,
                 pOem->cy,
                 pOem->x,
                 pOem->y,
                 dwFlags);
    } else {
        fRet = FALSE;
    }

    return fRet;
}


/***************************************************************************\
* xxxDrawItemtUnderline
*
* Draws or hides an underline for a menu item
*
* 07/23/96  vadimg      separated into a separate routine
\***************************************************************************/
VOID xxxDrawItemUnderline(
    PITEM pItem,
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR pszMenu,
    LONG lResLo)
{
    int   cx;
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    //
    // LOWORD of result is 0xFFFF if there is no underlined character.
    // Therefore ulX must be valid or be UNDERLINE_RECALC because the item
    // or menu mode changed.
    //
    // Bail out if there isn't one.
    //
    if (lResLo == 0xFFFF) {
        return;
    }

    //
    // For proportional fonts, or if an LPK is installed, find starting
    // point of underline.
    //
    if ((pItem->ulX == UNDERLINE_RECALC) || (PpiCurrent()->dwLpkEntryPoints & LPK_INSTALLED)) {
        if (lResLo != 0) {
            SIZE size;

            if (CALL_LPK(ptiCurrent)) {
                xxxClientGetTextExtentPointW(hdc, pszMenu, lResLo, &size);
            } else {
                GreGetTextExtentW(hdc, pszMenu, lResLo, &size, GGTE_WIN3_EXTENT);
            }
            pItem->ulX = size.cx - gcxMenuFontOverhang;
        } else
            pItem->ulX = 0;
    }

    xLeft += pItem->ulX;

    //
    // Adjust for proportional font when setting the length of the underline
    // and height of text.
    //
    // Calculate underline width.
    if (!pItem->ulWidth) {
        SIZE size;

        if (CALL_LPK(ptiCurrent)) {
            xxxClientGetTextExtentPointW(hdc, pszMenu + lResLo, 1, &size);
        } else {
            GreGetTextExtentW(hdc, pszMenu + lResLo, 1, &size, GGTE_WIN3_EXTENT);
        }
        pItem->ulWidth = size.cx - gcxMenuFontOverhang;
    }
    cx = pItem->ulWidth;

    // Get ascent of text (units above baseline) so that underline can be drawn
    // below the text
    yTop += gcyMenuFontAscent;

    // Proper brush should be selected into dc.
    GrePatBlt(hdc, xLeft, yTop, pItem->ulWidth, SYSMET(CYBORDER), PATCOPY);
}

/***************************************************************************\
* xxxDrawMenuItemText
*
* Draws menu text with underline.
\***************************************************************************/
VOID xxxDrawMenuItemText(
    PITEM pItem,
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    BOOL fShowUnderlines)
{
    LONG  result;
    WCHAR  szMenu[MENU_STRLEN], *pchOut;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    TL tl;

    if (cch > MENU_STRLEN) {
        pchOut = (WCHAR*)UserAllocPool((cch+1) * sizeof(WCHAR), TAG_RTL);
        if (pchOut == NULL)
            return;
        ThreadLockPool(ptiCurrent, pchOut, &tl);
    } else {
        pchOut = szMenu;
    }
    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    if (CALL_LPK(ptiCurrent)) {
        xxxClientExtTextOutW(hdc, xLeft, yTop, 0, NULL, pchOut, cch - HIWORD(result), NULL);
    } else {
        GreExtTextOutW(hdc, xLeft, yTop, 0, NULL, pchOut, cch - HIWORD(result), NULL);
    }

    if (fShowUnderlines || TEST_BOOL_ACCF(ACCF_KEYBOARDPREF) || TestEffectInvertUP(KEYBOARDCUES)
                        || (GetAppCompatFlags2(VER40) & GACF2_KCOFF)) {
        if (CALL_LPK(ptiCurrent)) {
            xxxPSMTextOut(hdc, xLeft, yTop, lpsz, cch, DT_PREFIXONLY);
        } else{
            xxxDrawItemUnderline(pItem, hdc, xLeft, yTop, pchOut, LOWORD(result));
        }
    }
    if (pchOut != szMenu) {
        ThreadUnlockAndFreePool(ptiCurrent, &tl);
    }
}

/***************************************************************************\
* xxxSendMenuDrawItemMessage
*
* Sends a WM_DRAWITEM message to the owner of the menu (pMenuState->hwndMenu).
* All state is determined in this routine so HILITE state must be properly
* set before entering this routine..
*
* Revalidation notes:
*  This routine must be called with a valid and non-NULL pwnd.
*  Revalidation is not required in this routine: no windows are used after
*  potentially leaving the critsect.
*
* History:
\***************************************************************************/
VOID xxxSendMenuDrawItemMessage(
    HDC hdc,
    UINT itemAction,
    PMENU pmenu,
    PITEM pItem,
    BOOL fBitmap,
    int iOffset)
{
    DRAWITEMSTRUCT dis;
    TL tlpwndNotify;
    int y;

    CheckLock(pmenu);

    dis.CtlType = ODT_MENU;
    dis.CtlID = 0;

    dis.itemID = pItem->wID;

    dis.itemAction = itemAction;
    dis.itemState   =
         ((pItem->fState & MF_GRAYED)       ? ODS_GRAYED    : 0) |
         ((pItem->fState & MFS_DEFAULT)     ? ODS_DEFAULT   : 0) |
         ((pItem->fState & MFS_CHECKED)     ? ODS_CHECKED   : 0) |
         ((pItem->fState & MFS_DISABLED)    ? ODS_DISABLED  : 0) |
         (MNDrawHilite(pItem)               ? ODS_SELECTED  : 0) |
         ((pItem->fState & MFS_HOTTRACK)    ? ODS_HOTLIGHT  : 0) |
         (TestMF(pmenu, MFINACTIVE)         ? ODS_INACTIVE  : 0) |
         (!TestMF(pmenu, MFUNDERLINE)       ? ODS_NOACCEL : 0);

    dis.hwndItem = (HWND)PtoH(pmenu);
    dis.hDC = hdc;

    y = pItem->yItem;
    if (fBitmap) {
        y = (pItem->cyItem - pItem->cyBmp) / 2;
    }

    dis.rcItem.left     = iOffset + pItem->xItem;
    dis.rcItem.top      = y;
    dis.rcItem.right    = iOffset + pItem->xItem + (fBitmap ? pItem->cxBmp : pItem->cxItem);
    dis.rcItem.bottom   = y + (fBitmap ? pItem->cyBmp : pItem->cyItem);
    dis.itemData = pItem->dwItemData;

    if (pmenu->spwndNotify != NULL) {
        ThreadLockAlways(pmenu->spwndNotify, &tlpwndNotify);
        xxxSendMessage(pmenu->spwndNotify, WM_DRAWITEM, 0, (LPARAM)&dis);
        ThreadUnlock(&tlpwndNotify);
    }

}

/***************************************************************************\
* CalcbfExtra
*
* History:
* 08-09-96 GerardoB  Made into an inline function (code from xxxMenuDraw)
\***************************************************************************/
__inline UINT CalcbfExtra(
    VOID)
{
    if (SYSRGB(3DHILIGHT) == SYSRGB(MENU) && SYSRGB(3DSHADOW) == SYSRGB(MENU)) {
        return BF_FLAT | BF_MONO;
    } else {
        return 0;
    }
}

/***************************************************************************\
* MNDrawInsertionBar
*
* History:
* 11/21/96 GerardoB  Created
\***************************************************************************/
VOID MNDrawInsertionBar(
    HDC hdc,
    PITEM pItem)
{
    BOOL fTop;
    POLYPATBLT PolyData [3], *ppd;

    /*
     * If no insertion bar for this item, bail
     */
    fTop = TestMFS(pItem, MFS_TOPGAPDROP);
    if (!fTop && !TestMFS(pItem, (MFS_BOTTOMGAPDROP))) {
        return;
    }

    /*
     * Vertical line on the left
     */
    ppd = PolyData;
    ppd->x = pItem->xItem + SYSMET(CXDRAG);
    ppd->cx = SYSMET(CXDRAG);
    ppd->cy = SYSMET(CYDRAG);
    if (fTop) {
        ppd->y = pItem->yItem;
    } else {
        ppd->y = pItem->yItem + pItem->cyItem - ppd->cy;
    }
    ppd->BrClr.hbr = SYSHBR(HIGHLIGHT);

    /*
     * Horizontal line in the middle
     */
    ppd++;
    ppd->x = pItem->xItem + (2 * SYSMET(CXDRAG));
    ppd->cx = pItem->cxItem - (4 * SYSMET(CXDRAG));
    ppd->cy = SYSMET(CYDRAG) / 2;
    if (fTop) {
        ppd->y = pItem->yItem;
    } else {
        ppd->y = pItem->yItem + pItem->cyItem - ppd->cy;
    }
    ppd->BrClr.hbr = PolyData->BrClr.hbr;

    /*
     * Vertical line on the right
     */
    ppd++;
    ppd->x = pItem->xItem + pItem->cxItem - (2 * SYSMET(CXDRAG));
    ppd->cx = PolyData->cx;
    ppd->cy = PolyData->cy;
    ppd->y = PolyData->y;
    ppd->BrClr.hbr = PolyData->BrClr.hbr;

    GrePolyPatBlt(hdc, PATCOPY, PolyData, 3, PPB_BRUSH);

}
/***************************************************************************\
* xxxDrawMenuItem
*
* !
*
* History:
\***************************************************************************/
VOID xxxDrawMenuItem(
    HDC hdc,
    PMENU pMenu,
    PITEM pItem,
    DWORD dwFlags)
{
    BOOL fHilite;
    BOOL fFlatMenuBar;
    BOOL fFlatMenu;
    HFONT   hfnOld;
    int     tcExtra;
    UINT    uFlags;
    int     iBkSave;
    hfnOld = NULL;
    uFlags = DST_COMPLEX;


    CheckLock(pMenu);

    fFlatMenu = MNIsFlatMenu();

    /*
     * If the insertion bar is on (MFS_GAPDROP), don't draw the item hilited
     */
    if (fFlatMenu) {
        fHilite = MNDrawHilite(pItem) || TestMFS(pItem, MFS_HOTTRACK) || TestMFS(pItem, MFS_HOTTRACKDRAWN);
        fFlatMenuBar = !TestMF(pMenu, MFISPOPUP);
    } else {
        fHilite = MNDrawHilite(pItem);
        fFlatMenuBar = FALSE;
    }


    if (TestMFS(pItem, MFS_DEFAULT))
    {
        if (ghMenuFontDef != NULL)
            hfnOld = GreSelectFont(hdc, ghMenuFontDef);
        else
        {
            uFlags |= DSS_DEFAULT;
            tcExtra = GreGetTextCharacterExtra(hdc);
            GreSetTextCharacterExtra(hdc, tcExtra + 1 + (gcxMenuFontChar / gpsi->cxSysFontChar));
        }
    }

    if (TestMFT(pItem, MFT_OWNERDRAW)) {

        /*
         * If ownerdraw, just set the default menu colors since the app is
         * responsible for handling the rest.
         */
        GreSetTextColor(hdc, SYSRGB(MENUTEXT));
        GreSetBkColor(hdc, fFlatMenuBar ? SYSRGB(MENUBAR) : SYSRGB(MENU));

        /*
         * Send drawitem message since this is an ownerdraw item.
         */
        xxxSendMenuDrawItemMessage(hdc,
                (UINT)((dwFlags & DMI_INVERT) ? ODA_SELECT : ODA_DRAWENTIRE),
                pMenu, pItem,FALSE,0);

        // Draw the hierarchical arrow for the cascade menu.
        if (TestMF(pMenu, MFISPOPUP) && (pItem->spSubMenu != NULL))
        {
            POEMBITMAPINFO pOem;
            HBRUSH hbr = fHilite ? SYSHBR(HIGHLIGHTTEXT) : SYSHBR(MENUTEXT);

            pOem = gpsi->oembmi + (TestMFT(pItem, MFT_RIGHTORDER)
                                           ? OBI_MENUARROW_L : OBI_MENUARROW);

            // This item has a hierarchical popup associated with it. Draw the
            // bitmap dealy to signify its presence. Note we check if fPopup is set
            // so that this isn't drawn for toplevel menus that have popups.

            BltColor(hdc,
                     hbr,
                     HDCBITS(),
                     TestMFT(pItem, MFT_RIGHTORDER)
                         ? pItem->xItem + pOem->cx :
                           pItem->xItem + pItem->cxItem - pOem->cx,
                     pItem->yItem + max((INT)(pItem->cyItem - 2 - pOem->cy) / 2,
                                        0),
                     pOem->cx,
                     pOem->cy,
                     pOem->x,
                     pOem->y,
                     BC_INVERT);
        }
    } else {
        COLORREF    crBack;
        COLORREF    crFore;
        GRAYMENU    gm;

        HBRUSH      hbrBack;
        HBRUSH      hbrFore;

        //
        // Setup colors and state
        //
        if (fHilite) {
            if (fFlatMenu) {
                crBack = SYSRGB(MENUHILIGHT);
                hbrBack = SYSHBR(MENUHILIGHT);
                crFore = SYSRGB(HIGHLIGHTTEXT);
                hbrFore = SYSHBR(HIGHLIGHTTEXT);
            } else {
                /*
                 * If we are not using flat menu's, only draw the highlight if
                 * the item is a popup menu.  If it is in the menubar, don't
                 * hilight it since it will be beveled.
                 */
                if (TestMF(pMenu, MFISPOPUP)) {
                    crBack = SYSRGB(HIGHLIGHT);
                    hbrBack = SYSHBR(HIGHLIGHT);
                    crFore = SYSRGB(HIGHLIGHTTEXT);
                    hbrFore = SYSHBR(HIGHLIGHTTEXT);
                } else {
                    goto NormalMenuItem;
                }
            }
        } else if (fFlatMenuBar) {
            UserAssertMsg0(fFlatMenu, "fFlatMenuBar should only be set for flat menus");

            crFore = SYSRGB(MENUTEXT);
            hbrFore = SYSHBR(MENUTEXT);
            if (pMenu->hbrBack != NULL) {
                crBack = SYSRGB(MENUBAR);
                hbrBack = pMenu->hbrBack;
            } else {
                crBack = SYSRGB(MENUBAR);
                hbrBack = SYSHBR(MENUBAR);
            }
        } else {
NormalMenuItem:
            crBack = SYSRGB(MENU);
            hbrBack = SYSHBR(MENU);
            crFore = SYSRGB(MENUTEXT);
            hbrFore = SYSHBR(MENUTEXT);
        }

        // B#4157 - Lotus doesn't like it if we draw
        // its disabled menu items in GRAY, t-arthb
        // MAKE SURE MF_GRAYED stays 0x0001 NOT 0x0003 for this to fix

        /*
         * System bitmaps are already grayed so don't draw them disabled
         *  if the menu is inactive
         */
        if (!MNIsCachedBmpOnly(pItem)
                    && (TestMFS(pItem, MF_GRAYED) || TestMF(pMenu, MFINACTIVE))) {
            //
            // Only do embossing if menu color is same as 3D color.  The
            // emboss uses 3D hilight & 3D shadow, which doesn't look cool
            // on a different background.
            //
            if ((fHilite) ||
                (crBack != SYSRGB(3DFACE)) || SYSMET(SLOWMACHINE)) {
                //
                // If gray text won't show up on background, then dither.
                //
                if (SYSRGB(GRAYTEXT) == crBack) {
                    uFlags |= DSS_UNION;
                } else {
                    crFore = SYSRGB(GRAYTEXT);
                    hbrFore = SYSHBR(GRAYTEXT);
                }
            } else {
                if ((SYSRGB(3DSHADOW) == crBack) && (SYSRGB(3DHILIGHT) == crBack)) {
                    uFlags |= DSS_UNION;
                } else {
                    uFlags |= TestMF(pMenu, MFINACTIVE) ? DSS_INACTIVE : DSS_DISABLED;
                }
            }
        }

        GreSetBkColor(hdc, crBack);
        GreSetTextColor(hdc, crFore);
        if (((dwFlags & DMI_INVERT) && (pMenu->hbrBack == NULL))
                || fHilite || fFlatMenuBar) {

            POLYPATBLT PolyData;

            /*
             * Only fill the background if we're being called on behalf of
             * MNInvertItem. This is so that we don't waste time filling
             * the unselected rect when the menu is first pulled down.
             * If the menu has a background brush and we were called by
             * MNInvertItem, that function will have already taken care of
             * filling the background
             */

            PolyData.x         = pItem->xItem;
            PolyData.y         = pItem->yItem;
            PolyData.cx        = pItem->cxItem;
            PolyData.cy        = pItem->cyItem;
            PolyData.BrClr.hbr = hbrBack;

            GrePolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);

            if (fHilite && fFlatMenu) {
                DrawOutline(hdc, pItem->xItem, pItem->yItem,
                        pItem->cxItem, pItem->cyItem, 1, SYSHBR(HIGHLIGHT));
            }
        }

        if (pMenu->hbrBack != NULL) {
            iBkSave = GreSetBkMode(hdc, TRANSPARENT);
        }
        GreSelectBrush(hdc, hbrFore);

        //
        // Draw the image
        //
        gm.pItem   = pItem;
        gm.pMenu   = pMenu;

        xxxDrawState(hdc,
            hbrFore,
            (LPARAM)(PGRAYMENU)&gm,
            pItem->xItem,
            pItem->yItem,
            pItem->cxItem,
            pItem->cyItem,
            uFlags);

        if (! fFlatMenu) {
            MNDrawMenu3DHotTracking(hdc, pMenu, pItem);
        }
    }

    /*
     * Draw the drop insertion bar, if any
     */
    MNDrawInsertionBar (hdc, pItem);


    if (pMenu->hbrBack != NULL)
        GreSetBkMode(hdc, iBkSave);

    if (TestMFS(pItem, MFS_DEFAULT))
    {
        if (hfnOld)
            GreSelectFont(hdc, hfnOld);
        else
            GreSetTextCharacterExtra(hdc, tcExtra);
    }
}

extern void SetupFakeMDIAppStuff(PMENU lpMenu, PITEM lpItem);

/***************************************************************************\
*
*  xxxRealDrawMenuItem()
*
*  Callback from xxxDrawState() to draw the menu item, either normally or into
*  an offscreen bitmp.  We don't know where we're drawing, and shouldn't
*  have to.
*
\***************************************************************************/
BOOL CALLBACK xxxRealDrawMenuItem(
    HDC hdc,
    PGRAYMENU pGray,
    int cx,
    int cy)
{
    PMENU  pMenu;
    PITEM  pItem;
    BOOL    fPopup;
    int     cch;
    int     xLeft;
    int     yTop;
    int     tp;
    int     rp;
    LPWSTR   lpsz;
    int     cyTemp;
    int     xHilite = 0;
    int     yHilite = 0;
    TL     tlpwndChild;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    BOOL fCheckDrawn = FALSE;
    int     xFarLeft;
    //
    // BOGUS
    // Use cx and cy instead of lpItem->cxItem, lpItem->cyItem to
    // speed stuff up.
    //
    pMenu = pGray->pMenu;
    CheckLock(pMenu);
    pItem = pGray->pItem;
    fPopup = TestMF(pMenu, MFISPOPUP);

    if (fPopup) {
        xLeft = MNLEFTMARGIN;
        if (TestMF(pMenu, MNS_NOCHECK)) {
            xLeft += MNXSPACE;
        } else {
            fCheckDrawn = DrawMenuItemCheckMark(hdc, pItem, xLeft);
            if (!TestMF(pMenu, MNS_CHECKORBMP)
                    || ((pItem->hbmp == NULL) || fCheckDrawn)) {

                xLeft += TestMFT(pItem, MFT_RIGHTORDER)
                            ? 0 : (gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE);
            }
        }
    } else {
        xLeft = 0;

        /*
         * If not drawing flat menus in the menubar, "depress" the menu item
         * when it becomes highlighted.
         */
        if ((! MNIsFlatMenu()) && TestMFS(pItem, MFS_HILITE)) {
            xHilite = CXMENU3DEDGE;
            yHilite = CYMENU3DEDGE;
        }
    }

    /*
     * If there is not bitmap or we don't to draw it, go draw the text
     */
    if ((pItem->hbmp == NULL)
        || (fCheckDrawn
            && TestMF(pMenu, MNS_CHECKORBMP))) {
        goto RealDrawMenuItemText;
    }

    /*
     * Draw the bitmap
     */
    if (TestMFS(pItem, MFS_CACHEDBMP)) {
        if (pItem->hbmp == HBMMENU_SYSTEM) {
            /*
             * Drawing app icon (system menu)
             */
            PWND  pwndChild;
            PICON pIcon = NULL;
            UINT cyUse, cxUse;

AintNothingLikeTheRealMDIThing:
            if (!(pItem->dwItemData))
                SetupFakeMDIAppStuff(pMenu, pItem);

            pwndChild = HMValidateHandleNoRip((HWND)(pItem->dwItemData),TYPE_WINDOW);
            if (!pwndChild)
            {
                //
                // Oops, child window isn't valid anymore.  Go find
                // the new one.
                //
                if (pItem->dwItemData)
                {
                    pItem->dwItemData = 0;
                    goto AintNothingLikeTheRealMDIThing;
                }

                pIcon = NULL;
            }
            else {
                ThreadLock(pwndChild, &tlpwndChild);
                pIcon = xxxGetWindowSmIcon(pwndChild, FALSE);
                ThreadUnlock(&tlpwndChild);
            }


            if (!pIcon)
                pIcon = SYSICO(WINLOGO);

            cyUse = cy - SYSMET(CYEDGE);
            cxUse = cx - (SYSMET(CXEDGE) * 2);
            /*
             * If this is a popup, make sure that no weird
             *  width/height stretch takes place.
             */
            if (fPopup && (cyUse < cxUse)) {
                cxUse = cyUse;
            }

            _DrawIconEx(hdc, xLeft + (SYSMET(CXEDGE) * 2),
                  SYSMET(CYBORDER), pIcon, cxUse,
                  cyUse, 0, SYSHBR(MENU), DI_NORMAL | DI_NOMIRROR);

        } else {
            /*
             * This is a cached bitmap
             */
            UINT wBmp;
            int xBmpLeft = xLeft;
            int y;
            POEMBITMAPINFO pOem;

            switch ((ULONG_PTR)pItem->hbmp) {
                case (ULONG_PTR)HBMMENU_MBAR_RESTORE:
                    wBmp = OBI_RESTORE_MBAR;
                    goto DrawSysBmp;

                case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE:
                    wBmp = OBI_REDUCE_MBAR;
                    xBmpLeft += SYSMET(CXEDGE);
                    goto DrawSysBmp;

                case (ULONG_PTR)HBMMENU_MBAR_CLOSE:
                    wBmp = OBI_CLOSE_MBAR;
                    goto DrawSysBmp;

                case (ULONG_PTR)HBMMENU_MBAR_CLOSE_D:
                    wBmp = OBI_CLOSE_MBAR_I;
                    goto DrawSysBmp2;

                case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE_D:
                    wBmp = OBI_REDUCE_MBAR_I;
                    xBmpLeft += SYSMET(CXEDGE);
                    goto DrawSysBmp2;

DrawSysBmp:
                    /*
                     * Select proper bitmap based on the item state
                     */
                    if (TestMFS(pItem, MFS_HILITE)) {
                        wBmp += DOBI_PUSHED;
                    }

DrawSysBmp2:
                    BitBltSysBmp(hdc, xBmpLeft, SYSMET(CYEDGE), wBmp);
                    break;

                default:
                    UserAssert((pItem->hbmp >= HBMMENU_POPUPFIRST)
                                && (pItem->hbmp <= HBMMENU_POPUPLAST));

                    wBmp = OBI_POPUPFIRST + HandleToUlong(pItem->hbmp) - HandleToUlong(HBMMENU_POPUPFIRST);
                    UserAssert(wBmp < OBI_COUNT);

                    pOem = gpsi->oembmi + wBmp;
                    y = (pItem->cyItem - pOem->cy) / 2;
                    if (y < 0) {
                        y = 0;
                    }
                    BltColor(hdc, NULL, HDCBITS(), xLeft, y,
                             pOem->cx, pOem->cy, pOem->x, pOem->y, BC_INVERT);
                    break;
            }

        } /* if (pItem->hbmp == HBMMENU_SYSTEM) */


    } else if (pItem->hbmp == HBMMENU_CALLBACK) {
        /*
         * Owner draw bitmap
         */
        xxxSendMenuDrawItemMessage(hdc,ODA_DRAWENTIRE, pMenu, pItem, TRUE, xLeft);

    } else {
        /*
         * Drawing a regular bitmap.
         */

        int dx, dy;
        HBITMAP hbmSave;

        //
        // Is this the zero'th item in a menu bar that's not all
        // bitmaps?  Hmm, sounds like it could be a fake MDI dude.
        // If it is, use the windows icon instead
        //
        /*
         * Let's fail this for > 4.0 apps so we can get rid of
         *  this horrible hack someday. The HBMMENU_ constants
         *  have been made public so people can use them freely.
         *
         * Note: even if the app is marked as 4.0, he could be
         * recompiled and may utilizes the new feature in NT5 menu.
         * So just in case, we have to check both dwItemData and lpstr
         * so that the menu could have bitmap, dwItemData and a menu string.
         *
         */
        if (LOWORD(ptiCurrent->dwExpWinVer) <= VER40) {
            if (pItem->dwItemData && pItem->lpstr == NULL)
                goto AintNothingLikeTheRealMDIThing;
            else if (!fPopup &&
                    (pItem == pMenu->rgItems) &&
                    (pMenu->cItems > 1) &&
                    !(pMenu->rgItems[1].hbmp) &&
                    (pItem->spSubMenu)) {
                RIPMSG0(RIP_WARNING, "Fake MDI detected, using window icon in place of bitmap");
                goto AintNothingLikeTheRealMDIThing;
            }
        }

        UserAssert(hdc != ghdcMem2);

        dx = pItem->cxBmp;

        if (fPopup) {
            dy = pItem->cyBmp;

            //
            // Center bitmap in middle of item area
            //
            cyTemp = (pItem->cyItem - dy);
            if (cyTemp > 0)
                cyTemp = cyTemp / 2;
            else
                cyTemp = 0;
        } else {
            dy = max(pItem->cyBmp, SYSMET(CYMENUSIZE));
            cyTemp = 0;
            if (pItem->lpstr != NULL) {
                xLeft += gcxMenuFontChar;
            }
        }

        if (hbmSave = GreSelectBitmap(ghdcMem2, pItem->hbmp)) {
            BITMAP  bmp;
            //
            // Draw the bitmap leaving some room on the left for the
            // optional check mark if we are in a popup menu. (as opposed
            // to a top level menu bar).
            //
            // We can do cool stuff with monochrome bitmap itmes
            // by merging with the current colors.
            //
            // If the item is selected and the bitmap isn't monochrome,
            // we just invert the thing when we draw it.  We can't do
            // anything more clever unless we want to convert to
            // monochrome.
            //
            GreExtGetObjectW(pItem->hbmp, sizeof(bmp), (LPSTR)&bmp);
            GreBitBlt(hdc, xLeft + xHilite, cyTemp + xHilite, dx, dy, ghdcMem2, 0, 0,
                (bmp.bmPlanes * bmp.bmBitsPixel == 1)   ?
                SRCSTENCIL                              :
                (MNDrawHilite(pItem) ? NOTSRCCOPY : SRCCOPY),
                0x00FFFFFF);
            GreSelectBitmap(ghdcMem2, hbmSave);
        } else {
            RIPMSG3(RIP_WARNING, "Menu 0x%08X, item 0x%08X: Tried to draw invalid bitmap 0x%08X", pMenu, pItem, pItem->hbmp) ;
        }
    }


RealDrawMenuItemText:
    if (pItem->lpstr != NULL) {
        /*
         * We want the text in all popup menu items to be aligned
         *  if an alignment offset is available.
         */
        if (fPopup && (pMenu->cxTextAlign != 0)) {
            xLeft = pMenu->cxTextAlign;
        } else if (pItem->hbmp != NULL) {
            xLeft += pItem->cxBmp + SYSMET(CXEDGE);
        }

        // This item is a text string item. Display it.
        yTop = gcyMenuFontExternLeading;

        cyTemp = pItem->cyItem - (gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYBORDER));
        if (cyTemp > 0)
            yTop += (cyTemp / 2);

        if (!fPopup && (pItem->hbmp == NULL)) {
            xLeft += gcxMenuFontChar;
        }

        lpsz = TextPointer(pItem->lpstr);
        if (lpsz!=NULL) {
            cch = pItem->cch;

            // Even though we no longer support any funky handling of the
            // help prefix character, we still need to eat it up if we run
            // across it so that the menu item is drawn correctly
            if ((*lpsz == CH_HELPPREFIX) && !fPopup) {
                // Skip help prefix character.
                lpsz++;
                cch--;
            }

            // tp will contain the character position of the \t indicator
            // in the menu string.  This is where we add a tab to the string.
            //
            // rp will contain the character position of the \a indicator
            // in the string.  All text following this is right aligned.
            tp = FindCharPosition(lpsz, TEXT('\t'));
            rp = FindCharPosition(lpsz, TEXT('\t') - 1);

            xFarLeft = pItem->cxItem - (gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE);

            if (rp && (rp != cch)) {
                // Display all the text up to the \a
                if (TestMFT(pItem, MFT_RIGHTORDER) && fPopup) {
                    SIZE extent;

                    xxxPSMGetTextExtent(hdc, lpsz, rp, &extent);
                    xLeft = xFarLeft - extent.cx;
                }
                xxxDrawMenuItemText(pItem, hdc, xLeft + xHilite, yTop + xHilite, lpsz, rp,
                        TestMF(pMenu, MFUNDERLINE));

                // Do we also have a tab beyond the \a ??
                if (tp > rp + 1) {
                    SIZE extent;

                    if (TestMFT(pItem, MFT_RIGHTORDER) && fPopup) {
                        xLeft = xFarLeft - pItem->dxTab ;
                    } else {
                        xxxPSMGetTextExtent(hdc, lpsz + rp + 1,
                                (UINT)(tp - rp - 1), &extent);
                        xLeft = (int)(pItem->dxTab - extent.cx);
                    }
                    //
                    // lotus in Hebrew make their menus by putting the
                    // accelerator on the left and the text on the right
                    //
                    xxxPSMTextOut(hdc, xLeft, yTop, (LPWSTR)(lpsz + rp + 1), tp - rp - 1,
                                  TestMF(pMenu, MFUNDERLINE) ? 0 : DT_HIDEPREFIX);
                }
             } else if (tp && rp == cch) {
                // Display text up to the tab position
                if (TestMFT(pItem, MFT_RIGHTORDER)) {
                    SIZE extent;

                    xxxPSMGetTextExtent(hdc, lpsz, tp, &extent);
                    xLeft = xFarLeft - extent.cx;
                    if (!fPopup && (pItem->hbmp == NULL)) {
                        xLeft += gcxMenuFontChar;
                    }
                }
                xxxDrawMenuItemText(pItem, hdc, xLeft + xHilite, yTop + xHilite, lpsz, tp,
                        TestMF(pMenu, MFUNDERLINE));
             }

            // Any text left to display (like after the tab) ??
            if (tp < cch - 1) {
                if (TestMFT(pItem, MFT_RIGHTORDER) && fPopup) {
                    SIZE extent;

                    xxxPSMGetTextExtent(hdc, lpsz + tp + 1, (int)cch - tp - 1, &extent);
                    xLeft = pItem->cxItem - pItem->dxTab - extent.cx;
                } else {
                    xLeft = pItem->dxTab + gcxMenuFontChar;
                }
                xxxPSMTextOut(hdc, xLeft, yTop, lpsz + tp + 1, cch - tp - 1,
                              TestMF(pMenu, MFUNDERLINE) ? 0 : DT_HIDEPREFIX);
            }
        }
    }

    //
    // Draw the hierarchical arrow for the cascade menu.
    //
    if (fPopup && (pItem->spSubMenu != NULL)) {
        POEMBITMAPINFO pOem;

        pOem = gpsi->oembmi + (TestMFT(pItem, MFT_RIGHTORDER)
                               ? OBI_MENUARROW_L : OBI_MENUARROW);

        // This item has a hierarchical popup associated with it. Draw the
        // bitmap dealy to signify its presence. Note we check if fPopup is set
        // so that this isn't drawn for toplevel menus that have popups.

        BltColor(hdc,
                 NULL,
                 HDCBITS(),
                 TestMFT(pItem, MFT_RIGHTORDER)
                 ? pOem->cx :
                   pItem->cxItem - pOem->cx,
                 max((INT)(pItem->cyItem - 2 - pOem->cy) / 2, 0),
                 pOem->cx,
                 pOem->cy,
                 pOem->x,
                 pOem->y,
                 BC_INVERT);
    }

    return TRUE;
}

/***************************************************************************\
* xxxMenuBarDraw
*
* History:
* 11-Mar-1992 mikeke   From win31
\***************************************************************************/
int xxxMenuBarDraw(
    PWND pwnd,
    HDC hdc,
    int cxFrame,
    int cyFrame)
{
    UINT cxMenuMax;
    UINT cyMenu;
    int yTop;
    PMENU pMenu;
    BOOL fClipped = FALSE;
    TL tlpMenu;
    HBRUSH hbrT;
    CheckLock(pwnd);

    pMenu = pwnd->spmenu;
    if (pMenu == NULL) {
        return SYSMET(CYBORDER);
    }

    /*
     * NT5 menus are drawn inactive when the window is not active.
     */
    if (TestwndFrameOn(pwnd) || (GetAppCompatFlags2(VER40) & GACF2_ACTIVEMENUS)) {
        ClearMF(pMenu, MFINACTIVE);
    } else {
        SetMF(pMenu, MFINACTIVE);
    }

    /*
     * Lock the menu so we can poke around.
     */
    ThreadLockMenuNoModify(pMenu, &tlpMenu);

    yTop = cyFrame;
    yTop += GetCaptionHeight(pwnd);


    /*
     * Calculate maximum available horizontal real estate
     */
    cxMenuMax = (pwnd->rcWindow.right - pwnd->rcWindow.left) - cxFrame * 2;

    /*
     * If the menu has switched windows, or if either count is 0,
     * then we need to recompute the menu width.
     */
    if (pwnd != pMenu->spwndNotify ||
            pMenu->cxMenu == 0 ||
            pMenu->cyMenu == 0) {

        xxxMenuBarCompute(pMenu, pwnd, yTop, cxFrame, cxMenuMax);
    }

    /*
     * If the menu rectangle is wider than allowed, or the
     * bottom would overlap the size border, we need to clip.
     */
    if (pMenu->cxMenu > cxMenuMax ||
            (int)(yTop + pMenu->cyMenu) > (int)((pwnd->rcWindow.bottom - pwnd->rcWindow.top)
            - cyFrame)) {

        /*
         * Lock the display while we're playing around with visrgns.  Make
         * a local copy of the saved-visrgn so it can be restored in case
         * we make a callback (i.e. WM_DRAWITEM).
         */
        GreLockDisplay(gpDispInfo->hDev);

        fClipped = TRUE;

        GreIntersectVisRect(hdc, pwnd->rcWindow.left + cxFrame,
                              pwnd->rcWindow.top,
                              pwnd->rcWindow.left + cxFrame + cxMenuMax,
                              pwnd->rcWindow.bottom - cyFrame);

        GreUnlockDisplay(gpDispInfo->hDev);
    }

    {
        // Draw menu background in MENU color
        // Draw border under menu in proper BORDER color

        POLYPATBLT PolyData[2];
        BOOL fFlatMenu;

        /*
         * We can't use MFISPOPUP to determine if we are drawing a menu bar.
         * This is because a menu can be created as a popup, but then attached
         * to a window using SetMenu(), making it a menubar.
         */
        fFlatMenu = MNIsFlatMenu();

        PolyData[0].x         = cxFrame;
        PolyData[0].y         = yTop;
        PolyData[0].cx        = pMenu->cxMenu;
        PolyData[0].cy        = pMenu->cyMenu;
        PolyData[0].BrClr.hbr = (pMenu->hbrBack) ? pMenu->hbrBack : (fFlatMenu ? SYSHBR(MENUBAR) : SYSHBR(MENU));

        PolyData[1].x         = cxFrame;
        PolyData[1].y         = yTop + pMenu->cyMenu;
        PolyData[1].cx        = pMenu->cxMenu;
        PolyData[1].cy        = SYSMET(CYBORDER);
        PolyData[1].BrClr.hbr = (TestWF(pwnd, WEFEDGEMASK) && !TestWF(pwnd, WFOLDUI))? SYSHBR(3DFACE) : SYSHBR(WINDOWFRAME);

        GrePolyPatBlt(hdc,PATCOPY,&PolyData[0],2,PPB_BRUSH);
    }

    /*
     * Finally, draw the menu itself.
     */

    hbrT = GreSelectBrush(hdc, (TestWF(pwnd, WEFEDGEMASK) && !TestWF(pwnd, WFOLDUI))? SYSHBR(3DFACE) : SYSHBR(WINDOWFRAME));
    xxxMenuDraw(hdc, pMenu);
    GreSelectBrush(hdc, hbrT);

    if (fClipped) {
        /*
         * Recalculate the DC visrgn after calling back.
         */
        PDCE pdce;
        if ((pdce = LookupDC(hdc)) != NULL) {
            InvalidateDce(pdce);
        }
    }

    cyMenu = pMenu->cyMenu + SYSMET(CYBORDER);
    ThreadUnlockMenuNoModify(&tlpMenu);
    return cyMenu;
}

/***************************************************************************\
* xxxMenuDraw
*
* Draws the menu
*
* Revalidation notes:
*  This routine must be called with a valid and non-NULL pwnd.
*
* History:
\***************************************************************************/
VOID xxxMenuDraw(
    HDC hdc,
    PMENU pmenu)
{
    PITEM pItem;
    UINT i, cy;
    RECT rcItem;
    HFONT       hFontOld;
    UINT        bfExtra;
    PTHREADINFO ptiCurrent = PtiCurrent();
    UINT        oldAlign;
    int         iBkSave;
    POINT       ptOrg;

    CheckLock(pmenu);

    if (pmenu == NULL) {
        RIPERR0(ERROR_INVALID_HANDLE,
                RIP_WARNING,
                "xxxMenuDraw: Invalid menu handle (NULL)");

        return;
    }

    GreGetViewportOrg(hdc, &ptOrg);
    hFontOld = GreSelectFont(hdc, ghMenuFont);

    oldAlign = GreGetTextAlign(hdc);
    if (pmenu->rgItems && TestMFT(pmenu->rgItems, MFT_RIGHTORDER)) {
        GreSetTextAlign(hdc, oldAlign | TA_RTLREADING);
    }

    bfExtra = CalcbfExtra();

    if (pmenu->hbrBack != NULL) {
        iBkSave = GreSetBkMode(hdc, TRANSPARENT);
    }

    if (pmenu->dwArrowsOn != MSA_OFF) {
        pItem = MNGetToppItem(pmenu);
        GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y - ((int)pItem->yItem), NULL);
        i = pmenu->iTop;
    } else {
        pItem = (PITEM)pmenu->rgItems;
        i = 0;
    }

    cy = 0;
    for (; i < pmenu->cItems; i++, pItem++) {
        if (TestMFT(pItem, MFT_MENUBARBREAK) &&
                TestMF(pmenu, MFISPOPUP)) {

            //
            // Draw a vertical etch.  This is done by calling DrawEdge(),
            // sunken, with BF_LEFT | BF_RIGHT.
            //
            if(TestMFT(pItem, MFT_RIGHTORDER) && i) {
                //
                // going backwards, so the correct place is just before the
                // _previous_ item.
                //
                PITEM pi;

                pi            = pItem - 1;
                rcItem.left   = pi->xItem - SYSMET(CXFIXEDFRAME);
                rcItem.top    = 0;
                rcItem.right  = pi->xItem - SYSMET(CXBORDER);
                rcItem.bottom = pmenu->cyMenu;
            } else {
                rcItem.left     = pItem->xItem - SYSMET(CXFIXEDFRAME);
                rcItem.top      = 0;
                rcItem.right    = pItem->xItem - SYSMET(CXBORDER);
                rcItem.bottom   = pmenu->cyMenu;
            }

            DrawEdge(hdc, &rcItem, BDR_SUNKENOUTER, BF_LEFT | BF_RIGHT | bfExtra);
        }
        /*
         * If this is a separator, draw it and return.
         * If version is less than 4.0  don't test the MFT_OWNERDRAW
         * flag. Bug 21922; App MaxEda has both separator and Ownerdraw
         * flags on. In 3.51 we didn't test the OwnerDraw flag
         */
        if (TestMFT(pItem, MFT_SEPARATOR)
                && (!TestMFT(pItem, MFT_OWNERDRAW)
                    || (LOWORD(ptiCurrent->dwExpWinVer) < VER40))) {

            /*
             * Draw a horizontal etch.
             */
            int yT = pItem->yItem + (pItem->cyItem / 2) - SYSMET(CYBORDER);
            RECT rcItem;

            rcItem.left     = pItem->xItem + 1;
            rcItem.top       = yT;
            rcItem.right    = pItem->xItem + pItem->cxItem - 1;
            rcItem.bottom   = yT + SYSMET(CYEDGE);

            DrawEdge(hdc, &rcItem, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM | bfExtra);
            /*
             * Draw drop insertion bar, if any.
             */
            MNDrawInsertionBar (hdc, pItem);

        } else {
            xxxDrawMenuItem(hdc, pmenu, pItem, 0);
        }

        if (pmenu->dwArrowsOn != MSA_OFF) {
            cy += pItem->cyItem;
            if (cy > pmenu->cyMenu) {
                /*
                 * This is a scrollable menu and the item just drawn falls below
                 * the bottom of the visible menu -- no need to draw any further
                 */
                break;
            }
        }
    }

    if (pmenu->hbrBack != NULL) {
        GreSetBkMode(hdc, iBkSave);
    }

    GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    GreSetTextAlign(hdc, oldAlign);
    GreSelectFont(hdc, hFontOld);
}


/***************************************************************************\
* xxxDrawMenuBar
*
* Forces redraw of the menu bar
*
* History:
\***************************************************************************/
BOOL xxxDrawMenuBar(
    PWND pwnd)
{
    CheckLock(pwnd);

    if (!TestwndChild(pwnd)) {
        xxxRedrawFrame(pwnd);
    }

    return TRUE;
}


/***************************************************************************\
* xxxMenuInvert
*
* Invert menu item
*
* Revalidation notes:
*  This routine must be called with a valid and non-NULL pwnd.
*
*  fOn - TRUE if the item is selected thus it needs to be inverted
*  fNotify - TRUE if the parent should be notified (as appropriate), FALSE
*            if we are just redrawing the selected item.
*
* History:
\***************************************************************************/
PITEM xxxMNInvertItem(
    PPOPUPMENU ppopupmenu,
    PMENU pmenu,
    int itemNumber,
    PWND pwndNotify,
    BOOL fOn)
{
    PITEM pItem = NULL;
    HDC hdc;
    int y, iNewTop;
    RECT rcItem;
    BOOL fSysMenuIcon = FALSE;
    PMENU pmenusys;
    BOOL fClipped = FALSE;
    HFONT   hOldFont;
    PWND pwnd;
    POINT ptOrg;
    TL tlpwnd;
    UINT oldAlign;

    CheckLock(pmenu);
    CheckLock(pwndNotify);

    /*
     * If we are in the middle of trying to get out of menu mode, hMenu
     * and/or pwndNotify will be NULL, so just bail out now.
     */
    if ((pmenu == NULL) || (pwndNotify == NULL)) {
        return NULL;
    }


    /*
     * If ppopupmenu is NULL, we're not in menu mode (i.e, call from
     *  HiliteMenuItem).
     */
    if (ppopupmenu == NULL) {
        pwnd = pwndNotify;
    } else {
        pwnd = ppopupmenu->spwndPopupMenu;
    }

    if (pwnd != pwndNotify) {
        ThreadLock(pwnd, &tlpwnd);
    }


    if (itemNumber < 0) {

        if (ppopupmenu != NULL) {
            if ((itemNumber == MFMWFP_UPARROW) || (itemNumber == MFMWFP_DOWNARROW)) {
                MNDrawArrow(NULL, ppopupmenu, itemNumber);
            }
        }

        xxxSendMenuSelect(pwndNotify, pwnd, pmenu, itemNumber);
        goto SeeYa;
    }

    if (!TestMF(pmenu, MFISPOPUP)) {
        pmenusys = xxxGetSysMenuHandle(pwndNotify);
        if (pmenu == pmenusys) {
            MNPositionSysMenu(pwndNotify, pmenusys);
            fSysMenuIcon = TRUE;
        }
    }

    if ((UINT)itemNumber >= pmenu->cItems)
        goto SeeYa;

    pItem = &pmenu->rgItems[itemNumber];

    if (!TestMF(pmenu, MFISPOPUP) && TestWF(pwndNotify, WFMINIMIZED)) {

        /*
         * Skip inverting top level menus if the window is iconic.
         */
        goto SeeYa;
    }

    /*
     * Is this a separator?
     */
    if (TestMFT(pItem, MFT_SEPARATOR)) {
        goto SendSelectMsg;
    }

    if ((BOOL)TestMFS(pItem, MFS_HILITE) == (BOOL)fOn) {

        /*
         * Item's state isn't really changing.  Just return.
         */
        goto SeeYa;
    }

    if (fOn && (ppopupmenu != NULL) && (pmenu->dwArrowsOn != MSA_OFF)) {
        /*
         * when selecting an item, ensure that the item is fully visible
         * NOTE -- For mouse use, partially visible should be acceptable
         *      -- Can we get mouse info down this far ?
         */

        if (itemNumber < pmenu->iTop) {
            iNewTop = itemNumber;
            goto NewTop;
        } else {
            PITEM pWalk = MNGetToppItem(pmenu);
            int dy = pItem->yItem + pItem->cyItem - pWalk->yItem - pmenu->cyMenu;
            iNewTop = pmenu->iTop;
            while ((dy > 0) && (iNewTop < (int)pmenu->cItems)) {
                dy -= pWalk->cyItem;
                pWalk++;
                iNewTop++;
            }
            if (iNewTop >= (int)pmenu->cItems) {
                iNewTop = pmenu->cItems;
            }
NewTop:
            if (xxxMNSetTop(ppopupmenu, iNewTop)) {
                xxxUpdateWindow(pwnd);
            }
        }
    }

    rcItem.left     = pItem->xItem;
    rcItem.top      = pItem->yItem;
    rcItem.right    = pItem->xItem + pItem->cxItem;
    rcItem.bottom   = pItem->yItem + pItem->cyItem;

    y = pItem->cyItem;

    if (TestMF(pmenu, MFISPOPUP)) {
        hdc = _GetDC(pwnd);
    } else {
        hdc = _GetWindowDC(pwnd);
        if (TestWF(pwnd, WFSIZEBOX) && !fSysMenuIcon) {

            /*
             * If the window is small enough that some of the menu bar has been
             * obscured by the frame, we don't want to draw on the bottom of the
             * sizing frame.  Note that we don't want to do this if we are
             * inverting the system menu icon since that will be clipped to the
             * window rect.  (otherwise we end up with only half the sys menu
             * icon inverted)
             */
            int xMenuMax = (pwnd->rcWindow.right - pwnd->rcWindow.left) - SYSMET(CXSIZEFRAME);

            if (rcItem.right > xMenuMax ||
                    rcItem.bottom > ((pwnd->rcWindow.bottom -
                    pwnd->rcWindow.top) - SYSMET(CYSIZEFRAME))) {

                /*
                 * Lock the display while we're playing around with visrgns.
                 * Make a local copy of the visrgn, so that it can be
                 * properly restored on potential callbacks (i.e. WM_DRAWITEM).
                 */
                GreLockDisplay(gpDispInfo->hDev);

                fClipped = TRUE;

                GreIntersectVisRect(hdc,
                        pwnd->rcWindow.left + rcItem.left,
                        pwnd->rcWindow.top + rcItem.top,
                        pwnd->rcWindow.left + xMenuMax,
                        pwnd->rcWindow.bottom - SYSMET(CYSIZEFRAME));

                GreUnlockDisplay(gpDispInfo->hDev);
            }
        }
    }

    oldAlign = GreGetTextAlign(hdc);
    if (pItem && TestMFT(pItem, MFT_RIGHTORDER))
        GreSetTextAlign(hdc, oldAlign | TA_RTLREADING);

    hOldFont = GreSelectFont(hdc, ghMenuFont);
    GreGetViewportOrg(hdc, &ptOrg);

    if (fOn) {
        SetMFS(pItem, MFS_HILITE);
    } else {
        ClearMFS(pItem, MFS_HILITE);
    }

    if (!fSysMenuIcon
        && ((pItem->hbmp != HBMMENU_SYSTEM)
            || (TestMF(pmenu, MFISPOPUP)))) {

        if (pmenu->dwArrowsOn != MSA_OFF) {
            GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y - ((int)MNGetToppItem(pmenu)->yItem), NULL);
        }

        if ((pmenu->hbrBack != NULL)
                && !MNDrawHilite(pItem)
                && !TestMFT(pItem, MFT_OWNERDRAW)) {

            /*
             * fill the background here so xxxDrawMenuItem doesn't have to fool
             * around with hbrBack
             */
            int iBkSave = GreSetBkMode(hdc, TRANSPARENT);
            MNEraseBackground (hdc, pmenu,
                    pItem->xItem, pItem->yItem,
                    pItem->cxItem, pItem->cyItem);
            GreSetBkMode(hdc, iBkSave);
        }

        xxxDrawMenuItem(hdc, pmenu, pItem, DMI_INVERT);
    }


    if (fClipped) {
        /*
         * Recalculate the DC visrgn after calling back.
         */
        PDCE pdce;
        if ((pdce = LookupDC(hdc)) != NULL) {
            InvalidateDce(pdce);
        }
    }

    GreSelectFont(hdc, hOldFont);
    GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    GreSetTextAlign(hdc, oldAlign);
    _ReleaseDC(hdc);

SendSelectMsg:
    /*
     * send select msg only if we are selecting an item.
     */
    if (fOn) {
        xxxSendMenuSelect(pwndNotify, pwnd, pmenu, itemNumber);
    }

SeeYa:
    if (pwnd != pwndNotify) {
        ThreadUnlock(&tlpwnd);
    }

    return pItem;
}

/***************************************************************************\
* xxxDrawMenuBarTemp
*
* This is so the control panel can let us do the work -- and make their
* preview windows that much more accurate. The only reason I put the hwnd in
* here is because, in the low level menu routines, we assume that an hwnd is
* associated with the hmenu -- I didn't want to slow that code down by adding
* NULL checks.
*
* The SYSMET(CYMENU) with regard to the given font is returned -- this
* way control panel can say, "The user wants this menu font (hfont) with this
* menu height (lprc)", and we can respond "this is the height we ended up
* using."
*
* NOTE: It's OK to over-write lprc because this function receives a pointer
*       to the rectangle captured in NtUserDrawMenuBarTemp.
*
* History:
* 20-Sep-95     BradG       Ported from Win95 (inctlpan.c)
\***************************************************************************/
int xxxDrawMenuBarTemp(
    PWND    pwnd,
    HDC     hdc,
    LPRECT  lprc,
    PMENU   pMenu,
    HFONT   hfont)
{
    int          cyMenu;
    HFONT        hOldFont;
    HFONT        hFontSave;
    int          cxCharSave;
    int          cxOverhangSave;
    int          cyCharSave;
    int          cyLeadingSave;
    int          cyAscentSave;
    int          cySizeSave;
    PWND        pwndNotify;
    TL          tlpwndNotify;

    hFontSave       = ghMenuFont;
    cxCharSave      = gcxMenuFontChar;
    cxOverhangSave  = gcxMenuFontOverhang;
    cyCharSave      = gcyMenuFontChar;
    cyLeadingSave   = gcyMenuFontExternLeading;
    cyAscentSave    = gcyMenuFontAscent;
    cySizeSave      = SYSMET(CYMENUSIZE);

    CheckLock(pwnd);
    CheckLock(pMenu);

    ThreadLock(pMenu->spwndNotify, &tlpwndNotify);
    pwndNotify = pMenu->spwndNotify;

    cyMenu = lprc->bottom - lprc->top;

    if (hfont) {
        TEXTMETRIC  textMetrics;

        /*
         *  Compute the new menu font info if needed
         */
        ghMenuFont = hfont;
        hOldFont = GreSelectFont(HDCBITS(), ghMenuFont);
        gcxMenuFontChar = GetCharDimensions(
                HDCBITS(), &textMetrics, &gcyMenuFontChar);

        gcxMenuFontOverhang = textMetrics.tmOverhang;
        GreSelectFont(HDCBITS(), hOldFont);

        gcyMenuFontExternLeading = textMetrics.tmExternalLeading;
        gcyMenuFontAscent = textMetrics.tmAscent + SYSMET(CYBORDER);
    }

    cyMenu -= SYSMET(CYBORDER);
    cyMenu = max(cyMenu, (gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE)));
    SYSMET(CYMENUSIZE) = cyMenu;
    SYSMET(CYMENU) = cyMenu + SYSMET(CYBORDER);

    /*
     *  Compute the dimensons of the menu (hope that we don't leave the
     *  USER critical section)
     */
    xxxMenuBarCompute(pMenu, pwnd, lprc->top, lprc->left, lprc->right);

    /*
     *  Draw menu border in menu color
     */
    lprc->bottom = lprc->top + pMenu->cyMenu;
    FillRect(hdc, lprc, MNIsFlatMenu() ? SYSHBR(MENUBAR) : SYSHBR(MENU));

    /*
     *  Finally, draw the menu itself.
     */
    xxxMenuDraw(hdc, pMenu);

    /*
     *  Restore the old state
     */
    ghMenuFont              = hFontSave;
    gcxMenuFontChar          = cxCharSave;
    gcxMenuFontOverhang      = cxOverhangSave;
    gcyMenuFontChar          = cyCharSave;
    gcyMenuFontExternLeading = cyLeadingSave;
    gcyMenuFontAscent        = cyAscentSave;
    SYSMET(CYMENUSIZE)      = cySizeSave;

    cyMenu = SYSMET(CYMENU);
    SYSMET(CYMENU) = cySizeSave + SYSMET(CYBORDER);

    Lock(&pMenu->spwndNotify, pwndNotify);
    ThreadUnlock(&tlpwndNotify);

    return cyMenu;
}

/***************************************************************************\
* xxxDrawMenuBarUnderlines
*
* Description: Shows or hides all underlines on a menu bar.
*
* History:
* 07/23/96  vadimg      created
\***************************************************************************/
VOID xxxDrawMenuBarUnderlines(
    PWND pwnd,
    BOOL fShow)
{
    HDC hdc;
    PMENU pmenu;
    PITEM pitem;
    ULONG i, yTop, cyTemp;
    LPWSTR psz;
    WCHAR  szMenu[MENU_STRLEN], *pchOut;
    LONG result;
    HBRUSH hbr;
    TL tlpMenu;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    int xLeft;
    LPWSTR lpsz;
    SIZE extent;
    BOOL fFlatMenuBar;

    CheckLock(pwnd);

    /*
     * Bail if menu underlines are always on.
     */
    if (TEST_BOOL_ACCF(ACCF_KEYBOARDPREF) || TestEffectInvertUP(KEYBOARDCUES)
        || (GetAppCompatFlags2(VER40) & GACF2_KCOFF)) {
        return;
    }

    // if there is no menu, bail out right away

    pwnd = GetTopLevelWindow(pwnd);
    if (pwnd == NULL || !TestWF(pwnd, WFMPRESENT)) {
        return;
    }

    /*
     * We don't clear WFMPRESENT when the menu is unlocked so make sure we have
     * one.
     */
    pmenu = pwnd->spmenu;
    if (pmenu == NULL) {
        return;
    }

    if (MNIsFlatMenu()) {
        fFlatMenuBar = !TestMF(pmenu, MFISPOPUP);
    } else {
        fFlatMenuBar = FALSE;
    }


    /*
     * set/clear the underline state. There are cases when the
     *  menu loop doesn't remove the keys from the queue; so after
     *  exiting we might get here but nothing needs to be drawn
     */
    if (fShow) {
        if (TestMF(pmenu, MFUNDERLINE)) {
            return;
        }
        hbr = SYSHBR(MENUTEXT);
        SetMF(pmenu, MFUNDERLINE);
    } else {
        if (!TestMF(pmenu, MFUNDERLINE)) {
            return;
        }
        if (pmenu->hbrBack != NULL) {
            hbr = pmenu->hbrBack;
        } else if (fFlatMenuBar) {
            hbr = SYSHBR(MENUBAR);
        } else {
            hbr = SYSHBR(MENU);
        }
        ClearMF(pmenu, MFUNDERLINE);
    }

    pitem = (PITEM)pmenu->rgItems;

    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);

    // select in the correct brush and font

    GreSelectFont(hdc, ghMenuFont);

    ThreadLockMenuNoModify(pmenu, &tlpMenu);
    for (i = 0; i < pmenu->cItems; i++, pitem++) {
        if (((psz = TextPointer(pitem->lpstr)) == NULL)
                && !TestMFT(pitem, MFT_OWNERDRAW)) {
            continue;
        }

        if (TestMFT(pitem, MFT_OWNERDRAW)) {
            GreSetViewportOrg(hdc, 0, 0, NULL);
        } else {
            GreSetViewportOrg(hdc, pitem->xItem, pitem->yItem, NULL);
        }

        // this funky xLeft and yTop calculation stolen from RealDrawMenuItem

        yTop = gcyMenuFontExternLeading;
        cyTemp = pitem->cyItem - (gcyMenuFontChar + gcyMenuFontExternLeading +
                SYSMET(CYBORDER));
        if (cyTemp > 0) {
            yTop += (cyTemp / 2);
        }

        if (fShow && TestMFS(pitem, MFS_HOTTRACK)) {
            GreSelectBrush(hdc, SYSHBR(HOTLIGHT));
        } else {
            GreSelectBrush(hdc, hbr);
        }

        if (TestMFT(pitem, MFT_OWNERDRAW)) {
            xxxSendMenuDrawItemMessage(hdc, ODA_DRAWENTIRE, pmenu, pitem, FALSE, 0);
        } else {
            TL tl;

            if (pitem->cch > MENU_STRLEN) {
                pchOut = (WCHAR*)UserAllocPool((pitem->cch+1) * sizeof(WCHAR), TAG_RTL);
                if (pchOut == NULL) {
                    break;
                }
                ThreadLockPool(ptiCurrent, pchOut, &tl);
            } else {
                pchOut = szMenu;
            }

            xLeft = gcxMenuFontChar;

            if (TestMFT(pitem, MFT_RIGHTORDER) &&
                 ((lpsz  = TextPointer(pitem->lpstr)) != NULL))
            {
                xxxPSMGetTextExtent(hdc, lpsz, pitem->cch, &extent);
                xLeft += (pitem->cxItem - (gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE) - extent.cx);
            }

            if (CALL_LPK(ptiCurrent)) {
                if (!fShow) {
                    //Becuase PSMTextOut does not use PatBlt it uses ExtTextOut.
                    GreSetTextColor(hdc, fFlatMenuBar ? SYSRGB(MENUBAR) : SYSRGB(MENU));
                }
                xxxPSMTextOut(hdc, xLeft, yTop, psz, pitem->cch, DT_PREFIXONLY);

            } else {
                result = GetPrefixCount(psz, pitem->cch, pchOut, pitem->cch);
                xxxDrawItemUnderline(pitem, hdc, xLeft, yTop, pchOut,
                    LOWORD(result));
            }
            if (pchOut != szMenu) {
                    ThreadUnlockAndFreePool(ptiCurrent, &tl);
            }
        }
    }
    ThreadUnlockMenuNoModify(&tlpMenu);

    _ReleaseDC(hdc);
}

/***************************************************************************\
* xxxPaintMenuBar
*
* 3/8/2000  vadimg      created
\***************************************************************************/

UINT xxxPaintMenuBar(PWND pwnd, HDC hdc, int iLeftOffset, int iRightOffset,
        int iTopOffset, DWORD dwFlags)
{
    PMENU pMenu;
    UINT cyMenu, cxMenuMax;
    HBRUSH hbrOld, hbr;
    TL tlpMenu;

    CheckLock(pwnd);

    pMenu = (PMENU)pwnd->spmenu;
    if (pMenu == NULL) {
        return 0;
    }

    ThreadLockMenuNoModify(pMenu, &tlpMenu);

    /*
     * Figure out whether to paint it in active or inactive colors.
     */
    if (dwFlags & PMB_ACTIVE) {
        ClearMF(pMenu, MFINACTIVE);
    } else {
        SetMF(pMenu, MFINACTIVE);
    }

    /*
     * Calculate maximum available horizontal real estate.
     */
    cxMenuMax = ((pwnd->rcWindow.right - iRightOffset) -
            (pwnd->rcWindow.left + iLeftOffset));

    /*
     * If the menu has switched windows, or if either count is 0,
     * then we need to recompute the menu width.
     */
    if (pwnd != pMenu->spwndNotify || pMenu->cxMenu == 0 ||
            pMenu->cyMenu == 0) {
        xxxMenuBarCompute(pMenu, pwnd, iTopOffset, iLeftOffset, cxMenuMax);
    }

    if (pMenu->hbrBack) {
        hbr = pMenu->hbrBack;
    } else {
        hbr = SYSHBR(MENUBAR);
    }
    hbrOld = GreSelectBrush(hdc, hbr);
    GrePatBlt(hdc, iLeftOffset, iTopOffset, pMenu->cxMenu, pMenu->cyMenu, PATCOPY);

    /*
     * Finally draw the menu itself.
     */
    xxxMenuDraw(hdc, pMenu);
    GreSelectBrush(hdc, hbrOld);

    cyMenu = pMenu->cyMenu;
    ThreadUnlockMenuNoModify(&tlpMenu);
    return cyMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnloop.c ===
/**************************** Module Header ********************************\
* Module Name: mnloop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Modal Loop Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxMNRemoveMessage
*
* History
* 11/23/96  GerardoB  Created
\***************************************************************************/
BOOL xxxMNRemoveMessage (UINT message1, UINT message2)
{
    MSG msg;
    if (!xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_NOREMOVE)) {
        return FALSE;
    }

    if ((msg.message == message1) || (msg.message == message2)) {
        UserAssert(msg.message != 0);
        xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
        return TRUE;
    } else {
        return FALSE;
    }
}
/***************************************************************************\
* xxxHandleMenuMessages
*
* History:
\***************************************************************************/

BOOL xxxHandleMenuMessages(
    LPMSG lpmsg,
    PMENUSTATE pMenuState,
    PPOPUPMENU ppopupmenu)
{
    DWORD ch;
    ULONG_PTR cmdHitArea;
    UINT cmdItem;
    LPARAM lParam;
    BOOL fThreadLock = FALSE;
    TL tlpwndHitArea;
    TL tlpwndT;
    POINT pt;
    PWND pwnd;
    RECT rc;

    /*
     * Paranoia. Let's bail up front if we don't have a menu.
     * Some code checks for NULL spmenu, other parts assume it's always not NULL
     * Use RIP_ERROR for a while to make sure this is OK
     */
    if (ppopupmenu->spmenu == NULL) {
        RIPMSG2(RIP_ERROR, "xxxHandleMenuMessages NULL spmenu. pMenuSate:%p ppopupmenu:%p",
                pMenuState, ppopupmenu);
        return FALSE;
    }
    /*
     * Get things out of the structure so that we can access them quicker.
     */
    ch = (DWORD)lpmsg->wParam;
    lParam = lpmsg->lParam;

    /*
     * In this switch statement, we only look at messages we want to handle and
     * swallow.  Messages we don't understand will get translated and
     * dispatched.
     */
    switch (lpmsg->message) {
    case WM_RBUTTONDOWN:
    case WM_NCRBUTTONDOWN:

        if (ppopupmenu->fRightButton) {
            goto HandleButtonDown;
        }
        /*
         * Fall through
         */
    case WM_RBUTTONDBLCLK:
    case WM_NCRBUTTONDBLCLK:
        /*
         * Right click outside the menu dismisses the menu
         * (we didn't use to do this for single right clicks on 4.0)
         */
        pMenuState->mnFocus = MOUSEHOLD;
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));
        if (cmdHitArea == MFMWFP_OFFMENU) {
            xxxMNDismiss(pMenuState);
            return TRUE;
        }
        /*
         * Do nothing on right clicks on the menu
         */
        if (!pMenuState->fModelessMenu) {
            xxxMNRemoveMessage(lpmsg->message, 0);
        }
        return TRUE;

    case WM_LBUTTONDOWN:
    case WM_NCLBUTTONDOWN:
// Commented out due to TandyT whinings...
// if ((ppopupmenu->trackPopupMenuFlags & TPM_RIGHTBUTTON))
// break;

HandleButtonDown:

        /*
         * Find out where this mouse down occurred.
         */
        pMenuState->mnFocus = MOUSEHOLD;
        pMenuState->ptMouseLast.x = GET_X_LPARAM(lParam);
        pMenuState->ptMouseLast.y =  GET_Y_LPARAM(lParam);
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));


        /*
         * Thread lock this if it is a pwnd.  This certainly isn't the way
         * you'd implement this if you had locking to begin with.
         */
        fThreadLock = IsMFMWFPWindow(cmdHitArea);
        if (fThreadLock) {
            ThreadLock((PWND)cmdHitArea, &tlpwndHitArea);
        }

        /*
         * If this is a drag and drop menu, remember the mouse
         *  position and the hit test results.
         */
        if (pMenuState->fDragAndDrop) {
            pMenuState->ptButtonDown = pMenuState->ptMouseLast;
            pMenuState->uButtonDownIndex = cmdItem;
            LockMFMWFPWindow(&pMenuState->uButtonDownHitArea, cmdHitArea);
        }

        /*
         * Modeless menus don't capture the mouse so we might not see
         *  the button up. We also release capture when sending the
         *  WM_MENUDODRAGDROP message. So we want to remember what
         *  mouse button went down.
         */
        if (pMenuState->fDragAndDrop || pMenuState->fModelessMenu) {
            if (ch & MK_RBUTTON) {
                pMenuState->vkButtonDown = VK_RBUTTON;
            } else {
                pMenuState->vkButtonDown = VK_LBUTTON;
            }
        }


        if ((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) {
            //
            // Clicked in middle of nowhere, so terminate menus, and
            // let button pass through.
CancelOut:
            xxxMNDismiss(pMenuState);
            goto Unlock;
        } else if (ppopupmenu->fHasMenuBar && (cmdHitArea == MFMWFP_ALTMENU)) {
            //
            // Switching between menu bar & popup
            //
            xxxMNSwitchToAlternateMenu(ppopupmenu);
            cmdHitArea = MFMWFP_NOITEM;
        }

        if (cmdHitArea == MFMWFP_NOITEM) {
            //
            // On menu bar (system or main)
            //
            xxxMNButtonDown(ppopupmenu, pMenuState, cmdItem, TRUE);
        } else {
            // On popup window menu
            UserAssert(cmdHitArea);
            xxxSendMessage((PWND)cmdHitArea, MN_BUTTONDOWN, cmdItem, 0L);
        }

        /*
         * Swallow the message since we handled it.
         */
            /*
             * The excel guys change a wm_rbuttondown to a wm_lbuttondown message
             * in their message filter hook.  Remove the message here or we'll
             * get in a nasty loop.
             *
             * We need to swallow msg32.message ONLY.  It is possible for
             * the LBUTTONDOWN to not be at the head of the input queue.
             * If not, we will swallow a WM_MOUSEMOVE or something else like
             * that.  The reason Peek() doesn't need to check the range
             * is because we've already Peek(PM_NOYIELD'ed) before, which
             * locked the sys queue.
             */
        if (!pMenuState->fModelessMenu) {
            xxxMNRemoveMessage(lpmsg->message, WM_RBUTTONDOWN);
        }
        goto Unlock;

    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:

        /*
         * Is the user starting to drag?
         */
        if (pMenuState->fDragAndDrop
                && pMenuState->fButtonDown
                && !pMenuState->fDragging
                && !pMenuState->fButtonAlwaysDown
                && (pMenuState->uButtonDownHitArea != MFMWFP_OFFMENU)) {

            /*
             * We expect the mouse to go down on a menu item before a drag can start
             */
            UserAssert(!ppopupmenu->fFirstClick);

            /*
             * Calculate drag detect rectangle using the position the mouse went
             *  down on
             */
            *(LPPOINT)&rc.left = pMenuState->ptButtonDown;
            *(LPPOINT)&rc.right = pMenuState->ptButtonDown;
            InflateRect(&rc, SYSMET(CXDRAG), SYSMET(CYDRAG));

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            /*
             * If we've moved outside the drag rect, then the user is dragging
             */
            if (!PtInRect(&rc, pt)) {
                /*
                 * Post a message so we'll finish processing this message
                 *  and get out of here before telling the app that the user
                 *  is dragging
                 */
                pwnd = GetMenuStateWindow(pMenuState);
                if (pwnd != NULL) {
                    pMenuState->fDragging = TRUE;
                    _PostMessage(pwnd, MN_DODRAGDROP, 0, 0);
                } else {
                    RIPMSG0(RIP_ERROR, "xxxMNMouseMove. Unble to post MN_DODGRAGDROP");
                }
             }
        } /* if (pMenuState->fDragAndDrop */

        xxxMNMouseMove(ppopupmenu, pMenuState, MAKEPOINTS(lParam));
        return TRUE;

    case WM_RBUTTONUP:
    case WM_NCRBUTTONUP:
        if (ppopupmenu->fRightButton) {
            goto HandleButtonUp;
        }
        /*
         * If the button is down, simply swallow this message
         */
        if (pMenuState->fButtonDown) {
            if (!pMenuState->fModelessMenu) {
                xxxMNRemoveMessage(lpmsg->message, 0);
            }
            return TRUE;
        }
        // New feature for shell start menu -- notify when a right click
        // occurs on a menu item, and open a window of opportunity for
        // menus to recurse, allowing them to popup a context-sensitive
        // menu for that item.      (jeffbog 9/28/95)
        //
        // NOTE: Though this feature was added for Nashville, it was enabled
        // by default for all apps on Win2K and exhibited no app compat
        // problems. Thus, it is assumed that no version checking is required;
        // moreoever, changing at this point is needlessly dangerous.
        if ((lpmsg->message == WM_RBUTTONUP) && !ppopupmenu->fNoNotify) {
                PPOPUPMENU ppopupActive;

                if ((ppopupmenu->spwndActivePopup != NULL)
                        && (ppopupActive = ((PMENUWND)(ppopupmenu->spwndActivePopup))->ppopupmenu)
                        && MNIsItemSelected(ppopupActive))
                {
                    TL tlpwndNotify;
                    ThreadLock( ppopupActive->spwndNotify, &tlpwndNotify );
                    xxxSendMessage(ppopupActive->spwndNotify, WM_MENURBUTTONUP,
                            ppopupActive->posSelectedItem, (LPARAM)PtoH(ppopupActive->spmenu));
                    ThreadUnlock( &tlpwndNotify );
                }
            }
        break;

    case WM_LBUTTONUP:
    case WM_NCLBUTTONUP:
// Commented out due to TandyT whinings...
// if ((ppopupmenu->trackPopupMenuFlags & TPM_RIGHTBUTTON))
// break;

HandleButtonUp:
        if (!pMenuState->fButtonDown) {

            /*
             * Don't care about this mouse up since we never saw the button
             * down for some reason.
             */
            return TRUE;
        }

        /*
         * Cancel the dragging state, if any.
         */
        if (pMenuState->fDragAndDrop) {

            UnlockMFMWFPWindow(&pMenuState->uButtonDownHitArea);
            pMenuState->fDragging = FALSE;

            if (pMenuState->fIgnoreButtonUp) {
                pMenuState->fButtonDown =
                pMenuState->fIgnoreButtonUp = FALSE;
                return TRUE;
            }
        }

        /*
         * Find out where this mouse up occurred.
         */
        pMenuState->ptMouseLast.x = GET_X_LPARAM(lParam);
        pMenuState->ptMouseLast.y = GET_Y_LPARAM(lParam);
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));


        /*
         * If this is not true, some the code below won't work right.
         */
        UserAssert((cmdHitArea != MFMWFP_OFFMENU) || (cmdItem == 0));
        UserAssert(cmdHitArea != 0x0000FFFF);

        /*
         * Thread lock this if it is a pwnd.  This certainly isn't the way
         * you'd implement this if you had locking to begin with.
         */
        fThreadLock = IsMFMWFPWindow(cmdHitArea);
        if (fThreadLock) {
            ThreadLock((PWND)cmdHitArea, &tlpwndHitArea);
        }


        if (ppopupmenu->fHasMenuBar) {
            if (((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) ||
                    ((cmdHitArea == MFMWFP_NOITEM) && ppopupmenu->fIsSysMenu && ppopupmenu->fToggle))
                    // Button up occurred in some random spot.  Terminate
                    // menus and swallow the message.
                    goto CancelOut;
        } else {
            if ((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) {
                if (!ppopupmenu->fFirstClick) {
                    //
                    // User upclicked in some random spot. Terminate
                    // menus and don't swallow the message.
                    //

                    //
                    // Don't do anything with HWND here cuz the window is
                    // destroyed after this SendMessage().
                    //
//                    DONTREVALIDATE();
                    ThreadLock(ppopupmenu->spwndPopupMenu, &tlpwndT);
                    xxxSendMessage(ppopupmenu->spwndPopupMenu, MN_CANCELMENUS, 0, 0);
                    ThreadUnlock(&tlpwndT);
                    goto Unlock;
                }
            }

            ppopupmenu->fFirstClick = FALSE;
        }

        if (cmdHitArea == MFMWFP_NOITEM) {
            //
            // This is a system menu or a menu bar and the button up
            // occurred on the system menu or on a menu bar item.
            //
            xxxMNButtonUp(ppopupmenu, pMenuState, cmdItem, 0);
        } else if ((cmdHitArea != MFMWFP_OFFMENU) && (cmdHitArea != MFMWFP_ALTMENU)) {
            //
            // Warning:  It's common for the popup to go away during the
            // processing of this message, so don't add any code that
            // messes with hwnd after this call!
            //
//            DONTREVALIDATE();

            //
            // We send lParam (that has the mouse co-ords ) for the app
            // to get it in its SC_RESTORE/SC_MINIMIZE messages 3.0
            // compat
            //
            xxxSendMessage((PWND)cmdHitArea, MN_BUTTONUP, (DWORD)cmdItem, lParam);
        } else {
            pMenuState->fButtonDown =
            pMenuState->fButtonAlwaysDown = FALSE;
        }
Unlock:
        if (fThreadLock)
            ThreadUnlock(&tlpwndHitArea);
        return TRUE;


    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:

        // Commented out due to TandyT whinings...
        //        if (ppopup->fRightButton)
        //            break;
        pMenuState->mnFocus = MOUSEHOLD;
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));
        if ((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) {
                // Dbl-clicked in middle of nowhere, so terminate menus, and
                // let button pass through.
                xxxMNDismiss(pMenuState);
                return TRUE;
        } else if (ppopupmenu->fHasMenuBar && (cmdHitArea == MFMWFP_ALTMENU)) {
            //
            // BOGUS
            // TREAT LIKE BUTTON DOWN since we didn't dblclk on same item.
            //
            xxxMNSwitchToAlternateMenu(ppopupmenu);
            cmdHitArea =  MFMWFP_NOITEM;
        }

        if (cmdHitArea == MFMWFP_NOITEM)
            xxxMNDoubleClick(pMenuState, ppopupmenu, cmdItem);
        else {
            UserAssert(cmdHitArea);

            ThreadLock((PWND)cmdHitArea, &tlpwndHitArea);
            xxxSendMessage((PWND)cmdHitArea, MN_DBLCLK,
                    (DWORD)cmdItem, 0L);
            ThreadUnlock(&tlpwndHitArea);
        }
        return TRUE;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:

        /*
         * If mouse button is down, ignore keyboard input (fix #3899, IanJa)
         */
        if (pMenuState->fButtonDown && (ch != VK_F1)) {

            /*
             * Check if the user wants to cancel dragging.
             */
            if (pMenuState->fDragging && (ch == VK_ESCAPE)) {
                RIPMSG0(RIP_WARNING, "xxxHandleMenuMessages: ESC while dragging");
                pMenuState->fIgnoreButtonUp = TRUE;
            }

            return TRUE;
        }
        pMenuState->mnFocus = KEYBDHOLD;
        switch (ch) {
        case VK_UP:
        case VK_DOWN:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_RETURN:
        case VK_CANCEL:
        case VK_ESCAPE:
        case VK_MENU:
        case VK_F10:
        case VK_F1:
            if (ppopupmenu->spwndActivePopup) {
                ThreadLockAlways(ppopupmenu->spwndActivePopup, &tlpwndT);
                xxxSendMessage(ppopupmenu->spwndActivePopup, lpmsg->message,
                        ch, 0L);
                ThreadUnlock(&tlpwndT);
            } else {
                xxxMNKeyDown(ppopupmenu, pMenuState, (UINT)ch);
            }
            break;

        case VK_TAB:
            /*
             * People hit the ALT key now just to turn underlines ON in dialogs.
             * This throws them into "invisible menu mode". If they hit any char
             * at that point, we'll bail in xxxMNChar. But not so if they hit ctrl-tab,
             * which is used to navigate property sheets. So let's help them out.
             */
            if (ppopupmenu->fIsMenuBar && (ppopupmenu->spwndActivePopup == NULL)) {
                xxxMNDismiss(pMenuState);
                return TRUE;
            }
            /*
             * Fall through
             */

        default:
TranslateKey:
            if (!pMenuState->fModelessMenu) {
                xxxTranslateMessage(lpmsg, 0);
            }
            break;
        }
        return TRUE;

    case WM_CHAR:
    case WM_SYSCHAR:
        if (ppopupmenu->spwndActivePopup) {
            ThreadLockAlways(ppopupmenu->spwndActivePopup, &tlpwndT);
            xxxSendMessage(ppopupmenu->spwndActivePopup, lpmsg->message,
                        ch, 0L);
            ThreadUnlock(&tlpwndT);
        } else {
            xxxMNChar(ppopupmenu, pMenuState, (UINT)ch);
        }
        return TRUE;

    case WM_SYSKEYUP:

        /*
         * Ignore ALT and F10 keyup messages since they are handled on
         * the KEYDOWN message.
         */
        if (ch == VK_MENU || ch == VK_F10) {
            return TRUE;
        }

        /*
         ** fall thru **
         */

    case WM_KEYUP:

        /*
         * Do RETURNs on the up transition only
         */
        goto TranslateKey;

      case WM_SYSTIMER:

        /*
         * Prevent the caret from flashing by eating all WM_SYSTIMER messages.
         */
        return TRUE;

      default:
        break;
    }

#if DBG
    /*
     * Nobody should be able to steal capture from modal menus.
     */
    if (!pMenuState->fModelessMenu
            && !pMenuState->fInDoDragDrop
            && !ExitMenuLoop (pMenuState, ppopupmenu) ) {

        UserAssert(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED);
        UserAssert(PtiCurrent()->pq->spwndCapture == ppopupmenu->spwndNotify);
    }
#endif

    /*
     * We didn't handle this message
     */
    return FALSE;
}

/***************************************************************************\
* xxxEndMenuLoop
*
* Makes sure that the menu has been ended/canceled
*
* History:
* 10/25/96 GerardoB    Extracted from xxxMNLoop
\***************************************************************************/
void xxxEndMenuLoop (PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu)
{

    UserAssert(IsRootPopupMenu(ppopupmenu));

    if (ppopupmenu->fIsTrackPopup) {
        if (!ppopupmenu->fInCancel) {
            xxxMNDismiss(pMenuState);
        }
    } else {
        if (pMenuState->fUnderline) {
            TL tlpwnd;
            ThreadLock(ppopupmenu->spwndNotify, &tlpwnd);
            xxxDrawMenuBarUnderlines(ppopupmenu->spwndNotify, FALSE);
            ThreadUnlock(&tlpwnd);
        }
        if (!pMenuState->fInEndMenu) {
            xxxEndMenu(pMenuState);
        }
    }
    /*
     * If this is a modeless menu, make sure that the notification
     *  window caption is drawn in the proper state
     */
    if (pMenuState->fModelessMenu && (ppopupmenu->spwndNotify != NULL)) {
        PWND pwndNotify = ppopupmenu->spwndNotify;
        PTHREADINFO pti = GETPTI(pwndNotify);
        BOOL fFrameOn = (pti->pq == gpqForeground)
                            && (pti->pq->spwndActive == pwndNotify);
        TL tlpwndNotify;

        if (fFrameOn ^ !!TestWF(pwndNotify, WFFRAMEON)) {
            ThreadLockAlways(pwndNotify, &tlpwndNotify);
            xxxDWP_DoNCActivate(pwndNotify,
                                (fFrameOn ? NCA_ACTIVE : NCA_FORCEFRAMEOFF),
                                HRGN_FULL);
            ThreadUnlock(&tlpwndNotify);

        }
    }
}
/***************************************************************************\
* xxxMenuLoop
*
* The menu processing entry point.
* assumes: pMenuState->spwndMenu is the window which is the owner of the menu
* we are processing.
*
* History:
\***************************************************************************/

int xxxMNLoop(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    LPARAM lParam,
    BOOL fDblClk)
{
    int hit;
    MSG msg;
    BOOL fSendIdle = TRUE;
    BOOL fInQueue = FALSE;
    DWORD menuState;
    PTHREADINFO pti;
    TL tlpwndT;

    UserAssert(IsRootPopupMenu(ppopupmenu));

    pMenuState->fInsideMenuLoop = TRUE;
    pMenuState->cmdLast = 0;

    pti = PtiCurrent();

    pMenuState->ptMouseLast.x = pti->ptLast.x;
    pMenuState->ptMouseLast.y = pti->ptLast.y;

    /*
     * Set flag to false, so that we can track if windows have
     * been activated since entering this loop.
     */
    pti->pq->QF_flags &= ~QF_ACTIVATIONCHANGE;

    /*
     * Were we called from xxxMenuKeyFilter? If not, simulate a LBUTTONDOWN
     * message to bring up the popup.
     */
    if (!pMenuState->fMenuStarted) {
        if (_GetKeyState(((ppopupmenu->fRightButton) ?
                        VK_RBUTTON : VK_LBUTTON)) >= 0) {

            /*
             * We think the mouse button should be down but the call to get key
             * state says different so we need to get outta menu mode.  This
             * happens if clicking on the menu causes a sys modal message box to
             * come up before we can enter this stuff.  For example, run
             * winfile, click on drive a: to see its tree.  Activate some other
             * app, then open drive a: and activate winfile by clicking on the
             * menu.  This causes a sys modal msg box to come up just before
             * entering menu mode.  The user may have the mouse button up but
             * menu mode code thinks it is down...
             */

            /*
             * Need to notify the app we are exiting menu mode because we told
             * it we were entering menu mode just before entering this function
             * in xxxSysCommand()...
             */
            if (!ppopupmenu->fNoNotify) {
                ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
                xxxSendNotifyMessage(ppopupmenu->spwndNotify, WM_EXITMENULOOP,
                    ((ppopupmenu->fIsTrackPopup && !ppopupmenu->fIsSysMenu) ? TRUE : FALSE), 0);
                ThreadUnlock(&tlpwndT);
            }
            goto ExitMenuLoop;
        }

        /*
         * Simulate a WM_LBUTTONDOWN message.
         */
        if (!ppopupmenu->fIsTrackPopup) {

            /*
             * For TrackPopupMenus, we do it in the TrackPopupMenu function
             * itself so we don't want to do it again.
             */
            if (!xxxMNStartMenu(ppopupmenu, MOUSEHOLD)) {
                goto ExitMenuLoop;
            }
        }

        if ((ppopupmenu->fRightButton)) {
            msg.message = (fDblClk ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN);
            msg.wParam = MK_RBUTTON;
        } else {
            msg.message = (fDblClk ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN);
            msg.wParam = MK_LBUTTON;
        }
        msg.lParam = lParam;
        msg.hwnd = HW(ppopupmenu->spwndPopupMenu);
        xxxHandleMenuMessages(&msg, pMenuState, ppopupmenu);
     }

    /*
     * If this is a modeless menu, release capture, mark it in the menu state
     *   and return. Decrement foreground lock count.
     */
     if (pMenuState->fModelessMenu) {
         xxxMNReleaseCapture();

         DecSFWLockCount();
         DBGDecModalMenuCount();
         return 0;
     }

    while (pMenuState->fInsideMenuLoop) {

        /*
         * Is a message waiting for us?
         */
        BOOL fPeek = xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_NOREMOVE);

        Validateppopupmenu(ppopupmenu);

        if (fPeek) {
            /*
             * Bail if we have been forced out of menu loop
             */
            if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                goto ExitMenuLoop;
            }

            /*
             * Since we could have blocked in xxxWaitMessage (see last line
             * of loop) or xxxPeekMessage, reset the cached copy of
             * ptiCurrent()->pq: It could have changed if someone did a
             * DetachThreadInput() while we were away.
             */
            if ((!ppopupmenu->fIsTrackPopup &&
                    pti->pq->spwndActive != ppopupmenu->spwndNotify &&
                    ((pti->pq->spwndActive == NULL) || !_IsChild(pti->pq->spwndActive, ppopupmenu->spwndNotify)))) {

                /*
                 * End menu processing if we are no longer the active window.
                 * This is needed in case a system modal dialog box pops up
                 * while we are tracking the menu code for example.  It also
                 * helps out Tracer if a macro is executed while a menu is down.
                 */

                /*
                 * Also, end menu processing if we think the mouse button is
                 * down but it really isn't.  (Happens if a sys modal dialog int
                 * time dlg box comes up while we are in menu mode.)
                 */

                goto ExitMenuLoop;
            }

            if (ppopupmenu->fIsMenuBar && msg.message == WM_LBUTTONDBLCLK) {

                /*
                 * Was the double click on the system menu or caption?
                 */
                hit = FindNCHit(ppopupmenu->spwndNotify, (LONG)msg.lParam);
                if (hit == HTCAPTION) {
                    PWND pwnd;
                    PMENU pmenu;

                    /*
                     * Get the message out of the queue since we're gonna
                     * process it.
                     */
                    xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
                    if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                        goto ExitMenuLoop;
                    } else {
                        pwnd = ppopupmenu->spwndNotify;
                        ThreadLockAlways(pwnd, &tlpwndT);
                        pmenu = xxxGetSysMenuHandle(pwnd);
                        UserAssert(pwnd == ppopupmenu->spwndNotify);

                        menuState = _GetMenuState(pmenu, SC_RESTORE & 0x0000FFF0,
                                MF_BYCOMMAND);

                        /*
                         * Only send the sys command if the item is valid.  If
                         * the item doesn't exist or is disabled, then don't
                         * post the syscommand.  Note that for win2 apps, we
                         * always send the sys command if it is a child window.
                         * This is so hosebag apps can change the sys menu.
                         */
                        if (!(menuState & MFS_GRAYED)) {
                            _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                        }

                        /*
                         * Get out of menu mode.
                         */
                        ThreadUnlock(&tlpwndT);
                        goto ExitMenuLoop;
                    }
                }
            }

            fInQueue = (msg.message == WM_LBUTTONDOWN ||
                        msg.message == WM_RBUTTONDOWN ||
                        msg.message == WM_NCLBUTTONDOWN ||
                        msg.message == WM_NCRBUTTONDOWN);

            if (!fInQueue) {

                /*
                 * Note that we call xxxPeekMessage() with the filter
                 * set to the message we got from xxxPeekMessage() rather
                 * than simply 0, 0.  This prevents problems when
                 * xxxPeekMessage() returns something like a WM_TIMER,
                 * and after we get here to remove it a WM_LBUTTONDOWN,
                 * or some higher-priority input message, gets in the
                 * queue and gets removed accidently.  Basically we want
                 * to be sure we remove the right message in this case.
                 * NT bug 3852 was caused by this problem.
                 * Set the TIF_IGNOREPLAYBACKDELAY bit in case journal playback
                 * is happening: this allows us to proceed even if the hookproc
                 * incorrectly returns a delay now.  The bit will be cleared if
                 * this happens, so we can see why the Peek-Remove below fails.
                 * Lotus' Freelance Graphics tutorial does such bad journalling
                 */

                pti->TIF_flags |= TIF_IGNOREPLAYBACKDELAY;
                if (!xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE)) {
                    if (pti->TIF_flags & TIF_IGNOREPLAYBACKDELAY) {
                        pti->TIF_flags &= ~TIF_IGNOREPLAYBACKDELAY;
                        /*
                         * It wasn't a bad journal playback: something else
                         * made the previously peeked message disappear before
                         * we could peek it again to remove it.
                         */
                        RIPMSG1(RIP_WARNING, "Disappearing msg 0x%08lx", msg.message);
                        goto NoMsg;
                    }
                }
                pti->TIF_flags &= ~TIF_IGNOREPLAYBACKDELAY;
            }

            if (!_CallMsgFilter(&msg, MSGF_MENU)) {
                if (!xxxHandleMenuMessages(&msg, pMenuState, ppopupmenu)) {
                    xxxTranslateMessage(&msg, 0);
                    xxxDispatchMessage(&msg);
                }

                Validateppopupmenu(ppopupmenu);

                if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                    goto ExitMenuLoop;
                }

                if (pti->pq->QF_flags & QF_ACTIVATIONCHANGE) {

                    /*
                     * Run away and exit menu mode if another window has become
                     * active while a menu was up.
                     */
                    RIPMSG0(RIP_WARNING, "Exiting menu mode: another window activated");
                    goto ExitMenuLoop;
                }

#if DBG
                /*
                 * Nobody should be able to steal capture from us.
                 */
                if (!pMenuState->fInDoDragDrop) {
                    UserAssert(pti->pq->QF_flags & QF_CAPTURELOCKED);
                    UserAssert(pti->pq->spwndCapture == ppopupmenu->spwndNotify);
                }
#endif

                /*
                 * If we get a system timer, then it's like we're idle
                 */
                if (msg.message == WM_SYSTIMER) {
                    goto NoMsg;
                }

                /*
                 * Don't set fSendIdle if we got these messages
                 */
                if ((msg.message == WM_TIMER) || (msg.message == WM_PAINT)) {
                    continue;
                }

            } else {
                if (fInQueue)
                    xxxPeekMessage(&msg, NULL, msg.message, msg.message,
                            PM_REMOVE);
            }

            /*
             * Reenable WM_ENTERIDLE messages.
             */
            fSendIdle = TRUE;

        } else {
NoMsg:
            /*
             * Bail if we have been forced out of menu loop
             */
            if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                goto ExitMenuLoop;
            }

            UserAssert((ppopupmenu->spwndActivePopup == NULL)
                    || (TestWF(ppopupmenu->spwndActivePopup, WFVISIBLE)));


            /*
             * If a hierarchical popup has been destroyed, this is a
             *  good time to flush ppmDelayedFree
             */
            if (ppopupmenu->fFlushDelayedFree) {
                MNFlushDestroyedPopups (ppopupmenu, FALSE);
                ppopupmenu->fFlushDelayedFree = FALSE;
            }

            /*
             * We need to send the WM_ENTERIDLE message only the first time
             * there are no messages for us to process.  Subsequent times we
             * need to yield via WaitMessage().  This will allow other tasks to
             * get some time while we have a menu down.
             */
            if (fSendIdle) {
                if (ppopupmenu->spwndNotify != NULL) {
                    ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndT);
                    xxxSendMessage(ppopupmenu->spwndNotify, WM_ENTERIDLE, MSGF_MENU,
                        (LPARAM)HW(ppopupmenu->spwndActivePopup));
                    ThreadUnlock(&tlpwndT);
                }
                fSendIdle = FALSE;
            } else {
                /*
                 * If we're animating, sleep only 1 ms to reduce the chance
                 *  of jerky animation.
                 * When not animating, this is the same as a xxxWaitMessage call
                 */
#ifdef MESSAGE_PUMP_HOOK
                xxxWaitMessageEx(QS_ALLINPUT | QS_EVENT, pMenuState->hdcWndAni != NULL);
#else
                xxxSleepThread(QS_ALLINPUT | QS_EVENT, (pMenuState->hdcWndAni != NULL), TRUE);
#endif
            }

        } /* if (PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD)) else */

    } /* end while (fInsideMenuLoop) */



ExitMenuLoop:
    pMenuState->fInsideMenuLoop = FALSE;
    pMenuState->fModelessMenu = FALSE;

    /*
     * Make sure that the menu has been ended/canceled
     */
    xxxEndMenuLoop (pMenuState, ppopupmenu);

    xxxMNReleaseCapture();

    // Throw in an extra peek here when we exit the menu loop to ensure that the input queue
    // for this thread gets unlocked if there is no more input left for him.
    xxxPeekMessage(&msg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, PM_NOYIELD | PM_NOREMOVE);
    return(pMenuState->cmdLast);
} /* xxxMenuLoop() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnstate.c ===
/**************************** Module Header ********************************\
* Module Name: mnstate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu State Routines
*
* History:
*  10-10-90 JimA      Cleanup.
*  03-18-91 IanJa     Windowrevalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PMENU xxxGetInitMenuParam(PWND pwndMenu, BOOL *lpfSystem);

/***************************************************************************\
* MNPositionSysMenu
*
* History:
* 4-25-91 Mikehar Port for 3.1 merge
\***************************************************************************/
VOID MNPositionSysMenu(
    PWND pwnd,
    PMENU pmenusys)
{
    RECT rc;
    PITEM pItem;

    if (pmenusys == NULL) {
        RIPERR0(ERROR_INVALID_HANDLE,
                RIP_WARNING,
                "Invalid menu handle pmenusys (NULL) to MNPositionSysMenu");

        return;
    }

    /*
     * Whoever positions the menu becomes the owner
     */
    if (pwnd != pmenusys->spwndNotify) {
        Lock(&pmenusys->spwndNotify, pwnd);
    }

    /*
     * Setup the SysMenu hit rectangle.
     */
    rc.top = rc.left = 0;

    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        rc.right = SYSMET(CXSMSIZE);
        rc.bottom = SYSMET(CYSMSIZE);
    } else {
        rc.right = SYSMET(CXSIZE);
        rc.bottom = SYSMET(CYSIZE);
    }

    if (!TestWF(pwnd, WFMINIMIZED)) {
        int cBorders;

        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        OffsetRect(&rc, cBorders*SYSMET(CXBORDER), cBorders*SYSMET(CYBORDER));
    }

    /*
     * Offset the System popup menu.
     */
    if (!TestMF(pmenusys, MF_POPUP) && (pmenusys->cItems > 0)) {
        pItem = pmenusys->rgItems;
        if (pItem) {
            pItem->yItem = rc.top;
            pItem->xItem = rc.left;
            pItem->cyItem = rc.bottom - rc.top;
            pItem->cxItem = rc.right - rc.left;
        }
    } else {
        // BOGUS -- MF_POPUP should never be set on a MENU -- only a MENU ITEM
        RIPMSG1(RIP_ERROR, "pmenu %#p has MF_POPUP set or 0 items", pmenusys);
    }
}

/***************************************************************************\
* MNFlushDestroyedPopups
*
* Walk the ppmDelayedFree list freeing those marked as destroyed.
*
* 05-14-96 GerardoB  Created
\***************************************************************************/
VOID MNFlushDestroyedPopups(
    PPOPUPMENU ppopupmenu,
    BOOL fUnlock)
{
    PPOPUPMENU ppmDestroyed, ppmFree;

    UserAssert(IsRootPopupMenu(ppopupmenu));

    /*
     * Walk ppmDelayedFree
     */
    ppmDestroyed = ppopupmenu;
    while (ppmDestroyed->ppmDelayedFree != NULL) {
        /*
         * If it's marked as destroyed, unlink it and free it
         */
        if (ppmDestroyed->ppmDelayedFree->fDestroyed) {
            ppmFree = ppmDestroyed->ppmDelayedFree;
            ppmDestroyed->ppmDelayedFree = ppmFree->ppmDelayedFree;
            UserAssert(ppmFree != ppmFree->ppopupmenuRoot);
            MNFreePopup(ppmFree);
        } else {
            /*
             * fUnlock is TRUE if the root popup is being destroyed; if
             * so, reset fDelayedFree and unlink it.
             */
            if (fUnlock) {
                /*
                 * This means that the root popup is going away before
                 * some of the hierarchical popups have been destroyed.
                 *
                 * This can happen if someone destroys one of the menu
                 * windows breaking the spwndNextPopup chain.
                 */
                ppmDestroyed->ppmDelayedFree->fDelayedFree = FALSE;

                /*
                 * Stop here so we can figure how this happened.
                 */
                UserAssert(ppmDestroyed->ppmDelayedFree->fDelayedFree);
                ppmDestroyed->ppmDelayedFree = ppmDestroyed->ppmDelayedFree->ppmDelayedFree;
            } else {
                /*
                 * Not fDestroyed so move to the next one.
                 */
                ppmDestroyed = ppmDestroyed->ppmDelayedFree;
            }
        }
    }
}

/***************************************************************************\
* MNAllocPopup
*
\***************************************************************************/
PPOPUPMENU MNAllocPopup(
    BOOL fForceAlloc)
{
    PPOPUPMENU ppm;

    if (!fForceAlloc && !TEST_PUDF(PUDF_POPUPINUSE)) {
        SET_PUDF(PUDF_POPUPINUSE);
        ppm = &gpopupMenu;
    } else {
        ppm = (PPOPUPMENU)UserAllocPoolWithQuota(sizeof(POPUPMENU), TAG_POPUPMENU);
    }

    if (ppm) {
        RtlZeroMemory(ppm, sizeof(POPUPMENU));
    }

    return ppm;
}

/***************************************************************************\
* MNFreePopup
*
\***************************************************************************/
VOID MNFreePopup(
    PPOPUPMENU ppopupmenu)
{
    Validateppopupmenu(ppopupmenu);

    if (IsRootPopupMenu(ppopupmenu)) {
        MNFlushDestroyedPopups(ppopupmenu, TRUE);
    }

    if (ppopupmenu->spwndPopupMenu &&
        GETFNID(ppopupmenu->spwndPopupMenu) == FNID_MENU &&
        ppopupmenu != &gpopupMenu) {
        ((PMENUWND)ppopupmenu->spwndPopupMenu)->ppopupmenu = NULL;
    }

    Unlock(&ppopupmenu->spwndPopupMenu);
    /*
     * If spwndNextPopup is not NULL, we're breaking the chain and spwndNext
     * won't get closed. I won't remove the unlock since it has always been
     * there.
     */
    UserAssert(ppopupmenu->spwndNextPopup == NULL);
    Unlock(&ppopupmenu->spwndNextPopup);

    Unlock(&ppopupmenu->spwndPrevPopup);
    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenu);
    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate);
    Unlock(&ppopupmenu->spwndNotify);
    Unlock(&ppopupmenu->spwndActivePopup);

#if DBG
    ppopupmenu->fFreed = TRUE;
#endif

    if (ppopupmenu == &gpopupMenu) {
        UserAssert(TEST_PUDF(PUDF_POPUPINUSE));
        CLEAR_PUDF(PUDF_POPUPINUSE);
    } else {
        UserFreePool(ppopupmenu);
    }
}

/***************************************************************************\
* MNEndMenuStateNotify
*
* spwndNotify might have been created by a thread other than the one
* the menu mode is running on. If this is the case, this function
* NULLs out pMenuState for the thread that owns spwndNotify.
*
* It returns TRUE if the menu state owner doesn't own the notification
* window (multiple threads involved).
*
* 05-21-96 GerardoB Created
\***************************************************************************/
BOOL MNEndMenuStateNotify(
    PMENUSTATE pMenuState)
{
    PTHREADINFO ptiNotify;

    if (pMenuState->pGlobalPopupMenu->spwndNotify != NULL) {
        ptiNotify = GETPTI(pMenuState->pGlobalPopupMenu->spwndNotify);
        if (ptiNotify != pMenuState->ptiMenuStateOwner) {
            /*
             * Later5.0 GerardoB. xxxMNStartMenuState no longer allows this.
             *  This is dead code that I'll remove eventually
             */
            UserAssert(ptiNotify == pMenuState->ptiMenuStateOwner);

            UserAssert(ptiNotify->pMenuState == pMenuState);
            UserAssert(pMenuState->pmnsPrev == NULL);
            ptiNotify->pMenuState = NULL;
            return TRUE;
        }
    }

    return FALSE;
}

/***************************************************************************\
* xxxMNEndMenuState
*
* This funtion must be called to clean up pMenuState after getting out
* of menu mode. It must be called by the same thread that initialized
* pMenuState either manually or by calling xxxMNStartMenuState.
*
* 05-20-96 GerardoB Created
\***************************************************************************/
VOID xxxMNEndMenuState(
    BOOL fFreePopup)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PMENUSTATE pMenuState;
    pMenuState = ptiCurrent->pMenuState;
    UserAssert(ptiCurrent->pMenuState != NULL);
    UserAssert(ptiCurrent == pMenuState->ptiMenuStateOwner);

    /*
     * If the menu is locked, someone doesn't want it to go just yet.
     */
    if (pMenuState->dwLockCount != 0) {
        RIPMSG1(RIP_WARNING, "xxxMNEndMenuState Locked:%#p", pMenuState);
        return;
    }

    MNEndMenuStateNotify(pMenuState);

    /*
     * pMenuState->pGlobalPopupMenu could be NULL if xxxMNAllocMenuState failed
     */
    if (pMenuState->pGlobalPopupMenu != NULL) {
        if (fFreePopup) {
            UserAssert(pMenuState->pGlobalPopupMenu->fIsMenuBar || pMenuState->pGlobalPopupMenu->fDestroyed);

            MNFreePopup(pMenuState->pGlobalPopupMenu);
        } else {
            /*
             * This means that we're ending the menustate but the popup menu
             *  window is still around. This can happen when called from
             *  xxxDestroyThreadInfo.
             */
            UserAssert(pMenuState->pGlobalPopupMenu->fIsTrackPopup);
            pMenuState->pGlobalPopupMenu->fDelayedFree = FALSE;
        }
    }

    /*
     * Unlock MFMWFP windows.
     */
    UnlockMFMWFPWindow(&pMenuState->uButtonDownHitArea);
    UnlockMFMWFPWindow(&pMenuState->uDraggingHitArea);

    /*
     * Restore the previous state, if any
     */
    ptiCurrent->pMenuState = pMenuState->pmnsPrev;

    /*
     * This (modal) menu mode is off
     */
    if (!pMenuState->fModelessMenu) {
        DecSFWLockCount();
        DBGDecModalMenuCount();
    }

    if (pMenuState->hbmAni != NULL) {
        MNDestroyAnimationBitmap(pMenuState);
    }

    /*
     * Free the menu state
     */
    if (pMenuState == &gMenuState) {
        UserAssert(TEST_PUDF(PUDF_MENUSTATEINUSE));
        CLEAR_PUDF(PUDF_MENUSTATEINUSE);
        GreSetDCOwner(gMenuState.hdcAni, OBJECT_OWNER_PUBLIC);
    } else {
        if (pMenuState->hdcAni != NULL) {
            GreDeleteDC(pMenuState->hdcAni);
        }
        UserFreePool(pMenuState);
    }

    /*
     * If returning to a modeless menu, make sure we have activation.
     * If returning to a modal menu, make sure we have capture.
     */
   if (ptiCurrent->pMenuState != NULL) {
       if (ptiCurrent->pMenuState->fModelessMenu) {
           xxxActivateThisWindow(ptiCurrent->pMenuState->pGlobalPopupMenu->spwndActivePopup,
                                 0, 0);
       } else {
           xxxMNSetCapture(ptiCurrent->pMenuState->pGlobalPopupMenu);
       }
   }

#if DBG
   /*
    * No pti should point to this pMenuState anymore.
    * If guModalMenuStateCount is zero, all pMenuState must be NULL or
    * modeless.
    */
    {
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO ptiT;

    pHead = &(ptiCurrent->rpdesk->PtiList);
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
       ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
       UserAssert(ptiT->pMenuState != pMenuState);
       if (guModalMenuStateCount == 0) {
           UserAssert(ptiT->pMenuState == NULL || ptiT->pMenuState->fModelessMenu);
       }
    }
    }
#endif
}

/***************************************************************************\
* MNCreateAnimationBitmap
*
\***************************************************************************/
BOOL MNCreateAnimationBitmap(
    PMENUSTATE pMenuState,
    UINT cx,
    UINT cy)
{
    HBITMAP hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy);
    if (hbm == NULL) {
        RIPMSG0(RIP_WARNING, "MNSetupAnimationBitmap: Failed to create hbmAni");
        return FALSE;
    }

#if DBG
    if (pMenuState->hdcAni == NULL) {
        RIPMSG0(RIP_WARNING, "MNCreateAnimationBitmap: hdcAni is NULL");
    }
    if (pMenuState->hbmAni != NULL) {
        RIPMSG0(RIP_WARNING, "MNCreateAnimationBitmap: hbmAni already exists");
    }
#endif // DBG

    GreSelectBitmap(pMenuState->hdcAni, hbm);
    pMenuState->hbmAni = hbm;
    return TRUE;
}

/***************************************************************************\
* MNDestroyAnimationBitmap
*
\***************************************************************************/
VOID MNDestroyAnimationBitmap(
    PMENUSTATE pMenuState)
{
    GreSelectBitmap(pMenuState->hdcAni, GreGetStockObject(PRIV_STOCK_BITMAP));
    UserVerify(GreDeleteObject(pMenuState->hbmAni));
    pMenuState->hbmAni = NULL;
}

/***************************************************************************\
* MNSetupAnimationDC
*
* 9/20/96 GerardoB      Created
\***************************************************************************/
BOOL MNSetupAnimationDC(
    PMENUSTATE pMenuState)
{
    pMenuState->hdcAni = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
    if (pMenuState->hdcAni == NULL) {
        RIPMSG0(RIP_WARNING, "MNSetupAnimationDC: Failed to create hdcAnimate");
        UserAssert(pMenuState != &gMenuState);
        return FALSE;
    }
    GreSelectFont(pMenuState->hdcAni, ghMenuFont);
    return TRUE;
}

/***************************************************************************\
* xxxUnlockMenuState
*
* 11/24/96 GerardoB      Created
\***************************************************************************/
BOOL xxxUnlockMenuState(
    PMENUSTATE pMenuState)
{
    UserAssert(pMenuState->dwLockCount != 0);

    (pMenuState->dwLockCount)--;
    if ((pMenuState->dwLockCount == 0) && ExitMenuLoop(pMenuState, pMenuState->pGlobalPopupMenu)) {
        xxxMNEndMenuState(TRUE);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxMNAllocMenuState
*
* Allocates and initializes a pMenuState.
*
* 5-21-96 GerardoB      Created
\***************************************************************************/
PMENUSTATE xxxMNAllocMenuState(
    PTHREADINFO ptiCurrent,
    PTHREADINFO ptiNotify,
    PPOPUPMENU ppopupmenuRoot)
{
    BOOL fAllocate;
    PMENUSTATE pMenuState;

    UserAssert(PtiCurrent() == ptiCurrent);
    UserAssert(ptiCurrent->rpdesk == ptiNotify->rpdesk);

    /*
     * If gMenuState is already taken, allocate one.
     */
    fAllocate = TEST_PUDF(PUDF_MENUSTATEINUSE);
    if (fAllocate) {
        pMenuState = (PMENUSTATE)UserAllocPoolWithQuota(sizeof(MENUSTATE), TAG_MENUSTATE);
        if (pMenuState == NULL) {
            return NULL;
        }
    } else {
        /*
         * Use chache global which already has the animation DC setup
         */
        SET_PUDF(PUDF_MENUSTATEINUSE);
        pMenuState = &gMenuState;
        UserAssert(gMenuState.hdcAni != NULL);
        GreSetDCOwner(gMenuState.hdcAni, OBJECT_OWNER_CURRENT);
    }

    /*
     * Prevent anyone from changing the foreground while this menu is active
     */
    IncSFWLockCount();
    DBGIncModalMenuCount();

    /*
     * Initialize pMenuState.
     * Animation DC stuff is already setup so don't zero init it.
     */
    RtlZeroMemory(pMenuState, sizeof(MENUSTATE) - sizeof(MENUANIDC));
    pMenuState->pGlobalPopupMenu = ppopupmenuRoot;
    pMenuState->ptiMenuStateOwner = ptiCurrent;

    /*
     * Save previous state, if any. Then set new state.
     */
    pMenuState->pmnsPrev = ptiCurrent->pMenuState;
    ptiCurrent->pMenuState = pMenuState;

    if (ptiNotify != ptiCurrent) {
        UserAssert(ptiNotify->pMenuState == NULL);
        ptiNotify->pMenuState = pMenuState;
    }

    /*
     * If the menustate was allocated, set up animation stuff.
     * This is done here because in case of failure, MNEndMenuState
     * will find ptiCurrent->pMenuState properly.
     */
    if (fAllocate) {
        RtlZeroMemory((PBYTE)pMenuState + sizeof(MENUSTATE) -
                sizeof(MENUANIDC), sizeof(MENUANIDC));
        if (!MNSetupAnimationDC(pMenuState)) {
            xxxMNEndMenuState(TRUE);
            return NULL;
        }
    }

    return pMenuState;
}

/***************************************************************************\
* xxxMNStartMenuState
*
* This function is called when the menu bar is about to be activated (the
*  app's main menu). It makes sure that the threads involved are not in
*  menu mode already, finds the owner/notification window, initializes
*  pMenuState and sends the WM_ENTERMENULOOP message.
* It successful, it returns a pointer to a pMenuState. If so, the caller
*  must call MNEndMenuState when done.
*
* History:
* 4-25-91 Mikehar       Port for 3.1 merge
* 5-20-96 GerardoB      Renamed and changed (Old name: xxxMNGetPopup)
\***************************************************************************/
PMENUSTATE xxxMNStartMenuState(
    PWND pwnd,
    DWORD cmd,
    LPARAM lParam)
{
    PPOPUPMENU ppopupmenu;
    PTHREADINFO ptiCurrent, ptiNotify;
    PMENUSTATE pMenuState;
    TL tlpwnd;
    PWND pwndT;

    CheckLock(pwnd);

    /*
     * Bail if the current thread is already in menu mode
     */
    ptiCurrent = PtiCurrent();
    if (ptiCurrent->pMenuState != NULL) {
        return NULL;
    }

    /*
     * If pwnd is not owned by ptiCurrent, the _PostMessage call below might
     *  send us in a loop
     */
    UserAssert(ptiCurrent == GETPTI(pwnd));

    /*
     * If this is not a child window, use the active window on its queue
     */
    if (!TestwndChild(pwnd)) {
        pwnd = GETPTI(pwnd)->pq->spwndActive;
    } else {
        /*
         * Search up the parents for a window with a System Menu.
         */
        while (TestwndChild(pwnd)) {
            if (TestWF(pwnd, WFSYSMENU)) {
                break;
            }
            pwnd = pwnd->spwndParent;
        }
    }

    if (pwnd == NULL) {
        return NULL;
    }

    if (!TestwndChild(pwnd) && (pwnd->spmenu != NULL)) {
        goto hasmenu;
    }

    if (!TestWF(pwnd, WFSYSMENU)) {
        return NULL;
    }

hasmenu:

    /*
     * If the owner/notification window was created by another thread,
     * make sure that it's not in menu mode already
     * This can happen if PtiCurrent() is attached to other threads, one of
     * which created pwnd.
     */
    ptiNotify = GETPTI(pwnd);
    if (ptiNotify->pMenuState != NULL) {
        return NULL;
    }

    /*
     * If the notification window is owned by another thread,
     * then the menu loop wouldn't get any keyboard or mouse
     * messages because we set capture to the notification window.
     * So we pass the WM_SYSCOMMAND to that thread and bail
     */
    if (ptiNotify != ptiCurrent) {
        RIPMSG2(RIP_WARNING, "Passing WM_SYSCOMMAND SC_*MENU from thread %#p to %#p", ptiCurrent, ptiNotify);
        _PostMessage(pwnd, WM_SYSCOMMAND, cmd, lParam);
        return NULL;
    }

    /*
     * Allocate ppoupmenu and pMenuState.
     */
    ppopupmenu = MNAllocPopup(FALSE);
    if (ppopupmenu == NULL) {
        return NULL;
    }

    pMenuState = xxxMNAllocMenuState(ptiCurrent, ptiNotify, ppopupmenu);
    if (pMenuState == NULL) {
        MNFreePopup(ppopupmenu);
        return NULL;
    }

    ppopupmenu->fIsMenuBar = TRUE;
    ppopupmenu->fHasMenuBar = TRUE;
    Lock(&(ppopupmenu->spwndNotify), pwnd);
    ppopupmenu->posSelectedItem = MFMWFP_NOITEM;
    Lock(&(ppopupmenu->spwndPopupMenu), pwnd);
    ppopupmenu->ppopupmenuRoot = ppopupmenu;

    pwndT = pwnd;
    while(TestwndChild(pwndT))
        pwndT = pwndT->spwndParent;

    if (pwndT->spmenu) {
        ppopupmenu->fRtoL = TestMF(pwndT->spmenu, MFRTL) ?TRUE:FALSE;
    } else {
        //
        // No way to know, no menu, but there is a system menu. Thus arrow
        // keys are really not important. However lets take the next best
        // thing just to be safe.
        //
        ppopupmenu->fRtoL = TestWF(pwnd, WEFRTLREADING) ?TRUE :FALSE;
    }

    /*
     * Notify the app we are entering menu mode. wParam is always 0 since this
     * procedure will only be called for menu bar menus not TrackPopupMenu
     * menus.
     */
    ThreadLockAlways(pwnd, &tlpwnd);
    xxxSendMessage(pwnd, WM_ENTERMENULOOP, 0, 0);
    ThreadUnlock(&tlpwnd);

    return pMenuState;
}


/***************************************************************************\
* xxxMNStartMenu
*
* Note that this function calls back many times so we might be forced
* out of menu mode at any time. We don't want to check this after
* each callback so we lock what we need and go on. Be careful.
*
* History:
* 4-25-91 Mikehar Port for 3.1 merge
\***************************************************************************/
BOOL xxxMNStartMenu(
    PPOPUPMENU ppopupmenu,
    int mn)
{
    PWND pwndMenu;
    PMENU pMenu;
    PMENUSTATE pMenuState;
    TL tlpwndMenu;
    TL tlpMenu;

    UserAssert(IsRootPopupMenu(ppopupmenu));

    if (ppopupmenu->fDestroyed) {
        return FALSE;
    }

    pwndMenu = ppopupmenu->spwndNotify;
    ThreadLock(pwndMenu, &tlpwndMenu);

    pMenuState = GetpMenuState(pwndMenu);
    if (pMenuState == NULL) {
        RIPMSG0(RIP_ERROR, "xxxMNStartMenu: pMenuState == NULL");
        ThreadUnlock(&tlpwndMenu);
        return FALSE;
    }
    pMenuState->mnFocus = mn;
    pMenuState->fMenuStarted = TRUE;
    pMenuState->fButtonDown =
    pMenuState->fButtonAlwaysDown = ((_GetKeyState(VK_LBUTTON) & 0x8000) != 0);

    xxxMNSetCapture(ppopupmenu);

    xxxSendMessage(pwndMenu, WM_SETCURSOR, (WPARAM)HWq(pwndMenu),
            MAKELONG(MSGF_MENU, 0));

    if (ppopupmenu->fIsMenuBar) {
        BOOL fSystemMenu;

        pMenu = xxxGetInitMenuParam(pwndMenu, &fSystemMenu);

        if (pMenu == NULL) {
            pMenuState->fMenuStarted = FALSE;
            xxxMNReleaseCapture();
            ThreadUnlock(&tlpwndMenu);
            return FALSE;
        }

        LockPopupMenu(ppopupmenu, &ppopupmenu->spmenu, pMenu);

        ppopupmenu->fIsSysMenu = (fSystemMenu != 0);
        if (!fSystemMenu) {
            pMenu = xxxGetSysMenu(pwndMenu, FALSE);
            LockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate, pMenu);
        }
    }

    pMenuState->fIsSysMenu = (ppopupmenu->fIsSysMenu != 0);

    if (!ppopupmenu->fNoNotify) {

        if (ppopupmenu->fIsTrackPopup && ppopupmenu->fIsSysMenu) {
            pMenu = xxxGetInitMenuParam(pwndMenu, NULL);
        } else {
            pMenu = ppopupmenu->spmenu;
        }

        xxxSendMessage(pwndMenu, WM_INITMENU, (WPARAM)PtoH(pMenu), 0L);
    }

    if (!ppopupmenu->fIsTrackPopup) {
        if (ppopupmenu->fIsSysMenu) {
            MNPositionSysMenu(pwndMenu, ppopupmenu->spmenu);
        } else if (ppopupmenu->fIsMenuBar) {
            ThreadLockMenuNoModify(ppopupmenu->spmenu, &tlpMenu);
            xxxMNRecomputeBarIfNeeded(pwndMenu, ppopupmenu->spmenu);
            ThreadUnlockMenuNoModify(&tlpMenu);
            MNPositionSysMenu(pwndMenu, ppopupmenu->spmenuAlternate);
        }
    }

    /*
     * If returning TRUE, set menu style in pMenuState
     */
    if (!ppopupmenu->fDestroyed) {
        if (TestMF(ppopupmenu->spmenu, MNS_MODELESS)) {
            pMenuState->fModelessMenu = TRUE;
        }

        if (TestMF(ppopupmenu->spmenu, MNS_DRAGDROP)) {
            if (NT_SUCCESS(xxxClientLoadOLE())) {
                pMenuState->fDragAndDrop = TRUE;
            }
        }

        if (TestMF(ppopupmenu->spmenu, MNS_AUTODISMISS)) {
            pMenuState->fAutoDismiss = TRUE;
        }

        if (TestMF(ppopupmenu->spmenu, MNS_NOTIFYBYPOS)) {
            pMenuState->fNotifyByPos = TRUE;
        }

    }

    /*
     * Bogus!  We don't always know that this is the system menu.  We
     * will frequently pass on an OBJID_MENU even when you hit Alt+Space.
     *
     * Hence, MNSwitchToAlternate will send a EVENT_SYSTEM_MENUEND for the
     * menu bar and an EVENT_SYSTEM_MENUSTART for the sysmenu when we "switch".
     */
    xxxWindowEvent(EVENT_SYSTEM_MENUSTART, pwndMenu,
            (ppopupmenu->fIsSysMenu ? OBJID_SYSMENU : (ppopupmenu->fIsMenuBar ? OBJID_MENU : OBJID_WINDOW)),
            INDEXID_CONTAINER, 0);

    ThreadUnlock(&tlpwndMenu);

    return !ppopupmenu->fDestroyed;
}

/***************************************************************************\
* xxxGetInitMenuParam
*
* Gets the HMENU sent as the wParam of WM_INITMENU, and for menu bars, is
* the actual menu to be interacted with.
*
* History:
* ????
\***************************************************************************/
PMENU xxxGetInitMenuParam(
    PWND pwndMenu,
    BOOL *lpfSystem)
{
    //
    // Find out what menu we should be sending in WM_INITMENU:
    //      If minimized/child/empty menubar, use system menu
    //
    CheckLock(pwndMenu);

    if (TestWF(pwndMenu, WFMINIMIZED) ||
        TestwndChild(pwndMenu) ||
        (pwndMenu->spmenu == NULL) ||
        !pwndMenu->spmenu->cItems) {
        if (lpfSystem != NULL)
            *lpfSystem = TRUE;

        return xxxGetSysMenu(pwndMenu, FALSE);
    } else {
        if (lpfSystem != NULL) {
            *lpfSystem = FALSE;
        }

        return pwndMenu->spmenu;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnsel.c ===
/**************************** Module Header ********************************\
* Module Name: mnsel.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Selection Routines
*
* History:
*  10-10-90 JimA    Cleanup.
*  03-18-91 IanJa   Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxSendMenuSelect
*
* !
*
* Revalidation notes:
* o Assumes pMenuState->hwndMenu is non-NULL and valid
*
* Note: if pMenu==SMS_NOMENU, idx had better be MFMWFP_NOITEM!
*
* History:
\***************************************************************************/

void xxxSendMenuSelect(
    PWND pwndNotify,
    PWND pwndMenu,
    PMENU pMenu,
    int idx)
{
    UINT cmd;       // Menu ID if applicable.
    UINT flags;     // MF_ values if any
    MSG msg;
    PMENUSTATE pMenuState;

    CheckLock(pwndNotify);
    CheckLock(pwndMenu);


    /*
     * We must be hacking or passing valid things.
     */
    UserAssert((pMenu != SMS_NOMENU) || (idx == MFMWFP_NOITEM));


    if ((idx >= 0) && (pMenu->cItems > (UINT)idx)) {
        PITEM pItem = &(pMenu->rgItems[idx]);

        flags   = (pItem->fType  & MFT_OLDAPI_MASK) |
                  (pItem->fState & MFS_OLDAPI_MASK);

        if (pItem->spSubMenu != NULL)
            flags |= MF_POPUP;

        flags &= (~(MF_SYSMENU | MF_MOUSESELECT));

        /*
         * WARNING!
         * Under Windows the menu handle was always returned but additionally
         * if the menu was a pop-up the pop-up menu handle was returned
         * instead of the ID.  In NT we don't have enough space for 2 handles
         * and flags so if it is a pop-up we return the pop-up index
         * and the main Menu handle.
         */

        if (flags & MF_POPUP)
            cmd = idx;      // index of popup-menu
        else
            cmd = pItem->wID;

        pMenuState = GetpMenuState(pwndNotify);
        if (pMenuState != NULL) {
            if (pMenuState->mnFocus == MOUSEHOLD)
                flags |= MF_MOUSESELECT;

            if (pMenuState->fIsSysMenu)
                flags |= MF_SYSMENU;

        }
    } else {
        /*
         * idx assumed to be MFMWFP_NOITEM
         */
        if (pMenu == SMS_NOMENU) {

            /*
             * Hack so we can send MenuSelect messages with MFMWFP_MAINMENU
             * (loword(lparam)=-1) when the menu pops back up for the CBT people.
             */
            flags = MF_MAINMENU;
        } else {
            flags = 0;
        }

        cmd = 0;    // so MAKELONG(cmd, flags) == MFMWFP_MAINMENU
        pMenu = 0;
        idx = -1;   // so that idx+1 == 0, meaning nothing for zzzWindowEvent()
    }

    /*
     * Call msgfilter so help libraries can hook WM_MENUSELECT messages.
     */
    msg.hwnd = HW(pwndNotify);
    msg.message = WM_MENUSELECT;
    msg.wParam = (DWORD)MAKELONG(cmd, flags);
    msg.lParam = (LPARAM)PtoH(pMenu);
    if (!_CallMsgFilter((LPMSG)&msg, MSGF_MENU)) {
        xxxSendNotifyMessage(pwndNotify, WM_MENUSELECT, msg.wParam, msg.lParam);
    }

    if (pwndMenu) {
        xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndMenu,
                ((pwndMenu != pwndNotify) ? OBJID_CLIENT : ((flags & MF_SYSMENU) ? OBJID_SYSMENU : OBJID_MENU)),
                idx+1, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnsys.c ===
/**************************** Module Header ********************************\
* Module Name: mnsys.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* System Menu Routines
*
* History:
*  10-10-90 JimA    Cleanup.
*  03-18-91 IanJa   Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

void _SetCloseDefault(PMENU pSubMenu);
PWND FindFakeMDIChild(PWND pwndParent);

/***************************************************************************\
* LoadSysDesktopMenu
*
* Loads and locks a desktop system menu. Since we have to call the client
*  to load the menu, while thread 1 is loading the menu, thread 2
*  might grab the critical section, check pdesk->spmenu* and decide that
*  the menu needs to be loaded. Hence we could load the menu more than once.
*  this function handles that case to avoid leaking menus.
*
* 10/24/97 Gerardob     Created
\***************************************************************************/
#ifdef LAME_BUTTON
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId, PWND pwnd)
#else
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId)
#endif // LAME_BUTTON
{
    PMENU pmenu;
    /*
     * This should only be called when the menu hasn't been loaded
     */
    UserAssert(*ppmenu == NULL);

#ifdef LAME_BUTTON
    pmenu = xxxLoadSysMenu(uMenuId, pwnd);
#else
    pmenu = xxxLoadSysMenu(uMenuId);
#endif // LAME_BUTTON

    if (pmenu == NULL) {
        return NULL;
    }
    /*
     * If someone beat us loading the menu, destroy this one
     *  and return the one already loaded
     */
    if (*ppmenu != NULL) {
        UserAssert(TestMF(*ppmenu, MFSYSMENU));
        RIPMSG1(RIP_WARNING,
                "LoadSysDesktopMenu: Menu loaded during callback. ppmenu:%#p",
                ppmenu);
        _DestroyMenu(pmenu);
        return *ppmenu;
    }
    /*
     * Mark it, lock it and done
     */
    SetMF(pmenu, MFSYSMENU);
    LockDesktopMenu(ppmenu, pmenu);
    return pmenu;
}
/***************************************************************************\
* Lock/UnlockDesktopMenu
*
* These functions lock/unlock a pmenu into a desktop structure (spmenuSys or
*  spmenuDialogSys) and mark/clear it as such.
* We mark these menus so we can identify them quickly on single bit test.
* We also don't want any one to modify these menus or any submenu.
*
* Note that this assumes that there is only one submenu. If more are added,
*  these functions have to be fixed accordingly.
*
* 08/18/97 Gerardob     Created
\***************************************************************************/
PVOID LockDesktopMenu(PMENU * ppmenu, PMENU pmenu)
{
    PMENU pSubMenu;
    PTHREADINFO ptiDesktop;
    /*
     * We only load desktop sys menus once.
     */
    UserAssert(*ppmenu == NULL);

    if (pmenu == NULL) {
        return NULL;
    }

    SetMF(pmenu, MFDESKTOP);
    /*
     * This is awful but this is the real owner of this object. We used to set it
     *  to NULL but that was forcing us to handle the NULL owner all over the place
     */
    ptiDesktop = PtiCurrent()->rpdesk->rpwinstaParent->pTerm->ptiDesktop;
    HMChangeOwnerProcess(pmenu, ptiDesktop);

    pSubMenu = pmenu->rgItems->spSubMenu;
    UserAssert(pSubMenu != NULL);

    SetMF(pSubMenu, MFDESKTOP);
    HMChangeOwnerProcess(pSubMenu, ptiDesktop);

#if DBG
    {
        /*
         * Assert that there are no other submenus that would need to be
         *  marked as MFDESKTOP.
         */
        PITEM pitem;
        UINT uItems;

        UserAssert(pmenu->cItems == 1);

        pitem = pSubMenu->rgItems;
        uItems = pSubMenu->cItems;
        while (uItems--) {
            UserAssert(pitem->spSubMenu == NULL);
            pitem++;
        }
    }
#endif

    return Lock(ppmenu, pmenu);
}

PVOID UnlockDesktopMenu(PMENU * ppmenu)
{
    UserAssert(*ppmenu != NULL);
    UserAssert(TestMF(*ppmenu, MFDESKTOP));
    ClearMF(*ppmenu, MFDESKTOP);
    UserAssert(TestMF((*ppmenu)->rgItems->spSubMenu, MFDESKTOP));
    ClearMF((*ppmenu)->rgItems->spSubMenu, MFDESKTOP);
    return Unlock(ppmenu);
}
/***************************************************************************\
* GetSysMenuHandle
*
* Returns a handle to the system menu of the given window. NULL if
* the window doesn't have a system menu.
*
* History:
\***************************************************************************/

PMENU xxxGetSysMenuHandle(
    PWND pwnd)
{
    PMENU pMenu;

    CheckLock(pwnd);

    if (TestWF(pwnd, WFSYSMENU)) {
        pMenu = pwnd->spmenuSys;

        /*
         * If the window doesn't have a System Menu, use the default one.
         */
        if (pMenu == NULL) {

            /*
             * Grab the menu from the desktop.  If the desktop menu
             * has not been loaded and this is not a system thread,
             * load it now.  Callbacks cannot be made from a system
             * thread or when a thread is in cleanup.
             */
            pMenu = pwnd->head.rpdesk->spmenuSys;

            /*
             * Do not do callbacks if the thread is exiting.  We ran into this when
             * destroying a thread's window and the window it was promoting to
             * foreground was a hard error popup.
             */
            if (pMenu == NULL && !(PtiCurrent()->TIF_flags & (TIF_SYSTEMTHREAD | TIF_INCLEANUP))) {

#ifdef LAME_BUTTON
                pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU, pwnd);
#else
                pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU);
#endif // LAME_BUTTON
            }
        }
    } else {
        pMenu = NULL;
    }

    return pMenu;
}

/***************************************************************************\
*
*  GetSysMenu()
*
*  Sets up the system menu first, then returns it.
*
\***************************************************************************/
PMENU xxxGetSysMenu(PWND pwnd, BOOL fSubMenu)
{
    PMENU   pMenu;

    CheckLock(pwnd);
    xxxSetSysMenu(pwnd);
    if ((pMenu = xxxGetSysMenuHandle(pwnd)) != NULL) {
        if (fSubMenu)
            pMenu = _GetSubMenu(pMenu, 0);
    }

    return(pMenu);
}

/***************************************************************************\
* IsSmallerThanScreen
*
\***************************************************************************/

BOOL IsSmallerThanScreen(PWND pwnd)
{
    int dxMax, dyMax;
    PMONITOR pMonitor;

    pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
    dxMax = pMonitor->rcWork.right - pMonitor->rcWork.left;
    dyMax = pMonitor->rcWork.bottom - pMonitor->rcWork.top;

    if ((pwnd->rcWindow.right - pwnd->rcWindow.left < dxMax) ||
            (pwnd->rcWindow.bottom - pwnd->rcWindow.top < dyMax)) {
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* SetSysMenu
*
* !
*
* History:
\***************************************************************************/

void xxxSetSysMenu(
    PWND pwnd)
{
    PMENU pMenu;
    UINT wSize;
    UINT wMinimize;
    UINT wMaximize;
    UINT wMove;
    UINT wRestore;
    UINT wDefault;
    BOOL fFramedDialogBox;
    TL tlmenu;

    CheckLock(pwnd);
    /*
     * Get the handle of the current system menu.
     */
    if ((pMenu = xxxGetSysMenuHandle(pwnd)) != NULL) {

        pMenu = _GetSubMenu(pMenu, 0);
        if (!pMenu)
            return;

        ThreadLockAlways(pMenu, &tlmenu);

        /*
         * System modal window: no size, icon, zoom, or move.
         */

// No system modal windows on NT.
//        wSize = wMaximize = wMinimize = wMove =
//            (UINT)((_GetSysModalWindow() == NULL) || hTaskLockInput ? 0: MFS_GRAYED);
        wSize = wMaximize = wMinimize = wMove =  0;
        wRestore = MFS_GRAYED;

        //
        // Default menu command is close.
        //
        wDefault = SC_CLOSE;

        /*
         * Minimized exceptions: no minimize, restore.
         */

        // we need to reverse these because VB has a "special" window
        // that is both minimized but without a minbox.
        if (TestWF(pwnd, WFMINIMIZED))
        {
            wRestore  = 0;
            wMinimize = MFS_GRAYED;
            wSize     = MFS_GRAYED;
            wDefault  = SC_RESTORE;

            if (IsTrayWindow(pwnd))
              wMove = MFS_GRAYED;
        }
        else if (!TestWF(pwnd, WFMINBOX))
            wMinimize = MFS_GRAYED;

        /*
         * Maximized exceptions: no maximize, restore.
         */
        if (!TestWF(pwnd, WFMAXBOX))
            wMaximize = MFS_GRAYED;
        else if (TestWF(pwnd, WFMAXIMIZED)) {
            wRestore = 0;

            /*
             * If the window is maximized but it isn't larger than the
             * screen, we allow the user to move the window around the
             * desktop (but we don't allow resizing).
             */
            wMove = MFS_GRAYED;
            if (!TestWF(pwnd, WFCHILD)) {
                if (IsSmallerThanScreen(pwnd)) {
                    wMove = 0;
                }
            }

            wSize     = MFS_GRAYED;
            wMaximize = MFS_GRAYED;
        }

        if (!TestWF(pwnd, WFSIZEBOX))
            wSize = MFS_GRAYED;

        /*
         * Are we dealing with a framed dialog box with a sys menu?
         * Dialogs with min/max/size boxes get a regular system menu
         *  (as opposed to the dialog menu)
         */
        fFramedDialogBox =
                (((TestWF(pwnd, WFBORDERMASK) == (BYTE)LOBYTE(WFDLGFRAME))
                        || (TestWF(pwnd, WEFDLGMODALFRAME)))
                    && !TestWF(pwnd, WFSIZEBOX | WFMINBOX | WFMAXBOX));

        if (!fFramedDialogBox) {
            xxxEnableMenuItem(pMenu, (UINT)SC_SIZE, wSize);
            if (!TestWF(pwnd, WEFTOOLWINDOW))
            {
                xxxEnableMenuItem(pMenu, (UINT)SC_MINIMIZE, wMinimize);
                xxxEnableMenuItem(pMenu, (UINT)SC_MAXIMIZE, wMaximize);
                xxxEnableMenuItem(pMenu, (UINT)SC_RESTORE, wRestore);
            }
        }

        xxxEnableMenuItem(pMenu, (UINT)SC_MOVE, wMove);

#if DBG
        /*
         * Assert that nobody managed to change the desktop menus.
         */
        if (TestMF(pMenu, MFSYSMENU)) {
            PITEM pItem = MNLookUpItem(pMenu, SC_CLOSE, FALSE, NULL);
            UserAssert((pItem != NULL) && !TestMFS(pItem, MFS_GRAYED));
        }
#endif

        if (wDefault == SC_CLOSE)
            _SetCloseDefault(pMenu);
        else
            _SetMenuDefaultItem(pMenu, wDefault, MF_BYCOMMAND);

        ThreadUnlock(&tlmenu);
    }
}


/***************************************************************************\
* GetSystemMenu
*
* !
*
* History:
\***************************************************************************/

PMENU xxxGetSystemMenu(
    PWND pwnd,
    BOOL fRevert)
{
    PMENU pmenu;
    CheckLock(pwnd);

    /*
     * Should we start with a fresh copy?
     */

    pmenu = pwnd->spmenuSys;
    if (fRevert) {

        /*
         * Destroy the old system menu.
         */
        if ((pmenu != NULL) && !TestMF(pmenu, MFSYSMENU)) {

            if (UnlockWndMenu(pwnd, &pwnd->spmenuSys)) {
                _DestroyMenu(pmenu);
            }
        }
    } else {

        /*
         * Do we need to load a new system menu?
         */
        if (((pmenu == NULL) || TestMF(pmenu, MFSYSMENU))
                && TestWF(pwnd, WFSYSMENU)) {

            PPOPUPMENU pGlobalPopupMenu;
            UINT uMenuId = (pwnd->spmenuSys == NULL ? ID_SYSMENU : ID_DIALOGSYSMENU);
#ifdef LAME_BUTTON
            pmenu = xxxLoadSysMenu(uMenuId, pwnd);
#else
            pmenu = xxxLoadSysMenu(uMenuId);
#endif // LAME_BUTTON
            if (pmenu == NULL) {
                RIPMSG1(RIP_WARNING, "_GetSystemMenu: xxxLoadSysMenu Failed. pwnd:%#p", pwnd);
            }
            LockWndMenu(pwnd, &pwnd->spmenuSys, pmenu);

            pmenu = pwnd->spmenuSys;
            pGlobalPopupMenu = GetpGlobalPopupMenu(pwnd);
            if ((pGlobalPopupMenu != NULL)
                    && !pGlobalPopupMenu->fIsTrackPopup
                    && (pGlobalPopupMenu->spwndPopupMenu == pwnd)) {

                UserAssert(pGlobalPopupMenu->spwndNotify == pwnd);
                if (pGlobalPopupMenu->fIsSysMenu) {
                    Lock(&pGlobalPopupMenu->spmenu, pmenu);
                } else {
                    Lock(&pGlobalPopupMenu->spmenuAlternate, pmenu);
                }
            }
        }
    }

    /*
     * Return the handle to the system menu.
     */
    if (pwnd->spmenuSys != NULL) {
        /*
         * The app is probably going to modify this menu and then we'll need to
         *  redraw the caption buttons. Hence we need to store the window pointer
         *  in this pmenu or we won't be able to know what window to repaint.
         * The bogus thing is that we cannot call LockWndMenu here because this is
         *  not the actual pmenuSys.
         */
        pmenu = _GetSubMenu(pwnd->spmenuSys, 0);
        if (pmenu) {
            SetMF(pmenu, MFAPPSYSMENU);
            Lock(&pmenu->spwndNotify, pwnd);
        }
        return pmenu;
    }

    return NULL;
}

/***************************************************************************\
* MenuItemState
*
* Sets the menu item flags identified by wMask to the states identified
* by wFlags.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

DWORD MenuItemState(
    PMENU pMenu,
    UINT wCmd,
    DWORD wFlags,
    DWORD wMask,
    PMENU *ppMenu)
{
    PITEM pItem;
    DWORD wRet;

    /*
     * Get a pointer the the menu item
     */
    if ((pItem = MNLookUpItem(pMenu, wCmd, (BOOL) (wFlags & MF_BYPOSITION), ppMenu)) == NULL)
        return (DWORD)-1;

    /*
     * Return previous state
     */
    wRet = pItem->fState & wMask;

    /*
     * Set new state
     */
    pItem->fState ^= ((wRet ^ wFlags) & wMask);

    return wRet;
}


/***************************************************************************\
* EnableMenuItem
*
* Enable, disable or gray a menu item.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

DWORD xxxEnableMenuItem(
    PMENU pMenu,
    UINT wIDEnableItem,
    UINT wEnable)
{
    DWORD dres;
    PMENU pRealMenu;
    PPOPUPMENU ppopup;

    CheckLock(pMenu);

    dres = MenuItemState(pMenu, wIDEnableItem, wEnable,
            MFS_GRAYED, &pRealMenu);

    /*
     * If enabling/disabling a system menu item, redraw the caption buttons
     */
    if (TestMF(pMenu, MFAPPSYSMENU) && (pMenu->spwndNotify != NULL) && (wEnable != dres)) {

        TL tlpwnd;

        switch (wIDEnableItem) {
        case SC_SIZE:
        case SC_MOVE:
        case SC_MINIMIZE:
        case SC_MAXIMIZE:
        case SC_CLOSE:
        case SC_RESTORE:
            ThreadLock(pMenu->spwndNotify, &tlpwnd);
            xxxRedrawTitle(pMenu->spwndNotify, DC_BUTTONS);
            ThreadUnlock(&tlpwnd);
        }
    }

    /* 367162: If the menu is already being displayed we need to redraw it */
    if(pRealMenu && (ppopup = MNGetPopupFromMenu(pRealMenu, NULL))){
        xxxMNUpdateShownMenu(ppopup, NULL, MNUS_DEFAULT);
    }

    return dres;
}


/***************************************************************************\
* CheckMenuItem (API)
*
* Check or un-check a popup menu item.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

DWORD _CheckMenuItem(
    PMENU pMenu,
    UINT wIDCheckItem,
    UINT wCheck)
{
    return MenuItemState(pMenu, wIDCheckItem, wCheck, (UINT)MF_CHECKED, NULL);
}


/***************************************************************************\
*
*  SetMenuDefaultItem() -
*
*  Sets the default item in the menu, by command or by position based on the
*  fByPosition flag.
*  We unset all the other items as the default, then set the given one.
*
*  The return value is TRUE if the given item was set as default, FALSE
*  if not.
*
\***************************************************************************/
BOOL _SetMenuDefaultItem(PMENU pMenu, UINT wID, BOOL fByPosition)
{
    UINT  iItem;
    UINT  cItems;
    PITEM pItem;
    PITEM pItemFound;
    PMENU   pMenuFound;

    //
    // We need to check if wId actually exists on this menu.  0xFFFF means
    // clear all default items.
    //

    if (wID != MFMWFP_NOITEM)
    {
        pItemFound = MNLookUpItem(pMenu, wID, fByPosition, &pMenuFound);

        // item must be on same menu and can't be a separator
        if ((pItemFound == NULL) || (pMenuFound != pMenu) || TestMFT(pItemFound, MFT_SEPARATOR))
            return(FALSE);

    }
    else
        pItemFound = NULL;

    pItem = pMenu->rgItems;
    cItems = pMenu->cItems;

    // Walk the menu list, clearing MFS_DEFAULT from all other items, and
    // setting MFS_DEFAULT on the requested one.
    for (iItem = 0; iItem < cItems; iItem++, pItem++) {
        //
        // Note we don't change the state of lpItemFound if it exists.  This
        // is so that below, where we try to set the default, we can tell
        // if we need to recalculate the underline.
        //

        if (TestMFS(pItem, MFS_DEFAULT) && (pItem != pItemFound))
        {
            //
            // We are changing the default item.  As such, it will be drawn
            // with a different font than the one used to calculate it, if
            // the menu has already been drawn once.  We need to ensure
            // that the underline gets drawn in the right place the next
            // time the menu comes up.  Cause it to recalculate.
            //
            // We do NOT do this if the item
            //      (a) isn't default--otherwise we'll recalculate the
            //  underline for every system menu item every time we go into
            //  menu mode because sysmenu init will call SetMenuDefaultItem.
            //      (b) isn't the item we're going to set as the default.
            //  That way we don't recalculate the underline when the item
            //  isn't changing state.
            //
            ClearMFS(pItem, MFS_DEFAULT);
            pItem->ulX = UNDERLINE_RECALC;
            pItem->ulWidth = 0;
        }
    }

    if (wID != MFMWFP_NOITEM)
    {
        if (!TestMFS(pItemFound, MFS_DEFAULT))
        {
            //
            // We are changing from non-default to default.  Clear out
            // the underline info.  If the menu has never painted, this
            // won't do anything.  But it matters a lot if it has.
            //
            SetMFS(pItemFound, MFS_DEFAULT);
            pItemFound->ulX = UNDERLINE_RECALC;
            pItemFound->ulWidth = 0;
        }
    }

    return(TRUE);
}

// --------------------------------------------------------------------------
//
//  SetCloseDefault()
//
//  Tries to find a close item in the first level of menu items.  Looks
//  for SC_CLOSE, then a couple other IDs.  We'd rather not do lstrstri's
//  for "Close", which is slow.
//
// --------------------------------------------------------------------------
void _SetCloseDefault(PMENU pSubMenu)
{
    if (!_SetMenuDefaultItem(pSubMenu, SC_CLOSE, MF_BYCOMMAND))
    {
        //
        // Let's try a couple other values.
        //      * Project   --  0x7000 less
        //      * FoxPro    --  0xC070
        //
        if (!_SetMenuDefaultItem(pSubMenu, SC_CLOSE - 0x7000, MF_BYCOMMAND))
            _SetMenuDefaultItem(pSubMenu, 0xC070, MF_BYCOMMAND);
    }
}


// --------------------------------------------------------------------------
//
//  FindFakeMDIChild()
//
//  Attempts to find first child visible child window in the zorder that
//  has a system menu or is maxed.  We can't check for an exact system
//  menu match because several apps make their own copy of the sys menu.
//
// --------------------------------------------------------------------------
PWND FindFakeMDIChild(PWND pwnd)
{
    PWND    pwndReturn;

    // Skip invisible windows and their descendants
    if (!TestWF(pwnd, WFVISIBLE))
        return(NULL);

    // Did we hit pay dirt?
    if (TestWF(pwnd, WFCHILD) && (TestWF(pwnd, WFMAXIMIZED) || (pwnd->spmenuSys)))
        return(pwnd);

    // Check our children
    for (pwnd = pwnd->spwndChild; pwnd; pwnd = pwnd->spwndNext)
    {
        pwndReturn = FindFakeMDIChild(pwnd);
        if (pwndReturn)
            return(pwndReturn);
    }

    return(NULL);
}



// --------------------------------------------------------------------------
//
//  SetupFakeMDIAppStuff()
//
//  For apps that mess around with their own MDI (Excel, Word, Project,
//      Quattro Pro), we want to make them a little more Chicago friendly.
//      Namely we:
//
//      (1) Set the default menu item to SC_CLOSE if there isn't one (this
//          won't help FoxPro, but they do so much wrong stuff it doesn't
//          really matter).
//          That way double-clicks will still work.
//
//      (2) Get the right small icon.
//
//  The way we do this is to go find the child window of the menu bar parent
//  who has a system menu that is this one.
//
//  If the system menu is the standard one, then we can't do (2).
//
// --------------------------------------------------------------------------
void SetupFakeMDIAppStuff(PMENU lpMenu, PITEM lpItem)
{
    PMENU   pSubMenu;
    PWND    pwndParent;
    PWND    pwndChild;

    if (!(pSubMenu = lpItem->spSubMenu))
        return;

    pwndParent = lpMenu->spwndNotify;

    //
    // Set up the default menu item.  Project and FoxPro renumber their
    // IDs so we do some special stuff for them, among others.
    //
    if (!TestWF(pwndParent, WFWIN40COMPAT))
    {
        if (_GetMenuDefaultItem(pSubMenu, TRUE, GMDI_USEDISABLED) == -1L)
            _SetCloseDefault(pSubMenu);
    }

    //
    // Don't touch the HIWORD if we don't find an HWND.  That way apps
    // like Excel which have starting-up maxed children can benefit a little.
    // The first time the menu bar is redrawn, the child isn't visible/
    // around (they add the item too early).  But if it redraws later, or
    // you max a child, the icon will kick in.
    //
    if (pwndChild = FindFakeMDIChild(pwndParent)) {
        lpItem->dwItemData = (ULONG_PTR)HWq(pwndChild);
//        lpItem->dwTypeData = MAKELONG(LOWORD(lpItem->dwTypeData), HW16(hwndChild));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\msgbeep.c ===
/****************************** Module Header ******************************\
* Module Name: msgbeep.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the xxxMessageBox API and related functions.
*
* History:
*  6-26-91 NigelT      Created it with some wood and a few nails
*  7 May 92 SteveDav   Getting closer to the real thing
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <ntddbeep.h>
#include <mmsystem.h>

/***************************************************************************\
* xxxOldMessageBeep (API)
*
* Send a beep to the beep device
*
* History:
* 09-25-91 JimA         Created.
\***************************************************************************/

BOOL xxxOldMessageBeep()
{
    BOOL b;
    if (TEST_PUDF(PUDF_BEEP)) {
        LeaveCrit();
        b = UserBeep(440, 125);
        EnterCrit();
        return b;
    } else {
        _UserSoundSentryWorker();
    }

    return TRUE;
}

/***************************************************************************\
* xxxMessageBeep (API)
*
*
* History:
*  6-26-91  NigelT      Wrote it.
* 24-Mar-92 SteveDav    Changed interface - no passing of strings
*                       If WINMM cannot be found or loaded, then use speaker
\***************************************************************************/

BOOL xxxMessageBeep(
    UINT dwType)
{
    UINT sndid;
    PTHREADINFO  pti = PtiCurrent();

    if (pti->TIF_flags & TIF_SYSTEMTHREAD) {
        xxxOldMessageBeep();
        return TRUE;
    }

    if (!TEST_PUDF(PUDF_BEEP)) {
        _UserSoundSentryWorker();
        return TRUE;
    }

    switch(dwType & MB_ICONMASK) {
    case MB_ICONHAND:
        sndid = USER_SOUND_SYSTEMHAND;
        break;

    case MB_ICONQUESTION:
        sndid = USER_SOUND_SYSTEMQUESTION;
        break;

    case MB_ICONEXCLAMATION:
        sndid = USER_SOUND_SYSTEMEXCLAMATION;
        break;

    case MB_ICONASTERISK:
        sndid = USER_SOUND_SYSTEMASTERISK;
        break;

    default:
        sndid = USER_SOUND_DEFAULT;
        break;
    }

    if (gspwndLogonNotify) {
        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_PLAYEVENTSOUND, sndid);
    }

    _UserSoundSentryWorker();

    return TRUE;
}

/***************************************************************************\
* xxxPlayEventSound
*
* Play a sound
*
* History:
* 09-25-91 JimA         Created.
\***************************************************************************/

VOID PlayEventSound(UINT idSound)
{
    PTHREADINFO    pti = PtiCurrent();

    if (!TEST_PUDF(PUDF_EXTENDEDSOUNDS))
        return;

    if (pti->TIF_flags & TIF_SYSTEMTHREAD)
        return;

    if (gspwndLogonNotify) {
        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_PLAYEVENTSOUND, idSound);
    }

//  NOTE -- we should only flash SoundSentry if a sound is played.  With the
//  new technique of posting to WinLogon, we can't determine this here.
//   _UserSoundSentryWorker();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\mnpopup.c ===
/**************************** Module Header ********************************\
* Module Name: mnpopup.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Popup Menu Support
*
* History:
*  10-10-90 JimA    Cleanup.
*  03-18-91 IanJa   Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define RECT_ONLEFT     0
#define RECT_ONTOP      1
#define RECT_ONRIGHT    2
#define RECT_ONBOTTOM   3
#define RECT_ORG        4

BOOL TryRect(
        UINT        wRect,
        int         x,
        int         y,
        int         cx,
        int         cy,
        LPRECT      prcExclude,
        LPPOINT     ppt,
        PMONITOR    pMonitor);

/***************************************************************************\
* xxxTrackPopupMenuEx (API)
*
* Process a popup menu
*
* Revalidation Notes:
* o  if pwndOwner is always the owner of the popup menu windows, then we don't
*    really have to revalidate it: when it is destroyed the popup menu windows
*    are destroyed first because it owns them - this is detected in MenuWndProc
*    so we would only have to test pMenuState->fSabotaged.
* o  pMenuState->fSabotaged must be cleared before this top-level routine
*    returns, to be ready for next time menus are processed (unless we are
*    currently inside xxxMenuLoop())
* o  pMenuState->fSabotaged should be FALSE when we enter this routine.
* o  xxxMenuLoop always returns with pMenuState->fSabotaged clear.  Use
*    a UserAssert to verify this.
*
* History:
\***************************************************************************/

int xxxTrackPopupMenuEx(
    PMENU       pMenu,
    UINT        dwFlags,
    int         x,
    int         y,
    PWND        pwndOwner,
    CONST TPMPARAMS *lpTpm)
{
    PMENUSTATE      pMenuState;
    PWND            pwndHierarchy;
    PPOPUPMENU      ppopupMenuHierarchy;
    LONG            sizeHierarchy;
    int             cxPopup,
                    cyPopup;
    BOOL            fSync;
    int             cmd;
    BOOL            fButtonDown;
    TL              tlpwndHierarchy;
    TL              tlpwndT;
    RECT            rcExclude;
    PTHREADINFO     ptiCurrent,
                    ptiOwner;
    PMONITOR        pMonitor;
    POINT           pt;

    CheckLock(pMenu);
    CheckLock(pwndOwner);

    /*
     * Capture the things we care about in case lpTpm goes away.
     */
    if (lpTpm != NULL) {
        if (lpTpm->cbSize != sizeof(TPMPARAMS)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "TrackPopupMenuEx: cbSize is invalid");
            return(FALSE);
        }
        rcExclude = lpTpm->rcExclude;
    }

    ptiCurrent = PtiCurrent();
    ptiOwner = GETPTI(pwndOwner);

    /*
     * Win95 compatibility: pwndOwner must be owned by ptiCurrent.
     */
    if (ptiCurrent != ptiOwner) {
        RIPMSG0(RIP_WARNING, "xxxTrackPopupMenuEx: pwndOwner not owned by ptiCurrent");
        return FALSE;
    }

    UserAssert(pMenu != NULL);
    if (ptiCurrent->pMenuState != NULL) {

        if (dwFlags & TPM_RECURSE) {
            /*
             * Only allow recursion if:
             *  -The current menu mode is not about to exit
             *  -Both menus notify the same window
             *  -Only one thread is involved in the current menu mode
             * This will prevent us from getting into some random
             *  scenarios we don't want to deal with
             */
           ppopupMenuHierarchy = ptiCurrent->pMenuState->pGlobalPopupMenu;
           pwndHierarchy = ppopupMenuHierarchy->spwndNotify;
           if (ExitMenuLoop(ptiCurrent->pMenuState, ppopupMenuHierarchy)
                || (pwndHierarchy == NULL)
                || (pwndHierarchy != pwndOwner)
                || (ptiCurrent->pMenuState->ptiMenuStateOwner != GETPTI(pwndHierarchy))) {

               RIPMSG0(RIP_WARNING, "xxxTrackPopupMenuEx: Failing TPM_RECURSE request");
               return FALSE;
           }
           /*
            * Terminate any animation
            */
            MNAnimate(ptiCurrent->pMenuState, FALSE);
           /*
            * Cancel pending show timer if any. ie, the app wants to
            *  pop up a context menu on a popup before we drop it.
            */
           ppopupMenuHierarchy = ((ppopupMenuHierarchy->spwndActivePopup != NULL)
                                  ? ((PMENUWND)(ppopupMenuHierarchy->spwndActivePopup))->ppopupmenu
                                  : NULL);
           if ((ppopupMenuHierarchy != NULL) && ppopupMenuHierarchy->fShowTimer) {

                _KillTimer(ppopupMenuHierarchy->spwndPopupMenu, IDSYS_MNSHOW);
                ppopupMenuHierarchy->fShowTimer = FALSE;
           }
           /*
            * If we're currently on a modal menu, let's unlock the capture
            *  so the recursive menu can get it.
            */
           if (!ptiCurrent->pMenuState->fModelessMenu) {
               ptiCurrent->pq->QF_flags &= ~QF_CAPTURELOCKED;
           }
        } else {
            /*
             * Allow only one guy to have a popup menu up at a time...
             */
            RIPERR0(ERROR_POPUP_ALREADY_ACTIVE, RIP_VERBOSE, "");
            return FALSE;
       }
   }

    // Is button down?

    if (dwFlags & TPM_RIGHTBUTTON)
    {
        fButtonDown = (_GetKeyState(VK_RBUTTON) & 0x8000) != 0;
    } else {
        fButtonDown = (_GetKeyState(VK_LBUTTON) & 0x8000) != 0;
    }

    /*
     * Create the menu window.
     */
    pwndHierarchy = xxxNVCreateWindowEx(
            WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
            (PLARGE_STRING)MENUCLASS,
            NULL,
            WS_POPUP | WS_BORDER,
            x, y, 100, 100,
            TestMF(pMenu, MNS_MODELESS) ? pwndOwner : NULL,
            NULL, (HANDLE)pwndOwner->hModule,
            NULL,
            WINVER);

    if (pwndHierarchy == NULL) {
        return FALSE;
    }

    if (TestWF(pwndOwner, WEFLAYOUTRTL) || (dwFlags & TPM_LAYOUTRTL)) {
        SetWF(pwndHierarchy, WEFLAYOUTRTL);
    }

    //
    // Do this so that old apps don't get weird borders on tracked popups due
    // to the app hack used in CreateWindowEx32.
    //
    ClrWF(pwndHierarchy, WFOLDUI);

    ThreadLockAlways(pwndHierarchy, &tlpwndHierarchy);

#ifdef HAVE_MN_GETPPOPUPMENU
    ppopupMenuHierarchy = (PPOPUPMENU)xxxSendMessage(pwndHierarchy,
                                                MN_GETPPOPUPMENU, 0, 0);
#else
    ppopupMenuHierarchy = ((PMENUWND)pwndHierarchy)->ppopupmenu;
#endif


    ppopupMenuHierarchy->fDelayedFree = TRUE;
    Lock(&(ppopupMenuHierarchy->spwndNotify), pwndOwner);
    LockPopupMenu(ppopupMenuHierarchy, &ppopupMenuHierarchy->spmenu, pMenu);
    Lock(&(ppopupMenuHierarchy->spwndActivePopup), pwndHierarchy);
    ppopupMenuHierarchy->ppopupmenuRoot = ppopupMenuHierarchy;
    ppopupMenuHierarchy->fIsTrackPopup  = TRUE;
    ppopupMenuHierarchy->fFirstClick = fButtonDown;
    ppopupMenuHierarchy->fRightButton   = ((dwFlags & TPM_RIGHTBUTTON) != 0);
    if (SYSMET(MENUDROPALIGNMENT) || TestMF(pMenu, MFRTL)) {
       //
       // popup's below this one need to follow the same direction as
       // the other menu's on the desktop.
       //
       ppopupMenuHierarchy->fDroppedLeft = TRUE;
    }
    ppopupMenuHierarchy->fNoNotify      = ((dwFlags & TPM_NONOTIFY) != 0);

    if (fSync = (dwFlags & TPM_RETURNCMD))
        ppopupMenuHierarchy->fSynchronous = TRUE;

    ppopupMenuHierarchy->fIsSysMenu =  ((dwFlags & TPM_SYSMENU) != 0);

    // Set the GlobalPopupMenu variable so that EndMenu works for popupmenus so
    // that WinWart II people can continue to abuse undocumented functions.
    // This is nulled out in MNCancel.
    /*
     * This is actually needed for cleanup in case this thread ends
     *  execution before we can free the popup. (See xxxDestroyThreadInfo)
     *
     * Note that one thread might own pwndOwner and another one might call
     *  TrackPopupMenu (pretty normal if the two threads are attached). So
     *  properly setting (and initializing) pMenuState is a must here.
     */
    pMenuState = xxxMNAllocMenuState(ptiCurrent, ptiOwner, ppopupMenuHierarchy);
    if (pMenuState == NULL) {
        /*
         * Get out. The app never knew we were here so don't notify it
         */
        dwFlags |= TPM_NONOTIFY;
        goto AbortTrackPopupMenuEx;
    }

    /*
     * Notify the app we are entering menu mode.  wParam is 1 since this is a
     * TrackPopupMenu.
     */

    if (!ppopupMenuHierarchy->fNoNotify)
        xxxSendMessage(pwndOwner, WM_ENTERMENULOOP,
            (ppopupMenuHierarchy->fIsSysMenu ? FALSE : TRUE), 0);

    /*
     * Send off the WM_INITMENU, set ourselves up for menu mode etc...
     */
    if (!xxxMNStartMenu(ppopupMenuHierarchy, MOUSEHOLD)) {
        /*
         * ppopupMenuHierarchy has been destroyed already; let's bail
         */
        goto AbortTrackPopupMenuEx;
    }

    /*
     * If drag and drop, register the window as a target.
     */
    if (pMenuState->fDragAndDrop) {
        if (!SUCCEEDED(xxxClientRegisterDragDrop(HW(pwndHierarchy)))) {
            RIPMSG0(RIP_ERROR, "xxxTrackPopupMenuEx: xxxClientRegisterDragDrop failed");
        }
    }

    if (!ppopupMenuHierarchy->fNoNotify) {
        ThreadLock(ppopupMenuHierarchy->spwndNotify, &tlpwndT);
        xxxSendMessage(ppopupMenuHierarchy->spwndNotify, WM_INITMENUPOPUP,
            (WPARAM)PtoHq(pMenu), MAKELONG(0, (ppopupMenuHierarchy->fIsSysMenu ? 1: 0)));
        ThreadUnlock(&tlpwndT);
        ppopupMenuHierarchy->fSendUninit = TRUE;
    }

    /*
     * Size the menu window if needed...
     */
    sizeHierarchy = (LONG)xxxSendMessage(pwndHierarchy, MN_SIZEWINDOW, MNSW_SIZE, 0);

    if (!sizeHierarchy) {

AbortTrackPopupMenuEx:
        xxxWindowEvent(EVENT_SYSTEM_MENUEND, pwndOwner, OBJID_WINDOW, INDEXID_CONTAINER, 0);
        
        /*
         * Release the mouse capture we set when we called StartMenuState...
         */
        xxxMNReleaseCapture();

        /* Notify the app we have exited menu mode.  wParam is 1 for real
         * tracked popups, not sys menu.  Check wFlags since ppopupHierarchy
         * will be gone.
         */
        if (!(dwFlags & TPM_NONOTIFY))
            xxxSendMessage(pwndOwner, WM_EXITMENULOOP, ((dwFlags & TPM_SYSMENU) ?
                FALSE : TRUE), 0L);

        /*
         * Make sure we return failure
         */
        fSync = TRUE;
        cmd = FALSE;
        goto CleanupTrackPopupMenuEx;
    }

    if (glinp.dwFlags & LINP_KEYBOARD) {
        pMenuState->fUnderline = TRUE;
        SetMF(pMenu, MFUNDERLINE);
    } else {
        ClearMF(pMenu, MFUNDERLINE);
    }

    //
    // Setup popup window dimensions
    //
    cxPopup = LOWORD(sizeHierarchy) + 2*SYSMET(CXFIXEDFRAME);
    cyPopup = HIWORD(sizeHierarchy) + 2*SYSMET(CYFIXEDFRAME);

    //
    // Calculate the monitor BEFORE we adjust the point.  Otherwise, we might
    // move the point offscreen.  In which case, we will end up pinning the
    // popup to the primary display, which is wrong.
    //
    pt.x = x;
    pt.y = y;
    pMonitor = _MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

    //
    // Horizontal alignment
    //
    if (TestWF(pwndOwner, WEFLAYOUTRTL) && !(dwFlags & TPM_CENTERALIGN)) {
        dwFlags = dwFlags ^ TPM_RIGHTALIGN;
    }

    if (dwFlags & TPM_RIGHTALIGN) {
#if DBG
        if (dwFlags & TPM_CENTERALIGN) {
            RIPMSG0(RIP_WARNING, "TrackPopupMenuEx:  TPM_CENTERALIGN ignored");
        }
#endif // DBG

        x -= cxPopup;
        ppopupMenuHierarchy->iDropDir = PAS_LEFT;
    } else if (dwFlags & TPM_CENTERALIGN) {
        x -= (cxPopup / 2);
    } else {
        ppopupMenuHierarchy->iDropDir = (ppopupMenuHierarchy->fDroppedLeft ? PAS_LEFT : PAS_RIGHT);
    }

    //
    // Vertical alignment
    //
    if (dwFlags & TPM_BOTTOMALIGN) {
#if DBG
        if (dwFlags & TPM_VCENTERALIGN) {
            RIPMSG0(RIP_WARNING, "TrackPopupMenuEx:  TPM_VCENTERALIGN ignored");
        }
#endif // DBG

        y -= cyPopup;
        ppopupMenuHierarchy->iDropDir |= PAS_UP;
    } else if (dwFlags & TPM_VCENTERALIGN) {
        y -= (cyPopup / 2);
    } else {
        ppopupMenuHierarchy->iDropDir |= PAS_DOWN;
    }
    /*
     * If the caller provided an animation direction, use that instead
     */
    if (dwFlags & TPM_ANIMATIONBITS) {
        ppopupMenuHierarchy->iDropDir = ((dwFlags >> TPM_FIRSTANIBITPOS) & (PAS_VERT | PAS_HORZ));
    }
    //
    // Get coords to move to.
    //
    sizeHierarchy = FindBestPos(
            x,
            y,
            cxPopup,
            cyPopup,
            ((lpTpm != NULL) ? &rcExclude : NULL),
            dwFlags,
            ppopupMenuHierarchy,
            pMonitor);

    if (TestWF(pwndOwner, WEFLAYOUTRTL) && (ppopupMenuHierarchy->iDropDir & PAS_HORZ)) {
        ppopupMenuHierarchy->iDropDir ^= PAS_HORZ;
    }

    /*
     * If we have an animation direction and the caller wants animation,
     *  set the bit to get it going.
     */
    if ((ppopupMenuHierarchy->iDropDir != 0) && !(dwFlags & TPM_NOANIMATION)) {
        ppopupMenuHierarchy->iDropDir |= PAS_OUT;
    }

    /*
     * Show the window. Modeless menus are not topmost and get activated.
     *  Modal menus are topmost but don't get activated.
     */
    PlayEventSound(USER_SOUND_MENUPOPUP);
    xxxSetWindowPos(pwndHierarchy,
            (pMenuState->fModelessMenu ? PWND_TOP : PWND_TOPMOST),
            GET_X_LPARAM(sizeHierarchy), GET_Y_LPARAM(sizeHierarchy), 0, 0,
            SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOOWNERZORDER
            | (pMenuState->fModelessMenu ? 0 : SWP_NOACTIVATE));

    xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPSTART, pwndHierarchy, OBJID_CLIENT, INDEXID_CONTAINER, 0);
    
    /*
     * We need to return TRUE for compatibility w/ async TrackPopupMenu().
     * It is conceivable that a menu ID could have ID 0, in which case just
     * returning the cmd chosen would return FALSE instead of TRUE.
     */

    /*
     * If mouse is in client of popup, act like clicked down
     */
    pMenuState->fButtonDown = fButtonDown;

    cmd = xxxMNLoop(ppopupMenuHierarchy, pMenuState, 0, FALSE);

    /*
     * If this is a modeless menu, return without clenning up because
     *  the menu is up.
     */
    if (pMenuState->fModelessMenu) {
        ThreadUnlock(&tlpwndHierarchy);
        goto ReturnCmdOrTrue;
    }

CleanupTrackPopupMenuEx:

    if (ThreadUnlock(&tlpwndHierarchy)) {
        if (!TestWF(pwndHierarchy, WFDESTROYED)) {
            xxxDestroyWindow(pwndHierarchy);
        }
    }

    if (pMenuState != NULL) {
        xxxMNEndMenuState (TRUE);
    }

    /*
     * Capture must be unlocked if no menu is active.
     */
    UserAssert(!(ptiCurrent->pq->QF_flags & QF_CAPTURELOCKED)
            || ((ptiCurrent->pMenuState != NULL)
                && !ptiCurrent->pMenuState->fModelessMenu));


ReturnCmdOrTrue:
    return(fSync ? cmd : TRUE);
}

/***************************************************************************\
*
* FindBestPos()
*
* Gets best point to move popup menu window to, given exclusion area and
* screen real estate.  Note that for our purposes, we consider center
* alignment to be the same as left/top alignment.
*
* We try to pin the menu to a particular monitor, to avoid having it
* cross.
*
* We try four possibilities if the original position fails.  The order of
* these is determined by the alignment and "try" flags.  Basically, we try
* to move the rectangle out of the exclusion area by sliding it horizontally
* or vertically without going offscreen.  If we can't, then we know that
* sliding it in both dimensions will also fail.  So we use the original
* point, clipping on screen.
*
* Take the example of a top-left justified popup, which should be moved
* horizontally before vertically.  We'll try the original point.  Then
* we'll try to left-justify with the right edge of the exclude rect.  Then
* we'll try to top-justify with the bottom edge of the exclude rect.  Then
* we'll try to right-justify with the left edge of the exclude rect.  Then
* we'll try to bottom-justify with the top edge of the exclude rect.
* Finally, we'll use the original pos.
*
\***************************************************************************/

LONG
FindBestPos(
        int         x,
        int         y,
        int         cx,
        int         cy,
        LPRECT      prcExclude,
        UINT        wFlags,
        PPOPUPMENU  ppopupmenu,
        PMONITOR    pMonitor)
{
    int iRect;
    int iT;
    UINT awRect[4];
    POINT ptT;
    RECT rcExclude;
    //
    // Clip our coords on screen first.  We use the same algorithm to clip
    // as in Win3.1 for dudes with no exclude rect.
    //

    if (prcExclude!=NULL) {
        // Clip exclude rect to monitor!
        CopyRect(&rcExclude, prcExclude);
        IntersectRect(&rcExclude, &rcExclude, &pMonitor->rcMonitor);
    } else {
        SetRect(&rcExclude, x, y, x, y);
    }


    /*
     * Make sure popup fits completely on the screen
     * At least the x,y point will be on the screen.
     */
    if (x + cx > pMonitor->rcMonitor.right) {
        if ((wFlags & TPM_CENTERALIGN)
                || (x - cx < pMonitor->rcMonitor.left)
                || (x >= pMonitor->rcMonitor.right)) {
            x = pMonitor->rcMonitor.right - cx;
        } else {
            x -= cx;
        }
        if (ppopupmenu->iDropDir & PAS_HORZ) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_LEFT, PAS_HORZ);
        }
    }

    if (x < pMonitor->rcMonitor.left) {
        x += cx;
        if ((wFlags & TPM_CENTERALIGN)
                || (x >= pMonitor->rcMonitor.right)
                || (x < pMonitor->rcMonitor.left)) {
            x = pMonitor->rcMonitor.left;
        }
        if (ppopupmenu->iDropDir & PAS_HORZ) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_RIGHT, PAS_HORZ);
        }
    }

    /*
     * Make sure popup fits completely on the screen
     * At least the x+cx,y point will be on the screen
     * for right aligned menus.
     */
    if ((wFlags & TPM_RIGHTALIGN) 
            && (x + cx > pMonitor->rcMonitor.right)) {
        x = pMonitor->rcMonitor.right - cx;
    }


    if (y + cy > pMonitor->rcMonitor.bottom) {
        if ((wFlags & TPM_VCENTERALIGN)
                || (y - cy < pMonitor->rcMonitor.top)
                || (y >= pMonitor->rcMonitor.bottom)) {
            y = pMonitor->rcMonitor.bottom - cy;
        } else {
            y -= cy;
        }
        if (ppopupmenu->iDropDir & PAS_VERT) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_UP, PAS_VERT);
        }
    }

    if (y < pMonitor->rcMonitor.top) {
        y += cy;
        if ((wFlags & TPM_VCENTERALIGN)
                || (y >= pMonitor->rcMonitor.bottom)
                || (y < pMonitor->rcMonitor.top)) {
            y = pMonitor->rcMonitor.top;
        }
        if (ppopupmenu->iDropDir & PAS_VERT) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_DOWN, PAS_VERT);
        }
    }

    //
    // Try first point
    //
    if (TryRect(RECT_ORG, x, y, cx, cy, &rcExclude, &ptT, pMonitor))
        goto FOUND;

    //
    // Sort possibilities.  Get offset of horizontal rects.
    //
    iRect = (wFlags & TPM_VERTICAL) ? 2 : 0;

    //
    // Sort horizontally.  Note that we treat TPM_CENTERALIGN like
    // TPM_LEFTALIGN.
    //
    //
    // If we're right-aligned, try to right-align on left side first.
    // Otherwise, try to left-align on right side first.
    //
    iT = (wFlags & TPM_RIGHTALIGN) ? 0 : 2;

    awRect[0 + iRect] = RECT_ONLEFT + iT;
    awRect[1 + iRect] = RECT_ONRIGHT - iT;

    //
    // Sort vertically.  Note that we treat TPM_VCENTERALIGN like
    // TPM_TOPALIGN.
    //
    // If we're bottom-aligned, try to bottom-align with top of rect
    // first.  Otherwise, try to top-align with bottom of exclusion first.
    //
    iT = (wFlags & TPM_BOTTOMALIGN) ? 0 : 2;

    awRect[2 - iRect] = RECT_ONTOP + iT;
    awRect[3 - iRect] = RECT_ONBOTTOM - iT;

    //
    // Loop through sorted alternatives.  Note that TryRect fails immediately
    // if an exclusion coordinate is too close to screen edge.
    //

    for (iRect = 0; iRect < 4; iRect++) {
        if (TryRect(awRect[iRect], x, y, cx, cy, &rcExclude, &ptT, pMonitor)) {
            switch (awRect[iRect])
            {
                case RECT_ONTOP:
                    ppopupmenu->iDropDir = PAS_UP;
                    break;
                case RECT_ONLEFT:
                    ppopupmenu->iDropDir = PAS_LEFT;
                    break;
                case RECT_ONBOTTOM:
                    ppopupmenu->iDropDir = PAS_DOWN;
                    break;
                case RECT_ONRIGHT:
                    ppopupmenu->iDropDir = PAS_RIGHT;
                    break;
            }

            x = ptT.x;
            y = ptT.y;
            break;
        }
    }

FOUND:
    return MAKELONG(x, y);
}



/***************************************************************************\
*
*  TryRect()
*
*  Tries to fit rect on screen without covering exclusion area.  Returns
*  TRUE if success.
*
\***************************************************************************/

BOOL
TryRect(
        UINT        wRect,
        int         x,
        int         y,
        int         cx,
        int         cy,
        LPRECT      prcExclude,
        LPPOINT     ppt,
        PMONITOR    pMonitor)
{
    RECT rcTry;

    switch (wRect) {
        case RECT_ONRIGHT:
            x = prcExclude->right;
            if (x + cx > pMonitor->rcMonitor.right)
                return FALSE;
            break;

        case RECT_ONBOTTOM:
            y = prcExclude->bottom;
            if (y + cy > pMonitor->rcMonitor.bottom)
                return FALSE;
            break;

        case RECT_ONLEFT:
            x = prcExclude->left - cx;
            if (x < pMonitor->rcMonitor.left)
                return FALSE;
            break;

        case RECT_ONTOP:
            y = prcExclude->top - cy;
            if (y < pMonitor->rcMonitor.top)
                return FALSE;
            break;

        //
        // case RECT_ORG:
        //      NOP;
        //      break;
        //
    }

    ppt->x = x;
    ppt->y = y;

    rcTry.left      = x;
    rcTry.top       = y;
    rcTry.right     = x + cx;
    rcTry.bottom    = y + cy;

    return(!IntersectRect(&rcTry, &rcTry, prcExclude));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\movesize.c ===
/****************************************************************************\
* Module Name: movesize.c  (formerly wmmove.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains Window Moving and Sizing Routines
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
* 13-Feb-1991 IanJa     HWND revalidation added
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define DRAG_START    0
#define DRAG_MOVE     1
#define DRAG_END      2

/****************************************************************************\
* These values are indexes that represent rect sides. These indexes are
* used as indexes into rgimpiwx and rgimpiwy (which are indexes into the
* the rect structure) which tell the move code where to store the new x & y
* coordinates. Notice that when two of these values that represent sides
* are added together, we get a unique list of contiguous values starting at
* 1 that represent all the ways we can size a rect. That also leaves 0 free
* a initialization value.
*
* The reason we need rgimpimpiw is for the keyboard interface - we
* incrementally decide what our 'move command' is. With the mouse interface
* we know immediately because we registered a mouse hit on the segment(s)
* we're moving.
*
*       4           5
*        \ ___3___ /
*         |       |
*         1       2
*         |_______|
*        /    6    \
*       7           8
*
\****************************************************************************/

static const int rgimpimpiw[] = {1, 3, 2, 6};
static const int rgimpiwx[]   = {0,  0,  2, -1, 0, 2, -1, 0, 2, 0};
static const int rgimpiwy[]   = {0, -1, -1,  1, 1, 1,  3, 3, 3, 1};
static const int rgcmdmpix[]  = {0, 1, 2, 0, 1, 2, 0, 1, 2, 1};
static const int rgcmdmpiy[]  = {0, 0, 0, 3, 3, 3, 6, 6, 6, 3};

/***************************************************************************\
* GetMonitorMaxArea
*
* Return the rectangle on a monitor which should be used to
* maximize to, the work rect or the monitor rect.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

void
GetMonitorMaxArea(PWND pwnd, PMONITOR pMonitor, LPRECT * pprc)
{
    if (    !TestWF(pwnd, WFMAXBOX) ||
            !TestWF(pwnd, WFCPRESENT) ||
            pMonitor->cFullScreen) {

        *pprc = &pMonitor->rcMonitor;
    } else {
        *pprc = &pMonitor->rcWork;
    }
}


/***************************************************************************\
* SizeRect
*
* Match corner or side (defined by cmd) to pt.
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3 asm code
\***************************************************************************/

BOOL SizeRect(
    PMOVESIZEDATA pmsd,
    DWORD         pt)
{
    int  ax;
    int  dx;
    int  index;
    int  indexOpp;
    PINT psideDragCursor = ((PINT)(&pmsd->rcDragCursor));
    PINT psideParent     = ((PINT)(&pmsd->rcParent));


    /*
     * DO HORIZONTAL
     */

    /*
     * We know what part of the rect we're moving based on
     * what's in cmd.  We use cmd as an index into rgimpiw? which
     * tells us what part of the rect we're dragging.
     */

    /*
     * Get the approriate array entry.
     */
    index = (int)rgimpiwx[pmsd->cmd];   // AX

    /*
     * Is it one of the entries we don't map (i.e.  -1)?
     */
    if (index < 0)
        goto mrLoopBottom;

    psideDragCursor[index] = LOSHORT(pt);

    indexOpp = index ^ 0x2;

    /*
     * Now check to see if we're below the min or above the max. Get the width
     * of the rect in this direction (either x or y) and see if it's bad. If
     * so, map the side we're moving to the min or max.
     */
    ax = psideDragCursor[index] - psideDragCursor[indexOpp];

    if (indexOpp & 0x2)
        ax = -ax;

    if ((ax >= (dx = pmsd->ptMinTrack.x)) &&
        (ax <= (dx = pmsd->ptMaxTrack.x))) {

        /*
         * Only test for the parent's client boundary if we are a child
         * window...Otherwise we are bound to the client of the desktop
         * which causes strange drag problems.
         */
        if (!TestWF(pmsd->spwnd,WFCHILD))
            goto mrLoopBottom;

        /*
         * Now see if we're extending beyond our parent's client rect.
         * Compute the size the rect can be expanded to in this direction.
         */
        dx = abs(psideParent[index] - psideDragCursor[indexOpp]);

        if (ax <= dx)
            goto mrLoopBottom;

        /*
         * The width is invalid - map the side we're moving to the other
         * side +/- the width.
         */
    }

    if (indexOpp & 0x2)
        dx = -dx;

    psideDragCursor[index] = dx + psideDragCursor[indexOpp];

mrLoopBottom:

    /*
     * DO VERTICAL
     */

    /*
     * We know what part of the rect we're moving based on
     * what's in cmd.  We use cmd as an index into rgimpiw? which
     * tells us what part of the rect we're dragging.
     */

    /*
     * Get the approriate array entry.
     */
    index = (int)rgimpiwy[pmsd->cmd];   // AX

    /*
     * Is it one of the entries we don't map (i.e.  -1)?
     */
    if (index < 0)
        return TRUE;

    psideDragCursor[index] = HISHORT(pt);

    indexOpp = index ^ 0x2;

    /*
     * Now check to see if we're below the min or above the max. Get the width
     * of the rect in this direction (either x or y) and see if it's bad. If
     * so, map the side we're moving to the min or max.
     */
    ax = psideDragCursor[index] - psideDragCursor[indexOpp];

    if (indexOpp & 0x2)
        ax = -ax;

    if ((ax >= (dx = pmsd->ptMinTrack.y)) &&
        (ax <= (dx = pmsd->ptMaxTrack.y))) {

        /*
         * Only test for the parent's client boundary if we are a child
         * window...Otherwise we are bound to the client of the desktop
         * which causes strange drag problems.
         */
        if (!TestWF(pmsd->spwnd,WFCHILD))
            return TRUE;

        /*
         * Now see if we're extending beyond our parent's client rect.
         * Compute the size the rect can be expanded to in this direction.
         */
        dx = abs(psideParent[index] - psideDragCursor[indexOpp]);

        if (ax <= dx)
            return TRUE;

        /*
         * The width is invalid - map the side we're moving to the other
         * side +/- the width.
         */
    }

    if (indexOpp & 0x2)
        dx = -dx;

    psideDragCursor[index] = dx + psideDragCursor[indexOpp];

    return TRUE;
}

/***************************************************************************\
* MoveRect
*
* Move the rect to pt, make sure we're not going out of the parent rect.
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3 asm code
\***************************************************************************/

BOOL MoveRect(
    PMOVESIZEDATA pmsd,
    DWORD         pt)
{
    RECT rcAnd;

    OffsetRect(&pmsd->rcDragCursor,
               LOSHORT(pt) - pmsd->rcDragCursor.left,
               HISHORT(pt) - pmsd->rcDragCursor.top);

    /*
     * Don't move the entire rectangle off the screen.
     * However, if the window started offscreen completely, let it move.
     */
    if (pmsd->fOffScreen)
        return TRUE;

    if (pmsd->spwnd->spwndParent->hrgnClip) {
        return GreRectInRegion(
                pmsd->spwnd->spwndParent->hrgnClip, &pmsd->rcDragCursor);
    }

    return IntersectRect(&rcAnd, &pmsd->rcDragCursor, &pmsd->rcParent);
}

/***************************************************************************\
* xxxTM_MoveDragRect
*
* History:
* 12-Nov-1990 MikeHar      Ported from win3
\***************************************************************************/

VOID xxxTM_MoveDragRect(
    PMOVESIZEDATA pmsd,
    LPARAM        lParam)
{
    UINT msg;
    RECT rc;

    UserAssert(pmsd == PtiCurrent()->pmsd);
    UserAssert(pmsd->cmd != WMSZ_KEYSIZE);

    CopyRect(&pmsd->rcDragCursor, &pmsd->rcDrag);

    if (pmsd->cmd == WMSZ_MOVE) {

        if (!MoveRect(pmsd, (DWORD)lParam))
            return;

        msg = WM_MOVING;

    } else {

        if (!SizeRect(pmsd, (DWORD)lParam))
            return;

        msg = WM_SIZING;
    }

    CopyRect(&rc, &pmsd->rcDragCursor);
    xxxSendMessage(pmsd->spwnd, msg, pmsd->cmd, (LPARAM)(LPRECT)&rc);
    xxxDrawDragRect(pmsd, &rc, DRAG_MOVE);

    if (pmsd->cmd == WMSZ_MOVE) {

        /*
         * Keep dxMouse & dxMouse relative to the offset from the top left
         * corner, the rectangle could've changed on WM_MOVING
         */
        pmsd->dxMouse += (rc.left - LOSHORT(lParam));
        pmsd->dyMouse += (rc.top - HISHORT(lParam));
    }
}

/***************************************************************************\
* CkptRestore
*
* Positions are always relative to the origin of the monitor's working
* area that the window is on, except for rcNormal.  That way, windows will
* maximize to the working area of the monitor they find themselves on, and
* not to a random place.
*
* This allows us to keep information in a reasonably independent fashion,
* information that doesn't go out of date when a window moves or the
* monitors are configured differently.
*
* rcNormal is different because that does need to be absolute.  It's where
* the window should come up the first time in a normal state.
*
* History:
* 14-Nov-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/

PCHECKPOINT CkptRestore(
    PWND    pwnd,
    LPCRECT lprcWindow)
{
    PCHECKPOINT pcp;

    /*
     * Don't return or create a checkpoint if the window is dying.
     */
    if (HMIsMarkDestroy(pwnd))
        return NULL;

    /*
     * If it doesn't exist, create it.
     */
    if ((pcp = (PCHECKPOINT)_GetProp(pwnd,
                                     PROP_CHECKPOINT,
                                     PROPF_INTERNAL)) == NULL) {

        if ((pcp = (PCHECKPOINT)UserAllocPoolWithQuota(sizeof(CHECKPOINT),
                                                       TAG_CHECKPT)) == NULL) {
            return NULL;
        }

        if (!InternalSetProp(pwnd,
                             PROP_CHECKPOINT,
                             (HANDLE)pcp,
                             PROPF_INTERNAL)) {

            UserFreePool(pcp);
            return NULL;
        }

        /*
         * Initialize it to -1 so first minimize will park the icon.
         */
        pcp->ptMin.x = -1;
        pcp->ptMin.y = -1;
        pcp->ptMax.x = -1;
        pcp->ptMax.y = -1;

        /*
         * Initialize pwndTitle to NULL so we create a title window on the
         * first minimize of the window
         */
        pcp->fDragged                     = FALSE;
        pcp->fWasMaximizedBeforeMinimized = FALSE;
        pcp->fWasMinimizedBeforeMaximized = FALSE;
        pcp->fMinInitialized              = FALSE;
        pcp->fMaxInitialized              = FALSE;

        /*
         * BOGUS!  We're going to copy this twice if the window isn't
         * minimized or maximized.  But if it isn't, we're going to get
         * a weird size in rcNormal...
         */
        CopyRect(&pcp->rcNormal, lprcWindow);
    }

    /*
     * If the window is minimized/maximized, then set the min/max
     * point.  Otherwise use checkpoint the window-size.
     */
    if (TestWF(pwnd, WFMINIMIZED)) {
        pcp->fMinInitialized = TRUE;
        pcp->ptMin.x = lprcWindow->left;
        pcp->ptMin.y = lprcWindow->top;
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        pcp->fMaxInitialized = TRUE;

        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            if (TestWF(pwnd, WFREALLYMAXIMIZABLE)) {
                pcp->fMaxInitialized = FALSE;
                pcp->ptMax.x = -1;
                pcp->ptMax.y = -1;
            } else {
                PMONITOR pMonitor;
                LPRECT   lprc;

                pMonitor = _MonitorFromRect(lprcWindow, MONITOR_DEFAULTTOPRIMARY);
                GetMonitorMaxArea(pwnd, pMonitor, &lprc);
                pcp->ptMax.x = lprcWindow->left - lprc->left;
                pcp->ptMax.y = lprcWindow->top - lprc->top;
            }
        } else {
            pcp->ptMax.x = lprcWindow->left;
            pcp->ptMax.y = lprcWindow->top;
        }
    } else {
        CopyRect(&pcp->rcNormal, lprcWindow);
    }

    return pcp;
}

/***************************************************************************\
* xxxMS_TrackMove
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

void xxxMS_TrackMove(
    PWND          pwnd,
    UINT          message,
    WPARAM        wParam,
    LPARAM        lParam,
    PMOVESIZEDATA pmsd)
{
    int         dxMove;
    int         dyMove;
    POINT       pt;
    BOOL        fSlower;
    RECT        rc;
    PCHECKPOINT pcp;
    LPWORD      ps;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());
    UserAssert(pmsd == ptiCurrent->pmsd);

    pt.x = LOSHORT(lParam);
    pt.y = HISHORT(lParam);

    switch (message) {
    case WM_LBUTTONUP:

        /*
         * Do final move!
         */
        xxxTM_MoveDragRect(pmsd, lParam);


        /*
         * Don't reset the mouse position when done.
         */
        pmsd->fmsKbd = FALSE;

Accept:

        /*
         * Turn off rect, unlock screen, release capture, and stop tracking.
         * 1 specifies end and accept drag.
         */
        bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
        if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {
            xxxDrawDragRect(pmsd, NULL, DDR_ENDACCEPT);
            ptiCurrent->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
        }

TrackMoveCancel:

        /*
         * Revalidation: if pwnd is unexpectedly deleted, jump here to cleanup.
         * If pwnd is/becomes invalid between here and return, continue with
         * cleanup as best as possible.
         */
        zzzClipCursor((LPRECT)NULL);
        LockWindowUpdate2(NULL, TRUE);
        xxxReleaseCapture();

        /*
         * First unlock task and reset cursor.
         */
        pmsd->fTrackCancelled = TRUE;

        /*
         * If using the keyboard, restore the initial mouse position.
         */
        if (pmsd->fmsKbd) {
            /*
             * No DeferWinEventNotify required - xxx calls above & below
             */
            zzzInternalSetCursorPos(pmsd->ptRestore.x,
                                 pmsd->ptRestore.y
                                 );
        }

        /*
         * Move to new location relative to parent.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            rc.left = rc.top = 0;
        } else {
            rc.left = pwnd->spwndParent->rcClient.left;
            rc.top = pwnd->spwndParent->rcClient.top;
        }

        if (!EqualRect(&pmsd->rcDrag, &pmsd->rcWindow)) {

            if (!xxxCallHook(HCBT_MOVESIZE,
                             (WPARAM)HWq(pwnd),
                             (LPARAM)&pmsd->rcDrag,
                             WH_CBT)) {

                RECT rcT;

                if (pmsd->cmd != WMSZ_MOVE) {

                    if (TestWF(pwnd, WFMINIMIZED)) {

                        CopyOffsetRect(&rcT,
                                       &pmsd->rcWindow,
                                       -rc.left,
                                       -rc.top);

                        /*
                         * Save the minimized position.
                         */
                        CkptRestore(pwnd, &rcT);
                        SetMinimize(pwnd, SMIN_CLEAR);

                    } else if (TestWF(pwnd, WFMAXIMIZED)) {
                        ClrWF(pwnd, WFMAXIMIZED);
                    }

                } else if (TestWF(pwnd, WFMINIMIZED)) {

                    CopyOffsetRect(&rcT,
                                   &pmsd->rcWindow,
                                   -rc.left,
                                   -rc.top);


                    if (pcp = CkptRestore(pwnd, &rcT))
                        pcp->fDragged = TRUE;
                }

            } else {
                CopyRect(&pmsd->rcDrag, &pmsd->rcWindow);
            }
        }

        /*
         * Move to new location relative to parent.
         */
        if (TestWF(pwnd->spwndParent,WEFLAYOUTRTL)) {
            /*
             * If this is a mirrored window, then measure the client
             * coordinates from the parent's right edge, not the left one.
             */
            int iLeft;

            OffsetRect(&pmsd->rcDrag, -pwnd->spwndParent->rcClient.right, -rc.top);
            iLeft = pmsd->rcDrag.left;
            pmsd->rcDrag.left  = (pmsd->rcDrag.right * -1);
            pmsd->rcDrag.right = (iLeft * -1);
        } else {
            OffsetRect(&pmsd->rcDrag, -rc.left, -rc.top);
        }

        /*
         * For top level windows, make sure at least part of the caption
         * caption is always visible in the desktop area.  This will
         * ensure that once moved, the window can be moved back.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {

            int         dy;
            BOOL        fMonitor;
            PMONITOR    pMonitor;

            UserAssert(HIBYTE(WEFTOPMOST) == HIBYTE(WEFTOOLWINDOW));
            fMonitor = TestWF(pwnd, WEFTOPMOST | WEFTOOLWINDOW);
            dy = (TestWF(pwnd, WEFTOOLWINDOW) ?
                    SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION)) - SYSMET(CYBORDER);

            if (gpDispInfo->cMonitors == 1) {
                pMonitor = GetPrimaryMonitor();
            } else {
                int     y;
                LPRECT  lprc;

                y = pmsd->rcDrag.top + dy;

                /*
                 * Make sure that some part of the caption is showing on some
                 * monitor...
                 */
                for (   pMonitor = gpDispInfo->pMonitorFirst;
                        pMonitor;
                        pMonitor = pMonitor->pMonitorNext) {

                    if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
                        continue;

                    if (fMonitor) {
                        lprc = &pMonitor->rcMonitor;
                    } else {
                        lprc = &pMonitor->rcWork;
                    }

                    /*
                     * Is the Y coordinate visible on screen somewhere?
                     */
                    if (y >= lprc->top && y < lprc->bottom)
                        goto AllSet;
                }

                /*
                 * Oops, have to move the window so that some part of
                 * the caption is visible on screen.
                 */
                pMonitor = _MonitorFromRect(&pmsd->rcDrag, MONITOR_DEFAULTTONEAREST);
            }

            if (fMonitor) {
                pmsd->rcDrag.top = max(pmsd->rcDrag.top, pMonitor->rcMonitor.top - dy);
            } else {
                pmsd->rcDrag.top = max(pmsd->rcDrag.top, pMonitor->rcWork.top - dy);
            }

AllSet:
            ;
        }

        /*
         * OR in SWP_NOSIZE so it doesn't redraw if we're just moving.
         */
        xxxSetWindowPos(
                pwnd,
                NULL,
                pmsd->rcDrag.left,
                pmsd->rcDrag.top,
                pmsd->rcDrag.right - pmsd->rcDrag.left,
                pmsd->rcDrag.bottom - pmsd->rcDrag.top,
                (DWORD)((pmsd->cmd == (int)WMSZ_MOVE) ? SWP_NOSIZE : 0));

        if (TestWF(pwnd, WFMINIMIZED)) {
            CkptRestore(pwnd, &pmsd->rcDrag);
        }

        xxxWindowEvent(EVENT_SYSTEM_MOVESIZEEND, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);

        /*
         * Send this message for winoldapp support
         */
        xxxSendMessage(pwnd, WM_EXITSIZEMOVE, 0L, 0L);
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:

        /*
         * Assume we're not moving the drag rectangle.
         */
        dxMove =
        dyMove = 0;

        /*
         * We move or size slower if the control key is down.
         */
        fSlower = (_GetKeyState(VK_CONTROL) < 0);

        switch (wParam) {
        case VK_RETURN:
            lParam = _GetMessagePos();
            goto Accept;

        case VK_ESCAPE:

            /*
             * 2 specifies end and cancel drag.
             */
            bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
            if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {
                xxxDrawDragRect(pmsd, NULL, DDR_ENDCANCEL);
                ptiCurrent->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
            }

            CopyRect(&pmsd->rcDrag, &pmsd->rcWindow);

            goto TrackMoveCancel;

        case VK_LEFT:
        case VK_RIGHT:

            if (pmsd->impx == 0) {

                pmsd->impx = rgimpimpiw[wParam - VK_LEFT];
                goto NoOffset;

            } else {

                dxMove = (fSlower ? 1 : max(SYSMET(CXSIZE) / 2, 1));

                if (wParam == VK_LEFT)
                    dxMove = -dxMove;

                goto KeyMove;
            }

        case VK_UP:
        case VK_DOWN:

            if (pmsd->impy == 0) {

                pmsd->impy = rgimpimpiw[wParam - VK_LEFT];
NoOffset:
                pmsd->dxMouse = pmsd->dyMouse = 0;

            } else {

                dyMove = (fSlower ? 1 : max(SYSMET(CYSIZE) / 2, 1));

                if (wParam == VK_UP) {
                    dyMove = -dyMove;
                }
            }

KeyMove:
            if (pmsd->cmd == WMSZ_MOVE) {

                /*
                 * Use the current rect position as the current mouse
                 * position
                 */
                lParam = (DWORD)(POINTTOPOINTS(*((POINT *)&pmsd->rcDrag)));

            } else {

                /*
                 * Get the current mouse position
                 */
                lParam = _GetMessagePos();
            }

            /*
             * Calc the new 'mouse' pos
             */
            if (pmsd->impx != 0) {
                ps = ((WORD *)(&lParam)) + 0;
                *ps = (WORD)(*((int *)&pmsd->rcDragCursor +
                             rgimpiwx[pmsd->impx])        +
                             dxMove);
            }

            if (pmsd->impy != 0) {
                ps = ((WORD *)(&lParam)) + 1;
                *ps = (WORD)(*((int *)&pmsd->rcDragCursor +
                             rgimpiwy[pmsd->impy])        +
                             dyMove);
            }

            if (pmsd->cmd != WMSZ_MOVE) {

                /*
                 * Calculate the new move command.
                 */
                pmsd->cmd = pmsd->impx + pmsd->impy;

                /*
                 * Change the mouse cursor for this condition.
                 */
                xxxSendMessage(
                        pwnd,
                        WM_SETCURSOR,
                        (WPARAM)HW(pwnd),
                        MAKELONG((SHORT)(pmsd->cmd + HTSIZEFIRST - WMSZ_SIZEFIRST), WM_MOUSEMOVE));
            }

            /*
             * We don't want to call zzzInternalSetCursorPos() if the
             * rect position is outside of rcParent because that'll
             * generate a mouse move which will jerk the rect back
             * again.  This is here so we can move rects partially off
             * screen without regard to the mouse position.
             */
            pt.x = LOSHORT(lParam) - pmsd->dxMouse;
            pt.y = HISHORT(lParam) - pmsd->dyMouse;

            if (pwnd->spwndParent->hrgnClip) {
                if (GrePtInRegion(pwnd->spwndParent->hrgnClip, pt.x, pt.y)) {
                    zzzInternalSetCursorPos(pt.x, pt.y);
                }
            } else {
                if (PtInRect(&pmsd->rcParent, pt)) {
                    zzzInternalSetCursorPos(pt.x, pt.y);
                }
            }

            /*
             * Move or size the rect using lParam as our mouse
             * coordinates
             */
            xxxTM_MoveDragRect(pmsd, lParam);
            break;

        }  // of inner switch
        break;

    case WM_MOUSEMOVE:
        xxxTM_MoveDragRect(pmsd, lParam);
        break;
    }
}

/***************************************************************************\
* xxxMS_FlushWigglies
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

VOID xxxMS_FlushWigglies(VOID)
{
    MSG msg;

    /*
     * HACK!
     *
     * Calling zzzInternalSetCursorPos() while initializing the cursor
     * position appears to be posting a bogus MouseMove
     * message...  don't really have the time
     * now to figure out why...  so spit out all the mouse move messages
     * before entering the main move/size loop.  CraigC.
     */
    while (xxxPeekMessage(&msg,
                          NULL,
                          WM_MOUSEMOVE,
                          WM_MOUSEMOVE,
                          PM_REMOVE | PM_NOYIELD));
}

/***************************************************************************\
* xxxTrackInitSize
*
* NOTE: to recover from hwnd invalidation, just return and let ?
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

BOOL xxxTrackInitSize(
    PWND          pwnd,
    UINT          message,
    WPARAM        wParam,
    LPARAM        lParam,
    PMOVESIZEDATA pmsd)
{
    int   ht;
    POINT pt;
    RECT  rc;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(pmsd == ptiCurrent->pmsd);
    UserAssert(IsWinEventNotifyDeferredOK());

    POINTSTOPOINT(pt, lParam);

    _ClientToScreen(pwnd, (LPPOINT)&pt);
    ht = FindNCHit(pwnd, POINTTOPOINTS(pt));

    switch (message) {

    case WM_KEYDOWN:
        if (pmsd->cmd == WMSZ_MOVE) {
            xxxSendMessage(pwnd,
                           WM_SETCURSOR,
                           (WPARAM)HW(pwnd),
                           MAKELONG(WMSZ_KEYSIZE, WM_MOUSEMOVE));
        }
        /* keys below are only allowed */
        switch (wParam) {
        case VK_RETURN:
        case VK_ESCAPE:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            pmsd->fInitSize = FALSE;
            break;
        }
        return TRUE;

    case WM_LBUTTONDOWN:
        if (!PtInRect(&pmsd->rcDrag, pt)) {

            /*
             *** FALL THRU ***
             */

    case WM_LBUTTONUP:

            /*
             * Cancel everything.
             */
            {
                PTHREADINFO ptiCurrent = PtiCurrent();

                bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
                if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {
                    xxxDrawDragRect(pmsd, NULL, DDR_ENDCANCEL);
                    ptiCurrent->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
                }

                pmsd->fInitSize = FALSE;
                zzzClipCursor(NULL);
            }

            xxxReleaseCapture();
            pmsd->fTrackCancelled = TRUE;
            return FALSE;

        } else {

            /*
             * Now start hit testing for a border.
             */
            goto CheckFrame;
        }

    case WM_MOUSEMOVE:

        /*
         * The mouse is down, hit test for a border on mouse moves.
         */
        if (wParam == MK_LBUTTON) {

CheckFrame:

            switch (pmsd->cmd) {
            case WMSZ_MOVE:

                /*
                 * If we are on the caption bar, exit.
                 */
                if (ht == HTCAPTION) {

                    /*
                     * Change the mouse cursor.
                     */
                    xxxSendMessage(pwnd,
                                   WM_SETCURSOR,
                                   (WPARAM)HW(pwnd),
                                   MAKELONG(WMSZ_KEYSIZE, WM_MOUSEMOVE));

                    pmsd->dxMouse   = pmsd->rcWindow.left - pt.x;
                    pmsd->dyMouse   = pmsd->rcWindow.top - pt.y;
                    pmsd->fInitSize = FALSE;
                    return TRUE;
                }
                break;

            case WMSZ_KEYSIZE:

                /*
                 * If we are on a frame control, change the cursor and exit.
                 */
                if (ht >= HTSIZEFIRST && ht <= HTSIZELAST) {

                    /*
                     * Change the mouse cursor
                     */
                    xxxSendMessage(pwnd,
                                   WM_SETCURSOR,
                                   (WPARAM)HW(pwnd),
                                   MAKELONG(ht, WM_MOUSEMOVE));

                    pmsd->fInitSize = FALSE;

                    /*
                     * Set the proper cmd for SizeRect().
                     *
                     * HACK! Depends on order of HTSIZE* defines!
                     */
                    pmsd->impx = rgcmdmpix[ht - HTSIZEFIRST + 1];
                    pmsd->impy = rgcmdmpiy[ht - HTSIZEFIRST + 1];
                    pmsd->cmd  = pmsd->impx + pmsd->impy;

                    pmsd->dxMouse = *((UINT FAR *)&pmsd->rcWindow + rgimpiwx[pmsd->cmd]) - pt.x;
                    pmsd->dyMouse = *((UINT FAR *)&pmsd->rcWindow + rgimpiwy[pmsd->cmd]) - pt.y;

                    return TRUE;
                }
            }

        } else {

            /*
             * If button not down, and we are moving the window, change the
             * cursor shape depending upon where the mouse is pointing.  This
             * allows the cursor to change to the arrows when over the window
             * frame.
             */
            CopyRect(&rc, &pwnd->rcWindow);
            if (PtInRect(&rc, pt)) {
                if ((ht >= HTSIZEFIRST) && (ht <= HTSIZELAST)) {
                    xxxSendMessage(pwnd,
                                   WM_SETCURSOR,
                                   (WPARAM)HW(pwnd),
                                   MAKELONG(ht, WM_MOUSEMOVE));

                    break;
                }
            }

            zzzSetCursor(SYSCUR(SIZEALL));
        }
        break;
    }

    return TRUE;
}

/***************************************************************************\
* xxxMoveSize
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

VOID xxxMoveSize(
    PWND  pwnd,
    UINT  cmdMove,
    DWORD wptStart)
{
    MSG             msg;
    int             x;
    int             y;
    int             i;
    RECT            rcSys;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PMOVESIZEDATA   pmsd;
    TL              tlpwndT;
    PWND            pwndT;
    POINT           ptStart;
    MINMAXINFO      mmi;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Don't allow the app to track a window
     * from another queue.
     */
    if (GETPTI(pwnd)->pq != ptiCurrent->pq)
        return;

    if (ptiCurrent->pmsd != NULL)
        return;

    /*
     * If the window with the focus is a combobox, hide the dropdown
     * listbox before tracking starts.  The dropdown listbox is not a
     * child of the window being moved, therefore it won't be moved along
     * with the window.
     *
     * NOTE: Win 3.1 doesn't perform this check.
     */
    if ((pwndT = ptiCurrent->pq->spwndFocus) != NULL) {

        if (GETFNID(pwndT) == FNID_COMBOBOX) {
            ;
        } else if ((pwndT->spwndParent != NULL) &&
                (GETFNID(pwndT->spwndParent) == FNID_COMBOBOX)) {

            pwndT = pwndT->spwndParent;
        } else {
            pwndT = NULL;
        }

        if (pwndT != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);
            xxxSendMessage(pwndT, CB_SHOWDROPDOWN, FALSE, 0);
            ThreadUnlock(&tlpwndT);
        }
    }

    /*
     * Allocate and zero the movesize data structure
     */
    pmsd = (PMOVESIZEDATA)UserAllocPoolWithQuotaZInit(
            sizeof(MOVESIZEDATA), TAG_MOVESIZE);

    if (pmsd == NULL)
        return;

    /*
     * Assign the move data into the pti.  If the thread is destroyed before
     * we free the data the DestroyThreadInfo() routine will free the move data
     */
    ptiCurrent->pmsd = pmsd;

    Lock(&(pmsd->spwnd), pwnd);

    /*
     * Set fForeground so we know whether to draw or not.
     */
    pmsd->fForeground = (ptiCurrent->pq == gpqForeground) ? TRUE : FALSE;

    /*
     * Lower the priority of the thread doing the dragging to make sure
     * that we don't starve other threads and they get to repaint more often.
     */
    if (ptiCurrent == gptiForeground) {
        SetForegroundPriority(ptiCurrent, FALSE);
    }

    /*
     * Get the client and window rects.
     */
    CopyRect(&pmsd->rcWindow, &pwnd->rcWindow);

    if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        if (    TestWF(pwnd, WEFTOPMOST) ||
                TestWF(pwnd, WEFTOOLWINDOW) ||
                gpDispInfo->cMonitors > 1) {

            pmsd->rcParent = gpDispInfo->rcScreen;
         } else {
            pmsd->rcParent = GetPrimaryMonitor()->rcWork;
         }
    } else {
        CopyRect(&pmsd->rcParent, &pwnd->spwndParent->rcClient);

        /*
         * If the parent does have a region, intersect with its bounding rect.
         */
        if (pwnd->spwndParent->hrgnClip != NULL) {

            RECT rcT;

            GreGetRgnBox(pwnd->spwndParent->hrgnClip, &rcT);
            IntersectRect(&pmsd->rcParent, &pmsd->rcParent, &rcT);
        }
    }

    /*
     * This works for multiple monitors _and_ regional windows
     */
    if (pwnd->spwndParent->hrgnClip) {
        pmsd->fOffScreen = !GreRectInRegion(pwnd->spwndParent->hrgnClip, &pmsd->rcWindow);
    } else {
        pmsd->fOffScreen = !IntersectRect(&rcSys, &pmsd->rcWindow, &pmsd->rcParent);
    }

    /*
     * No need to DeferWinEventNotify(), judging by xxxInitSendValidateMinMaxInfo below
     */
    zzzClipCursor(&pmsd->rcParent);
    CopyRect(&rcSys, &pmsd->rcWindow);

    if (TestWF(pwnd, WFMINIMIZED)) {

        /*
         * No need to send WM_GETMINMAXINFO since we know the minimized size.
         */
        pmsd->ptMinTrack.x = pmsd->ptMaxTrack.x = SYSMET(CXMINIMIZED);
        pmsd->ptMinTrack.y = pmsd->ptMaxTrack.y = SYSMET(CYMINIMIZED);

    } else {
        xxxInitSendValidateMinMaxInfo(pwnd, &mmi);
        pmsd->ptMinTrack = mmi.ptMinTrackSize;
        pmsd->ptMaxTrack = mmi.ptMaxTrackSize;
    }

    /*
     * Set up the drag rectangle.
     */
    CopyRect(&pmsd->rcDrag, &pmsd->rcWindow);
    CopyRect(&pmsd->rcDragCursor, &pmsd->rcDrag);

    ptStart.x = LOSHORT(wptStart);
    ptStart.y = HISHORT(wptStart);

    /*
     * Assume Move/Size from mouse.
     */
    pmsd->fInitSize = FALSE;
    pmsd->fmsKbd = FALSE;

    /*
     * Get the mouse position for this move/size command.
     */
    switch (pmsd->cmd = cmdMove) {
    case WMSZ_KEYMOVE:
        pmsd->cmd = cmdMove = WMSZ_MOVE;

        /*
         ** FALL THRU **
         */

    case WMSZ_KEYSIZE:
        /*
         * No need to DeferWinEventNotify() - pmsd won't go away, and pwnd is locked
         */
        zzzSetCursor(SYSCUR(SIZEALL));

        if (!TestWF(pwnd, WFMINIMIZED))
            pmsd->fInitSize = TRUE;

        /*
         * Workaround: always behave as if the command is
         * issued using keyboard.
         * if it's found as the wrong way, the behavior is defined as:
         * if (mnFocus == KEYBDHOLD) ||
         *   ((mnFocus == MOUSEHOLD) && TestWF(pwnd, WFMINIMIZED))) {
         * In order to do this, mnFocus should be saved somewhere.
         * originally, mnFocus was saved in MenuState.
         */
        pmsd->fmsKbd      = TRUE;
        pmsd->ptRestore.x = LOSHORT(wptStart);
        pmsd->ptRestore.y = HISHORT(wptStart);

        /*
         * Center cursor in caption area of window
         */

        /*
         * Horizontally
         */
        ptStart.x = (pmsd->rcDrag.left + pmsd->rcDrag.right) / 2;

        /*
         * Vertically
         */
        if (TestWF(pwnd,WFMINIMIZED) || (pmsd->cmd != WMSZ_MOVE)) {
            ptStart.y = (pmsd->rcDrag.top + pmsd->rcDrag.bottom) / 2;
        } else {
            int dy;

            dy = GetCaptionHeight(pwnd);
            ptStart.y = pmsd->rcDrag.top + SYSMET(CYFIXEDFRAME) + dy / 2;
        }

        zzzInternalSetCursorPos(ptStart.x, ptStart.y);
        xxxMS_FlushWigglies();
        break;

    default:
        break;
    }

    pmsd->fDragFullWindows = TEST_BOOL_PUDF(PUDF_DRAGFULLWINDOWS);
    SET_OR_CLEAR_PUDF(PUDF_DRAGGINGFULLWINDOW, pmsd->fDragFullWindows);

    /*
     * If we hit with the mouse, set up impx and impy so that we
     * can use the keyboard too.
     */
    pmsd->impx = rgcmdmpix[cmdMove];
    pmsd->impy = rgcmdmpiy[cmdMove];

    /*
     * Setup dxMouse and dyMouse - If we're sizing with the keyboard these
     * guys are set to zero down in the keyboard code.
     */
    if ((i = rgimpiwx[cmdMove]) != (-1))
        pmsd->dxMouse = *((int *)&pmsd->rcWindow + (short)i) - ptStart.x;

    if ((i = rgimpiwy[cmdMove]) != (-1))
        pmsd->dyMouse = *((int *)&pmsd->rcWindow + (short)i) - ptStart.y;

    /*
     * Tell Gdi the width of the drag rect (if its a special size)
     * Turn the drag rect on.  0 specifies start drag.
     */
    if (!TestWF(pwnd, WFSIZEBOX))
        bSetDevDragWidth(gpDispInfo->hDev, 1);

    xxxWindowEvent(EVENT_SYSTEM_MOVESIZESTART, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    xxxDrawDragRect(pmsd, NULL, DDR_START);
    ptiCurrent->TIF_flags |= TIF_TRACKRECTVISIBLE;

    msg.lParam = MAKELONG(ptStart.x, ptStart.y);

    /*
     * Right here win3.1 calls LockWindowUpdate(). This calls zzzSetFMouseMoved()
     * which ensures that the next message in the queue is a mouse message.
     * We need that mouse message as the first message because the first
     * call to TrackInitSize() assumes that lParam is an x, y from a mouse
     * message - scottlu.
     */
    zzzSetFMouseMoved();

    /*
     * Send this message for winoldapp support
     */
    xxxSendMessage(pwnd, WM_ENTERSIZEMOVE, 0L, 0L);
    xxxCapture(ptiCurrent, pwnd, CLIENT_CAPTURE_INTERNAL);

    /*
     * Show the move cursor for non-mouse systems.
     */
    zzzShowCursor(TRUE);

    while (!(pmsd->fTrackCancelled)) {

        /*
         * Let other messages not related to dragging be dispatched
         * to the application window.
         * In the case of clock, clock will now receive messages to
         * update the time displayed instead of having the time display
         * freeze while we are dragging.
         */
        while (ptiCurrent->pq->spwndCapture == pwnd) {

            if (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                if ((msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST)
                    || (msg.message == WM_QUEUESYNC)
                    || (msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST)) {

                    break;
                }

                if (_CallMsgFilter(&msg, cmdMove == WMSZ_MOVE ? MSGF_MOVE : MSGF_SIZE)) {
                    continue;
                }

                xxxTranslateMessage(&msg, 0);
                /*
                 * To prevent applications from doing
                 * a PeekMessage loop and getting the mouse move messages that
                 * are destined for the xxxMoveSize PeekMessage loop, we OR in
                 * this flag. See comments in input.c for xxxInternalGetMessage.
                 */
                ptiCurrent->TIF_flags |= TIF_MOVESIZETRACKING;
                xxxDispatchMessage(&msg);
                ptiCurrent->TIF_flags &= ~TIF_MOVESIZETRACKING;

            } else {
                /*
                 * If we've been cancelled by someone else, or our pwnd
                 * has been destroyed, blow out of here.
                 */
                if (pmsd->fTrackCancelled)
                    break;

                if (!xxxWaitMessage())
                    break;
            }
        }

        /*
         * If we've lost capture while tracking,
         * cancel the move/size operation.
         */
        if (ptiCurrent->pq->spwndCapture != pwnd) {

            /*
             * Fake a key-down of the escape key to cancel.
             */
            xxxMS_TrackMove(pwnd, WM_KEYDOWN, (DWORD)VK_ESCAPE, 1, pmsd);
            goto MoveSizeCleanup;
        }

        /*
         * If we've been cancelled by someone else, or our pwnd
         * has been destroyed, blow out of here.
         */
        if (pmsd->fTrackCancelled) {
            pmsd->fTrackCancelled = FALSE;
            goto MoveSizeCleanup;
        }

        /*
         * If we get a WM_QUEUESYNC, let the CBT hook know.
         */
        if (msg.message == WM_QUEUESYNC) {
            xxxCallHook(HCBT_QS, 0, 0, WH_CBT);
        }

        if (pmsd->fInitSize) {
            if (!xxxTrackInitSize(pwnd, msg.message, msg.wParam, msg.lParam,
                    pmsd)) {
                break;
            }
        }

        /*
         * Convert captured mouse into screen coordinates.
         */
        x = msg.pt.x + pmsd->dxMouse;
        y = msg.pt.y + pmsd->dyMouse;

        /*
         * This is checked twice so the same message is not processed both
         * places.
         */
        if (!pmsd->fInitSize) {
            xxxMS_TrackMove(pwnd, msg.message, msg.wParam, MAKELONG(x, y),
                    pmsd);
        }
    }

MoveSizeCleanup:

    /*
     * Reset priority if still in the foreground thread.
     */

    if (ptiCurrent == gptiForeground) {
        SetForegroundPriority(ptiCurrent, TRUE);
    }

    /*
     * Reset the border size if it was abnormal
     */

    if (!TestWF(pwnd, WFSIZEBOX))
        bSetDevDragWidth(gpDispInfo->hDev, gpsi->gclBorder + BORDER_EXTRA);

    /*
     * Revalidation: If pwnd is deleted unexpectedly, jump here to cleanup.
     */

    bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
    ptiCurrent->TIF_flags &= ~(TIF_TRACKRECTVISIBLE);

    if (pmsd->fDragFullWindows) {
        if (ghrgnUpdateSave != NULL) {
            GreDeleteObject(ghrgnUpdateSave);
            ghrgnUpdateSave = NULL;
            gnUpdateSave = 0;
        }
    }

    CLEAR_PUDF(PUDF_DRAGGINGFULLWINDOW);

    ptiCurrent->pmsd = NULL;

    Unlock(&pmsd->spwnd);


    zzzShowCursor(FALSE);

    /*
     * Free the move/size data structure
     */
    UserFreePool(pmsd);
}

/***************************************************************************\
* This calls xxxRedrawHungWindow() on windows that do not belong to this thread.
*
* History:
* 27-May-1994 johannec
\***************************************************************************/

VOID xxxUpdateOtherThreadsWindows(
    PWND pwnd,
    HRGN hrgnFullDrag)
{
    PWND        pwndChild;
    TL          tlpwndChild;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);

    xxxRedrawHungWindow(pwnd, hrgnFullDrag);

    /*
     * If the parent window does not have the flag WFCLIPCHILDREN set,
     * there is no need to redraw its children.
     */
    if (!TestWF(pwnd, WFCLIPCHILDREN))
        return;

    pwndChild = pwnd->spwndChild;
    ThreadLockNever(&tlpwndChild);
    while (pwndChild != NULL) {
        ThreadLockExchangeAlways(pwndChild, &tlpwndChild);
        xxxUpdateOtherThreadsWindows(pwndChild, hrgnFullDrag);
        pwndChild = pwndChild->spwndNext;
    }

    ThreadUnlock(&tlpwndChild);
}

/***************************************************************************\
* This calls UpdateWindow() on every window that is owned by this thread
* and calls xxxRedrawHungWindow() for windows owned by other threads.
*
* History:
* 28-Sep-1993 mikeke   Created
\***************************************************************************/

VOID xxxUpdateThreadsWindows(
    PTHREADINFO pti,
    PWND        pwnd,
    HRGN        hrgnFullDrag)
{
    TL   tlpwnd;

    CheckLock(pwnd);

    ThreadLockNever(&tlpwnd);
    while (pwnd != NULL) {
        ThreadLockExchangeAlways(pwnd, &tlpwnd);
        if (GETPTI(pwnd) == pti) {
            xxxUpdateWindow(pwnd);
        } else {
            xxxUpdateOtherThreadsWindows(pwnd, hrgnFullDrag);
        }

        pwnd = pwnd->spwndNext;
    }

    ThreadUnlock(&tlpwnd);
}

/***************************************************************************\
* xxxDrawDragRect
*
* Draws the drag rect for sizing and moving windows.  When moving windows,
* can move full windows including client area.  lprc new rect to move to.
* if lprc is null, flags specify why.
*
* flags:  DDR_START     0 - start drag.
*         DDR_ENDACCEPT 1 - end and accept
*         DDR_ENDCANCEL 2 - end and cancel.
*
* History:
* 07-29-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxDrawDragRect(
    PMOVESIZEDATA pmsd,
    LPRECT        lprc,
    UINT          type)
{
    HDC  hdc;
    int  lvBorder;
    HRGN hrgnClip;

    /*
     * If we're dragging an icon, or we're not foreground, don't draw
     * the dragging rect.
     */
    if (!pmsd->fForeground) {

        if (lprc != NULL)
            CopyRect(&pmsd->rcDrag, lprc);

        return;
    }

    /*
     * If it already equals, just return.
     */
    if ((lprc != NULL) && EqualRect(&pmsd->rcDrag, lprc))
        return;

    if (!(pmsd->fDragFullWindows)) {

        /*
         * If we were not able to lock the screen (because some other process
         * or thread had the screen locked), then get a dc but make sure
         * it is totally clipped to nothing.
         * NO longer a posibility
         */

        /*
         * Clip to client rect of parent.  (Client given in screen coords.)
         */
        hrgnClip = GreCreateRectRgnIndirect(&pmsd->rcParent);

        /*
         * Clip to the parent's window clipping rgn if it has one.
         */
        if (hrgnClip != NULL && pmsd->spwnd->spwndParent->hrgnClip != NULL)
            IntersectRgn(hrgnClip,
                         hrgnClip,
                         pmsd->spwnd->spwndParent->hrgnClip);

        if (hrgnClip == NULL)
            hrgnClip = HRGN_FULL;

        /*
         * If lprc == NULL, just draw rcDrag once.  If lprc != NULL,
         * undraw *lprc, draw rcDrag, copy in *lprc.
         */

        /*
         * Use size 1 for minimized or non-sizeable windows.  Otherwise
         * use the # of borders (2 for outer edge, 1 for border, clBorder for
         * size border.
         */
        if (TestWF(pmsd->spwnd, WFMINIMIZED) || !TestWF(pmsd->spwnd, WFSIZEBOX))
            lvBorder = 1;
        else
            lvBorder = 3 + gpsi->gclBorder;

        /*
         * Get a screen DC clipped to the parent, select in a gray brush.
         */
        hdc = _GetDCEx(
                PWNDDESKTOP(pmsd->spwnd),
                hrgnClip,
                DCX_WINDOW | DCX_CACHE | DCX_INTERSECTRGN | DCX_LOCKWINDOWUPDATE);

        if (lprc != NULL) {

            /*
             * Move the frame to a new location by delta drawing
             */
            GreLockDisplay(gpDispInfo->hDev);
            bMoveDevDragRect(gpDispInfo->hDev, (PRECTL) lprc);
            CopyRect(&pmsd->rcDrag, lprc);
            GreUnlockDisplay(gpDispInfo->hDev);

        } else {

            if (type == DDR_START) {
                bSetDevDragRect(gpDispInfo->hDev,
                                (PRECTL)&pmsd->rcDrag,
                                (PRECTL)&pmsd->rcParent);
            }
        }

        /*
         * Release the DC & delete hrgnClip
         */
        _ReleaseDC(hdc);

    } else {

        RECT        rcSWP;
        HRGN        hrgnFullDragNew;
        HRGN        hrgnFullDragOld;
        PTHREADINFO ptiCancel = GETPTI(pmsd->spwnd);
        PTHREADINFO ptiCurrent = PtiCurrent();
        PWND        pwnd;
        TL          tlpwnd;

#if DBG
        /*
         * If ptiCancel != ptiCurrent, we must have come from xxxCancelTracking,
         * which has already locked ptiCancel.
         */
        if (ptiCancel != ptiCurrent) {
            CheckLock(ptiCancel);
        }
#endif

        /*
         * To prevent applications (like Micrografx Draw) from doing
         * a PeekMessage loop and getting the mouse move messages that
         * are destined for the xxxMoveSize PeekMessage loop, we OR in
         * this flag. See comments in input.c for xxxInternalGetMessage.
         */
        ptiCancel->TIF_flags |= TIF_MOVESIZETRACKING;

        if (lprc != NULL)
            CopyRect(&(pmsd->rcDrag), lprc);

        CopyRect(&rcSWP, &(pmsd->rcDrag));

        /*
         * Convert coordinates to client if the window is a child window or
         * if it's a popup-with parent.  The test for the popup is necessary
         * to solve a problem where a popup was assigned a parent of a MDI-
         * CLIENT window.
         */
        if (pmsd->spwnd->spwndParent != NULL && !FTopLevel(pmsd->spwnd)) {
            _ScreenToClient(pmsd->spwnd->spwndParent, (LPPOINT)&rcSWP);
            _ScreenToClient(pmsd->spwnd->spwndParent, ((LPPOINT)&rcSWP)+1);

            //
            // If the parent of this window is mirrored, then mirror the
            // rectangle coordinates so that child MDI windows work
            // properly
            //
            if( TestWF(pmsd->spwnd->spwndParent,WEFLAYOUTRTL) )
            {
              int iLeft   = rcSWP.left;
              rcSWP.left  = rcSWP.right;
              rcSWP.right = iLeft;
            }
        }

        /*
         * Don't bother being optimal here.  There's one case where we
         * really shouldn't blow away the SPB--the window is being sized
         * bigger.  We do want to do this when moving or sizing the window
         * smaller.  Why bother detecting the first case?
         */
        if (TestWF(pmsd->spwnd, WFHASSPB)){

            PSPB pspb;
            RECT rc;

            /*
             * If we're intersecting the original window rect and the window
             * has an SPB saved onboard, then just free it.  Otherwise the
             * window will move, the entire SPB will blt over it, we'll
             * invalidate the intersection, and the window will repaint,
             * causing mad flicker.
             */
            pspb = FindSpb(pmsd->spwnd);

            CopyRect(&rc, &pmsd->spwnd->rcWindow);
            if (lprc && IntersectRect(&rc, &rc, lprc)){
                FreeSpb(pspb);
            }
        }

        hrgnFullDragOld = GreCreateRectRgnIndirect(&pmsd->spwnd->rcWindow);

        if (pmsd->spwnd->hrgnClip != NULL)
            IntersectRgn(hrgnFullDragOld,
                         hrgnFullDragOld,
                         pmsd->spwnd->hrgnClip);

        xxxSetWindowPos(pmsd->spwnd,
                        NULL,
                        rcSWP.left, rcSWP.top,
                        rcSWP.right-rcSWP.left, rcSWP.bottom-rcSWP.top,
                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER);

        /*
         * We locked ptiCancel, so ptiCancel->pmsd has not been unexpectedly
         * freed in DeleteThreadInfo(), but xxxMoveSize() may have terminated
         * during our callback to xxxSetWindowPos and freed the pmsd there.
         */
        if (ptiCancel->pmsd != pmsd) {
            RIPMSG3(RIP_ERROR,
                    "xxxDrawDragRect: ptiCancel(%#p)->pmsd(%#p) != pmsd(%#p)\n",
                    ptiCancel, ptiCancel->pmsd, pmsd);
            goto CleanupAfterPmsdDisappearance;
        }
        hrgnFullDragNew = GreCreateRectRgnIndirect(&pmsd->spwnd->rcWindow);

        if (pmsd->spwnd->hrgnClip != NULL) {
            IntersectRgn(hrgnFullDragNew,
                         hrgnFullDragNew,
                         pmsd->spwnd->hrgnClip);
        }

        /*
         * Set the full drag update region that is used in xxxRedrawHungWindow.
         */
        if (hrgnFullDragNew == NULL) {

            /*
             * We couldn't create the new full drag region so don't
             * use the full drag region to xxxRedrawHungWindow. Using
             * NULL with force a redraw of the entire window's hrgnUpdate.
             * (which is what we used to do, overdrawing but at least
             * covering the invalidated areas).
             */
            if (hrgnFullDragOld != NULL) {
                GreDeleteObject(hrgnFullDragOld);
                hrgnFullDragOld = NULL;
            }

        } else {

            if (hrgnFullDragOld != NULL) {

                /*
                 * Subtract the new window rect from the old window rect
                 * to create the update region caused by the drag.
                 */
                SubtractRgn(hrgnFullDragOld, hrgnFullDragOld, hrgnFullDragNew);
            }
        }

        pwnd = PWNDDESKTOP(pmsd->spwnd)->spwndChild;
        ThreadLock(pwnd, &tlpwnd);
        xxxUpdateThreadsWindows(ptiCurrent, pwnd, hrgnFullDragOld);
        ThreadUnlock(&tlpwnd);

        GreDeleteObject(hrgnFullDragNew);

CleanupAfterPmsdDisappearance:
        GreDeleteObject(hrgnFullDragOld);

        ptiCancel->TIF_flags &= ~TIF_MOVESIZETRACKING;
    }
}

/***************************************************************************\
* xxxCancelTrackingForThread
*
*
\***************************************************************************/

VOID xxxCancelTrackingForThread(
    PTHREADINFO ptiCancel)
{
    PMOVESIZEDATA pmsdCancel;

    UserAssert(ptiCancel);

    /*
     * If this thread isn't around any more, skip it.
     */
    if (ptiCancel == NULL)
        return;

    if ((pmsdCancel = ptiCancel->pmsd) != NULL) {

        /*
         * Found one, now stop tracking.
         */
        pmsdCancel->fTrackCancelled = TRUE;

        /*
         * Only remove the tracking rectangle if it's
         * been made visible.
         */
        if (ptiCancel->TIF_flags & TIF_TRACKRECTVISIBLE) {
            bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
            if (!(pmsdCancel->fDragFullWindows)) {
                xxxDrawDragRect(pmsdCancel, NULL, DDR_ENDCANCEL);
            }
        }

        /*
         * Leave TIF_TRACKING set to prevent xxxMoveSize()
         * recursion.
         */
        ptiCancel->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
        if (ptiCancel->pq) {
            SetWakeBit(ptiCancel, QS_MOUSEMOVE);
        }

        /*
         * If the tracking window is still in menuloop, send the
         * WM_CANCELMODE message so that it can exit the menu.
         * This fixes the bug where we have 2 icons with their
         * system menu up.
         * 8/5/94 johannec
         */
        if (IsInsideMenuLoop(ptiCancel) && ptiCancel->pmsd)
            _PostMessage(ptiCancel->pmsd->spwnd, WM_CANCELMODE, 0, 0);

        /*
         * Turn off capture
         */
        xxxCapture(ptiCancel, NULL, NO_CAP_CLIENT);
    }
}

/***************************************************************************\
* xxxCancelTracking
*
*
\***************************************************************************/

#define MAX_THREADS 12

VOID xxxCancelTracking(VOID)
{
    PTHREADINFO pti;
    PTHREADINFO ptiList[MAX_THREADS];
    TL          tlptiList[MAX_THREADS];
    TL          tlspwndList[MAX_THREADS];
    UINT        cThreads = 0;
    INT         i;
    PLIST_ENTRY pHead;
    PLIST_ENTRY pEntry;
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Build a list of threads that we need to look at. We can't just
     * walk the pointer list while we're doing the work, because we
     * might leave the critical section and the pointer could get
     * deleted out from under us.
     */
    pHead = &grpdeskRitInput->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        if (pti->pmsd != NULL) {

            UserAssert(cThreads < MAX_THREADS);

            if (cThreads < MAX_THREADS) {
                ThreadLockPti(ptiCurrent, pti, &tlptiList[cThreads]);
                ThreadLockAlwaysWithPti(ptiCurrent, pti->pmsd->spwnd, &tlspwndList[cThreads]);
                ptiList[cThreads++] = pti;
            }
        }
    }

    /*
     * Walk the list backwards so the unlocks will be done in the right order.
     */
    for (i = cThreads - 1; i >= 0; i--) {
        if (!(ptiList[i]->TIF_flags & TIF_INCLEANUP)) {
            xxxCancelTrackingForThread(ptiList[i]);
        }

        ThreadUnlock(&tlspwndList[i]);
        ThreadUnlockPti(ptiCurrent, &tlptiList[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\multimon.c ===
/****************************** Module Header ******************************\
* Module Name: multimon.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multimonitor APIs.
*
* History:
* 27-Sep-1996 adams     Stub implementation for NT 5.
* 20-Feb-1997 adams     Port from NT4 SP3.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* last monitor the cursor was clipped to */
PMONITOR gpMonitorMouse;

/***************************************************************************\
* ClipPointToDesktop
*
* Clips the point the nearest monitor on the desktop.
*
* Arguments:
*     lppt - The point to clip.
*
* History:
* 22-Sep-1996 adams     Created.
* 04-Sep-1998 MCostea   Use _MonitorFromPoint()
\***************************************************************************/

void
ClipPointToDesktop(LPPOINT lppt)
{
    PMONITOR        pMonitor;

    UserAssert(!gpDispInfo->fDesktopIsRect &&
               "You shouldn't call this function if the desktop is a rectangle.\n"
               "Just clip to gpsi->rcScreen instead.");

    /*
     * Optimization: The cursor is likely to be on the monitor it was last on,
     * so check for that case.
     */
    if (gpMonitorMouse != NULL && PtInRect(&gpMonitorMouse->rcMonitor, *lppt)) {
        return;
    }

    pMonitor = _MonitorFromPoint(*lppt, MONITOR_DEFAULTTONEAREST);

    /*
     * Remember the monitor the cursor is on.
     */
    gpMonitorMouse = pMonitor;

    if (lppt->x < pMonitor->rcMonitor.left) {
        lppt->x = pMonitor->rcMonitor.left;
    } else if (lppt->x >= pMonitor->rcMonitor.right) {
        lppt->x = pMonitor->rcMonitor.right-1;
    }
    if (lppt->y < pMonitor->rcMonitor.top) {
        lppt->y = pMonitor->rcMonitor.top;
    } else if (lppt->y >= pMonitor->rcMonitor.bottom) {
        lppt->y = pMonitor->rcMonitor.bottom-1;
    }
}

/***************************************************************************\
* xxxEnumDisplayMonitors
*
* Enumerates the monitors in a display.
*
* Arguments:
*     hdcPaint  - An HDC with a particular visible region. The HDC
*         passed to lpfnEnum will have the capabilities of that monitor,
*         with its visible region clipped to the monitor and hdcPaint.
*         If hdcPaint is NULL, the hdcMonitor passed to lpfnEnum will be NULL.
*
*     lprcClip  - A rectangle to clip the area to. If hdcPaint is non-NULL,
*         the coordinates have the origin of hdcPaint. If hdcPaint is NULL,
*         the coordinates are virtual screen coordinates. If lprcClip is NULL,
*         no clipping is performed.
*
*     lpfnEnum  - The enumeration function.
*
*     dwData    - Application-defined data that is passed through to the
*         enumeration function.
*
*     fInternal - TRUE if the callback is in the kernel, FALSE otherwise.
*
* History:
* 22-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
xxxEnumDisplayMonitors(
    HDC             hdcPaint,
    LPRECT          lprcPaint,
    MONITORENUMPROC lpfnEnum,
    LPARAM          lData,
    BOOL            fInternal)
{
    RECT            rcPaint;
    POINT           ptOrg;
    RECT            rcMonitorPaint;
    BOOL            fReturn;
    PMONITOR        pMonitor;
    TL              tlpMonitor;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PDCE            pdcePaint;
    HDC             hdcMonitor;
    PWND            pwndOrg;

    /*
     * Validate the DC passed in.
     */
    if (hdcPaint) {

        if ((pdcePaint = LookupDC(hdcPaint)) == NULL) {
            RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: LookupDC failed");
            return FALSE;
        }

        pwndOrg = pdcePaint->pwndOrg;

        /*
         * Intersect the painting area with the clipbox.  If there
         * isn't anything, bail out now.
         */
        if (GreGetClipBox(hdcPaint, &rcPaint, FALSE) == NULLREGION)
            return TRUE;

        if (lprcPaint && !IntersectRect(&rcPaint, &rcPaint, lprcPaint))
            return TRUE;

        /*
         * rcPaint is in dc coordinates.  We must convert to screen
         * coords so we can intersect with monitors.
         */
        GreGetDCOrg(hdcPaint, &ptOrg);
        OffsetRect(&rcPaint, ptOrg.x, ptOrg.y);
    } else {
        CopyRect(&rcPaint, &gpDispInfo->rcScreen);
        if (lprcPaint && !IntersectRect(&rcPaint, &rcPaint, lprcPaint))
            return TRUE;
    }

    fReturn = TRUE;

    for (pMonitor = gpDispInfo->pMonitorFirst; pMonitor != NULL;
                pMonitor = pMonitor->pMonitorNext) {

        /*
         * Note: the check for MONF_VISIBLE was removed to allow mirror drivers
         * to see monitor specific updates.
         */
        if (!IntersectRect(&rcMonitorPaint, &rcPaint, &pMonitor->rcMonitor)) {
            continue;
        }

        if (hdcPaint) {

            if ((hdcMonitor = GetMonitorDC(pdcePaint, pMonitor)) == NULL) {
                RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: GetMonitorDC failed");
                return FALSE;
            }

            OffsetRect(&rcMonitorPaint, -ptOrg.x, -ptOrg.y);
            GreIntersectClipRect(
                    hdcMonitor,
                    rcMonitorPaint.left,
                    rcMonitorPaint.top,
                    rcMonitorPaint.right,
                    rcMonitorPaint.bottom);
        } else {

            hdcMonitor = NULL;
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pMonitor, &tlpMonitor);

        if (fInternal) {
            fReturn = (*lpfnEnum) (
                    (HMONITOR) pMonitor,
                    hdcMonitor,
                    &rcMonitorPaint,
                    lData);

        } else {
            fReturn = xxxClientMonitorEnumProc(
                    PtoH(pMonitor),
                    hdcMonitor,
                    &rcMonitorPaint,
                    lData,
                    lpfnEnum);
        }

        /*
         * We just called back and the monitor has been freed if
         * ThreadUnlock returns NULL. The entire monitor configuration may
         * have changed, the monitors may have been rearranged, so just stop
         * enumerating at this point.
         */
        if (ThreadUnlock(&tlpMonitor) == NULL || HMIsMarkDestroy(pMonitor)) {
            /*
             * During the callback, pMonitor was destroyed
             * so we have to bail out. pMonitor->pNext may also
             * have been ruined.
             * Windows Bug #488330.
             */
            RIPMSGF1(RIP_WARNING, "pMonitor %p has been destroyed during the callback",
                     pMonitor);
#if DBG
            {
                /*
                 * Double check to see pMonitor does not
                 * appear in the monitor list.
                 */
                 PMONITOR pMonitorTmp = gpDispInfo->pMonitorFirst;

                 while (pMonitorTmp) {
                     UserAssert(pMonitorTmp != pMonitor);
                     pMonitorTmp = pMonitorTmp->pMonitorNext;
                 }
            }
#endif

            fReturn = FALSE;
        }

        if (hdcMonitor)
            ReleaseCacheDC(hdcMonitor, FALSE);

        if (!fReturn) {
            /*
             * Something went wrong, we have to bail out.
             */
            break;
        }

        /*
         * Revalidate hdcPaint, since it could have been messed with
         * in the callback.
         */
        if (hdcPaint) {
            if ((pdcePaint = LookupDC(hdcPaint)) == NULL) {
                RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: LookupDC failed");
                return FALSE;
            }

            if (pdcePaint->pwndOrg != pwndOrg) {
                RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: wrong window");
                return FALSE;
            }
        }
    }

    return fReturn;
}

/***************************************************************************\
* DestroyMonitor
*
* This function doesn't keep track of the visible monitors count because
* it assumes that after it was called the count will be recalculated, such
* as the case during mode changes. For a final unlock the monitor will have
* been removed from the monitor list already, so the count doesn't need to
* be recalculated.
*
* 5-May-1998    vadimg      created
\***************************************************************************/

void DestroyMonitor(PMONITOR pMonitor)
{
    UserAssert(pMonitor);

    /*
     * Remove references to this monitor from the global data.
     */
    if (pMonitor == gpMonitorMouse) {
        gpMonitorMouse = NULL;
    }

    /*
     * Remove from the monitor list.
     */
    REMOVE_FROM_LIST(MONITOR, gpDispInfo->pMonitorFirst, pMonitor, pMonitorNext);

    /*
     * Make sure the primary monitor points to a valid monitor. During the
     * mode changes the primary monitor will be recalculated as appropriate.
     */
    if (pMonitor == gpDispInfo->pMonitorPrimary) {
        gpDispInfo->pMonitorPrimary = gpDispInfo->pMonitorFirst;
    }

    /*
     * Clean up the next link here...
     */
    pMonitor->pMonitorNext = NULL;

    /*
     * To make sure memory write operations are retired
     * before really destroying the monitor object:
     */
    Win32MemoryBarrier();

    if (HMMarkObjectDestroy(pMonitor)) {

        if (pMonitor->hrgnMonitor) {
           GreDeleteObject(pMonitor->hrgnMonitor);
        }

        HMFreeObject(pMonitor);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\newmouse.c ===
/****************************** Module Header ******************************\
* Module Name: newmouse.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implements new mouse acceleration algorithm.
*
* History:
* 10-12-2000 JasonSch       Adapted code from StevieB
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef SUBPIXEL_MOUSE

/*
 * Globals.
 */
BOOL gbNewMouseInit;

#define MIN_REFRESH 60
#define MIN_RESOLUTION 96

/*
 * Constants for FixedPoint Math.
 */
#define FP_SHIFT        16    // number of binary decimal digits
#define FP_SCALE        65536 // (2^(32-FP_SHIFT)), used during conversion of
                              // floats
#define FP_MASK         0x0000ffff // mask to retrieve the remainder

#define FIXP2INT(n)  ((INT)((n) >> FP_SHIFT))
#define FIXP_REM(n)  ((n) & FP_MASK)
#define INT2FIXP(n)  ((((FIXPOINT)n) << FP_SHIFT))

/*
 * This function divides two fixed point numbers and returns the result.
 * Notice how the final result is shifted back.
 */
__inline FIXPOINT Div_Fixed(FIXPOINT f1, FIXPOINT f2)
{
    return ((f1 << FP_SHIFT) / f2);
}

/*
 * This function mulitplies two fixed point numbers and returns the result.
 * Notice how the final result is shifted back.
 */
__inline FIXPOINT Mul_Fixed(FIXPOINT f1, FIXPOINT f2)
{
    return (f1 * f2) >> FP_SHIFT;
}

/*
 * This function adds two fixed point numbers and returns the result.
 * Notice how no shifting is necessary.
 */
__inline FIXPOINT Add_Fixed(FIXPOINT f1, FIXPOINT f2)
{
    return f1 + f2;
}

/*
 * Build the curves at boot and when the user changes the setting in the UI.
 * The algorithm uses the speedscale, the screenscale, and mousescale to
 * interpolate the new curves.
 */
VOID
BuildMouseAccelerationCurve(
    PMONITOR pMonitor)
{
    int i, res, vrefresh;
    HDC hdc;
    FIXPOINT ScreenScale, SpeedScale;
    /*
     * 229376 is 3.5 in FP. This is strong magic, so don't sweat it too much!
     * Ideally we'd calculate this number, but USB mice don't report their
     * refresh rate, which we'd need:
     *
     * MouseScale = Div_Fixed(INT2FIXP(MouseRefresh), INT2FIXP(MouseDPI));
     */
    FIXPOINT MouseScale = 229376;

    if (!gbNewMouseInit) {
        return;
    }

    /*
     * Dividing by 10 is somewhat ad hoc -- this divisor controls the
     * overall "height" of the curves, but does not affect the shape.
     */
    SpeedScale = INT2FIXP(gMouseSensitivity) / 10;

    hdc = GreCreateDisplayDC(pMonitor->hDev, DCTYPE_DIRECT, FALSE);
    res = GreGetDeviceCaps(hdc, LOGPIXELSX);
    if (res < MIN_RESOLUTION) {
        /*
         * While there is no evidence that display drivers can return bogus
         * values for the resolution, we have no reason to think they won't
         * (see below). So we clamp the value to a reasonable minimum.
         */
        RIPMSG2(RIP_WARNING,
                "GreGetDeviceCaps(0x%p, LOGPIXELSX) returned 0n%d", hdc, res);
        res = MIN_RESOLUTION;
    }

    /*
     * Some video cards lie to us and tell us the refresh rate is 1. There are
     * probably others that lie in different ways, so let's make sure there's
     * some sane mimimum value, or the mouse will be entirely too slow.
     * ALL YOUR REFRESH ARE BELONG TO US!
     */
    vrefresh = GreGetDeviceCaps(hdc, VREFRESH);
    if (vrefresh < MIN_REFRESH) {
        vrefresh = MIN_REFRESH;
    }
    ScreenScale = INT2FIXP(vrefresh) / res;
    GreDeleteDC(hdc);

    for (i = 0; i < ARRAY_SIZE(pMonitor->xTxf); i++) {
        pMonitor->yTxf[i] = Mul_Fixed(Mul_Fixed(gDefyTxf[i], ScreenScale), SpeedScale);
        pMonitor->xTxf[i] = Mul_Fixed(gDefxTxf[i], MouseScale);
    }

    /*
     * Build the new curves in a slope-intercept format.
     */
    for (i = 1; i < ARRAY_SIZE(pMonitor->xTxf); i++) {
        /*
         * Make sure we don't divide by zero (this could happen if bogus values
         * are in the registry).
         */
        if ((pMonitor->xTxf[i] - pMonitor->xTxf[i-1]) == 0) {
            RIPMSG1(RIP_ERROR, "Bad data in registry for new mouse (i = %d)", i);
            pMonitor->slope[i-1] = pMonitor->yint[i-1] = 0;
            continue;
        }

        pMonitor->slope[i-1] = Div_Fixed(pMonitor->yTxf[i] - pMonitor->yTxf[i-1], pMonitor->xTxf[i] - pMonitor->xTxf[i-1]);
        pMonitor->yint[i-1] = pMonitor->yTxf[i-1] - Mul_Fixed(pMonitor->slope[i-1], pMonitor->xTxf[i-1]);
    }
}

VOID
DoNewMouseAccel(
    INT *dx,
    INT *dy)
{
    static FIXPOINT fpDxAcc = 0, fpDyAcc = 0;
    static int i_last = 0;
    int i = 0;
    PMONITOR pMonitor = _MonitorFromPoint(gptCursorAsync, MONITOR_DEFAULTTOPRIMARY);
    FIXPOINT accel, fpDxyMag;

    /*
     * Convert Mouse X and Y to FixedPoint.
     */
    FIXPOINT fpDx = INT2FIXP(*dx);
    FIXPOINT fpDy = INT2FIXP(*dy);

    /*
     * During TS operations it's possible for a mouse move to be queued up but
     * for gpDispInfo->pMonitorFirst/Primary to be NULL. Let's try not to fault
     * in that case. Windows Bug #413159.
     */
    if (pMonitor == NULL) {
        RIPMSG0(RIP_WARNING, "Ignoring mouse movement w/ no monitor set.");
        return;
    }

    // Get the magnitude
    fpDxyMag = max(abs(fpDx), abs(fpDy)) + (min(abs(fpDx), abs(fpDy)) / 2);

    /*
     * Ensure we don't divide by 0.
     */
    if (fpDxyMag != 0) {
        /*
         * Find the position MagXY from the interpolate acceleration curves.
         * It's possible we won't find one so we'll just use the biggest (i.e.,
         * the last entry in the array).
         */
        while (i < (ARRAY_SIZE(pMonitor->xTxf) - 1) && fpDxyMag > pMonitor->xTxf[i]) {
            ++i;
        }
        --i;


        accel = Div_Fixed(Add_Fixed(Mul_Fixed(pMonitor->slope[i], fpDxyMag), pMonitor->yint[i]), fpDxyMag);

        /*
         * If change of slope from last time then average the accel value using
         * i_last and the current i.
         */
        if (i_last != i) {
            accel = (accel + Div_Fixed((Mul_Fixed(pMonitor->slope[i_last], fpDxyMag) + pMonitor->yint[i_last]), fpDxyMag)) / 2;
            i_last = i;
        }

        /*
         * Calculate the multiplier for the mouse data.
         */
        fpDx = Mul_Fixed(accel, fpDx) + fpDxAcc;
        fpDy = Mul_Fixed(accel, fpDy) + fpDyAcc;

        /*
         * Store the remainder of the calculated X and Y. This gets added in
         * next time.
         */
        fpDxAcc = FIXP_REM(fpDx);
        fpDyAcc = FIXP_REM(fpDy);

        /*
         * Convert back to integer.
         */
        *dx = FIXP2INT(fpDx);
        *dy = FIXP2INT(fpDy);
    }
}

VOID
ReadDefaultAccelerationCurves(
    PUNICODE_STRING pProfileUserName)
{
    FIXPOINT xTxf[SM_POINT_CNT], yTxf[SM_POINT_CNT];
    DWORD cbSizeX, cbSizeY;

    /*
     * The default curves will reside in the .DEFAULT user profile but can be
     * overridden on a per-user basis.
     */
    cbSizeX = FastGetProfileValue(pProfileUserName,
                                  PMAP_MOUSE,
                                  (LPWSTR)STR_SMOOTHMOUSEXCURVE,
                                  NULL,
                                  (LPBYTE)xTxf,
                                  sizeof(xTxf),
                                  0);

    cbSizeY = FastGetProfileValue(pProfileUserName,
                                  PMAP_MOUSE,
                                  (LPWSTR)STR_SMOOTHMOUSEYCURVE,
                                  NULL,
                                  (LPBYTE)yTxf,
                                  sizeof(yTxf),
                                  0);

    /*
     * Check if we successfully read the correct amount of data from both keys.
     * If not, and we're reading the .DEFAULT profile, copy in the default
     * values.
     */
    if (cbSizeX == sizeof(xTxf) && cbSizeY == sizeof(yTxf)) {
        RtlCopyMemory(gDefxTxf, xTxf, sizeof(xTxf));
        RtlCopyMemory(gDefyTxf, yTxf, sizeof(yTxf));
    } else if (!gbNewMouseInit) {
        /*
         * Default values.
         */
        static FIXPOINT _xTxf[SM_POINT_CNT] = {0x0, 0x6E15, 0x14000, 0x3DC29, 0x280000};
        static FIXPOINT _yTxf[SM_POINT_CNT] = {0x0, 0x15EB8, 0x54CCD, 0x184CCD, 0x2380000};

        RtlCopyMemory(gDefxTxf, _xTxf, sizeof(_xTxf));
        RtlCopyMemory(gDefyTxf, _yTxf, sizeof(_yTxf));
    }

    gbNewMouseInit = TRUE;
}

VOID
ResetMouseAccelerationCurves(
    VOID)
{
    PMONITOR pMonitor = gpDispInfo->pMonitorFirst;

    CheckCritIn();

    for (; pMonitor != NULL; pMonitor = pMonitor->pMonitorNext) {
        BuildMouseAccelerationCurve(pMonitor);
    }
}

#endif // SUBPIXEL_MOUSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ntimm.c ===
/**************************************************************************\
* Module Name: ntimm.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains IMM functionality
*
* History:
* 21-Dec-1995 wkwok
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


static CONST WCHAR wszDefaultIme[] = L"Default IME";

#if DBG
BOOL CheckOwnerCirculate(PWND pwnd)
{
    PWND pwndT = pwnd->spwndOwner;

    while (pwndT) {
        UserAssert(pwndT->spwndOwner != pwnd);
        pwndT = pwndT->spwndOwner;
    }
    return TRUE;
}
#endif

/**************************************************************************\
* CreateInputContext
*
* Create input context object.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

PIMC CreateInputContext(
    ULONG_PTR dwClientImcData)
{
    PTHREADINFO    ptiCurrent;
    PIMC           pImc;
    PDESKTOP       pdesk = NULL;

    ptiCurrent = PtiCurrentShared();

    /*
     * Only for thread that wants IME processing.
     */
    if ((ptiCurrent->TIF_flags & TIF_DISABLEIME) || !IS_IME_ENABLED()) {
        RIPMSG1(RIP_VERBOSE, "CreateInputContext: TIF_DISABLEIME or !IME Enabled. pti=%#p", ptiCurrent);
        return NULL;
    }

    /*
     * If pti->spDefaultImc is NULL (means this is the first instance)
     * but dwClientImcData is not 0, some bogus application like NtCrash
     * has tried to trick the kernel. Just bail out.
     */
    if (dwClientImcData != 0 && ptiCurrent->spDefaultImc == NULL) {
        RIPMSG2(RIP_WARNING, "CreateInputContext: bogus value(0x%08x) is passed. pti=%#p",
                dwClientImcData, ptiCurrent);
        return NULL;
    }

    /*
     * If the windowstation has been initialized, allocate from
     * the current desktop.
     */
    pdesk = ptiCurrent->rpdesk;
#ifdef LATER
    RETURN_IF_ACCESS_DENIED(ptiCurrent->amdesk, DESKTOP_CREATEINPUTCONTEXT, NULL);
#else
    if (ptiCurrent->rpdesk == NULL) {
        return NULL;
    }
#endif

    pImc = HMAllocObject(ptiCurrent, pdesk, TYPE_INPUTCONTEXT, sizeof(IMC));

    if (pImc == NULL) {
        RIPMSG0(RIP_WARNING, "CreateInputContext: out of memory");
        return NULL;
    }

    if (dwClientImcData == 0) {
        /*
         * We are creating default input context for current thread.
         * Initialize the default input context as head of the
         * per-thread IMC list.
         */
        UserAssert(ptiCurrent->spDefaultImc == NULL);
        Lock(&ptiCurrent->spDefaultImc, pImc);
        pImc->pImcNext = NULL;
    }
    else {
        /*
         * Link it to the per-thread IMC list.
         */
        UserAssert(ptiCurrent->spDefaultImc != NULL);
        pImc->pImcNext = ptiCurrent->spDefaultImc->pImcNext;
        ptiCurrent->spDefaultImc->pImcNext = pImc;
    }

    pImc->dwClientImcData = dwClientImcData;

    return pImc;
}


/**************************************************************************\
* DestroyInputContext
*
* Destroy the specified input context object.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

BOOL DestroyInputContext(
    IN PIMC pImc)
{
    PTHREADINFO ptiImcOwner;
    PBWL        pbwl;
    PWND        pwnd;
    HWND       *phwnd;
    PHE         phe;

    ptiImcOwner = GETPTI(pImc);

    /*
     * Cannot destroy input context from other thread.
     */
    if (ptiImcOwner != PtiCurrent()) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
              "DestroyInputContext: pImc not of current pti");
        return FALSE;
    }

    /*
     * Cannot destroy default input context.
     */
    if (pImc == ptiImcOwner->spDefaultImc) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
              "DestroyInputContext: can't destroy default Imc");
        return FALSE;
    }

    /*
     * Cleanup destroyed input context from each associated window.
     */
    pbwl = BuildHwndList(ptiImcOwner->rpdesk->pDeskInfo->spwnd->spwndChild,
                             BWL_ENUMLIST|BWL_ENUMCHILDREN, ptiImcOwner);

    if (pbwl != NULL) {

        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
            /*
             * Make sure this hwnd is still around.
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                continue;

            /*
             * Cleanup by associating the default input context.
             */
            if (pwnd->hImc == (HIMC)PtoH(pImc))
                AssociateInputContext(pwnd, ptiImcOwner->spDefaultImc);
        }

        FreeHwndList(pbwl);
    }

    phe = HMPheFromObject(pImc);

    /*
     * Make sure this object isn't already marked to be destroyed - we'll
     * do no good if we try to destroy it now since it is locked.
     */
    if (!(phe->bFlags & HANDLEF_DESTROY))
        HMDestroyUnlockedObject(phe);

    return TRUE;
}


/**************************************************************************\
* FreeInputContext
*
* Free up the specified input context object.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

VOID FreeInputContext(
    IN PIMC pImc)
{
    PIMC pImcT;

    /*
     * Mark it for destruction.  If it the object is locked it can't
     * be freed right now.
     */
    if (!HMMarkObjectDestroy((PVOID)pImc))
        return;

    /*
     * Unlink it.
     */
    pImcT = GETPTI(pImc)->spDefaultImc;

    while (pImcT != NULL && pImcT->pImcNext != pImc)
        pImcT = pImcT->pImcNext;

    if (pImcT != NULL)
        pImcT->pImcNext = pImc->pImcNext;

    /*
     * We're really going to free the input context.
     */
    HMFreeObject((PVOID)pImc);

    return;
}


/**************************************************************************\
* UpdateInputContext
*
* Update the specified input context object according to UpdateType.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

BOOL UpdateInputContext(
    IN PIMC pImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue)
{
    PTHREADINFO ptiCurrent, ptiImcOwner;

    ptiCurrent = PtiCurrent();
    ptiImcOwner = GETPTI(pImc);

    /*
     * Cannot update input context from other process.
     */
    if (ptiImcOwner->ppi != ptiCurrent->ppi) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "UpdateInputContext: pImc not of current ppi");
        return FALSE;
    }


    switch (UpdateType) {

    case UpdateClientInputContext:
        if (pImc->dwClientImcData != 0) {
            RIPERR0(RIP_WARNING, RIP_WARNING, "UpdateInputContext: pImc->dwClientImcData != 0");
            return FALSE;
        }
        pImc->dwClientImcData = UpdateValue;
        break;

    case UpdateInUseImeWindow:
        pImc->hImeWnd = (HWND)UpdateValue;
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/**************************************************************************\
* AssociateInputContext
*
* Associate input context object to the specified window.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

HIMC AssociateInputContext(
    IN PWND  pWnd,
    IN PIMC  pImc)
{
    HIMC hImcRet = pWnd->hImc;
    pWnd->hImc = (HIMC)PtoH(pImc);

    return hImcRet;
}

AIC_STATUS AssociateInputContextEx(
    IN PWND  pWnd,
    IN PIMC  pImc,
    IN DWORD dwFlag)
{
    PTHREADINFO ptiWnd = GETPTI(pWnd);
    PWND pWndFocus = ptiWnd->pq->spwndFocus;
    BOOL fIgnoreNoContext = (dwFlag & IACE_IGNORENOCONTEXT) == IACE_IGNORENOCONTEXT;
    AIC_STATUS Status = AIC_SUCCESS;

    if (dwFlag & IACE_DEFAULT) {
        /*
         * use default input context.
         */
        pImc = ptiWnd->spDefaultImc;

    } else if (pImc != NULL && GETPTI(pImc) != ptiWnd) {
        /*
         * Cannot associate input context to window created
         * by other thread.
         */
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
                "AssociateInputContextEx: pwnd not of Imc pti");
        return AIC_ERROR;
    }

    /*
     * Cannot do association under different process context.
     */
    if (GETPTI(pWnd)->ppi != PtiCurrent()->ppi) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
                "AssociateInputContextEx: pwnd not of current ppi");
        return AIC_ERROR;
    }

    /*
     * Finally, make sure they are on the same desktop.
     */
    if (pImc != NULL && pImc->head.rpdesk != pWnd->head.rpdesk) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
                "AssociateInputContextEx: no desktop access");
        return AIC_ERROR;
    }

    /*
     * If IACE_CHILDREN is specified, associate the input context
     * to the child windows of pWnd as well.
     */
    if ((dwFlag & IACE_CHILDREN) && pWnd->spwndChild != NULL) {
        PBWL        pbwl;
        PWND        pwndT;
        HWND       *phwndT;

        pbwl = BuildHwndList(pWnd->spwndChild,
                   BWL_ENUMLIST|BWL_ENUMCHILDREN, ptiWnd);

        if (pbwl != NULL) {

            for (phwndT = pbwl->rghwnd; *phwndT != (HWND)1; phwndT++) {
                /*
                 * Make sure this hwnd is still around.
                 */
                if ((pwndT = RevalidateHwnd(*phwndT)) == NULL)
                    continue;

                if (pwndT->hImc == (HIMC)PtoH(pImc))
                    continue;

                if (pwndT->hImc == NULL_HIMC && fIgnoreNoContext)
                    continue;

                AssociateInputContext(pwndT, pImc);

                if (pwndT == pWndFocus)
                    Status = AIC_FOCUSCONTEXTCHANGED;
            }

            FreeHwndList(pbwl);
        }
    }

    /*
     * Associate the input context to pWnd.
     */
    if (pWnd->hImc != NULL_HIMC || !fIgnoreNoContext) {
        if (pWnd->hImc != (HIMC)PtoH(pImc)) {
            AssociateInputContext(pWnd, pImc);
            if (pWnd == pWndFocus)
                Status = AIC_FOCUSCONTEXTCHANGED;
        }
    }

    return Status;
}


/**************************************************************************\
* xxxFocusSetInputContext
*
* Set active input context upon focus change.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

VOID xxxFocusSetInputContext(
    IN PWND pWnd,
    IN BOOL fActivate,
    IN BOOL fQueueMsg)
{
    PTHREADINFO pti;
    PWND        pwndDefaultIme;
    TL          tlpwndDefaultIme;

    CheckLock(pWnd);

    pti = GETPTI(pWnd);

    /*
     * CS_IME class or "IME" class windows can not be SetActivated to hImc.
     * WinWord 6.0 US Help calls ShowWindow with the default IME window.
     * HELPMACROS get the default IME window by calling GetNextWindow().
     */
    if (TestCF(pWnd, CFIME) ||
            (pWnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]))
        return;

    /*
     * Do nothing if the thread does not have default IME window.
     */
    if ((pwndDefaultIme = pti->spwndDefaultIme) == NULL)
        return;

    /*
     * If the thread is going away or the default IME window is being vanished,
     * then do nothing.
     */
    if (pti->TIF_flags & TIF_INCLEANUP)
        return;

    UserAssert(!TestWF(pwndDefaultIme, WFDESTROYED));

    ThreadLockAlways(pwndDefaultIme, &tlpwndDefaultIme);

    if (fQueueMsg) {
        xxxSendMessageCallback(pwndDefaultIme, WM_IME_SYSTEM,
                fActivate ? IMS_ACTIVATECONTEXT : IMS_DEACTIVATECONTEXT,
                (LPARAM)HWq(pWnd), NULL, 1L, 0);
    } else {
        xxxSendMessage(pwndDefaultIme, WM_IME_SYSTEM,
                fActivate ? IMS_ACTIVATECONTEXT : IMS_DEACTIVATECONTEXT,
                (LPARAM)HWq(pWnd));
    }

#if _DBG
    if (pti->spwndDefaultIme != pwndDefaultIme) {
        RIPMSG1(RIP_WARNING, "pti(%#p)->spwndDefaultIme got freed during the callback.", pti);
    }
#endif

    ThreadUnlock(&tlpwndDefaultIme);

    return;
}


/**************************************************************************\
* BuildHimcList
*
* Retrieve the list of input context handles created by given thread.
*
* History:
* 21-Feb-1995 wkwok       Created
\**************************************************************************/

UINT BuildHimcList(
    PTHREADINFO pti,
    UINT cHimcMax,
    HIMC *ccxphimcFirst)
{
    PIMC pImcT;
    UINT i = 0;

    if (pti == NULL) {
        /*
         * Build the list which contains all IMCs created by calling process.
         */
        for (pti = PtiCurrent()->ppi->ptiList; pti != NULL; pti = pti->ptiSibling) {
            pImcT = pti->spDefaultImc;
            while (pImcT != NULL) {
                if (i < cHimcMax) {
                    try {
                        ccxphimcFirst[i] = (HIMC)PtoH(pImcT);
                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    }
                }
                i++;
                pImcT = pImcT->pImcNext;
            }
        }
    }
    else {
        /*
         * Build the list which contains all IMCs created by specified thread.
         */
        pImcT = pti->spDefaultImc;
        while (pImcT != NULL) {
            if (i < cHimcMax) {
                try {
                    ccxphimcFirst[i] = (HIMC)PtoH(pImcT);
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                }
            }
            i++;
            pImcT = pImcT->pImcNext;
        }
    }

    return i;
}


/**************************************************************************\
* xxxCreateDefaultImeWindow
*
* Create per-thread based default IME window.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

PWND xxxCreateDefaultImeWindow(
    IN PWND pwnd,
    IN ATOM atomT,
    IN HANDLE hInst)
{
    LARGE_STRING strWindowName;
    PWND pwndDefaultIme;
    TL tlpwnd;
    PIMEUI pimeui;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    LPWSTR pwszDefaultIme;

    UserAssert(ptiCurrent == GETPTI(pwnd) && ptiCurrent->spwndDefaultIme == NULL);

    /*
     * Those conditions should have been checked by WantImeWindow()
     * before xxxCreateDefaultImeWindow gets called.
     */
    UserAssert(!(ptiCurrent->TIF_flags & TIF_DISABLEIME));
    UserAssert(!TestWF(pwnd, WFSERVERSIDEPROC));

    /*
     * The first Winlogon thread starts without default input context.
     * Create it now.
     */
    if (ptiCurrent->spDefaultImc == NULL &&
            PsGetThreadProcessId(ptiCurrent->pEThread) == gpidLogon)
        CreateInputContext(0);

    /*
     * No default IME window for thread that doesn't have
     * default input context
     */
    if (ptiCurrent->spDefaultImc == NULL)
        return (PWND)NULL;

    /*
     * Avoid recursion
     */
    if (atomT == gpsi->atomSysClass[ICLS_IME] || TestCF(pwnd, CFIME))
        return (PWND)NULL;

    /*
     * B#12165-win95b
     * Yet MFC does another nice. We need to avoid to give an IME window
     * to the child of desktop window which is in different process.
     */
    if (TestwndChild(pwnd) && GETPTI(pwnd->spwndParent)->ppi != ptiCurrent->ppi &&
            !(pwnd->style & WS_VISIBLE))
        return (PWND)NULL;

    if (ptiCurrent->rpdesk->pheapDesktop == NULL)
        return (PWND)NULL;

    /*
     * Allocate storage for L"Default IME" string from desktop heap
     * so that it can be referenced from USER32.DLL in user mode.
     */
    pwszDefaultIme = (LPWSTR)DesktopAlloc(ptiCurrent->rpdesk,
                                          sizeof(wszDefaultIme),
                                          DTAG_IMETEXT);
    if (pwszDefaultIme == NULL)
        return (PWND)NULL;

    RtlCopyMemory(pwszDefaultIme, wszDefaultIme, sizeof(wszDefaultIme));

    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
                              pwszDefaultIme,
                              (UINT)-1);

    ThreadLock(pwnd, &tlpwnd);

    pwndDefaultIme = xxxNVCreateWindowEx( (DWORD)0,
                             (PLARGE_STRING)gpsi->atomSysClass[ICLS_IME],
                             (PLARGE_STRING)&strWindowName,
                             WS_POPUP | WS_DISABLED,
                             0, 0, 0, 0,
                             pwnd, (PMENU)NULL,
                             hInst, NULL, VER40);


    if (pwndDefaultIme != NULL) {
        pimeui = ((PIMEWND)pwndDefaultIme)->pimeui;
        UserAssert(pimeui != NULL && (LONG_PTR)pimeui != (LONG_PTR)-1);
        try {
            ProbeForWrite(pimeui, sizeof *pimeui, sizeof(DWORD));
            pimeui->fDefault = TRUE;
            if (TestwndChild(pwnd) && GETPTI(pwnd->spwndParent) != ptiCurrent) {
                pimeui->fChildThreadDef = TRUE;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
    }

    ThreadUnlock(&tlpwnd);

    DesktopFree(ptiCurrent->rpdesk, pwszDefaultIme);

    return pwndDefaultIme;
}


/**************************************************************************\
* xxxImmActivateThreadsLayout
*
* Activate keyboard layout for multiple threads.
*
* Return:
*     TRUE if at least one thread has changed its active keyboard layout.
*     FALSE otherwise
*
* History:
* 11-Apr-1996 wkwok       Created
\**************************************************************************/

BOOL xxxImmActivateThreadsLayout(
    PTHREADINFO pti,
    PTLBLOCK    ptlBlockPrev,
    PKL         pkl)
{
    TLBLOCK     tlBlock;
    PTHREADINFO ptiCurrent, ptiT;
    UINT        cThreads = 0;
    INT         i;

    CheckLock(pkl);

    ptiCurrent = PtiCurrentShared();

    /*
     * Build a list of threads that we need to update their active layouts.
     * We can't just walk the ptiT list while we're doing the work, because
     * for IME based keyboard layout, we will do callback to client side
     * and the ptiT could get deleted out while we leave the critical section.
     */
    for (ptiT = pti; ptiT != NULL; ptiT = ptiT->ptiSibling) {
        /*
         * Skip all the *do nothing* cases in xxxImmActivateLayout
         * so as to minimize the # of TLBLOCK required.
         */
        if (ptiT->spklActive == pkl || (ptiT->TIF_flags & TIF_INCLEANUP))
            continue;

        UserAssert(ptiT->pClientInfo != NULL);
        UserAssert(ptiT->ppi == PpiCurrent()); // can't access pClientInfo of other process

        if (ptiT->spwndDefaultIme == NULL) {
            /*
             * Keyboard layout is being switched but there's no way to callback
             * the client side to activate&initialize input context now.
             * Let's do hkl switching only in the kernel side for this thread
             * but remember the input context needs to be re-initialized
             * when this GUI thread recreates the default IME window later.
             */
            ptiT->hklPrev = ptiT->spklActive->hkl;
            Lock(&ptiT->spklActive, pkl);
            if (ptiT->spDefaultImc) {
                try {
                    ptiT->pClientInfo->CI_flags |= CI_INPUTCONTEXT_REINIT;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    continue;
                }
                RIPMSG1(RIP_VERBOSE, "xxxImmActivateThreadsLayout: ptiT(%08p) will be re-initialized.", ptiT);
            }
            UserAssert((ptiT->TIF_flags & TIF_INCLEANUP) == 0);
            try {
                ptiT->pClientInfo->hKL = pkl->hkl;
                ptiT->pClientInfo->CodePage = pkl->CodePage;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
            continue;
        }

        ThreadLockPti(ptiCurrent, ptiT, &tlBlock.list[cThreads].tlpti);
        tlBlock.list[cThreads++].pti = ptiT;

        if (cThreads == THREADS_PER_TLBLOCK)
            break;
    }

    /*
     * Return FALSE if all the threads already had the pkl active.
     */
    if (ptlBlockPrev == NULL && ptiT == NULL && cThreads == 0)
        return FALSE;

    /*
     * If we can't service all the threads in this run,
     * call ImmActivateThreadsLayout() again for a new TLBLOCK.
     */
    if (ptiT != NULL && ptiT->ptiSibling != NULL) {
        tlBlock.ptlBlockPrev = ptlBlockPrev;
        return xxxImmActivateThreadsLayout(ptiT->ptiSibling, &tlBlock, pkl);
    }

    /*
     * Finally, we can do the actual keyboard layout activation
     * starting from this run. Work on current TLBLOCK first.
     * We walk the list backwards so that the pti unlocks will
     * be done in the right order.
     */

    tlBlock.ptlBlockPrev = ptlBlockPrev;
    ptlBlockPrev = &tlBlock;

    while (ptlBlockPrev != NULL) {
        for (i = cThreads - 1; i >= 0; --i) {
            if ((ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP) == 0) {
                ptiT = ptlBlockPrev->list[i].pti;
                UserAssert(ptiT);
                xxxImmActivateLayout(ptiT, pkl);
                if ((ptiT->TIF_flags & TIF_INCLEANUP) == 0) {
                    try {
                        ptiT->pClientInfo->hKL = pkl->hkl;
                        ptiT->pClientInfo->CodePage = pkl->CodePage;
                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    } 
                }
            }
            ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
        }
        ptlBlockPrev = ptlBlockPrev->ptlBlockPrev;
        cThreads = THREADS_PER_TLBLOCK;
    }

    return TRUE;
}

VOID xxxImmActivateAndUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntries,
    IN PTLBLOCK     ptlBlockPrev,
    PKL             pklCurrent,
    DWORD           dwHklReplace)
{
    TLBLOCK     tlBlock;
    PTHREADINFO ptiCurrent;
    int         i, cThreads;
    enum { RUN_ACTIVATE = 1, RUN_UNLOAD = 2, RUN_FLAGS_MASK = RUN_ACTIVATE | RUN_UNLOAD, RUN_INVALID = 0xffff0000 };

    CheckLock(pklCurrent);

    ptiCurrent = PtiCurrentShared();

    tlBlock.ptlBlockPrev = ptlBlockPrev;

    /*
     * Build a list of threads that we need to unload their IME DLL(s).
     * We can't just walk the ptiList while we're doing the work, because
     * for IME based keyboard layout, we will do callback to client side
     * and the pti could get deleted out while we leave the critical section.
     */
    for (i = 0, cThreads = 0; i < (INT)nEntries; i++) {
        DWORD dwFlags = 0;

        /*
         * Skip all the *do nothing* cases in xxxImmActivateLayout
         * so as to minimize the # of TLBLOCKs required.
         */
        if (ptiList[i]->TIF_flags & TIF_INCLEANUP) {
            dwFlags = RUN_INVALID;
        }
        else if (ptiList[i]->spklActive != pklCurrent) {
            if (ptiList[i]->spwndDefaultIme == NULL) {
                BOOLEAN fAttached = FALSE;

                Lock(&ptiList[i]->spklActive, pklCurrent);
                if (ptiList[i]->pClientInfo != ptiCurrent->pClientInfo &&
                        ptiList[i]->ppi != ptiCurrent->ppi) {
                    /*
                     * If the thread is in another process, attach
                     * to that process so that we can access its ClientInfo.
                     */
                    KeAttachProcess(PsGetProcessPcb(ptiList[i]->ppi->Process));
                    fAttached = TRUE;
                }

                try {
                    ptiList[i]->pClientInfo->CodePage = pklCurrent->CodePage;
                    ptiList[i]->pClientInfo->hKL = pklCurrent->hkl;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                      dwFlags = RUN_INVALID;
                }
                if (fAttached) {
                    KeDetachProcess();
                }
            } else {
                dwFlags = RUN_ACTIVATE;
            }
        }

        /*
         * Skip all the *do nothing* cases in xxxImmUnloadLayout()
         * so as to minimize the # of TLBLOCK required.
         * (#99321)
         */
        if (ptiList[i]->spwndDefaultIme != NULL &&
                ptiList[i]->spklActive != NULL &&
                (dwHklReplace != IFL_DEACTIVATEIME ||
                 IS_IME_KBDLAYOUT(ptiList[i]->spklActive->hkl)
#ifdef CUAS_ENABLE
                 ||
                 IS_CICERO_ENABLED_AND_NOT16BIT()
#endif // CUAS_ENABLE
                ) &&
                dwFlags != RUN_INVALID) {
            dwFlags |= RUN_UNLOAD;
        }

        if (dwFlags && dwFlags != RUN_INVALID) {
            ThreadLockPti(ptiCurrent, ptiList[i], &tlBlock.list[cThreads].tlpti);
#if DBG
            tlBlock.list[cThreads].dwUnlockedCount = 0;
#endif
            tlBlock.list[cThreads].pti = ptiList[i];
            tlBlock.list[cThreads++].dwFlags = dwFlags;

            if (cThreads == THREADS_PER_TLBLOCK) {
                i++;   // 1 more before exit the loop.
                break;
            }
        }
    }

    /*
     * If we can't service all the threads in this run,
     * call xxxImmActivateAndUnloadThreadsLayout again for a new TLBLOCK.
     */
    if (i < (INT)nEntries) {
        ptiList  += i;
        nEntries -= i;
        xxxImmActivateAndUnloadThreadsLayout(ptiList, nEntries, &tlBlock, pklCurrent, dwHklReplace);
        return;
    }

    /*
     * Finally, we can do the actual keyboard layout activation
     * starting from this run. Work on current TLBLOCK first.
     * We walk the list backwards so that the pti unlocks will
     * be done in the right order.
     */
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev != NULL; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; i--) {
            if ((ptlBlockPrev->list[i].dwFlags & RUN_ACTIVATE) &&
                    !(ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP)) {
                xxxImmActivateLayout(ptlBlockPrev->list[i].pti, pklCurrent);
            }

            // unlock the thread if the thread is only locked for the first run
            if ((ptlBlockPrev->list[i].dwFlags & RUN_FLAGS_MASK) == RUN_ACTIVATE) {
                ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
#if DBG
                ptlBlockPrev->list[i].dwUnlockedCount++;
#endif
            }
        }
        i = THREADS_PER_TLBLOCK - 1;
    }

    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev != NULL; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            if (ptlBlockPrev->list[i].dwFlags & RUN_UNLOAD) {
                if (!(ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP)) {
                    xxxImmUnloadLayout(ptlBlockPrev->list[i].pti, dwHklReplace);
                }
                else {
                    RIPMSG1(RIP_WARNING, "xxxImmActivateAndUnloadThreadsLayout: thread %#p is cleaned up.",
                            ptlBlockPrev->list[i].pti);
                }
                // unlock the thread
                UserAssert((ptlBlockPrev->list[i].dwFlags & RUN_FLAGS_MASK) != RUN_ACTIVATE);
                UserAssert(ptlBlockPrev->list[i].dwUnlockedCount == 0);
                ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
#if DBG
                ptlBlockPrev->list[i].dwUnlockedCount++;
#endif
            }
        }
        i = THREADS_PER_TLBLOCK - 1;
    }

#if DBG
    // Check if all the locked thread is properly unlocked
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            UserAssert(ptlBlockPrev->list[i].dwUnlockedCount == 1);
        }
        i = THREADS_PER_TLBLOCK - 1;
    }
#endif

    return;
}

/**************************************************************************\
* xxxImmActivateLayout
*
* Activate IME based keyboard layout.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

VOID xxxImmActivateLayout(
    IN PTHREADINFO pti,
    IN PKL pkl)
{
    TL tlpwndDefaultIme;
    PTHREADINFO ptiCurrent;

    CheckLock(pkl);

    /*
     * Do nothing if it's already been the current active layout.
     */
    if (pti->spklActive == pkl)
        return;

    if (pti->spwndDefaultIme == NULL) {
        /*
         * Only activate kernel side keyboard layout if this pti
         * doesn't have the default IME window.
         */
        Lock(&pti->spklActive, pkl);
        return;
    }

    ptiCurrent = PtiCurrentShared();

    /*
     * Activate client side IME based keyboard layout.
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pti->spwndDefaultIme, &tlpwndDefaultIme);
    xxxSendMessage(pti->spwndDefaultIme, WM_IME_SYSTEM,
                (WPARAM)IMS_ACTIVATETHREADLAYOUT, (LPARAM)pkl->hkl);
    ThreadUnlock(&tlpwndDefaultIme);

    Lock(&pti->spklActive, pkl);

    return;
}


VOID xxxImmUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntries,
    IN PTLBLOCK     ptlBlockPrev,
    IN DWORD        dwFlag)
{
    TLBLOCK     tlBlock;
    PTHREADINFO ptiCurrent;
    INT         i, cThreads;
    BOOLEAN     fPerformUnlock;

    ptiCurrent = PtiCurrentShared();
    tlBlock.ptlBlockPrev = ptlBlockPrev;

    /*
     * Build a list of threads that we need to unload their IME DLL(s).
     * We can't just walk the ptiList while we're doing the work, because
     * for IME based keyboard layout, we will do callback to client side
     * and the pti could get deleted out while we leave the critical section.
     */
    for (i = 0, cThreads = 0; i < (INT)nEntries; i++) {
        /*
         * Skip all the *do nothing* cases in xxxImmUnloadLayout()
         * so as to minimize the # of TLBLOCK required.
         */
        if ((ptiList[i]->TIF_flags & TIF_INCLEANUP) || ptiList[i]->spwndDefaultIme == NULL)
            continue;

        if (ptiList[i]->spklActive == NULL)
            continue;

#if !defined(CUAS_ENABLE)
        if (dwFlag == IFL_DEACTIVATEIME &&
                !IS_IME_KBDLAYOUT(ptiList[i]->spklActive->hkl)) // #99321
            continue;
#else
        if (dwFlag == IFL_DEACTIVATEIME &&
                ((! IS_CICERO_ENABLED() && ! IS_IME_KBDLAYOUT(ptiList[i]->spklActive->hkl)) ||
                 (  IS_CICERO_ENABLED() && (PtiCurrent()->TIF_flags & TIF_16BIT)))
           ) // #99321
            continue;
#endif

#if DBG
        tlBlock.list[cThreads].dwUnlockedCount = 0;
#endif
        ThreadLockPti(ptiCurrent, ptiList[i], &tlBlock.list[cThreads].tlpti);
        tlBlock.list[cThreads++].pti = ptiList[i];
        if (cThreads == THREADS_PER_TLBLOCK) {
            i++;   // 1 more before exit the loop.
            break;
        }
    }

    if (i < (INT)nEntries) {
        ptiList  += i;
        nEntries -= i;
        xxxImmUnloadThreadsLayout(ptiList, nEntries, &tlBlock, dwFlag);
        return;
    }

    UserAssert(dwFlag == IFL_UNLOADIME || dwFlag == IFL_DEACTIVATEIME);
    if (dwFlag == IFL_UNLOADIME) {
        dwFlag = IFL_DEACTIVATEIME;
        fPerformUnlock = FALSE;
    } else {
        fPerformUnlock = TRUE;
    }
RepeatForUnload:
    /*
     * Finally, we can unload the IME based keyboard layout
     * starting from this run. Work on current TLBLOCK first.
     * We walk the list backwards so that the pti unlocks will
     * be done in the right order.
     */
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            if (!(ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP)) {
                xxxImmUnloadLayout(ptlBlockPrev->list[i].pti, dwFlag);
            }
            else {
                RIPMSG2(RIP_WARNING, "Thread %#p is cleaned during the loop for %x!", ptlBlockPrev->list[i].pti, dwFlag);
            }

            if (fPerformUnlock) {
#if DBG
                ptlBlockPrev->list[i].dwUnlockedCount++;
#endif
                ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
            }
        }
        i = THREADS_PER_TLBLOCK - 1;
    }

    if (!fPerformUnlock) {
        fPerformUnlock = TRUE;
        dwFlag = IFL_UNLOADIME;
        goto RepeatForUnload;
    }

#if DBG
    // Check if all the locked thread is properly unlocked
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            UserAssert(ptlBlockPrev->list[i].dwUnlockedCount == 1);
        }
        i = THREADS_PER_TLBLOCK - 1;
    }
#endif

    return;
}



VOID xxxImmUnloadLayout(
    IN PTHREADINFO pti,
    IN DWORD dwFlag)
{
    TL tlpwndDefaultIme;
    PTHREADINFO ptiCurrent;
    ULONG_PTR dwResult;
    LRESULT r;

    /*
     * Do nothing if the thread does not have default IME window.
     */
    if (pti->spwndDefaultIme == NULL)
        return;

    if (pti->spklActive == NULL)
        return;

#if !defined(CUAS_ENABLE)
    if (dwFlag == IFL_DEACTIVATEIME &&
            !IS_IME_KBDLAYOUT(pti->spklActive->hkl))
        return;
#else
    if (dwFlag == IFL_DEACTIVATEIME &&
            ((! IS_CICERO_ENABLED() && !IS_IME_KBDLAYOUT(pti->spklActive->hkl)) ||
             (  IS_CICERO_ENABLED() && (PtiCurrent()->TIF_flags & TIF_16BIT)))
       )
        return;
#endif

    ptiCurrent = PtiCurrentShared();

    ThreadLockAlwaysWithPti(ptiCurrent, pti->spwndDefaultIme, &tlpwndDefaultIme);
    r = xxxSendMessageTimeout(pti->spwndDefaultIme, WM_IME_SYSTEM,
                          IMS_UNLOADTHREADLAYOUT, (LONG)dwFlag,
                          SMTO_NOTIMEOUTIFNOTHUNG, CMSHUNGAPPTIMEOUT, &dwResult);

    if (!r) {
        RIPMSG1(RIP_WARNING, "Timeout in xxxImmUnloadLayout: perhaps this thread (0x%x) is not pumping messages.",
                GETPTIID(pti));
    }

    ThreadUnlock(&tlpwndDefaultIme);

    return;
}

/**************************************************************************\
* xxxImmLoadLayout
*
* Retrieves extended IMEINFO for the given IME based keyboard layout.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

PIMEINFOEX xxxImmLoadLayout(
    IN HKL hKL)
{
    PIMEINFOEX  piiex;
    PTHREADINFO ptiCurrent;
    TL          tlPool;

    /*
     * No IMEINFOEX for non-IME based keyboard layout.
     */
#if !defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return (PIMEINFOEX)NULL;
#else
    if ((! IS_CICERO_ENABLED() && !IS_IME_KBDLAYOUT(hKL)) ||
        (  IS_CICERO_ENABLED() && (PtiCurrent()->TIF_flags & TIF_16BIT))
       )
        return (PIMEINFOEX)NULL;
#endif

    piiex = (PIMEINFOEX)UserAllocPool(sizeof(IMEINFOEX), TAG_IME);

    if (piiex == NULL) {
        RIPMSG1(RIP_WARNING,
              "xxxImmLoadLayout: failed to create piiex for hkl = %lx", hKL);
        return (PIMEINFOEX)NULL;
    }

    ptiCurrent = PtiCurrent();

    /*
     * Lock this allocations since we are going to the client side
     */
    ThreadLockPool(ptiCurrent, piiex, &tlPool);

    if (!ClientImmLoadLayout(hKL, piiex)) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
        return (PIMEINFOEX)NULL;
    }

    ThreadUnlockPool(ptiCurrent, &tlPool);

    return piiex;
}


/**************************************************************************\
* GetImeInfoEx
*
* Query extended IMEINFO.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

BOOL GetImeInfoEx(
    PWINDOWSTATION pwinsta,
    PIMEINFOEX piiex,
    IMEINFOEXCLASS SearchType)
{
    PKL pkl, pklFirst;

    /*
     * Note: this check was forced to insert due to winmm.dll who indirectly
     * loads imm32.dll in CSRSS context. CSRSS is not always bound to
     * specific window station, thus pwinsta could be NULL.
     * This has been avoided by not loading imm32.dll.
     * After winmm.dll gets removed from CSRSS, this if statement should be
     * removed, or substituted as an assertion.
     */
    if (pwinsta == NULL) {
        return FALSE;
    }

    /*
     * Keyboard layer has not been initialized.
     */
    if (pwinsta->spklList == NULL)
        return FALSE;

    pkl = pklFirst = pwinsta->spklList;

    switch (SearchType) {
    case ImeInfoExKeyboardLayout:
        do {
            if (pkl->hkl == piiex->hkl) {

                if (pkl->piiex == NULL)
                    break;

                RtlCopyMemory(piiex, pkl->piiex, sizeof(IMEINFOEX));
                return TRUE;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklFirst);
        break;

    case ImeInfoExImeFileName:
        do {
            if (pkl->piiex != NULL &&
                !_wcsnicmp(pkl->piiex->wszImeFile, piiex->wszImeFile, IM_FILE_SIZE)) {

                RtlCopyMemory(piiex, pkl->piiex, sizeof(IMEINFOEX));
                return TRUE;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklFirst);
        break;

    default:
        break;
    }

    return FALSE;
}


/**************************************************************************\
* SetImeInfoEx
*
* Set extended IMEINFO.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

BOOL SetImeInfoEx(
    PWINDOWSTATION pwinsta,
    PIMEINFOEX piiex)
{
    PKL pkl, pklFirst;

    if (pwinsta == NULL) {
        return FALSE;
    }

    UserAssert(pwinsta->spklList != NULL);

    pkl = pklFirst = pwinsta->spklList;

    do {
        if (pkl->hkl == piiex->hkl) {

            /*
             * Error out for non-IME based keyboard layout.
             */
            if (pkl->piiex == NULL)
                return FALSE;

            /*
             * Update kernel side IMEINFOEX for this keyboard layout
             * only if this is its first loading.
             */
            if (pkl->piiex->fLoadFlag == IMEF_NONLOAD) {
                RtlCopyMemory(pkl->piiex, piiex, sizeof(IMEINFOEX));
            }

            return TRUE;
        }
        pkl = pkl->pklNext;

    } while (pkl != pklFirst);

    return FALSE;
}


/***************************************************************************\
* xxxImmProcessKey
*
*
* History:
* 03-03-96 TakaoK             Created.
\***************************************************************************/

DWORD xxxImmProcessKey(
    IN PQ   pq,
    IN PWND pwnd,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    UINT  uVKey;
    PKL   pkl;
    DWORD dwHotKeyID;
    DWORD dwReturn = 0;
    PIMC  pImc = NULL;
    BOOL  fDBERoman = FALSE;
    PIMEHOTKEYOBJ pImeHotKeyObj;
    HKL hklTarget;

    CheckLock(pwnd);

    //
    // we're interested in only keyboard messages.
    //
    if ( message != WM_KEYDOWN    &&
         message != WM_SYSKEYDOWN &&
         message != WM_KEYUP      &&
         message != WM_SYSKEYUP ) {

        return dwReturn;
    }

    //
    // Check if it's IME hotkey. This must be done before checking
    // the keyboard layout because IME hotkey handler should be
    // called even if current keyboard layout is non-IME layout.
    //
    pkl = GETPTI(pwnd)->spklActive;
    if ( pkl == NULL ) {
        return dwReturn;
    }

    uVKey = (UINT)wParam & 0xff;

    pImeHotKeyObj = CheckImeHotKey(pq, uVKey, lParam);
    if (pImeHotKeyObj) {
        dwHotKeyID = pImeHotKeyObj->hk.dwHotKeyID;
        hklTarget = pImeHotKeyObj->hk.hKL;
    }
    else {
        dwHotKeyID = IME_INVALID_HOTKEY;
        hklTarget = (HKL)NULL;
    }

    //
    // Handle Direct KL switching here.
    //
    if (dwHotKeyID >= IME_HOTKEY_DSWITCH_FIRST && dwHotKeyID <= IME_HOTKEY_DSWITCH_LAST) {
        UserAssert(hklTarget != NULL);
        if (pkl->hkl != hklTarget) {
            //
            // Post the message only if the new Keyboard Layout is different from
            // the current Keyboard Layout.
            //
            _PostMessage(pwnd, WM_INPUTLANGCHANGEREQUEST,
                         (pkl->dwFontSigs & gSystemFS) ? INPUTLANGCHANGE_SYSCHARSET : 0,
                         (LPARAM)hklTarget);
        }
        if (GetAppImeCompatFlags(GETPTI(pwnd)) & IMECOMPAT_HYDRACLIENT) {
            return 0;
        }
        return IPHK_HOTKEY;
    }

    if (!IS_IME_ENABLED()) {
        //
        // Since IMM is disabled, no need to process further.
        // Just bail out.
        //
        return 0;
    }

    if ( dwHotKeyID != IME_INVALID_HOTKEY ) {
        //
        // if it's a valid hotkey, go straight and call back
        // the IME in the client side.
        //
        goto ProcessKeyCallClient;
    }

    //
    // if it's not a hotkey, we may want to check something
    // before calling back.
    //
    if ( pkl->piiex == NULL ) {
        return dwReturn;
    }

    //
    // Check input context
    //
    pImc = HtoP(pwnd->hImc);
    if ( pImc == NULL ) {
        return dwReturn;
    }

#ifdef LATER
    //
    // If there is an easy way to check the input context open/close status
    // from the kernel side, IME_PROP_NO_KEYS_ON_CLOSE checking should be
    // done here in kernel side.  [ 3/10/96 takaok]
    //

    //
    // Check IME_PROP_NO_KEYS_ON_CLOSE bit
    //
    // if the current imc is not open and IME doesn't need
    // keys when being closed, we don't pass any keyboard
    // input to ime except hotkey and keys that change
    // the keyboard status.
    //
    if ( (piix->ImeInfo.fdwProperty & IME_PROP_NO_KEYS_ON_CLOSE) &&
         (!pimc->fdwState & IMC_OPEN)                            &&
         uVKey != VK_SHIFT                                       &&  // 0x10
         uVKey != VK_CONTROL                                     &&  // 0x11
         uVKey != VK_CAPITAL                                     &&  // 0x14
         uVKey != VK_KANA                                        &&  // 0x15
         uVKey != VK_NUMLOCK                                     &&  // 0x90
         uVKey != VK_SCROLL )                                        // 0x91
    {
      // Check if Korea Hanja conversion mode
      if( !(pimc->fdwConvMode & IME_CMODE_HANJACONVERT) ) {
          return dwReturn;
      }
    }
#endif

    //
    // if the IME doesn't need key up messages, we don't call ime.
    //
    if ( lParam & 0x80000000 && // set if key up, clear if key down
         pkl->piiex->ImeInfo.fdwProperty & IME_PROP_IGNORE_UPKEYS )
    {
        return dwReturn;
    }

    //
    // we don't want to handle sys keys since many functions for
    // acceelerators won't work without this
    //
    fDBERoman = (BOOL)( (uVKey == VK_DBE_ROMAN)            ||
                        (uVKey == VK_DBE_NOROMAN)          ||
                        (uVKey == VK_DBE_HIRAGANA)         ||
                        (uVKey == VK_DBE_KATAKANA)         ||
                        (uVKey == VK_DBE_CODEINPUT)        ||
                        (uVKey == VK_DBE_NOCODEINPUT)      ||
                        (uVKey == VK_DBE_IME_WORDREGISTER) ||
                        (uVKey == VK_DBE_IME_DIALOG) );

    if (message == WM_SYSKEYDOWN || message == WM_SYSKEYUP ) {
        //
        // IME may be waiting for VK_MENU, VK_F10 or VK_DBE_xxx
        //
        if ( uVKey != VK_MENU && uVKey != VK_F10 && !fDBERoman ) {
            return dwReturn;
        }
    }

    //
    // check if the IME doesn't need ALT key
    //
    if ( !(pkl->piiex->ImeInfo.fdwProperty & IME_PROP_NEED_ALTKEY) ) {
        //
        // IME doesn't need ALT key
        //
        // we don't pass the ALT and ALT+xxx except VK_DBE_xxx keys.
        //
        if ( ! fDBERoman &&
             (uVKey == VK_MENU || (lParam & 0x20000000))  // KF_ALTDOWN
           )
        {
            return dwReturn;
        }
    }

    //
    // finaly call back the client
    //

ProcessKeyCallClient:

    if ((uVKey & 0xff) == VK_PACKET) {
        //
        // need to retrieve UNICODE character from pti
        //
        uVKey = MAKELONG(wParam, PtiCurrent()->wchInjected);
    }
    dwReturn = ClientImmProcessKey( PtoH(pwnd),
                                    pkl->hkl,
                                    uVKey,
                                    lParam,
                                    dwHotKeyID);

    //
    // Hydra server wants to see the IME hotkeys.
    //
    if (GetAppImeCompatFlags(GETPTI(pwnd)) & IMECOMPAT_HYDRACLIENT) {
        dwReturn &= ~IPHK_HOTKEY;
    }
    return dwReturn;
}


/**************************************************************************\
* ImeCanDestroyDefIME
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

BOOL ImeCanDestroyDefIME(
    PWND pwndDefaultIme,
    PWND pwndDestroy)
{
    PWND   pwnd;
    PIMEUI pimeui;

    pimeui = ((PIMEWND)pwndDefaultIme)->pimeui;

    if (pimeui == NULL || (LONG_PTR)pimeui == (LONG_PTR)-1)
        return FALSE;

    try {
        if (ProbeAndReadStructure(pimeui, IMEUI).fDestroy) {
            return FALSE;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    /*
     * If the pwndDestroy has no owner/ownee relationship with
     * pwndDefaultIme, don't bother to change anything.
     *
     * If pwndDefaultIme->spwndOwner is NULL, this means we need
     * to search for a new good owner window.
     */
    if ( pwndDefaultIme->spwndOwner != NULL ) {
        for (pwnd = pwndDefaultIme->spwndOwner;
             pwnd != pwndDestroy && pwnd != NULL; pwnd = pwnd->spwndOwner) ;

        if (pwnd == NULL)
            return FALSE;
    }

    /*
     * If the destroying window is IME or UI window, do nothing
     */
    pwnd = pwndDestroy;

    while (pwnd != NULL) {
        if (TestCF(pwnd, CFIME) ||
                pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
            return FALSE;

        pwnd = pwnd->spwndOwner;
    }

    ImeSetFutureOwner(pwndDefaultIme, pwndDestroy);

    /*
     * If new owner is lower z-order than IME class window,
     * we need to check topmost to change z-order.
     */
    pwnd = pwndDefaultIme->spwndOwner;
    while (pwnd != NULL && pwnd != pwndDefaultIme)
        pwnd = pwnd->spwndNext;

    if (pwnd == pwndDefaultIme)
        ImeCheckTopmost(pwndDefaultIme);

#if DBG
    CheckOwnerCirculate(pwndDefaultIme);
#endif

    /*
     * If ImeSetFutureOwner can not find the owner window any
     * more, this IME window should be destroyed.
     */
    if (pwndDefaultIme->spwndOwner == NULL ||
            pwndDestroy == pwndDefaultIme->spwndOwner) {

//        RIPMSG1(RIP_WARNING, "ImeCanDestroyDefIME: TRUE for pwnd=%#p", pwndDestroy);
        Unlock(&pwndDefaultIme->spwndOwner);

        /*
         * Return TRUE! Please destroy me.
         */
        return TRUE;
    }

    return FALSE;
}


/**************************************************************************\
* IsChildSameThread (IsChildSameQ)
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

BOOL IsChildSameThread(
    PWND pwndParent,
    PWND pwndChild)
{
    PWND pwnd;
    PTHREADINFO ptiChild = GETPTI(pwndChild);

    for (pwnd = pwndParent->spwndChild; pwnd; pwnd = pwnd->spwndNext) {
        /*
         * If pwnd is not child window, we need to skip MENU window and
         * IME related window.
         */
        if (!TestwndChild(pwnd)) {
            PWND pwndOwner = pwnd;
            BOOL fFoundOwner = FALSE;

            /*
             * Skip MENU window.
             */
            if (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_MENU])
                continue;

            while (pwndOwner != NULL) {
                /*
                 * CS_IME class or "IME" class windows can not be the owner of
                 * IME windows.
                 */
                if (TestCF(pwndOwner, CFIME) ||
                        pwndOwner->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
                    fFoundOwner = TRUE;
                    break;
                }

                pwndOwner = pwndOwner->spwndOwner;
            }

            if (fFoundOwner)
                continue;
        }

        /*
         * We need to skip pwndChild.
         */
        if (pwnd == pwndChild)
            continue;

        /*
         * pwnd and pwndChild are on same thread?
         */
        if (GETPTI(pwnd) == ptiChild) {
            PWND pwndT = pwnd;
            BOOL fFoundImeWnd = FALSE;

            /*
             * Check again. If hwndT is children or ownee of
             * IME related window, skip it.
             */
            if (TestwndChild(pwndT)) {

                for (; TestwndChild(pwndT) && GETPTI(pwndT) == ptiChild;
                        pwndT = pwndT->spwndParent) {
                    if (TestCF(pwndT, CFIME) ||
                            pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
                        fFoundImeWnd = TRUE;
                }
            }

            if (!TestwndChild(pwndT)) {

                for (; pwndT != NULL && GETPTI(pwndT) == ptiChild;
                        pwndT = pwndT->spwndOwner) {
                    if (TestCF(pwndT, CFIME) ||
                            pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
                        fFoundImeWnd = TRUE;
                }
            }

            if (!fFoundImeWnd)
                return TRUE;
        }
    }

    return FALSE;
}


/**************************************************************************\
* ImeCanDestroyDefIMEforChild
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

BOOL ImeCanDestroyDefIMEforChild(
    PWND pwndDefaultIme,
    PWND pwndDestroy)
{
    PWND pwnd;
    PIMEUI pimeui;

    pimeui = ((PIMEWND)pwndDefaultIme)->pimeui;

    /*
     * If this window is not for Child Thread.....
     */
    if (pimeui == NULL || (LONG_PTR)pimeui == (LONG_PTR)-1)
        return FALSE;

    try {
        if (!ProbeAndReadStructure(pimeui, IMEUI).fChildThreadDef) {
            return FALSE;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    /*
     * If parent belongs to different thread,
     * we don't need to check any more...
     */
    if (pwndDestroy->spwndParent == NULL ||
            GETPTI(pwndDestroy) == GETPTI(pwndDestroy->spwndParent))
        return FALSE;

    pwnd = pwndDestroy;

    while (pwnd != NULL && pwnd != PWNDDESKTOP(pwnd)) {
        if (IsChildSameThread(pwnd->spwndParent, pwndDestroy))
            return FALSE;
        pwnd = pwnd->spwndParent;
    }

    /*
     * We could not find any other window created by GETPTI(pwndDestroy).
     * Let's destroy the default IME window of this Q.
     */
    return TRUE;
}


/**************************************************************************\
* ImeCheckTopmost
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeCheckTopmost(
    PWND pwndIme)
{
    if (pwndIme->spwndOwner) {
        PWND pwndInsertBeforeThis;
        /*
         * The ime window have to be same topmost tyle with the owner window.
         * If the Q of this window is not foreground Q, we don't need to
         * forground the IME window.
         * But the topmost attribute of owner was changed, this IME window
         * should be re-calced.
         */
        if (GETPTI(pwndIme) == gptiForeground) {
            pwndInsertBeforeThis = NULL;
        } else {
            pwndInsertBeforeThis = pwndIme->spwndOwner;
        }

        ImeSetTopmost(pwndIme, TestWF(pwndIme->spwndOwner, WEFTOPMOST) != 0, pwndInsertBeforeThis);
    }
}


/**************************************************************************\
* ImeSetOwnerWindow
*
* Before re-owning the IME window, several checks must be done on the new 
* owner.  Of great importance, the new owner cannot be an IME window itself,
* must be a top level window and there can never be an ownership cycle or 
* it would throw win32k into an un-recoverable spin.
*
* History:
* 17-July-2001  Mohamed    Created.
\**************************************************************************/
VOID ImeSetOwnerWindow(
    IN PWND pwndIme,
    IN PWND pwndNewOwner) 
{
    PWND pwndTopLevel;
    PWND pwndT;

    if (TestCF(pwndNewOwner, CFIME) || pwndNewOwner->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
        RIPMSG1(RIP_WARNING, "New owner window (pwnd=%p) should not be an IME/UI window!!", pwndNewOwner);
        return;
    }

    /*
     * Child window cannot be an owner window.  Therefore, we get that window's top
     * level parent.
     */
    pwndTopLevel = pwndT = GetTopLevelWindow(pwndNewOwner);

    /*
     * To prevent an IME window from becoming the owner of another IME window.
     */
    while (pwndT != NULL) {
        if (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
            RIPMSG1(RIP_WARNING, "The new owner (pwnd=%p) of an IME window should not itself be an IME window!!", pwndT);
            pwndTopLevel = NULL;
            break;
        }
        pwndT = pwndT->spwndOwner;
    }

    UserAssert(pwndIme->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]);
    UserAssert(pwndTopLevel == NULL || !TestCF(pwndTopLevel, CFIME));
    Lock(&pwndIme->spwndOwner, pwndTopLevel);
}


/**************************************************************************\
* ImeSetFutureOwner
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeSetFutureOwner(
    PWND pwndIme,
    PWND pwndOrgOwner)
{
    PWND pwnd, pwndOwner;
    PTHREADINFO ptiImeWnd = GETPTI(pwndIme);

    if (pwndOrgOwner == NULL || TestWF(pwndOrgOwner, WFCHILD))
        return;

    pwnd = pwndOrgOwner;

    /*
     * Get top of owner created by the same thread.
     */
    while ((pwndOwner = pwnd->spwndOwner) != NULL &&
            GETPTI(pwndOwner) == ptiImeWnd)
        pwnd = pwndOwner;

    /*
     * Bottom window can not be the owner of IME window easily...
     */
    if (TestWF(pwnd, WFBOTTOMMOST) && !TestWF(pwndOrgOwner, WFBOTTOMMOST))
        pwnd = pwndOrgOwner;

    /*
     * CS_IME class or "IME" class windows can not be the owner of
     * IME windows.
     */
    if (TestCF(pwnd, CFIME) ||
            pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
        pwnd = pwndOrgOwner;

    /*
     * If hwndOrgOwner is a top of owner, we start to search
     * another top owner window in same queue.
     */
    if (pwndOrgOwner == pwnd && pwnd->spwndParent != NULL) {
        PWND pwndT;

        for (pwndT = pwnd->spwndParent->spwndChild;
                pwndT != NULL; pwndT = pwndT->spwndNext) {

            if (GETPTI(pwnd) != GETPTI(pwndT))
                continue;

            if (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_MENU])
                continue;

            /*
             * CS_IME class or "IME" class windows can not be the owner of
             * IME windows.
             */
            if (TestCF(pwndT, CFIME) ||
                    pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
                continue;

            // We don't like the window that is being destroyed.
            if (TestWF(pwndT, WFINDESTROY))
                continue;

            /*
             * !!!!WARNING!!!!!
             * Is hwndT a good owner of hIMEwnd??
             *  1. Of cource, it should no CHILD window!
             *  2. If it is hwnd,.. I know it and find next!
             *  3. Does hwndT have owner in the same thread?
             */
            if (!TestWF(pwndT, WFCHILD) && pwnd != pwndT &&
                    (pwndT->spwndOwner == NULL ||
                     GETPTI(pwndT) != GETPTI(pwndT->spwndOwner))) {
                UserAssert(GETPTI(pwndIme) == GETPTI(pwndT));
                pwnd = pwndT;
                break;
            }
        }
    }

    UserAssert(!TestCF(pwnd, CFIME));
    Lock(&pwndIme->spwndOwner, pwnd);

    return;
}


/**************************************************************************\
* ImeSetTopmostChild
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeSetTopmostChild(
    PWND pwndParent,
    BOOL fMakeTopmost)
{
    PWND pwnd = pwndParent->spwndChild;

    while (pwnd != NULL) {
        if (fMakeTopmost)
            SetWF(pwnd, WEFTOPMOST);
        else
            ClrWF(pwnd, WEFTOPMOST);

        ImeSetTopmostChild(pwnd, fMakeTopmost);

        pwnd = pwnd->spwndNext;
    }

    return;
}


/**************************************************************************\
*
*  GetLastTopMostWindowNoIME() -
*
*  Get the last topmost window which is not the ownee of pwndRoot (IME window).
*
\**************************************************************************/

PWND GetLastTopMostWindowNoIME(PWND pwndRoot)
{
    PWND pwndT = _GetDesktopWindow();
    PWND pwndRet = NULL;

    /*
     * pwndRoot should not be NULL, and should be IME window.
     */
    UserAssert(pwndRoot && pwndRoot->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]);

    if (pwndT == NULL || pwndT->spwndChild == NULL) {
#if _DBG
        if (pwndT == NULL) {
            RIPMSG0(RIP_WARNING, "GetLastTopMostWindowNoIME: there's no desktop window !!");
        }
        else {
            RIPMSG0(RIP_WARNING, "GetLastTopMostWindowNoIME: there is no toplevel window !!");
        }
#endif
        return NULL;
    }

    /*
     * Get the first child of the desktop window.
     */
    pwndT = pwndT->spwndChild;

    /*
     * Loop through the toplevel windows while they are topmost.
     */
    while (TestWF(pwndT, WEFTOPMOST)) {
        PWND pwndOwner = pwndT;
        BOOL fOwned = FALSE;

        /*
         * If pwndT is a IME related window, track the owner. If pwndRoot is not
         * pwndT's owner, remember pwndT as a candidate.
         */
        if (TestCF(pwndT,CFIME) || (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])) {
            while (pwndOwner != NULL) {
                if (pwndRoot == pwndOwner) {
                    fOwned = TRUE;
                    break;
                }
                pwndOwner = pwndOwner->spwndOwner;
            }
        }
        if (!fOwned)
            pwndRet = pwndT;

        /*
         * Next toplevel window.
         */
        pwndT = pwndT->spwndNext;
        UserAssert(pwndT->spwndParent == _GetDesktopWindow());
    }

    return pwndRet;
}


#if DBG
void ImeCheckSetTopmostLink(PWND pwnd, PWND pwndInsFirst, PWND pwndIns)
{
    PWND pwndDebT0 = pwndInsFirst;
    BOOL fFound = FALSE;

    if (pwndDebT0) {
        while (pwndDebT0 && (pwndDebT0 != pwndIns)) {
            if (pwndDebT0 == pwnd)
                fFound = TRUE;

            pwndDebT0 = pwndDebT0->spwndNext;
        }

        if (pwndDebT0 == NULL) {
            RIPMSG3(RIP_ERROR, "pwndIns(%#p) is upper that pwndInsFirst(%#p) pwnd is (%#p)", pwndIns, pwndInsFirst, pwnd);
        } else if (fFound) {
            RIPMSG3(RIP_ERROR, "pwnd(%#p) is between pwndInsFirst(%#p) and pwndIns(%#p)", pwnd, pwndInsFirst, pwndIns);
        }
    } else if (pwndIns) {
        pwndDebT0 = pwnd->spwndParent->spwndChild;

        while (pwndDebT0 && (pwndDebT0 != pwndIns)) {
            if (pwndDebT0 == pwnd)
                fFound = TRUE;

            pwndDebT0 = pwndDebT0->spwndNext;
        }

        if (fFound) {
            RIPMSG3(RIP_ERROR, "pwnd(%#p) is between TOPLEVEL pwndInsFirst(%#p) and pwndIns(%#p)", pwnd, pwndInsFirst, pwndIns);
        }
    }
}
#endif

/**************************************************************************\
* ImeSetTopmost
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeSetTopmost(
    PWND pwndRootIme,
    BOOL fMakeTopmost,
    PWND pwndInsertBefore)
{
    PWND pwndParent = pwndRootIme->spwndParent;
    PWND pwndInsert = PWND_TOP; // pwnd which should be prior to pwndRootIme.
    PWND pwnd, pwndT;
    PWND pwndInsertFirst;
    BOOLEAN fFound;

    if (pwndParent == NULL)
        return;

    pwnd = pwndParent->spwndChild;

    if (!fMakeTopmost) {
        /*
         * Get the last topmost window. This should be after unlink pwndRootIme
         * because pwndRootIme may be the last topmost window.
         */
        pwndInsert = GetLastTopMostWindowNoIME(pwndRootIme);

        if (pwndInsertBefore) {

            fFound = FALSE;
            pwndT = pwndInsert;

            while (pwndT != NULL && pwndT->spwndNext != pwndInsertBefore) {
                if (pwndT == pwndRootIme)
                    fFound = TRUE;
                pwndT = pwndT->spwndNext;
            }

            if (pwndT == NULL || fFound)
                return;

            pwndInsert = pwndT;
        }

        if (TestWF(pwndRootIme->spwndOwner, WFBOTTOMMOST)) {
            pwndT = pwndInsert;

            while (pwndT != NULL && pwndT != pwndRootIme->spwndOwner) {
                if (!TestCF(pwndT, CFIME) &&
                        pwndT->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]) {
                    pwndInsert = pwndT;
                }
                pwndT = pwndT->spwndNext;
            }
        }
    }

    pwndInsertFirst = pwndInsert;

    /*
     * Enum the all toplevel windows and if the owner of the window is same as
     * the owner of pwndRootIme, the window should be changed the position of
     * window link.
     */
    while (pwnd != NULL) {
        /*
         * Get the next window before calling ImeSetTopmost.
         * Because the next window will be changed in LinkWindow.
         */
        PWND pwndNext = pwnd->spwndNext;

        /*
         * the owner relation between IME and UI window is in same thread.
         */
        if (GETPTI(pwnd) != GETPTI(pwndRootIme))
            goto ist_next;

        /*
         * pwnd have to be CS_IME class or "IME" class.
         */
        if (!TestCF(pwnd, CFIME) &&
                pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME])
            goto ist_next;

        /*
         * If pwnd is pwndInsert, we don't need to do anything...
         */
        if (pwnd == pwndInsert)
            goto ist_next;

        pwndT = pwnd;
        while (pwndT != NULL) {
            if (pwndT == pwndRootIme) {
                /*
                 * Found!!
                 * pwnd is the ownee of pwndRootIme.
                 */

                UserAssert(GETPTI(pwnd) == GETPTI(pwndRootIme));
                UserAssert(TestCF(pwnd,CFIME) ||
                            (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]));
                UserAssert(pwnd != pwndInsert);

                UnlinkWindow(pwnd, pwndParent);

                if (fMakeTopmost) {
                    if (pwndInsert != PWND_TOP)
                        UserAssert(TestWF(pwndInsert, WEFTOPMOST));
                    SetWF(pwnd, WEFTOPMOST);
                }
                else {
                    if (pwndInsert == PWND_TOP) {
                        /*
                         * In rare cases, the first toplevel window could be the one we'll look next,
                         * who may still have obscure topmost flag.
                         */
                        UserAssert(pwndParent->spwndChild == pwndNext || !TestWF(pwndParent->spwndChild, WEFTOPMOST));
                    }
                    else if (pwndInsert->spwndNext != NULL) {
                        /*
                         * In rare cases, pwndInsert->spwndNext could be the one we'll look next,
                         * who may still have obscure topmost flag.
                         */
                        UserAssert(pwndInsert->spwndNext == pwndNext || !TestWF(pwndInsert->spwndNext, WEFTOPMOST));
                    }
                    ClrWF(pwnd, WEFTOPMOST);
                }

                LinkWindow(pwnd, pwndInsert, pwndParent);
#if 0   // Let's see what happens if we disable this
                ImeSetTopmostChild(pwnd, fMakeTopmost);
#endif

                pwndInsert = pwnd;
                break;  // goto ist_next;
            }
            pwndT = pwndT->spwndOwner;
        }
ist_next:
        pwnd = pwndNext;

        /*
         * Skip the windows that were inserted before.
         */
        if (pwnd != NULL && pwnd == pwndInsertFirst)
            pwnd = pwndInsert->spwndNext;

#if DBG
        if (pwnd)
            ImeCheckSetTopmostLink(pwnd, pwndInsertFirst, pwndInsert);
#endif
    }
}


/**************************************************************************\
* ProbeAndCaptureSoftKbdData
*
* Captures SoftKbdData that comes from user mode.
*
* 23-Apr-1996 wkwok     created
\**************************************************************************/

PSOFTKBDDATA ProbeAndCaptureSoftKbdData(
    PSOFTKBDDATA Source)
{
    PSOFTKBDDATA Destination = NULL;
    DWORD        cbSize;
    UINT         uCount;

    try {
        uCount = ProbeAndReadUlong((PULONG)Source);

#if defined(_X86_)
        ProbeForReadBuffer(&Source->wCode, uCount, sizeof(BYTE));
#else
        ProbeForReadBuffer(&Source->wCode, uCount, sizeof(WORD));
#endif

        cbSize = FIELD_OFFSET(SOFTKBDDATA, wCode[0])
               + uCount * sizeof(WORD) * 256;

        Destination = (PSOFTKBDDATA)UserAllocPool(cbSize, TAG_IME);

        if (Destination != NULL) {
            RtlCopyMemory(Destination, Source, cbSize);
        } else {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }

    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {

        if (Destination != NULL) {
            UserFreePool(Destination);
        }

        return NULL;
    }

    return Destination;
}

//
// ported from Win95:ctxtman.c\SetConvMode()
//
VOID  SetConvMode( PTHREADINFO pti, DWORD dwConversion )
{
    if ( pti->spklActive == NULL )
        return;

    switch ( PRIMARYLANGID(HandleToUlong(pti->spklActive->hkl)) ) {
    case LANG_JAPANESE:

        ClearKeyStateDown(pti->pq, VK_DBE_ALPHANUMERIC);
        ClearKeyStateToggle(pti->pq, VK_DBE_ALPHANUMERIC);
        ClearKeyStateDown(pti->pq, VK_DBE_KATAKANA);
        ClearKeyStateToggle(pti->pq, VK_DBE_KATAKANA);
        ClearKeyStateDown(pti->pq, VK_DBE_HIRAGANA);
        ClearKeyStateToggle(pti->pq, VK_DBE_HIRAGANA);

        if ( dwConversion & IME_CMODE_NATIVE ) {
            if ( dwConversion & IME_CMODE_KATAKANA ) {
                SetKeyStateDown( pti->pq, VK_DBE_KATAKANA);
                SetKeyStateToggle( pti->pq, VK_DBE_KATAKANA);
            } else {
                SetKeyStateDown( pti->pq, VK_DBE_HIRAGANA);
                SetKeyStateToggle( pti->pq, VK_DBE_HIRAGANA);
            }
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_ALPHANUMERIC);
            SetKeyStateToggle( pti->pq, VK_DBE_ALPHANUMERIC);
        }

        if ( dwConversion & IME_CMODE_FULLSHAPE ) {
            SetKeyStateDown( pti->pq, VK_DBE_DBCSCHAR);
            SetKeyStateToggle( pti->pq, VK_DBE_DBCSCHAR);
            ClearKeyStateDown(pti->pq, VK_DBE_SBCSCHAR);
            ClearKeyStateToggle(pti->pq, VK_DBE_SBCSCHAR);
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_SBCSCHAR);
            SetKeyStateToggle( pti->pq, VK_DBE_SBCSCHAR);
            ClearKeyStateDown(pti->pq, VK_DBE_DBCSCHAR);
            ClearKeyStateToggle(pti->pq, VK_DBE_DBCSCHAR);
        }

        if ( dwConversion & IME_CMODE_ROMAN ) {
            SetKeyStateDown( pti->pq, VK_DBE_ROMAN);
            SetKeyStateToggle( pti->pq, VK_DBE_ROMAN);
            ClearKeyStateDown(pti->pq, VK_DBE_NOROMAN);
            ClearKeyStateToggle(pti->pq, VK_DBE_NOROMAN);
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_NOROMAN);
            SetKeyStateToggle( pti->pq, VK_DBE_NOROMAN);
            ClearKeyStateDown(pti->pq, VK_DBE_ROMAN);
            ClearKeyStateToggle(pti->pq, VK_DBE_ROMAN);
        }

        if ( dwConversion & IME_CMODE_CHARCODE ) {
            SetKeyStateDown( pti->pq, VK_DBE_CODEINPUT);
            SetKeyStateToggle( pti->pq, VK_DBE_CODEINPUT);
            ClearKeyStateDown(pti->pq, VK_DBE_NOCODEINPUT);
            ClearKeyStateToggle(pti->pq, VK_DBE_NOCODEINPUT);
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_NOCODEINPUT);
            SetKeyStateToggle( pti->pq, VK_DBE_NOCODEINPUT);
            ClearKeyStateDown(pti->pq, VK_DBE_CODEINPUT);
            ClearKeyStateToggle(pti->pq, VK_DBE_CODEINPUT);
        }
        break;

    case LANG_KOREAN:
        if ( dwConversion & IME_CMODE_NATIVE) {
            SetKeyStateToggle( pti->pq, VK_HANGUL);
        } else {
            ClearKeyStateToggle( pti->pq, VK_HANGUL);
        }

        if ( dwConversion & IME_CMODE_FULLSHAPE ) {
            SetKeyStateToggle( pti->pq, VK_JUNJA);
        } else {
            ClearKeyStateToggle( pti->pq, VK_JUNJA);
        }

        if ( dwConversion & IME_CMODE_HANJACONVERT ) {
            SetKeyStateToggle( pti->pq, VK_HANJA);
        } else {
            ClearKeyStateToggle( pti->pq, VK_HANJA);
        }
        break;

    default:
        break;
    }
    return;
}

//
// called by IMM32 client when:
//
//      input focus is switched
//   or IME open status is changed
//   or IME conversion status is changed
//
//
VOID xxxNotifyIMEStatus(
                       IN PWND pwnd,
                       IN DWORD dwOpen,
                       IN DWORD dwConversion )
{
    PTHREADINFO pti;

    CheckLock(pwnd);

    if ( (pti = GETPTI(pwnd)) != NULL && gptiForeground != NULL ) {
        if ( pti == gptiForeground || pti->pq == gptiForeground->pq ) {

            if ( gHimcFocus != pwnd->hImc   ||
                 gdwIMEOpenStatus != dwOpen ||
                 gdwIMEConversionStatus != dwConversion ) {

                //
                // save the new status
                //
                gHimcFocus = pwnd->hImc;
                if ( gHimcFocus != (HIMC)NULL ) {

                    RIPMSG2(RIP_VERBOSE, "xxxNotifyIMEStatus: newOpen=%x newConv=%x",
                            dwOpen, dwConversion);
                    gdwIMEOpenStatus = dwOpen;
                    gdwIMEConversionStatus = dwConversion;

                    //
                    // set keyboard states that are related to IME conversion status
                    //
                    SetConvMode(pti, dwOpen ? dwConversion : 0);
                }

                //
                // notify shell the IME status change
                //
                // Implementation note: [takaok 9/5/96]
                //
                // Using HSHELL_LANGUAGE is not the best way to inform shell
                // IME status change because we didn't change the keyboard layout.
                // ( The spec says HSHELL_LANGUAGE is for keyboard layout change.
                //  Also passing window handle as WPARAM is not documented )
                //
                // This is same as what Win95 does. I won't change this for now
                // because in the future shell will be developed by a different
                // group in MS.
                //
                // Currently only Korean Windows is interested in getting
                // the conversion status change.
                //
                if (IsHooked(pti, WHF_SHELL)) {
                    HKL hkl = NULL;

                    if (pti->spklActive != NULL) {
                        hkl = pti->spklActive->hkl;
                    }
                    xxxCallHook(HSHELL_LANGUAGE, (WPARAM)HWq(pwnd), (LPARAM)hkl, WH_SHELL);
                }

                //
                // notify keyboard driver
                //
                NlsKbdSendIMENotification(dwOpen,dwConversion);
            }
        }
    }
}

//---------------------------------------------------------------------------
//
// xxxCheckImeShowStatus() -
//
// Only one Status Window should be shown in the System.
// This functsion enums all IME window and check the show status of them.
//
// If pti is NULL, check all toplevel windows regardless their owners.
// If pti is not NULL, check only windows belong to the thread.
//
//----------------------------------------------------------------------------

BOOL xxxCheckImeShowStatus(PWND pwndIme, PTHREADINFO pti)
{
    PBWL pbwl;
    PHWND phwnd;
    BOOL fRet = FALSE;
    PTHREADINFO ptiCurrent = PtiCurrent();

    if (TestWF(pwndIme, WFINDESTROY)) {
        return FALSE;
    }

    // Parent window of IME window should be the desktop window
    UserAssert(pwndIme);
    UserAssert(pwndIme->spwndParent == GETPTI(pwndIme)->pDeskInfo->spwnd);

    pbwl = BuildHwndList(pwndIme->spwndParent->spwndChild, BWL_ENUMLIST, NULL);
    if (pbwl != NULL) {
        fRet = TRUE;
        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
            PWND pwndT = RevalidateHwnd(*phwnd);

            // If pwndT is the current active IME window, we should skip it
            // since it's the only one window allowed to show status, and
            // we've already taken care of it.
            if (pwndT == NULL || (/*pwndIme && */pwndIme == pwndT)) {   // Can skip pwndIme != NULL test
                continue;
            }

            // We are going to touch IME windows only
            if (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME] &&
                    !TestWF(pwndT, WFINDESTROY)) {

                PIMEUI pimeui = ((PIMEWND)pwndT)->pimeui;

                if (pimeui == NULL || pimeui == (PIMEUI)-1) {
                    continue;
                }

                if (pti == NULL || pti == GETPTI(pwndT)) {
                    BOOLEAN fAttached = FALSE;
                    PWND    pwndIMC;

                    // If pwndT is not a window of the current process, we have to138163
                    // attach the process to get access to pimeui.
                    if (GETPTI(pwndT)->ppi != ptiCurrent->ppi) {
                        RIPMSG0(RIP_VERBOSE, "Attaching process in xxxCheckImeShowStatus");
                        KeAttachProcess(PsGetProcessPcb(GETPTI(pwndT)->ppi->Process));
                        fAttached = TRUE;
                    }

                    try {
                        if (ProbeAndReadStructure(pimeui, IMEUI).fShowStatus) {
                            if (pti == NULL) {
                                RIPMSG0(RIP_VERBOSE, "xxxCheckImeShowStatus: the status window is shown !!");
                            }
                            if ((pwndIMC = RevalidateHwnd(pimeui->hwndIMC)) != NULL) {
                                pimeui->fShowStatus = FALSE;
                            }
                        } else {
                            pwndIMC = NULL;
                        }

                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                          pwndIMC = NULL;
                    }
                    if (fAttached) {
                        KeDetachProcess();
                    }

                    if (pwndIMC && GETPTI(pwndIMC) && !(GETPTI(pwndIMC)->TIF_flags & TIF_INCLEANUP)) {
                        TL tl;

                        ThreadLockAlways(pwndIMC, &tl);
                        RIPMSG1(RIP_VERBOSE, "Sending WM_IME_NOTIFY to %#p, IMN_CLOSESTATUSWINDOW", pwndIMC);
                        xxxSendMessage(pwndIMC, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0L);
                        ThreadUnlock(&tl);
                    }

                }
            }
        }
        FreeHwndList(pbwl);
    }
    return fRet;
}

LRESULT xxxSendMessageToUI(
    PTHREADINFO ptiIme,
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND  pwndUI;
    LRESULT lRet = 0L;
    TL    tl;
    BOOL  fAttached = FALSE;

    CheckCritIn();

    if (ptiIme != PtiCurrent()) {
        fAttached = TRUE;
        KeAttachProcess(PsGetProcessPcb(ptiIme->ppi->Process));
    }

    try {
        pwndUI = RevalidateHwnd(ProbeAndReadStructure(pimeui, IMEUI).hwndUI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        pwndUI = NULL;
    }

    if (pwndUI != NULL){
        try {
            ProbeAndReadUlong((PULONG)&pimeui->nCntInIMEProc);
            InterlockedIncrement(&pimeui->nCntInIMEProc);   // Mark to avoid recursion.
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              goto skip_it;
        }
        if (fAttached) {
            KeDetachProcess();
        }

        ThreadLockAlways(pwndUI, &tl);
        RIPMSG3(RIP_VERBOSE, "Sending message UI pwnd=%#p, msg:%x to wParam=%#p", pwndUI, message, wParam);
        lRet = xxxSendMessage(pwndUI, message, wParam, lParam);
        ThreadUnlock(&tl);

        if (fAttached) {
            KeAttachProcess(PsGetProcessPcb(ptiIme->ppi->Process));
        }
        try {
            InterlockedDecrement(&pimeui->nCntInIMEProc);   // Mark to avoid recursion.
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
    }
skip_it:
    if (fAttached) {
        KeDetachProcess();
    }

    return lRet;
}

VOID xxxSendOpenStatusNotify(
    PTHREADINFO ptiIme,
    PIMEUI pimeui,
    PWND   pwndApp,
    BOOL   fOpen)
{
    WPARAM wParam = fOpen ? IMN_OPENSTATUSWINDOW : IMN_CLOSESTATUSWINDOW;

    UserAssert(GETPTI(pwndApp));

    if (LOWORD(GETPTI(pwndApp)->dwExpWinVer >= VER40) && pwndApp->hImc != NULL) {
        TL tl;
        ThreadLockAlways(pwndApp, &tl);
        RIPMSG2(RIP_VERBOSE, "Sending %s to pwnd=%#p",
                fOpen ? "IMN_OPENSTATUSWINDOW" : "IMN_CLOSESTATUSWINDOW",
                pwndApp);
        xxxSendMessage(pwndApp, WM_IME_NOTIFY, wParam, 0L);
        ThreadUnlock(&tl);
    }
    else {
        xxxSendMessageToUI(ptiIme, pimeui, WM_IME_NOTIFY, wParam, 0L);
    }

    return;
}

VOID xxxNotifyImeShowStatus(PWND pwndIme)
{
    PIMEUI pimeui;
    BOOL fShow;
    PWND pwnd;
    PTHREADINFO ptiIme, ptiCurrent;
    BOOL fSendOpenStatusNotify = FALSE;

    if (!IS_IME_ENABLED() || TestWF(pwndIme, WFINDESTROY)) {
        RIPMSG0(RIP_WARNING, "IME is not enabled or in destroy.");
        return;
    }

    ptiCurrent = PtiCurrent();
    ptiIme = GETPTI(pwndIme);

    if (ptiIme != ptiCurrent) {
        RIPMSG1(RIP_VERBOSE, "Attaching pti=%#p", ptiIme);
        KeAttachProcess(PsGetProcessPcb(GETPTI(pwndIme)->ppi->Process));
    }

    try {
        pimeui = ((PIMEWND)pwndIme)->pimeui;
        fShow = gfIMEShowStatus && ProbeAndReadStructure(pimeui, IMEUI).fCtrlShowStatus;

        pwnd = RevalidateHwnd(pimeui->hwndIMC);

        if (pwnd != NULL || (pwnd = GETPTI(pwndIme)->pq->spwndFocus) != NULL) {
            RIPMSG0(RIP_VERBOSE, "Setting new show status.");
            fSendOpenStatusNotify = TRUE;
            pimeui->fShowStatus = fShow;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          if (ptiIme != ptiCurrent) {
              KeDetachProcess();
          }
          return;
    }
    if (ptiIme != ptiCurrent) {
        KeDetachProcess();
    }

    if (fSendOpenStatusNotify) {
        RIPMSG1(RIP_VERBOSE, "Sending OpenStatus fShow=%d", fShow);
        xxxSendOpenStatusNotify(ptiIme, pimeui, pwnd, fShow);
    }

    // Check the show status of all IME windows in the system.
    if (!TestWF(pwndIme, WFINDESTROY)) {
        xxxCheckImeShowStatus(pwndIme, NULL);
    }
}


/***************************************************************************\
* xxxSetIMEShowStatus() -
*
* Set IME Status windows' show status. Called from SystemParametersInfo()
* handler.
*
\***************************************************************************/

BOOL xxxSetIMEShowStatus(IN BOOL fShow)
{
    CheckCritIn();

    UserAssert(fShow == FALSE || fShow == TRUE);

    if (gfIMEShowStatus == fShow) {
        return TRUE;
    }

    if (gfIMEShowStatus == IMESHOWSTATUS_NOTINITIALIZED) {
        /*
         * Called for the first time after logon.
         * No need to write the value to the registry.
         */
        gfIMEShowStatus = fShow;
    }
    else {
        /*
         * We need to save the new fShow status to the registry.
         */
        TL tlName;
        PUNICODE_STRING pProfileUserName;
        BOOL fOK = FALSE;

        pProfileUserName = CreateProfileUserName(&tlName);
        if (pProfileUserName) {
            UserAssert(pProfileUserName != NULL);
            fOK = UpdateWinIniInt(pProfileUserName, PMAP_INPUTMETHOD, STR_SHOWIMESTATUS, fShow);
            FreeProfileUserName(pProfileUserName, &tlName);
        }
        if (!fOK) {
            return FALSE;
        }
        gfIMEShowStatus = fShow;
    }

    /*
     * If IME is not enabled, further processing is not needed
     */
    if (!IS_IME_ENABLED()) {
        return TRUE;
    }

    /*
     * Let the current active IME window know the change.
     */
    if (gpqForeground && gpqForeground->spwndFocus) {
        PTHREADINFO ptiFocus = GETPTI(gpqForeground->spwndFocus);
        TL tl;

        UserAssert(ptiFocus);

        if (ptiFocus->spwndDefaultIme && !(ptiFocus->TIF_flags & TIF_INCLEANUP)) {
            ThreadLockAlways(ptiFocus->spwndDefaultIme, &tl);
            xxxNotifyImeShowStatus(ptiFocus->spwndDefaultIme);
            ThreadUnlock(&tl);
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxBroadcastImeShowStatusChange() -
*
* Let all IME windows in the desktop, including myself  know about the
* status change.
* This routine does not touch the registry, assuming internat.exe updated
* the registry.
*
\***************************************************************************/

VOID xxxBroadcastImeShowStatusChange(PWND pwndIme, BOOL fShow)
{
    CheckCritIn();

    gfIMEShowStatus = !!fShow;
    xxxNotifyImeShowStatus(pwndIme);
}

/***************************************************************************\
* xxxCheckImeShowStatusInThread() -
*
* Let all IME windows in the same thread know about the status change.
* Called from ImeSetContextHandler().
*
\***************************************************************************/
VOID xxxCheckImeShowStatusInThread(PWND pwndIme)
{
    if (IS_IME_ENABLED()) {
        UserAssert(pwndIme);

        if (!TestWF(pwndIme, WFINDESTROY)) {
            xxxCheckImeShowStatus(pwndIme, GETPTI(pwndIme));
        }
    }
}

BOOL _GetIMEShowStatus(VOID)
{
    return gfIMEShowStatus != FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ntinput.c ===
/****************************** Module Header ******************************\
* Module Name: ntinput.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains low-level input code specific to the NT
* implementation of Win32 USER, which is mostly the interfaces to the
* keyboard and mouse device drivers.
*
* History:
* 11-26-90 DavidPe      Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <ntddmou.h>


PKWAIT_BLOCK  gWaitBlockArray;

KEYBOARD_UNIT_ID_PARAMETER kuid;
MOUSE_UNIT_ID_PARAMETER muid;

typedef struct tagSCANCODEFLEXIBLEMAP {
    struct {
        BYTE bScanCode;
        BYTE bPrefix;
        BYTE abModifiers[6];
    } Orig;
    struct {
        BYTE bScanCode;
        BYTE bPrefix;
        BYTE abModifiers[6];
    } Target;
} SCANCODEFLEXIBLEMAP, FAR *LPSCANCODEFLEXIBLEMAP;

BYTE bLastVKDown = 0;
int iLastMatchedTarget = -1;


SCANCODEFLEXIBLEMAP* gpFlexMap;
DWORD gdwFlexMapSize;



VOID ProcessQueuedMouseEvents(VOID);
#ifndef SUBPIXEL_MOUSE
LONG DoMouseAccel(LONG delta);
#endif
VOID GetMouseCoord(LONG dx, LONG dy, DWORD dwFlags, LONG time, ULONG_PTR ExtraInfo, PPOINT ppt);
VOID xxxMoveEventAbsolute(LONG x, LONG y, ULONG_PTR dwExtraInfo,
#ifdef GENERIC_INPUT
            HANDLE hDevice,
            PMOUSE_INPUT_DATA pmei,
#endif
            DWORD time,
            BOOL bInjected);

VOID ProcessKeyboardInputWorker(PKEYBOARD_INPUT_DATA pkei,
#ifdef GENERIC_INPUT
                                PDEVICEINFO pDeviceInfo,
#endif
                                BOOL fProcessRemap);


INT  idxRemainder, idyRemainder;

BYTE gbVKLastDown;

/*
 * Mouse/Kbd diagnostics for #136483 etc. Remove when PNP is stable (IanJa)
 */
#ifdef DIAGNOSE_IO
ULONG    gMouseProcessMiceInputTime = 0;  // tick at start of ProcessMiceInput
ULONG    gMouseQueueMouseEventTime = 0;   // tick at start of QueueMouseEvent
ULONG    gMouseUnqueueMouseEventTime = 0; // tick at start of UnqueueMouseEvent

// Return a value as close as possible to the system's tick count,
// yet guaranteed to be larger than the value returned last time.
// (useful for sequencing events)
// BUG: when NtGetTickCount overflows, the value returned by MonotonicTick
// will not track system tick count well: instead it will increase by one
// each time until it too overflows. (considerd harmless for IO DIAGNOSTICS)
ULONG MonotonicTick()
{
    static ULONG lasttick = 0;
    ULONG newtick;

    newtick = NtGetTickCount();
    if (newtick > lasttick) {
        lasttick = newtick;  // use the new tick since it is larger
    } else {
        lasttick++;          // artificially bump the tick up one.
    }
    return lasttick;
}

#endif

/*
 * Parameter Constants for xxxButtonEvent()
 */
#define MOUSE_BUTTON_LEFT   0x0001
#define MOUSE_BUTTON_RIGHT  0x0002
#define MOUSE_BUTTON_MIDDLE 0x0004
#define MOUSE_BUTTON_X1     0x0008
#define MOUSE_BUTTON_X2     0x0010

#define ID_INPUT       0
#define ID_MOUSE       1

#define ID_TIMER       2
#define ID_HIDCHANGE   3
#define ID_SHUTDOWN    4

#ifdef GENERIC_INPUT
#define ID_TRUEHIDCHANGE                5
#define ID_WDTIMER                      6
#define ID_NUMBER_HYDRA_REMOTE_HANDLES  7
#else   // GENERIC_INPUT
#define ID_WDTIMER                      5
#define ID_NUMBER_HYDRA_REMOTE_HANDLES  6
#endif  // GENERIC_INPUT

PKTIMER gptmrWD;

PVOID *apObjects;


/***************************************************************************\
* fAbsoluteMouse
*
* Returns TRUE if the mouse event has absolute coordinates (as apposed to the
* standard delta values we get from MS and PS2 mice)
*
* History:
* 23-Jul-1992 JonPa     Created.
\***************************************************************************/
#define fAbsoluteMouse( pmei )      \
        (((pmei)->Flags & MOUSE_MOVE_ABSOLUTE) != 0)

/***************************************************************************\
* ConvertToMouseDriverFlags
*
* Converts SendInput kind of flags to mouse driver flags as GetMouseCoord
* needs them.
* As mouse inputs are more frequent than send inputs, we penalize the later.
*
* History:
* 17-dec-1997 MCostea     Created.
\***************************************************************************/
#if ((MOUSEEVENTF_ABSOLUTE >> 15) ^ MOUSE_MOVE_ABSOLUTE) || \
    ((MOUSEEVENTF_VIRTUALDESK >> 13) ^ MOUSE_VIRTUAL_DESKTOP)
#   error("Bit mapping broken: fix ConvertToMouseDriverFlags")
#endif

#define ConvertToMouseDriverFlags( Flags )      \
        (((Flags) & MOUSEEVENTF_ABSOLUTE) >> 15 | \
         ((Flags) & MOUSEEVENTF_VIRTUALDESK) >> 13)

#define VKTOMODIFIERS(Vk) ((((Vk) >= VK_SHIFT) && ((Vk) <= VK_MENU)) ? \
                           (MOD_SHIFT >> ((Vk) - VK_SHIFT)) :           \
                           0)
#if (VKTOMODIFIERS(VK_SHIFT) != MOD_SHIFT) || \
    (VKTOMODIFIERS(VK_CONTROL) != MOD_CONTROL) || \
    (VKTOMODIFIERS(VK_MENU) != MOD_ALT)
#   error("VKTOMODIFIERS broken")
#endif


/***************************************************************************\
* xxxInitInput
*
* This function is called from CreateTerminalInput() and gets USER setup to
* process keyboard and mouse input.  It starts the RIT for that terminal.
* History:
* 11-26-90 DavidPe      Created.
\***************************************************************************/
BOOL xxxInitInput(
    PTERMINAL pTerm)
{
    NTSTATUS Status;
    USER_API_MSG m;
    RIT_INIT initData;

UserAssert(pTerm != NULL);

#ifdef MOUSE_LOCK_CODE
    /*
     * Lock RIT pages into memory
     */
    LockMouseInputCodePages();
#endif

    initData.pTerm = pTerm;
    initData.pRitReadyEvent = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (initData.pRitReadyEvent == NULL) {
        return FALSE;
    }
    /*
     * Create the RIT and let it run.
     */

    if (!InitCreateSystemThreadsMsg(&m, CST_RIT, &initData, 0, FALSE)) {
        FreeKernelEvent(&initData.pRitReadyEvent);
        return FALSE;
    }
    /*
     * Be sure that we are not in CSRSS context.
     * WARNING: If for any reason we changed this to run in CSRSS context then we have to use
     * LpcRequestPort instead of LpcRequestWaitReplyPort.
     */
    UserAssert (!ISCSRSS());

    LeaveCrit();
    Status = LpcRequestWaitReplyPort(CsrApiPort, (PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    KeWaitForSingleObject(initData.pRitReadyEvent, WrUserRequest,
            KernelMode, FALSE, NULL);
Exit:
    FreeKernelEvent(&initData.pRitReadyEvent);
    EnterCrit();

    return (gptiRit != NULL);
}


/***************************************************************************\
* InitScancodeMap
*
* Fetches the scancode map from the registry, allocating space as required.
*
* A scancode map is used to convert unusual OEM scancodes into standard
* "Scan Code Set 1" values.  This is to support KB3270 keyboards, but can
* be used for other types too.
*
* History:
* 96-04-18 IanJa      Created.
\***************************************************************************/



const WCHAR gwszScancodeMap[] = L"Scancode Map";
const WCHAR gwszScancodeMapEx[] = L"Scancode Map Ex";


VOID InitScancodeMap(
    PUNICODE_STRING pProfileName)
{
    DWORD dwBytes;
    UINT idSection;
    PUNICODE_STRING pPN;
    LPBYTE pb;

    TAGMSG2(DBGTAG_KBD, "InitScancodeMap with pProfileName=%#p, \"%S\"", pProfileName,
            pProfileName ? pProfileName->Buffer : L"");

    if (gpScancodeMap) {
        UserFreePool(gpScancodeMap);
        gpScancodeMap = NULL;
    }

    /*
     * Read basic scancode mapping information.
     * Firstly try per user, and then per system.
     */
    idSection = PMAP_UKBDLAYOUT;
    pPN = pProfileName;
    dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMap, NULL, NULL, 0, 0);
    if (dwBytes == 0) {
        idSection = PMAP_KBDLAYOUT;
        pPN = NULL;
        dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMap, NULL, NULL, 0, 0);
    }
    if (dwBytes > sizeof(SCANCODEMAP)) {
        pb = UserAllocPoolZInit(dwBytes, TAG_SCANCODEMAP);
        if (pb) {
            dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMap, NULL, pb, dwBytes, 0);
            gpScancodeMap = (SCANCODEMAP*)pb;
        }
    }

    /*
     * Read extended scancode mapping information.
     * Firstly try per user, then per system.
     */
    if (gpFlexMap) {
        UserFreePool(gpFlexMap);
        gpFlexMap = NULL;
        gdwFlexMapSize = 0;
    }

    idSection = PMAP_UKBDLAYOUT;
    pPN = pProfileName;
    dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMapEx, NULL, NULL, 0, 0);
    if (dwBytes == 0) {
        TAGMSG0(DBGTAG_KBD, "InitScancodeMap: mapex is not in per-user profile. will use the system's");
        idSection = PMAP_KBDLAYOUT;
        pPN = NULL;
        dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMapEx, NULL, NULL, 0, 0);
    }
    if (dwBytes >= sizeof(SCANCODEFLEXIBLEMAP) && dwBytes % sizeof(SCANCODEFLEXIBLEMAP) == 0) {
        if ((pb = UserAllocPoolZInit(dwBytes, TAG_SCANCODEMAP)) != NULL) {
            dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMapEx, NULL, pb, dwBytes, 0);
            gpFlexMap = (SCANCODEFLEXIBLEMAP*)pb;
            gdwFlexMapSize = dwBytes / sizeof(SCANCODEFLEXIBLEMAP);
        }
    }
#if DBG
    else if (dwBytes != 0) {
        TAGMSG1(DBGTAG_KBD, "InitScancodeMap: incorrect dwSize(0x%x) specified.", dwBytes);
    }
#endif
}

/***************************************************************************\
* MapScancode
*
* Converts a scancode (and it's prefix, if any) to a different scancode
* and prefix.
*
* Parameters:
*   pbScanCode = address of Scancode byte, the scancode may be changed
*   pbPrefix   = address of Prefix byte, The prefix may be changed
*
* Return value:
*   TRUE  - mapping was found, scancode was altered.
*   FALSE - no mapping found, scancode was not altered.
*
* Note on scancode map table format:
*     A table entry DWORD of 0xE0450075 means scancode 0x45, prefix 0xE0
*     gets mapped to scancode 0x75, no prefix
*
* History:
* 96-04-18 IanJa      Created.
\***************************************************************************/

PKBDTABLES GetCurrentKbdTables()
{
    PKBDTABLES pKbdTbl;
    PTHREADINFO pti;

    CheckCritIn();
    if (gpqForeground == NULL) {
        TAGMSG0(DBGTAG_KBD, "GetCurrentKbdTables: NULL gpqForeground\n");
        return NULL;
    }

    pti = PtiKbdFromQ(gpqForeground);
    UserAssert(pti);
    if (pti->spklActive) {
        pKbdTbl = pti->spklActive->spkf->pKbdTbl;
    } else {
        RIPMSG0(RIP_WARNING, "SendKeyUpDown: NULL spklActive\n");
        pKbdTbl = gpKbdTbl;
    }
    UserAssert(pKbdTbl);

    return pKbdTbl;
}

VOID SendKeyUpDown(
    CONST BYTE bVK,
    CONST BOOLEAN fBreak)
{
    KE ke;
    PKBDTABLES pKbdTbl;

    CheckCritIn();

    ke.dwTime = 0;
    ke.usFlaggedVk = bVK | KBDMAPPEDVK;
    if (fBreak) {
        ke.usFlaggedVk |= KBDBREAK;
    }

    //
    // If scancode is not specified (==0), we need to
    // find the scancode value from the virtual key code.
    //
    pKbdTbl = GetCurrentKbdTables();
    if (pKbdTbl) {
        ke.bScanCode = (BYTE)InternalMapVirtualKeyEx(bVK, 0, pKbdTbl);
    }

    TAGMSG1(DBGTAG_KBD, "Sending Key for VK=%04x", ke.usFlaggedVk);

    xxxProcessKeyEvent(&ke, 0, TRUE);
}

__inline VOID SendKeyDown(
    CONST BYTE bVK)
{
    SendKeyUpDown(bVK, FALSE);
}

__inline VOID SendKeyUp(
    CONST BYTE bVK)
{
    SendKeyUpDown(bVK, TRUE);
}

BOOL IsKeyDownSpecified(CONST BYTE bVK, CONST BYTE* pbMod)
{
    int i;

    for (i = 0; i < sizeof((SCANCODEFLEXIBLEMAP*)NULL)->Orig.abModifiers && pbMod[i]; ++i) {
        if (bVK == pbMod[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL MapFlexibleKeys(PKE pke, CONST BYTE bPrefix
#ifdef GENERIC_INPUT
                     , PDEVICEINFO pDeviceInfo
#endif
                     )
{
    UINT i;
    static const BYTE abModifiers[] = {
        VK_LCONTROL,    VK_RCONTROL,
        VK_LSHIFT,      VK_RSHIFT,
        VK_LMENU,       VK_RMENU,
        VK_LWIN,        VK_RWIN,
        VK_APPS,        VK_CAPITAL,
    };

    for (i = 0; i < gdwFlexMapSize; ++i) {
        if (gpFlexMap[i].Orig.bPrefix == bPrefix && gpFlexMap[i].Orig.bScanCode == pke->bScanCode) {
            UINT j;

            if ((pke->usFlaggedVk & KBDBREAK) && i == (UINT)iLastMatchedTarget) {
                //
                // If this is a keyup event, and if it matches the last substituted
                // key, we want to send keyup event right away.
                //
                iLastMatchedTarget = -1;
                break;
            }

            for (j = 0; j < ARRAY_SIZE(abModifiers); ++j) {
                BYTE bVK = abModifiers[j];

                if (bVK == bLastVKDown) {
                    //
                    // Ignore the key if it's previously substituted by us.
                    //
                    bLastVKDown = 0;
                    continue;
                }
                if (!TestKeyDownBit(gafRawKeyState, bVK) == IsKeyDownSpecified(bVK, gpFlexMap[i].Orig.abModifiers)) {
                    TAGMSG1(DBGTAG_KBD, "MapFlexibleKeys: not match by vk=%02x", bVK);
                    // No match!
                    break;
                }
            }

            if (j >= ARRAY_SIZE(abModifiers)) {
                // We found the match. Now break the loop.
                TAGMSG1(DBGTAG_KBD, "MapFlexibleKeys: found a match for sc=%02x", gpFlexMap[i].Orig.bScanCode);
                break;
            }
        }
    }

    if (i < gdwFlexMapSize) {
        KEYBOARD_INPUT_DATA kei;
        UINT j, nUp = 0, nDown = 0;
        BYTE bVKModUp[ARRAY_SIZE(((SCANCODEFLEXIBLEMAP*)NULL)->Orig.abModifiers)];
        BYTE bVKModDown[ARRAY_SIZE(((SCANCODEFLEXIBLEMAP*)NULL)->Target.abModifiers)];

        // We found it.
        // Yes, this key.
        TAGMSG3(DBGTAG_KBD, "MapFlexibleKeys: found a match %d (prefix=%x, sc=%x).", i, gpFlexMap[i].Orig.bPrefix, gpFlexMap[i].Orig.bScanCode);

        //
        // If this is a keydown event, we want to simulate
        // the modifier keys.
        //
        if ((pke->usFlaggedVk & KBDBREAK) == 0) {
            //
            // Now we need to adjust the down state of the modifieres, which is currently
            // pressed but not specified in the substitute.
            // For instance, if CTRL key is pressed now, but if CTRL is not specified in the substitute
            // modifiers list, we need to make an artificial keyup so that we'll be able to fake the
            // situation. Of cource, we need to push CTRL key after we finish remapping.
            //
            for (j = 0; j < ARRAY_SIZE(gpFlexMap[i].Orig.abModifiers) && gpFlexMap[i].Orig.abModifiers[j]; ++j) {
                if (!IsKeyDownSpecified(gpFlexMap[i].Orig.abModifiers[j], gpFlexMap[i].Target.abModifiers)) {
                    //
                    // We need to send UP key for this one.
                    //
                    bVKModUp[nUp++] = gpFlexMap[i].Orig.abModifiers[j];
                    SendKeyUp(gpFlexMap[i].Orig.abModifiers[j]);
                }
            }
            for (j = 0; j < ARRAY_SIZE(gpFlexMap[i].Target.abModifiers) && gpFlexMap[i].Target.abModifiers[i]; ++j) {
                if (!IsKeyDownSpecified(gpFlexMap[i].Target.abModifiers[j], gpFlexMap[i].Orig.abModifiers)) {
                    //
                    // We need to send DOWN key for this one.
                    //
                    bVKModDown[nDown++] = gpFlexMap[i].Target.abModifiers[j];
                    SendKeyDown(gpFlexMap[i].Target.abModifiers[j]);
                }
            }
        }

        //
        // Now we are ready to send the substituted key.
        //
        kei.ExtraInformation = 0;
        kei.Flags = 0;
        if (gpFlexMap[i].Target.bPrefix == 0xE0) {
            kei.Flags |= KEY_E0;
        } else if (gpFlexMap[i].Target.bPrefix == 0xE1) {
            kei.Flags |= KEY_E1;
        }
        if (pke->usFlaggedVk & KBDBREAK) {
            kei.Flags |= KEY_BREAK;
        }
        kei.MakeCode = gpFlexMap[i].Target.bScanCode;

        kei.UnitId = 0; // LATER:

        TAGMSG2(DBGTAG_KBD, "MapFlexibleKeys: injecting sc=%02x (flag=%x)",
                kei.MakeCode, kei.Flags);

        ProcessKeyboardInputWorker(&kei,
#ifdef GENERIC_INPUT
                                   pDeviceInfo,
#endif
                                   FALSE);

        if ((pke->usFlaggedVk & KBDBREAK) == 0) {
            //
            // Remember the last down key generated by me.
            // This will be used when matching the UP key.
            //
            bLastVKDown = gbVKLastDown;
            iLastMatchedTarget = i;
        }


        //
        // Restore the orignial modifier state.
        //
        for (j = 0; j < nUp; ++j) {
            SendKeyDown(bVKModUp[j]);
        }
        for (j = 0; j < nDown; ++j) {
            SendKeyUp(bVKModDown[j]);
        }

        //
        // Tell the caller we processed this key. The caller should
        // not continue handling this key if this function returns FALSE.
        //
        return FALSE;
    }

    return TRUE;
}

BOOL
MapScancode(
    PKE pke,
    PBYTE pbPrefix
#ifdef GENERIC_INPUT
    ,
    PDEVICEINFO pDeviceInfo
#endif
    )
{
    if (gpScancodeMap) {
        DWORD *pdw;
        WORD wT = MAKEWORD(pke->bScanCode, *pbPrefix);

        CheckCritIn();
        UserAssert(gpScancodeMap != NULL);

        for (pdw = &(gpScancodeMap->dwMap[0]); *pdw; pdw++) {
            if (HIWORD(*pdw) == wT) {
                wT = LOWORD(*pdw);
                pke->bScanCode = LOBYTE(wT);
                *pbPrefix = HIBYTE(wT);
                break;
            }
        }
    }

    return IsRemoteConnection() ||
        MapFlexibleKeys(pke, *pbPrefix
#ifdef GENERIC_INPUT
                           , pDeviceInfo
#endif
                           );
}



/***************************************************************************\
* InitMice
*
* This function initializes the data and settings before we start enumerating
* the mice.
*
* History:
* 11-18-97 IanJa      Created.
\***************************************************************************/

VOID InitMice()
{
    CLEAR_ACCF(ACCF_MKVIRTUALMOUSE);
    CLEAR_GTERMF(GTERMF_MOUSE);
    SYSMET(MOUSEPRESENT) = FALSE;
    SYSMET(CMOUSEBUTTONS) = 0;
    SYSMET(MOUSEWHEELPRESENT) = FALSE;
}

/***************************************************************************\
* FreeDeviceInfo
*
* Unlinks a DEVICEINFO struct from the gpDeviceInfoList list and frees the
* allocated memory UNLESS the device is actively being read (GDIF_READING) or
* has a PnP thread waiting for it in RequestDeviceChange() (GDIAF_PNPWAITING)
* If the latter, then wake the PnP thread via pkeHidChangeCompleted so that it
* can free the structure itself.
*
* Returns a pointer to the next DEVICEINFO struct, or NULL if the device was
* not found in the gpDeviceInfoList.
*
* History:
* 11-18-97 IanJa      Created.
\***************************************************************************/
PDEVICEINFO FreeDeviceInfo(PDEVICEINFO pDeviceInfo)
{
    PDEVICEINFO *ppDeviceInfo;

    CheckDeviceInfoListCritIn();

    TAGMSG1(DBGTAG_PNP, "FreeDeviceInfo(%#p)", pDeviceInfo);

    /*
     * We cannot free the device since we still have a read pending.
     * Mark it GDIAF_FREEME so that it will be freed when the APC is made
     * (see InputApc), or when the next read request is about to be issued
     * (see StartDeviceRead).
     */
    if (pDeviceInfo->bFlags & GDIF_READING) {
#if DIAGNOSE_IO
        pDeviceInfo->bFlags |= GDIF_READERMUSTFREE;
#endif
        TAGMSG1(DBGTAG_PNP, "** FreeDeviceInfo(%#p) DEFERRED : reader must free", pDeviceInfo);
        pDeviceInfo->usActions |= GDIAF_FREEME;
#ifdef TRACK_PNP_NOTIFICATION
        if (gfRecordPnpNotification) {
            RecordPnpNotification(PNP_NTF_FREEDEVICEINFO_DEFERRED, pDeviceInfo, pDeviceInfo->usActions);
        }
#endif
        return pDeviceInfo->pNext;
    }

    /*
     * If a PnP thread is waiting in RequestDeviceChange for some action to be
     * performed on this device, just mark it for freeing and signal that PnP
     * thread with the pkeHidChangeCompleted so that it will free it
     */
#ifdef GENERIC_INPUT
    /*
     * Now that pDeviceInfo is handle based, if we don't own the user critical section.
     * we mark it to be freed later on and have to bail out,
     */
    if ((pDeviceInfo->usActions & GDIAF_PNPWAITING) || !ExIsResourceAcquiredExclusiveLite(gpresUser))
#else
    if (pDeviceInfo->usActions & GDIAF_PNPWAITING)
#endif
    {
#if DIAGNOSE_IO
        pDeviceInfo->bFlags |= GDIF_PNPMUSTFREE;
#endif
        TAGMSG1(DBGTAG_PNP, "** FreeDeviceInfo(%#p) DEFERRED : PnP must free", pDeviceInfo);
        pDeviceInfo->usActions |= GDIAF_FREEME;
        KeSetEvent(pDeviceInfo->pkeHidChangeCompleted, EVENT_INCREMENT, FALSE);
        return pDeviceInfo->pNext;
    }

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_FREEDEVICEINFO, pDeviceInfo, pDeviceInfo->usActions);
    }
#endif


#ifdef GENERIC_INPUT
    CheckCritIn();
#endif

    ppDeviceInfo = &gpDeviceInfoList;

    while (*ppDeviceInfo) {
        if (*ppDeviceInfo == pDeviceInfo
#ifdef GENERIC_INPUT
            && HMMarkObjectDestroy(pDeviceInfo)
#endif
            ) {
            /*
             * Found the DEVICEINFO struct, so free it and its members.
             */
            if (pDeviceInfo->pkeHidChangeCompleted != NULL) {
                // N.b. the timing could be pretty critical around this
                FreeKernelEvent(&pDeviceInfo->pkeHidChangeCompleted);
            }
            if (pDeviceInfo->ustrName.Buffer != NULL) {
                UserFreePool(pDeviceInfo->ustrName.Buffer);
            }
#ifdef GENERIC_INPUT
            if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                CheckCritIn();
                /*
                 * Unlock the device request list
                 */
                UserAssert(pDeviceInfo->hid.pTLCInfo);
                if (--pDeviceInfo->hid.pTLCInfo->cDevices == 0) {
                    if (!HidTLCActive(pDeviceInfo->hid.pTLCInfo)) {
                        // Nobody is interested in this device anymore
                        FreeHidTLCInfo(pDeviceInfo->hid.pTLCInfo);
                    }
                }
                /*
                 * Unlock the HID descriptor
                 */
                UserAssert(pDeviceInfo->hid.pHidDesc);
                FreeHidDesc(pDeviceInfo->hid.pHidDesc);
            }
#endif

            *ppDeviceInfo = pDeviceInfo->pNext;

#ifdef GENERIC_INPUT
            TAGMSG1(DBGTAG_PNP, "FreeDeviceInfo: freeing deviceinfo=%#p", pDeviceInfo);
            HMFreeObject(pDeviceInfo);
#else
            UserFreePool(pDeviceInfo);
#endif

            return *ppDeviceInfo;
        }
        ppDeviceInfo = &(*ppDeviceInfo)->pNext;
    }

    RIPMSG1(RIP_ERROR, "pDeviceInfo %#p not found in gpDeviceInfoList", pDeviceInfo);

    return NULL;
}

/***************************************************************************\
* UpdateMouseInfo
*
* This function updates mouse information for a remote session.
*
* History:
* 05-22-98 clupu      Created.
\***************************************************************************/
VOID UpdateMouseInfo(
    VOID)
{
    DEVICEINFO *pDeviceInfo;
    CheckCritIn();               // expect no surprises

    UserAssert(IsRemoteConnection());

    if (ghRemoteMouseChannel == NULL) {
        return;
    }

    UserAssert(gnMice == 1);

    /*
     * Mark the mice and signal the RIT to do the work asynchronously
     */
    EnterDeviceInfoListCrit();
    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        if (pDeviceInfo->type == DEVICE_TYPE_MOUSE) {
            TAGMSG1(DBGTAG_PNP, "UpdateMouseInfo(): pDeviceInfo %#p ARRIVED", pDeviceInfo);
            RequestDeviceChange(pDeviceInfo, GDIAF_ARRIVED | GDIAF_RECONNECT, TRUE);
        }
    }
    LeaveDeviceInfoListCrit();
}


NTSTATUS DeviceNotify(IN PPLUGPLAY_NOTIFY_HDR, IN PDEVICEINFO);


/*
 * The below two routines are transplanted from i8042prt
 * to get the BIOS NumLock status.
 */
typedef struct _LED_INFO {
    USHORT usLedFlags;
    BOOLEAN fFound;
} LED_INFO, *PLED_INFO;


/****************************************************************************
 *
 * Routine Description:
 *
 *    This is the callout routine sent as a parameter to
 *    IoQueryDeviceDescription.  It grabs the keyboard peripheral configuration
 *    information.
 *
 * Arguments:
 *
 *     Context - Context parameter that was passed in by the routine
 *         that called IoQueryDeviceDescription.
 *
 *     PathName - The full pathname for the registry key.
 *
 *     BusType - Bus interface type (Isa, Eisa, Mca, etc.).
 *
 *     BusNumber - The bus sub-key (0, 1, etc.).
 *
 *     BusInformation - Pointer to the array of pointers to the full value
 *         information for the bus.
 *
 *     ControllerType - The controller type (should be KeyboardController).
 *
 *     ControllerNumber - The controller sub-key (0, 1, etc.).
 *
 *     ControllerInformation - Pointer to the array of pointers to the full
 *         value information for the controller key.
 *
 *     PeripheralType - The peripheral type (should be KeyboardPeripheral).
 *
 *     PeripheralNumber - The peripheral sub-key.
 *
 *     PeripheralInformation - Pointer to the array of pointers to the full
 *         value information for the peripheral key.
 *
 *
 * Return Value:
 *
 *     None.  If successful, will have the following side-effects:
 *
 *         - Sets DeviceObject->DeviceExtension->HardwarePresent.
 *         - Sets configuration fields in
 *           DeviceObject->DeviceExtension->Configuration.
 *
 ****************************************************************************/
NTSTATUS
KeyboardDeviceSpecificCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation)
{
    PUCHAR                          pPeripheralData;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDesc;
    PCM_KEYBOARD_DEVICE_DATA        pKbdDeviceData;
    PLED_INFO    pInfo;
    ULONG                           i, listCount;

    TAGMSG0(DBGTAG_KBD, "KeyboardDeviceSpecificCallout: called.");

    UNREFERENCED_PARAMETER(PathName);
    UNREFERENCED_PARAMETER(BusType);
    UNREFERENCED_PARAMETER(BusNumber);
    UNREFERENCED_PARAMETER(BusInformation);
    UNREFERENCED_PARAMETER(ControllerType);
    UNREFERENCED_PARAMETER(ControllerNumber);
    UNREFERENCED_PARAMETER(ControllerInformation);
    UNREFERENCED_PARAMETER(PeripheralType);
    UNREFERENCED_PARAMETER(PeripheralNumber);

    pInfo = (PLED_INFO)Context;

    if (pInfo->fFound) {
        return STATUS_SUCCESS;
    }

    //
    // Look through the peripheral's resource list for device-specific
    // information.
    //
    if (PeripheralInformation[IoQueryDeviceConfigurationData]->DataLength != 0) {
        pPeripheralData =
            ((PUCHAR)(PeripheralInformation[IoQueryDeviceConfigurationData])) +
                PeripheralInformation[IoQueryDeviceConfigurationData]->DataOffset;

        pPeripheralData += FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList);

        listCount = ((PCM_PARTIAL_RESOURCE_LIST)pPeripheralData)->Count;

        pResDesc = ((PCM_PARTIAL_RESOURCE_LIST)pPeripheralData)->PartialDescriptors;

        for (i = 0; i < listCount; i++, pResDesc++) {
            if (pResDesc->Type == CmResourceTypeDeviceSpecific) {
                //
                // Get the keyboard type, subtype, and the initial
                // settings for the LEDs.
                //
                pKbdDeviceData = (PCM_KEYBOARD_DEVICE_DATA)
                                       (((PUCHAR) pResDesc) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                TAGMSG1(DBGTAG_KBD, "KeyboardDeviceSpecificCallout: specific data is %p\n", pKbdDeviceData);

#ifdef LATER
                if (pKbdDeviceData->Type <= NUM_KNOWN_KEYBOARD_TYPES) {
                    pInfo->KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Type =
                    pKbdDeviceData->Type;
                }

                pInfo->KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Subtype =
                pKbdDeviceData->Subtype;
#endif

                pInfo->usLedFlags = (pKbdDeviceData->KeyboardFlags >> 4) &
                                  (KEYBOARD_SCROLL_LOCK_ON | KEYBOARD_NUM_LOCK_ON | KEYBOARD_CAPS_LOCK_ON);

                TAGMSG1(DBGTAG_KBD, "KeyboardDeviceSpecificCallout: LED %04x", pInfo->usLedFlags);

                pInfo->fFound = TRUE;
                break;
            }
        }
    }

    return STATUS_SUCCESS;
}

VOID GetBiosNumLockStatus(
    VOID)
{
    LED_INFO info;
    INTERFACE_TYPE interfaceType;
    CONFIGURATION_TYPE controllerType = KeyboardController;
    CONFIGURATION_TYPE peripheralType = KeyboardPeripheral;
    ULONG i;

    info.usLedFlags = 0;
    info.fFound = FALSE;

    for (i = 0; i < MaximumInterfaceType; i++) {
        //
        // Get the registry information for this device.
        //
        interfaceType = i;
        IoQueryDeviceDescription(&interfaceType,
                                 NULL,
                                 &controllerType,
                                 NULL,
                                 &peripheralType,
                                 NULL,
                                 KeyboardDeviceSpecificCallout,
                                 (PVOID)&info);
        if (info.fFound) {
            gklpBootTime.LedFlags = info.usLedFlags;
            return;
        }
    }

    RIPMSG0(RIP_WARNING, "GetBiosNumLockStatus: could not find the BIOS LED info!!!");
}

/***************************************************************************\
* InitKeyboardState
*
* This function clears the keyboard down state. It will be required
* when the system resumes from hybernation.
* states.
*
* History:
* 12-12-00 Hiroyama
\***************************************************************************/
VOID InitKeyboardState(
    VOID)
{
    TAGMSG0(DBGTAG_KBD, "InitKeyboardState >>>>>");

    /*
     * Clear the cached modifier state for the hotkey.
     * (WindowsBug #252051)
     */
    ClearCachedHotkeyModifiers();

    TAGMSG0(DBGTAG_KBD, "InitKeyboardState <<<<<<");
}

/***************************************************************************\
* InitKeyboard
*
* This function gets information about the keyboard and initialize the internal
* states.
*
* History:
* 11-26-90 DavidPe      Created.
* XX-XX-00 Hiroyama
\***************************************************************************/

VOID InitKeyboard(VOID)
{
    if (!IsRemoteConnection()) {
        /*
         * Get the BIOS Numlock status.
         */
        GetBiosNumLockStatus();

        /*
         * Initialize the keyboard state.
         */
        InitKeyboardState();
    }

    UpdatePerUserKeyboardMappings(NULL);
}

VOID UpdatePerUserKeyboardMappings(PUNICODE_STRING pProfileUserName)
{
    /*
     * Get or clean the Scancode Mapping, if any.
     */
    InitScancodeMap(pProfileUserName);
}


HKL GetActiveHKL()
{
    CheckCritIn();
    if (gpqForeground && gpqForeground->spwndActive) {
        PTHREADINFO ptiForeground = GETPTI(gpqForeground->spwndActive);
        if (ptiForeground && ptiForeground->spklActive) {
            return ptiForeground->spklActive->hkl;
        }
    }
    return _GetKeyboardLayout(0L);
}

VOID FinalizeKoreanImeCompStrOnMouseClick(PWND pwnd)
{
    PTHREADINFO ptiWnd = GETPTI(pwnd);

    /*
     * 274007: MFC flushes mouse related messages if keyup is posted
     * while it's in context help mode.
     */
    if (gpqForeground->spwndCapture == NULL &&
            /*
             * Hack for OnScreen Keyboard: no finalization on button event.
             */
            (GetAppImeCompatFlags(ptiWnd) & IMECOMPAT_NOFINALIZECOMPSTR) == 0) {

        if (LOWORD(ptiWnd->dwExpWinVer) > VER40) {
            PWND pwndIme = ptiWnd->spwndDefaultIme;

            if (pwndIme && !TestWF(pwndIme, WFINDESTROY)) {
                /*
                 * For new applications, we no longer post hacky WM_KEYUP.
                 * Instead, we use private IME_SYSTEM message.
                 */
                _PostMessage(pwndIme, WM_IME_SYSTEM, IMS_FINALIZE_COMPSTR, 0);
            }
        } else {
            /*
             * For the backward compatibility w/NT4, we post WM_KEYUP to finalize
             * the composition string.
             */
            PostInputMessage(gpqForeground, NULL, WM_KEYUP, VK_PROCESSKEY, 0, 0, 0);
        }
    }
}


#ifdef GENERIC_INPUT
#ifdef GI_SINK

__inline VOID FillRawMouseInput(
    PHIDDATA pHidData,
    PMOUSE_INPUT_DATA pmei)
{
    /*
     * Set the data.
     */
    pHidData->rid.data.mouse.usFlags = pmei->Flags;
    pHidData->rid.data.mouse.ulButtons = pmei->Buttons;
    pHidData->rid.data.mouse.ulRawButtons = pmei->RawButtons;
    pHidData->rid.data.mouse.lLastX = pmei->LastX;
    pHidData->rid.data.mouse.lLastY = pmei->LastY;
    pHidData->rid.data.mouse.ulExtraInformation = pmei->ExtraInformation;
}


BOOL PostRawMouseInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei)
{
    PHIDDATA pHidData;
    PWND pwnd;
    PPROCESS_HID_TABLE pHidTable;

    if (pmei->UnitId == INVALID_UNIT_ID) {
        TAGMSG1(DBGTAG_PNP, "PostRawMouseInput: MOUSE_INPUT_DATA %p is already handled.", pmei);
        return TRUE;
    }

    if (pq) {
        pHidTable = PtiMouseFromQ(pq)->ppi->pHidTable;
    } else {
        pHidTable = NULL;
    }

    if (pHidTable && pHidTable->fRawMouse) {
        UserAssert(PtiMouseFromQ(pq)->ppi->pHidTable);
        pwnd = PtiMouseFromQ(pq)->ppi->pHidTable->spwndTargetMouse;
        if (pwnd) {
            pq = GETPTI(pwnd)->pq;
        }

        pHidData = AllocateHidData(hDevice, RIM_TYPEMOUSE, sizeof(RAWMOUSE), RIM_INPUT, pwnd);

        UserAssert(pq);

        if (pHidData == NULL) {
            // failed to allocate
            RIPMSG0(RIP_WARNING, "PostRawMouseInput: filed to allocate HIDDATA.");
            return FALSE;
        }

        UserAssert(pmei);

        FillRawMouseInput(pHidData, pmei);

        PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoH(pHidData), dwTime, pmei->ExtraInformation);
    }

#if DBG
    pHidData = NULL;
#endif

    if (IsMouseSinkPresent()) {
        /*
         * Walk through the global sink list.
         */
        PLIST_ENTRY pList = gHidRequestTable.ProcessRequestList.Flink;

        for (; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
            PPROCESS_HID_TABLE pProcessHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);
            PPROCESSINFO ppiForeground;

            if (pq) {
                ppiForeground = PtiMouseFromQ(pq)->ppi;
            } else {
                ppiForeground = NULL;
            }

            UserAssert(pProcessHidTable);
            if (pProcessHidTable->fRawMouseSink) {
                /*
                 * Sink is specified. Let's check out if it's the legid receiver.
                 */

                UserAssert(pProcessHidTable->spwndTargetMouse);   // shouldn't be NULL.

                if (pProcessHidTable->spwndTargetMouse == NULL ||
                        TestWF(pProcessHidTable->spwndTargetMouse, WFINDESTROY) ||
                        TestWF(pProcessHidTable->spwndTargetMouse, WFDESTROYED)) {
                    /*
                     * This guy doesn't have a legit spwndTarget or the window is
                     * halfly destroyed.
                     */
#ifdef LATER
                    pProcessHidTable->fRawMouse = pProcessHidTable->fRawMouseSink =
                        pProcessHidTable->fNoLegacyMouse = FALSE;
#endif
                    continue;
                }

                if (pProcessHidTable->spwndTargetMouse->head.rpdesk != grpdeskRitInput) {
                    /*
                     * This guy belongs to the other desktop, let's skip it.
                     */
                    continue;
                }

                if (GETPTI(pProcessHidTable->spwndTargetMouse)->ppi == ppiForeground) {
                    /*
                     * Should be already handled, let's skip it.
                     */
                    continue;
                }

                /*
                 * Let's post the message to this guy.
                 */
                pHidData = AllocateHidData(hDevice, RIM_TYPEMOUSE, sizeof(RAWMOUSE), RIM_INPUTSINK, pProcessHidTable->spwndTargetMouse);

                if (pHidData == NULL) {
                    RIPMSG1(RIP_WARNING, "PostInputMessage: failed to allocate HIDDATA for sink: %p", pProcessHidTable);
                    return FALSE;
                }

                FillRawMouseInput(pHidData, pmei);
                pwnd = pProcessHidTable->spwndTargetMouse;
                PostInputMessage(GETPTI(pwnd)->pq,
                                 pwnd,
                                 WM_INPUT,
                                 RIM_INPUTSINK,
                                 (LPARAM)PtoH(pHidData),
                                 dwTime,
                                 pmei->ExtraInformation);
            }
        }
    }

    /*
     * Mark this raw input as processed.
     */
    pmei->UnitId = INVALID_UNIT_ID;

    return TRUE;
}

#else   // GI_SINK

// original code

BOOL PostRawMouseInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei)
{
    PHIDDATA pHidData;
    PWND pwnd;

    UserAssert(PtiMouseFromQ(pq)->ppi->pHidTable);
    if (pmei->UnitId == INVALID_UNIT_ID) {
        TAGMSG1(DBGTAG_PNP, "PostRawMouseInput: MOUSE_INPUT_DATA %p is already handled.", pmei);
        return TRUE;
    }
    pwnd = PtiMouseFromQ(pq)->ppi->pHidTable->spwndTargetMouse;
    if (pwnd) {
        pq = GETPTI(pwnd)->pq;
    }

    pHidData = AllocateHidData(hDevice, RIM_TYPEMOUSE, sizeof(RAWMOUSE), RIM_INPUT, pwnd);

    UserAssert(pq);

    if (pHidData == NULL) {
        // failed to allocate
        RIPMSG0(RIP_WARNING, "PostRawMouseInput: filed to allocate HIDDATA.");
        return FALSE;
    }

    UserAssert(hDevice);
    UserAssert(pmei);
    pHidData->rid.data.mouse.usFlags = pmei->Flags;
    pHidData->rid.data.mouse.ulButtons = pmei->Buttons;
    pHidData->rid.data.mouse.ulRawButtons = pmei->RawButtons;
    pHidData->rid.data.mouse.lLastX = pmei->LastX;
    pHidData->rid.data.mouse.lLastY = pmei->LastY;
    pHidData->rid.data.mouse.ulExtraInformation = pmei->ExtraInformation;

    /*
     * Mark this raw input as processed.
     */
    pmei->UnitId = INVALID_UNIT_ID;

    PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoH(pHidData), dwTime, pmei->ExtraInformation);

    return TRUE;
}
#endif  // GI_SINK

BOOL RawInputRequestedForMouse(PTHREADINFO pti)
{
#ifdef GI_SINK
    return gHidCounters.cMouseSinks > 0 || TestRawInputMode(pti, RawMouse);
#else
    return TestRawInputMode(pti, RawKeyboard);
#endif
}

#endif  // GENERIC_INPUT

/***************************************************************************\
* xxxButtonEvent (RIT)
*
* Button events from the mouse driver go here.  Based on the location of
* the cursor the event is directed to specific window.  When a button down
* occurs, a mouse owner window is established.  All mouse events up to and
* including the corresponding button up go to the mouse owner window.  This
* is done to best simulate what applications want when doing mouse capturing.
* Since we're processing these events asynchronously, but the application
* calls SetCapture() in response to it's synchronized processing of input
* we have no other way to get this functionality.
*
* The async keystate table for VK_*BUTTON is updated here.
*
* History:
* 10-18-90 DavidPe     Created.
* 01-25-91 IanJa       xxxWindowHitTest change
* 03-12-92 JonPa       Make caller enter crit instead of this function
\***************************************************************************/

VOID xxxButtonEvent(
    DWORD ButtonNumber,
    POINT ptPointer,
    BOOL  fBreak,
    DWORD time,
    ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL  bInjected,
    BOOL  fDblClk)
{
    UINT    message, usVK, usOtherVK, wHardwareButton;
    PWND    pwnd;
    LPARAM  lParam;
    WPARAM  wParam;
    int     xbutton;
    TL      tlpwnd;
    PHOOK   pHook;
#ifdef GENERIC_INPUT
    BOOL    fMouseExclusive = FALSE;
#endif

#ifdef REDIRECTION
    PWND    pwndStart;
#endif // REDIRECTION

    CheckCritIn();


    /*
     * Cancel Alt-Tab if the user presses a mouse button
     */
    if (gspwndAltTab != NULL) {
        xxxCancelCoolSwitch();
    }

    /*
     * Grab the mouse button before we process any button swapping.
     * This is so we won't get confused if someone calls
     * SwapMouseButtons() inside a down-click/up-click.
     */
    wHardwareButton = (UINT)ButtonNumber;

    /*
     * If this is the left or right mouse button, we have to handle mouse
     * button swapping.
     */
    if (ButtonNumber & (MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT)) {
        /*
         * If button swapping is on, swap the mouse buttons
         */
        if (SYSMET(SWAPBUTTON)) {
            ButtonNumber ^= (MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT);
        }

        /*
         * Figure out VK
         */
        if (ButtonNumber == MOUSE_BUTTON_RIGHT) {
            usVK = VK_RBUTTON;
            usOtherVK = VK_LBUTTON;
        } else if (ButtonNumber == MOUSE_BUTTON_LEFT) {
            usVK = VK_LBUTTON;
            usOtherVK = VK_RBUTTON;
        } else {
            RIPMSG1(RIP_ERROR, "Unexpected Button number %d", ButtonNumber);
        }

        /*
         * If the mouse buttons have recently been swapped AND the button
         * transition doesn't match what we have in our keystate, then swap the
         * button to match.
         * This is to fix the ruler (tabs and margins) in Word 97 SR1, which
         * calls SwapMouseButtons(0) to determine if button swapping is on, and
         * if so then calls SwapMouseButtons(1) to restore it: if we receive a
         * button event between these two calls, we may swap incorrectly, and
         * be left with a mouse button stuck down or see the wrong button going
         * down. This really messed up single/double button tab/margin setting!
         * The same bug shows up under Windows '95, although very infrequently:
         * Word 9 will use GetSystemMetrics(SM_SWAPBUTTON) instead according to
         * to Mark Walker (MarkWal).                            (IanJa) #165157
         */
        if (gbMouseButtonsRecentlySwapped) {
            if ((!fBreak == !!TestAsyncKeyStateDown(usVK)) &&
                    (fBreak == !!TestAsyncKeyStateDown(usOtherVK))) {
                RIPMSG4(RIP_WARNING, "Correct %s %s to %s %s",
                         ButtonNumber == MOUSE_BUTTON_LEFT ? "Left" : "Right",
                         fBreak ? "Up" : "Down",
                         ButtonNumber == MOUSE_BUTTON_LEFT ? "Right" : "Left",
                         fBreak ? "Up" : "Down");
                ButtonNumber ^= (MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT);
                usVK = usOtherVK;
            }
            gbMouseButtonsRecentlySwapped = FALSE;
        }
    }

    xbutton = 0;
    switch (ButtonNumber) {
    case MOUSE_BUTTON_RIGHT:
        if (fBreak) {
            message = WM_RBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_RBUTTONDBLCLK;
            else
                message = WM_RBUTTONDOWN;
        }
        break;

    case MOUSE_BUTTON_LEFT:
        if (fBreak) {
            message = WM_LBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_LBUTTONDBLCLK;
            else
                message = WM_LBUTTONDOWN;
        }
        break;

    case MOUSE_BUTTON_MIDDLE:
        if (fBreak) {
            message = WM_MBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_MBUTTONDBLCLK;
            else
                message = WM_MBUTTONDOWN;
        }
        usVK = VK_MBUTTON;
        break;

    case MOUSE_BUTTON_X1:
    case MOUSE_BUTTON_X2:
        if (fBreak) {
            message = WM_XBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_XBUTTONDBLCLK;
            else
                message = WM_XBUTTONDOWN;
        }

        if (ButtonNumber == MOUSE_BUTTON_X1) {
            usVK = VK_XBUTTON1;
            xbutton = XBUTTON1;
        } else {
            usVK = VK_XBUTTON2;
            xbutton = XBUTTON2;
        }
        break;

    default:
        /*
         * Unknown button.  Since we don't
         * have messages for these buttons, ignore them.
         */
        return;
    }
    UserAssert(usVK != 0);

    /*
     * Check for click-lock
     */
    if (TestEffectUP(MOUSECLICKLOCK)) {
        if (message == WM_LBUTTONDOWN) {
            if (gfStartClickLock) {
                /*
                 * Already inside click-lock, so just throw this message away
                 * and turn click-lock off.
                 */
                gfStartClickLock        = FALSE;
                return;
            } else {
                /*
                 * Start click-lock and record the time.
                 */
                gfStartClickLock        = TRUE;
                gdwStartClickLockTick   = time;
            }
        } else if (message == WM_LBUTTONUP) {
            if (gfStartClickLock) {
                DWORD dwDeltaTick = time - gdwStartClickLockTick;
                if (dwDeltaTick > UPDWORDValue(SPI_GETMOUSECLICKLOCKTIME)) {
                    /*
                     * Inside a potential click-lock, so throw this message away
                     * if waited beyond the click-lock period.
                     */
                    return;
                } else {
                    /*
                     * The mouse up occurred before the click-lock period completed,
                     * so cancel the click-lock.
                     */

                    gfStartClickLock = FALSE;
                }
            }
        }
    }

    wParam = MAKEWPARAM(0, xbutton);

    /*
     * Call low level mouse hooks to see if they allow this message
     * to pass through USER
     */
    if ((pHook = PhkFirstValid(PtiCurrent(), WH_MOUSE_LL)) != NULL) {
        MSLLHOOKSTRUCT mslls;
        BOOL           bAnsiHook;

        mslls.pt          = ptPointer;
        mslls.mouseData   = (LONG)wParam;
        mslls.flags       = bInjected;
        mslls.time        = time;
        mslls.dwExtraInfo = ExtraInfo;

        if (xxxCallHook2(pHook, HC_ACTION, (DWORD)message, (LPARAM)&mslls, &bAnsiHook)) {
            return;
        }
    }


#ifdef GENERIC_INPUT
    UserAssert(gpqForeground == NULL || PtiMouseFromQ(gpqForeground));
    if (gpqForeground) {
        if (hDevice && RawInputRequestedForMouse(PtiMouseFromQ(gpqForeground))) {
            PostRawMouseInput(gpqForeground, time, hDevice, pmei);
        }
    }
#endif


    /*
     * This is from HYDRA
     */
    UserAssert(grpdeskRitInput != NULL);

#ifdef GENERIC_INPUT
    if (gpqForeground && TestRawInputMode(PtiMouseFromQ(gpqForeground), CaptureMouse)) {
        fMouseExclusive = TRUE;
        pwnd = PtiMouseFromQ(gpqForeground)->ppi->pHidTable->spwndTargetMouse;
        UserAssert(pwnd);
        if (pwnd) {
            goto KeyStatusUpdate;
        }
        // Something bad happened to our HidTable, but
        // not let it AV because of that.
    }
#endif
#ifdef REDIRECTION
    /*
     * Call the speed hit test hook
     */
    pwndStart = xxxCallSpeedHitTestHook(&ptPointer);
    if (pwndStart == NULL) {
        pwndStart = grpdeskRitInput->pDeskInfo->spwnd;
    }

    pwnd = SpeedHitTest(pwndStart, ptPointer);
#else
    pwnd = SpeedHitTest(grpdeskRitInput->pDeskInfo->spwnd, ptPointer);
#endif // REDIRECTION

    /*
     * Only post the message if we actually hit a window.
     */
    if (pwnd == NULL) {
        return;
    }

    /*
     * Assign the message to a window.
     */
    lParam = MAKELONG((SHORT)ptPointer.x, (SHORT)ptPointer.y);

    /*
     * KOREAN:
     *  Send VK_PROCESSKEY to finalize current composition string (NT4 behavior)
     *  Post private message to let IMM finalize the composition string (NT5)
     */
    if (IS_IME_ENABLED() &&
            !fBreak &&
            KOREAN_KBD_LAYOUT(GetActiveHKL()) &&
            !TestCF(pwnd, CFIME) &&
            gpqForeground != NULL) {
        FinalizeKoreanImeCompStrOnMouseClick(pwnd);
    }

    /*
     * If screen capture is active do it
     */
    if (gspwndScreenCapture != NULL)
        pwnd = gspwndScreenCapture;

    /*
     * If this is a button down event and there isn't already
     * a mouse owner, setup the mouse ownership globals.
     */
    if (gspwndMouseOwner == NULL) {
        if (!fBreak) {
            PWND pwndCapture;

            /*
             * BIG HACK: If the foreground window has the capture
             * and the mouse is outside the foreground queue then
             * send a buttondown/up pair to that queue so it'll
             * cancel it's modal loop.
             */
            if (pwndCapture = PwndForegroundCapture()) {

                if (GETPTI(pwnd)->pq != GETPTI(pwndCapture)->pq) {
                    PQ pqCapture;

                    pqCapture = GETPTI(pwndCapture)->pq;
                    PostInputMessage(pqCapture, pwndCapture, message,
                            0, lParam, 0, 0);
                    PostInputMessage(pqCapture, pwndCapture, message + 1,
                            0, lParam, 0, 0);

                    /*
                     * EVEN BIGGER HACK: To maintain compatibility
                     * with how tracking deals with this, we don't
                     * pass this event along.  This prevents mouse
                     * clicks in other windows from causing them to
                     * become foreground while tracking.  The exception
                     * to this is when we have the sysmenu up on
                     * an iconic window.
                     */
                    if ((GETPTI(pwndCapture)->pmsd != NULL) &&
                            !IsMenuStarted(GETPTI(pwndCapture))) {
                        return;
                    }
                }
            }

            Lock(&(gspwndMouseOwner), pwnd);
            gwMouseOwnerButton |= wHardwareButton;
            glinp.ptLastClick = gpsi->ptCursor;
        } else {

            /*
             * The mouse owner must have been destroyed or unlocked
             * by a fullscreen switch.  Keep the button state in sync.
             */
            gwMouseOwnerButton &= ~wHardwareButton;
        }

    } else {

        /*
         * Give any other button events to the mouse-owner window
         * to be consistent with old capture semantics.
         */
        if (gspwndScreenCapture == NULL)  {
            /*
             * NT5 Foreground and Drag Drop.
             * If the mouse goes up on a different thread
             * make the mouse up thread the owner of this click
             */
            if (fBreak && (GETPTI(pwnd) != GETPTI(gspwndMouseOwner))) {
                glinp.ptiLastWoken = GETPTI(pwnd);
                TAGMSG1(DBGTAG_FOREGROUND, "xxxButtonEvent. ptiLastWoken %#p", glinp.ptiLastWoken);
            }
            pwnd = gspwndMouseOwner;
        }

        /*
         * If this is the button-up event for the mouse-owner
         * clear gspwndMouseOwner.
         */
        if (fBreak) {
            gwMouseOwnerButton &= ~wHardwareButton;
            if (!gwMouseOwnerButton)
                Unlock(&gspwndMouseOwner);
        } else {
            gwMouseOwnerButton |= wHardwareButton;
        }
    }

KeyStatusUpdate:
    /*
     * Only update the async keystate when we know which window this
     * event goes to (or else we can't keep the thread specific key
     * state in sync).
     */
    UserAssert(usVK != 0);
    UpdateAsyncKeyState(GETPTI(pwnd)->pq, usVK, fBreak);

#ifdef GENERIC_INPUT
    if (fMouseExclusive) {
        /*
         * If the foreground application requests mouse exclusive
         * raw input, let's not post the activate messages etc.
         * The mouse exclusiveness requires no activation,
         * even within the same app.
         */
        return;
    }
#endif

    /*
     * Put pwnd into the foreground if this is a button down event
     * and it isn't already the foreground window.
     */
    if (!fBreak && GETPTI(pwnd)->pq != gpqForeground) {
        /*
         * If this is an WM_*BUTTONDOWN on a desktop window just do
         * cancel-mode processing.  Check to make sure that there
         * wasn't already a mouse owner window.  See comments below.
         */
        if ((gpqForeground != NULL) && (pwnd == grpdeskRitInput->pDeskInfo->spwnd) &&
                ((gwMouseOwnerButton & wHardwareButton) ||
                (gwMouseOwnerButton == 0))) {
            PostEventMessage(gpqForeground->ptiMouse,
                    gpqForeground, QEVENT_CANCELMODE, NULL, 0, 0, 0);

        } else if ((gwMouseOwnerButton & wHardwareButton) ||
                (gwMouseOwnerButton == 0)) {

            /*
             * Don't bother setting the foreground window if there's
             * already mouse owner window from a button-down different
             * than this event.  This prevents weird things from happening
             * when the user starts a tracking operation with the left
             * button and clicks the right button during the tracking
             * operation.
             */
            /*
             * If pwnd is a descendent of a WS_EX_NOACTIVATE window, then we
             * won't set it to the  foreground
             */
            PWND pwndTopLevel = GetTopLevelWindow(pwnd);
            if (!TestWF(pwndTopLevel, WEFNOACTIVATE)) {
                ThreadLockAlways(pwnd, &tlpwnd);
                xxxSetForegroundWindow2(pwnd, NULL, 0);
                /*
                 * Ok to unlock right away: the above didn't really leave the crit sec.
                 * We lock here for consistency so the debug macros work ok.
                 */
                ThreadUnlock(&tlpwnd);

            }
        }
    }

#ifdef GENERIC_INPUT
    if (TestRawInputMode(PtiMouseFromQ(GETPTI(pwnd)->pq), NoLegacyMouse)) {
        return;
    }
#endif

    if (GETPTI(pwnd)->pq->QF_flags & QF_MOUSEMOVED) {
        PostMove(GETPTI(pwnd)->pq);
    }

    PostInputMessage(GETPTI(pwnd)->pq, pwnd, message, wParam, lParam, time, ExtraInfo);

    /*
     * If this is a mouse up event and stickykeys is enabled all latched
     * keys will be released.
     */
    if (fBreak && (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) ||
                   TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON))) {
        xxxHardwareMouseKeyUp(ButtonNumber);
    }

    if (message == WM_LBUTTONDOWN) {
        PDESKTOP pdesk = GETPTI(pwnd)->rpdesk;
        if (pdesk != NULL && pdesk->rpwinstaParent != NULL) {

            UserAssert(!(pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

#ifdef HUNGAPP_GHOSTING
            if (FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT)) {
                SignalGhost(pwnd);
            }
#endif // HUNGAPP_GHOSTING
        }
    }
}

/***************************************************************************\
*
* The Button-Click Queue is protected by the semaphore gcsMouseEventQueue
*
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, QueueMouseEvent)
#endif

/***************************************************************************\
* QueueMouseEvent
*
* Params:
*     ButtonFlags - button flags from the driver in MOUSE_INPUT_DATA.ButtonFlags
*
*     ButtonData  - data from the driver in MOUSE_INPUT_DATA.ButtonData
*                   Stores the wheel delta
*
*     ExtraInfo - extra information from the driver in MOUSE_INPUT_DATA.ExtraInfo
*     ptMouse - mouse delta
*     time - tick count at time of event
*     bInjected - injected by SendInput?
*     bWakeRIT - wake the RIT?
*
\***************************************************************************/

VOID QueueMouseEvent(
    USHORT  ButtonFlags,
    USHORT  ButtonData,
    ULONG_PTR ExtraInfo,
    POINT   ptMouse,
    LONG    time,
#ifdef GENERIC_INPUT
    HANDLE  hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL    bInjected,
    BOOL    bWakeRIT
    )
{
    CheckCritOut();

    EnterMouseCrit();

    LOGTIME(gMouseQueueMouseEventTime);

    /*
     * Button data must always be accompanied by a flag to interpret it.
     */
    UserAssert(ButtonData == 0 || ButtonFlags != 0);

    /*
     * We can coalesce this mouse event with the previous event if there is a
     * previous event, and if the previous event and this event involve no
     * key transitions.
     */
    if ((gdwMouseEvents == 0) ||
            (ButtonFlags != 0) ||
            (gMouseEventQueue[gdwMouseQueueHead].ButtonFlags != 0)) {
        /*
         * Can't coalesce: must add a new mouse event
         */
        if (gdwMouseEvents >= NELEM_BUTTONQUEUE) {
            /*
             * But no more room!
             */
            LeaveMouseCrit();
            UserBeep(440, 125);
            return;
        }

        gdwMouseQueueHead = (gdwMouseQueueHead + 1) % NELEM_BUTTONQUEUE;
        gMouseEventQueue[gdwMouseQueueHead].ButtonFlags = ButtonFlags;
        gMouseEventQueue[gdwMouseQueueHead].ButtonData  = ButtonData;
        gdwMouseEvents++;
    }

    gMouseEventQueue[gdwMouseQueueHead].ExtraInfo = ExtraInfo;
    gMouseEventQueue[gdwMouseQueueHead].ptPointer = ptMouse;
    gMouseEventQueue[gdwMouseQueueHead].time      = time;
    gMouseEventQueue[gdwMouseQueueHead].bInjected = bInjected;
#ifdef GENERIC_INPUT
    gMouseEventQueue[gdwMouseQueueHead].hDevice   = hDevice;
    if (pmei) {
        gMouseEventQueue[gdwMouseQueueHead].rawData = *pmei;
    } else {
        /*
         * To indicate the rawData is invalid, set INVALID_UNIT_ID.
         */
        gMouseEventQueue[gdwMouseQueueHead].rawData.UnitId = INVALID_UNIT_ID;
    }
#endif

    LeaveMouseCrit();

    if (bWakeRIT) {
        /*
         * Signal RIT to complete the mouse input processing
         */
        KeSetEvent(gpkeMouseData, EVENT_INCREMENT, FALSE);
    }
}

/*****************************************************************************\
*
* Gets mouse events out of the queue
*
* Returns:
*   TRUE  - a mouse event is obtained in *pme
*   FALSE - no mouse event available
*
\*****************************************************************************/

BOOL UnqueueMouseEvent(
    PMOUSEEVENT pme
    )
{
    DWORD dwTail;

    EnterMouseCrit();

    LOGTIME(gMouseUnqueueMouseEventTime);

    if (gdwMouseEvents == 0) {
        LeaveMouseCrit();
        return FALSE;
    } else {
        dwTail = (gdwMouseQueueHead - gdwMouseEvents + 1) % NELEM_BUTTONQUEUE;
        *pme = gMouseEventQueue[dwTail];
        gdwMouseEvents--;
    }

    LeaveMouseCrit();
    return TRUE;
}

VOID xxxDoButtonEvent(PMOUSEEVENT pme)
{
    ULONG   dwButtonMask;
    ULONG   dwButtonState;
    LPARAM  lParam;
    BOOL    fWheel;
    PHOOK   pHook;
    ULONG   dwButtonData = (ULONG) pme->ButtonData;

    CheckCritIn();

    dwButtonState = (ULONG) pme->ButtonFlags;
    fWheel = dwButtonState & MOUSE_WHEEL;
    dwButtonState &= ~MOUSE_WHEEL;

    for(    dwButtonMask = 1;
            dwButtonState != 0;
            dwButtonData >>= 2, dwButtonState >>= 2, dwButtonMask <<= 1) {

        if (dwButtonState & 1) {
            xxxButtonEvent(dwButtonMask, pme->ptPointer, FALSE,
                pme->time, pme->ExtraInfo,
#ifdef GENERIC_INPUT
                pme->hDevice,
                &pme->rawData,
#endif
                pme->bInjected,
                gbClientDoubleClickSupport && (dwButtonData & 1));
        }

        if (dwButtonState & 2) {
            xxxButtonEvent(dwButtonMask, pme->ptPointer, TRUE,
                pme->time, pme->ExtraInfo,
#ifdef GENERIC_INPUT
                pme->hDevice,
                &pme->rawData,
#endif
                pme->bInjected ,FALSE);
        }
    }

    /*
     * Handle the wheel msg.
     */
    if (fWheel && pme->ButtonData != 0 && gpqForeground) {

        lParam = MAKELONG((SHORT)pme->ptPointer.x, (SHORT)pme->ptPointer.y);

        /*
         * Call low level mouse hooks to see if they allow this message
         * to pass through USER
         */
        if ((pHook = PhkFirstValid(PtiCurrent(), WH_MOUSE_LL)) != NULL) {
            MSLLHOOKSTRUCT mslls;
            BOOL           bAnsiHook;

            mslls.pt          = pme->ptPointer;
            mslls.mouseData   = MAKELONG(0, pme->ButtonData);
            mslls.flags       = pme->bInjected;
            mslls.time        = pme->time;
            mslls.dwExtraInfo = pme->ExtraInfo;

            if (xxxCallHook2(pHook, HC_ACTION, (DWORD)WM_MOUSEWHEEL,
                    (LPARAM)&mslls, &bAnsiHook)) {
                return;
            }
        }

#ifdef GENERIC_INPUT
        UserAssert(gpqForeground == NULL || PtiMouseFromQ(gpqForeground));
        if (gpqForeground && RawInputRequestedForMouse(PtiMouseFromQ(gpqForeground))) {
            PostRawMouseInput(gpqForeground, pme->time, pme->hDevice, &pme->rawData);
        }

        if (gpqForeground && !TestRawInputMode(PtiMouseFromQ(gpqForeground), NoLegacyMouse)) {
#endif
            PostInputMessage(
                    gpqForeground,
                    NULL,
                    WM_MOUSEWHEEL,
                    MAKELONG(0, pme->ButtonData),
                    lParam, pme->time,
                    pme->ExtraInfo);
#ifdef GENERIC_INPUT
        }
#endif

        return;
    }
}

VOID NTAPI InputApc(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PDEVICEINFO pDeviceInfo = (PDEVICEINFO)ApcContext;
    UNREFERENCED_PARAMETER(Reserved);

    /*
     * Check if the RIT is being terminated.
     * If we hit this assertion, the RIT was killed by someone inadvertently.
     * Not much can be done if it once happens.
     */
    UserAssert(gptiRit);
    UserAssert((gptiRit->TIF_flags & TIF_INCLEANUP) == 0);


#ifdef DIAGNOSE_IO
    pDeviceInfo->nReadsOutstanding--;
#endif

    /*
     * If this device needs freeing, abandon reading now and request the free.
     * (Don't even process the input that we received in this APC)
     */
    if (pDeviceInfo->usActions & GDIAF_FREEME) {
#ifdef GENERIC_INPUT
        CheckCritOut();
        EnterCrit();
#endif
        EnterDeviceInfoListCrit();
        pDeviceInfo->bFlags &= ~GDIF_READING;
        FreeDeviceInfo(pDeviceInfo);
        LeaveDeviceInfoListCrit();
#ifdef GENERIC_INPUT
        LeaveCrit();
#endif
        return;
    }

    if (NT_SUCCESS(IoStatusBlock->Status) && pDeviceInfo->handle) {
        PDEVICE_TEMPLATE pDevTpl = &aDeviceTemplate[pDeviceInfo->type];
        pDevTpl->DeviceRead(pDeviceInfo);
    }

    if (IsRemoteConnection()) {

        PoSetSystemState(ES_SYSTEM_REQUIRED);

    }

    StartDeviceRead(pDeviceInfo);
}

/***************************************************************************\
* ProcessMouseInput
*
* This function is called whenever a mouse event occurs.  Once the event
* has been processed by USER, StartDeviceRead() is called again to request
* the next mouse event.
*
* When this routin returns, InputApc will start another read.
*
* History:
* 11-26-90 DavidPe      Created.
* 07-23-92 Mikehar      Moved most of the processing to _InternalMouseEvent()
* 11-08-92 JonPa        Rewrote button code to work with new mouse drivers
* 11-18-97 IanJa        Renamed from MouseApcProcedure etc, for multiple mice
\***************************************************************************/
VOID ProcessMouseInput(
    PDEVICEINFO pMouseInfo)
{
    PMOUSE_INPUT_DATA pmei, pmeiNext;
    LONG              time;
    POINT             ptLastMove;

    /*
     * This is an APC, so we don't need the DeviceInfoList Critical Section
     * In fact, we don't want it either. We will not remove the device until
     * ProcessMouseInput has signalled that it is OK to do so. (TBD)
     */
    CheckCritOut();
    CheckDeviceInfoListCritOut();

    UserAssert(pMouseInfo);
    UserAssert((PtiCurrentShared() == gTermIO.ptiDesktop) ||
               (PtiCurrentShared() == gTermNOIO.ptiDesktop));

    LOGTIME(gMouseProcessMiceInputTime);

    if (gptiBlockInput != NULL) {
        return;
    }

    if (TEST_ACCF(ACCF_ACCESSENABLED)) {
        /*
         * Any mouse movement resets the count of consecutive shift key
         * presses.  The shift key is used to enable & disable the
         * stickykeys accessibility functionality.
         */
        gStickyKeysLeftShiftCount = 0;
        gStickyKeysRightShiftCount = 0;

        /*
         * Any mouse movement also cancels the FilterKeys activation timer.
         * Entering critsect here breaks non-jerky mouse movement
         */
        if (gtmridFKActivation != 0) {
            EnterCrit();
            KILLRITTIMER(NULL, gtmridFKActivation);
            gtmridFKActivation = 0;
            gFilterKeysState = FKMOUSEMOVE;
            LeaveCrit();
        }
    }

#ifdef MOUSE_IP
    /*
     * Any mouse movement stops the sonar.
     */
    if (IS_SONAR_ACTIVE()) {
        EnterCrit();
        if (IS_SONAR_ACTIVE()) {
            StopSonar();
            CLEAR_SONAR_LASTVK();
        }
        LeaveCrit();
    }
#endif

    if (!NT_SUCCESS(pMouseInfo->iosb.Status)) {
        /*
         * If we get a bad status, we abandon reading this mouse.
         */

        if (!IsRemoteConnection())
            if (pMouseInfo->iosb.Status != STATUS_DELETE_PENDING) {
                RIPMSG3(RIP_ERROR, "iosb.Status %lx for mouse %#p (id %x) tell IanJa x63321",
                        pMouseInfo->iosb.Status,
                        pMouseInfo, pMouseInfo->mouse.Attr.MouseIdentifier);
            }
        return;
    }

    /*
     * get the last move point from ptCursorAsync
     */
    ptLastMove = gptCursorAsync;

    pmei = pMouseInfo->mouse.Data;
    while (pmei != NULL) {

        time = NtGetTickCount();

        /*
         * Figure out where the next event is.
         */
        pmeiNext = pmei + 1;
        if ((PUCHAR)pmeiNext >=
            (PUCHAR)(((PUCHAR)pMouseInfo->mouse.Data) + pMouseInfo->iosb.Information)) {

            /*
             * If there isn't another event set pmeiNext to
             * NULL so we exit the loop and don't get confused.
             */
            pmeiNext = NULL;
        }

        /*
         * If a PS/2 mouse was plugged in, evaluate the (new) mouse and
         * the skip the input record.
         */
        if (pmei->Flags & MOUSE_ATTRIBUTES_CHANGED) {
            RequestDeviceChange(pMouseInfo, GDIAF_REFRESH_MOUSE, FALSE);
            goto NextMouseInputRecord;
        }

        /*
         * First process any mouse movement that occured.
         * It is important to process movement before button events, otherwise
         * absolute coordinate pointing devices like touch-screens and tablets
         * will produce button clicks at old coordinates.
         */
        if (pmei->LastX || pmei->LastY) {

            /*
             * Get the actual point that will be injected.
             */
            GetMouseCoord(pmei->LastX,
                          pmei->LastY,
                          pmei->Flags,
                          time,
                          pmei->ExtraInformation,
                          &ptLastMove);

            /*
             * If this is a move-only event, and the next one is also a
             * move-only event, skip/coalesce it.
             */
            if (    (pmeiNext != NULL) &&
                    (pmei->ButtonFlags == 0) &&
                    (pmeiNext->ButtonFlags == 0) &&
                    (fAbsoluteMouse(pmei) == fAbsoluteMouse(pmeiNext))) {

                pmei = pmeiNext;

                continue;
            }

#ifdef GENERIC_INPUT
            UserAssert(sizeof(HANDLE) == sizeof(pMouseInfo));
#endif
            /*
             * Moves the cursor on the screen and updates gptCursorAsync
             * Call directly xxxMoveEventAbsolute because we already did the
             * acceleration sensitivity and clipping.
             */
            xxxMoveEventAbsolute(
                    ptLastMove.x,
                    ptLastMove.y,
                    pmei->ExtraInformation,
#ifdef GENERIC_INPUT
                    PtoHq(pMouseInfo),
                    pmei,
#endif
                    time,
                    FALSE
                    );

            /*
             * Now update ptLastMove with ptCursorAsync because ptLastMove
             * doesn't reflect the clipping.
             */
            ptLastMove = gptCursorAsync;
        }

        /*
         * Queue mouse event for the other thread to pick up when it finishes
         * with the USER critical section.
         * If pmeiNext == NULL, there is no more mouse input yet, so wake RIT.
         */
        QueueMouseEvent(
                pmei->ButtonFlags,
                pmei->ButtonData,
                pmei->ExtraInformation,
                gptCursorAsync,
                time,
#ifdef GENERIC_INPUT
                PtoH(pMouseInfo),
                pmei,
#endif
                FALSE,
                (pmeiNext == NULL));

NextMouseInputRecord:
        pmei = pmeiNext;
    }
}


/***************************************************************************\
* IsHexNumpadKeys (RIT) inline
*
* If you change this code, you may need to change
* xxxInternalToUnicode() as well.
\***************************************************************************/
__inline BOOL IsHexNumpadKeys(
    BYTE Vk,
    WORD wScanCode)
{
    return (wScanCode >= SCANCODE_NUMPAD_FIRST && wScanCode <= SCANCODE_NUMPAD_LAST && aVkNumpad[wScanCode - SCANCODE_NUMPAD_FIRST] != 0xff) ||
        (Vk >= L'A' && Vk <= L'F') ||
        (Vk >= L'0' && Vk <= L'9');
}


/***************************************************************************\
* LowLevelHexNumpad (RIT) inline
*
* If you change this code, you may need to change
* xxxInternalToUnicode() as well.
\***************************************************************************/
VOID LowLevelHexNumpad(
    WORD wScanCode,
    BYTE Vk,
    BOOL fBreak,
    USHORT usExtraStuff)
{
    if (!TestAsyncKeyStateDown(VK_MENU)) {
        if (gfInNumpadHexInput & NUMPAD_HEXMODE_LL) {
            gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
        }
    } else {
        if (!fBreak) {  // if it's key down
            if ((gfInNumpadHexInput & NUMPAD_HEXMODE_LL) ||
                    wScanCode == SCANCODE_NUMPAD_PLUS || wScanCode == SCANCODE_NUMPAD_DOT) {
                if ((usExtraStuff & KBDEXT) == 0) {
                    /*
                     * We need to check whether the input is escape character
                     * of hex input mode.
                     * This should be equivalent code as in xxxInternalToUnicode().
                     * If you change this code, you may need to change
                     * xxxInternalToUnicode() as well.
                     */
                    WORD wModBits = 0;

                    wModBits |= TestAsyncKeyStateDown(VK_MENU) ? KBDALT : 0;
                    wModBits |= TestAsyncKeyStateDown(VK_SHIFT) ? KBDSHIFT : 0;
                    wModBits |= TestAsyncKeyStateDown(VK_KANA) ? KBDKANA : 0;

                    if (MODIFIER_FOR_ALT_NUMPAD(wModBits)) {
                        if ((gfInNumpadHexInput & NUMPAD_HEXMODE_LL) == 0) {
                            /*
                             * Only if it's not a hotkey, we enter hex Alt+Numpad mode.
                             */
                            UINT wHotKeyMod = 0;

                            wHotKeyMod |= (wModBits & KBDSHIFT) ? MOD_SHIFT : 0;
                            wHotKeyMod |= TestAsyncKeyStateDown(VK_CONTROL) ? MOD_CONTROL : 0;
                            UserAssert(wModBits & KBDALT);
                            wHotKeyMod |= MOD_ALT;
                            wHotKeyMod |= TestAsyncKeyStateDown(VK_LWIN) || TestAsyncKeyStateDown(VK_RWIN) ?
                                            MOD_WIN : 0;

                            if (IsHotKey(wHotKeyMod, Vk) == NULL) {
                                UserAssert(wScanCode == SCANCODE_NUMPAD_PLUS || wScanCode == SCANCODE_NUMPAD_DOT);
                                gfInNumpadHexInput |= NUMPAD_HEXMODE_LL;
                            }
                        } else if (!IsHexNumpadKeys(Vk, wScanCode)) {
                             gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
                        }
                    } else {
                        gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
                    }
                } else {
                    gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
                }
            } else {
                UserAssert((gfInNumpadHexInput & NUMPAD_HEXMODE_LL) == 0);
            }
        }
    }
}


#ifdef GENERIC_INPUT
#if defined(GI_SINK)

__inline VOID FillRawKeyboardInput(
    PHIDDATA pHidData,
    PKEYBOARD_INPUT_DATA pkei,
    UINT message,
    USHORT vkey)
{
    /*
     * Set the data.
     */
    pHidData->rid.data.keyboard.MakeCode = pkei->MakeCode;
    pHidData->rid.data.keyboard.Flags = pkei->Flags;
    pHidData->rid.data.keyboard.Reserved = pkei->Reserved;
    pHidData->rid.data.keyboard.Message = message;
    pHidData->rid.data.keyboard.VKey = vkey;
    pHidData->rid.data.keyboard.ExtraInformation = pkei->ExtraInformation;
}

BOOL PostRawKeyboardInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PKEYBOARD_INPUT_DATA pkei,
    UINT message,
    USHORT vkey)
{
    PPROCESS_HID_TABLE pHidTable = PtiKbdFromQ(pq)->ppi->pHidTable;
    PHIDDATA pHidData;
    PWND pwnd;
    WPARAM wParam = RIM_INPUT;

    if (pHidTable && pHidTable->fRawKeyboard) {
        PTHREADINFO pti;

        UserAssert(PtiKbdFromQ(pq)->ppi->pHidTable);
        pti = PtiKbdFromQ(pq);
        pwnd = pti->ppi->pHidTable->spwndTargetKbd;

        if (pwnd == NULL) {
            pwnd = pq->spwndFocus;
        } else {
            pq = GETPTI(pwnd)->pq;
        }

        if (TestRawInputModeNoCheck(pti, RawKeyboard)) {
            wParam = RIM_INPUT;
        }

        pHidData = AllocateHidData(hDevice, RIM_TYPEKEYBOARD, sizeof(RAWKEYBOARD), wParam, pwnd);

        UserAssert(pq);

        if (pHidData == NULL) {
            // failed to allocate
            RIPMSG0(RIP_WARNING, "PostRawKeyboardInput: failed to allocate HIDDATA.");
            return FALSE;
        }

        UserAssert(pkei);

        FillRawKeyboardInput(pHidData, pkei, message, vkey);

        if (!PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoHq(pHidData), dwTime, pkei->ExtraInformation)) {
            FreeHidData(pHidData);
        }
    }

#if DBG
    pHidData = NULL;
#endif

    if (IsKeyboardSinkPresent()) {
        /*
         * Walk through the global sink list.
         */
        PLIST_ENTRY pList = gHidRequestTable.ProcessRequestList.Flink;
        PPROCESSINFO ppiForeground = PtiKbdFromQ(pq)->ppi;

        for (; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
            PPROCESS_HID_TABLE pProcessHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);

            UserAssert(pProcessHidTable);
            if (pProcessHidTable->fRawKeyboardSink) {
                /*
                 * Sink is specified. Let's check out if it's the legid receiver.
                 */

                UserAssert(pProcessHidTable->spwndTargetKbd);   // shouldn't be NULL.

                if (pProcessHidTable->spwndTargetKbd == NULL ||
                        TestWF(pProcessHidTable->spwndTargetKbd, WFINDESTROY) ||
                        TestWF(pProcessHidTable->spwndTargetKbd, WFDESTROYED)) {
                    /*
                     * This guy doesn't have a legit spwndTarget or the window is
                     * halfly destroyed.
                     */
#ifdef LATER
                    pProcessHidTable->fRawKeyboard = pProcessHidTable->fRawKeyboardSink =
                        pProcessHidTable->fNoLegacyKeyboard = FALSE;
#endif
                    continue;
                }

                if (pProcessHidTable->spwndTargetKbd->head.rpdesk != grpdeskRitInput) {
                    /*
                     * This guy belongs to the other desktop, let's skip it.
                     */
                    continue;
                }

                if (GETPTI(pProcessHidTable->spwndTargetKbd)->ppi == ppiForeground) {
                    /*
                     * Should be already handled, let's skip it.
                     */
                    continue;
                }

                /*
                 * Let's post the message to this guy.
                 */
                pHidData = AllocateHidData(hDevice, RIM_TYPEKEYBOARD, sizeof(RAWKEYBOARD), RIM_INPUTSINK, pProcessHidTable->spwndTargetKbd);

                if (pHidData == NULL) {
                    RIPMSG1(RIP_WARNING, "PostInputMessage: failed to allocate HIDDATA for sink: %p", pProcessHidTable);
                    return FALSE;
                }

                FillRawKeyboardInput(pHidData, pkei, message, vkey);
                pwnd = pProcessHidTable->spwndTargetKbd;
                pq = GETPTI(pwnd)->pq;
                PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUTSINK, (LPARAM)PtoHq(pHidData), dwTime, pkei->ExtraInformation);
            }
        }
    }

    return TRUE;
}

#else   // GI_SINK

BOOL PostRawKeyboardInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PKEYBOARD_INPUT_DATA pkei,
    UINT message,
    USHORT vkey)
{
    PHIDDATA pHidData;
    PWND pwnd;

    UserAssert(PtiKbdFromQ(pq)->ppi->pHidTable);
    pwnd = PtiKbdFromQ(pq)->ppi->pHidTable->spwndTargetKbd;

    if (pwnd == NULL) {
        pwnd = pq->spwndFocus;
    } else {
        pq = GETPTI(pwnd)->pq;
    }

    pHidData = AllocateHidData(hDevice, RIM_TYPEKEYBOARD, sizeof(RAWKEYBOARD), RIM_INPUT, pwnd);

    UserAssert(pq);

    if (pHidData == NULL) {
        // failed to allocate
        RIPMSG0(RIP_WARNING, "PostRawKeyboardInput: failed to allocate HIDDATA.");
        return FALSE;
    }

    UserAssert(hDevice);
    UserAssert(pkei);

    /*
     * Set the data.
     */
    pHidData->rid.data.keyboard.MakeCode = pkei->MakeCode;
    pHidData->rid.data.keyboard.Flags = pkei->Flags;
    pHidData->rid.data.keyboard.Reserved = pkei->Reserved;
    pHidData->rid.data.keyboard.Message = message;
    pHidData->rid.data.keyboard.VKey = vkey;
    pHidData->rid.data.keyboard.ExtraInformation = pkei->ExtraInformation;

    PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoHq(pHidData), dwTime, pkei->ExtraInformation);

    return TRUE;
}

#endif  // GI_SINK

BOOL RawInputRequestedForKeyboard(PTHREADINFO pti)
{
#ifdef GI_SINK
    return IsKeyboardSinkPresent() || TestRawInputMode(pti, RawKeyboard);
#else
    return TestRawInputMode(pti, RawKeyboard);
#endif
}

#endif  // GENERIC_INPUT

/***************************************************************************\
* xxxKeyEvent (RIT)
*
* All events from the keyboard driver go here.  We receive a scan code
* from the driver and convert it to a virtual scan code and virtual
* key.
*
* The async keystate table and keylights are also updated here.  Based
* on the 'focus' window we direct the input to a specific window.  If
* the ALT key is down we send the events as WM_SYSKEY* messages.
*
* History:
* 10-18-90 DavidPe      Created.
* 11-13-90 DavidPe      WM_SYSKEY* support.
* 11-30-90 DavidPe      Added keylight updating support.
* 12-05-90 DavidPe      Added hotkey support.
* 03-14-91 DavidPe      Moved most lParam flag support to xxxCookMessage().
* 06-07-91 DavidPe      Changed to use gpqForeground rather than pwndFocus.
\***************************************************************************/

VOID xxxKeyEvent(
    USHORT    usFlaggedVk,
    WORD      wScanCode,
    DWORD     time,
    ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE    hDevice,
    PKEYBOARD_INPUT_DATA pkei,
#endif
    BOOL      bInjected)
{
    USHORT        message, usExtraStuff;
    BOOL          fBreak;
    BYTE          VkHanded;
    BYTE          Vk;
    TL            tlpwndActivate;
    DWORD         fsReserveKeys;
    static BOOL   fMakeAltUpASysKey;
    PHOOK         pHook;
    PTHREADINFO   ptiCurrent = PtiCurrent();
#ifdef GENERIC_INPUT
    PTHREADINFO   ptiKbd;   // N.b. needs revalidation every time
                            // it leaves the critsec.
    BOOL          fSASHandled = FALSE;
#endif

    CheckCritIn();

    fBreak = usFlaggedVk & KBDBREAK;
    SET_SRVIF(SRVIF_LASTRITWASKEYBOARD);

    /*
     * Is this a keyup or keydown event?
     */
    message = fBreak ? WM_KEYUP : WM_KEYDOWN;

    VkHanded = (BYTE)usFlaggedVk;    // get rid of state bits - no longer needed
    usExtraStuff = usFlaggedVk & KBDEXT;

    /*
     * Convert Left/Right Ctrl/Shift/Alt key to "unhanded" key.
     * ie: if VK_LCONTROL or VK_RCONTROL, convert to VK_CONTROL etc.
     * Update this "unhanded" key's state if necessary.
     */
    if ((VkHanded >= VK_LSHIFT) && (VkHanded <= VK_RMENU)) {
        BYTE VkOtherHand = VkHanded ^ 1;

        Vk = (BYTE)((VkHanded - VK_LSHIFT) / 2 + VK_SHIFT);
        if (!fBreak || !TestAsyncKeyStateDown(VkOtherHand)) {
            if ((gptiBlockInput == NULL) || (gptiBlockInput != ptiCurrent)) {
                UpdateAsyncKeyState(gpqForeground, Vk, fBreak);
            }
        }
    } else {
        Vk = VkHanded;
    }

    /*
     * Maintain gfsSASModifiersDown to indicate which of Ctrl/Shift/Alt
     * are really truly physically down
     */
    if (!bInjected && ((wScanCode & SCANCODE_SIMULATED) == 0)) {
        if (fBreak) {
            gfsSASModifiersDown &= ~VKTOMODIFIERS(Vk);
        } else {
            gfsSASModifiersDown |= VKTOMODIFIERS(Vk);
        }
    }

#ifdef GENERIC_INPUT
    ptiKbd = ValidatePtiKbd(gpqForeground);
#endif

    /*
     * Call low level keyboard hook to see if it allows this
     * message to pass
     */
    if ((pHook = PhkFirstValid(ptiCurrent, WH_KEYBOARD_LL)) != NULL) {
        KBDLLHOOKSTRUCT kbds;
        BOOL            bAnsiHook;
        USHORT          msg = message;
        USHORT          usExtraLL = usExtraStuff;

#ifdef GENERIC_INPUT
        UserAssert(GETPTI(pHook));
        if (ptiKbd && ptiKbd->ppi == GETPTI(pHook)->ppi) {
            // Skip LL hook call if the foreground application has
            // a LL keyboard hook and the raw input enabled
            // at the same time.
            if (TestRawInputMode(ptiKbd, RawKeyboard)) {
                goto skip_llhook;
            }
        }
#endif

        /*
         * Check if this is a WM_SYS* message
         */
        if (TestRawKeyDown(VK_MENU) &&
            !TestRawKeyDown(VK_CONTROL)) {

            msg += (WM_SYSKEYDOWN - WM_KEYDOWN);
            usExtraLL |= 0x2000;  // ALT key down
        }

        kbds.vkCode      = (DWORD)VkHanded;
        kbds.scanCode    = (DWORD)wScanCode;
        kbds.flags       = HIBYTE(usExtraLL | (bInjected ? (LLKHF_INJECTED << 8) : 0));
        kbds.flags      |= (fBreak ? (KBDBREAK >> 8) : 0);
        kbds.time        = time;
        kbds.dwExtraInfo = ExtraInfo;

        if (xxxCallHook2(pHook, HC_ACTION, (DWORD)msg, (LPARAM)&kbds, &bAnsiHook)) {

            UINT fsModifiers;

            /*
             * We can't let low level hooks or BlockInput() eat SAS
             * or someone could write a trojan winlogon look alike.
             */
            if (IsSAS(VkHanded, &fsModifiers)) {
                RIPMSG0(RIP_WARNING, "xxxKeyEvent: SAS ignore bad response from low level hook");
            } else {
                return;
            }
        }
    }

#ifdef GENERIC_INPUT
skip_llhook:
#endif

    /*
     * If someone is blocking input and it's not us, don't allow this input
     */
    if (gptiBlockInput && (gptiBlockInput != ptiCurrent)) {
        UINT fsModifiers;
        if (IsSAS(VkHanded, &fsModifiers)) {
            RIPMSG0(RIP_WARNING, "xxxKeyEvent: SAS unblocks BlockInput");
            gptiBlockInput = NULL;
        } else {
            return;
        }
    }

    UpdateAsyncKeyState(gpqForeground, VkHanded, fBreak);

    /*
     * Clear gfInNumpadHexInput if Menu key is up.
     */
    if (gfEnableHexNumpad && gpqForeground
#ifdef GENERIC_INPUT
        && !TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)
#endif
        ) {
        LowLevelHexNumpad(wScanCode, Vk, fBreak, usExtraStuff);
    }

    /*
     * If this is a make and the key is one linked to the keyboard LEDs,
     * update their state.
     */

    if (!fBreak &&
            ((Vk == VK_CAPITAL) || (Vk == VK_NUMLOCK) || (Vk == VK_SCROLL) ||
             (Vk == VK_KANA && JAPANESE_KBD_LAYOUT(GetActiveHKL())))) {
        /*
         * Only Japanese keyboard layout could generate VK_KANA.
         *
         * [Comments for before]
         *  Since NT 3.x, UpdatesKeyLisghts() had been called for VK_KANA
         * at both of 'make' and 'break' to support NEC PC-9800 Series
         * keyboard hardware, but for NT 4.0, thier keyboard driver emurate
         * PC/AT keyboard hardware, then this is changed to
         * "Call UpdateKeyLights() only at 'make' for VK_KANA"
         */
        UpdateKeyLights(bInjected);
    }

    /*
     * check for reserved keys
     */
    fsReserveKeys = 0;
    if (gptiForeground != NULL)
        fsReserveKeys = gptiForeground->fsReserveKeys;

    /*
     *  Check the RIT's queue to see if it's doing the cool switch thing.
     *  Cancel if the user presses any other key.
     */
    if (gspwndAltTab != NULL && (!fBreak) &&
            Vk != VK_TAB && Vk != VK_SHIFT && Vk != VK_MENU) {

        /*
         * Remove the Alt-tab window
         */
        xxxCancelCoolSwitch();

        /*
         * eat VK_ESCAPE if the app doesn't want it
         */
        if ((Vk == VK_ESCAPE) && !(fsReserveKeys & CONSOLE_ALTESC)) {
            return;
        }
    }

    /*
     * Check for hotkeys.
     */
    if (xxxDoHotKeyStuff(Vk, fBreak, fsReserveKeys)) {

#ifdef GENERIC_INPUT
        UINT fsModifiers;

        /*
         * Windows Bug 268903: DI folks want the DEL key reported
         * even though it's already handled --- for the compatibility
         * with the LL hook.
         */
        if (IsSAS(VkHanded, &fsModifiers)) {
            fSASHandled = TRUE;
        } else {
#endif
            /*
             * The hotkey was processed so don't pass on the event.
             */
            return;
#ifdef GENERIC_INPUT
        }
#endif
    }

#ifdef GENERIC_INPUT
    /*
     * If the foreground thread wants RawInput, post it here.
     */

    ptiKbd = ValidatePtiKbd(gpqForeground);

    if (pkei && ptiKbd && RawInputRequestedForKeyboard(ptiKbd)) {
        DWORD msg = message;
#if POST_EXTRALL
        DWORD usExtraLL = usExtraStuff;
#endif

        /*
         * Check if this is a WM_SYS* message
         */
        if (TestRawKeyDown(VK_MENU) &&
            !TestRawKeyDown(VK_CONTROL)) {

            msg += (WM_SYSKEYDOWN - WM_KEYDOWN);
#if POST_EXTRA_LL
            usExtraLL |= 0x2000;  // ALT key down
#endif
        }

        TAGMSG3(DBGTAG_PNP, "xxxKeyEvent: posting to pwnd=%#p, vk=%02x, flag=%04x", gpqForeground->spwndFocus, Vk, pkei->Flags);
        PostRawKeyboardInput(gpqForeground, time, hDevice, pkei, msg, (USHORT)Vk);
    }

    /*
     * If SAS key is handled, this is a special case, just bail out.
     */
    if (fSASHandled) {
        return;
    }

    /*
     * If the foreground thread does not want the legacy input, bail out.
     */
    if (ptiKbd) {
        if (VkHanded == 0) {
            TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: vkHanded is zero, bail out.");
            return;
        }

        if (TestRawInputMode(ptiKbd, NoLegacyKeyboard)) {
            if (Vk == VK_MENU || Vk == VK_TAB || gspwndAltTab != NULL) {
                /*
                 * Special case for fast switching. We should always
                 * handle these hotkeys.
                 */
                TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: we'll do Alt+Tab even if the FG thread requests NoLegacy");
            } else if ((TestRawInputMode(ptiKbd, AppKeys)) &&
                       (Vk >= VK_APPCOMMAND_FIRST && Vk <= VK_APPCOMMAND_LAST)) {
                TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: we'll do app commands if the FG thread requests NoLegacy and AppKeys");
            } else {
                TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: FG thread doen't want legacy kbd. bail out");
                return;
            }
        }
    }

#endif  // GENERIC_INPUT

    /*
     * If the ALT key is down and the CTRL key
     * isn't, this is a WM_SYS* message.
     */
    if (TestAsyncKeyStateDown(VK_MENU) && !TestAsyncKeyStateDown(VK_CONTROL) && Vk != VK_JUNJA) {
        // VK_JUNJA is ALT+'+'. Since all KOR VKs are not converted to IME hotkey IDs and
        // should be passed directly to IME, KOR related VKs are not treated as SYSKEYDOWN.
        message += (WM_SYSKEYDOWN - WM_KEYDOWN);
        usExtraStuff |= 0x2000;

        /*
         * If this is the ALT-down set this flag, otherwise
         * clear it since we got a key inbetween the ALT-down
         * and ALT-up.  (see comment below)
         */
        if (Vk == VK_MENU) {
            fMakeAltUpASysKey = TRUE;
            /*
             * Unlock SetForegroundWindow (if locked) when the ALT key went down.
             */
            if (!fBreak) {
                gppiLockSFW = NULL;
            }
        } else {
            fMakeAltUpASysKey = FALSE;
        }

    } else if (Vk == VK_MENU) {
        if (fBreak) {
            /*
             * End our switch if we are in the middle of one.
             */
            if (fMakeAltUpASysKey) {

               /*
                * We don't make the keyup of the ALT key a WM_SYSKEYUP if any
                * other key is typed while the ALT key was down.  I don't know
                * why we do this, but it's been here since version 1 and any
                * app that uses SDM relies on it (eg - opus).
                *
                * The Alt bit is not set for the KEYUP message either.
                */
               message += (WM_SYSKEYDOWN - WM_KEYDOWN);
           }

           if (gspwndAltTab != NULL) {

               /*
                * Send the alt up message before we change queues
                */
               if (gpqForeground != NULL) {
#ifdef GENERIC_INPUT
                    if (!TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)) {
#endif
                        /*
                         * Set this flag so that we know we're doing a tab-switch.
                         * This makes sure that both cases where the ALT-KEY is released
                         * before or after the TAB-KEY is handled.  It is checked in
                         * xxxDefWindowProc().
                         */
                        gpqForeground->QF_flags |= QF_TABSWITCHING;

                        PostInputMessage(gpqForeground, NULL, message, (DWORD)Vk,
                               MAKELONG(1, (wScanCode | usExtraStuff)),
                               time, ExtraInfo);
#ifdef GENERIC_INPUT
                    }
#endif
               }

               /*
                * Remove the Alt-tab window
                */
               xxxCancelCoolSwitch();

               if (gspwndActivate != NULL) {
                   /*
                    * Make our selected window active and destroy our
                    * switch window.  If the new window is minmized,
                    * restore it.  If we are switching in the same
                    * queue, we clear out gpqForeground to make
                    * xxxSetForegroundWindow2 to change the pwnd
                    * and make the switch.  This case will happen
                    * with WOW and Console apps.
                    */
                   if (gpqForeground == GETPTI(gspwndActivate)->pq) {
                       gpqForeground = NULL;
                   }

                   /*
                    * Make the selected window thread the owner of the last input;
                    *  since the user has selected him, he owns the ALT-TAB.
                    */
                   glinp.ptiLastWoken = GETPTI(gspwndActivate);


                   ThreadLockAlways(gspwndActivate, &tlpwndActivate);
                   xxxSetForegroundWindow2(gspwndActivate, NULL,
                           SFW_SWITCH | SFW_ACTIVATERESTORE);
                   /*
                    * Win3.1 calls SetWindowPos() with activate, which z-orders
                    * first regardless, then activates. Our code relies on
                    * xxxActivateThisWindow() to z-order, and it'll only do
                    * it if the window does not have the child bit set (regardless
                    * that the window is a child of the desktop).
                    *
                    * To be compatible, we'll just force z-order here if the
                    * window has the child bit set. This z-order is asynchronous,
                    * so this'll z-order after the activate event is processed.
                    * That'll allow it to come on top because it'll be foreground
                    * then. (Grammatik has a top level window with the child
                    * bit set that wants to be come the active window).
                    */
                   if (TestWF(gspwndActivate, WFCHILD)) {
                       xxxSetWindowPos(gspwndActivate, (PWND)HWND_TOP, 0, 0, 0, 0,
                               SWP_NOSIZE | SWP_NOMOVE | SWP_ASYNCWINDOWPOS);
                   }
                   ThreadUnlock(&tlpwndActivate);

                   Unlock(&gspwndActivate);
               }
               return;
           }
        } else {
            /*
             * The ALT key is down, unlock SetForegroundWindow (if locked)
             */
            gppiLockSFW = NULL;
        }
    }

    /*
     * Handle switching.  Eat the Key if we are doing switching.
     */
    if (!FJOURNALPLAYBACK() && !FJOURNALRECORD() && (!fBreak) &&
            (TestAsyncKeyStateDown(VK_MENU)) &&
            (!TestAsyncKeyStateDown(VK_CONTROL)) && //gpqForeground &&
            (((Vk == VK_TAB) && !(fsReserveKeys & CONSOLE_ALTTAB)) ||
            ((Vk == VK_ESCAPE) && !(fsReserveKeys & CONSOLE_ALTESC)))) {

            xxxNextWindow(gpqForeground ? gpqForeground : gptiRit->pq, Vk);

    } else if (gpqForeground != NULL) {
        PQMSG pqmsgPrev = gpqForeground->mlInput.pqmsgWriteLast;
        DWORD wParam = (DWORD)Vk;
        LONG lParam;

#ifdef GENERIC_INPUT
        if (TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)) {
            if (!TestRawInputMode(PtiKbdFromQ(gpqForeground), AppKeys) ||
                !(Vk >= VK_APPCOMMAND_FIRST && Vk <= VK_APPCOMMAND_LAST)) {
            return;
            }
        }
#endif

        /*
         * We have a packet containing a Unicode character
         * This is injected by Pen via SendInput
         */
        if ((Vk == VK_PACKET) && (usFlaggedVk & KBDUNICODE)) {
            wParam |= (wScanCode << 16);
            wScanCode = 0;
        }
        lParam = MAKELONG(1, (wScanCode | usExtraStuff));

        /*
         * WM_*KEYDOWN messages are left unchanged on the queue except the
         * repeat count field (LOWORD(lParam)) is incremented.
         */
        if (pqmsgPrev != NULL &&
                pqmsgPrev->msg.message == message &&
                (message == WM_KEYDOWN || message == WM_SYSKEYDOWN) &&
                pqmsgPrev->msg.wParam == wParam &&
                HIWORD(pqmsgPrev->msg.lParam) == HIWORD(lParam)) {
#ifdef GENERIC_INPUT
            /*
             * We shouldn't be here for a generic input keyboard that
             * doesn't want legacy support.
             */
            UserAssert(!TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard));
#endif
            /*
             * Increment the queued message's repeat count.  This could
             * conceivably overflow but Win 3.0 doesn't deal with it
             * and anyone who buffers up 65536 keystrokes is a chimp
             * and deserves to have it wrap anyway.
             */
            pqmsgPrev->msg.lParam = MAKELONG(LOWORD(pqmsgPrev->msg.lParam) + 1,
                    HIWORD(lParam));

            WakeSomeone(gpqForeground, message, pqmsgPrev);

        } else {
            /*
             * check if these are speedracer keys - bug 339877
             * for the speedracer keys we want to post an event message and generate the
             * wm_appcommand in xxxprocesseventmessage
             * Since SpeedRacer software looks for the hotkeys we want to let those through
             * It is going in here since we don't want the ability to eat up tons of pool memory
             * so we post the event message here and then post the input message for the wm_keydown
             * below - that way if the key is repeated then there is coalescing done above and no more
             * qevent_appcommands are posted to the input queue.
             */
            if (VK_APPCOMMAND_FIRST <= Vk && Vk <= VK_APPCOMMAND_LAST) {
                /*
                 * Only send wm_appcommands for wm_keydown (& wm_syskeydown) messages -
                 * essentially we ignore wm_keyup for those vk's defined for wm_appcommand messages
                 */
                if (!fBreak && gpqForeground) {
                    /*
                     * post an event message so we can syncronize with normal types of input
                     * send through the vk - we will construct the message in xxxProcessEventMessage
                     */
                    PostEventMessage(gpqForeground->ptiKeyboard, gpqForeground, QEVENT_APPCOMMAND,
                                     NULL, 0, (WPARAM)0, Vk);
                }
#ifdef GENERIC_INPUT
                if (TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)) {
                    return;
                }
#endif
            }
            /*
             * We let the key go through since we want wm_keydowns/ups to get generated for these
             * SpeedRacer keys
             */

            if (gpqForeground->QF_flags & QF_MOUSEMOVED) {
                PostMove(gpqForeground);
            }

            PostInputMessage(gpqForeground, NULL, message, wParam,
                    lParam, time, ExtraInfo);
        }
    }
}

/**************************************************************************\
* GetMouseCoord
*
* Calculates the coordinates of the point that will be injected.
*
* History:
* 11-01-96 CLupu     Created.
* 12-18-97 MCostea   MOUSE_VIRTUAL_DESKTOP support
\**************************************************************************/
VOID GetMouseCoord(
    LONG   dx,
    LONG   dy,
    DWORD  dwFlags,
    LONG   time,
    ULONG_PTR  ExtraInfo,
    PPOINT ppt)
{
    if (dwFlags & MOUSE_MOVE_ABSOLUTE) {

        LONG cxMetric, cyMetric;

        /*
         * If MOUSE_VIRTUAL_DESKTOP was specified, map to entire virtual screen
         */
        if (dwFlags & MOUSE_VIRTUAL_DESKTOP) {
            cxMetric = SYSMET(CXVIRTUALSCREEN);
            cyMetric = SYSMET(CYVIRTUALSCREEN);
        } else {
            cxMetric = SYSMET(CXSCREEN);
            cyMetric = SYSMET(CYSCREEN);
        }

        /*
         * Absolute pointing device used: deltas are actually the current
         * position.  Update the global mouse position.
         *
         * Note that the position is always reported in units of
         * (0,0)-(0xFFFF,0xFFFF) which corresponds to
         * (0,0)-(SYSMET(CXSCREEN), SYSMET(CYSCREEN)) in pixels.
         * We must first scale it to fit on the screen using the formula:
         *     ptScreen = ptMouse * resPrimaryMonitor / 64K
         *
         * The straightforward algorithm coding of this algorithm is:
         *
         *     ppt->x = (dx * SYSMET(CXSCREEN)) / (long)0x0000FFFF;
         *     ppt->y = (dy * SYSMET(CYSCREEN)) / (long)0x0000FFFF;
         *
         * On x86, with 14 more bytes we can avoid the division function with
         * the following code.
         */

        ppt->x = dx * cxMetric;
        if (ppt->x >= 0) {
            ppt->x = HIWORD(ppt->x);
        } else {
            ppt->x = - (long) HIWORD(-ppt->x);
        }

        ppt->y = dy * cyMetric;
        if (ppt->y >= 0) {
            ppt->y = HIWORD(ppt->y);
        } else {
            ppt->y = - (long) HIWORD(-ppt->y);
        }

        /*
         * (0, 0) must map to the leftmost point on the desktop
         */
        if (dwFlags & MOUSE_VIRTUAL_DESKTOP) {
            ppt->x +=  SYSMET(XVIRTUALSCREEN);
            ppt->y +=  SYSMET(YVIRTUALSCREEN);
        }

        /*
         * Reset the mouse sensitivity remainder.
         */
        idxRemainder = idyRemainder = 0;

        /*
         * Save the absolute coordinates in the global array
         * for GetMouseMovePointsEx.
         */
        SAVEPOINT(dx, dy, 0xFFFF, 0xFFFF, time, ExtraInfo);
    } else {
        /*
         * Is there any mouse acceleration to do?
         */
        if (gMouseSpeed != 0) {
#ifdef SUBPIXEL_MOUSE
            DoNewMouseAccel(&dx, &dy);
#else
            dx = DoMouseAccel(dx);
            dy = DoMouseAccel(dy);
#endif
        } else if (gMouseSensitivity != MOUSE_SENSITIVITY_DEFAULT) {
            int iNumerator;

            /*
             * Does the mouse sensitivity need to be adjusted?
             */

            if (dx != 0) {
                iNumerator   = dx * gMouseSensitivityFactor + idxRemainder;
                dx           = iNumerator / 256;
                idxRemainder = iNumerator % 256;
                if ((iNumerator < 0) && (idxRemainder > 0)) {
                    dx++;
                    idxRemainder -= 256;
                }
            }

            if (dy != 0) {
                iNumerator   = dy * gMouseSensitivityFactor + idyRemainder;
                dy           = iNumerator / 256;
                idyRemainder = iNumerator % 256;
                if ((iNumerator < 0) && (idyRemainder > 0)) {
                    dy++;
                    idyRemainder -= 256;
                }
            }
        }

        ppt->x += dx;
        ppt->y += dy;

        /*
         * Save the absolute coordinates in the global array
         * for GetMouseMovePointsEx.
         */
        SAVEPOINT(ppt->x, ppt->y,
                  SYSMET(CXVIRTUALSCREEN) - 1, SYSMET(CYVIRTUALSCREEN) - 1,
                  time, ExtraInfo);
    }
}

/***************************************************************************\
* xxxMoveEventAbsolute (RIT)
*
* Mouse move events from the mouse driver are processed here.  If there is a
* mouse owner window setup from xxxButtonEvent() the event is automatically
* sent there, otherwise it's sent to the window the mouse is over.
*
* Mouse acceleration happens here as well as cursor clipping (as a result of
* the ClipCursor() API).
*
* History:
* 10-18-90 DavidPe     Created.
* 11-29-90 DavidPe     Added mouse acceleration support.
* 01-25-91 IanJa       xxxWindowHitTest change
*          IanJa       non-jerky mouse moves
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxMoveEventAbsolute)
#endif

VOID xxxMoveEventAbsolute(
    LONG         x,
    LONG         y,
    ULONG_PTR    dwExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    DWORD        time,
    BOOL         bInjected
    )
{
    LONG ulMoveFlags = MP_NORMAL;
    CheckCritOut();

    if (IsHooked(gptiRit, WHF_FROM_WH(WH_MOUSE_LL))) {
        MSLLHOOKSTRUCT mslls;
        BOOL           bEatEvent = FALSE;
        BOOL           bAnsiHook;
        PHOOK pHook;

        mslls.pt.x        = x;
        mslls.pt.y        = y;
        mslls.mouseData   = 0;
        mslls.flags       = bInjected;
        mslls.time        = time;
        mslls.dwExtraInfo = dwExtraInfo;

        /*
         * Call low level mouse hooks to see if they allow this message
         * to pass through USER
         */

        EnterCrit();

        /*
         * Check again to see if we still have the hook installed. Fix for 80477.
         */
        if ((pHook = PhkFirstValid(gptiRit, WH_MOUSE_LL)) != NULL) {
            PTHREADINFO ptiCurrent;

            bEatEvent = (xxxCallHook2(pHook, HC_ACTION, WM_MOUSEMOVE, (LPARAM)&mslls, &bAnsiHook) != 0);
            ptiCurrent = PtiCurrent();
            if (ptiCurrent->pcti->fsChangeBits & ptiCurrent->pcti->fsWakeMask & ~QS_SMSREPLY) {
                RIPMSG1(RIP_WARNING, "xxxMoveEventAbsolute: applying changed wake bits (0x%x) during the LL hook callback",
                        ptiCurrent->pcti->fsChangeBits & ~QS_SMSREPLY);
                SetWakeBit(ptiCurrent, ptiCurrent->pcti->fsChangeBits & ~QS_SMSREPLY);
            }

        }

        LeaveCrit();

        if (bEatEvent) {
            return;
        }
    }

#ifdef GENERIC_INPUT
    if (pmei && gpqForeground && RawInputRequestedForMouse(PtiMouseFromQ(gpqForeground))) {
        EnterCrit();

        PostRawMouseInput(gpqForeground, time, hDevice, pmei);
        LeaveCrit();
    }
#endif

    /*
     * Blow off the event if WH_JOURNALPLAYBACK is installed.  Do not
     * use FJOURNALPLAYBACK() because this routine may be called from
     * multiple desktop threads and the hook check must be done
     * for the rit thread, not the calling thread.
     */
    if (IsGlobalHooked(gptiRit, WHF_FROM_WH(WH_JOURNALPLAYBACK))) {
        return;
    }

    /*
     * For the atomicness of monitor. Let's bail out while the monitor
     * is being updated by the other thread.
     */
    if (InterlockedCompareExchange(&gdwMonitorBusy, TRUE, FALSE) != FALSE) {
        RIPMSGF0(RIP_VERBOSE, "the monitor info is being updated. We have to bail out here");
        return;
    }

    gptCursorAsync.x = x;
    gptCursorAsync.y = y;

    BoundCursor(&gptCursorAsync);

    /*
     * Move the screen pointer.
     * Pass an event source parameter as the flags so that TS
     * can correctly send a mouse update to the client if the mouse
     * move is originating from a shadow client or if the move is injected.
     */
#ifdef GENERIC_INPUT
    if (pmei && (pmei->Flags & MOUSE_TERMSRV_SRC_SHADOW)) {
        ulMoveFlags = MP_TERMSRV_SHADOW;
    }
    else if (bInjected) {
        ulMoveFlags = MP_PROCEDURAL;
    }
#endif
    GreMovePointer(gpDispInfo->hDev, gptCursorAsync.x, gptCursorAsync.y,
                   ulMoveFlags);


    /*
     * Save the time stamp in a global so we can use it in PostMove
     */
    gdwMouseMoveTimeStamp = time;

    /*
     * Reset the locking, so that the pMonitor update can continue
     */
    UserAssert(gdwMonitorBusy == TRUE);
    InterlockedExchange(&gdwMonitorBusy, FALSE);

    /*
     * Set the number of trails to hide to gMouseTrails + 1 to avoid calling
     * GreMovePointer while the mouse is moving, look at HideMouseTrails().
     */
    if (GETMOUSETRAILS()) {
        InterlockedExchange(&gMouseTrailsToHide, gMouseTrails + 1);
    }

}


/***************************************************************************\
* xxxMoveEvent (RIT)
*
* The dwFlags can be
*   0 relative move
*   MOUSEEVENTF_ABSOLUTE absolute move
*   MOUSEEVENTF_VIRTUALDESK the absolute coordinates will be maped
*   to the entire virtual desktop.  This flag makes sense only with MOUSEEVENTF_ABSOLUTE
*
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxMoveEvent)
#endif

VOID xxxMoveEvent(
    LONG         dx,
    LONG         dy,
    DWORD        dwFlags,
    ULONG_PTR    dwExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    DWORD        time,
    BOOL         bInjected)
{
    POINT ptLastMove = gptCursorAsync;

    CheckCritOut();

    /*
     * Get the actual point that will be injected.
     */
    GetMouseCoord(dx, dy, ConvertToMouseDriverFlags(dwFlags),
                  time, dwExtraInfo, &ptLastMove);

    /*
     * move the mouse
     */
    xxxMoveEventAbsolute(
            ptLastMove.x,
            ptLastMove.y,
            dwExtraInfo,
#ifdef GENERIC_INPUT
            hDevice,
            pmei,
#endif
            time,
            bInjected);
}


/***************************************************************************\
* UpdateRawKeyState
*
* A helper routine for ProcessKeyboardInput.
* Based on a VK and a make/break flag, this function will update the physical
* keystate table.
*
* History:
* 10-13-91 IanJa        Created.
\***************************************************************************/
VOID UpdateRawKeyState(
    BYTE Vk,
    BOOL fBreak)
{
    CheckCritIn();

    if (fBreak) {
        ClearRawKeyDown(Vk);
    } else {

        /*
         * This is a key make.  If the key was not already down, update the
         * physical toggle bit.
         */
        if (!TestRawKeyDown(Vk)) {
            ToggleRawKeyToggle(Vk);
        }

        /*
         * This is a make, so turn on the physical key down bit.
         */
        SetRawKeyDown(Vk);
    }
}


VOID CleanupResources(
    VOID)
{
    PPCLS       ppcls;
    PTHREADINFO pti;

    UserAssert(!gbCleanedUpResources);

    gbCleanedUpResources = TRUE;

    HYDRA_HINT(HH_CLEANUPRESOURCES);

    /*
     * Prevent power callouts.
     */
    CleanupPowerRequestList();

    /*
     * Destroy the system classes also
     */
    ppcls = &gpclsList;
    while (*ppcls != NULL) {
        DestroyClass(ppcls);
    }

    /*
     * Unlock the cursor from all the CSRSS's threads.
     * We do this here because RIT might not be the only
     * CSRSS process running at this time and we want
     * to prevent the change of thread ownership
     * after RIT is gone.
     */
    pti = PpiCurrent()->ptiList;

    while (pti != NULL) {

        if (pti->pq != NULL) {
            LockQCursor(pti->pq, NULL);
        }
        pti = pti->ptiSibling;
    }

    UnloadCursorsAndIcons();

    /*
     * Cleanup the GDI globals in USERK
     */
    CleanupGDI();
}

#if 0    // Temporariry

typedef struct _EX_RUNDOWN_WAIT_BLOCK {
    ULONG Count;
    KEVENT WakeEvent;
} EX_RUNDOWN_WAIT_BLOCK, *PEX_RUNDOWN_WAIT_BLOCK;


//NTKERNELAPI
VOID
FASTCALL
__ExWaitForRundownProtectionRelease (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Wait till all outstanding rundown protection calls have exited

Arguments:

    RunRef - Pointer to a rundown structure

Return Value:

    None

--*/
{
    EX_RUNDOWN_WAIT_BLOCK WaitBlock;
    PKEVENT Event;
    ULONG_PTR Value, NewValue;
    ULONG WaitCount;
#if 1
    LARGE_INTEGER liTimeout;
    NTSTATUS Status;
    ULONG counter;
#endif

    PAGED_CODE ();

    //
    // Fast path. this should be the normal case. If Value is zero then there are no current accessors and we have
    // marked the rundown structure as rundown. If the value is EX_RUNDOWN_ACTIVE then the structure has already
    // been rundown and ExRundownCompleted. This second case allows for callers that might initiate rundown
    // multiple times (like handle table rundown) to have subsequent rundowns become noops.
    //

    Value = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                           (PVOID) EX_RUNDOWN_ACTIVE,
                                                           (PVOID) 0);
    if (Value == 0 || Value == EX_RUNDOWN_ACTIVE) {
#if 1
        RIPMSG1(RIP_WARNING, "__ExWaitForRundownProtectionRelease: rundown finished in session %d", gSessionId);
#endif
        return;
    }

    //
    // Slow path
    //
    Event = NULL;
#if 1
    counter = 0;
#endif
    do {

        //
        // Extract total number of waiters. Its biased by 2 so we can hanve the rundown active bit.
        //
        WaitCount = (ULONG) (Value >> EX_RUNDOWN_COUNT_SHIFT);

        //
        // If there are some accessors present then initialize and event (once only).
        //
        if (WaitCount > 0 && Event == NULL) {
            Event = &WaitBlock.WakeEvent;
            KeInitializeEvent (Event, SynchronizationEvent, FALSE);
        }
        //
        // Store the wait count in the wait block. Waiting threads will start to decrement this as they exit
        // if our exchange succeeds. Its possible for accessors to come and go between our initial fetch and
        // the interlocked swap. This doesn't matter so long as there is the same number of outstanding accessors
        // to wait for.
        //
        WaitBlock.Count = WaitCount;

        NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            if (WaitCount > 0) {
#if 1
                /*
                 * NT Base calls take time values in 100 nanosecond units.
                 * Make it relative (negative)...
                 * Timeout in 20 minutes.
                 */
                liTimeout.QuadPart = Int32x32To64(-10000, 300000 * 4);
                Status = KeWaitForSingleObject (Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       &liTimeout);

                if (Status == STATUS_TIMEOUT) {
                    FRE_RIPMSG1(RIP_ERROR, "__ExWaitForRundownProtectionRelease: Rundown wait time out in session %d", gSessionId);
                }
#endif

                ASSERT (WaitBlock.Count == 0);

            }
            return;
        }
        Value = NewValue;

        ASSERT ((Value&EX_RUNDOWN_ACTIVE) == 0);

#if 1
#define THRESHOLD   (50000)
        if (++counter > THRESHOLD) {
            FRE_RIPMSG2(RIP_ERROR, "__ExWaitForRundownProtectionRelease: Rundown wait loop over %d in session %d", THRESHOLD, gSessionId);
            counter = 0;
        }
#endif
    } while (TRUE);
}
#endif

VOID WaitForWinstaRundown(
    PKEVENT pRundownEvent)
{
    if (pRundownEvent) {
        KeSetEvent(pRundownEvent, EVENT_INCREMENT, FALSE);
    }

    /*
     * Wait for any WindowStation objects to get freed.
     */

#if 0
    /*
      * HACK ALERT!
      * Tentatively, we call our own copy of WaitForRundown
      * to let it timeout in the target session.
      */
    __ExWaitForRundownProtectionRelease(&gWinstaRunRef);
#endif

    ExWaitForRundownProtectionRelease(&gWinstaRunRef);
    ExRundownCompleted (&gWinstaRunRef);
}

VOID SetWaitForWinstaRundown(
    VOID)
{
    OBJECT_ATTRIBUTES   obja;
    NTSTATUS            Status;
    HANDLE              hProcess = NULL;
    HANDLE              hThreadWinstaRundown = NULL;
    PKEVENT             pRundownEvent = NULL;

    pRundownEvent = CreateKernelEvent(SynchronizationEvent, FALSE);

    InitializeObjectAttributes(&obja,
                               NULL,
                               0,
                               NULL,
                               NULL);

    UserAssert(gpepCSRSS != NULL);

    Status = ObOpenObjectByPointer(
                 gpepCSRSS,
                 0,
                 NULL,
                 PROCESS_CREATE_THREAD,
                 NULL,
                 KernelMode,
                 &hProcess);

    if (!NT_SUCCESS(Status)) {
        goto ExitClean;
    }

    UserAssert(hProcess != NULL);


    Status = PsCreateSystemThread(
                    &hThreadWinstaRundown,
                    THREAD_ALL_ACCESS,
                    &obja,
                    hProcess,
                    NULL,
                    (PKSTART_ROUTINE)WaitForWinstaRundown,
                    pRundownEvent);
    if (!NT_SUCCESS(Status)) {
        goto ExitClean;
    }

    if (pRundownEvent) {
        KeWaitForSingleObject(pRundownEvent, WrUserRequest,
                KernelMode, FALSE, NULL);
    } else {
        UserSleep(100);
    }

ExitClean:
    if (pRundownEvent) {
        FreeKernelEvent(&pRundownEvent);
    }

    if (hProcess) {
        ZwClose(hProcess);
    }

    if (hThreadWinstaRundown) {
        ZwClose(hThreadWinstaRundown);
    }
}

/***************************************************************
* NumHandles
*
* This function returns the number of handles of an Ob Object.
*
* History:
* 03/29/2001    MohamB    Created.
****************************************************************/
ULONG NumHandles(
    HANDLE hObjectHandle)
{
    NTSTATUS        Status;
    OBJECT_BASIC_INFORMATION Obi;

    if (hObjectHandle != NULL) {
        Status = ZwQueryObject(hObjectHandle,
                               ObjectBasicInformation,
                               &Obi,
                               sizeof (OBJECT_BASIC_INFORMATION),
                               NULL);
        if (Status == STATUS_SUCCESS) {
            if (Obi.HandleCount > 1) {
               HYDRA_HINT(HH_DTWAITONHANDLES);
            }
            return Obi.HandleCount;
        }
    }

    return 0;
}


/***************************************************************************\
* InitiateWin32kCleanup (RIT)
*
* This function starts the cleanup of a win32k
*
* History:
* 04-Dec-97 clupu      Created.
\***************************************************************************/
BOOL InitiateWin32kCleanup(
    VOID)
{
    PTHREADINFO     ptiCurrent;
    PWINDOWSTATION  pwinsta;
    BOOLEAN         fWait = TRUE;
    PDESKTOP        pdesk;
    UNICODE_STRING  ustrName;
    WCHAR           szName[MAX_SESSION_PATH];
    HANDLE          hevtRitExited;
    OBJECT_ATTRIBUTES obja;
    NTSTATUS        Status;
    LARGE_INTEGER   timeout;
    NTSTATUS        Reason;
    BOOL            fFirstTimeout = TRUE;

    TRACE_HYDAPI(("InitiateWin32kCleanup\n"));

    TAGMSG0(DBGTAG_RIT, "Exiting Win32k ...");

    SetWaitForWinstaRundown();

    /*
     * Prevent power callouts.
     */
    CleanupPowerRequestList();

    /*
     * Unregister Device notifications for sessions attached to Physical Console
     * We already do this during Session disconnection -- but if disconnect fails, we leak notifications which is not good
     */
    if (!IsRemoteConnection()) {
        /*
         * Cleanup device class notifications
         */
        xxxUnregisterDeviceClassNotifications();
    }

    EnterCrit();

    gbCleanupInitiated = TRUE;

    HYDRA_HINT(HH_INITIATEWIN32KCLEANUP);

    ptiCurrent = PtiCurrent();

    UserAssert(ptiCurrent != NULL);

    pwinsta = ptiCurrent->pwinsta;

    /*
     * Give DTs 5 minutes to go away
     */
    timeout.QuadPart = Int32x32To64(-10000, 600000);

    /*
     * Wait for all desktops to exit other than the disconnected desktop.
     */
    while (fWait) {

        /*
         * If things are left on the destroy list or the disconnected desktop is
         * not the current desktop (at the end we should always switch to the
         * disconnected desktop), then wait.
         */
        if (pwinsta == NULL) {
            break;
        }

        pdesk = pwinsta->rpdeskList;

        if (pdesk == NULL) {
            break;
        }

        fWait = pdesk != gspdeskDisconnect
                 || pdesk->rpdeskNext != NULL
                 || pwinsta->pTerm->rpdeskDestroy != NULL
                 || NumHandles(ghDisconnectDesk) > 1;

        if (fWait) {

            LeaveCrit();

            Reason = KeWaitForSingleObject(gpevtDesktopDestroyed, WrUserRequest,
                                           KernelMode, FALSE, &timeout);

            if (Reason == STATUS_TIMEOUT) {
#if 0

                /*
                 * The first time we timeout might be because winlogon died
                 * before calling ExitWindowsEx. In that case there may be processes
                 * w/ GUI threads running and those threads will have an hdesk
                 * in the THREADINFO structure. Thus the desktop threads will not exit.
                 * In this situation we signal the event 'EventRitStuck' so that
                 * csrss can tell termsrv to start killing the remaining processes
                 * calling NtTerminateProcess on them. csrss signals that to termsrv
                 * by closing the LPC port in ntuser\server\api.c (W32WinStationTerminate)
                 */

                if (fFirstTimeout) {

                    HANDLE hevtRitStuck;

                    FRE_RIPMSG0(RIP_ERROR,
                            "Timeout in RIT waiting for gpevtDesktopDestroyed. Signal EventRitStuck...");

                    swprintf(szName, L"\\Sessions\\%ld\\BaseNamedObjects\\EventRitStuck",
                             gSessionId);

                    RtlInitUnicodeString(&ustrName, szName);

                    InitializeObjectAttributes(&obja,
                                               &ustrName,
                                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                               NULL,
                                               NULL);

                    Status = ZwCreateEvent(&hevtRitStuck,
                                           EVENT_ALL_ACCESS,
                                           &obja,
                                           SynchronizationEvent,
                                           FALSE);

                    UserAssert((! gbRemoteSession) || NT_SUCCESS(Status));

                    if (NT_SUCCESS(Status)) {
                        ZwSetEvent(hevtRitStuck, NULL);
                        ZwClose(hevtRitStuck);

                        fFirstTimeout = FALSE;
                    }

                } else {
                    FRE_RIPMSG0(RIP_WARNING,
                            "Timeout in RIT waiting for gpevtDesktopDestroyed.\n"
                            "There are still GUI threads (assigned to a desktop) running !");
                }

                RIPMSG0(RIP_WARNING,
                        "Timeout in RIT waiting for gpevtDesktopDestroyed. Signal EventRitStuck...");
                {
                    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
                    NTSTATUS Status;

                    Status = ZwQuerySystemInformation(SystemKernelDebuggerInformation,
                            &KernelDebuggerInfo, sizeof(KernelDebuggerInfo), NULL);
                    if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)
                         DbgBreakPoint();
                }
#endif
            }

            EnterCrit();
        }
    }
    TAGMSG0(DBGTAG_RIT, "All other desktops exited...");

    Unlock(&gspwndLogonNotify);

    /*
     * Set ExitInProgress -- this will prevent us from posting any
     * device reads in the future.
     */
    gbExitInProgress = TRUE;

    TAGMSG2(DBGTAG_RIT, "Shutting down ptiCurrent %lx cWindows %d",
           ptiCurrent, ptiCurrent->cWindows);

    /*
     * Clear out some values so some operations won't be possible.
     */
    gpqCursor = NULL;
    UserAssert(gspwndScreenCapture == NULL);
    Unlock(&gspwndMouseOwner);
    UserAssert(gspwndMouseOwner == NULL);
    UserAssert(gspwndInternalCapture == NULL);

    /*
     * Free any SPBs.
     */
    if (gpDispInfo) {
        FreeAllSpbs();
    }

    /*
     * Close the disconnected desktop.
     */
    if (ghDisconnectWinSta) {
        UserVerify(NT_SUCCESS(ZwClose(ghDisconnectWinSta)));
        ghDisconnectWinSta = NULL;
    }

    if (ghDisconnectDesk) {
        CloseProtectedHandle(ghDisconnectDesk);
        ghDisconnectDesk = NULL;
    }

    if (pwinsta) {
        UserAssert(pwinsta->rpdeskList == NULL);
    }

    /*
     * Unlock the logon desktop from the global variable
     */
    UnlockDesktop(&grpdeskLogon, LDU_DESKLOGON, 0);

    /*
     * Unlock the disconnect logon
     *
     * This was referenced when we created it, so free it now.
     * This is also a flag since the disconnect code checks to see if
     * the disconnected desktop is still around.
     */
    UnlockDesktop(&gspdeskDisconnect, LDU_DESKDISCONNECT, 0);

    /*
     * Unlock any windows still locked in the SMS list. We need to do
     * this here because if we don't, we end up with zombie windows in the
     * desktop thread that we'll try to assign to RIT but RIT will be gone.
     */
    {
        PSMS psms = gpsmsList;

        while (psms != NULL) {
            if (psms->spwnd != NULL) {
                UserAssert(psms->message == WM_CLIENTSHUTDOWN);

                RIPMSG1(RIP_WARNING, "Window %#p locked in the SMS list",
                        psms->spwnd);

                Unlock(&psms->spwnd);
            }
            psms = psms->psmsNext;
        }
    }

    /*
     * Free outstanding timers.
     */
    while (gptmrFirst != NULL) {
        FreeTimer(gptmrFirst);
    }

    /*
     * Free the task switch window if there.
     */
    if (gspwndAltTab != NULL) {
        Unlock(&gspwndAltTab);
    }

    TAGMSG0(DBGTAG_RIT, "posting WM_QUIT to the IO DT");

    if (pwinsta) {
        UserAssert(pwinsta->pTerm->ptiDesktop != NULL);
        UserAssert(pwinsta->pTerm == &gTermIO);
    }

    {
        /*
         * Wait for desktop thread(s) to exit.
         * This thread (RIT) is used to assign
         * objects if the orginal thread leaves.  So it should be
         * the last one to go.  Hopefully, if the desktop thread
         * exits, there shouldn't be any objects in use.
         */
        PVOID  aDT[2];
        ULONG  cObjects = 0;

        if (gTermIO.ptiDesktop != NULL) {
            aDT[0] = gTermIO.ptiDesktop->pEThread;
            ObReferenceObject(aDT[0]);
            cObjects++;

            if (!_PostThreadMessage(gTermIO.ptiDesktop, WM_QUIT, 0, 0)) {
                FRE_RIPMSG1(RIP_ERROR, "InitiateWin32kCleanup: failed to post WM_QUIT message to IO desktop thread %p",
                            gTermIO.ptiDesktop);
            }

            HYDRA_HINT(HH_DTQUITPOSTED);
        }

        if (gTermNOIO.ptiDesktop != NULL) {
            aDT[1] = gTermNOIO.ptiDesktop->pEThread;
            ObReferenceObject(aDT[1]);
            cObjects++;

            if (!_PostThreadMessage(gTermNOIO.ptiDesktop, WM_QUIT, 0, 0)) {
                FRE_RIPMSG1(RIP_ERROR, "InitiateWin32kCleanup: failed to post WM_QUIT message to NOIO desktop thread %p",
                            gTermNOIO.ptiDesktop);
            }
        }

        if (cObjects > 0) {
            LeaveCrit();

            TAGMSG0(DBGTAG_RIT, "waiting on desktop thread(s) destruction ...");

            /*
             * Give DTs 5 minutes to go away
             */
            timeout.QuadPart = Int32x32To64(-10000, 300000);
    WaitAgain:

            Reason =

            KeWaitForMultipleObjects(cObjects,
                                     aDT,
                                     WaitAll,
                                     WrUserRequest,
                                     KernelMode,
                                     TRUE,
                                     &timeout,
                                     NULL);

            if (Reason == STATUS_TIMEOUT) {
                FRE_RIPMSG0(RIP_ERROR,
                        "InitiateWin32kCleanup: Timeout in RIT waiting for desktop threads to go away.");
                goto WaitAgain;
            }

            TAGMSG0(DBGTAG_RIT, "Desktop thread(s) destroyed");

            ObDereferenceObject(aDT[0]);

            if (cObjects > 1) {
                ObDereferenceObject(aDT[1]);
            }

            EnterCrit();
        }
    }

    HYDRA_HINT(HH_ALLDTGONE);

    /*
     * If still connected, tell the miniport driver to disconnect
     */
    if (gbConnected) {
        if (!gfRemotingConsole) {

            bDrvDisconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                           gThinwireFileObject);
        } else{

            ASSERT(!IsRemoteConnection());
            ASSERT(gConsoleShadowhDev != NULL);
            bDrvDisconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                           gConsoleShadowThinwireFileObject);
        }
    }

    UnlockDesktop(&grpdeskRitInput, LDU_DESKRITINPUT, 0);
    UnlockDesktop(&gspdeskShouldBeForeground, LDU_DESKSHOULDBEFOREGROUND, 0);

    /*
     * Kill the csr port so no hard errors are services after this point
     */
    if (CsrApiPort != NULL) {
        ObDereferenceObject(CsrApiPort);
        CsrApiPort = NULL;
    }

    Unlock(&gspwndCursor);

    /*
     * set this to NULL
     */
    gptiRit = NULL;

    TAGMSG0(DBGTAG_RIT, "TERMINATING !!!");

#if DBG
    {
        PPROCESSINFO ppi = gppiList;

        KdPrint(("Processes still running:\n"));
        KdPrint(("-------------------------\n"));

        while (ppi) {

            PTHREADINFO pti;

            KdPrint(("ppi '%s' %#p threads: %d\n",
                     PsGetProcessImageFileName(ppi->Process),
                     ppi,
                     ppi->cThreads));

            KdPrint(("\tGUI threads\n"));

            pti = ppi->ptiList;

            while (pti) {
                KdPrint(("\t%#p\n", pti));
                pti = pti->ptiSibling;
            }

            ppi = ppi->ppiNextRunning;
        }
        KdPrint(("-------------------------\n"));
    }
#endif // DBG

    LeaveCrit();

    if (gbRemoteSession) {
        swprintf(szName, L"\\Sessions\\%ld\\BaseNamedObjects\\EventRitExited",
                 gSessionId);

        RtlInitUnicodeString(&ustrName, szName);

        InitializeObjectAttributes(&obja,
                                   &ustrName,
                                   OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                   NULL,
                                   NULL);

        Status = ZwCreateEvent(&hevtRitExited,
                               EVENT_ALL_ACCESS,
                               &obja,
                               SynchronizationEvent,
                               FALSE);

        if (NT_SUCCESS(Status)) {
            ZwSetEvent(hevtRitExited, NULL);
            ZwClose(hevtRitExited);
        } else {
            RIPMSG1(RIP_ERROR, "RIT unable to create EventRitExited: 0x%x\n", Status);
        }
    }

    /*
     * Clear TIF_PALETTEAWARE or else we will AV in xxxDestroyThreadInfo
     * MCostea #412136
     */
    ptiCurrent->TIF_flags &= ~TIF_PALETTEAWARE;

    HYDRA_HINT(HH_RITGONE);

    return TRUE;
}

/***************************************************************************\
* RemoteSyncToggleKeys (RIT)
*
* This function is called whenever a remote client needs to synchronize the
* current toggle key state of the server.  If the keys are out of sync, it
* injects the correct toggle key sequences.
*
* History:
* 11-12-98 JParsons     Created.
\***************************************************************************/
VOID RemoteSyncToggleKeys(
    ULONG toggleKeys)
{
    KE ke;
    BOOL bInjected;

    CheckCritIn();
    gSetLedReceived = toggleKeys | KEYBOARD_LED_INJECTED;

#ifdef GENERIC_INPUT
    ke.hDevice = NULL;
#endif

    // Key injection only works if there is a ready application queue.
    if (gpqForeground != NULL) {

        bInjected = gSetLedReceived & KEYBOARD_SHADOW ? TRUE : FALSE;

        if (!(gSetLedReceived & KEYBOARD_CAPS_LOCK_ON) != !TestRawKeyToggle(VK_CAPITAL)) {
            ke.bScanCode = (BYTE)(0x3a);
            ke.usFlaggedVk = VK_CAPITAL;
            xxxProcessKeyEvent(&ke, 0, bInjected);

            ke.bScanCode = (BYTE)(0xba & 0x7f);
            ke.usFlaggedVk = VK_CAPITAL | KBDBREAK;
            xxxProcessKeyEvent(&ke, 0, bInjected);
        }

        if (!(gSetLedReceived & KEYBOARD_NUM_LOCK_ON) != !TestRawKeyToggle(VK_NUMLOCK)) {
            ke.bScanCode = (BYTE)(0x45);
            ke.usFlaggedVk = VK_NUMLOCK;
            xxxProcessKeyEvent(&ke, 0, bInjected);

            ke.bScanCode = (BYTE)(0xc5 & 0x7f);
            ke.usFlaggedVk = VK_NUMLOCK | KBDBREAK;
            xxxProcessKeyEvent(&ke, 0, bInjected);
        }

        if (!(gSetLedReceived & KEYBOARD_SCROLL_LOCK_ON) != !TestRawKeyToggle(VK_SCROLL)) {
            ke.bScanCode = (BYTE)(0x46);
            ke.usFlaggedVk = VK_SCROLL;
            xxxProcessKeyEvent(&ke, 0, bInjected);

            ke.bScanCode = (BYTE)(0xc6 & 0x7f);
            ke.usFlaggedVk = VK_SCROLL | KBDBREAK;
            xxxProcessKeyEvent(&ke, 0, bInjected);
        }

        if (JAPANESE_KBD_LAYOUT(GetActiveHKL())) {
            if (!(gSetLedReceived & KEYBOARD_KANA_LOCK_ON) != !TestRawKeyToggle(VK_KANA)) {
                ke.bScanCode = (BYTE)(0x70);
                ke.usFlaggedVk = VK_KANA;
                xxxProcessKeyEvent(&ke, 0, bInjected);

                ke.bScanCode = (BYTE)(0xf0 & 0x7f);
                ke.usFlaggedVk = VK_KANA | KBDBREAK;
                xxxProcessKeyEvent(&ke, 0, bInjected);
            }
        }

        gSetLedReceived = 0;
    }
}


/***************************************************************************\
* ProcessKeyboardInput (RIT)
*
* This function is called whenever a keyboard input is ready to be consumed.
* It calls xxxProcessKeyEvent() for every input event, and once all the events
* have been consumed, calls StartDeviceRead() to request more keyboard events.
*
* Return value: "OK to continue walking gpDeviceInfoList"
* TRUE  - processed input without leaving gpresDeviceInfoList critical section
* FALSE - had to leave the gpresDeviceInfoList critical section
*
* History:
* 11-26-90 DavidPe      Created.
\***************************************************************************/
VOID ProcessKeyboardInputWorker(
    PKEYBOARD_INPUT_DATA pkei,
#ifdef GENERIC_INPUT
    PDEVICEINFO pDeviceInfo,
#endif
    BOOL fProcessRemap)
{
    BYTE Vk;
    BYTE bPrefix;
    KE ke;

#ifdef GENERIC_INPUT
    /*
     * Set the device handle and raw data
     */
    ke.hDevice = PtoH(pDeviceInfo);
    UserAssert(pkei);
    ke.data = *pkei;
#endif

    /*
     * Remote terminal server clients occationally need to be able to set
     * the server's toggle key state to match the client.  All other
     * standard keyboard inputs are processed below since this is the most
     * frequent code path.
     */
    if ((pkei->Flags & (KEY_TERMSRV_SET_LED | KEY_TERMSRV_VKPACKET)) == 0) {

        // Process any deferred remote key sync requests
        if (!(gSetLedReceived & KEYBOARD_LED_INJECTED)) {
            goto ProcessKeys;
        } else {
            RemoteSyncToggleKeys(gSetLedReceived);
        }

ProcessKeys:
        if (pkei->Flags & KEY_E0) {
            bPrefix = 0xE0;
        } else if (pkei->Flags & KEY_E1) {
            bPrefix = 0xE1;
        } else {
            bPrefix = 0;
        }

        if (pkei->MakeCode == 0xFF) {
            /*
             * Kbd overrun (kbd hardware and/or keyboard driver) : Beep!
             * (some DELL keyboards send 0xFF if keys are hit hard enough,
             * presumably due to keybounce)
             */
            LeaveCrit();
            UserBeep(440, 125);
            EnterCrit();
            return;
        }

        ke.bScanCode = (BYTE)(pkei->MakeCode & 0x7F);
        if (fProcessRemap && (gpScancodeMap || gpFlexMap)) {
            ke.usFlaggedVk = 0;
            if (pkei->Flags & KEY_BREAK) {
                ke.usFlaggedVk |= KBDBREAK;
            }
            if (!MapScancode(&ke, &bPrefix
#ifdef GENERIC_INPUT
                             , pDeviceInfo
#endif
                             )) {
                /*
                 * If the input is all processed within MapScancode, go to the
                 * next one.
                 */
                return;
            }
        }

        gbVKLastDown = Vk = VKFromVSC(&ke, bPrefix, gafRawKeyState);



        if (Vk == 0
#ifdef GENERIC_INPUT
            && gpqForeground && !RawInputRequestedForKeyboard(PtiKbdFromQ(gpqForeground))
#endif
            ) {
            return;
        }

        if (pkei->Flags & KEY_BREAK) {
            ke.usFlaggedVk |= KBDBREAK;
        }


        /*
         * We don't know if the client system or the host should get the
         * windows key, so the choice is to not support it on the host.
         * (The windows key is a local key.)
         *
         * The other practical problem is that the local shell intercepts
         * the "break" of the windows key and switches to the start menu.
         * The client never sees the "break" so the host thinks the
         * windows key is always depressed.
         *
         * Newer clients may indicate they support the windows key.
         * If the client has indicated this through the gfEnableWindowsKey,
         * then we allow it to be processed here on the host.
         */
        if (IsRemoteConnection()) {
            BYTE CheckVk = (BYTE)ke.usFlaggedVk;

            if (CheckVk == VK_LWIN || CheckVk == VK_RWIN) {
                if (!gfEnableWindowsKey) {
                    return;
                }
            }
        }

        //
        // Keep track of real modifier key state.  Conveniently, the values for
        // VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU and
        // VK_RMENU are contiguous.  We'll construct a bit field to keep track
        // of the current modifier key state.  If a bit is set, the corresponding
        // modifier key is down.  The bit field has the following format:
        //
        //     +---------------------------------------------------+
        //     | Right | Left  |  Right  |  Left   | Right | Left  |
        //     |  Alt  |  Alt  | Control | Control | Shift | Shift |
        //     +---------------------------------------------------+
        //         5       4        3         2        1       0     Bit
        //
        // Add bit 7 -- VK_RWIN
        //     bit 6 -- VK_LWIN

        switch (Vk) {
        case VK_LSHIFT:
        case VK_RSHIFT:
        case VK_LCONTROL:
        case VK_RCONTROL:
        case VK_LMENU:
        case VK_RMENU:
            gCurrentModifierBit = 1 << (Vk & 0xf);
            break;
        case VK_LWIN:
            gCurrentModifierBit = 0x40;
            break;
        case VK_RWIN:
            gCurrentModifierBit = 0x80;
            break;
        default:
            gCurrentModifierBit = 0;
        }
        if (gCurrentModifierBit) {
            /*
             * If this is a break of a modifier key then clear the bit value.
             * Otherwise, set it.
             */
            if (pkei->Flags & KEY_BREAK) {
                gPhysModifierState &= ~gCurrentModifierBit;
            } else {
                gPhysModifierState |= gCurrentModifierBit;
            }
        }

        if (!TEST_ACCF(ACCF_ACCESSENABLED)) {
            xxxProcessKeyEvent(&ke, (ULONG_PTR)pkei->ExtraInformation,
                pkei->Flags & KEY_TERMSRV_SHADOW ? TRUE : FALSE);
        } else {
            if ((gtmridAccessTimeOut != 0) && TEST_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON)) {
                gtmridAccessTimeOut = InternalSetTimer(
                                                 NULL,
                                                 gtmridAccessTimeOut,
                                                 (UINT)gAccessTimeOut.iTimeOutMSec,
                                                 xxxAccessTimeOutTimer,
                                                 TMRF_RIT | TMRF_ONESHOT
                                                 );
            }
            if (AccessProceduresStream(&ke, pkei->ExtraInformation, 0)) {
                xxxProcessKeyEvent(&ke, (ULONG_PTR)pkei->ExtraInformation,
                    pkei->Flags & KEY_TERMSRV_SHADOW ? TRUE : FALSE);
            }
        }
    } else {

        // Special toggle key synchronization for Terminal Server
        if (pkei->Flags & KEY_TERMSRV_SET_LED) {
            if (pkei->Flags & KEY_TERMSRV_SHADOW) {
                pkei->ExtraInformation |= KEYBOARD_SHADOW;
            }
            RemoteSyncToggleKeys(pkei->ExtraInformation);
        }

        if (pkei->Flags & KEY_TERMSRV_VKPACKET) {
            ke.wchInjected = (WCHAR)pkei->MakeCode;
            ke.usFlaggedVk = VK_PACKET | KBDUNICODE |
                ((pkei->Flags & KEY_BREAK) ? KBDBREAK : 0);
            xxxProcessKeyEvent(
                &ke, 0,
                pkei->Flags & KEY_TERMSRV_SHADOW ? TRUE : FALSE
                );
        }
    }
}

VOID SearchAndSetKbdTbl(
    PDEVICEINFO pDeviceInfo,
    DWORD dwType,
    DWORD dwSubType)
{
    PKBDFILE pkf = gpKL->spkfPrimary;
    UINT i;

    if (pkf->pKbdTbl->dwType == dwType && pkf->pKbdTbl->dwSubType == dwSubType) {
        goto primary_match;
    }

    if ((pDeviceInfo->bFlags & GDIF_NOTPNP) == 0) {
        TAGMSG2(DBGTAG_KBD, "SearchAndSetKbdTbl: new type 0x%x:0x%x", dwType, dwSubType);

        /*
         * Search for matching keyboard layout in the current KL
         */
        for (i = 0; i < gpKL->uNumTbl; ++i) {
            TAGMSG2(DBGTAG_KBD, "SearchAndSetKbdTbl: searching 0x%x:0x%x",
                gpKL->pspkfExtra[i]->pKbdTbl->dwType,
                gpKL->pspkfExtra[i]->pKbdTbl->dwSubType);
            if (gpKL->pspkfExtra[i]->pKbdTbl->dwType == dwType &&
                    gpKL->pspkfExtra[i]->pKbdTbl->dwSubType == dwSubType) {
                TAGMSG2(DBGTAG_KBD, "SearchAndSetKbdTbl: new layout for 0x%x:0x%x",
                        gpKL->pspkfExtra[i]->pKbdTbl->dwType,
                        gpKL->pspkfExtra[i]->pKbdTbl->dwSubType);
                pkf = gpKL->pspkfExtra[i];
                break;
            }
        }

        if (i >= gpKL->uNumTbl) {
            /*
             * Unknown type to this KL.
             */
            TAGMSG0(DBGTAG_KBD, "ProcessKeyboardInput: cannot find the matching KL. Reactivating primary.");
        }

    } else {
        TAGMSG0(DBGTAG_KBD, "ProcessKeyboardInput: The new keyboard is not PnP. Use primary.");
    }

primary_match:
    if (gpKL->spkf != pkf) {
        Lock(&gpKL->spkf, pkf);
        SetGlobalKeyboardTableInfo(gpKL);
    }
}

VOID ProcessKeyboardInput(PDEVICEINFO pDeviceInfo)
{
    PKEYBOARD_INPUT_DATA pkei;
    PKEYBOARD_INPUT_DATA pkeiStart, pkeiEnd;

    EnterCrit();
    UserAssert(pDeviceInfo->type == DEVICE_TYPE_KEYBOARD);
    UserAssert(pDeviceInfo->iosb.Information);
    UserAssert(NT_SUCCESS(pDeviceInfo->iosb.Status));

    /*
     * Switch the keyboard layout table, if the current KL has multiple
     * tables.
     */
    if (gpKL && gpKL->uNumTbl > 0 &&
                (gpKL->dwLastKbdType != GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo) ||
                 gpKL->dwLastKbdSubType != GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo))) {
        SearchAndSetKbdTbl(pDeviceInfo,
                           GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo),
                           GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo));
        /*
         * Whether or not we found the match, cache the type/subtype so that
         * we will not try to find the same type/subtype for a while.
         */
        gpKL->dwLastKbdType = GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo);
        gpKL->dwLastKbdSubType = GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo);
    }

    pkeiStart = pDeviceInfo->keyboard.Data;
    pkeiEnd   = (PKEYBOARD_INPUT_DATA)((PBYTE)pkeiStart + pDeviceInfo->iosb.Information);
    for (pkei = pkeiStart; pkei < pkeiEnd; pkei++) {
        ProcessKeyboardInputWorker(pkei,
#ifdef GENERIC_INPUT
                                   pDeviceInfo,
#endif
                                   TRUE);
    }

    LeaveCrit();
}


/***************************************************************************\
* xxxProcessKeyEvent (RIT)
*
* This function is called to process an individual keystroke (up or down).
* It performs some OEM, language and layout specific processing which
* discards or modifies the keystroke or introduces additional keystrokes.
* The RawKeyState is updated here, also termination of screen saver and video
* power down is initiated here.
* xxxKeyEvent() is called for each resulting keystroke.
*
* History:
* 11-26-90 DavidPe      Created.
\***************************************************************************/

VOID xxxProcessKeyEvent(
    PKE pke,
    ULONG_PTR ExtraInformation,
    BOOL bInjected)
{
    BYTE Vk;

    CheckCritIn();

    Vk = (BYTE)pke->usFlaggedVk;

    /*
     * KOREAN:
     * Check this is Korean keyboard layout, or not..
     *
     * NOTE:
     *  It would be better check this by "keyboard hardware" or
     * "keyboard layout" ???
     *
     * 1. Check by hardware :
     *
     *   if (KOREAN_KEYBOARD(gKeyboardInfo.KeyboardIdentifier)) {
     *
     * 2. Check by layout :
     *
     *   if (KOREAN_KBD_LAYOUT(_GetKeyboardLayout(0L))) {
     */
    if (KOREAN_KBD_LAYOUT(GetActiveHKL())) {
        if ((pke->usFlaggedVk & KBDBREAK) &&
            !(pke->usFlaggedVk & KBDUNICODE) &&
            (pke->bScanCode == 0xF1 || pke->bScanCode == 0xF2) &&
            !TestRawKeyDown(Vk)) {
            /*
             * This is actually a keydown with a scancode of 0xF1 or 0xF2 from a
             * Korean keyboard. Korean IMEs and apps want a WM_KEYDOWN with a
             * scancode of 0xF1 or 0xF2. They don't mind not getting the WM_KEYUP.
             * Don't update physical keystate to allow a real 0x71/0x72 keydown.
             */
            pke->usFlaggedVk &= ~KBDBREAK;
        } else {
            UpdateRawKeyState(Vk, pke->usFlaggedVk & KBDBREAK);
        }
    } else {
        UpdateRawKeyState(Vk, pke->usFlaggedVk & KBDBREAK);
    }

    /*
     * Convert Left/Right Ctrl/Shift/Alt key to "unhanded" key.
     * ie: if VK_LCONTROL or VK_RCONTROL, convert to VK_CONTROL etc.
     */
    if ((Vk >= VK_LSHIFT) && (Vk <= VK_RMENU)) {
        Vk = (BYTE)((Vk - VK_LSHIFT) / 2 + VK_SHIFT);
        UpdateRawKeyState(Vk, pke->usFlaggedVk & KBDBREAK);
    }

    /*
     * Setup to shutdown screen saver and exit video power down mode.
     */
    if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
        /*
         * Call video driver here to exit power down mode.
         */
        TAGMSG0(DBGTAG_Power, "Exit video power down mode");
        DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
    }
    glinp.dwFlags = (glinp.dwFlags & ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES)) | LINP_KEYBOARD;

    gpsi->dwLastRITEventTickCount = NtGetTickCount();
    if (!gbBlockSendInputResets || !bInjected) {
        glinp.timeLastInputMessage = gpsi->dwLastRITEventTickCount;
    }

    if (gpsi->dwLastRITEventTickCount - gpsi->dwLastSystemRITEventTickCountUpdate > SYSTEM_RIT_EVENT_UPDATE_PERIOD) {
        SharedUserData->LastSystemRITEventTickCount = gpsi->dwLastRITEventTickCount;
        gpsi->dwLastSystemRITEventTickCountUpdate = gpsi->dwLastRITEventTickCount;
    }

    if (!bInjected || (pke->dwTime == 0)) {
        pke->dwTime = glinp.timeLastInputMessage;
    }

#ifdef MOUSE_IP
    /*
     * Sonar
     */
    CheckCritIn();
#ifdef KBDMAPPEDVK
    if ((pke->usFlaggedVk & KBDMAPPEDVK) == 0) {
#endif
        /*
         * Sonar is not activated for simulated modifier keys
         */
        if ((pke->usFlaggedVk & KBDBREAK) == 0) {
            /*
             * Key down:
             * When the key is down, sonar needs to be stopped.
             */
            if (IS_SONAR_ACTIVE()) {
                StopSonar();
            }
            /*
             * Do not process the repeated keys...
             * If this key is not pressed before, remember it for the key up event.
             */
            if (gbLastVkForSonar != Vk) {
                gbLastVkForSonar = Vk;
            }
        } else {
            /*
             * Key up:
             */
            if ((BYTE)Vk == gbVkForSonarKick && (BYTE)Vk == gbLastVkForSonar && TestUP(MOUSESONAR)) {
                /*
                 * If this is keyup and it is the Sonar key, and it's the last key downed,
                 * kick the sonar now.
                 */
                StartSonar();
            }
            /*
             * Clear the last VK for the next key event.
             */
            CLEAR_SONAR_LASTVK();
        }
#ifdef KBDMAPPEDVK
    }
#endif
#endif

    /*
     * Now call all the OEM- and Locale- specific KEProcs.
     * If KEProcs return FALSE, the keystroke has been discarded, in
     * which case don't pass the key event on to xxxKeyEvent().
     */
    if (pke->usFlaggedVk & KBDUNICODE) {
        xxxKeyEvent(pke->usFlaggedVk, pke->wchInjected,
                    pke->dwTime, ExtraInformation,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    bInjected);
    } else {
        if (KEOEMProcs(pke) && xxxKELocaleProcs(pke) && xxxKENLSProcs(pke,ExtraInformation)) {
            xxxKeyEvent(pke->usFlaggedVk, pke->bScanCode,
                        pke->dwTime, ExtraInformation,
#ifdef GENERIC_INPUT
                        pke->hDevice,
                        &pke->data,
#endif
                        bInjected);
        }
    }
}

#ifndef SUBPIXEL_MOUSE
/***************************************************************************\
* DoMouseAccel (RIT)
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, DoMouseAccel)
#endif

LONG DoMouseAccel(
    LONG Delta)
{
    LONG newDelta = Delta;

    if (abs(Delta) > gMouseThresh1) {
        newDelta *= 2;

        if ((abs(Delta) > gMouseThresh2) && (gMouseSpeed == 2)) {
            newDelta *= 2;
        }
    }

    return newDelta;
}
#endif


/***************************************************************************\
* PwndForegroundCapture
*
* History:
* 10-23-91 DavidPe      Created.
\***************************************************************************/

PWND PwndForegroundCapture(VOID)
{
    if (gpqForeground != NULL) {
        return gpqForeground->spwndCapture;
    }

    return NULL;
}


/***************************************************************************\
* SetKeyboardRate
*
* This function calls the keyboard driver to set a new keyboard repeat
* rate and delay.  It limits the values to the min and max given by
* the driver so it won't return an error when we call it.
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/
VOID SetKeyboardRate(
    UINT                nKeySpeedAndDelay
    )
{
    UINT nKeyDelay;
    UINT nKeySpeed;

    nKeyDelay = (nKeySpeedAndDelay & KDELAY_MASK) >> KDELAY_SHIFT;

    nKeySpeed = KSPEED_MASK & nKeySpeedAndDelay;

    gktp.Rate = (USHORT)( ( gKeyboardInfo.KeyRepeatMaximum.Rate -
                   gKeyboardInfo.KeyRepeatMinimum.Rate
                 ) * nKeySpeed / KSPEED_MASK
               ) +
               gKeyboardInfo.KeyRepeatMinimum.Rate;

    gktp.Delay = (USHORT)( ( gKeyboardInfo.KeyRepeatMaximum.Delay -
                    gKeyboardInfo.KeyRepeatMinimum.Delay
                  ) * nKeyDelay / (KDELAY_MASK >> KDELAY_SHIFT)
                ) +
                gKeyboardInfo.KeyRepeatMinimum.Delay;

    /*
     * Hand off the IOCTL to the RIT, since only the system process can
     * access keyboard handles
     */
    gdwUpdateKeyboard |= UPDATE_KBD_TYPEMATIC;
}


/***************************************************************************\
* UpdateKeyLights
*
* This function calls the keyboard driver to set the keylights into the
* current state specified by the async keystate table.
*
* bInjected: (explanation from John Parsons via email)
* Set this TRUE if you do something on the server to asynchronously change the
* indicators behind the TS client's back, to get this reflected back to the
* client.  Examples are toggling num lock or caps lock programatically, or our
* favorite example is the automatic spelling correction on Word: if you type
* "tHE mouse went up the clock", Word will fix it by automagically pressing
* CAPS LOCK, then retyping the T  -- if the client is not informed, the keys
* get out of sync.
* Set this to FALSE for indicator changes initiated by the client (let's say by
* pressing CAPS LOCK) in which case we don't loop back the indicator change
* since the client has already changed state locally.
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/

VOID UpdateKeyLights(BOOL bInjected)
{
    /*
     * Looking at async keystate.  Must be in critical section.
     */
    CheckCritIn();

    /*
     * Based on the toggle bits in the async keystate table,
     * set the key lights.
     */
    gklp.LedFlags = 0;
    if (TestAsyncKeyStateToggle(VK_CAPITAL)) {
        gklp.LedFlags |= KEYBOARD_CAPS_LOCK_ON;
        SetRawKeyToggle(VK_CAPITAL);
    } else {
        ClearRawKeyToggle(VK_CAPITAL);
    }

    if (TestAsyncKeyStateToggle(VK_NUMLOCK)) {
        gklp.LedFlags |= KEYBOARD_NUM_LOCK_ON;
        SetRawKeyToggle(VK_NUMLOCK);
    } else {
        ClearRawKeyToggle(VK_NUMLOCK);
    }

    if (TestAsyncKeyStateToggle(VK_SCROLL)) {
        gklp.LedFlags |= KEYBOARD_SCROLL_LOCK_ON;
        SetRawKeyToggle(VK_SCROLL);
    } else {
        ClearRawKeyToggle(VK_SCROLL);
    }

    /*
     * Only "Japanese keyboard hardware" has "KANA" LEDs, and switch to
     * "KANA" state.
     */
    if (JAPANESE_KEYBOARD(gKeyboardInfo.KeyboardIdentifier)) {
        if (TestAsyncKeyStateToggle(VK_KANA)) {
            gklp.LedFlags |= KEYBOARD_KANA_LOCK_ON;
            SetRawKeyToggle(VK_KANA);
        } else {
            ClearRawKeyToggle(VK_KANA);
        }
    }

    /*
     * On terminal server, we need to tell the WD about application injected
     * toggle keys so it can update the client accordingly.
     */

    if (IsRemoteConnection()) {
        if (bInjected)
            gklp.LedFlags |= KEYBOARD_LED_INJECTED;
        else
            gklp.LedFlags &= ~KEYBOARD_LED_INJECTED;
    }


    if (PtiCurrent() != gptiRit) {
        /*
         * Hand off the IOCTL to the RIT, since only the system process can
         * access the keyboard handles.  Happens when applying user's profile.
         * IanJa: Should we check PpiCurrent() == gptiRit->ppi instead?
         */
        gdwUpdateKeyboard |= UPDATE_KBD_LEDS;
    } else {
        /*
         * Do it immediately (avoids a small delay between keydown and LED
         * on when typing)
         */
        PDEVICEINFO pDeviceInfo;

        EnterDeviceInfoListCrit();
        for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
            if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                        &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                        (PVOID)&gklp, sizeof(gklp), NULL, 0);
            }
        }
        LeaveDeviceInfoListCrit();

        if (gfRemotingConsole) {
            ZwDeviceIoControlFile(ghConsoleShadowKeyboardChannel, NULL, NULL, NULL,
                    &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                    (PVOID)&gklp, sizeof(gklp), NULL, 0);
        }
    }
}


/*
 * _GetKeyboardType is obsolete API. The API cannot
 * deal with the multiple keyboards attached.
 * This API returns the best guess that older apps
 * would expect.
 */
int _GetKeyboardType(int nTypeFlag)
{

    switch (nTypeFlag) {
    case 0:
        if (gpKL) {
            DWORD dwType;

            //
            // If there's gpKL, use its primary
            // type info rather than the one used
            // last time.
            //
            UserAssert(gpKL->spkfPrimary);
            UserAssert(gpKL->spkfPrimary->pKbdTbl);
            dwType = gpKL->spkfPrimary->pKbdTbl->dwType;
            if (dwType != 0 && dwType != KEYBOARD_TYPE_UNKNOWN) {
                return dwType;
            }
        }
        return gKeyboardInfo.KeyboardIdentifier.Type;

    case 1:
    // FE_SB
    {
        int OEMId = 0;
        DWORD dwSubType;
        PKBDNLSTABLES pKbdNlsTbl = gpKbdNlsTbl;

        //
        // If there's gpKL, use its primary value
        // rather than the one used last time.
        //
        if (gpKL) {
            UserAssert(gpKL->spkfPrimary);
            if (gpKL->spkfPrimary->pKbdNlsTbl) {
                pKbdNlsTbl =gpKL->spkfPrimary->pKbdNlsTbl;
            }
            UserAssert(gpKL->spkfPrimary->pKbdTbl);
            dwSubType = gpKL->spkfPrimary->pKbdTbl->dwSubType;
        } else {
            dwSubType = gKeyboardInfo.KeyboardIdentifier.Subtype;
        }

        //
        // If this keyboard layout is compatible with 101 or 106
        // Japanese keyboard, we just return 101 or 106's keyboard
        // id, not this keyboard's one to let application handle
        // this keyboard as 101 or 106 Japanese keyboard.
        //
        if (pKbdNlsTbl) {
            if (pKbdNlsTbl->LayoutInformation & NLSKBD_INFO_EMURATE_101_KEYBOARD) {
                return MICROSOFT_KBD_101_TYPE;
            }
            if (pKbdNlsTbl->LayoutInformation & NLSKBD_INFO_EMURATE_106_KEYBOARD) {
                return MICROSOFT_KBD_106_TYPE;
            }
        }

        //
        // PSS ID Number: Q130054
        // Article last modified on 05-16-1995
        //
        // 3.10 1.20 | 3.50 1.20
        // WINDOWS   | WINDOWS NT
        //
        // ---------------------------------------------------------------------
        // The information in this article applies to:
        // - Microsoft Windows Software Development Kit (SDK) for Windows
        //   version 3.1
        // - Microsoft Win32 Software Development Kit (SDK) version 3.5
        // - Microsoft Win32s version 1.2
        // ---------------------------------------------------------------------
        // SUMMARY
        // =======
        // Because of the variety of computer manufacturers (NEC, Fujitsu, IBMJ, and
        // so on) in Japan, sometimes Windows-based applications need to know which
        // OEM (original equipment manufacturer) manufactured the computer that is
        // running the application. This article explains how.
        //
        // MORE INFORMATION
        // ================
        // There is no documented way to detect the manufacturer of the computer that
        // is currently running an application. However, a Windows-based application
        // can detect the type of OEM Windows by using the return value of the
        // GetKeyboardType() function.
        //
        // If an application uses the GetKeyboardType API, it can get OEM ID by
        // specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
        // is listed here:
        //
        // OEM Windows       OEM ID
        // ------------------------------
        // Microsoft         00H (DOS/V)
        // all AX            01H
        // EPSON             04H
        // Fujitsu           05H
        // IBMJ              07H
        // Matsushita        0AH
        // NEC               0DH
        // Toshiba           12H
        //
        // Application programs can use these OEM IDs to distinguish the type of OEM
        // Windows. Note, however, that this method is not documented, so Microsoft
        // may not support it in the future version of Windows.
        //
        // As a rule, application developers should write hardware-independent code,
        // especially when making Windows-based applications. If they need to make a
        // hardware-dependent application, they must prepare the separated program
        // file for each different hardware architecture.
        //
        // Additional reference words: 3.10 1.20 3.50 1.20 kbinf
        // KBCategory: kbhw
        // KBSubcategory: wintldev
        // =============================================================================
        // Copyright Microsoft Corporation 1995.

        if (pKbdNlsTbl) {
            //
            // Get OEM (Windows) ID.
            //
            OEMId = ((int)pKbdNlsTbl->OEMIdentifier) << 8;
        }
        //
        // The format of KeyboardIdentifier.Subtype :
        //
        // 0 - 3 bits = keyboard subtype
        // 4 - 7 bits = kernel mode kerboard driver provider id.
        //
        // Kernel mode keyboard dirver provier | ID
        // ------------------------------------+-----
        // Microsoft                           | 00H
        // all AX                              | 01H
        // Toshiba                             | 02H
        // EPSON                               | 04H
        // Fujitsu                             | 05H
        // IBMJ                                | 07H
        // Matsushita                          | 0AH
        // NEC                                 | 0DH
        //

        //
        // And here is the format of return value.
        //
        // 0  -  7 bits = Keyboard Subtype.
        // 8  - 15 bits = OEM (Windows) Id.
        // 16 - 31 bits = not used.
        //
        return (int)(OEMId | (dwSubType & 0x0f));
    }

    case 2:
        return gKeyboardInfo.NumberOfFunctionKeys;
    }
    return 0;
}

/**************************************************************************\
* xxxMouseEventDirect
*
* Mouse event inserts a mouse event into the input stream.
*
* The parameters are the same as the fields of the MOUSEINPUT structure
* used in SendInput.
*
*    dx           Delta x
*    dy           Delta y
*    mouseData    Mouse wheel movement or xbuttons
*    dwMEFlags    Mouse event flags
*    dwExtraInfo  Extra info from driver.
*
* History:
* 07-23-92 Mikehar      Created.
* 01-08-93 JonPa        Made it work with new mouse drivers
\**************************************************************************/

BOOL xxxMouseEventDirect(
   DWORD dx,
   DWORD dy,
   DWORD mouseData,
   DWORD dwMEFlags,
   DWORD dwTime,
   ULONG_PTR dwExtraInfo)
{
    DWORD   dwDriverMouseFlags;
    DWORD   dwDriverMouseData;
#ifdef GENERIC_INPUT
    MOUSE_INPUT_DATA mei;
#endif

    PTHREADINFO pti = PtiCurrent();
    if (dwTime == 0) {
        dwTime = NtGetTickCount();
    }

    /*
     * The calling thread must be on the active desktop
     * and have journal playback access to that desktop.
     */
    if (pti->rpdesk == grpdeskRitInput) {
        UserAssert(!(pti->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));
        if (!CheckGrantedAccess(pti->amdesk, DESKTOP_JOURNALPLAYBACK)) {

            RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING,
                      "mouse_event(): No DESKTOP_JOURNALPLAYBACK access to input desktop.");
            return FALSE;
        }
    } else {
        /*
         * 3/22/95 BradG - Only allow below HACK for pre 4.0 applications
         */
        if (LOWORD(pti->dwExpWinVer) >= VER40) {
            RIPMSG0(RIP_VERBOSE,"mouse_event(): Calls not forwarded for 4.0 or greater apps.");
            return FALSE;
        } else {
            BOOL fAccessToDesktop;

            /*
             * 3/22/95 BradG - Bug #9314: Screensavers are not deactivated by mouse_event()
             *    The main problem is the check above, since screensavers run on their own
             *    desktop.  This causes the above check to fail because the process using
             *    mouse_event() is running on another desktop.  The solution is to determine
             *    if we have access to the input desktop by calling _OpenDesktop for the
             *    current input desktop, grpdeskRitInput, with a request for DESKTOP_JOURNALPLAYBACK
             *    access.  If this succeeds, we can allow this mouse_event() request to pass
             *    through, otherwise return.
             */
            UserAssert(grpdeskRitInput != NULL);

            UserAssert(!(grpdeskRitInput->rpwinstaParent->dwWSF_Flags & WSF_NOIO));
            fAccessToDesktop = AccessCheckObject(grpdeskRitInput,
                    DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_JOURNALPLAYBACK,
                    KernelMode,
                    &DesktopMapping);
            if (!fAccessToDesktop) {
                RIPMSG0(RIP_VERBOSE, "mouse_event(): Call NOT forwarded to input desktop" );
                return FALSE;
            }

            /*
             * We do have access to the desktop, so
             * let this mouse_event() call go through.
             */
            RIPMSG0( RIP_VERBOSE, "mouse_event(): Call forwarded to input desktop" );
        }
    }

    /*
     * This process is providing input so it gets the right to
     *  call SetForegroundWindow
     */
    gppiInputProvider = pti->ppi;

    /*
     * The following code assumes that MOUSEEVENTF_MOVE == 1,
     * that MOUSEEVENTF_ABSOLUTE > all button flags, and that the
     * mouse_event button flags are defined in the same order as the
     * MOUSE_INPUT_DATA button bits.
     */
#if MOUSEEVENTF_MOVE != 1
#   error("MOUSEEVENTF_MOVE != 1")
#endif
#if MOUSEEVENTF_LEFTDOWN != MOUSE_LEFT_BUTTON_DOWN * 2
#   error("MOUSEEVENTF_LEFTDOWN != MOUSE_LEFT_BUTTON_DOWN * 2")
#endif
#if MOUSEEVENTF_LEFTUP != MOUSE_LEFT_BUTTON_UP * 2
#   error("MOUSEEVENTF_LEFTUP != MOUSE_LEFT_BUTTON_UP * 2")
#endif
#if MOUSEEVENTF_RIGHTDOWN != MOUSE_RIGHT_BUTTON_DOWN * 2
#   error("MOUSEEVENTF_RIGHTDOWN != MOUSE_RIGHT_BUTTON_DOWN * 2")
#endif
#if MOUSEEVENTF_RIGHTUP != MOUSE_RIGHT_BUTTON_UP * 2
#   error("MOUSEEVENTF_RIGHTUP != MOUSE_RIGHT_BUTTON_UP * 2")
#endif
#if MOUSEEVENTF_MIDDLEDOWN != MOUSE_MIDDLE_BUTTON_DOWN * 2
#   error("MOUSEEVENTF_MIDDLEDOWN != MOUSE_MIDDLE_BUTTON_DOWN * 2")
#endif
#if MOUSEEVENTF_MIDDLEUP != MOUSE_MIDDLE_BUTTON_UP * 2
#   error("MOUSEEVENTF_MIDDLEUP != MOUSE_MIDDLE_BUTTON_UP * 2")
#endif
#if MOUSEEVENTF_WHEEL != MOUSE_WHEEL * 2
#   error("MOUSEEVENTF_WHEEL != MOUSE_WHEEL * 2")
#endif

    /* set legal values */
    dwDriverMouseFlags = dwMEFlags & MOUSEEVENTF_BUTTONMASK;

    /* remove MOUSEEVENTF_XDOWN/UP because we are going to add
       MOUSEEVENTF_DRIVER_X1/2DOWN/UP later */
    dwDriverMouseFlags &= ~(MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP);

    dwDriverMouseData = 0;

    /*
     * Handle mouse wheel and xbutton inputs.
     *
     * Note that MOUSEEVENTF_XDOWN/UP and MOUSEEVENTF_MOUSEWHEEL cannot both
     * be specified since they share the mouseData field
     */
    if (    ((dwMEFlags & (MOUSEEVENTF_XDOWN | MOUSEEVENTF_WHEEL)) == (MOUSEEVENTF_XDOWN | MOUSEEVENTF_WHEEL)) ||
            ((dwMEFlags & (MOUSEEVENTF_XUP   | MOUSEEVENTF_WHEEL)) == (MOUSEEVENTF_XUP | MOUSEEVENTF_WHEEL))) {

        RIPMSG1(RIP_WARNING, "Can't specify both MOUSEEVENTF_XDOWN/UP and MOUSEEVENTF_WHEEL in call to SendInput, dwFlags=0x%.8X", dwMEFlags);
        dwDriverMouseFlags &= ~(MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP | MOUSEEVENTF_WHEEL);
    } else if (dwMEFlags & MOUSEEVENTF_WHEEL) {
        /*
         * Force the value to a short. We cannot fail if it is out of range
         * because we accepted a 32 bit value in NT 4.
         */
        dwDriverMouseData = min(max(SHRT_MIN, (LONG)mouseData), SHRT_MAX);
    } else {

        /* don't process xbuttons if mousedata has invalid buttons */
        if (~XBUTTON_MASK & mouseData) {
            RIPMSG1(RIP_WARNING, "Invalid xbutton specified in SendInput, mouseData=0x%.8X", mouseData);
        } else {
            if (dwMEFlags & MOUSEEVENTF_XDOWN) {
                if (mouseData & XBUTTON1) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X1DOWN;
                }
                if (mouseData & XBUTTON2) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X2DOWN;
                }
            }
            if (dwMEFlags & MOUSEEVENTF_XUP) {
                if (mouseData & XBUTTON1) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X1UP;
                }
                if (mouseData & XBUTTON2) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X2UP;
                }
            }
        }
    }

    /* Convert the MOUSEEVENTF_ flags to MOUSE_BUTTON flags sent by the driver */
    dwDriverMouseFlags >>= 1;

#ifdef GENERIC_INPUT
    mei.UnitId = INJECTED_UNIT_ID;
    if (dwMEFlags & MOUSEEVENTF_ABSOLUTE) {
        mei.Flags = MOUSE_MOVE_ABSOLUTE;
    } else {
        mei.Flags = MOUSE_MOVE_RELATIVE;
    }
    if (dwMEFlags & MOUSEEVENTF_VIRTUALDESK) {
        mei.Flags |= MOUSE_VIRTUAL_DESKTOP;
    }
    mei.Buttons = dwDriverMouseFlags;
    if (dwDriverMouseData) {
        mei.ButtonData = (USHORT)dwDriverMouseData;
    }
    mei.RawButtons = 0; // LATER...
    mei.LastX = dx;
    mei.LastY = dy;
    mei.ExtraInformation = (ULONG)dwExtraInfo;
#endif

    LeaveCrit();

    /*
     * Process coordinates first.  This is especially useful for absolute
     * pointing devices like touch-screens and tablets.
     */
    if (dwMEFlags & MOUSEEVENTF_MOVE) {
        TAGMSG2(DBGTAG_PNP, "xxxMouseEventDirect: posting mouse move msg: Flag=%04x MouseData=%04x",
                mei.Flags, mei.Buttons);
        xxxMoveEvent(dx, dy, dwMEFlags, dwExtraInfo,
#ifdef GENERIC_INPUT
                    /*
                     * This is a simulated input from SendInput API.
                     * There is no real mouse device associated with this input,
                     * so we can only pass NULL as a hDevice.
                     */
                     NULL,
                     &mei,
#endif
                     dwTime, TRUE);
    }

    TAGMSG2(DBGTAG_PNP, "xxxMoveEvent: queueing mouse msg: Flag=%04x MouseData=%04x",
            mei.Flags, mei.Buttons);
    QueueMouseEvent(
            (USHORT) dwDriverMouseFlags,
            (USHORT) dwDriverMouseData,
            dwExtraInfo,
            gptCursorAsync,
            dwTime,
#ifdef GENERIC_INPUT
            NULL,
            &mei,
#endif
            TRUE,
            FALSE
            );

    ProcessQueuedMouseEvents();

    EnterCrit();

    return TRUE;
}

/**************************************************************************\
* xxxInternalKeyEventDirect
*
* key event inserts a key event into the input stream.
*
* History:
* 07-23-92 Mikehar      Created.
\**************************************************************************/
BOOL xxxInternalKeyEventDirect(
   BYTE  bVk,
   WORD  wScan,
   DWORD dwFlags,
   DWORD dwTime,
   ULONG_PTR dwExtraInfo)
{
    PTHREADINFO pti = PtiCurrent();
    KE KeyEvent;

    /*
     * The calling thread must be on the active desktop
     * and have journal playback access to that desktop.
     */
    if (pti->rpdesk != grpdeskRitInput ||
        !(ISCSRSS() ||
          RtlAreAllAccessesGranted(pti->amdesk, DESKTOP_JOURNALPLAYBACK))) {

        RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING,
                  "Injecting key failed: Non active desktop or access denied");

        return FALSE;
    }
    UserAssert(!(pti->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    KeyEvent.bScanCode = (BYTE)wScan;
#ifdef GENERIC_INPUT
    /*
     * This is a injected key, no real device is associated with this...
     */
    KeyEvent.hDevice = NULL;
#endif

    if (dwFlags & KEYEVENTF_SCANCODE) {
        bVk = VKFromVSC(&KeyEvent,
                        (BYTE)(dwFlags & KEYEVENTF_EXTENDEDKEY ? 0xE0 : 0),
                        gafRawKeyState);
        KeyEvent.usFlaggedVk = (USHORT)bVk;
    } else {
        KeyEvent.usFlaggedVk = bVk | KBDINJECTEDVK;
    }

    if (dwFlags & KEYEVENTF_KEYUP)
        KeyEvent.usFlaggedVk |= KBDBREAK;

    if (dwFlags & KEYEVENTF_UNICODE) {
        KeyEvent.usFlaggedVk |= KBDUNICODE;
        KeyEvent.wchInjected = wScan;
    } else if (dwFlags & KEYEVENTF_EXTENDEDKEY) {
        KeyEvent.usFlaggedVk |= KBDEXT;
    } else {
        // Is it from the numeric keypad?
        if (((bVk >= VK_NUMPAD0) && (bVk <= VK_NUMPAD9)) || (bVk == VK_DECIMAL)) {
            KeyEvent.usFlaggedVk |= KBDNUMPAD;
        } else {
            int i;
            for (i = 0; ausNumPadCvt[i] != 0; i++) {
                if (bVk == LOBYTE(ausNumPadCvt[i])) {
                    KeyEvent.usFlaggedVk |= KBDNUMPAD;
                    break;
                }
            }
        }
    }

#ifdef GENERIC_INPUT
    /*
     * Let's simulate the input as far as we can.
     */
    KeyEvent.data.MakeCode = (BYTE)wScan;
    if (dwFlags & KEYEVENTF_KEYUP) {
        KeyEvent.data.Flags = KEY_BREAK;
    } else {
        KeyEvent.data.Flags = KEY_MAKE;
    }
    if (dwFlags & KEYEVENTF_EXTENDEDKEY) {
        KeyEvent.data.Flags |= KEY_E0;
    }
    KeyEvent.data.Reserved = 0;
    KeyEvent.data.UnitId = INJECTED_UNIT_ID;
    KeyEvent.data.ExtraInformation = (ULONG)dwExtraInfo;
#endif

    /*
     * This process is providing input so it gets the right to
     *  call SetForegroundWindow
     */
    gppiInputProvider = pti->ppi;

    KeyEvent.dwTime = dwTime;
    xxxProcessKeyEvent(&KeyEvent, dwExtraInfo, TRUE);

    return TRUE;
}


/*****************************************************************************\
*
*  _BlockInput()
*
*  This disables/enables input into USER via keyboard or mouse
*  If input is enabled and the caller
*  is disabling it, the caller gets the 'input cookie.'  This means two
*  things:
*      (a) Only the caller's thread can reenable input
*      (b) Only the caller's thread can fake input messages by calling
*          SendInput().
*
*  This guarantees a sequential uninterrupted input stream.
*
*  It can be used in conjunction with a journal playback hook however,
*  since USER still does some processing in *_event functions before
*  noticing a journal playback hook is around.
*
*  Note that the disabled state can be suspended, and will be, when the
*  fault dialog comes up.  ForceInputState() will save away the enabled
*  status, so input is cleared, then whack back the old stuff when done.
*  We do the same thing for capture, modality, blah blah.  This makes sure
*  that if somebody is hung, the end user can still type Ctrl+Alt+Del and
*  interact with the dialog.
*
\*****************************************************************************/
BOOL
_BlockInput(BOOL fBlockIt)
{
    PTHREADINFO ptiCurrent;

    ptiCurrent = PtiCurrent();

    /*
     * The calling thread must be on the active desktop and have journal
     * playback access to that desktop if it wants to block input.
     * (Unblocking is less restricted)
     */
    if (fBlockIt &&
            (ptiCurrent->rpdesk != grpdeskRitInput ||
            !RtlAreAllAccessesGranted(ptiCurrent->amdesk, DESKTOP_JOURNALPLAYBACK))) {

        RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING,
                  "BlockInput failed: Non active desktop or access denied");
        return FALSE;
    }
    UserAssert(!(ptiCurrent->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    /*
     * If we are enabling input
     *      * Is it disabled?  No, then fail the call
     *      * Is it disabled but we aren't the dude in control?  Yes, then
     *              fail the call.
     * If we are disabling input
     *      * Is it enabled?  No, then fail the call
     *      * Set us up as the dude in control
     */

    if (fBlockIt) {
        /*
         * Is input blocked right now?
         */
        if (gptiBlockInput != NULL) {
            return FALSE;
        }

        /*
         * Is this thread exiting?  If so, fail the call now.  User's
         * cleanup code won't get a chance to whack this back if so.
         */
        if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
            return FALSE;
        }

        /*
         * Set blocking on.
         */
        gptiBlockInput = ptiCurrent;
    } else {
        /*
         * Fail if input is not blocked, or blocked by another thread
         */
        if (gptiBlockInput != ptiCurrent) {
            return FALSE;
        }

        /*
         * This thread was blocking input, so now clear the block.
         */
        gptiBlockInput = NULL;
    }

    return TRUE;
}


/**************************************************************************\
* xxxSendInput
*
* input injection
*
* History:
* 11-01-96 CLupu      Created.
\**************************************************************************/
UINT xxxSendInput(
   UINT    nInputs,
   LPINPUT pInputs)
{
    UINT    nEv;
    LPINPUT pEvent;
    BOOLEAN fCanDiscontinue = Is510Compat(PtiCurrent()->dwExpWinVer);

    for (nEv = 0, pEvent = pInputs; nEv < nInputs; nEv++) {

        switch (pEvent->type) {
        case INPUT_MOUSE:
            if (!xxxMouseEventDirect(
                        pEvent->mi.dx,
                        pEvent->mi.dy,
                        pEvent->mi.mouseData,
                        pEvent->mi.dwFlags,
                        pEvent->mi.time,
                        pEvent->mi.dwExtraInfo) &&
                    fCanDiscontinue) {
                /*
                 * Note: the error code should have been assigned in
                 * xxx.*EventDirect routines, so we should just
                 * bail out.
                 */
                RIPMSG0(RIP_WARNING, "xxxMouseEventDirect: failed");
                goto discontinue;
            }
            break;

        case INPUT_KEYBOARD:
            if ((pEvent->ki.dwFlags & KEYEVENTF_UNICODE) &&
                    (pEvent->ki.wVk == 0) &&
                    ((pEvent->ki.dwFlags & ~(KEYEVENTF_KEYUP | KEYEVENTF_UNICODE)) == 0)) {
                if (!xxxInternalKeyEventDirect(
                            VK_PACKET,
                            pEvent->ki.wScan,   // actually a Unicode character
                            pEvent->ki.dwFlags,
                            pEvent->ki.time,
                            pEvent->ki.dwExtraInfo) &&
                        fCanDiscontinue) {
                    goto discontinue;
                }
            } else {
                if (!xxxInternalKeyEventDirect(
                            LOBYTE(pEvent->ki.wVk),
                            LOBYTE(pEvent->ki.wScan),
                            pEvent->ki.dwFlags,
                            pEvent->ki.time,
                            pEvent->ki.dwExtraInfo) &&
                        fCanDiscontinue) {
                    goto discontinue;
                }
            }
            break;

        case INPUT_HARDWARE:
            if (fCanDiscontinue) {
                /*
                 * Not supported on NT.
                 */
                RIPERR0(ERROR_CALL_NOT_IMPLEMENTED, RIP_WARNING, "xxxSendInput: INPUT_HARDWARE is for 9x only.");
                goto discontinue;
            }
            break;
        }

        pEvent++;
    }

discontinue:
    return nEv;
}

/**************************************************************************\
* _SetConsoleReserveKeys
*
* Sets the reserved keys field in the console's pti.
*
* History:
* 02-17-93 JimA         Created.
\**************************************************************************/

BOOL _SetConsoleReserveKeys(
    PWND pwnd,
    DWORD fsReserveKeys)
{
    GETPTI(pwnd)->fsReserveKeys = fsReserveKeys;
    return TRUE;
}

/**************************************************************************\
* _GetMouseMovePointsEx
*
* Gets the last nPoints mouse moves from the global buffer starting with
* ppt. Returns -1 if it doesn't find it. It uses the timestamp if it was
* provided to differentiate between mouse points with the same coordinates.
*
* History:
* 03-17-97 CLupu        Created.
\**************************************************************************/
int _GetMouseMovePointsEx(
    CONST MOUSEMOVEPOINT* ppt,
    MOUSEMOVEPOINT*       ccxpptBuf,
    UINT                  nPoints,
    DWORD                 resolution)
{
    UINT  uInd, uStart, nPointsRetrieved, i;
    BOOL  bFound = FALSE;
    int   x, y;
    DWORD resX, resY;

    /*
     * Search the point in the global buffer and get the first occurance.
     */
    uInd = uStart = PREVPOINT(gptInd);


    do {
        /*
         * The resolutions can be zero only if the buffer is still not full
         */
        if (HIWORD(gaptMouse[uInd].x) == 0 || HIWORD(gaptMouse[uInd].y) == 0) {
            break;
        }

        resX = (DWORD)HIWORD(gaptMouse[uInd].x) + 1;
        resY = (DWORD)HIWORD(gaptMouse[uInd].y) + 1;

        if ((int)resX != SYSMET(CXVIRTUALSCREEN)) {
            UserAssert(resX == 0x10000);
            x = LOWORD(gaptMouse[uInd].x) * SYSMET(CXVIRTUALSCREEN) / resX;
        } else {
            x = LOWORD(gaptMouse[uInd].x);
        }

        if ((int)resY != SYSMET(CYVIRTUALSCREEN)) {
            UserAssert(resY == 0x10000);
            y = LOWORD(gaptMouse[uInd].y) * SYSMET(CYVIRTUALSCREEN) / resY;
        } else {
            y = LOWORD(gaptMouse[uInd].y);
        }

        if (x == ppt->x && y == ppt->y) {
            /*
             * If the timestamp was provided check to see if it's the right
             * timestamp.
             */
            if (ppt->time != 0 && ppt->time != gaptMouse[uInd].time) {
                uInd = PREVPOINT(uInd);
                RIPMSG4(RIP_VERBOSE,
                        "GetMouseMovePointsEx: Found point (%x, %x) but timestamp %x diff from %x",
                        x, y, ppt->time, gaptMouse[uInd].time);
                continue;
            }

            bFound = TRUE;
            break;
        }
        uInd = PREVPOINT(uInd);
    } while (uInd != uStart);

    /*
     * The point might not be in the buffer anymore.
     */
    if (!bFound) {
        RIPERR2(ERROR_POINT_NOT_FOUND, RIP_VERBOSE,
                  "GetMouseMovePointsEx: point not found (%x, %x)", ppt->x, ppt->y);
        return -1;
    }

    /*
     * See how many points we can retrieve.
     */
    nPointsRetrieved = (uInd <= uStart ? uInd + MAX_MOUSEPOINTS - uStart : uInd - uStart);

    nPointsRetrieved = min(nPointsRetrieved, nPoints);

    /*
     * Copy the points to the app buffer.
     */
    try {
        for (i = 0; i < nPointsRetrieved; i++) {
            resX = (DWORD)HIWORD(gaptMouse[uInd].x) + 1;
            resY = (DWORD)HIWORD(gaptMouse[uInd].y) + 1;

            /*
             * If one of the resolutions is 0 then we're done.
             */
            if (HIWORD(gaptMouse[uInd].x) == 0 || HIWORD(gaptMouse[uInd].y) == 0) {
                break;
            }

            /*
             * LOWORD(gaptMouse[uInd].x) contains the x point on the scale
             * specified by HIWORD(gaptMouse[uInd].x).
             */
            if (resolution == GMMP_USE_HIGH_RESOLUTION_POINTS) {
                ccxpptBuf[i].x = (DWORD)LOWORD(gaptMouse[uInd].x) * 0xFFFF / (resX - 1);
                ccxpptBuf[i].y = (DWORD)LOWORD(gaptMouse[uInd].y) * 0xFFFF / (resY - 1);

            } else {
                UserAssert(resolution == GMMP_USE_DISPLAY_POINTS);

                ccxpptBuf[i].x = LOWORD(gaptMouse[uInd].x) * SYSMET(CXVIRTUALSCREEN) / resX;
                ccxpptBuf[i].y = LOWORD(gaptMouse[uInd].y) * SYSMET(CYVIRTUALSCREEN) / resY;
            }
            ccxpptBuf[i].time = gaptMouse[uInd].time;
            ccxpptBuf[i].dwExtraInfo = gaptMouse[uInd].dwExtraInfo;

            uInd = PREVPOINT(uInd);
        }
    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    return i;
}


/**************************************************************************\
* ProcessQueuedMouseEvents
*
* Process mouse events.
*
* History:
* 11-01-96 CLupu        Created.
\**************************************************************************/
VOID ProcessQueuedMouseEvents(
    VOID)
{
    MOUSEEVENT MouseEvent;
    static POINT ptCursorLast = {0,0};

    while (UnqueueMouseEvent(&MouseEvent)) {

        EnterCrit();

        // Setup to shutdown screen saver and exit video power down mode.
        if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
            // Call video driver here to exit power down mode.
            TAGMSG0(DBGTAG_Power, "Exit video power down mode");
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        }
        glinp.dwFlags &= ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES);

        gpsi->dwLastRITEventTickCount = MouseEvent.time;
        if (!gbBlockSendInputResets || !MouseEvent.bInjected) {
            glinp.timeLastInputMessage = MouseEvent.time;
        }

        if (gpsi->dwLastRITEventTickCount - gpsi->dwLastSystemRITEventTickCountUpdate > SYSTEM_RIT_EVENT_UPDATE_PERIOD) {
            SharedUserData->LastSystemRITEventTickCount = gpsi->dwLastRITEventTickCount;
            gpsi->dwLastSystemRITEventTickCountUpdate = gpsi->dwLastRITEventTickCount;
        }

        CLEAR_SRVIF(SRVIF_LASTRITWASKEYBOARD);

        gpsi->ptCursor = MouseEvent.ptPointer;

#ifdef GENERIC_INPUT
        if ((gpqForeground && TestRawInputMode(PtiMouseFromQ(gpqForeground), RawMouse))
#ifdef GI_SINK
            || IsMouseSinkPresent()
#endif
            ) {
            PostRawMouseInput(gpqForeground, MouseEvent.time, MouseEvent.hDevice, &MouseEvent.rawData);
        }
#endif

        if ((ptCursorLast.x != gpsi->ptCursor.x) ||
            (ptCursorLast.y != gpsi->ptCursor.y)) {

            /*
             * This mouse move ExtraInfo is global (as ptCursor
             * was) and is associated with the current ptCursor
             * position. ExtraInfo is sent from the driver - pen
             * win people use it.
             */
            gdwMouseMoveExtraInfo = MouseEvent.ExtraInfo;

            ptCursorLast = gpsi->ptCursor;

            /*
             * Wake up someone. xxxSetFMouseMoved() clears
             * dwMouseMoveExtraInfo, so we must then restore it.
             */
#ifdef GENERIC_INPUT
#ifdef GI_SINK
            if (IsMouseSinkPresent()) {
                PostRawMouseInput(gpqForeground, MouseEvent.time, MouseEvent.hDevice, &MouseEvent.rawData);
            }
#endif
            if (gpqForeground == NULL || !TestRawInputMode(PtiMouseFromQ(gpqForeground), NoLegacyMouse)) {
                zzzSetFMouseMoved();
            }
#else
            zzzSetFMouseMoved();
#endif

            gdwMouseMoveExtraInfo = MouseEvent.ExtraInfo;
        }

        if (MouseEvent.ButtonFlags != 0) {
            xxxDoButtonEvent(&MouseEvent);
        }

        LeaveCrit();
    }
}

/***************************************************************************\
* RawInputThread (RIT)
*
* This is the RIT.  It gets low-level/raw input from the device drivers
* and posts messages the appropriate queue.  It gets the input via APC
* calls requested by calling NtReadFile() for the keyboard and mouse
* drivers.  Basically it makes the first calls to Start*Read() and then
* sits in an NtWaitForSingleObject() loop which allows the APC calls to
* occur.
*
* All functions called exclusively on the RIT will have (RIT) next to
* the name in the header.
*
* History:
* 10-18-90 DavidPe      Created.
* 11-26-90 DavidPe      Rewrote to stop using POS layer.
\***************************************************************************/
#if DBG
DWORD gBlockDelay = 0;
DWORD gBlockSleep = 0;
#endif

VOID RawInputThread(
    PRIT_INIT pInitData)
{
    KPRIORITY      Priority;
    NTSTATUS       Status;
    UNICODE_STRING strRIT;
    UINT           NumberOfHandles = ID_NUMBER_HYDRA_REMOTE_HANDLES;
    PTERMINAL      pTerm;
    PMONITOR       pMonitorPrimary;
    HANDLE         hevtShutDown;
    PKEVENT        pEvents[2];
    USHORT         cEvents = 1;
    static DWORD   nLastRetryReadInput = 0;

    /*
     * Session 0  Console session does not need the shutdown event
     */


    pTerm = pInitData->pTerm;

    /*
     * Initialize GDI accelerators.  Identify this thread as a server thread.
     */
    apObjects = UserAllocPoolNonPaged(NumberOfHandles * sizeof(PVOID), TAG_SYSTEM);

    gWaitBlockArray = UserAllocPoolNonPagedNS(NumberOfHandles * sizeof(KWAIT_BLOCK),
                                             TAG_SYSTEM);

    if (apObjects == NULL || gWaitBlockArray == NULL) {
        RIPMSG0(RIP_WARNING, "RIT failed to allocate memory");
        goto Exit;
    }

    RtlZeroMemory(apObjects, NumberOfHandles * sizeof(PVOID));

    /*
     * Set the priority of the RIT to maximum allowed.
     * LOW_REALTIME_PRIORITY - 1 is chosen so that the RIT
     * does not block the Mm Working set trimmer thread
     * in the memory starvation situation.
     */
#ifdef W2K_COMPAT_PRIORITY
    Priority = LOW_REALTIME_PRIORITY + 3;
#else
    Priority = LOW_REALTIME_PRIORITY - 1;
#endif

    ZwSetInformationThread(NtCurrentThread(),
                           ThreadPriority,
                           &Priority,
                           sizeof(KPRIORITY));

    RtlInitUnicodeString(&strRIT, L"WinSta0_RIT");

    /*
     * Create an event for signalling mouse/kbd attach/detach and device-change
     * notifications such as QueryRemove, RemoveCancelled etc.
     */
    aDeviceTemplate[DEVICE_TYPE_KEYBOARD].pkeHidChange =
            apObjects[ID_HIDCHANGE] =
            CreateKernelEvent(SynchronizationEvent, FALSE);
    aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange =
            CreateKernelEvent(SynchronizationEvent, FALSE);

#ifdef GENERIC_INPUT
    gpkeHidChange =
    apObjects[ID_TRUEHIDCHANGE] =
    aDeviceTemplate[DEVICE_TYPE_HID].pkeHidChange = CreateKernelEvent(SynchronizationEvent, FALSE);
#endif

    /*
     * Create an event for desktop threads to pass mouse input to RIT
     */
    apObjects[ID_MOUSE] = CreateKernelEvent(SynchronizationEvent, FALSE);
    gpkeMouseData = apObjects[ID_MOUSE];

    if (aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange == NULL ||
            apObjects[ID_HIDCHANGE] == NULL ||
            gpkeMouseData == NULL
#ifdef GENERIC_INPUT
            || gpkeHidChange == NULL
#endif
        ) {
        RIPMSG0(RIP_WARNING, "RIT failed to create a required input event");
        goto Exit;
    }

    /*
     * Initialize keyboard device driver.
     */
    EnterCrit();
    InitKeyboard();
    InitMice();
    LeaveCrit();

    Status = InitSystemThread(&strRIT);

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "RIT failed InitSystemThread");
        goto Exit;
    }

    UserAssert(gpepCSRSS != NULL);

    /*
     * Allow the system to read the screen
     */
    ((PW32PROCESS)PsGetProcessWin32Process(gpepCSRSS))->W32PF_Flags |= (W32PF_READSCREENACCESSGRANTED|W32PF_IOWINSTA);

    /*
     * Initialize the cursor clipping rectangle to the screen rectangle.
     */
    UserAssert(gpDispInfo != NULL);
    grcCursorClip = gpDispInfo->rcScreen;

    /*
     * Initialize gpsi->ptCursor and gptCursorAsync
     */
    pMonitorPrimary = GetPrimaryMonitor();

    UserAssert(gpsi != NULL);

    gpsi->ptCursor.x = pMonitorPrimary->rcMonitor.right / 2;
    gpsi->ptCursor.y = pMonitorPrimary->rcMonitor.bottom / 2;
    gptCursorAsync = gpsi->ptCursor;

    /*
     * The hung redraw list should already be set to NULL by the compiler,
     * linker & loader since it is an uninitialized global variable. Memory will
     * be allocated the first time a pwnd is added to this list (hungapp.c)
     */
    UserAssert(gpvwplHungRedraw == NULL);

    /*
     * Initialize the pre-defined hotkeys
     */
    EnterCrit();
    _RegisterHotKey(PWND_INPUTOWNER, IDHOT_WINDOWS, MOD_WIN, VK_NONE);
    SetDebugHotKeys();
    LeaveCrit();

    /*
     * Create a timer for timers.
     */
    gptmrMaster = UserAllocPoolNonPagedNS(sizeof(KTIMER),
                                        TAG_SYSTEM);
    if (gptmrMaster == NULL) {
        RIPMSG0(RIP_WARNING, "RIT failed to create gptmrMaster");
        goto Exit;
    }

    KeInitializeTimer(gptmrMaster);
    apObjects[ID_TIMER] = gptmrMaster;

    /*
     * Create an event for mouse device reads to signal the desktop thread to
     * move the pointer and QueueMouseEvent().
     * We should do this *before* we have any devices.
     */
    UserAssert(gpDeviceInfoList == NULL);


    if (!gbRemoteSession) {
        gptmrWD = UserAllocPoolNonPagedNS(sizeof(KTIMER), TAG_SYSTEM);

        if (gptmrWD == NULL) {
            Status = STATUS_NO_MEMORY;
            RIPMSG0(RIP_WARNING, "RemoteConnect failed to create gptmrWD");
            goto Exit;
        }
        KeInitializeTimerEx(gptmrWD, SynchronizationTimer);
    }


    /*
     * At this point, the WD timer must already have been initialized by RemoteConnect
     */



    UserAssert(gptmrWD != NULL);
    apObjects[ID_WDTIMER] = gptmrWD;

    if (IsRemoteConnection() ) {
        BOOL   fSuccess=TRUE;
        fSuccess &= !!HDXDrvEscape(gpDispInfo->hDev,
                                   ESC_SET_WD_TIMEROBJ,
                                   (PVOID)gptmrWD,
                                   sizeof(gptmrWD));

        if (!fSuccess) {
            Status = STATUS_UNSUCCESSFUL;
            RIPMSG0(RIP_WARNING, "RemoteConnect failed to pass gptmrWD to display driver");
            goto Exit;
        }
    }

    if (IsRemoteConnection()) {

        UNICODE_STRING    ustrName;
        BOOL              fSuccess = TRUE;



        RtlInitUnicodeString(&ustrName, NULL);

        /*
         * Pass a pointer to the timer to the WD via the display driver
         */
        EnterCrit();

        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_MOUSE, &ustrName, 0);
        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_KEYBOARD, &ustrName, 0);

        LeaveCrit();

        if (!fSuccess) {
            RIPMSG0(RIP_WARNING,
                    "RIT failed HDXDrvEscape or the creation of input devices");
            goto Exit;
        }
    } else {
        EnterCrit();

        /*
         * Register for Plug and Play devices.
         * If any PnP devices are already attached, these will be opened and
         * we will start reading them at this time.
         */
        xxxRegisterForDeviceClassNotifications();

        LeaveCrit();
    }

    if (gbRemoteSession) {
        WCHAR             szName[MAX_SESSION_PATH];
        UNICODE_STRING    ustrName;
        OBJECT_ATTRIBUTES obja;
        /*
         * Create the shutdown event. This event will be signaled
         * from W32WinStationTerminate.
         * This is a named event opend by CSR to signal that win32k should
         * go away. It's used in ntuser\server\api.c
         */
        swprintf(szName, L"\\Sessions\\%ld\\BaseNamedObjects\\EventShutDownCSRSS",
                 gSessionId);
        RtlInitUnicodeString(&ustrName, szName);

        InitializeObjectAttributes(&obja,
                                   &ustrName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = ZwCreateEvent(&hevtShutDown,
                               EVENT_ALL_ACCESS,
                               &obja,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "RIT failed to create EventShutDownCSRSS");
            goto Exit;
        }

        ObReferenceObjectByHandle(hevtShutDown,
                                  EVENT_ALL_ACCESS,
                                  *ExEventObjectType,
                                  KernelMode,
                                  &apObjects[ID_SHUTDOWN],
                                  NULL);
        pEvents[1] = apObjects[ID_SHUTDOWN];
        cEvents++;
    } else {

        hevtShutDown = NULL;

        Status = PoRequestShutdownEvent(&apObjects[ID_SHUTDOWN]);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "RIT failed to get shutdown event");
            goto Exit;
        }
    }

    /*
     * Get the rit-thread.
     */
    gptiRit = PtiCurrentShared();

    HYDRA_HINT(HH_RITCREATED);

    /*
     * Don't allow this thread to get involved with journal synchronization.
     */
    gptiRit->TIF_flags |= TIF_DONTJOURNALATTACH;

    /*
     * Also wait on our input event so the cool switch window can
     * receive messages.
     */
    apObjects[ID_INPUT] = gptiRit->pEventQueueServer;

    /*
     * Signal that the rit has been initialized
     */
    KeSetEvent(pInitData->pRitReadyEvent, EVENT_INCREMENT, FALSE);

    pEvents[0] = pTerm->pEventInputReady;

    /*
     * Wait until the first desktop is created.
     */
    ObReferenceObjectByPointer(pEvents[0],
                               EVENT_ALL_ACCESS,
                               *ExEventObjectType,
                               KernelMode);

    Status = KeWaitForMultipleObjects(cEvents,
                                      pEvents,
                                      WaitAny,
                                      WrUserRequest,
                                      KernelMode,
                                      FALSE,
                                      NULL,
                                      NULL);
    ObDereferenceObject(pEvents[0]);

    if (Status == WAIT_OBJECT_0 + 1) {
        KeSetEvent(pEvents[1], EVENT_INCREMENT, FALSE);
        InitiateWin32kCleanup();

        ObDereferenceObject(pEvents[1]);
        if (hevtShutDown) {
            ZwClose(hevtShutDown);
        }
        return;
    }

    /*
     * Switch to the first desktop if no switch has been
     * performed.
     */
    EnterCrit();

    if (gptiRit->rpdesk == NULL) {
        UserVerify(xxxSwitchDesktop(gptiRit->pwinsta, gptiRit->pwinsta->rpdeskList, 0));
    }

    /*
     * The io desktop thread is supposed to be created at this point.
     * The xxxSwitchDesktop call is expected to set the io desktop thread to run in grpdeskritinput
     */
    if ((pTerm->ptiDesktop == NULL) || (pTerm->ptiDesktop->rpdesk != grpdeskRitInput)) {
        FRE_RIPMSG0(RIP_ERROR, "RawInputThread: Desktop thread not running on grpdeskRitInput");
    }

    /*
     * Create a timer for hung app detection/redrawing.
     */
    StartTimers();

    LeaveCrit();

    /*
     * Go into a wait loop so we can process input events and APCs as
     * they occur.
     */
    while (TRUE) {

        CheckCritOut();

        Status = KeWaitForMultipleObjects(NumberOfHandles,
                                          apObjects,
                                          WaitAny,
                                          WrUserRequest,
                                          KernelMode,
                                          TRUE,
                                          NULL,
                                          gWaitBlockArray);

        UserAssert(NT_SUCCESS(Status));

        if (gdwUpdateKeyboard != 0) {
            /*
             * Here's our opportunity to process pending IOCTLs for the kbds:
             * These are asynchronous IOCTLS, so be sure any buffers passed
             * in to ZwDeviceIoControlFile are not in the stack!
             * Using gdwUpdateKeyboard to tell the RIT to issue these IOCTLS
             * renders the action asynchronous (delayed until next apObjects
             * event), but the IOCTL was asynch anyway
             */
            PDEVICEINFO pDeviceInfo;
            EnterDeviceInfoListCrit();
            for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
                if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                    if (gdwUpdateKeyboard & UPDATE_KBD_TYPEMATIC) {
                        ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                                &giosbKbdControl, IOCTL_KEYBOARD_SET_TYPEMATIC,
                                (PVOID)&gktp, sizeof(gktp), NULL, 0);
                    }
                    if (gdwUpdateKeyboard & UPDATE_KBD_LEDS) {
                        ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                                &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                                (PVOID)&gklp, sizeof(gklp), NULL, 0);
                    }
                }
            }
            LeaveDeviceInfoListCrit();
            if ((gdwUpdateKeyboard & UPDATE_KBD_LEDS) && gfRemotingConsole) {
                    ZwDeviceIoControlFile(ghConsoleShadowKeyboardChannel, NULL, NULL, NULL,
                            &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                            (PVOID)&gklp, sizeof(gklp), NULL, 0);
            }
            gdwUpdateKeyboard &= ~(UPDATE_KBD_TYPEMATIC | UPDATE_KBD_LEDS);
        }

        if (Status == ID_MOUSE) {
            /*
             * A desktop thread got some Mouse input for us. Process it.
             */
            ProcessQueuedMouseEvents();

        } else if (Status == ID_HIDCHANGE) {
            TAGMSG0(DBGTAG_PNP | RIP_THERESMORE, "RIT wakes for HID Change");
            EnterCrit();
            ProcessDeviceChanges(DEVICE_TYPE_KEYBOARD);
            LeaveCrit();
        }
#ifdef GENERIC_INPUT
        else if (Status == ID_TRUEHIDCHANGE) {
            TAGMSG0(DBGTAG_PNP | RIP_THERESMORE, "RIT wakes for True HID Change");
            EnterCrit();
            ProcessDeviceChanges(DEVICE_TYPE_HID);
            LeaveCrit();
        }
#endif
        else if (Status == ID_SHUTDOWN) {

            InitiateWin32kCleanup();

            if(gbRemoteSession) {
                ObDereferenceObject(apObjects[ID_SHUTDOWN]);
            }
            if (hevtShutDown) {
                ZwClose(hevtShutDown);
            }

            break;

        } else if (Status == ID_WDTIMER) {
            //LARGE_INTEGER liTemp;

            EnterCrit();


            /*
             * Call the TShare display driver to flush the frame buffer
             */

            if (IsRemoteConnection()) {
                if (!HDXDrvEscape(gpDispInfo->hDev, ESC_TIMEROBJ_SIGNALED, NULL, 0)) {
                    UserAssert(FALSE);
                }
            } else {
                if (gfRemotingConsole && gConsoleShadowhDev != NULL) {
                    ASSERT(gConsoleShadowhDev != NULL);
                    if (!HDXDrvEscape(gConsoleShadowhDev, ESC_TIMEROBJ_SIGNALED, NULL, 0)) {
                        UserAssert(FALSE);
                    }
                }
            }

            LeaveCrit();

        } else {
            /*
             * If the master timer has expired, then process the timer
             * list. Otherwise, an APC caused the raw input thread to be
             * awakened.
             */
            if (Status == ID_TIMER) {
                TimersProc();
                /*
                 * If an input degvice read failed due to insufficient resources,
                 * we retry by signalling the proper thread: ProcessDeviceChanges
                 * will call RetryReadInput().
                 */
                if (gnRetryReadInput != nLastRetryReadInput) {
                    nLastRetryReadInput = gnRetryReadInput;
                    KeSetEvent(aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange, EVENT_INCREMENT, FALSE);
                    KeSetEvent(aDeviceTemplate[DEVICE_TYPE_KEYBOARD].pkeHidChange, EVENT_INCREMENT, FALSE);
                }
            }

#if DBG
            /*
             * In the debugger set gBlockSleep to n:
             * The RIT will sleep n millicseconds, then n timer ticks later
             * will sleep n milliseconds again.
             */
            if (gBlockDelay) {
                gBlockDelay--;
            } else if ((gBlockDelay == 0) && (gBlockSleep != 0)) {
                UserSleep(gBlockSleep);
                gBlockDelay = 100 * gBlockSleep;
            }
#endif

            /*
             * if in cool task switcher window, dispose of the messages
             * on the queue
             */
            if (gspwndAltTab != NULL) {
                EnterCrit();
                xxxReceiveMessages(gptiRit);
                LeaveCrit();
            }
        }
    }

    return;

Exit:

    UserAssert(gptiRit == NULL);

    /*
     * Signal that the rit has been initialized
     */
    KeSetEvent(pInitData->pRitReadyEvent, EVENT_INCREMENT, FALSE);

    RIPMSG0(RIP_WARNING, "RIT initialization failure");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\paint.c ===
/****************************** Module Header ******************************\
* Module Name: paint.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the APIs used to begin and end window painting.
*
* History:
* 27-Oct-1990 DarrinM   Created.
* 12-Feb-1991 IanJa     HWND revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxFillWindow (not an API)
*
* pwndBrush - The brush is aligned with with client rect of this window.
*             It is usually either pwndPaint or pwndPaint's parent.
*
* pwndPaint - The window to paint.
* hdc       - The DC to paint in.
* hbr       - The brush to use.
*
* Returns TRUE if successful, FALSE if not.
*
* History:
* 15-Nov-1990 DarrinM   Ported from Win 3.0 sources.
* 21-Jan-1991 IanJa     Prefix '_' denoting exported function.
\***************************************************************************/

BOOL xxxFillWindow(
    PWND   pwndBrush,
    PWND   pwndPaint,
    HDC    hdc,
    HBRUSH hbr)
{
    RECT rc;

    CheckLock(pwndBrush);
    CheckLock(pwndPaint);

    /*
     * If there is no pwndBrush (sometimes the parent), use pwndPaint.
     */
    if (pwndBrush == NULL)
        pwndBrush = pwndPaint;

    if (UT_GetParentDCClipBox(pwndPaint, hdc, &rc))
        return xxxPaintRect(pwndBrush, pwndPaint, hdc, hbr, &rc);

    return TRUE;
}

/***************************************************************************\
* xxxPaintRect
*
* pwndBrush - The brush is aligned with with client rect of this window.
*             It is usually either pwndPaint or pwndPaint's parent.
*
* pwndPaint - The window to paint in.
* hdc       - The DC to paint in.
* hbr       - The brush to use.
* lprc      - The rectangle to paint.
*
* History:
* 15-Nov-1990 DarrinM   Ported from Win 3.0 sources.
* 21-Jan-1991 IanJa     Prefix '_' denoting exported function.
\***************************************************************************/

BOOL xxxPaintRect(
    PWND   pwndBrush,
    PWND   pwndPaint,
    HDC    hdc,
    HBRUSH hbr,
    LPRECT lprc)
{
    POINT ptOrg;

    CheckLock(pwndBrush);
    CheckLock(pwndPaint);

    if (pwndBrush == NULL) {
        pwndBrush = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
    }

    if (pwndBrush == PWNDDESKTOP(pwndBrush)) {
        GreSetBrushOrg(
                hdc,
                0,
                0,
                &ptOrg);
    } else {
        GreSetBrushOrg(
                hdc,
                pwndBrush->rcClient.left - pwndPaint->rcClient.left,
                pwndBrush->rcClient.top - pwndPaint->rcClient.top,
                &ptOrg);
    }

    /*
     * If hbr < CTLCOLOR_MAX, it isn't really a brush but is one of our
     * special color values.  Translate it to the appropriate WM_CTLCOLOR
     * message and send it off to get back a real brush.  The translation
     * process assumes the CTLCOLOR*** and WM_CTLCOLOR*** values map directly.
     */
    if (hbr < (HBRUSH)CTLCOLOR_MAX) {
        hbr = xxxGetControlColor(pwndBrush,
                                 pwndPaint,
                                 hdc,
                                 HandleToUlong(hbr) + WM_CTLCOLORMSGBOX);
    }

    FillRect(hdc, lprc, hbr);

    GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, NULL);


    return TRUE;
}

/***************************************************************************\
* DeleteMaybeSpecialRgn
*
* Deletes a GDI region, making sure it is not a special region.
*
* History:
* 26-Feb-1992 MikeKe    from win3.1
\***************************************************************************/

VOID DeleteMaybeSpecialRgn(
    HRGN hrgn)
{
    if (hrgn > HRGN_SPECIAL_LAST) {
        GreDeleteObject(hrgn);
    }
}



/***************************************************************************\
* GetNCUpdateRgn
*
* Gets the update region which includes the non-client area.
*
* History:
* 26-Feb-1992 MikeKe    From win3.1
\***************************************************************************/

HRGN GetNCUpdateRgn(
    PWND pwnd,
    BOOL fValidateFrame)
{
    HRGN hrgnUpdate;

    if (pwnd->hrgnUpdate > HRGN_FULL) {

        /*
         * We must make a copy of our update region, because
         * it could change if we send a message, and we want to
         * make sure the whole thing is used for drawing our
         * frame and background.  We can't use a global
         * temporary region, because more than one app may
         * be calling this routine.
         */
        hrgnUpdate = CreateEmptyRgnPublic();

        if (hrgnUpdate == NULL) {
            hrgnUpdate = HRGN_FULL;
        } else if (CopyRgn(hrgnUpdate, pwnd->hrgnUpdate) == ERROR) {
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = HRGN_FULL;
        }

        if (fValidateFrame) {

            /*
             * Now that we've taken care of any frame drawing,
             * intersect the update region with the window's
             * client area.  Otherwise, apps that do ValidateRects()
             * to draw themselves (e.g., WinWord) won't ever
             * subtract off the part of the update region that
             * overlaps the frame but not the client.
             */
            CalcWindowRgn(pwnd, ghrgnInv2, TRUE);

            switch (IntersectRgn(pwnd->hrgnUpdate,
                                 pwnd->hrgnUpdate,
                                 ghrgnInv2)) {
            case ERROR:
                /*
                 * If an error occured, we can't leave things as
                 * they are: invalidate the whole window and let
                 * BeginPaint() take care of it.
                 */
                GreDeleteObject(pwnd->hrgnUpdate);
                pwnd->hrgnUpdate = HRGN_FULL;
                break;

            case NULLREGION:
                /*
                 * There is nothing in the client area to repaint.
                 * Blow the region away, and decrement the paint count
                 * if possible.
                 */
                GreDeleteObject(pwnd->hrgnUpdate);
                pwnd->hrgnUpdate = NULL;
                ClrWF(pwnd, WFUPDATEDIRTY);
                if (!TestWF(pwnd, WFINTERNALPAINT))
                    DecPaintCount(pwnd);
                break;
            }
        }

    } else {
        hrgnUpdate = pwnd->hrgnUpdate;
    }

    return hrgnUpdate;
}

/***************************************************************************\
* xxxSendNCPaint
*
* Sends a WM_NCPAINT message to a window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxSendNCPaint(
    PWND pwnd,
    HRGN hrgnUpdate)
{
    CheckLock(pwnd);

    /*
     * Clear the WFSENDNCPAINT bit...
     */
    ClrWF(pwnd, WFSENDNCPAINT);

    /*
     * If the window is active, but its FRAMEON bit hasn't
     * been set yet, set it and make sure that the entire frame
     * gets redrawn when we send the NCPAINT.
     */
    if ((pwnd == PtiCurrent()->pq->spwndActive) && !TestWF(pwnd, WFFRAMEON)) {
        SetWF(pwnd, WFFRAMEON);
        hrgnUpdate = HRGN_FULL;
        ClrWF(pwnd, WFNONCPAINT);
    }

    /*
     * If PixieHack() has set the WM_NCPAINT bit, we must be sure
     * to send with hrgnClip == HRGN_FULL.  (see PixieHack() in wmupdate.c)
     */
    if (TestWF(pwnd, WFPIXIEHACK)) {
        ClrWF(pwnd, WFPIXIEHACK);
        hrgnUpdate = HRGN_FULL;
    }

    if (hrgnUpdate)
        xxxSendMessage(pwnd, WM_NCPAINT, (WPARAM)hrgnUpdate, 0L);
}



/***************************************************************************\
* xxxSendChildNCPaint
*
* Sends WM_NCPAINT message to the immediate children of a window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxSendChildNCPaint(
    PWND pwnd)
{
    TL tlpwnd;

    CheckLock(pwnd);

    ThreadLockNever(&tlpwnd);
    pwnd = pwnd->spwndChild;
    while (pwnd != NULL) {
        if ((pwnd->hrgnUpdate == NULL) && TestWF(pwnd, WFSENDNCPAINT)) {
            ThreadLockExchangeAlways(pwnd, &tlpwnd);
            xxxSendNCPaint(pwnd, HRGN_FULL);
        }

        pwnd = pwnd->spwndNext;
    }

    ThreadUnlock(&tlpwnd);
}

/***************************************************************************\
* xxxBeginPaint
*
* Revalidation Note:
* We MUST return NULL if the window is deleted during xxxBeginPaint because
* its DCs are released upon deletion, and we shouldn't return a *released* DC!
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

HDC xxxBeginPaint(
    PWND          pwnd,
    LPPAINTSTRUCT lpps)
{
    HRGN hrgnUpdate;
    HDC  hdc;
    BOOL fSendEraseBkgnd;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (TEST_PUDF(PUDF_DRAGGINGFULLWINDOW))
        SetWF(pwnd, WFSTARTPAINT);

    /*
     * We're processing a WM_PAINT message: clear this flag.
     */
    ClrWF(pwnd, WFPAINTNOTPROCESSED);

    /*
     * If this bit gets set while we are drawing the frame we will need
     * to redraw it.
     *
     * If necessary, send our WM_NCPAINT message now.
     *
     * please heed these notes
     *
     * We have to send this message BEFORE we diddle hwnd->hrgnUpdate,
     * because an app may call ValidateRect or InvalidateRect in its
     * handler, and it expects what it does to affect what gets drawn
     * in the later WM_PAINT.
     *
     * It is possible to get an invalidate when we leave the critical
     * section below, therefore we loop until UPDATEDIRTY is clear
     * meaning there were no additional invalidates.
     */
    if (TestWF(pwnd, WFSENDNCPAINT)) {

        do {
            ClrWF(pwnd, WFUPDATEDIRTY);
            hrgnUpdate = GetNCUpdateRgn(pwnd, FALSE);
            xxxSendNCPaint(pwnd, hrgnUpdate);
            DeleteMaybeSpecialRgn(hrgnUpdate);
        } while (TestWF(pwnd, WFUPDATEDIRTY));

    } else {
        ClrWF(pwnd, WFUPDATEDIRTY);
    }

    /*
     * Hide the caret if needed.  Do this before we get the DC so
     * that if HideCaret() gets and releases a DC we will be able
     * to reuse it later here.
     * No need to DeferWinEventNotify() since pwnd is locked.
     */
    if (pwnd == PtiCurrent()->pq->caret.spwnd)
        zzzInternalHideCaret();

    /*
     * Send the check for sending an WM_ERASEBKGND to the
     * window.
     */
    if (fSendEraseBkgnd = TestWF(pwnd, WFSENDERASEBKGND)) {
        ClrWF(pwnd, WFERASEBKGND);
        ClrWF(pwnd, WFSENDERASEBKGND);
    }

    /*
     * Validate the entire window.
     */
    if (NEEDSPAINT(pwnd))
        DecPaintCount(pwnd);

    ClrWF(pwnd, WFINTERNALPAINT);

    hrgnUpdate = pwnd->hrgnUpdate;
    pwnd->hrgnUpdate = NULL;

    if (TestWF(pwnd, WFDONTVALIDATE)) {

        if (ghrgnUpdateSave == NULL) {
            ghrgnUpdateSave = CreateEmptyRgn();
        }

        if (ghrgnUpdateSave != NULL) {
            UnionRgn(ghrgnUpdateSave, ghrgnUpdateSave, hrgnUpdate);
            gnUpdateSave++;
        }
    }

    /*
     * Clear these flags for backward compatibility
     */
    lpps->fIncUpdate =
    lpps->fRestore   = FALSE;

    lpps->hdc =
    hdc       = _GetDCEx(pwnd,
                         hrgnUpdate,
                         DCX_USESTYLE | DCX_INTERSECTRGN);

    if (UT_GetParentDCClipBox(pwnd, hdc, &lpps->rcPaint)) {

        /*
         * If necessary, erase our background, and possibly deal with
         * our children's frames and backgrounds.
         */
        if (fSendEraseBkgnd)
            xxxSendEraseBkgnd(pwnd, hdc, hrgnUpdate);
    }

    /*
     * Now that we're completely erased, see if there are any children
     * that couldn't draw their own frames because their update regions
     * got deleted.
     */
    xxxSendChildNCPaint(pwnd);

    /*
     * The erase and frame operation has occured. Clear the WFREDRAWIFHUNG
     * bit here. We don't want to clear it until we know the erase and
     * frame has occured, so we know we always have a consistent looking
     * window.
     */
    ClearHungFlag(pwnd, WFREDRAWIFHUNG);

    lpps->fErase = (TestWF(pwnd, WFERASEBKGND) != 0);

    return hdc;
}

/***************************************************************************\
* xxxEndPaint (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxEndPaint(
    PWND          pwnd,
    LPPAINTSTRUCT lpps)
{
    CheckLock(pwnd);

    ReleaseCacheDC(lpps->hdc, TRUE);

    if (TestWF(pwnd, WFDONTVALIDATE)) {

        if (ghrgnUpdateSave != NULL) {

            InternalInvalidate3(pwnd,
                                ghrgnUpdateSave,
                                RDW_INVALIDATE | RDW_ERASE);

            if (--gnUpdateSave == 0) {
                GreDeleteObject(ghrgnUpdateSave);
                ghrgnUpdateSave = NULL;
            }
        }

        ClrWF(pwnd, WFDONTVALIDATE);
    }

    ClrWF(pwnd, WFWMPAINTSENT);

    /*
     * This used to check that the update-region was empty before
     * doing the clear.  However, this caused a problem with WOW
     * amipro/approach hanging.  They were invalidating rects in
     * their WM_PAINT handler, and allowing the defwindowproc to
     * perform the validation for them.  Since we were blocking
     * the BeginPaint in this case, it sent them into a infinite
     * loop (see bug 19036).
     */
    ClrWF(pwnd, WFSTARTPAINT);

    /*
     * Reshow the caret if needed, but AFTER we've released the DC.
     * This way ShowCaret() can reuse the DC we just released.
     */
    if (pwnd == PtiCurrent()->pq->caret.spwnd)
        zzzInternalShowCaret();

    return TRUE;
}

/***************************************************************************\
* GetLastChild
*
\***************************************************************************/

PWND GetLastChild(PWND pwnd)
{
    PWND pwndLast;

    pwnd = pwnd->spwndChild;
    pwndLast = pwnd;

    while (pwnd != NULL) {
        pwndLast = pwnd;
        pwnd = pwnd->spwndNext;
    }

    return pwndLast;
}

/***************************************************************************\
* xxxCompositedTraverse
*
* Uses pre-order traversal starting with the last child to render the
* windows in a bottom-up order.
*
* 9/30/1999       vadimg      created
\***************************************************************************/

BOOL xxxCompositedTraverse(PWND pwnd)
{
    TL tlpwnd;
    BOOL fPainted = FALSE;

    CheckLock(pwnd);

    if (NEEDSPAINT(pwnd)) {
        xxxSendMessage(pwnd, WM_PAINT, 0, 0);
        fPainted = TRUE;
    }

    pwnd = GetLastChild(pwnd);
    ThreadLock(pwnd, &tlpwnd);

    while (pwnd != NULL) {

        if (xxxCompositedTraverse(pwnd)) {
            fPainted = TRUE;
        }
        pwnd = pwnd->spwndPrev;

        if (ThreadLockExchange(pwnd, &tlpwnd) == NULL) {
            break;
        }
    }

    ThreadUnlock(&tlpwnd);
    return fPainted;
}

/***************************************************************************\
* xxxCompositedPaint
*
* 9/30/1999       vadimg      created
\***************************************************************************/

VOID xxxCompositedPaint(PWND pwnd)
{
    BOOL fPainted;
    HBITMAP hbm, hbmOld;
    PREDIRECT prdr;
    HDC hdc;
    LPRECT prc;
    SIZE size;
    POINT pt;

    CheckLock(pwnd);
    UserAssert(TestWF(pwnd, WEFCOMPOSITED));

    SetWF(pwnd, WEFPCOMPOSITING);

    /*
     * Render the child windows in a bottom-up order.
     */
    fPainted = xxxCompositedTraverse(pwnd);

    ClrWF(pwnd, WEFPCOMPOSITING);

    /*
     * While we were compositing, an invalid region may have accumulated.
     * So, let's go and invalidate that area of the window.
     */
    BEGINATOMICCHECK();
    prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
    if (prdr != NULL && prdr->hrgnComp != NULL) {

        xxxInternalInvalidate(pwnd, prdr->hrgnComp, RDW_INVALIDATE |
                RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);

        if (prdr->hrgnComp != HRGN_FULL) {
            GreDeleteObject(prdr->hrgnComp);
        }

        prdr->hrgnComp = NULL;
    }
    ENDATOMICCHECK();

#ifdef REDIRECTION
    if (TestWF(pwnd, WEFEXTREDIRECTED)) {
        return;
    }
#endif // REDIRECTION

    BEGINATOMICCHECK();

    if (fPainted && TestWF(pwnd, WEFPREDIRECTED)) {

        prdr = (PREDIRECT)_GetProp(pwnd, PROP_LAYER, TRUE);
        prc = &prdr->rcUpdate;
        hbm = prdr->hbm;
        UserAssert(hbm != NULL);

        if (TestWF(pwnd, WEFLAYERED)) {

            hbmOld = GreSelectBitmap(ghdcMem, hbm);

            size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
            size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

            pt.x = pt.y = 0;
            GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL, NULL,
                    &size, ghdcMem, &pt, 0, NULL, ULW_DEFAULT_ATTRIBUTES, prc);

            GreSelectBitmap(ghdcMem, hbmOld);
        } else {

            /*
             * Temporarily clear the redirected bit so that we can get the dc
             * with proper screen clipping.
             */
            ClrWF(pwnd, WEFPREDIRECTED);

            hbmOld = GreSelectBitmap(ghdcMem, hbm);
            hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW | DCX_CACHE);
    
            /*
             * Transfer the bits for the window from the redirection bitmap
             * to the screen.
             */
            GreBitBlt(hdc, prc->left, prc->top, prc->right - prc->left,
                    prc->bottom - prc->top, ghdcMem,
                    prc->left, prc->top, SRCCOPY, 0);
    
            _ReleaseDC(hdc);
            GreSelectBitmap(ghdcMem, hbmOld);
    
            /*
             * Restore the redirection bit on the window.
             */
            SetWF(pwnd, WEFPREDIRECTED);
        }

        SetRectEmpty(prc);
    }

    ENDATOMICCHECK();
}

/***************************************************************************\
* InternalDoPaint
*
* Return a window equal to or below pwnd, created by the current thread,
* which needs painting.
*
* pwnd       - Window to start searching from. Search is depth first.
* ptiCurrent - The current thread.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND xxxInternalDoPaint(
    PWND        pwnd,
    PTHREADINFO ptiCurrent)
{
    PWND pwndT;
    TL tlpwnd;

    /*
     * Enumerate all windows, top-down, looking for one that
     * needs repainting.  Skip windows of other tasks.
     */
    while (pwnd != NULL) {

        if (GETPTI(pwnd) == ptiCurrent) {

            if (TestWF(pwnd, WEFCOMPOSITED)) {

                ThreadLock(pwnd, &tlpwnd);

                xxxCompositedPaint(pwnd);
                pwnd = pwnd->spwndNext;

                if (ThreadUnlock(&tlpwnd) == NULL) {
                    return NULL;
                }
                continue;

            } else if (NEEDSPAINT(pwnd)) {

                /*
                 * If this window is transparent, we don't want to
                 * send it a WM_PAINT until all its siblings below it
                 * have been repainted.  If we find an unpainted sibling
                 * below, return it instead.
                 */
                if (TestWF(pwnd, WEFTRANSPARENT)) {

                    pwndT = pwnd;
                    while ((pwndT = pwndT->spwndNext) != NULL) {

                        /*
                         * Make sure sibling window belongs to same app
                         */
                        if ((GETPTI(pwndT) == ptiCurrent) && NEEDSPAINT(pwndT)) {

                            if (TestWF(pwndT, WEFTRANSPARENT))
                                continue;

                            return pwndT;
                        }
                    }
                }

                return pwnd;
            }
        }

        if (pwnd->spwndChild &&
                (pwndT = xxxInternalDoPaint(pwnd->spwndChild, ptiCurrent))) {

            return pwndT;
        }

        pwnd = pwnd->spwndNext;
    }

    return pwnd;
}

/***************************************************************************\
* DoPaint
*
* Looks at all the desktops for the window needing a paint and places a
* WM_PAINT in its queue.
*
* History:
* 16-Jul-91 DarrinM     Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDoPaint(
    PWND  pwndFilter,
    LPMSG lpMsg)
{
    PWND        pwnd;
    PWND        pwndT;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwndFilter);

#if 0 // CHRISWIL: WIN95 SPECIFIC

    /*
     * If there is a system modal up and it is attached to another task,
     * DON'T do paints.  We don't want to return a message for a window in
     * another task!
     */
    if (hwndSysModal && (hwndSysModal->hq != hqCurrent)) {

        /*
         * Poke this guy so he wakes up at some point in the future,
         * otherwise he may never wake up to realize he should paint.
         * Causes hangs - e.g. Photoshop installation program
         *   PostThreadMessage32(Lpq(hqCurrent)->idThread, WM_NULL, 0, 0, 0);
         */
        return FALSE;
    }

#endif

    /*
     * If this is a system thread, then walk the windowstation desktop-list
     * to find the window which needs painting.  For other threads, we
     * reference off the thread-desktop.
     */
    if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {

        PWINDOWSTATION pwinsta;
        PDESKTOP       pdesk;

        if ((pwinsta = ptiCurrent->pwinsta) == NULL) {
            RIPMSG0(RIP_ERROR, "DoPaint: SYSTEMTHREAD does not have (pwinsta)");
            return FALSE;
        }

        pwnd = pwinsta->pTerm->spwndDesktopOwner;
        if (!NEEDSPAINT(pwnd)) {

            pwnd = NULL;
            for(pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
    
                if (pwnd = xxxInternalDoPaint(pdesk->pDeskInfo->spwnd, ptiCurrent))
                    break;
            }
        }

    } else {

        pwnd = xxxInternalDoPaint(ptiCurrent->rpdesk->pDeskInfo->spwnd,
                                  ptiCurrent);
    }

    if (pwnd != NULL) {

        if (!CheckPwndFilter(pwnd, pwndFilter))
            return FALSE;

        /*
         * We're returning a WM_PAINT message, so clear WFINTERNALPAINT so
         * it won't get sent again later.
         */
        if (TestWF(pwnd, WFINTERNALPAINT)) {

            ClrWF(pwnd, WFINTERNALPAINT);

            /*
             * If there is no update region, then no more paint for this
             * window.
             */
            if (pwnd->hrgnUpdate == NULL)
                DecPaintCount(pwnd);
        }

        /*
         * Set the STARTPAINT so that any other calls to BeginPaint while
         * painting is begin performed, will prevent painting on those
         * windows.
         *
         * Clear the UPDATEDIRTY since some apps (DBFast) don't call
         * GetUpdateRect, BeginPaint/EndPaint.
         */
        ClrWF(pwnd, WFSTARTPAINT);
        ClrWF(pwnd, WFUPDATEDIRTY);

        /*
         * If we get an invalidate between now and the time the app calls
         * BeginPaint() and the windows parent is not CLIPCHILDREN, then
         * the parent will paint in the wrong order.  So we are going to
         * cause the child to paint again.  Look in beginpaint and internal
         * invalidate for other parts of this fix.
         *
         * Set a flag to signify that we are in the bad zone.
         *
         * Must go up the parent links to make sure all parents have
         * WFCLIPCHILDREN set otherwise set the WFWMPAINTSENT flag.
         * This is to fix Excel spreadsheet and fulldrag. The speadsheet
         * parent window (class XLDESK) has WFCLIPCHILDREN set but it's
         * parent (class XLMAIN) doesn't. So the main window erases  the
         * background after the child window paints.
         *
         * JOHANNEC : 27-Jul-1994
         */
        
        /*
         * NT Bug 400167: As we walk up the tree, we need to stop short of
         * desktop windows and mother desktop windows.  We can't do a test
         * for WFCLIPCHILDREN on the mother desktop window's parent because
         * it doesn't exist.  This means that no desktop window will get 
         * WFWMPAINTSENT set, but the message window will be able to get 
         * WFWMPAINTSENT set.
         */
        
        pwndT = pwnd;
        while (pwndT && (GETFNID(pwndT) != FNID_DESKTOP)) {

            if (!TestWF(pwndT->spwndParent, WFCLIPCHILDREN)) {
                SetWF(pwnd, WFWMPAINTSENT);
                break;
            }

            pwndT = pwndT->spwndParent;
        }

        /*
         * If the top level "tiled" owner/parent of this window is iconed,
         * send a WM_PAINTICON rather than a WM_PAINT.  The wParam
         * is TRUE if this is the tiled window and FALSE if it is a
         * child/owned popup of the minimized window.
         *
         * BACKWARD COMPATIBILITY HACK
         *
         * 3.0 sent WM_PAINTICON with wParam == TRUE for no apparent
         * reason.  Lotus Notes 2.1 depends on this for some reason
         * to properly change its icon when new mail arrives.
         */
        if (!TestWF(pwnd, WFWIN40COMPAT) &&
            TestWF(pwnd, WFMINIMIZED)    &&
            (pwnd->pcls->spicn != NULL)) {

            StoreMessage(lpMsg, pwnd, WM_PAINTICON, (DWORD)TRUE, 0L, 0L);

        } else {

            StoreMessage(lpMsg, pwnd, WM_PAINT, 0, 0L, 0L);
        }

        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxSimpleDoSyncPaint
*
* Process the sync-paint for this window.  This can send either a NCPAINT
* or an ERASEBKGND.  This assumes no recursion and flags == 0.
*
* History:
* 26-Oct-1993 MikeKe    Created
\***************************************************************************/

VOID xxxSimpleDoSyncPaint(
    PWND pwnd)
{
    HRGN  hrgnUpdate;
    DWORD flags = 0;

    CheckLock(pwnd);

    /*
     * No syncpaints for composited windows, it messes up their painting
     * since erasebkgnds and ncpaints will be sent in the wrong order.
     */
    if (GetStyleWindow(pwnd, WEFCOMPOSITED) != NULL)
        return;

    /*
     * Since we're taking care of the frame drawing, we can consider
     * this WM_PAINT message processed.
     */
    ClrWF(pwnd, WFPAINTNOTPROCESSED);

    /*
     * Make copies of these flags, because their state might
     * change after we send a message, and we don't want
     * to "lose" them.
     */
    if (TestWF(pwnd, WFSENDNCPAINT))
        flags |= DSP_FRAME;

    if (TestWF(pwnd, WFSENDERASEBKGND))
        flags |= DSP_ERASE;

    if (flags & (DSP_ERASE | DSP_FRAME)) {

        if (!TestWF(pwnd, WFVISIBLE)) {

            /*
             * If there is no update region, just clear the bits.
             */
            ClrWF(pwnd, WFSENDNCPAINT);
            ClrWF(pwnd, WFSENDERASEBKGND);
            ClrWF(pwnd, WFPIXIEHACK);
            ClrWF(pwnd, WFERASEBKGND);
            ClearHungFlag(pwnd, WFREDRAWIFHUNG);

        } else {

            PTHREADINFO ptiCurrent = PtiCurrent();

            /*
             * If there is no update region, we don't have to
             * do any erasing, but we may need to send an NCPAINT.
             */
            if (pwnd->hrgnUpdate == NULL) {
                ClrWF(pwnd, WFSENDERASEBKGND);
                ClrWF(pwnd, WFERASEBKGND);
                flags &= ~DSP_ERASE;
            }

            /*
             * Only mess with windows owned by the current thread.
             * NOTE: This means that WM_NCPAINT and WM_ERASEBKGND are
             *       only sent intra-thread.
             */
            if (GETPTI(pwnd) == ptiCurrent) {

                hrgnUpdate = GetNCUpdateRgn(pwnd, TRUE);

                if (flags & DSP_FRAME) {

                    /*
                     * If the message got sent before we got here then do
                     * nothing.
                     */
                    if (TestWF(pwnd, WFSENDNCPAINT))
                        xxxSendNCPaint(pwnd, hrgnUpdate);
                }

                if (flags & DSP_ERASE) {

                    if (TestWF(pwnd, WFSENDNCPAINT)) {
                        /*
                         * If we got another invalidate during the NCPAINT
                         * callback get the new update region
                         */
                        DeleteMaybeSpecialRgn(hrgnUpdate);
                        hrgnUpdate = GetNCUpdateRgn(pwnd, FALSE);
                    }

                    /*
                     * If the message got sent before we got here
                     * (e.g.: an UpdateWindow() inside WM_NCPAINT handler,
                     * for example), don't do anything.
                     *
                     * WINPROJ.EXE (version 1.0) calls UpdateWindow() in
                     * the WM_NCPAINT handlers for its subclassed listboxes
                     * in the open dialog.
                     */
                    if (TestWF(pwnd, WFSENDERASEBKGND)) {
                        ClrWF(pwnd, WFSENDERASEBKGND);
                        ClrWF(pwnd, WFERASEBKGND);
                        xxxSendEraseBkgnd(pwnd, NULL, hrgnUpdate);
                    }

                    /*
                     * The erase and frame operation has occured. Clear the
                     * WFREDRAWIFHUNG bit here. We don't want to clear it until we
                     * know the erase and frame has occured, so we know we always
                     * have a consistent looking window.
                     */
                    ClearHungFlag(pwnd, WFREDRAWIFHUNG);
                }

                DeleteMaybeSpecialRgn(hrgnUpdate);

            } else if (!TestwndChild(pwnd)                         &&
                       (pwnd != grpdeskRitInput->pDeskInfo->spwnd) &&
                       FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT)   &&
                       TestWF(pwnd, WFREDRAWIFHUNG)) {

                ClearHungFlag(pwnd, WFREDRAWIFHUNG);
                xxxRedrawHungWindow(pwnd, NULL);
            }
        }
    }
}

/***************************************************************************\
* xxxInternalDoSyncPaint
*
* Mostly the same functionality as the old xxxDoSyncPaint.
*
*
* This function is called to erase the background of a window, and
* possibly frame and erase the children too.
*
* WM_SYNCPAINT(wParam)/DoSyncPaint(flags) values:
*
* DSP_ERASE               - Erase background
* DSP_FRAME               - Draw child frames
* DSP_ENUMCLIPPEDCHILDREN - Recurse if children are clipped
* DSP_NOCHECKPARENTS      - Don't check
*
*
* Normally, only the DSP_ENUMCLIPPEDCHILDREN bit of flags is
* significant on entry.  If DSP_WM_SYNCPAINT is set, then hrgnUpdate
* and the rest of the flags bits are valid.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxInternalDoSyncPaint(
    PWND  pwnd,
    DWORD flags)
{
    CheckLock(pwnd);

    /*
     * Do the paint for this window.
     */
    xxxSimpleDoSyncPaint(pwnd);

    /*
     * Normally we like to enumerate all of this window's children and have
     * them erase their backgrounds synchronously.  However, this is a bad
     * thing to do if the window is NOT CLIPCHLIDREN.  Here's the scenario
     * we want to to avoid:
     *
     * 1) Window 'A' is invalidated
     * 2) 'A' erases itself (or not, doesn't matter)
     * 3) 'A's children are enumerated and they erase themselves.
     * 4) 'A' paints over its children (remember, 'A' isn't CLIPCHILDREN)
     * 5) 'A's children paint but their backgrounds aren't their ERASEBKND
     *    color (because 'A' painted over them) and everything looks like
     *    dirt.
     */
    if ((flags & DSP_ALLCHILDREN) ||
        ((flags & DSP_ENUMCLIPPEDCHILDREN) && TestWF(pwnd, WFCLIPCHILDREN))) {

        TL   tlpwnd;
        PBWL pbwl;
        HWND *phwnd;

        if (pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL)) {

            PTHREADINFO ptiCurrent = PtiCurrent();
            HWND        hwnd;

            /*
             * If the client dies during a callback, the hwnd list
             * will be freed in xxxDestroyThreadInfo.
             */
            for (phwnd = pbwl->rghwnd; (hwnd = *phwnd) != (HWND)1; phwnd++) {

                if (hwnd == NULL)
                    continue;

                if ((pwnd = (PWND)RevalidateHwnd(hwnd)) == NULL)
                    continue;

                /*
                 * Note: testing if a window is a child automatically
                 * excludes the desktop window.
                 */
                if (TestWF(pwnd, WFCHILD) && (ptiCurrent != GETPTI(pwnd))) {

                    /*
                     * Don't cause any more intertask sendmessages cause it
                     * does bad things to cbt's windowproc hooks.  (Due to
                     * SetParent allowing child windows in the topwindow
                     * hierarchy.
                     */
                    continue;
                }

                /*
                 * Note that we pass only certain bits down as we recurse:
                 * the other bits pertain to the current window only.
                 */
                ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                xxxInternalDoSyncPaint(pwnd, flags);
                ThreadUnlock(&tlpwnd);
            }

            FreeHwndList(pbwl);
        }
    }
}

/***************************************************************************\
* DoQueuedSyncPaint
*
* Queues WM_SYNCPAINT messages for top level windows not of the specified
* thread.
*
* History:
\***************************************************************************/

VOID DoQueuedSyncPaint(
    PWND        pwnd,
    DWORD       flags,
    PTHREADINFO pti)
{
    PTHREADINFO ptiPwnd = GETPTI(pwnd);

    if ((ptiPwnd != pti)          &&
        TestWF(pwnd, WFSENDNCPAINT)    &&
        TestWF(pwnd, WFSENDERASEBKGND) &&
        TestWF(pwnd, WFVISIBLE)) {

        PSMS psms = ptiPwnd->psmsReceiveList;

        /*
         * If this window already has a WM_SYNCPAINT queue'd up, then there's
         * no need to send another one.  Also protects our heap from getting
         * chewed up.
         */
        while (psms != NULL) {

            if ((psms->message == WM_SYNCPAINT) && (psms->spwnd == pwnd)) {
                break;
            }

            psms = psms->psmsReceiveNext;
        }

        if (psms == NULL) {
            /*
             * This will give this message the semantics of a notify
             * message (sendmessage no wait), without calling back
             * the WH_CALLWNDPROC hook. We don't want to do that
             * because that'll let all these processes with invalid
             * windows to process paint messages before they process
             * "synchronous" erasing or framing needs.
             *
             * Hi word of wParam must be zero or wow will drop it
             *
             * LATER mikeke
             * Do we need to send down the flags with DWP_ERASE and DSP_FRAME
             * in it?
             */
            UserAssert(HIWORD(flags) == 0);
            QueueNotifyMessage(pwnd, WM_SYNCPAINT, flags, 0);

            /*
             * Set our syncpaint-pending flag, since we queued one up.  This
             * will be used to check when we validate-parents for windows
             * without clipchildren.
             */
            SetWF(pwnd, WFSYNCPAINTPENDING);
        }

        /*
         * If we posted a WM_SYNCPAINT for a top-level window that is not
         * of the current thread we're done; we'll pick up the children
         * when we process the message for real.  If we're the desktop
         * however make sure we get all it children.
         */
        if (pwnd != PWNDDESKTOP(pwnd))
            return;
    }

    /*
     * Normally we like to enumerate all of this window's children and have
     * them erase their backgrounds synchronously.  However, this is a bad
     * thing to do if the window is NOT CLIPCHLIDREN.  Here's the scenario
     * we want to to avoid:
     *
     * 1.  Window 'A' is invalidated
     * 2.  'A' erases itself (or not, doesn't matter)
     * 3.  'A's children are enumerated and they erase themselves.
     * 4.  'A' paints over its children (remember, 'A' isn't CLIPCHILDREN)
     * 5.  'A's children paint but their backgrounds aren't their ERASEBKND
     *    color (because 'A' painted over them) and everything looks like
     *    dirt.
     */
    if ((flags & DSP_ALLCHILDREN) ||
        ((flags & DSP_ENUMCLIPPEDCHILDREN) && TestWF(pwnd, WFCLIPCHILDREN))) {

        PWND pwndT;

        for (pwndT = pwnd->spwndChild; pwndT; pwndT = pwndT->spwndNext) {

            /*
             * Don't cause any more intertask sendmessages cause it does
             * bad things to cbt's windowproc hooks.  (Due to SetParent
             * allowing child windows in the topwindow hierarchy.
             * The child bit also catches the desktop window; we want to
             */
            if (TestWF(pwndT, WFCHILD) && (pti != GETPTI(pwndT)))
                continue;

            /*
             * Note that we pass only certain bits down as we recurse:
             * the other bits pertain to the current window only.
             */
            DoQueuedSyncPaint(pwndT, flags, pti);
        }
    }
}

/***************************************************************************\
* xxxDoSyncPaint
*
* This funstion is only called for the initial syncpaint so we always
* queue syncpaints to other threads in this funtion.
*
* History:
\***************************************************************************/

VOID xxxDoSyncPaint(
    PWND  pwnd,
    DWORD flags)
{
    CheckLock(pwnd);

    /*
     * If any of our non-clipchildren parents have an update region, don't
     * do anything.  This way we won't redraw our background or frame out
     * of order, only to have it get obliterated when our parent erases his
     * background.
     */
    if (ParentNeedsPaint(pwnd))
        return;

    /*
     * First of all if we are going to be queueing any WM_SYNCPAINT messages
     * to windows of another thread do it first while the window's update
     * regions are still in sync.  This way there is no chance the update
     * region will be incorrect (through window movement during callbacks of
     * the WM_ERASEBKGND|WM_NCPAINT messages).
     */
    DoQueuedSyncPaint(pwnd, flags, PtiCurrent());
    xxxInternalDoSyncPaint(pwnd, flags);
}

/***************************************************************************\
* ParentNeedsPaint
*
* Return a non-zero PWND if a non-CLIPCHILDREN parent requires a WM_PAINT
* message.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND ParentNeedsPaint(
    PWND pwnd)
{
    while ((pwnd = pwnd->spwndParent) != NULL) {

        if (TestWF(pwnd, WFCLIPCHILDREN))
            break;

        if (NEEDSPAINT(pwnd))
            return pwnd;
    }

    return NULL;
}

/***************************************************************************\
* xxxSendEraseBkgnd
*
* Sends a WM_ERASEBKGROUND event to the window.  This contains the paintDC
* with the update-region selected into it.  If there's no update region
* then we prevent this event from making it to the window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 15-Dec-1996 ChrisWil  Merged Chicago Functionality (no erase on min).
\***************************************************************************/

BOOL xxxSendEraseBkgnd(
    PWND pwnd,
    HDC  hdcBeginPaint,
    HRGN hrgnUpdate)
{
    PTHREADINFO ptiCurrent;
    BOOL        fErased;
    HDC         hdc;

    CheckLock(pwnd);

    /*
     * For minimized dudes in win3.1, we would've sent an
     * WM_ICONERASEBKGND and cleared the erase bit.  Now that min
     * windows in 4.0 are all nonclient, don't bother erasing at
     * all.  Pretend like we did.
     *
     * NOTE:
     * For < 4.0 windows, we may have to send a fake WM_ICONERASEKBGND
     * to keep 'em happy.  Saves time not to though.  Getting a DC and
     * sending the message ain't speedy.
     */
    if ((hrgnUpdate == NULL) || TestWF(pwnd, WFMINIMIZED))
        return FALSE;

    /*
     * If a DC to use was not passed in, get one.
     * We want one clipped to this window's update region.
     */
    if (hdcBeginPaint == NULL) {

       hdc = _GetDCEx(pwnd,
                      hrgnUpdate,
                      DCX_USESTYLE | DCX_INTERSECTRGN | DCX_NODELETERGN);
    } else {

        hdc = hdcBeginPaint;
    }

    /*
     * If we're send the WM_ERASEBKGND to another process
     * we need to change the DC owner.
     *
     * We'd like to change the owner to pwnd->pti->idProcess, but
     * GDI won't let us assign ownership back to ourselves later.
     */
    ptiCurrent = PtiCurrent();

    if (GETPTI(pwnd)->ppi != ptiCurrent->ppi)
        GreSetDCOwner(hdc, OBJECT_OWNER_PUBLIC);

    /*
     * Send the event to the window.  This contains the DC clipped to
     * the update-region.
     */
    fErased = (BOOL)xxxSendMessage(pwnd, WM_ERASEBKGND, (WPARAM)hdc, 0L);

    /*
     * If we've changed the DC owner, change it back to
     * the current process.
     */
    if (GETPTI(pwnd)->ppi != ptiCurrent->ppi)
        GreSetDCOwner(hdc, OBJECT_OWNER_CURRENT);

    /*
     * If the WM_ERASEBKGND message did not erase the
     * background, then set this flag to let BeginPaint()
     * know to ask the caller to do it via the fErase
     * flag in the PAINTSTRUCT.
     */
    if (!fErased) {
        SetWF(pwnd, WFERASEBKGND);
        if (!TestWF(pwnd, WFWIN31COMPAT))
            SetWF(pwnd, WFSENDERASEBKGND);
    }

    /*
     * If we got a cache DC in this routine, release it.
     */
    if (hdcBeginPaint == NULL) {
        ReleaseCacheDC(hdc, TRUE);
    }

    return fErased;
}

/***************************************************************************\
* IncPaintCount
*
* EFFECTS:
* If cPaintsReady changes from 0 to 1, the QS_PAINT bit is set for
* associated queue and we wake up task so repaint will occur.
*
* IMPLEMENTATION:
* Get the queue handle from the window handle, bump the paint count, and
* if paint count is one, Set the wakebit.
*
* History:
* 17-Jul-1991 DarrinM   Translated Win 3.1 ASM code.
\***************************************************************************/

VOID IncPaintCount(
    PWND pwnd)
{
    PTHREADINFO pti = GETPTI(pwnd);

    if (pti->cPaintsReady++ == 0)
        SetWakeBit(pti, QS_PAINT);
}

/***************************************************************************\
* DecPaintCount
*
* EFFECTS:
* If cPaintsReady changes from 1 to 0, the QS_PAINT bit is cleared so
* that no more paints will occur.
*
* IMPLEMENTATION:
* Get the queue handle from the window handle, decrement the paint count,
* and if paint count is zero, clear the wakebit.
*
* History:
* 17-Jul-1991 DarrinM   Translated Win 3.1 ASM code.
\***************************************************************************/

VOID DecPaintCount(
    PWND pwnd)
{
    PTHREADINFO pti = GETPTI(pwnd);

    if (--pti->cPaintsReady == 0) {
        pti->pcti->fsWakeBits   &= ~QS_PAINT;
        pti->pcti->fsChangeBits &= ~QS_PAINT;
    }
}

/***************************************************************************\
* UT_GetParentDCClipBox
*
* Return rectangle coordinates of the parent clip-rect.  If the window
* isn't using a parentDC for drawing then return normal clipbox.
*
* History:
* 31-Oct-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/

int UT_GetParentDCClipBox(
    PWND   pwnd,
    HDC    hdc,
    LPRECT lprc)
{
    RECT rc;

    if (GreGetClipBox(hdc, lprc, TRUE) == NULLREGION)
        return FALSE;

    if ((pwnd == NULL) || !TestCF(pwnd, CFPARENTDC))
        return TRUE;

    GetRect(pwnd, &rc, GRECT_CLIENT | GRECT_CLIENTCOORDS);

    return IntersectRect(lprc, lprc, &rc);
}

/***************************************************************************\
* UserRedrawDesktop
*
* Redraw the desktop and its children.  This is called from GDI for DCI
* related unlocks, so that all visrgns are recalculated for the apps.
*
* History:
* 08-Jan-1996 ChrisWil  Created.
\***************************************************************************/

VOID UserRedrawDesktop(VOID)
{
    TL   tlpwnd;
    PWND pwndDesk;

    EnterCrit();

    pwndDesk = PtiCurrent()->rpdesk->pDeskInfo->spwnd;

    ThreadLockAlways(pwndDesk, &tlpwnd);

    xxxInternalInvalidate(pwndDesk,
                          HRGN_FULL,
                          RDW_INVALIDATE |
                              RDW_ERASE  |
                              RDW_FRAME  |
                              RDW_ALLCHILDREN);

    ThreadUnlock(&tlpwnd);

    LeaveCrit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ntstubs.c ===
/****************************** Module Header ******************************\
* Module Name: ntstubs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Kernel-mode stubs
*
* History:
* 03-16-95 JimA             Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "cscall.h"

#include <dbt.h>
#define PROTOS_ONLY 1
#include "msgdef.h"

#if DBG

UINT gcMaxNestedCalls;
ULONG_PTR gcMaxUsedStack;
#if defined(_IA64_)
ULONG_PTR gcMaxUsedBStore;
#endif // _IA64_

int ThreadLockCount(
    BOOL fInc)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    PTL ptl = ptiCurrent->ptl;
    int nLocks = 0;
    ULONG_PTR CurrentUsedSize;

    if (fInc) {
        (ptiCurrent->cNestedCalls)++;

        if (GetNestedCallsCounter() > 50) {
            RIPMSG1(RIP_WARNING, "ThreadLockCount: This thread did %d nested calls.", GetNestedCallsCounter());
        }

        if (ptiCurrent->cNestedCalls > gcMaxNestedCalls) {
            gcMaxNestedCalls = ptiCurrent->cNestedCalls;
        }
    } else {
        (ptiCurrent->cNestedCalls)--;
    }

    if (!ISCSRSS()) {
        CurrentUsedSize = GET_USED_STACK_SIZE();
        if (CurrentUsedSize > gcMaxUsedStack) {
            gcMaxUsedStack = CurrentUsedSize;
        }

#ifdef _IA64_
        CurrentUsedSize = GET_USED_BSTORE_SIZE();
        if (CurrentUsedSize > gcMaxUsedBStore) {
            gcMaxUsedBStore = CurrentUsedSize;
        }
#endif
    }


    while (ptl != NULL) {
        nLocks++;
        ptl = ptl->next;
    }
    ptl = ptiCurrent->ptlW32;
    while (ptl != NULL) {
        nLocks++;
        ptl = ptl->next;
    }

    return nLocks;
}

VOID ThreadLockCheck(
    int nLocks)
{
    int nNewCount = ThreadLockCount(FALSE);
    if (nLocks != nNewCount) {
        RIPMSG2(RIP_ERROR, "ThreadLocks mismatch %d %d", nLocks, nNewCount);
    }
}

// The parameter is used to ensure BEGINRECV* matches ENDRECV* in each stub.
#define DBG_THREADLOCK_START(s)   { int nLocks ## s = ThreadLockCount(TRUE);
#define DBG_THREADLOCK_END(s)     ThreadLockCheck(nLocks ## s); }
#else
#define DBG_THREADLOCK_START(s)
#define DBG_THREADLOCK_END(s)
#endif

/*
 * Setup and control macros
 */
#define BEGINRECV(type, err)    \
    type retval;                \
    type errret = err;          \
    EnterCrit();                \
    DBG_THREADLOCK_START(_)
#define ENDRECV() ENDRECV_(_)

#define BEGINATOMICRECV(type, err)    \
    type retval;                      \
    type errret = err;                \
    EnterCrit();                      \
    DBG_THREADLOCK_START(_)           \
    BEGINATOMICCHECK()
#define ENDATOMICRECV() ENDATOMICRECV_(_)

#define BEGINRECVCSRSS(type, err)      \
    type retval;                       \
    type errret = err;                 \
    EnterCrit();                       \
    DBG_THREADLOCK_START(CSRSS)        \
    if (!ISCSRSS()) {                  \
        retval = STATUS_ACCESS_DENIED; \
        goto errorexit;                \
    }
#define ENDRECVCSRSS() ENDRECV_(CSRSS)

#define BEGINRECV_SHARED(type, err) \
    type retval;                    \
    type errret = err;              \
    EnterSharedCrit();              \
    DBG_THREADLOCK_START(SHARED)
#define ENDRECV_SHARED() ENDRECV_(SHARED)

#define BEGINRECV_NOCRIT(type, err) \
    type retval;                    \
    type errret = err;

#define BEGINRECV_VOID() \
    EnterCrit();         \
    DBG_THREADLOCK_START(_VOID)
#define ENDRECV_VOID() ENDRECV_VOID_(_VOID)

#define BEGINRECV_HWND(type, err, hwnd)           \
    type retval;                                  \
    type errret = err;                            \
    PWND pwnd;                                    \
    EnterCrit();                                  \
    DBG_THREADLOCK_START(HWND)                    \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        retval = errret;                          \
        goto errorexit;                           \
    }
#define ENDRECV_HWND() ENDRECV_HWND_(HWND)

#define BEGINATOMICRECV_HWND(type, err, hwnd)     \
    type retval;                                  \
    type errret = err;                            \
    PWND pwnd;                                    \
    EnterCrit();                                  \
    DBG_THREADLOCK_START(HWND)                    \
    BEGINATOMICCHECK()                            \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        retval = errret;                          \
        goto errorexit;                           \
    }
#define ENDATOMICRECV_HWND() ENDATOMICRECV_HWND_(HWND)

#define BEGINRECV_HWND_VOID(hwnd)                 \
    PWND pwnd;                                    \
    EnterCrit();                                  \
    DBG_THREADLOCK_START(HWND_VOID)               \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        goto errorexit;                           \
    }
#define ENDRECV_HWND_VOID() ENDRECV_VOID_(HWND_VOID)

#define BEGINRECV_HWND_SHARED(type, err, hwnd)    \
    type retval;                                  \
    type errret = err;                            \
    PWND pwnd;                                    \
    EnterSharedCrit();                            \
    DBG_THREADLOCK_START(HWND_SHARED)             \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        retval = errret;                          \
        goto errorexit;                           \
    }
#define ENDRECV_HWND_SHARED() ENDRECV_HWND_(HWND_SHARED)

#define BEGINRECV_HWNDOPT_SHARED(type, err, hwnd)    \
    type retval;                                     \
    type errret = err;                               \
    PWND pwnd;                                       \
    EnterSharedCrit();                               \
    DBG_THREADLOCK_START(HWND_OPT_SHARED)              \
    if (hwnd) {                                      \
        if ((pwnd = ValidateHwnd((hwnd))) == NULL) { \
            retval = errret;                         \
            goto errorexit;                          \
        }                                            \
    } else {                                         \
        pwnd = NULL;                                 \
    }
#define ENDRECV_HWNDOPT_SHARED() ENDRECV_HWND_(HWND_OPT_SHARED)

#define BEGINRECV_HWNDLOCK(type, err, hwnd)      \
    type retval;                                 \
    type errret = err;                           \
    PWND pwnd;                                   \
    TL tlpwnd;                                   \
    PTHREADINFO ptiCurrent;                      \
    EnterCrit();                                 \
    DBG_THREADLOCK_START(HWNDLOCK)               \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) { \
        retval = errret;                         \
        goto errorexit2;                         \
    }                                            \
    ptiCurrent = PtiCurrent();                   \
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

#define BEGINRECV_HWNDLOCKFF(type, err, hwnd, xpfnProc)         \
    type retval;                                                \
    type errret = err;                                          \
    PWND pwnd;                                                  \
    TL tlpwnd;                                                  \
    EnterCrit();                                                \
    DBG_THREADLOCK_START(HWNDLOCK)                              \
    if ((hwnd == HWND_BROADCAST || hwnd == (HWND)-1) &&         \
        (xpfnProc == FNID_SENDNOTIFYMESSAGE ||                  \
        xpfnProc == FNID_SENDMESSAGECALLBACK)) {                \
                                                                \
        if (hwnd == (HWND)-1) {                                 \
            RIPMSG0(RIP_VERBOSE,                                \
                    "Use HWND_BROADCAST, not -1");              \
        }                                                       \
                                                                \
        pwnd = PWND_BROADCAST;                                  \
    } else if ((pwnd = ValidateHwnd((hwnd))) == NULL) {         \
        retval = errret;                                        \
        goto errorexit2;                                        \
    } else {                                                    \
        PTHREADINFO ptiCurrent = PtiCurrent();                  \
        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);     \
    }

#define ENDRECV_HWNDLOCK() ENDRECV_HWNDLOCK_(HWNDLOCK)
#define ENDRECV_HWNDLOCKFF() ENDRECV_HWNDLOCK_FF(HWNDLOCK)

#define BEGINRECV_HWNDLOCK_ND(type, err, hwnd)       \
    type retval;                                     \
    type errret = err;                               \
    PWND pwndND;                                     \
    TL tlpwnd;                                       \
    PTHREADINFO ptiCurrent;                          \
    EnterCrit();                                     \
    DBG_THREADLOCK_START(HWNDLOCK_ND)                \
    if (((pwndND = ValidateHwnd((hwnd))) == NULL) || \
            (GETFNID(pwndND) == FNID_DESKTOP) ||     \
            (GETFNID(pwndND) == FNID_MESSAGEWND)) {  \
        retval = errret;                             \
        goto errorexit2;                             \
    }                                                \
    ptiCurrent = PtiCurrent();                       \
    ThreadLockAlwaysWithPti(ptiCurrent, pwndND, &tlpwnd);
#define ENDRECV_HWNDLOCK_ND() ENDRECV_HWNDLOCK_(HWNDLOCK_ND)

/*
 * This macro performs normal HWNDLOCK stub handling and
 * optionally rejects desktop hwnd arguments for certain
 * APIs.
 */
#define BEGINRECV_HWNDLOCK_COND_ND(type, err, hwnd, xpfnProc)  \
    type retval;                                               \
    type errret = err;                                         \
    PWND pwndCondND;                                           \
    TL tlpwnd;                                                 \
    PTHREADINFO ptiCurrent;                                    \
    EnterCrit();                                               \
    DBG_THREADLOCK_START(HWNDLOCK_COND_ND)                     \
    if ((pwndCondND = ValidateHwnd(hwnd)) == NULL) {           \
        retval = errret;                                       \
        goto errorexit2;                                       \
    }                                                          \
    switch(xpfnProc) {                                         \
    case SFI_XXXDRAWMENUBAR:                                   \
    case SFI_XXXENABLEWINDOW:                                  \
        if ((GETFNID(pwndCondND) == FNID_DESKTOP) ||           \
            (GETFNID(pwndCondND) == FNID_MESSAGEWND)) {        \
            retval = errret;                                   \
            goto errorexit2;                                   \
        }                                                      \
        break;                                                 \
    }                                                          \
    ptiCurrent = PtiCurrent();                                 \
    ThreadLockAlwaysWithPti(ptiCurrent, pwndCondND, &tlpwnd);
#define ENDRECV_HWNDLOCK_COND_ND() ENDRECV_HWNDLOCK_(HWNDLOCK_COND_ND)

#define BEGINRECV_HWNDLOCK_OPT(type, err, hwnd) \
    type retval;                                    \
    type errret = err;                              \
    PWND pwnd;                                      \
    TL tlpwnd;                                      \
    PTHREADINFO ptiCurrent;                         \
    EnterCrit();                                    \
    DBG_THREADLOCK_START(HWNDLOCK_OPT)                \
    if (hwnd) {                                     \
        if ((pwnd = ValidateHwnd(hwnd)) == NULL) {  \
            retval = errret;                        \
            goto errorexit2;                        \
        }                                           \
    } else {                                        \
        pwnd = NULL;                                \
    }                                               \
    ptiCurrent = PtiCurrent();                      \
    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);
#define ENDRECV_HWNDLOCK_OPT() ENDRECV_HWNDLOCK_(HWNDLOCK_OPT)

#define BEGINRECV_HWNDLOCK_VOID(hwnd) \
    PWND pwnd;                                          \
    TL tlpwnd;                                          \
    PTHREADINFO ptiCurrent;                             \
    EnterCrit();                                        \
    DBG_THREADLOCK_START(HWNDLOCK_VOID)                   \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {        \
        goto errorexit2;                                \
    }                                                   \
    ptiCurrent = PtiCurrent();                          \
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);


#define ISXPFNPROCINRANGE(range)                        \
   ((xpfnProc >= SFI_BEGINTRANSLATE ## range) &&        \
    (xpfnProc < SFI_ENDTRANSLATE ## range))

#define VALIDATEXPFNPROC(range)                                 \
    UserAssert(SFI_ENDTRANSLATETABLE == ulMaxSimpleCall);       \
    UserAssert(SFI_ENDTRANSLATE ## range <= ulMaxSimpleCall);   \
    if (!ISXPFNPROCINRANGE(range)) {                            \
        MSGERROR(0);                                             \
    }


#define CLEANUPRECV() \
cleanupexit:

#define ENDRECV_(s)       \
    goto errorexit;       \
errorexit:                \
    DBG_THREADLOCK_END(s) \
    LeaveCrit();          \
    return retval;

#define ENDATOMICRECV_(s) \
    goto errorexit;       \
errorexit:                \
    ENDATOMICCHECK()      \
    DBG_THREADLOCK_END(s) \
    LeaveCrit();          \
    return retval;

#define ENDRECV_NOCRIT() \
    goto errorexit;      \
errorexit:               \
    return retval;

#define ENDRECV_VOID_(s) \
    goto errorexit;      \
errorexit:               \
    DBG_THREADLOCK_END(s)  \
    LeaveCrit();         \
    return;

#define ENDRECV_HWND_(s) \
    goto errorexit;         \
errorexit:                  \
    DBG_THREADLOCK_END(s)     \
    LeaveCrit();            \
    return retval;

#define ENDATOMICRECV_HWND_(s) \
    goto errorexit;         \
errorexit:                  \
    ENDATOMICCHECK()        \
    DBG_THREADLOCK_END(s)   \
    LeaveCrit();            \
    return retval;

#define ENDRECV_HWNDLOCK_(s) \
    goto errorexit;          \
errorexit:                   \
    ThreadUnlock(&tlpwnd);   \
errorexit2:                  \
    DBG_THREADLOCK_END(s)      \
    LeaveCrit();             \
    return retval;

#define ENDRECV_HWNDLOCK_FF(s)      \
    goto errorexit;                 \
errorexit:                          \
    if (pwnd != PWND_BROADCAST) {   \
        ThreadUnlock(&tlpwnd);      \
    }                               \
errorexit2:                         \
    DBG_THREADLOCK_END(s)           \
    LeaveCrit();                    \
    return retval;

#define ENDRECV_HWNDLOCK_VOID() \
    goto errorexit;                 \
errorexit:                          \
    ThreadUnlock(&tlpwnd);          \
errorexit2:                         \
    DBG_THREADLOCK_END(HWNDLOCK_VOID) \
    LeaveCrit();                    \
    return;

/*
 * MSGERROR - exit the stub with an error condition.
 * Parameters:
 * LastError (OPTIONAL):
 * == 0 If LastError is 0, the compiler will optimize away the call to
 *      UserSetLastError(). The last error will not be set to zero!
 * != 0 If you want to SetLastError, provide a non-zero value.
 */
#define MSGERROR(LastError) {        \
    retval = errret;                 \
    if (LastError) {                 \
        UserSetLastError(LastError); \
    }                                \
    goto errorexit; }


#define MSGERROR_VOID() { \
    goto errorexit; }

/*
 * Same as MSGERROR but jumps to cleanup code instead of straight to the return
 */
#define MSGERRORCLEANUP(LastError) { \
    retval = errret;                 \
    if (LastError) {                 \
        UserSetLastError(LastError); \
    }                                \
    goto cleanupexit; }

#define StubExceptionHandler(fSetLastError)  W32ExceptionHandler((fSetLastError), RIP_WARNING)

#define TESTFLAGS(flags, mask) \
    if (((flags) & ~(mask)) != 0) { \
        RIPERR2(ERROR_INVALID_FLAGS, RIP_WARNING, "Invalid flags, %x & ~%x != 0 " #mask, \
            flags, mask); \
        MSGERROR(0);   \
    }

#define LIMITVALUE(value, limit, szText) \
    if ((UINT)(value) > (UINT)(limit)) {     \
        RIPERR3(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid parameter, %d > %d in %s", \
             value, limit, szText); \
        MSGERROR(0);     \
    }

#define MESSAGECALL(api) \
LRESULT NtUserfn ## api( \
    PWND pwnd,           \
    UINT msg,            \
    WPARAM wParam,       \
    LPARAM lParam,       \
    ULONG_PTR xParam,     \
    DWORD xpfnProc,      \
    BOOL bAnsi)

#define BEGINRECV_MESSAGECALL(err)      \
    LRESULT retval;                     \
    LRESULT errret = err;               \
    PTHREADINFO ptiCurrent = PtiCurrent(); \
    CheckCritIn();

#define ENDRECV_MESSAGECALL()           \
    goto errorexit;                     \
errorexit:                              \
    return retval;

#define BEGINRECV_HOOKCALL()            \
    LRESULT retval;                     \
    LRESULT errret = 0;                 \
    CheckCritIn();

#define ENDRECV_HOOKCALL()              \
    goto errorexit;                     \
errorexit:                              \
    return retval;

#define CALLPROC(p) FNID(p)

/*
 * Validation macros
 */
#define ValidateHWNDNoRIP(p,h)              \
    if ((p = ValidateHwnd(h)) == NULL)      \
        MSGERROR(0);

#define ValidateHWND(p,h)                   \
    if ((p = ValidateHwnd(h)) == NULL)      \
        MSGERROR(0);

#define ValidateHWNDND(p,h)                 \
    if ( ((p = ValidateHwnd(h)) == NULL) || \
         (GETFNID(p) == FNID_DESKTOP) ||    \
         (GETFNID(p) == FNID_MESSAGEWND)    \
        )       \
        MSGERROR(0);

#define ValidateHWNDOPT(p,h) \
    if (h) {                                \
        if ((p = ValidateHwnd(h)) == NULL)  \
            MSGERROR(0);                     \
    } else {                                \
        p = NULL;                           \
    }

#define ValidateHWNDIA(p,h)                      \
    if (h != HWND_TOP &&                         \
        h != HWND_BOTTOM &&                      \
        h != HWND_TOPMOST &&                     \
        h != HWND_NOTOPMOST) {                   \
        if ( ((p = ValidateHwnd(h)) == NULL) ||  \
             (GETFNID(p) == FNID_DESKTOP) ||     \
             (GETFNID(p) == FNID_MESSAGEWND)     \
            )        \
            MSGERROR(0);                          \
    } else {                                     \
        p = (PWND)h;                             \
    }

#define ValidateHMENUOPT(p,h) \
    if (h) {                                \
        if ((p = ValidateHmenu(h)) == NULL) \
            MSGERROR(0);                    \
    } else {                                \
        p = NULL;                           \
    }

#define ValidateHMENU(p,h) \
    if ((p = ValidateHmenu(h)) == NULL) \
        MSGERROR(0);

#define ValidateHMENUMODIFY(p,h) \
    if ((p = ValidateHmenu(h)) == NULL)  {          \
        MSGERROR(0);                                \
    } else if (TestMF(p, MFDESKTOP)) { \
        RIPMSG1(RIP_WARNING, "ValidateHMENUMODIFY: Attempt to modify desktop menu:%#p", p); \
        MSGERROR(0);                                \
    }

#define ValidateHMENUMODIFYCHECKLOCK(p,h) \
    if ((p = ValidateHmenu(h)) == NULL)  {          \
        MSGERROR(0);                                \
    } else if (TestMF(p, MFDESKTOP)) { \
        RIPMSG1(RIP_WARNING, "ValidateHMENUMODIFYCHECKLOCK: Attempt to modify desktop menu:%#p", p); \
        MSGERROR(0);                                \
    } else if (TestMF(p, MFREADONLY)) { \
        RIPMSG1(RIP_WARNING, "ValidateHMENUMODIFYCHECKLOCK: Attempt to modify RO menu: %#p", p); \
        MSGERROR(0);                                \
    }

#define ValidateHACCEL(p,h) \
    if ((p = HMValidateHandle(h, TYPE_ACCELTABLE)) == NULL) \
        MSGERROR(0);

#define ValidateHCURSOR(p,h) \
    if ((p = HMValidateHandle(h, TYPE_CURSOR)) == NULL) \
        MSGERROR(0);

#define ValidateHCURSOROPT(p,h) \
    if (h) {                                 \
        if ((p = HMValidateHandle(h, TYPE_CURSOR)) == NULL) \
        MSGERROR(0);                          \
    } else {                                \
        p = NULL;                           \
    }

#define ValidateHICON(p,h) \
    if ((p = HMValidateHandle(h, TYPE_CURSOR)) == NULL) \
        MSGERROR(0);

#define ValidateHHOOK(p,h) \
    if ((p = HMValidateHandle(h, TYPE_HOOK)) == NULL) \
        MSGERROR(0);

#define ValidateHWINEVENTHOOK(p,h) \
    if ((p = HMValidateHandle(h, TYPE_WINEVENTHOOK)) == NULL) \
        MSGERROR(0);

#define ValidateHDWP(p,h) \
    if ((p = HMValidateHandle(h, TYPE_SETWINDOWPOS)) == NULL) \
        MSGERROR(0);

#define ValidateHMONITOR(p,h) \
    if ((p = ValidateHmonitor(h)) == NULL) \
        MSGERROR(0);

#define ValidateHIMC(p,h) \
    if ((p = HMValidateHandle((HANDLE)h, TYPE_INPUTCONTEXT)) == NULL) \
        MSGERROR(0);

#define ValidateHIMCOPT(p,h) \
    if (h) {                                                              \
        if ((p = HMValidateHandle((HANDLE)h, TYPE_INPUTCONTEXT)) == NULL) \
            MSGERROR(0);                                                   \
    } else {                                                              \
        p = NULL;                                                         \
    }

#define ValidateIMMEnabled()                                                                    \
    if (!IS_IME_ENABLED()) {                                                                    \
        RIPERR0(ERROR_CALL_NOT_IMPLEMENTED, RIP_VERBOSE, "IME is disabled in this system.");    \
        MSGERROR(0); \
    }

#define ValidateIMMEnabledVOID()                                                                \
    if (!IS_IME_ENABLED()) {                                                                    \
        RIPERR0(ERROR_CALL_NOT_IMPLEMENTED, RIP_VERBOSE, "IME is disabled in this system.");    \
        MSGERROR_VOID();                                                                        \
    }


#define DOWNCAST(type, value)  ((type)(ULONG_PTR)(value))

NTSTATUS
NtUserRemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG cchDisplayDriverNameLength,
    IN PWCHAR DisplayDriverName)
{
    UINT chMax;
    DOCONNECTDATA CapturedDoConnectData;
    WCHAR CapturedDriverName[DR_DISPLAY_DRIVER_NAME_LENGTH + 1];

    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    /*
     * Probe all read arguments.
     */
    try {
        CapturedDoConnectData = ProbeAndReadStructure(pDoConnectData, DOCONNECTDATA);
        ProbeForRead(DisplayDriverName, cchDisplayDriverNameLength, sizeof(WCHAR));

        UserAssert(DR_DISPLAY_DRIVER_NAME_LENGTH + 1 >= cchDisplayDriverNameLength);

        chMax = min((sizeof(CapturedDriverName)/sizeof(WCHAR)) - 1, cchDisplayDriverNameLength);
        wcsncpycch(CapturedDriverName, DisplayDriverName, chMax);
        CapturedDriverName[chMax] = 0;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = RemoteConnect(&CapturedDoConnectData,
                           chMax * sizeof(WCHAR),
                           CapturedDriverName);

    TRACE("NtUserRemoteConnect");
    ENDRECVCSRSS();
}

NTSTATUS
NtUserRemoteRedrawRectangle(
    IN WORD Left,
    IN WORD Top,
    IN WORD Right,
    IN WORD Bottom)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    retval = RemoteRedrawRectangle(Left, Top, Right, Bottom);

    TRACE("NtUserRemoteRedrawRectangle");
    ENDRECVCSRSS();
}


NTSTATUS
NtUserRemoteRedrawScreen(
    VOID)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    /*
     * If there are any shadow connections, or it's not disconnected.
     */
    if (gnShadowers > 0 || gbConnected) {
        retval = RemoteRedrawScreen();
    } else {
        retval = STATUS_UNSUCCESSFUL;
    }

    TRACE("NtUserRemoteRedrawScreen");
    ENDRECVCSRSS();
}


NTSTATUS
NtUserRemoteStopScreenUpdates(
    VOID)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);
    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }
    if (!gfSwitchInProgress) {
        retval = xxxRemoteStopScreenUpdates();
    } else {
        retval = STATUS_UNSUCCESSFUL;
    }

    TRACE("NtUserRemoteStopScreenUpdates");
    ENDRECVCSRSS();
}

NTSTATUS
NtUserCtxDisplayIOCtl(
    IN ULONG  DisplayIOCtlFlags,
    IN PUCHAR pDisplayIOCtlData,
    IN ULONG  cbDisplayIOCtlData)
{
    PUCHAR pCapturedDisplayIOCtlData = NULL;
    TL tlBuffer;
    PTHREADINFO ptiCurrent;

    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    ptiCurrent = PtiCurrent();

    /*
     * Probe all read arguments.
     */
    try {
        ProbeForRead(pDisplayIOCtlData, cbDisplayIOCtlData, sizeof(BYTE));
        pCapturedDisplayIOCtlData = UserAllocPoolWithQuota(cbDisplayIOCtlData, TAG_SYSTEM);

        if (pCapturedDisplayIOCtlData) {
            ThreadLockPool(ptiCurrent, pCapturedDisplayIOCtlData, &tlBuffer);
            RtlCopyMemory(pCapturedDisplayIOCtlData, pDisplayIOCtlData, cbDisplayIOCtlData);
        } else {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }


    retval = CtxDisplayIOCtl(DisplayIOCtlFlags,
                             pCapturedDisplayIOCtlData,
                             cbDisplayIOCtlData);

    CLEANUPRECV();

    if (pCapturedDisplayIOCtlData) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    }

    TRACE("NtUserCtxDisplayIOCtl");
    ENDRECVCSRSS();

}

UINT NtUserHardErrorControl(
    IN  HARDERRORCONTROL dwCmd,
    IN  HANDLE handle,
    OUT PDESKRESTOREDATA pdrdRestore OPTIONAL)
{
    DESKRESTOREDATA drdRestore;
    BEGINRECVCSRSS(BOOL, HEC_ERROR);

    /*
     * Probe all arguments.  Try block necessary even with CSRSS as
     * the calling process because it can incurr an in-page exception.
     */
    try {
        if (ARGUMENT_PRESENT(pdrdRestore)) {
            ProbeForRead(pdrdRestore, sizeof(DESKRESTOREDATA), sizeof(DWORD));
            RtlCopyMemory(&drdRestore, pdrdRestore, sizeof(DESKRESTOREDATA));
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxHardErrorControl(dwCmd, handle, (ARGUMENT_PRESENT(pdrdRestore))? &drdRestore : NULL);

    try {
        if (ARGUMENT_PRESENT(pdrdRestore)) {
            ProbeForWrite(pdrdRestore, sizeof(DESKRESTOREDATA), sizeof(DWORD));
            RtlCopyMemory(pdrdRestore, &drdRestore, sizeof(DESKRESTOREDATA));
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserHardErrorControl");
    ENDRECVCSRSS();
}

BOOL NtUserGetObjectInformation(  // API GetUserObjectInformationA/W
    IN HANDLE hObject,
    IN int nIndex,
    OUT PVOID pvInfo,
    IN DWORD nLength,
    OUT OPTIONAL LPDWORD pnLengthNeeded)
{
    DWORD dwAlign;
    DWORD dwLocalLength;
    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        dwAlign = sizeof(BYTE);
#else
        if (nIndex == UOI_FLAGS) {
            dwAlign = sizeof(DWORD);
        } else {
            dwAlign = sizeof(WCHAR);
        }
#endif
        ProbeForWrite(pvInfo, nLength, dwAlign);
        if (ARGUMENT_PRESENT(pnLengthNeeded))
            ProbeForWriteUlong(pnLengthNeeded);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Make sure the handle doesn't get closed while we're playing with it.
     */
    SetHandleInUse(hObject);

    /*
     * pvInfo is client-side. GetUserObjectInformation
     * protects use of this pointer with try blocks.
     */

    retval = _GetUserObjectInformation(hObject,
            nIndex, pvInfo,
            nLength, &dwLocalLength);

    /*
     * OK, we're done with the handle.
     */
    SetHandleInUse(NULL);

    if (ARGUMENT_PRESENT(pnLengthNeeded)) {
        try {
            *pnLengthNeeded = dwLocalLength;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetObjectInformation");
    ENDATOMICRECV();
}

BOOL NtUserWin32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagsCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc)
{
#ifdef POOL_INSTR_API
    SIZE_T  dwMaxMem, dwCrtMem;
    DWORD   dwMaxAlloc, dwCrtAlloc;

    BEGINRECV(BOOL, FALSE);

    retval = _Win32PoolAllocationStats(parrTags,
                                       tagsCount,
                                       &dwMaxMem,
                                       &dwCrtMem,
                                       &dwMaxAlloc,
                                       &dwCrtAlloc);
    /*
     * Probe and copy
     */
    try {
        if (lpdwMaxMem != NULL) {
            ProbeForWrite(lpdwMaxMem, sizeof(SIZE_T), sizeof(DWORD));
            *lpdwMaxMem = dwMaxMem;
        }
        if (lpdwCrtMem != NULL) {
            ProbeForWrite(lpdwCrtMem, sizeof(SIZE_T), sizeof(DWORD));
            *lpdwCrtMem = dwCrtMem;
        }
        if (lpdwMaxAlloc != NULL) {
            ProbeForWrite(lpdwMaxAlloc, sizeof(DWORD), sizeof(DWORD));
            *lpdwMaxAlloc = dwMaxAlloc;
        }
        if (lpdwCrtAlloc != NULL) {
            ProbeForWrite(lpdwCrtAlloc, sizeof(DWORD), sizeof(DWORD));
            *lpdwCrtAlloc = dwCrtAlloc;
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserWin32PoolAllocationStats");
    ENDRECV();
#else
    UNREFERENCED_PARAMETER(parrTags);
    UNREFERENCED_PARAMETER(tagsCount);
    UNREFERENCED_PARAMETER(lpdwMaxMem);
    UNREFERENCED_PARAMETER(lpdwCrtMem);
    UNREFERENCED_PARAMETER(lpdwMaxAlloc);
    UNREFERENCED_PARAMETER(lpdwCrtAlloc);
    return FALSE;
#endif // POOL_INSTR_API
}

#if DBG

VOID NtUserDbgWin32HeapFail( // private DbgWin32HeapFail
    IN DWORD dwFlags,
    IN BOOL  bFail)
{
    BEGINRECV_VOID();

    if ((dwFlags | WHF_VALID) != WHF_VALID) {
        RIPMSG1(RIP_WARNING, "Invalid flags for DbgWin32HeapFail %x", dwFlags);
        MSGERROR_VOID();
    }

    Win32HeapFailAllocations(bFail);

    TRACEVOID("NtUserDbgWin32HeapFail");
    ENDRECV_VOID();
}

DWORD  NtUserDbgWin32HeapStat( // private DbgWin32HeapStat
    PDBGHEAPSTAT phs,
    DWORD dwLen)
{
    extern DWORD Win32HeapStat(PDBGHEAPSTAT phs, DWORD dwLen, BOOL bTagsAreShift);

    DBGHEAPSTAT localHS[30];
    BEGINRECV(DWORD, 0);

    LIMITVALUE(dwLen, sizeof(localHS), "DbgWin32HeapStat");

    try{
        ProbeForRead(phs, dwLen, CHARALIGN);
        RtlCopyMemory(localHS, phs, dwLen);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = Win32HeapStat(localHS, dwLen, FALSE);

    try {
        ProbeForWrite(phs, dwLen, CHARALIGN);
        RtlCopyMemory(phs, localHS, dwLen);
    } except (StubExceptionHandler(FALSE)) {
    }
    TRACE("NtUserDbgWin32HeapStat");
    ENDRECV();
}
#endif // DBG

BOOL NtUserSetObjectInformation(  // API SetUserObjectInformationA/W
    IN HANDLE hObject,
    IN int nIndex,
    IN PVOID pvInfo,
    IN DWORD nLength)
{
    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(pvInfo, nLength, DATAALIGN);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Make sure the handle doesn't get closed while we're playing with it.
     */
    SetHandleInUse(hObject);

    /*
     * pvInfo is client-side. SetUserObjectInformation
     * protects use of this pointer with try blocks.
     */
    retval = _SetUserObjectInformation(hObject,
                nIndex, pvInfo, nLength);

    /*
     * OK, we're done with the handle.
     */
    SetHandleInUse(NULL);

    TRACE("NtUserSetObjectInformation");
    ENDATOMICRECV();
}

NTSTATUS NtUserConsoleControl(  // private NtUserConsoleControl
    IN CONSOLECONTROL ConsoleCommand,
    IN PVOID ConsoleInformation,
    IN DWORD ConsoleInformationLength)
{
    union {
        CONSOLEDESKTOPCONSOLETHREAD DesktopConsole;
        ATOM                        ClassAtom;
        CONSOLE_PROCESS_INFO        ProcessInfo;
        RECT                        rc;
        HPALETTE                    hPalette;
        CONSOLEWINDOWSTATIONPROCESS WindowStationConsole;
        CONSOLE_REGISTER_CONSOLEIME IMEConsole;
        CONSOLE_FULLSCREEN_SWITCH   FullScreenConsole;
        CONSOLE_CARET_INFO          CaretInfo;
    } ConsoleInformationUnion;
    PVOID pConsoleInformation = &ConsoleInformationUnion;

    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (ConsoleInformationLength > sizeof(ConsoleInformationUnion)) {
        FRE_RIPMSG2(
            RIP_ERROR,
            "ConsoleInformationLength: %x is greater than union size: %x.",
            ConsoleInformationLength,
            sizeof(ConsoleInformationUnion));
    }

    /*
     * Probe all arguments.  Try block necessary even with CSRSS as
     * the calling process because it can incurr an in-page exception.
     */
    try {
        if (ARGUMENT_PRESENT(ConsoleInformation)) {
            ProbeForRead(ConsoleInformation, ConsoleInformationLength, sizeof(ATOM));
            RtlCopyMemory(pConsoleInformation, ConsoleInformation, ConsoleInformationLength);
        } else {
            pConsoleInformation = NULL;
        }
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    retval = xxxConsoleControl(
                 ConsoleCommand,
                 pConsoleInformation,
                 ConsoleInformationLength);

    try {
        if (ARGUMENT_PRESENT(ConsoleInformation)) {
            ProbeForWrite(ConsoleInformation, ConsoleInformationLength, sizeof(ATOM));
            RtlCopyMemory(ConsoleInformation, pConsoleInformation, ConsoleInformationLength);
        }
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    TRACE("NtUserConsoleControl");
    ENDRECVCSRSS();
}

HWINSTA NtUserCreateWindowStation(  // API CreateWindowStationA/W
    IN POBJECT_ATTRIBUTES pObja,
    IN ACCESS_MASK        amRequest,
    IN HANDLE             hKbdLayoutFile,
    IN DWORD              offTable,
    IN PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN PUNICODE_STRING    pstrKLID,
    UINT                  uKbdInputLocale)

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           CapturedAttributes;
    SECURITY_QUALITY_OF_SERVICE qosCaptured;
    PSECURITY_DESCRIPTOR        psdCaptured = NULL;
    LUID                        luidService;
    UNICODE_STRING              strWinSta;
    UNICODE_STRING              strKLID;
    KBDTABLE_MULTI_INTERNAL     kbdTableMulti;
    WCHAR                       awchName[MAX_SESSION_PATH];
    WCHAR                       awchKF[KL_NAMELENGTH];
    UINT                        chMax;
    KPROCESSOR_MODE             OwnershipMode;

    BEGINRECV(HWINSTA, NULL);

    /*
     * Set status so we can clean up in case of failure
     */
    Status = STATUS_SUCCESS;

    try {
        /*
         * Probe and capture the ??? string
         */
        strKLID = ProbeAndReadUnicodeString(pstrKLID);
        ProbeForReadUnicodeStringBuffer(strKLID);
        chMax = min(sizeof(awchKF) - sizeof(WCHAR), strKLID.Length) / sizeof(WCHAR);
        wcsncpycch(awchKF, strKLID.Buffer, chMax);
        awchKF[chMax] = 0;

        kbdTableMulti = ProbeAndReadStructure(pKbdTableMulti, KBDTABLE_MULTI_INTERNAL);
        if (kbdTableMulti.multi.nTables >= KBDTABLE_MULTI_MAX) {
            RIPMSG1(RIP_WARNING, "NtUserCreateWindowStation: kbdTableMulti.multi.nTables too big: %x", kbdTableMulti.multi.nTables);
            MSGERROR(ERROR_INVALID_PARAMETER);
        }

        /*
         * Probe and capture the object attributes
         */
        CapturedAttributes = ProbeAndReadStructure(pObja, OBJECT_ATTRIBUTES);

        /*
         * Probe and capture all other components of the object attributes.
         */
        if (CapturedAttributes.ObjectName == NULL && CapturedAttributes.RootDirectory == NULL) {

            /*
             * Use the logon authentication id to form the windowstation
             * name.
             */
            Status = GetProcessLuid(NULL, &luidService);
            if (NT_SUCCESS(Status)) {
                swprintf(awchName, L"%ws\\Service-0x%x-%x$",
                        szWindowStationDirectory,
                        luidService.HighPart, luidService.LowPart);
                RtlInitUnicodeString(&strWinSta, awchName);
                CapturedAttributes.ObjectName = &strWinSta;
            }
            OwnershipMode = KernelMode;
        } else {
            strWinSta = ProbeAndReadUnicodeString(CapturedAttributes.ObjectName);
            ProbeForReadUnicodeStringBuffer(strWinSta);

            /*
             * Use the StaticUnicodeBuffer on the TEB as the buffer for the
             * object name. Even if this is client side and we pass
             * KernelMode to the Ob call in _OpenWindowStation this is
             * safe because the TEB is not going to go away during this
             * call. The worst it can happen is to have the buffer in the
             * TEB trashed.
             */
            strWinSta.Length = min(strWinSta.Length, STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR));

            RtlCopyMemory(NtCurrentTeb()->StaticUnicodeBuffer,
                          strWinSta.Buffer,
                          strWinSta.Length);

            strWinSta.Buffer = NtCurrentTeb()->StaticUnicodeBuffer;
            CapturedAttributes.ObjectName = &strWinSta;
            OwnershipMode = UserMode;
        }

        if (CapturedAttributes.SecurityQualityOfService) {
            PSECURITY_QUALITY_OF_SERVICE pqos;

            pqos = CapturedAttributes.SecurityQualityOfService;
            qosCaptured = ProbeAndReadStructure(pqos, SECURITY_QUALITY_OF_SERVICE);
            CapturedAttributes.SecurityQualityOfService = &qosCaptured;
        }

        if (NT_SUCCESS(Status) && CapturedAttributes.SecurityDescriptor != NULL) {
            Status = SeCaptureSecurityDescriptor(
                    CapturedAttributes.SecurityDescriptor,
                    UserMode,
                    PagedPool,
                    FALSE,
                    &psdCaptured);
            if (!NT_SUCCESS(Status)) {
                psdCaptured = NULL;
            }
            CapturedAttributes.SecurityDescriptor = psdCaptured;
        }
    } except (StubExceptionHandler(FALSE)) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {
        MSGERRORCLEANUP(RtlNtStatusToDosError(Status));
    }

    /*
     * Create the windowstation and return a kernel handle.
     */
    retval = xxxCreateWindowStation(&CapturedAttributes,
                                    OwnershipMode,
                                    amRequest,
                                    hKbdLayoutFile,
                                    offTable,
                                    &kbdTableMulti,
                                    awchKF,
                                    uKbdInputLocale);
    CLEANUPRECV();

    /*
     * Release captured security descriptor.
     */
    if (psdCaptured != NULL) {
        SeReleaseSecurityDescriptor(psdCaptured, UserMode, FALSE);
    }

    TRACE("NtUserCreateWindowStation");
    ENDRECV();
}


HWINSTA NtUserOpenWindowStation(
    IN OUT POBJECT_ATTRIBUTES pObja,
    IN ACCESS_MASK amRequest)
{
    NTSTATUS Status;
    LUID luidService;
    WCHAR awchName[sizeof(L"Service-0x0000-0000$") / sizeof(WCHAR)];
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;

    BEGINRECV(HWINSTA, NULL);

    /*
     * NT Bug 387849: We want to allow the caller to pass in a "template" to
     * be filled in for the Service windowstation. So, we need to walk
     * through the pObja structure and check the string out, replacing it
     * with the real object name if necessary.
     *
     * It is VERY important that we pass the pObja object to the executive
     * (through _OpenWindowStation) and not the Obja object. This is
     * because we will request UserMode for this object, and the executive
     * will check that it is actually getting a user-mode address.
     *
     * We will still make a copy of the structures to manipulate while we
     * are walking everything so that we don't need to worry about the rug
     * being removed from beneath us. The executive will do its own checking.
     */
    try {
        /*
         * Probe the object attributes. We need to be able to read the
         * OBJECT_ATTRIBUTES and to write the ObjectName (UNICODE_STRING).
         */
        Obja = ProbeAndReadStructure(pObja, OBJECT_ATTRIBUTES);

        ProbeForWrite(Obja.ObjectName, sizeof(*(Obja.ObjectName)), DATAALIGN);

        ObjectName = ProbeAndReadUnicodeString(Obja.ObjectName);

        /*
         * If we are trying to open the NULL or "" WindowStation, remap this
         * benign name to Service-0x????-????$.
         */
        if (Obja.RootDirectory != NULL &&
            ObjectName.Buffer != NULL &&
            ObjectName.MaximumLength == sizeof(awchName) &&
            ObjectName.Length == (sizeof(awchName) - sizeof(UNICODE_NULL))) {

            /*
             * Use the logon authentication id to form the windowstation
             * name. Put this in the user's buffer since we were the one
             * who allocated it in _OpenWindowStation.
             */

            ProbeForWrite(ObjectName.Buffer, ObjectName.MaximumLength, CHARALIGN);

            if (!_wcsicmp(ObjectName.Buffer, L"Service-0x0000-0000$")) {
                Status = GetProcessLuid(NULL, &luidService);
                if (NT_SUCCESS(Status)) {
                    swprintf(ObjectName.Buffer,
                             L"Service-0x%x-%x$",
                             luidService.HighPart,
                             luidService.LowPart);
                    /*
                     * We need to re-initialize the string to get the counted
                     * length correct. Otherwise the hashing function used
                     * by ObpLookupDirectoryEntry will fail.
                     */
                    RtlInitUnicodeString(Obja.ObjectName, ObjectName.Buffer);
                }
            }
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Open the WindowStation.
     */
    retval = _OpenWindowStation(pObja, amRequest, UserMode);

    TRACE("NtUserOpenWindowStation");
    ENDRECV();
}

BOOL NtUserCloseWindowStation(
    IN HWINSTA hwinsta)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    retval = FALSE;

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (NT_SUCCESS(Status)) {
        retval = _CloseWindowStation(hwinsta);
        ObDereferenceObject(pwinsta);
    }

    TRACE("NtUserCloseWindowStation");
    ENDRECV();
}


BOOL NtUserSetProcessWindowStation(
    IN HWINSTA hwinsta)
{
    BEGINRECV(BOOL, FALSE);

    retval = NT_SUCCESS(_SetProcessWindowStation(hwinsta, UserMode));

    TRACE("NtUserSetProcessWindowStation");
    ENDRECV();
}

HWINSTA NtUserGetProcessWindowStation(
    VOID)
{
    BEGINRECV_SHARED(HWINSTA, NULL);

    _GetProcessWindowStation(&retval);

    TRACE("NtUserGetProcessWindowStation");
    ENDRECV_SHARED();
}

BOOL NtUserLockWorkStation(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = _LockWorkStation();

    TRACE("NtUserLockWorkStation");
    ENDRECV();
}


HDESK NtUserCreateDesktop(  // API CreateDesktopA/W
    IN POBJECT_ATTRIBUTES pObja,
    IN PUNICODE_STRING pstrDevice,
    IN LPDEVMODEW pDevmode,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest)
{
    BEGINRECV(HDESK, NULL);

    /*
     * Fail this call for restricted threads.
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_DESKTOP)) {
        RIPMSGF0(RIP_WARNING, "Failed for restricted thread");
        MSGERROR(ERROR_ACCESS_DENIED);
    }

    /*
     * Validate the dwFlags parameter. The only externally visible flag is
     * DF_ALLOWOTHERACCOUNTHOOK.
     */
    if (dwFlags && dwFlags != DF_ALLOWOTHERACCOUNTHOOK) {
        RIPMSGF1(RIP_WARNING, "Invalid dwFlags 0x%x", dwFlags);
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    /*
     * Probe arguments.
     */
    try {
        ProbeForRead(pObja, sizeof(*pObja), sizeof(DWORD));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * pObja, pDevmode, and pstrDevice are all client side addresses.
     *
     * pstrDevice and pDevmode are put into the Context info, and they are
     * used by GDI (where thay are captured before use).
     */
    retval = xxxCreateDesktop(pObja,
                              UserMode,
                              pstrDevice,
                              pDevmode,
                              dwFlags,
                              amRequest);

    TRACE("NtUserCreateDesktop");
    ENDRECV();
}

HDESK NtUserOpenDesktop(
    IN POBJECT_ATTRIBUTES pObja,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest)
{
    BOOL bShutDown;

    BEGINRECV(HDESK, NULL);

    retval = _OpenDesktop(pObja, UserMode, dwFlags, amRequest, &bShutDown);

    TRACE("NtUserOpenDesktop");
    ENDRECV();
}


HDESK NtUserOpenInputDesktop(
    IN DWORD dwFlags,
    IN BOOL fInherit,
    IN DWORD amRequest)
{
    HWINSTA        hwinsta;
    PWINDOWSTATION pwinsta;
    PDESKTOP       pdesk;
    NTSTATUS       Status;

    BEGINRECV(HDESK, NULL);

    if (grpdeskRitInput == NULL) {
        MSGERROR(ERROR_OPEN_FAILED);
    } else {
        pwinsta = _GetProcessWindowStation(&hwinsta);
        if (pwinsta == NULL) {
            MSGERROR(ERROR_ACCESS_DENIED);
        }

        if (pwinsta->dwWSF_Flags & WSF_NOIO) {
            MSGERROR(ERROR_INVALID_FUNCTION);
        } else {
            /*
             * We should never return the 'Disconnect' desktop to an app. We
             * should instead return the desktop that we will restore to
             * from the Disconnect desktop.
             */
            pdesk = (gbDesktopLocked ? gspdeskShouldBeForeground : grpdeskRitInput);
            if (pdesk == NULL) {
                MSGERROR(ERROR_OPEN_FAILED);
            }

            /*
             * Require read/write access
             */
            amRequest |= DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS;

            Status = ObOpenObjectByPointer(
                    pdesk,
                    fInherit ? OBJ_INHERIT : 0,
                    NULL,
                    amRequest,
                    *ExDesktopObjectType,
                    UserMode,
                    &retval);
            if (NT_SUCCESS(Status)) {
                BOOL bShutDown;

                /*
                 * Complete the desktop open
                 */
                if (!OpenDesktopCompletion(pdesk, retval, dwFlags, &bShutDown)) {
                    CloseProtectedHandle(retval);
                    retval = NULL;
                } else {
                    SetHandleFlag(retval, HF_PROTECTED, TRUE);
                }
            } else {
                MSGERROR(RtlNtStatusToDosError(Status));
            }
        }
    }

    TRACE("NtUserOpenInputDesktop");
    ENDRECV();
}


NTSTATUS NtUserResolveDesktopForWOW (  // WOW ResolveDesktopForWOW
    IN OUT PUNICODE_STRING pstrDesktop)
{
    UNICODE_STRING strDesktop, strDesktop2;
    PTHREADINFO ptiCurrent;
    TL tlBuffer;
    LPWSTR lpBuffer = NULL;
    BOOL fFreeBuffer = FALSE;
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    retval = STATUS_SUCCESS;

    ptiCurrent = PtiCurrent();
    /*
     * Probe arguments
     */
    try {
        strDesktop = ProbeAndReadUnicodeString(pstrDesktop);
        ProbeForReadUnicodeStringFullBuffer(strDesktop);
        RtlCopyMemory(&strDesktop2, &strDesktop, sizeof(strDesktop));
        if (strDesktop.MaximumLength > 0) {
            PWSTR pszCapture = strDesktop.Buffer;
            strDesktop.Buffer = UserAllocPoolWithQuota(strDesktop.MaximumLength, TAG_TEXT2);
            if (strDesktop.Buffer) {
                fFreeBuffer = TRUE;
                ThreadLockPool(ptiCurrent, strDesktop.Buffer, &tlBuffer);
                RtlCopyMemory(strDesktop.Buffer, pszCapture, strDesktop.Length);
            } else {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
        } else {
            strDesktop.Buffer = NULL;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxResolveDesktopForWOW(&strDesktop);

    if (NT_SUCCESS(retval)) {
        try {
            /*
             * The string structure at pstrDesktop could have changed
             * so we will ignore it and drop the one we have already
             * probed down on top of it. We have already performed the
             * ResolveDesktopForWOW action, so we should not return an
             * error if this copy fails.
             */

            RtlCopyUnicodeString(&strDesktop2, &strDesktop);
            RtlCopyMemory(pstrDesktop, &strDesktop2, sizeof(strDesktop2));
        } except (StubExceptionHandler(FALSE)) {
        }
    }

CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    TRACE("NtUserResolveDesktopForWOW");
    ENDRECV();
}

HDESK NtUserResolveDesktop(
    IN HANDLE hProcess,
    IN PUNICODE_STRING pstrDesktop,
    IN BOOL fInherit,
    OUT HWINSTA *phwinsta)
{
    UNICODE_STRING strDesktop;
    HWINSTA hwinsta = NULL;
    PTHREADINFO pti;
    TL tlBuffer;
    BOOL fFreeBuffer = FALSE;
    BOOL bShutDown = FALSE;

    BEGINRECV(HDESK, NULL);

    pti = PtiCurrent();
    /*
     * Probe and capture desktop path
     */
    try {
        strDesktop = ProbeAndReadUnicodeString(pstrDesktop);
        if (strDesktop.Length > 0) {
            PWSTR pszCapture = strDesktop.Buffer;
            ProbeForReadUnicodeStringBuffer(strDesktop);
            strDesktop.Buffer = UserAllocPoolWithQuota(strDesktop.Length, TAG_TEXT2);
            if (strDesktop.Buffer) {
                fFreeBuffer = TRUE;
                ThreadLockPool(pti, strDesktop.Buffer, &tlBuffer);
                RtlCopyMemory(strDesktop.Buffer, pszCapture, strDesktop.Length);
            } else {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
        } else {
            strDesktop.Buffer = NULL;
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxResolveDesktop(hProcess, &strDesktop, &hwinsta,
            fInherit, &bShutDown);

    CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(pti, &tlBuffer);

    if (retval != NULL) {
        try {
            ProbeAndWriteHandle((PHANDLE)phwinsta, hwinsta);
        } except (StubExceptionHandler(TRUE)) {
            xxxCloseDesktop(retval, KernelMode);
            if (hwinsta) {
                _CloseWindowStation(hwinsta);
            }
            MSGERROR(0);
        }
    } else {
        UserAssert(hwinsta == NULL);
    }

    TRACE("NtUserResolveDesktop");
    ENDRECV();
}

BOOL NtUserCloseDesktop(
    IN HDESK hdesk)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxCloseDesktop(hdesk, UserMode);

    TRACE("NtUserCloseDesktop");
    ENDRECV();
}

BOOL NtUserSetThreadDesktop(
    IN HDESK hdesk)
{
    PDESKTOP pdesk = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    BEGINRECV(BOOL, FALSE);
    Status = ValidateHdesk(hdesk, UserMode, 0, &pdesk);
    if (NT_SUCCESS(Status)) {
        retval = xxxSetThreadDesktop(hdesk, pdesk);
        LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK1, FALSE, (ULONG_PTR)PtiCurrent());
        ObDereferenceObject(pdesk);
    } else if (hdesk == NULL && PsGetCurrentProcess() == gpepCSRSS) {
        retval = xxxSetThreadDesktop(NULL, NULL);
    } else {
        retval = FALSE;
    }

    TRACE("NtUserSetThreadDesktop");
    ENDRECV();
}

HDESK NtUserGetThreadDesktop(
    IN DWORD dwThreadId,
    IN HDESK hdeskConsole)
{
    BEGINRECV_SHARED(HDESK, NULL);

    retval = xxxGetThreadDesktop(dwThreadId, hdeskConsole, UserMode);

    TRACE("NtUserGetThreadDesktop");
    ENDRECV_SHARED();
}

BOOL NtUserSwitchDesktop(
    IN HDESK hdesk)
{
    PDESKTOP pdesk;
    TL tlpdesk;
    PTHREADINFO ptiCurrent;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    /*
     * Fail this call for restricted threads
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_DESKTOP)) {
        RIPMSG0(RIP_WARNING, "NtUserSwitchDesktop failed for restricted thread");
        MSGERROR(0);
    }

    Status = ValidateHdesk(hdesk, UserMode, DESKTOP_SWITCHDESKTOP, &pdesk);
    if (NT_SUCCESS(Status)) {
        if (pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) {
            LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK2, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);
            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
            retval = FALSE;
        } else {
            ThreadLockDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_NTUSERSWITCHDESKTOP);
            LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK3, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);
            retval = xxxSwitchDesktop(NULL, pdesk, 0);
            ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_NTUSERSWITCHDESKTOP);
        }
    } else {
        retval = FALSE;
    }

    TRACE("NtUserSwitchDesktop");
    ENDRECV();
}

NTSTATUS NtUserInitializeClientPfnArrays(  // private
    IN CONST PFNCLIENT *ppfnClientA OPTIONAL,
    IN CONST PFNCLIENT *ppfnClientW OPTIONAL,
    IN CONST PFNCLIENTWORKER *ppfnClientWorker OPTIONAL,
    IN HANDLE hModUser)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe all read arguments
     */
    try {
        if (ARGUMENT_PRESENT(ppfnClientA)) {
            ProbeForRead(ppfnClientA, sizeof(*ppfnClientA), sizeof(DWORD));
        }
        if (ARGUMENT_PRESENT(ppfnClientW)) {
            ProbeForRead(ppfnClientW, sizeof(*ppfnClientW), sizeof(DWORD));
        }

        if (ARGUMENT_PRESENT(ppfnClientWorker)) {
            ProbeForRead(ppfnClientWorker, sizeof(*ppfnClientWorker), sizeof(DWORD));
        }

        retval = InitializeClientPfnArrays(
                ppfnClientA, ppfnClientW, ppfnClientWorker, hModUser);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserInitializeThreadInfo");
    ENDRECV();
}

BOOL NtUserWaitForMsgAndEvent(
    IN HANDLE hevent)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxSleepTask(FALSE, hevent);

    TRACE("NtUserWaitForMsgAndEvent");
    ENDRECV();
}

DWORD NtUserDragObject(
    IN HWND hwndParent,
    IN HWND hwndFrom,
    IN UINT wFmt,
    IN ULONG_PTR dwData,
    IN HCURSOR hcur)
{
    PWND pwndFrom;
    PCURSOR pcur;
    TL tlpwndFrom;
    TL tlpcur;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwndParent);

    ValidateHWNDOPT(pwndFrom, hwndFrom);
    ValidateHCURSOROPT(pcur, hcur);

    ThreadLockWithPti(ptiCurrent, pwndFrom, &tlpwndFrom);
    ThreadLockWithPti(ptiCurrent, pcur, &tlpcur);

    retval = xxxDragObject(
            pwnd,
            pwndFrom,
            wFmt,
            dwData,
            pcur);

    ThreadUnlock(&tlpcur);
    ThreadUnlock(&tlpwndFrom);

    TRACE("NtUserDragObject");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserGetIconInfo(  // API GetIconInfo
    IN  HICON hIcon,
    OUT PICONINFO piconinfo,
    IN OUT OPTIONAL PUNICODE_STRING pstrInstanceName,
    IN OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT LPDWORD pbpp,
    IN  BOOL fInternal)
{
    PICON pIcon;
    UNICODE_STRING strInstanceName, *pstrInstanceLocal;
    UNICODE_STRING strResName, *pstrResLocal;

    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * NOTE -- this can't be _SHARED since it calls Gre code with system HDC's.
     */

    ValidateHCURSOR(pIcon, hIcon);

    /*
     * Probe arguments
     */
    try {
        if (pstrInstanceName != NULL) {
            strInstanceName = ProbeAndReadUnicodeString(pstrInstanceName);
            ProbeForWrite(strInstanceName.Buffer, strInstanceName.MaximumLength, CHARALIGN);
            pstrInstanceLocal = &strInstanceName;
        } else {
            pstrInstanceLocal = NULL;
        }

        if (pstrResName != NULL) {
            strResName = ProbeAndReadUnicodeString(pstrResName);
            ProbeForWrite(strResName.Buffer, strResName.MaximumLength, CHARALIGN);
            pstrResLocal = &strResName;
        } else {
            pstrResLocal = NULL;
        }

        if (pbpp != NULL) {
            ProbeForWrite(pbpp, sizeof(DWORD), sizeof(DWORD));
        }
        ProbeForWrite(piconinfo, sizeof(*piconinfo), DATAALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * All use of client-side pointers in InternalGetIconInfo
     * is protected by try/except.
     */

    retval = _InternalGetIconInfo(
            pIcon,
            piconinfo,
            pstrInstanceLocal,
            pstrResLocal,
            pbpp,
            fInternal);

    try {
        if (pstrInstanceName != NULL) {
            RtlCopyMemory(pstrInstanceName, pstrInstanceLocal, sizeof(UNICODE_STRING));
        }
        if (pstrResName != NULL) {
            RtlCopyMemory(pstrResName, pstrResLocal, sizeof(UNICODE_STRING));
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetIconInfo");
    ENDATOMICRECV();
}

BOOL NtUserGetIconSize(  // private
    IN HICON hIcon,
    IN UINT istepIfAniCur,
    OUT int *pcx,
    OUT int *pcy)
{
    PCURSOR picon;

    BEGINRECV_SHARED(BOOL, FALSE);

    ValidateHICON(picon, hIcon);

    if (picon->CURSORF_flags & CURSORF_ACON) {
        PACON pacon = (PACON)picon;
        if (istepIfAniCur < (UINT)pacon->cpcur) {
            picon = pacon->aspcur[pacon->aicur[istepIfAniCur]];
        } else {
            RIPMSG2(RIP_WARNING, "NtUserGetIconSize: Invalid istepIfAniCur:%#lx. picon:%#p",
                    istepIfAniCur, picon);
            MSGERROR(0);
        }
    }

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteLong(pcx, picon->cx);
        ProbeAndWriteLong(pcy, picon->cy);

        retval = 1;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetIconSize");
    ENDRECV_SHARED();
}



BOOL NtUserDrawIconEx(  // API DrawIconEx
    IN HDC hdc,
    IN int x,
    IN int y,
    IN HICON hicon,
    IN int cx,
    IN int cy,
    IN UINT istepIfAniCur,
    IN HBRUSH hbrush,
    IN UINT diFlags,
    IN BOOL fMeta,
    OUT DRAWICONEXDATA *pdid)
{
    PCURSOR picon;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHICON(picon, hicon);

    if (fMeta) {
        if (picon->CURSORF_flags & CURSORF_ACON)
            picon = ((PACON)picon)->aspcur[((PACON)picon)->aicur[0]];

        /*
         * Probe arguments
         */
        try {
            ProbeForWrite(pdid, sizeof(*pdid), DATAALIGN);

            pdid->hbmMask  = picon->hbmMask;
            pdid->hbmColor = picon->hbmColor;
            pdid->hbmUserAlpha = picon->hbmUserAlpha;

            pdid->cx = picon->cx;
            pdid->cy = picon->cy;

            retval = 1;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }

    } else {
        retval = _DrawIconEx(hdc,
                             x,
                             y,
                             picon,
                             cx,
                             cy,
                             istepIfAniCur,
                             hbrush,
                             diFlags);
    }

    TRACE("NtUserDrawIconEx");
    ENDATOMICRECV();
}

HANDLE NtUserDeferWindowPos(
    IN HDWP hWinPosInfo,
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT wFlags)
{
    PWND pwnd;
    PWND pwndInsertAfter;
    PSMWP psmwp;

    BEGINATOMICRECV(HANDLE, NULL);

    TESTFLAGS(wFlags, SWP_VALID);

    ValidateHWNDND(pwnd, hwnd);
    ValidateHWNDIA(pwndInsertAfter, hwndInsertAfter);
    ValidateHDWP(psmwp, hWinPosInfo);

    if (wFlags & ~(SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER |
            SWP_NOREDRAW | SWP_NOACTIVATE | SWP_FRAMECHANGED |
            SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCOPYBITS |
            SWP_NOOWNERZORDER)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid flags (0x%lx) passed to DeferWindowPos",
                wFlags);
        MSGERROR(0);
    }

    /*
     * Make sure the window coordinates can fit in WORDs.
     */
    if (!(wFlags & SWP_NOMOVE)) {
        if (x > SHRT_MAX) {
            x = SHRT_MAX;
        } else if (x < SHRT_MIN) {
            x = SHRT_MIN;
        }
        if (y > SHRT_MAX) {
            y = SHRT_MAX;
        } else if (y < SHRT_MIN) {
            y = SHRT_MIN;
        }
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(wFlags & SWP_NOSIZE)) {
        if (cx < 0) {
            cx = 0;
        } else if (cx > SHRT_MAX) {
            cx = SHRT_MAX;
        }
        if (cy < 0) {
            cy = 0;
        } else if (cy > SHRT_MAX) {
            cy = SHRT_MAX;
        }
    }

#ifdef NEVER
//
// do not fail these conditions because real apps use them.
//
    if (!(wFlags & SWP_NOMOVE) &&
            (x > SHRT_MAX || x < SHRT_MIN ||
             y > SHRT_MAX || y < SHRT_MIN)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid coordinate passed to SetWindowPos");
        MSGERROR(0);
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(wFlags & SWP_NOSIZE) &&
            (cx < 0 || cx > SHRT_MAX ||
             cy < 0 || cy > SHRT_MAX)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid width/height passed to SetWindowPos");
        MSGERROR(0);
    }
#endif

    retval = _DeferWindowPos(
            psmwp,
            pwnd,
            pwndInsertAfter,
            x,
            y,
            cx,
            cy,
            wFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserDeferWindowPos");
    ENDATOMICRECV();
}

BOOL NtUserEndDeferWindowPosEx(
    IN HDWP hWinPosInfo,
    IN BOOL fAsync)
{
    PSMWP psmwp;
    TL tlpsmp;

    BEGINRECV(BOOL, FALSE);

    ValidateHDWP(psmwp, hWinPosInfo);

    ThreadLockAlways(psmwp, &tlpsmp);

    retval = xxxEndDeferWindowPosEx(
            psmwp,
            fAsync);

    ThreadUnlock(&tlpsmp);

    TRACE("NtUserEndDeferWindowPosEx");
    ENDRECV();
}

BOOL NtUserGetMessage(  // API GetMessageA/W
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    retval = xxxGetMessage(
            &msg,
            hwnd,
            wMsgFilterMin,
            wMsgFilterMax);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(pmsg, msg, MSG);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetMessage");
    ENDRECV();
}


#ifdef MESSAGE_PUMP_HOOK

BOOL NtUserRealInternalGetMessage(  // API RealInternalGetMessage
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT flags,
    BOOL fGetMessage)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);
    TESTFLAGS(flags, PM_VALID);

    if (!IsInsideMPH()) {
        RIPMSG0(RIP_WARNING, "NtUserRealInternalGetMessage: Calling MPH function on non-initialized thread");
    }

    retval = xxxRealInternalGetMessage(
            &msg,
            hwnd,
            wMsgFilterMin,
            wMsgFilterMax,
            flags,
            fGetMessage);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(pmsg, msg, MSG);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserRealInternalGetMessage");
    ENDRECV();
}

#endif // MESSAGE_PUMP_HOOK


BOOL NtUserMoveWindow(
    IN HWND hwnd,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN BOOL fRepaint)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    /*
     * Make sure the window coordinates can fit in WORDs.
     */
    if (x > SHRT_MAX) {
        x = SHRT_MAX;
    } else if (x < SHRT_MIN) {
        x = SHRT_MIN;
    }
    if (y > SHRT_MAX) {
        y = SHRT_MAX;
    } else if (y < SHRT_MIN) {
        y = SHRT_MIN;
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (cx < 0) {
        cx = 0;
    } else if (cx > SHRT_MAX) {
        cx = SHRT_MAX;
    }
    if (cy < 0) {
        cy = 0;
    } else if (cy > SHRT_MAX) {
        cy = SHRT_MAX;
    }

#ifdef NEVER
//
// do not fail these conditions because real apps use them.
//
    if (x > SHRT_MAX || x < SHRT_MIN ||
            y > SHRT_MAX || y < SHRT_MIN) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid coordinate passed to MoveWindow");
        MSGERROR(0);
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (cx < 0 || cx > SHRT_MAX ||
            cy < 0 || cy > SHRT_MAX) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid width/height passed to MoveWindow");
        MSGERROR(0);
    }
#endif

    retval = xxxMoveWindow(
            pwndND,
            x,
            y,
            cx,
            cy,
            fRepaint);

    TRACE("NtUserMoveWindow");
    ENDRECV_HWNDLOCK_ND();
}

int NtUserTranslateAccelerator(  // API TranslateAcceleratorA/W
    IN HWND hwnd,
    IN HACCEL haccel,
    IN LPMSG lpmsg)
{
    PWND pwnd;
    LPACCELTABLE pat;
    TL tlpwnd;
    TL tlpat;
    PTHREADINFO ptiCurrent;
    MSG msg;

    BEGINRECV(int, 0);

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage(lpmsg);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * This is called within a message loop. If the window gets destroyed,
     * there still may be other messages in the queue that get returned
     * after the window is destroyed. The app will call TranslateAccelerator()
     * on every one of these, causing RIPs.... Make it nice so it just
     * returns FALSE.
     */
    ValidateHWNDNoRIP(pwnd, hwnd);
    ValidateHACCEL(pat, haccel);

    ptiCurrent = PtiCurrent();
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockAlwaysWithPti(ptiCurrent, pat, &tlpat);

    retval = xxxTranslateAccelerator(
            pwnd,
            pat,
            &msg);

    ThreadUnlock(&tlpat);
    ThreadUnlock(&tlpwnd);

    TRACE("NtUserTranslateAccelerator");
    ENDRECV();
}

LONG_PTR NtUserSetClassLongPtr(  // API SetClassLongPtrA/W
    IN  HWND hwnd,
    IN  int nIndex,
    OUT LONG_PTR dwNewLong,
    IN  BOOL bAnsi)
{
    UNICODE_STRING strMenuName;
    CLSMENUNAME cmn, *pcmnSave;

    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    switch (nIndex) {
    case GCLP_MENUNAME:
        try {
            /*
             * There is no callback from the routine for
             * this value, so we can protect it with a try/except.
             * This is cheaper than capturing the name
             * and copying it back. FritzS
             */

            pcmnSave = (PCLSMENUNAME) dwNewLong;
            cmn = ProbeAndReadStructure(pcmnSave, CLSMENUNAME);
            strMenuName = ProbeAndReadUnicodeString(cmn.pusMenuName);
            ProbeForReadUnicodeStringBufferOrId(strMenuName);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        cmn.pusMenuName = &strMenuName;
        dwNewLong = (ULONG_PTR) &cmn;
        retval = xxxSetClassLongPtr(
            pwnd,
            nIndex,
            dwNewLong,
            bAnsi);
        try {
            ProbeAndWriteStructure(pcmnSave, cmn, CLSMENUNAME);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        break;

    case GCL_STYLE:
        /*
         * I'm not sure how CS_VALID mask will affect existing apps,
         * so leave it for now --- except CS_IME flag, on which the system
         * deeply depends.
         */
#if DBG
        if (dwNewLong & ~CS_VALID) {
            RIPMSG1(RIP_WARNING, "NtUserSetClassLongPtr: Invalid style (%x) specified.", dwNewLong);
        }
#endif
        if (dwNewLong & CS_IME) {
           RIPERR1(ERROR_INVALID_DATA, RIP_VERBOSE, "NtUserSetClassLongPtr: CS_IME is specified in new style (%x).", dwNewLong);
           MSGERROR(0);
        }
    default:
        retval = xxxSetClassLongPtr(
                pwnd,
                nIndex,
                dwNewLong,
                bAnsi);

    }

    TRACE("NtUserSetClassLongPtr");
    ENDRECV_HWNDLOCK();
}

#ifdef _WIN64
LONG NtUserSetClassLong(
    IN  HWND hwnd,
    IN  int nIndex,
    OUT LONG dwNewLong,
    IN  BOOL bAnsi)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    switch (nIndex) {
    case GCL_STYLE:
        /*
         * I'm not sure how CS_VALID mask will affect existing apps,
         * so leave it for now --- except CS_IME flag, on which the system
         * deeply depends.
         */
#if DBG
        if (dwNewLong & ~CS_VALID) {
            RIPMSG1(RIP_WARNING, "NtUserSetClassLong: Invalid style (%x) specified.", dwNewLong);
        }
#endif
        if (dwNewLong & CS_IME) {
           RIPERR1(ERROR_INVALID_DATA, RIP_VERBOSE, "NtUserSetClassLong: CS_IME is specified in new style (%x).", dwNewLong);
           MSGERROR(0);
        }
    }

    retval = xxxSetClassLong(
            pwnd,
            nIndex,
            dwNewLong,
            bAnsi);

    TRACE("NtUserSetClassLong");
    ENDRECV_HWNDLOCK();
}
#endif

BOOL NtUserSetKeyboardState(  // API SetKeyboardState
    IN CONST BYTE *lpKeyState)
{
    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(lpKeyState, 256, sizeof(BYTE));

        retval = _SetKeyboardState(lpKeyState);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserSetKeyboardState");
    ENDRECV();
}

BOOL NtUserSetWindowPos(
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT dwFlags)
{
    PWND        pwndT;
    PWND        pwndInsertAfter;
    TL          tlpwndT;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    TESTFLAGS(dwFlags, SWP_VALID);

    ValidateHWNDIA(pwndInsertAfter, hwndInsertAfter);

    /*
     * Let's not allow the window to be shown/hidden once we
     * started the destruction of the window.
     */
    if (TestWF(pwndND, WFINDESTROY)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "SetWindowPos: Window is being destroyed (pwnd == %#p)",
                pwndND);
        MSGERROR(0);
    }

    if (dwFlags & ~SWP_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "SetWindowPos: Invalid flags passed in (flags == 0x%lx)",
                dwFlags);
        MSGERROR(0);
    }

    /*
     * Make sure the window coordinates can fit in WORDs.
     */
    if (!(dwFlags & SWP_NOMOVE)) {
        if (x > SHRT_MAX) {
            x = SHRT_MAX;
        } else if (x < SHRT_MIN) {
            x = SHRT_MIN;
        }
        if (y > SHRT_MAX) {
            y = SHRT_MAX;
        } else if (y < SHRT_MIN) {
            y = SHRT_MIN;
        }
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(dwFlags & SWP_NOSIZE)) {
        if (cx < 0) {
            cx = 0;
        } else if (cx > SHRT_MAX) {
            cx = SHRT_MAX;
        }
        if (cy < 0) {
            cy = 0;
        } else if (cy > SHRT_MAX) {
            cy = SHRT_MAX;
        }
    }

#ifdef NEVER
//
// do not fail these conditions because real apps use them.
//
    if (!(dwFlags & SWP_NOMOVE) &&
            (x > SHRT_MAX || x < SHRT_MIN ||
             y > SHRT_MAX || y < SHRT_MIN)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid coordinate passed to SetWindowPos");
        MSGERROR(0);
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(dwFlags & SWP_NOSIZE) &&
            (cx < 0 || cx > SHRT_MAX ||
             cy < 0 || cy > SHRT_MAX)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid width/height passed to SetWindowPos");
        MSGERROR(0);
    }
#endif

    switch((ULONG_PTR)pwndInsertAfter) {
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
        pwndT = NULL;
        break;

    default:
        pwndT = pwndInsertAfter;
        break;
    }

    ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

    retval = xxxSetWindowPos(
            pwndND,
            pwndInsertAfter,
            x,
            y,
            cx,
            cy,
            dwFlags);

    ThreadUnlock(&tlpwndT);

    TRACE("NtUserSetWindowPos");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserSetShellWindowEx(
    IN HWND hwnd,
    IN HWND hwndBkGnd)
{
    PWND        pwndBkGnd;
    TL          tlpwndBkGnd;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    ValidateHWNDND(pwndBkGnd, hwndBkGnd);

    ThreadLockAlwaysWithPti(ptiCurrent, pwndBkGnd, &tlpwndBkGnd);

    retval = xxxSetShellWindow(pwndND, pwndBkGnd);

    ThreadUnlock(&tlpwndBkGnd);

    TRACE("NtUserSetShellWindowEx");
    ENDRECV_HWNDLOCK_ND();
}

DWORD
NtUserGetGuiResources(
    HANDLE hProcess,
    DWORD dwFlags)

{
    PEPROCESS Process;
    PW32PROCESS pW32Process;
    BEGINRECV_SHARED(DWORD, 0);

    /*
     * Probe arguments
     */
    if (dwFlags > GR_MAXOBJECT) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "GetGuiResources: Invalid flag bits 0x%x",
                dwFlags);
        MSGERROR(0);
    }


    if (hProcess == NtCurrentProcess()) {
        pW32Process = W32GetCurrentProcess();
    } else {
        NTSTATUS Status;
        Status = ObReferenceObjectByHandle(hProcess,
                                           PROCESS_QUERY_INFORMATION,
                                           *PsProcessType,
                                           UserMode,
                                           &Process,
                                           NULL);

        if (!NT_SUCCESS(Status)) {
            RIPERR2(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "GetGuiResources: Failed with process 0x%x, Status = 0x%x",
                    hProcess,
                    Status);
            MSGERROR(0);
        }

        /*
         * Make sure they are from the same session
         */
        if (PsGetProcessSessionId(Process) != gSessionId) {
            RIPERR2(ERROR_INVALID_PARAMETER,
                    RIP_VERBOSE,
                    "GetGuiResources: Different session. Failed with process 0x%x, Status = 0x%x",
                    hProcess,
                    Status);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        pW32Process = PsGetProcessWin32Process(Process);
    }

    if (pW32Process) {
        switch(dwFlags) {
        case GR_GDIOBJECTS:
            retval = pW32Process->GDIHandleCount;
            break;
        case GR_USEROBJECTS:
            retval = pW32Process->UserHandleCount;
            break;
        }
    } else {
        retval = 0;
    }

    if (hProcess != NtCurrentProcess()) {
        ObDereferenceObject(Process);
    }

    TRACE("NtUserGetGuiResources");
    ENDRECV_SHARED();
}


BOOL NtUserSystemParametersInfo(  // API SystemParametersInfoA/W
    IN UINT   wFlag,
    IN DWORD  wParam,
    IN OUT LPVOID lpData,
    IN UINT   flags)
{
    UNICODE_STRING strData;
    ULONG          ulLength, ulLength2;
    LPVOID         lpDataSave;
    union {
        INT              MouseData[3];
        LOGFONTW         LogFont;
        MOUSEKEYS        MouseKeys;
        FILTERKEYS       FilterKeys;
        STICKYKEYS       StickyKeys;
        TOGGLEKEYS       ToggleKeys;
        SOUNDSENTRY      SoundSentry;
        ACCESSTIMEOUT    AccessTimeout;
        RECT             Rect;
        ANIMATIONINFO    AnimationInfo;
        NONCLIENTMETRICS NonClientMetrics;
        MINIMIZEDMETRICS MinimizedMetrics;
        ICONMETRICS      IconMetrics;
        HKL              hkl;
        INTERNALSETHIGHCONTRAST     ihc;
        HIGHCONTRAST     hc;
        WCHAR            szTemp[MAX_PATH];
    } CaptureBuffer;
    PTHREADINFO pti;
    TL tlBuffer;
    BOOL fFreeBuffer = FALSE;
    BOOL fWrite = FALSE;


    BEGINRECV(BOOL, FALSE);

    /*
     * Prevent restricted processes from setting system
     * parameters.
     *
     * clupu: this is ineficient and temporary. I'll change this
     * soon !!!
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS)) {

        switch (wFlag) {
        case SPI_SETBEEP:
        case SPI_SETMOUSE:
        case SPI_SETBORDER:
        case SPI_SETKEYBOARDSPEED:
        case SPI_ICONHORIZONTALSPACING:
        case SPI_SETSCREENSAVETIMEOUT:
        case SPI_SETBLOCKSENDINPUTRESETS:
        case SPI_SETSCREENSAVEACTIVE:
        case SPI_SETGRIDGRANULARITY:
        case SPI_SETDESKWALLPAPER:
        case SPI_SETDESKPATTERN:
        case SPI_SETKEYBOARDDELAY:
        case SPI_ICONVERTICALSPACING:
        case SPI_SETICONTITLEWRAP:
        case SPI_SETMENUDROPALIGNMENT:
        case SPI_SETDOUBLECLKWIDTH:
        case SPI_SETDOUBLECLKHEIGHT:
        case SPI_SETDOUBLECLICKTIME:
        case SPI_SETMOUSEBUTTONSWAP:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETFASTTASKSWITCH:
        case SPI_SETDRAGFULLWINDOWS:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETMINIMIZEDMETRICS:
        case SPI_SETICONMETRICS:
        case SPI_SETWORKAREA:
        case SPI_SETPENWINDOWS:
        case SPI_SETHIGHCONTRAST:
        case SPI_SETKEYBOARDPREF:
        case SPI_SETSCREENREADER:
        case SPI_SETANIMATION:
        case SPI_SETFONTSMOOTHING:
        case SPI_SETDRAGWIDTH:
        case SPI_SETDRAGHEIGHT:
        case SPI_SETHANDHELD:
        case SPI_SETLOWPOWERTIMEOUT:
        case SPI_SETPOWEROFFTIMEOUT:
        case SPI_SETLOWPOWERACTIVE:
        case SPI_SETPOWEROFFACTIVE:
        case SPI_SETCURSORS:
        case SPI_SETICONS:
        case SPI_SETDEFAULTINPUTLANG:
        case SPI_SETLANGTOGGLE:
        case SPI_SETMOUSETRAILS:
        case SPI_SETSCREENSAVERRUNNING:
        case SPI_SETFILTERKEYS:
        case SPI_SETTOGGLEKEYS:
        case SPI_SETMOUSEKEYS:
        case SPI_SETSHOWSOUNDS:
        case SPI_SETSTICKYKEYS:
        case SPI_SETACCESSTIMEOUT:
        case SPI_SETSOUNDSENTRY:
        case SPI_SETSNAPTODEFBUTTON:
        case SPI_SETMOUSEHOVERWIDTH:
        case SPI_SETMOUSEHOVERHEIGHT:
        case SPI_SETMOUSEHOVERTIME:
        case SPI_SETWHEELSCROLLLINES:
        case SPI_SETMENUSHOWDELAY:
        case SPI_SETSHOWIMEUI:
        case SPI_SETMOUSESPEED:
        case SPI_SETACTIVEWINDOWTRACKING:
        case SPI_SETMENUANIMATION:
        case SPI_SETCOMBOBOXANIMATION:
        case SPI_SETLISTBOXSMOOTHSCROLLING:
        case SPI_SETGRADIENTCAPTIONS:
        case SPI_SETKEYBOARDCUES:
        case SPI_SETACTIVEWNDTRKZORDER:
        case SPI_SETHOTTRACKING:
        case SPI_SETMENUFADE:
        case SPI_SETSELECTIONFADE:
        case SPI_SETTOOLTIPANIMATION:
        case SPI_SETTOOLTIPFADE:
#ifdef MOUSE_IP
        case SPI_SETMOUSESONAR:
        case SPI_SETMOUSECLICKLOCK:
#endif
        case SPI_SETFOREGROUNDLOCKTIMEOUT:
        case SPI_SETACTIVEWNDTRKTIMEOUT:
        case SPI_SETFOREGROUNDFLASHCOUNT:
        case SPI_SETMOUSECLICKLOCKTIME:
        case SPI_SETFOCUSBORDERWIDTH:
        case SPI_SETFOCUSBORDERHEIGHT:
            MSGERROR(0);
            break;
        }
    }

    try {
        switch(wFlag) {

        case SPI_SETDESKPATTERN:
            /*
             * If wParam is -1, that means read the new wallpaper from
             * win.ini. If wParam is not -1, lParam points to the wallpaper
             * string.
             */
            if (wParam == (WPARAM)-1) {
                break;
            }

            /*
             * SetDeskPattern may take a string in lpData; if lpData
             * is one of the magic values it obviously is not a string
             */
            if (lpData == IntToPtr(0xFFFFFFFF) || lpData == NULL) {
                /*
                 * These are not really magic values, but in order not to break
                 * apps we have to keep them valid. wParam == -1 will make
                 * lParam be ignored.
                 */
                wParam = -1;
                break;
            }
            goto ProbeString;

        case SPI_SETDESKWALLPAPER:

            /*
             * If the caller passed in (-1) in the wParam, then the
             * wallpaper name is to be loaded later. Otherwise,
             * they passed in a unicode string in the lParam.
             */
            if (wParam == (WPARAM)-1) {
                break;
            }

            if (((LPWSTR)lpData == NULL)                 ||
                ((LPWSTR)lpData == SETWALLPAPER_METRICS) ||
                ((LPWSTR)lpData == SETWALLPAPER_DEFAULT)) {
                break;
            }

ProbeString:

            /*
             * Probe and capture the string. Capture is necessary to
             * the pointer to be passed directly to the registry routines
             * which cannot cleanly handle exceptions.
             */
            strData = ProbeAndReadUnicodeString((PUNICODE_STRING)lpData);
#if defined(_X86_)
            ProbeForRead(strData.Buffer, strData.Length, sizeof(BYTE));
#else
            ProbeForRead(strData.Buffer, strData.Length, sizeof(WCHAR));
#endif
            lpData = UserAllocPoolWithQuota(strData.Length + sizeof(WCHAR), TAG_TEXT2);
            if (lpData == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            pti = PtiCurrent();
            ThreadLockPool(pti, lpData, &tlBuffer);
            fFreeBuffer = TRUE;
            RtlCopyMemory(lpData,
                          strData.Buffer,
                          strData.Length);
            ((PWSTR)lpData)[strData.Length / sizeof(WCHAR)] = 0;
            break;

        case SPI_SETBLOCKSENDINPUTRESETS:
            /*
             * This must be done a we must allow our value to be passed in wparam
             * to be consistent with xxxUpdatePerUserSystemParameters().  If we allow
             * This to fall through the default it will assert on us and the value will
             * not get set properly.
             */
            break;
        case SPI_SETMOUSE:
            ulLength = sizeof(INT) * 3;
            goto ProbeRead;
        case SPI_SETICONTITLELOGFONT:
            if (!ARGUMENT_PRESENT(lpData))
                break;
            ulLength = sizeof(LOGFONTW);
            goto ProbeRead;
        case SPI_SETMOUSEKEYS:
            ulLength = sizeof(MOUSEKEYS);
            goto ProbeRead;
        case SPI_SETFILTERKEYS:
            ulLength = sizeof(FILTERKEYS);
            goto ProbeRead;
        case SPI_SETSTICKYKEYS:
            ulLength = sizeof(STICKYKEYS);
            goto ProbeRead;
        case SPI_SETTOGGLEKEYS:
            ulLength = sizeof(TOGGLEKEYS);
            goto ProbeRead;
        case SPI_SETSOUNDSENTRY:
            ulLength = sizeof(SOUNDSENTRY);
            goto ProbeRead;
        case SPI_SETACCESSTIMEOUT:
            ulLength = sizeof(ACCESSTIMEOUT);
            goto ProbeRead;
        case SPI_SETWORKAREA:
            ulLength = sizeof(RECT);
            goto ProbeRead;
        case SPI_SETANIMATION:
            ulLength = sizeof(ANIMATIONINFO);
            goto ProbeRead;
        case SPI_SETNONCLIENTMETRICS:
            ulLength = sizeof(NONCLIENTMETRICS);
            goto ProbeRead;
        case SPI_SETMINIMIZEDMETRICS:
            ulLength = sizeof(MINIMIZEDMETRICS);
            goto ProbeRead;
        case SPI_SETICONMETRICS:
            ulLength = sizeof(ICONMETRICS);
            goto ProbeRead;
        case SPI_SETDEFAULTINPUTLANG:
            ulLength = sizeof(HKL);
            goto ProbeRead;
        case SPI_SETHIGHCONTRAST:
            CaptureBuffer.ihc = ProbeAndReadStructure((INTERNALSETHIGHCONTRAST *)lpData, INTERNALSETHIGHCONTRAST);
            lpData = &CaptureBuffer.ihc;

            /*
             * Now probe High Contrast string -- note that we send a client-side
             * buffer pointer to the routine.
             */

            ProbeForReadUnicodeStringBuffer(CaptureBuffer.ihc.usDefaultScheme);
            if (CaptureBuffer.ihc.usDefaultScheme.Length == 0) {
                CaptureBuffer.ihc.usDefaultScheme.Buffer = NULL;
            }
            break;

            /*
             * Probe and capture the data. Capture is necessary to
             * allow the pointer to be passed to the worker routines
             * where exceptions cannot be cleanly handled.
             */
ProbeRead:
#if defined(_X86_)
            ProbeForRead(lpData, ulLength, sizeof(BYTE));
#else
            ProbeForRead(lpData, ulLength, sizeof(DWORD));
#endif
            RtlCopyMemory(&CaptureBuffer, lpData, ulLength);
            lpData = &CaptureBuffer;
            break;

        case SPI_ICONHORIZONTALSPACING: // returns INT
        case SPI_ICONVERTICALSPACING:   // returns INT
            if (!IS_PTR(lpData))
                break;

            /*
             * Fall through and probe the data
             */
        case SPI_GETBEEP:                   // returns BOOL
        case SPI_GETBORDER:                 // returns INT
        case SPI_GETKEYBOARDSPEED:          // returns DWORD
        case SPI_GETKEYBOARDDELAY:          // returns INT
        case SPI_GETSCREENSAVETIMEOUT:      // returns INT
        case SPI_GETLOWPOWERTIMEOUT:        // returns INT
        case SPI_GETPOWEROFFTIMEOUT:        // returns INT
        case SPI_GETSCREENSAVEACTIVE:       // returns BOOL
        case SPI_GETBLOCKSENDINPUTRESETS:   // returns BOOL
        case SPI_GETLOWPOWERACTIVE:         // returns BOOL
        case SPI_GETPOWEROFFACTIVE:         // returns BOOL
        case SPI_GETGRIDGRANULARITY:        // returns INT
        case SPI_GETICONTITLEWRAP:          // returns BOOL
        case SPI_GETMENUDROPALIGNMENT:      // returns BOOL
        case SPI_GETFASTTASKSWITCH:         // returns BOOL
        case SPI_GETDRAGFULLWINDOWS:        // returns INT
        case SPI_GETSHOWSOUNDS:             // returns BOOL
        case SPI_GETFONTSMOOTHING:          // returns INT
        case SPI_GETSNAPTODEFBUTTON:        // returns BOOL
        case SPI_GETKEYBOARDPREF:           // returns BOOL
        case SPI_GETSCREENREADER:           // returns BOOL
        case SPI_GETMOUSEHOVERWIDTH:
        case SPI_GETMOUSEHOVERHEIGHT:
        case SPI_GETMOUSEHOVERTIME:
        case SPI_GETWHEELSCROLLLINES:
        case SPI_GETMENUSHOWDELAY:
        case SPI_GETMOUSESPEED:
        case SPI_GETMOUSETRAILS:        // returns int
        case SPI_GETSCREENSAVERRUNNING:
        case SPI_GETSHOWIMEUI:
            goto ProbeWriteUlong;

        case SPI_GETDEFAULTINPUTLANG:   // returns HKL
            ulLength = sizeof(HKL);
            goto ProbeWrite;
        case SPI_GETICONTITLELOGFONT:   // returns LOGFONT
            ulLength = sizeof(LOGFONT);
            goto ProbeWrite;
        case SPI_GETMOUSE:              // returns 3 INTs
            ulLength = sizeof(INT) * 3;
            goto ProbeWrite;
        case SPI_GETFILTERKEYS:         // returns FILTERKEYS
            ulLength = sizeof(FILTERKEYS);
            goto ProbeWrite;
        case SPI_GETSTICKYKEYS:         // returns STICKYKEYS
            ulLength = sizeof(STICKYKEYS);
            goto ProbeWrite;
        case SPI_GETMOUSEKEYS:          // returns MOUSEKEYS
            ulLength = sizeof(MOUSEKEYS);
            goto ProbeWrite;
        case SPI_GETTOGGLEKEYS:         // returns TOGGLEKEYS
            ulLength = sizeof(TOGGLEKEYS);
            goto ProbeWrite;
        case SPI_GETSOUNDSENTRY:        // returns SOUNDSENTRY
            ulLength = sizeof(SOUNDSENTRY);
            goto ProbeWrite;
        case SPI_GETACCESSTIMEOUT:      // returns ACCESSTIMEOUT
            ulLength = sizeof(ACCESSTIMEOUT);
            goto ProbeWrite;
        case SPI_GETANIMATION:          // returns ANIMATIONINFO
            ulLength = sizeof(ANIMATIONINFO);
            goto ProbeWrite;
        case SPI_GETNONCLIENTMETRICS:   // returns NONCLIENTMETRICS
            ulLength = sizeof(NONCLIENTMETRICS);
            goto ProbeWrite;
        case SPI_GETMINIMIZEDMETRICS:   // returns MINIMIZEDMETRICS
            ulLength = sizeof(MINIMIZEDMETRICS);
            goto ProbeWrite;
        case SPI_GETICONMETRICS:        // returns ICONMETRICS
            ulLength = sizeof(ICONMETRICS);
            goto ProbeWrite;

        case SPI_GETHIGHCONTRAST:       // returns HIGHCONTRAST
            ulLength = sizeof(HIGHCONTRASTW);
            ProbeForWrite(lpData, ulLength, DATAALIGN);
            lpDataSave = lpData;
            CaptureBuffer.hc = *((LPHIGHCONTRAST)lpData);
            lpData = &CaptureBuffer.hc;

            /*
             * now probe string address
             */

            ulLength2 = MAX_SCHEME_NAME_SIZE * sizeof(WCHAR);

            ProbeForWrite(((LPHIGHCONTRAST)lpData)->lpszDefaultScheme, ulLength2, CHARALIGN);
            fWrite = TRUE;
            break;
        case SPI_GETWORKAREA:           // returns RECT
            ulLength = sizeof(RECT);
            goto ProbeWrite;

        case SPI_GETDESKWALLPAPER:
            lpDataSave = lpData;
            lpData = CaptureBuffer.szTemp;
            ProbeForWriteBuffer((PWSTR)lpDataSave, wParam, CHARALIGN);
            wParam = (wParam < MAX_PATH) ? wParam : MAX_PATH;
            ulLength = wParam * sizeof(WCHAR);
            fWrite = TRUE;
            break;

        default:
            if (wFlag < SPI_MAX) {
                break;
            } else if (!UPIsBOOLRange(wFlag)
                    && !UPIsDWORDRange(wFlag)) {

                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSystemParametersInfo: Invalid SPI_:%#lx", wFlag);
                MSGERRORCLEANUP(0);
            }

            /*
             * Let's enforce this or this parameter is gone for good.
             */
            if (wParam != 0) {
                /*
                 * Too late, Winstone98 is alreay using it (incorrectly).
                 * Bummer, this has never been shipped and it's hacked already
                 * Allow a special case to go through
                 */
                if (LOWORD((PtiCurrent()->dwExpWinVer) > VER40)
                        || (wFlag != SPI_SETUIEFFECTS)
                        || (wParam != 1)) {
                    RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSystemParametersInfo: uiParam must be zero for SPI %#lx", wFlag);
                    MSGERRORCLEANUP(0);
                }
            }

            UserAssert(wFlag & SPIF_RANGETYPEMASK);

            if (wFlag & SPIF_SET) {
                /*
                 * If your dword data needs to be validated (i.e, range, value),
                 *  switch here on wFlag and do it here
                 */
                switch (wFlag) {
                    case SPI_SETFOREGROUNDLOCKTIMEOUT:
                        if (!CanForceForeground(PpiCurrent() FG_HOOKLOCK_PARAM(PtiCurrent()))) {
                            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
                            MSGERRORCLEANUP(0);
                        }
                        break;
                    case SPI_SETFONTSMOOTHINGTYPE:
                        if (PtrToInt(lpData) & ~FE_FONTSMOOTHINGTYPE_VALID) {
                            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "");
                            MSGERRORCLEANUP(0);
                        }
                        break;
                    case SPI_SETFONTSMOOTHINGORIENTATION:
                        if (PtrToInt(lpData) & ~FE_FONTSMOOTHINGORIENTATION_VALID) {
                            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "");
                            MSGERRORCLEANUP(0);
                        }
                        break;
                }

            } else {
ProbeWriteUlong:
                ulLength = sizeof(ULONG);
                lpDataSave = lpData;
                lpData = &CaptureBuffer;
                ProbeForWriteUlong((PULONG)lpDataSave);
                fWrite = TRUE;
            }
            break;

            /*
             * Probe the data. wParam contains the length.
             */
ProbeWrite:
            lpDataSave = lpData;
            lpData = &CaptureBuffer;
            ProbeForWrite(lpDataSave, ulLength, DATAALIGN);
            fWrite = TRUE;
            /*
             * Copy the first DWORD of the buffer. This will make sure that
             * the cbSize parameter of some structures gets copied.
             */

            UserAssert(ulLength >= sizeof(DWORD));
            *(LPDWORD)lpData=*(LPDWORD)lpDataSave;
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxSystemParametersInfo(wFlag, wParam, lpData, flags);

    /*
     * Copy out any data we need to.
     */
    if (fWrite) {
        try {
            RtlCopyMemory(lpDataSave, lpData, ulLength);
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    }

    CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(pti, &tlBuffer);

    TRACE("NtUserSystemParametersInfo");
    ENDRECV();
}

BOOL NtUserUpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN DWORD dwFlags)
{
    BEGINRECV(BOOL, FALSE);

    UNREFERENCED_PARAMETER(hToken);

    retval = xxxUpdatePerUserSystemParameters(dwFlags);

    TRACE("NtUserUpdatePerUserSystemParameters");
    ENDRECV();
}

DWORD NtUserDdeInitialize(  // API DdeInitializeA/W
    OUT PHANDLE phInst,
    OUT HWND *phwnd,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd,
    IN PVOID pcii)
{
    HANDLE hInst;
    HWND hwnd;
    DWORD MonFlags;

    BEGINRECV(DWORD, DMLERR_INVALIDPARAMETER);

    /*
     * NOTE -- pcii is a value that is passed back to the client side
     * for event callbacks. It is not probed because it is not used
     * on the kernel side.
     */

    retval = xxxCsDdeInitialize(&hInst, &hwnd,
            &MonFlags, afCmd, pcii);

    /*
     * Probe arguments. pcii is not dereferenced in the kernel so probing
     * is not needed.
     */
    if (retval == DMLERR_NO_ERROR) {
        try {
            ProbeAndWriteHandle(phInst, hInst);
            ProbeAndWriteHandle((PHANDLE)phwnd, hwnd);
            ProbeAndWriteUlong(pMonFlags, MonFlags);
        } except (StubExceptionHandler(TRUE)) {
            xxxDestroyThreadDDEObject(PtiCurrent(), HtoP(hInst));
            MSGERROR(0);
        }
    }

    TRACE("NtUserDdeInitialize");
    ENDRECV();
}

DWORD NtUserUpdateInstance( // private, but pMonFlags from API DdeInitializeA/W
    IN HANDLE hInst,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd)
{
    DWORD MonFlags;
    BEGINRECV(DWORD, DMLERR_INVALIDPARAMETER);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteUlong(pMonFlags);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = _CsUpdateInstance(hInst, &MonFlags, afCmd);
    try {
        *pMonFlags = MonFlags;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserUpdateInstance");
    ENDRECV();
}

DWORD NtUserEvent(  // private
    IN PEVENT_PACKET pep)
{
    WORD cbEventData;
    BEGINRECV(DWORD, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(pep, sizeof(*pep), DATAALIGN);
        /*
         * capture so that another thread can't change it after the probe.
         */
        cbEventData = pep->cbEventData;
        ProbeForRead(&pep->Data, cbEventData, DATAALIGN);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * The buffer is captured within a try/except in xxxCsEvent.
     */

    retval = xxxCsEvent((PEVENT_PACKET)pep, cbEventData);

    TRACE("NtUserEvent");
    ENDRECV();
}

BOOL NtUserFillWindow(
    IN HWND hwndBrush,
    IN HWND hwndPaint,
    IN HDC hdc,
    IN HBRUSH hbr)
{
    PWND pwndBrush;
    TL tlpwndBrush;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwndPaint);

    if (hdc == NULL)
        MSGERROR(0);

    ValidateHWNDOPT(pwndBrush, hwndBrush);

    ThreadLockWithPti(ptiCurrent, pwndBrush, &tlpwndBrush);

    retval = xxxFillWindow(
            pwndBrush,
            pwnd,
            hdc,
            hbr);

    ThreadUnlock(&tlpwndBrush);

    TRACE("NtUserFillWindow");
    ENDRECV_HWNDLOCK();
}

PCLS NtUserGetWOWClass(  // wow
    IN HINSTANCE hInstance,
    IN PUNICODE_STRING pString)
{
    UNICODE_STRING strClassName;

    BEGINRECV_SHARED(PCLS, NULL);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pString);
        ProbeForReadUnicodeStringBuffer(strClassName);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = _GetWOWClass(
            hInstance,
            strClassName.Buffer);

    TRACE("NtUserGetWOWClass");
    ENDRECV_SHARED();
}

UINT NtUserGetInternalWindowPos(  // private
    IN HWND hwnd,
    OUT LPRECT lpRect OPTIONAL,
    OUT LPPOINT lpPoint OPTIONAL)
{
    WINDOWPLACEMENT wp;

    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lpRect)) {
            ProbeForWriteRect(lpRect);
        }
        if (ARGUMENT_PRESENT(lpPoint)) {
            ProbeForWritePoint(lpPoint);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    wp.length = sizeof(WINDOWPLACEMENT);

    _GetWindowPlacement(pwnd, &wp);

    retval = wp.showCmd;
    try {
        if (ARGUMENT_PRESENT(lpRect)) {
            RtlCopyMemory(lpRect, &wp.rcNormalPosition, sizeof(RECT));
        }

        if (ARGUMENT_PRESENT(lpPoint)) {
            RtlCopyMemory(lpPoint, &wp.ptMinPosition, sizeof(POINT));
        }
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("NtUserGetInternalWindowPos");
    ENDRECV_HWND_SHARED();
}

NTSTATUS NtUserInitTask(  // wow
    IN UINT dwExpWinVer,
    IN DWORD dwAppCompatFlags,
    IN DWORD dwUserWOWCompatFlags,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrBaseFileName,
    IN DWORD hTaskWow,
    IN DWORD dwHotkey,
    IN DWORD idTask,
    IN DWORD dwX,
    IN DWORD dwY,
    IN DWORD dwXSize,
    IN DWORD dwYSize)
{
    UNICODE_STRING strModName;
    UNICODE_STRING strBaseFileName;

    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Make sure this is really a WOW process.
     */
    if (PpiCurrent()->pwpi == NULL) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        strModName = ProbeAndReadUnicodeString(pstrModName);
        /*
         * pstrModName->Buffer has a UNICODE_NULL that's not counted in
         * the length, but we want to include it for convenience. The
         * probe routine does this.
         */
        ProbeForReadUnicodeStringBuffer(strModName);

        if (pstrBaseFileName) {
            strBaseFileName = ProbeAndReadUnicodeString(pstrBaseFileName);
            ProbeForReadUnicodeStringBuffer(strBaseFileName);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = zzzInitTask(
            dwExpWinVer,
            dwAppCompatFlags,
            dwUserWOWCompatFlags,
            &strModName,
            pstrBaseFileName ? &strBaseFileName : NULL,
            hTaskWow,
            dwHotkey,
            idTask,
            dwX,
            dwY,
            dwXSize,
            dwYSize);

    TRACE("NtUserInitTask");
    ENDRECV();
}

BOOL NtUserPostThreadMessage(
    IN DWORD id,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    PTHREADINFO ptiCurrent, pti;

    BEGINRECV(BOOL, FALSE);

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (msg & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        MSGERROR(0);
    }

    pti = PtiFromThreadId(id);
    if (pti == NULL) {
        struct tagWOWPROCESSINFO *pwpi;
        PTDB ptdb;

        for (pwpi=gpwpiFirstWow; pwpi; pwpi=pwpi->pwpiNext) {
            for (ptdb=pwpi->ptdbHead; ptdb; ptdb=ptdb->ptdbNext) {
                if (ptdb->hTaskWow == id) {
                    pti=ptdb->pti;
                    goto PTM_DoIt;
                }
            }
        }

        RIPERR0(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, "");
        MSGERROR(0);
    }

PTM_DoIt:

    /*
     * Should be OK if any of the following are true
     *   threads are running on the same desktop
     *   request is on behalf of a system process
     *   this process owns the desktop the thread is running in
     *   the LUIDs match
     */
    ptiCurrent = PtiCurrent();
    if ( !(ptiCurrent->rpdesk == pti->rpdesk) &&
         !(ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) &&
         !(GetDesktopView(ptiCurrent->ppi, pti->rpdesk))) {

        LUID     luidCurrent, luidTo;

        if (!NT_SUCCESS(GetProcessLuid(ptiCurrent->pEThread, &luidCurrent)) ||
            !NT_SUCCESS(GetProcessLuid(pti->pEThread, &luidTo)) ||
            !RtlEqualLuid(&luidCurrent, &luidTo)) {
            RIPERR3(ERROR_INVALID_THREAD_ID,
                    RIP_WARNING,
                    "NtUserPostThreadMessage failed LUID check: msg(%lx), t1(%#p) -> t2(%#p)",
                    msg, ptiCurrent, pti);
            MSGERROR(0);
        }
    }

    retval = _PostThreadMessage(
            pti,
            msg,
            wParam,
            lParam);

    TRACE("NtUserPostThreadMessage");
    ENDRECV();
}

BOOL NtUserRegisterTasklist(
    IN HWND hwnd)
{
    BEGINRECV_HWND(DWORD, 0, hwnd);

    retval = _RegisterTasklist(
            pwnd);

    TRACE("NtUserRegisterTasklist");
    ENDRECV_HWND();
}

BOOL NtUserCloseClipboard(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxCloseClipboard(NULL);

    TRACE("NtUserCloseClipboard");
    ENDRECV();
}

BOOL NtUserEmptyClipboard(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxEmptyClipboard(NULL);

    TRACE("NtUserEmptyClipboard");
    ENDRECV();
}

BOOL NtUserSetClipboardData(  // API SetClipboardData
    IN UINT          fmt,
    IN HANDLE        hData,
    IN PSETCLIPBDATA pscd)
{
    SETCLIPBDATA scd;

    BEGINRECV(BOOL, FALSE);

    /*
     * Check for jobs with JOB_OBJECT_UILIMIT_WRITECLIPBOARD
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_WRITECLIPBOARD)) {
        RIPMSG0(RIP_WARNING, "NtUserSetClipboardData failed for restricted thread");
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        scd = ProbeAndReadSetClipBData(pscd);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _SetClipboardData(
            fmt,
            hData,
            scd.fGlobalHandle,
            scd.fIncSerialNumber);

    TRACE("NtUserSetClipboardData");
    ENDRECV();
}

HANDLE NtUserConvertMemHandle(  // worker routine, lpData not from API
    IN LPBYTE lpData,
    IN UINT   cbData)
{
    BEGINRECV(HANDLE, NULL);

    /*
     * Probe arguments
     */
    try {

        ProbeForRead(lpData, cbData, sizeof(BYTE));

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * lpData is client-side.
     */
    retval = _ConvertMemHandle(lpData, cbData);

    TRACE("NtUserConvertMemHandle");
    ENDRECV();
}

NTSTATUS NtUserCreateLocalMemHandle(  // helper routine
    IN HANDLE hMem,
    OUT LPBYTE lpData OPTIONAL,
    IN UINT cbData,
    OUT PUINT lpcbNeeded OPTIONAL)
{
    PCLIPDATA pClipData;

    BEGINRECV(NTSTATUS, STATUS_INVALID_HANDLE);

    pClipData = HMValidateHandle(hMem, TYPE_CLIPDATA);
    if (pClipData == NULL)
        MSGERROR(0);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lpData)) {
            ProbeForWrite(lpData, cbData, sizeof(BYTE));
        }

        if (ARGUMENT_PRESENT(lpcbNeeded)) {
            ProbeAndWriteUlong(lpcbNeeded, pClipData->cbData);
        }

        if (!ARGUMENT_PRESENT(lpData) || cbData < pClipData->cbData) {
            retval = STATUS_BUFFER_TOO_SMALL;
        } else {
            RtlCopyMemory(lpData, &pClipData->abData, pClipData->cbData);
            retval = STATUS_SUCCESS;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserCreateLocalMemHandle");
    ENDRECV();
}

HHOOK NtUserSetWindowsHookEx(
    IN HANDLE hmod,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN DWORD idThread,
    IN int nFilterType,
    IN PROC pfnFilterProc,
    IN DWORD dwFlags)
{
    PTHREADINFO ptiThread;

    BEGINRECV(HHOOK, NULL);

    if (idThread != 0) {
        ptiThread = PtiFromThreadId(idThread);
        if (ptiThread == NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            MSGERROR(0);
        }
    } else {
        ptiThread = NULL;
    }

    /*
     * Probe pstrLib in GetHmodTableIndex().
     */
    retval = (HHOOK)zzzSetWindowsHookEx(
            hmod,
            pstrLib,
            ptiThread,
            nFilterType,
            pfnFilterProc,
            dwFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserSetWindowsHookEx");
    ENDRECV();
}

HWINEVENTHOOK NtUserSetWinEventHook(
    IN DWORD           eventMin,
    IN DWORD           eventMax,
    IN HMODULE         hmodWinEventProc,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN WINEVENTPROC    pfnWinEventProc,
    IN DWORD           idEventProcess,
    IN DWORD           idEventThread,
    IN DWORD           dwFlags)
{
    BEGINRECV(HWINEVENTHOOK, NULL);

    TESTFLAGS(dwFlags, WINEVENT_VALID);

    /*
     * Probe pstrLib in GetHmodTableIndex().
     */
    retval = (HWINEVENTHOOK)_SetWinEventHook(
            eventMin,
            eventMax,
            hmodWinEventProc,
            pstrLib,
            pfnWinEventProc,
            LongToHandle(idEventProcess),
            idEventThread,
            dwFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserSetWinEventHook");
    ENDRECV();
}

BOOL NtUserUnhookWinEvent(
    IN HWINEVENTHOOK hWinEventUnhook)
{
    PEVENTHOOK peh;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWINEVENTHOOK(peh, hWinEventUnhook);

    retval = _UnhookWinEvent(peh);

    TRACE("NtUserUnhookWinEvent");
    ENDATOMICRECV();
}

VOID NtUserNotifyWinEvent(
    IN DWORD event,
    IN HWND  hwnd,
    IN LONG  idObject,
    IN LONG  idChild)
{
    BEGINRECV_HWNDLOCK_VOID(hwnd);

    xxxWindowEvent(event, pwnd, idObject, idChild, WEF_USEPWNDTHREAD);

    TRACEVOID("NtUserNotifyWinEvent");
    ENDRECV_HWNDLOCK_VOID();
}

BOOL NtUserRegisterUserApiHook(
    IN PUNICODE_STRING pstrLib,
    IN ULONG_PTR offPfnInitUserApiHook)
{
    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * Probe pstrLib in GetHmodTableIndex().
     */
    retval = _RegisterUserApiHook(
            pstrLib,
            offPfnInitUserApiHook);

    TRACE("NtUserRegisterUserApiHook");
    ENDATOMICRECV();
}

BOOL NtUserUnregisterUserApiHook(VOID)
{
    BEGINATOMICRECV(BOOL, FALSE);

    retval = _UnregisterUserApiHook();

    TRACE("NtUserUnregisterUserApiHook");
    ENDATOMICRECV();
}

BOOL NtUserGetGUIThreadInfo(  // API GetGUIThreadInfo
    IN DWORD idThread,
    IN OUT PGUITHREADINFO pgui)
{
    PTHREADINFO ptiThread;
    GUITHREADINFO gui;

    BEGINRECV_SHARED(BOOL, FALSE);

    if (idThread) {
        ptiThread = PtiFromThreadId(idThread);
        if (ptiThread == NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "Bad thread id");
            MSGERROR(0);
        }
    } else {
        ptiThread = NULL;
    }

    /*
     * Probe arguments and copy results
     * C2: test pti & current thread on same desktop within _GetGUIThreadInfo
     */
    try {
        ProbeForWrite(pgui, sizeof(*pgui), DATAALIGN);
        gui.cbSize = pgui->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _GetGUIThreadInfo(ptiThread, &gui);
    if (retval) {
        try {
            *pgui = gui;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetGUIThreadInfo");
    ENDRECV_SHARED();
}

/*****************************************************************************\
* GetTitleBarInfo
*
* Gets information about the title bar
\*****************************************************************************/
BOOL NtUserGetTitleBarInfo(IN HWND hwnd, IN OUT PTITLEBARINFO ptbi)
{
    TITLEBARINFO tbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments and copy out results
     */
    try {
        ProbeForWrite(ptbi, sizeof(*ptbi), DATAALIGN);
        tbi.cbSize = ptbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    /*
     * Get the titlebar info
     */
    retval = xxxGetTitleBarInfo(pwnd, &tbi);
    if (retval) {
        try {
            *ptbi = tbi;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetTitleBarInfo");
    ENDRECV_HWNDLOCK();
}


/*****************************************************************************\
* NtUserGetComboBoxInfo
*
* Gets information about the combo box
\*****************************************************************************/
BOOL NtUserGetComboBoxInfo(IN HWND hwnd, IN OUT PCOMBOBOXINFO pcbi)
{
    COMBOBOXINFO cbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments and copy out results
     */
    try {
        ProbeForWrite(pcbi, sizeof(*pcbi), DATAALIGN);
        cbi.cbSize = pcbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

        /*
         * Get the combobox info
         */
    retval = xxxGetComboBoxInfo(pwnd, &cbi);

    if (retval) {
        try {
            *pcbi = cbi;
        } except (StubExceptionHandler(TRUE)) {
             MSGERROR(0);
        }
    }

    TRACE("NtUserGetComboBoxInfo");
    ENDRECV_HWNDLOCK();
}


/*****************************************************************************\
* NtUserGetListBoxInfo
*
* Gets information about the list box
\*****************************************************************************/
DWORD NtUserGetListBoxInfo(IN HWND hwnd)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    /*
     * Get the listbox info
     */
    retval = xxxGetListBoxInfo(pwnd);

    TRACE("NtUserGetListBoxInfo");
    ENDRECV_HWNDLOCK();
}


/*****************************************************************************\
* GetCursorInfo
*
* Gets information about the global cursor
\*****************************************************************************/
BOOL NtUserGetCursorInfo(IN OUT PCURSORINFO pci)
{
    CURSORINFO ci = {0};

    BEGINRECV_SHARED(BOOL, FALSE);

    ci.ptScreenPos = gpsi->ptCursor;
    ci.flags = 0;

    if (gpcurPhysCurrent)
        ci.flags |= CURSOR_SHOWING;

    /*
     * Get the current LOGICAL cursor (the one apps actually see from LoadCursor())
     */
    ci.hCursor = (HCURSOR)PtoH(gpcurLogCurrent);

    retval = TRUE;

    /*
     * Probe arguments and copy out result
     */
    try {
        ProbeForWrite(pci, sizeof(*pci), DATAALIGN);
        if (pci->cbSize != sizeof(CURSORINFO)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "CURSORINFO.cbSize %d is wrong", pci->cbSize);
            retval = FALSE;
        } else {
            *pci = ci;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetCursorInfo");
    ENDRECV_SHARED();
}

/*****************************************************************************\
* GetScrollBarInfo
*
* Gets information about the scroll bar
\*****************************************************************************/
BOOL NtUserGetScrollBarInfo(IN HWND hwnd, IN LONG idObject, IN OUT PSCROLLBARINFO psbi)
{
    SCROLLBARINFO sbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments and copy out results
     */
    try {
        ProbeForWrite(psbi, sizeof(*psbi), DATAALIGN);
        sbi.cbSize = psbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    /*
     * Get the scrollbar info
     */
    retval = xxxGetScrollBarInfo(pwnd, idObject, &sbi);

    if (retval) {
        try {
            *psbi = sbi;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetScrollBarInfo");
    ENDRECV_HWNDLOCK();
}

HWND NtUserGetAncestor(IN HWND hwndChild, IN UINT gaFlags)
{
    BEGINRECV_HWND_SHARED(HWND, NULL, hwndChild);

    if ((gaFlags < GA_MIN) || (gaFlags > GA_MAX)) {
        RIPERR3(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "NtUserGetAncestor: Invalid gaFlags parameter %d, not %d - %d",
                 gaFlags, GA_MIN, GA_MAX);
        MSGERROR(0);
    }
    retval = (HWND)_GetAncestor(pwnd, gaFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserGetAncestor");
    ENDRECV_HWND_SHARED();
}

HWND NtUserRealChildWindowFromPoint(IN HWND hwndParent, IN POINT pt)
{
    BEGINRECV_HWND_SHARED(HWND, NULL, hwndParent);

    retval = (HWND)_RealChildWindowFromPoint(pwnd, pt);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserRealChildWindowFromPoint");
    ENDRECV_HWND_SHARED();
}

BOOL NtUserGetAltTabInfo(
    IN HWND hwnd,
    IN int iItem,
    IN OUT PALTTABINFO pati,
    OUT LPWSTR lpszItemText,
    IN UINT cchItemText OPTIONAL,
    BOOL bAnsi)
{
    ALTTABINFO ati;

    BEGINRECV_HWNDOPT_SHARED(BOOL, FALSE, hwnd);

    /*
     * If the specified window is not a switch window, then fail the call.
     * It's a dumb API we got from Windows 95, I am hereby allowing NULL hwnd.
     */
    if (pwnd && (pwnd != gspwndAltTab)) {
        MSGERROR(ERROR_INVALID_WINDOW_HANDLE);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWrite(pati, sizeof(*pati), DATAALIGN);
        if (bAnsi) {
            ProbeForWriteBuffer((LPSTR)lpszItemText, cchItemText, CHARALIGN);
        } else {
            ProbeForWriteBuffer(lpszItemText, cchItemText, CHARALIGN);
        }

        /*
         * Validate AltTabInfo structure
         */
        if (pati->cbSize != sizeof(ALTTABINFO)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "ALTTABINFO.cbSize %d is wrong", pati->cbSize);
            MSGERROR(0);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Get the alt tab info
     */
    ati.cbSize = sizeof(ALTTABINFO);
    retval = _GetAltTabInfo(iItem, &ati, lpszItemText, cchItemText, bAnsi);
    if (retval) {
        try {
            *pati = ati;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetAltTabInfo");
    ENDRECV_HWNDOPT_SHARED();
}

BOOL NtUserGetMenuBarInfo(
    IN HWND hwnd,
    IN long idObject,
    IN long idItem,
    IN OUT PMENUBARINFO pmbi)
{
    MENUBARINFO mbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        ProbeForWrite(pmbi, sizeof(*pmbi), sizeof(BYTE));
#else
        ProbeForWrite(pmbi, sizeof(*pmbi), sizeof(DWORD));
#endif
        mbi.cbSize = pmbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Get the menubar info
     */
    retval = xxxGetMenuBarInfo(pwnd, idObject, idItem, &mbi);

    if (retval) {
        try {
            *pmbi = mbi;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetMenuBarInfo");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserSetInternalWindowPos(  // private SetInternalWindowPos
    IN HWND hwnd,
    IN UINT cmdShow,
    IN CONST RECT *lpRect,
    IN CONST POINT *lpPoint)
{
    RECT rc;
    POINT pt;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect(lpRect);
        pt = ProbeAndReadPoint(lpPoint);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxSetInternalWindowPos(
            pwndND,
            cmdShow,
            &rc,
            &pt);

    TRACE("NtUserSetInternalWindowPos");
    ENDRECV_HWNDLOCK_ND();
}


BOOL NtUserChangeClipboardChain(
    IN HWND hwndRemove,
    IN HWND hwndNewNext)
{
    PWND pwndNewNext;
    TL tlpwndNewNext;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwndRemove);

    ValidateHWNDOPT(pwndNewNext, hwndNewNext);

    ThreadLockWithPti(ptiCurrent, pwndNewNext, &tlpwndNewNext);
    retval = xxxChangeClipboardChain(
            pwnd,
            pwndNewNext);

    ThreadUnlock(&tlpwndNewNext);

    TRACE("NtUserChangeClipboardChain");
    ENDRECV_HWNDLOCK();
}

DWORD NtUserCheckMenuItem(
    IN HMENU hmenu,
    IN UINT wIDCheckItem,
    IN UINT wCheck)
{
    PMENU pmenu;

    BEGINATOMICRECV(DWORD, (DWORD)-1);

    TESTFLAGS(wCheck, MF_VALID);

    ValidateHMENUMODIFY(pmenu, hmenu);

    retval = _CheckMenuItem(
            pmenu,
            wIDCheckItem,
            wCheck);

    TRACE("NtUserCheckMenuItem");
    ENDATOMICRECV();
}

HWND NtUserChildWindowFromPointEx(
    IN HWND hwndParent,
    IN POINT point,
    IN UINT flags)
{
    BEGINRECV_HWND(HWND, NULL, hwndParent);

    retval = (HWND)_ChildWindowFromPointEx(pwnd, point, flags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserChildWindowFromPointEx");
    ENDRECV_HWND();
}

BOOL NtUserClipCursor(  // API ClipCursor
    IN CONST RECT *lpRect OPTIONAL)
{
    RECT rc;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lpRect)) {
        try {
            rc = ProbeAndReadRect(lpRect);
            lpRect = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    retval = zzzClipCursor(lpRect);

    TRACE("NtUserClipCursor");
    ENDRECV();
}

HACCEL NtUserCreateAcceleratorTable(  // API CreateAcceleratorTableA/W
    IN LPACCEL paccel,
    IN INT cAccel)
{
    BEGINRECV(HACCEL, NULL);

    if (cAccel <= 0) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForReadBuffer(paccel, cAccel, DATAALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = (HACCEL)_CreateAcceleratorTable(
            paccel,
            cAccel * sizeof(ACCEL));
    retval = PtoH((PVOID)retval);

    TRACE("NtUserCreateAcceleratorTable");
    ENDRECV();
}

BOOL NtUserDeleteMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(dwFlags, MF_VALID);

    ValidateHMENUMODIFYCHECKLOCK(pmenu, hmenu);
    ThreadLock(pmenu, &tlpMenu);
    retval = xxxDeleteMenu(
            pmenu,
            nPosition,
            dwFlags);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserDeleteMenu");
    ENDRECV();
}

BOOL NtUserDestroyAcceleratorTable(
    IN HACCEL hAccel)
{
    LPACCELTABLE pat;

    BEGINRECV(BOOL, FALSE);

    ValidateHACCEL(pat, hAccel);

    /*
     * Mark the object for destruction - if it says it's ok to free,
     * then free it.
     */
    if (HMMarkObjectDestroy(pat)) {
        HMFreeObject(pat);
    }
    retval = TRUE;

    TRACE("NtUserDestroyAcceleratorTable");
    ENDRECV();
}

BOOL NtUserDestroyCursor(
    IN HCURSOR hcurs,
    IN DWORD cmd)
{
    PCURSOR pcurs;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHCURSOR(pcurs, hcurs);

    retval = _DestroyCursor(pcurs, cmd);

    TRACE("NtUserDestroyCursor");
    ENDATOMICRECV();
}

HANDLE NtUserGetClipboardData(  // API GetClipboardData
    IN  UINT          fmt,
    OUT PGETCLIPBDATA pgcd)
{
    PTHREADINFO    ptiCurrent;
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    GETCLIPBDATA   gcd;

    BEGINRECV(HANDLE, NULL);

    ptiCurrent = PtiCurrent();
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    /*
     * Check for jobs with JOB_OBJECT_UILIMIT_READCLIPBOARD
     */
    if (IS_THREAD_RESTRICTED(ptiCurrent, JOB_OBJECT_UILIMIT_READCLIPBOARD)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "NtUserGetClipboardData failed for restricted thread");
        MSGERROR(0);
    }

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    /*
     * Start out assuming the format requested
     * will be the format returned.
     */
    gcd.uFmtRet = fmt;

    retval = xxxGetClipboardData(pwinsta, fmt, &gcd);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(pgcd, gcd, GETCLIPBDATA);
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();
    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    TRACE("NtUserGetClipboardData");
    ENDRECV();

}

BOOL NtUserDestroyMenu(
    IN HMENU hmenu)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENUMODIFY(pmenu, hmenu);

    retval = _DestroyMenu(pmenu);

    TRACE("NtUserDestroyMenu");
    ENDATOMICRECV();
}

BOOL NtUserDestroyWindow(
    IN HWND hwnd)
{
    BEGINRECV_HWND(DWORD, 0, hwnd);

    retval  = xxxDestroyWindow(pwnd);

    TRACE("NtUserDestroyWindow");
    ENDRECV_HWND();
}

LRESULT NtUserDispatchMessage(  // API DispatchMessageA/W
    IN CONST MSG *pmsg)
{
    MSG msg;

    BEGINRECV(LRESULT, 0);

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage(pmsg);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxDispatchMessage(&msg);

    TRACE("NtUserDispatchMessage");
    ENDRECV();
}

BOOL NtUserEnableMenuItem(
    IN HMENU hMenu,
    IN UINT wIDEnableItem,
    IN UINT wEnable)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV(BOOL, -1);

    TESTFLAGS(wEnable, MF_VALID);

    ValidateHMENUMODIFY(pmenu, hMenu);

    ThreadLockAlways(pmenu, &tlpMenu);
    retval = xxxEnableMenuItem(
            pmenu,
            wIDEnableItem,
            wEnable);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserEnableMenuItem");
    ENDRECV();
}

BOOL NtUserAttachThreadInput(
    IN DWORD idAttach,
    IN DWORD idAttachTo,
    IN BOOL fAttach)
{
    PTHREADINFO ptiAttach;
    PTHREADINFO ptiAttachTo;

    BEGINRECV(BOOL, FALSE);

    /*
     * Always must attach or detach from a real thread id.
     */
    if ((ptiAttach = PtiFromThreadId(idAttach)) == NULL) {
        MSGERROR(0);
    }
    if ((ptiAttachTo = PtiFromThreadId(idAttachTo)) == NULL) {
        MSGERROR(0);
    }

    retval = zzzAttachThreadInput(
            ptiAttach,
            ptiAttachTo,
            fAttach);

    TRACE("NtUserAttachThreadInput");
    ENDRECV();
}

BOOL NtUserGetWindowPlacement(  // API GetWindowPlacement
    IN HWND hwnd,
    OUT PWINDOWPLACEMENT pwp)
{
    WINDOWPLACEMENT wp;
    BEGINRECV_HWND(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteWindowPlacement(pwp);
        wp.length = pwp->length;
#ifdef LATER
        if (pwp->length != sizeof(WINDOWPLACEMENT)) {
            if (TestWF(pwnd, WFWIN40COMPAT)) {
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "GetWindowPlacement: invalid length %lX", pwp->length);
                MSGERROR(0);
            } else {
                RIPMSG1(RIP_WARNING, "GetWindowPlacement: invalid length %lX", pwp->length);
                pwp->length = sizeof(WINDOWPLACEMENT);
            }
        }
#endif

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _GetWindowPlacement(pwnd, &wp);

    try {
        RtlCopyMemory(pwp, &wp, sizeof(WINDOWPLACEMENT));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetWindowPlacement");
    ENDRECV_HWND();
}

BOOL NtUserSetWindowPlacement(  // API SetWindowPlacement
    IN HWND hwnd,
    IN CONST WINDOWPLACEMENT *pwp)
{
    WINDOWPLACEMENT wp;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        wp = ProbeAndReadWindowPlacement(pwp);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (wp.length != sizeof(WINDOWPLACEMENT)) {
        if (Is400Compat(ptiCurrent->dwExpWinVer)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "SetWindowPlacement: invalid length %lX", pwp->length);
            MSGERROR(0);
        } else {
            RIPMSG1(RIP_WARNING, "SetWindowPlacement: invalid length %lX", pwp->length);
        }
    }

    retval = xxxSetWindowPlacement(pwndND, &wp);

    TRACE("NtUserSetWindowPlacement");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserLockWindowUpdate(  // API LockWindowUpdate
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = LockWindowUpdate2(pwnd, FALSE);

    TRACE("NtUserLockWindowUpdate");
    ENDATOMICRECV();
}

BOOL NtUserGetClipCursor(  // API GetClipCursor
    OUT LPRECT lpRect)
{
    /*
     * Check if the caller has the proper access rights: if not, this will
     * SetLastError to ERROR_ACCESS_DENIED and return FALSE. Do this *before*
     * BEGINRECV_SHARED, else we must use MSGERROR to release the critsect!
     */
    RETURN_IF_ACCESS_DENIED(PpiCurrent()->amwinsta,
                            WINSTA_READATTRIBUTES,
                            FALSE);
    {
        BEGINRECV_SHARED(BOOL, FALSE);

        /*
         * Probe arguments
         */
        try {
            ProbeForWriteRect(lpRect);

            *lpRect = grcCursorClip;
            retval = TRUE;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }

        TRACE("NtUserGetClipCursor");
        ENDRECV_SHARED();
    }
}

BOOL NtUserEnableScrollBar(
    IN HWND hwnd,
    IN UINT wSBflags,
    IN UINT wArrows)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    LIMITVALUE(wSBflags, SB_MAX, "EnableScrollBar");

    retval = xxxEnableScrollBar(
            pwndND,
            wSBflags,
            wArrows);

    TRACE("NtUserEnableScrollBar");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserDdeSetQualityOfService(  // API DdeSetQualityOfService
    IN HWND hwndClient,
    IN CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    OUT PSECURITY_QUALITY_OF_SERVICE pqosPrev OPTIONAL)
{
    SECURITY_QUALITY_OF_SERVICE qosNew, qosPrev;

    BEGINRECV_HWND(BOOL, FALSE, hwndClient);

    if (GETPTI(pwnd) != PtiCurrent()) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        qosNew = ProbeAndReadStructure(pqosNew, SECURITY_QUALITY_OF_SERVICE);
        if (ARGUMENT_PRESENT(pqosPrev))
            ProbeForWrite(pqosPrev, sizeof(*pqosPrev), sizeof(DWORD));

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _DdeSetQualityOfService(
                pwnd,
                &qosNew,
                &qosPrev);

    try {
        if (ARGUMENT_PRESENT(pqosPrev))
            *pqosPrev = qosPrev;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserDdeSetQualityOfService");
    ENDRECV_HWND();
}

BOOL NtUserDdeGetQualityOfService(  // private DdeGetQualityOfService
    IN HWND hwndClient,
    IN HWND hwndServer,
    OUT PSECURITY_QUALITY_OF_SERVICE pqos)
{
    PWND pwndServer;
    PTHREADINFO ptiCurrent;
    SECURITY_QUALITY_OF_SERVICE qos;

    BEGINATOMICRECV_HWND(BOOL, FALSE, hwndClient);

    ValidateHWNDOPT(pwndServer, hwndServer);
    ptiCurrent = PtiCurrent();
    if (GETPTI(pwnd) != ptiCurrent && pwndServer != NULL &&
            GETPTI(pwndServer) != ptiCurrent) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWrite(pqos, sizeof(*pqos), DATAALIGN);

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = _DdeGetQualityOfService(
                pwnd,
                pwndServer,
                &qos);
    try {
        RtlCopyMemory(pqos, &qos, sizeof (SECURITY_QUALITY_OF_SERVICE));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserDdeGetQualityOfService");
    ENDATOMICRECV_HWND();
}

DWORD NtUserGetMenuIndex(
    IN HMENU hMenu,
    IN HMENU hSubMenu)
{

    PMENU pmenu;
    PMENU psubmenu;
    DWORD idx;

    BEGINRECV_SHARED(DWORD, 0);

    ValidateHMENU(pmenu, hMenu);
    ValidateHMENU(psubmenu, hSubMenu);

    retval = (DWORD)-1;

    if (pmenu && psubmenu) {
        for (idx=0; idx<pmenu->cItems; idx++)
            if ((pmenu->rgItems[idx].spSubMenu == psubmenu)) {
                retval = idx;
                break;
            }
    }

    TRACE("NtUserGetMenuIndex");
    ENDRECV_SHARED();
}

#if DBG
VOID NtUserSetRipFlags(
    DWORD dwRipFlags)
{
    BEGINRECV_VOID();

    SetRipFlags(dwRipFlags);

    TRACEVOID("NtUserSetRipFlags");
    ENDRECV_VOID();
}

VOID NtUserSetDbgTag(
    int tag,
    DWORD dwBitFlags)
{
    BEGINRECV_VOID();

    SetDbgTag(tag, dwBitFlags);

    TRACEVOID("NtUserSetDbgTag");
    ENDRECV_VOID();
}

VOID NtUserSetDbgTagCount(
    DWORD dwTagCount)
{
    BEGINRECV_VOID();

    SetDbgTagCount(dwTagCount);

    TRACEVOID("NtUserSetDbgTagCount");
    ENDRECV_VOID();
}
#endif

ULONG_PTR NtUserCallNoParam(
    IN DWORD xpfnProc)
{
    BEGINRECV(ULONG_PTR, 0);

    /*
     * C4296: (...) : expression is always true/false
     * The first comparison in ISXPFNPROCINRANGE is always true for
     * SFI_BEGINTRANSLATENOPARAMXXX, so we explicitly disable the warning.
     */
#pragma warning(disable:4296)
    VALIDATEXPFNPROC(NOPARAM);

    retval = (apfnSimpleCall[xpfnProc]());
    if (ISXPFNPROCINRANGE(NOPARAMANDRETURNHANDLE)) {
        retval = (ULONG_PTR)PtoH((PVOID)retval);
    }
#pragma warning(default:4296)

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV();
}

ULONG_PTR NtUserCallOneParam(
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc)
{
    BEGINRECV(ULONG_PTR, 0);

    VALIDATEXPFNPROC(ONEPARAM);

    retval = (apfnSimpleCall[xpfnProc](dwParam));
    if (ISXPFNPROCINRANGE(ONEPARAMANDRETURNHANDLE)) {
        retval = (ULONG_PTR)PtoH((PVOID)retval);
    }

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV();
}

ULONG_PTR NtUserCallHwnd(
    IN HWND hwnd,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    VALIDATEXPFNPROC(HWND);

    retval = (apfnSimpleCall[xpfnProc](pwnd));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK();
}

ULONG_PTR NtUserCallHwndLock(
    IN HWND hwnd,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK_COND_ND(ULONG_PTR, 0, hwnd, xpfnProc);

    VALIDATEXPFNPROC(HWNDLOCK);

    retval = apfnSimpleCall[xpfnProc](pwndCondND);

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK_COND_ND();
}

ULONG_PTR NtUserCallHwndOpt(
    IN HWND hwnd,
    IN DWORD xpfnProc)
{
    PWND pwnd;

    BEGINATOMICRECV(ULONG_PTR, 0);

    ValidateHWNDOPT(pwnd, hwnd);

    VALIDATEXPFNPROC(HWNDOPT);

    retval = (apfnSimpleCall[xpfnProc](pwnd));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDATOMICRECV();
}

ULONG_PTR NtUserCallHwndParam(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    VALIDATEXPFNPROC(HWNDPARAM);

    retval = (apfnSimpleCall[xpfnProc](pwnd, dwParam));
    if (ISXPFNPROCINRANGE(HWNDPARAMANDRETURNHANDLE)) {
        retval = (ULONG_PTR)PtoH((PVOID)retval);
    }

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK();
}

ULONG_PTR NtUserCallHwndParamLock(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK_COND_ND(ULONG_PTR, 0, hwnd, xpfnProc);

    VALIDATEXPFNPROC(HWNDPARAMLOCK);

    retval = apfnSimpleCall[xpfnProc](pwndCondND, dwParam);

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK_COND_ND();
}

ULONG_PTR NtUserCallTwoParam(
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    IN DWORD xpfnProc)
{
    BEGINRECV(ULONG_PTR, 0);

    VALIDATEXPFNPROC(TWOPARAM);

    retval = (apfnSimpleCall[xpfnProc](dwParam1, dwParam2));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV();
}

BOOL NtUserThunkedMenuItemInfo(  // worker for various menu APIs
    IN HMENU hMenu,
    IN UINT nPosition,
    IN BOOL fByPosition,
    IN BOOL fInsert,
    IN LPMENUITEMINFOW lpmii,
    IN PUNICODE_STRING pstrItem OPTIONAL)
{
    PMENU pmenu;
    MENUITEMINFO mii;
    UNICODE_STRING strItem;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     * No need to SetLastError because lpmii is always the address of
     * a local stack structure in USER code, not an application address.
     */
    try {
        mii = ProbeAndReadMenuItem(lpmii);

        if (ARGUMENT_PRESENT(pstrItem)) {
            strItem = ProbeAndReadUnicodeString(pstrItem);
            ProbeForReadUnicodeStringBuffer(strItem);
        } else {
            RtlInitUnicodeString(&strItem, NULL);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    if (fInsert) {
        ValidateHMENUMODIFYCHECKLOCK(pmenu, hMenu);
    } else {
        ValidateHMENUMODIFY(pmenu, hMenu);
    }

    ThreadLock(pmenu, &tlpMenu);
    /*
     * These routines only use the buffer in a try/except (actually in
     * xxxSetLPITEMInfo).
     */
    if (fInsert) {
        retval = xxxInsertMenuItem(
                pmenu,
                nPosition,
                fByPosition,
                &mii,
                &strItem);
    } else {
        retval = xxxSetMenuItemInfo(
                pmenu,
                nPosition,
                fByPosition,
                &mii,
                &strItem);
    }
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserThunkedMenuItemInfo");
    ENDRECV();
}

/***************************************************************************\
* NtUserThunkedMenuInfo
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
BOOL NtUserThunkedMenuInfo(  // API SetMenuInfo
    IN HMENU hMenu,
    IN LPCMENUINFO lpmi)
{
    PMENU pmenu;
    MENUINFO mi;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        mi = ProbeAndReadMenuInfo(lpmi);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ValidateHMENUMODIFY(pmenu, hMenu);

    ThreadLock(pmenu, &tlpMenu);
    retval = xxxSetMenuInfo(pmenu, &mi);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserThunkedMenuInfo");
    ENDRECV();
}

BOOL NtUserSetMenuDefaultItem(
    IN HMENU hMenu,
    IN UINT wID,
    IN UINT fByPosition)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENUMODIFY(pmenu, hMenu);

    retval = _SetMenuDefaultItem(
            pmenu,
            wID,
            fByPosition);

    TRACE("NtUserSetMenuDefaultItem");
    ENDATOMICRECV();
}

BOOL NtUserSetMenuContextHelpId(
    IN HMENU hMenu,
    IN DWORD dwContextHelpId)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENUMODIFY(pmenu, hMenu);

    retval = _SetMenuContextHelpId(
            pmenu,
            dwContextHelpId);

    TRACE("NtUserSetMenuContextHelpId");
    ENDATOMICRECV();
}

BOOL NtUserSetMenuFlagRtoL(
    IN HMENU hMenu)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENU(pmenu, hMenu);

    retval = _SetMenuFlagRtoL(pmenu);

    TRACE("NtUserSetMenuFlagRtoL");
    ENDATOMICRECV();
}

BOOL NtUserDrawAnimatedRects(  // API DrawAnimatedRects
    IN HWND hwnd,
    IN int idAni,
    IN CONST RECT *lprcFrom,
    IN CONST RECT *lprcTo)
{
    PWND pwnd;
    TL tlpwnd;
    RECT rcFrom;
    RECT rcTo;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    /*
     * Probe arguments
     */
    try {
        rcFrom = ProbeAndReadRect(lprcFrom);
        rcTo = ProbeAndReadRect(lprcTo);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxDrawAnimatedRects(
        pwnd,
        idAni,
        &rcFrom,
        &rcTo);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserDrawAnimatedRects");
    ENDRECV();
}

BOOL NtUserDrawCaption(  // API DrawCaption
    IN HWND hwnd,
    IN HDC hdc,
    IN CONST RECT *lprc,
    IN UINT flags)
{
    RECT rc;

    BEGINRECV_HWNDLOCK(DWORD, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect(lprc);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxDrawCaptionTemp(pwnd, hdc, &rc, NULL, NULL, NULL, flags);

    TRACE("NtUserDrawCaption");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserPaintDesktop(
    IN HDC hdc)
{
    PTHREADINFO ptiCurrent;
    PWND        pwndDesk;
    TL          tlpwndDesk;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    if (ptiCurrent->rpdesk != NULL) {
        pwndDesk = ptiCurrent->rpdesk->pDeskInfo->spwnd;
        ThreadLockWithPti(ptiCurrent, pwndDesk, &tlpwndDesk);
        retval = xxxInternalPaintDesktop(pwndDesk, hdc, TRUE);
        ThreadUnlock(&tlpwndDesk);
    } else {
        MSGERROR(0);
    }

    TRACE("NtUserPaintDesktop");
    ENDRECV();
}

SHORT NtUserGetAsyncKeyState(
    IN int vKey)
{

    PTHREADINFO ptiCurrent;
    BEGINRECV_SHARED(SHORT, 0);


    ptiCurrent = PtiCurrentShared();
    UserAssert(ptiCurrent);

    /*
     * Don't allow other processes to spy on other deskops or a process
     * to spy on the foreground if the desktop does not allow input spying
     */
    if ((ptiCurrent->rpdesk != grpdeskRitInput) ||
            ( ((gptiForeground == NULL) || (PpiCurrent() != gptiForeground->ppi)) &&
              !RtlAreAnyAccessesGranted(ptiCurrent->amdesk, (DESKTOP_HOOKCONTROL | DESKTOP_JOURNALRECORD)))) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "GetAysncKeyState: not"
                " foreground desktop or no desktop hooking (input spying)");
        MSGERROR(0);
    }
    UserAssert(!(ptiCurrent->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    retval = _GetAsyncKeyState(vKey);

    /*
     * Update the client side key state cache.
     */
    try {
        ptiCurrent->pClientInfo->dwAsyncKeyCache = gpsi->dwAsyncKeyCache;
        RtlCopyMemory(ptiCurrent->pClientInfo->afAsyncKeyState,
                      gafAsyncKeyState,
                      CBASYNCKEYCACHE);
        RtlCopyMemory(ptiCurrent->pClientInfo->afAsyncKeyStateRecentDown,
                      gafAsyncKeyStateRecentDown,
                      CBASYNCKEYCACHE);
    } except (StubExceptionHandler(TRUE)) {
        retval = 0;
    }

    TRACE("NtUserGetAsyncKeyState");
    ENDRECV_SHARED();
}

HBRUSH NtUserGetControlBrush(
    IN HWND hwnd,
    IN HDC hdc,
    IN UINT msg)
{
    BEGINRECV_HWNDLOCK(HBRUSH, NULL, hwnd);

    if (hdc == NULL || !InMsgRange(msg, WM_CTLCOLORFIRST, WM_CTLCOLORLAST)) {
        MSGERROR(0);
    }

    retval = xxxGetControlBrush(
            pwnd,
            hdc,
            msg);

    TRACE("NtUserGetControlBrush");
    ENDRECV_HWNDLOCK();
}

HBRUSH NtUserGetControlColor(
    IN HWND hwndParent,
    IN HWND hwndCtl,
    IN HDC hdc,
    IN UINT msg)
{
    PWND pwndCtl;
    TL tlpwndCtl;

    BEGINRECV_HWNDLOCK(HBRUSH, NULL, hwndParent);

    ValidateHWND(pwndCtl, hwndCtl);

    if (hdc == NULL || !InMsgRange(msg, WM_CTLCOLORFIRST, WM_CTLCOLORLAST)) {
        MSGERROR(0);
    }

    ThreadLockAlwaysWithPti(ptiCurrent, pwndCtl, &tlpwndCtl);

    retval = xxxGetControlColor(
            pwnd,
            pwndCtl,
            hdc,
            msg);

    ThreadUnlock(&tlpwndCtl);

    TRACE("NtUserGetControlColor");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserEndMenu(VOID)
{
    PTHREADINFO ptiCurrent;
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    /*
     * The menu might be in the middle of some callback, so calling xxxEndMenu
     *  directly might mess things up. So we post it a message to signal it to
     *  go away at a good moment
     */
    if (ptiCurrent->pMenuState != NULL) {
        pwnd = GetMenuStateWindow(ptiCurrent->pMenuState);

        if (pwnd != NULL) {
            _PostMessage(pwnd, MN_ENDMENU, 0, 0);
        } else {
            /*
             * Is this menu messed up?
             */
            UserAssert(pwnd != NULL);
            ptiCurrent->pMenuState->fInsideMenuLoop = FALSE;
        }
    }

    retval = TRUE;

    TRACEVOID("NtUserEndMenu");
    ENDRECV();
}

int NtUserCountClipboardFormats(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(int, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = pwinsta->cNumClipFormats;

    TRACE("NtUserCountClipboardFormats");
    ENDRECV_SHARED();
}

DWORD NtUserGetClipboardSequenceNumber(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(DWORD, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = pwinsta->iClipSequenceNumber;

    TRACE("NtUserGetClipboardSequenceNumber");
    ENDRECV_SHARED();
}

UINT NtUserGetCaretBlinkTime(VOID)
{
    BEGINRECV_SHARED(UINT, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights. However,
     * allow CSRSS to use this value internally to the server. Note that if the
     * client tries to retrieve this value itself, the access check will
     * function normally.
     */
    if ((PpiCurrent()->Process != gpepCSRSS) &&
        (!CheckGrantedAccess(PpiCurrent()->amwinsta, WINSTA_READATTRIBUTES))) {
        MSGERROR(0);
    }

    retval = gpsi->dtCaretBlink;

    TRACE("NtUserGetCaretBlinkTime");
    ENDRECV_SHARED();
}

HWND NtUserGetClipboardOwner(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = PtoH(pwinsta->spwndClipOwner);

    TRACE("NtUserGetClipboardOwner");
    ENDRECV_SHARED();
}

HWND NtUserGetClipboardViewer(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = PtoH(pwinsta->spwndClipViewer);

    TRACE("NtUserGetClipboardViewer");
    ENDRECV_SHARED();
}

UINT NtUserGetDoubleClickTime(
    VOID)
{
    BEGINRECV_SHARED(UINT, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights. However,
     * allow CSRSS to use this value internally to the server. Note that if the
     * client tries to retrieve this value itself, the access check will
     * function normally.
     */
    if ((PpiCurrent()->Process != gpepCSRSS) &&
        (!CheckGrantedAccess(PpiCurrent()->amwinsta, WINSTA_READATTRIBUTES))) {
        MSGERROR(0);
    }

    retval = gdtDblClk;

    TRACE("NtUserGetDoubleClickTime");
    ENDRECV_SHARED();
}

HWND NtUserGetForegroundWindow(
    VOID)
{
    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Only return a window if there is a foreground queue and the
     * caller has access to the current desktop.
     */
    if (gpqForeground == NULL || gpqForeground->spwndActive == NULL ||
            PtiCurrentShared()->rpdesk != gpqForeground->spwndActive->head.rpdesk) {
        MSGERROR(0);
    }

    retval = PtoHq(gpqForeground->spwndActive);

    TRACE("NtUserGetForegroundWindow");
    ENDRECV_SHARED();
}

HWND NtUserGetOpenClipboardWindow(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = PtoH(pwinsta->spwndClipOpen);

    TRACE("NtUserGetOpenClipboardWindow");
    ENDRECV_SHARED();
}

int NtUserGetPriorityClipboardFormat(  // API GetPriorityClipboardFormat
    IN UINT *paFormatPriorityList,
    IN int cFormats)
{
    BEGINRECV_SHARED(int, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForReadBuffer(paFormatPriorityList, cFormats, DATAALIGN);

        retval = _GetPriorityClipboardFormat(
                paFormatPriorityList,
                cFormats);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetPriorityClipboardFormat");
    ENDRECV_SHARED();
}

HMENU NtUserGetSystemMenu(
    IN HWND hwnd,
    IN BOOL bRevert)
{
    BEGINRECV_HWNDLOCK(HMENU, NULL, hwnd);

    retval = (HMENU)xxxGetSystemMenu(pwnd, bRevert);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserGetSystemMenu");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserGetUpdateRect(  // API GetUpdateRect
    IN HWND hwnd,
    IN LPRECT prect OPTIONAL,
    IN BOOL bErase)
{
    RECT rect2;
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxGetUpdateRect(
            pwnd,
            prect? &rect2:NULL,
            bErase);
    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(prect)) {
        try {
            ProbeAndWriteStructure(prect, rect2, RECT);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetUpdateRect");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserHideCaret(
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = zzzHideCaret(pwnd);

    TRACE("NtUserHideCaret");
    ENDRECV();
}

BOOL NtUserHiliteMenuItem(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uIDHiliteItem,
    IN UINT uHilite)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    TESTFLAGS(uHilite, MF_VALID);

    ValidateHMENUMODIFY(pmenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxHiliteMenuItem(
            pwnd,
            pmenu,
            uIDHiliteItem,
            uHilite);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserHiliteMenuItem");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserInvalidateRect(  // API InvalidateRect
    IN HWND hwnd,
    IN CONST RECT *prect OPTIONAL,
    IN BOOL bErase)
{
    PWND pwnd;
    TL tlpwnd;
    RECT rc;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(prect)) {
        try {
            rc = ProbeAndReadRect(prect);
            prect = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxInvalidateRect(
            pwnd,
            (PRECT)prect,
            bErase);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserInvalidateRect");
    ENDRECV();
}

BOOL NtUserIsClipboardFormatAvailable(
    IN UINT nFormat)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(BOOL, FALSE);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = (FindClipFormat(pwinsta, nFormat) != NULL);

    TRACE("NtUserIsClipboardFormatAvailable");
    ENDRECV_SHARED();
}

BOOL NtUserKillTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _KillTimer(
            pwnd,
            nIDEvent);

    TRACE("NtUserKillTimer");
    ENDATOMICRECV();
}

HWND NtUserMinMaximize(
    IN HWND hwnd,
    IN UINT nCmdShow,
    IN BOOL fKeepHidden)
{
    BEGINRECV_HWNDLOCK_ND(HWND, NULL, hwnd);

    retval = (HWND)xxxMinMaximize(
            pwndND,
            nCmdShow,
            ((fKeepHidden) ? MINMAX_KEEPHIDDEN : 0) | TEST_PUDF(PUDF_ANIMATE));
    retval = PtoH((PVOID)retval);

    TRACE("NtUserMinMaximize");
    ENDRECV_HWNDLOCK_ND();
}

/**************************************************************************\
* NtUserMNDragOver
*
* Called from the IDropTarget interface to let menus update the selection
*  given the mouse position. It also returns the handle of the menu the
*  the index of the item  the point is on.
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
BOOL NtUserMNDragOver(  // worker for menu drag & drop
    IN POINT * ppt,
    OUT PMNDRAGOVERINFO pmndoi)
{
    POINT pt;
    MNDRAGOVERINFO mndoi;

    BEGINRECV(BOOL, FALSE);

    /*
     * No need to SetLastError since ppt and pmndoi are always addresses of
     * local stack variables in USER, not addresses from an application
     */
    try {
        pt = ProbeAndReadPoint(ppt);
    } except (StubExceptionHandler(FALSE)) {
        RIPMSG1(RIP_WARNING, "NtUserMNDragOver: Exception:%#lx", GetExceptionCode());
        MSGERROR(0);
    }

    retval = xxxMNDragOver(&pt, &mndoi);

    if (retval) {
        try {
            ProbeAndWriteStructure(pmndoi, mndoi, MNDRAGOVERINFO);
        } except (StubExceptionHandler(FALSE)) {
            RIPMSG1(RIP_WARNING, "NtUserMNDragOver: Exception:%#lx", GetExceptionCode());
            MSGERROR(0);
        }
    }

    TRACE("NtUserMNDragOver");
    ENDRECV();
}
/**************************************************************************\
* NtUserMNDragLeave
*
* Called from the IDropTarget interface to let the menu clean up
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
BOOL NtUserMNDragLeave(VOID)
{
    BEGINRECV(BOOL, FALSE);
    retval = xxxMNDragLeave();
    TRACE("NtUserMNDragLeave");
    ENDRECV();
}

BOOL NtUserOpenClipboard(  // API OpenClipboard
    IN HWND hwnd,
    OUT PBOOL pfEmptyClient)
{
    PWND pwnd;
    TL tlpwnd;
    BOOL fEmptyClient;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = _OpenClipboard(pwnd, &fEmptyClient);

    ThreadUnlock(&tlpwnd);

    /*
     * Probe arguments
     * No need to SetLastError since pfEmptyClient is the address of a local
     * variable in USER client code, not an application address.
     */
    try {
        ProbeAndWriteUlong(pfEmptyClient, fEmptyClient);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserOpenClipboard");
    ENDRECV();
}

BOOL NtUserPeekMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT wRemoveMsg)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(wRemoveMsg, PM_VALID);

    retval = xxxPeekMessage(
            &msg,
            hwnd,
            wMsgFilterMin,
            wMsgFilterMax,
            wRemoveMsg);

    /*
     * Probe and write arguments only if PeekMessage suceeds otherwise
     * we want to leave MSG undisturbed (bug 16224) to be compatible.
     */
    if (retval) {
        try {
            ProbeAndWriteStructure(pmsg, msg, MSG);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserPeekMessage");
    ENDRECV();
}

BOOL NtUserPostMessage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (msg & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        MSGERROR(0);
    }

    switch ((ULONG_PTR)hwnd) {
    case -1:
    case 0x0000FFFF:
        pwnd = PWND_BROADCAST;
        break;

    case 0:
        pwnd = NULL;
        break;

    default:
        if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
            /*
             * We fake terminates to dead windows! (SAS)
             */
            errret = (msg == WM_DDE_TERMINATE);
            MSGERROR(0);
        }
        break;
    }

    retval = _PostMessage(
            pwnd,
            msg,
            wParam,
            lParam);

    TRACE("NtUserPostMessage");
    ENDRECV();
}

BOOL NtUserRegisterHotKey(
    IN HWND hwnd,
    IN int id,
    IN UINT fsModifiers,
    IN UINT vk)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    TESTFLAGS(fsModifiers, MOD_VALID);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _RegisterHotKey(pwnd, id, fsModifiers, vk);

    TRACE("NtUserRegisterHotKey");
    ENDATOMICRECV();
}

BOOL NtUserRemoveMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(dwFlags, MF_VALID);

    ValidateHMENUMODIFYCHECKLOCK(pmenu, hmenu);

    ThreadLock(pmenu, &tlpMenu);
    retval = xxxRemoveMenu(pmenu, nPosition, dwFlags);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserRemoveMenu");
    ENDRECV();
}

BOOL NtUserScrollWindowEx(  // API ScrollWindowEx
    IN HWND hwnd,
    IN int dx,
    IN int dy,
    IN CONST RECT *prcScroll OPTIONAL,
    IN CONST RECT *prcClip OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT prcUpdate OPTIONAL,
    IN UINT flags)
{
    RECT rcScroll;
    RECT rcClip;
    RECT rcUpdate;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(prcScroll)) {
            rcScroll = ProbeAndReadRect(prcScroll);
            prcScroll = &rcScroll;
        }
        if (ARGUMENT_PRESENT(prcClip)) {
            rcClip = ProbeAndReadRect(prcClip);
            prcClip = &rcClip;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxScrollWindowEx(
                pwnd,
                dx,
                dy,
                (PRECT)prcScroll,
                (PRECT)prcClip,
                hrgnUpdate,
                prcUpdate ? &rcUpdate : NULL,
                flags);

    if (ARGUMENT_PRESENT(prcUpdate)) {
        try {
            ProbeAndWriteStructure(prcUpdate, rcUpdate, RECT);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserScrollWindow");
    ENDRECV_HWNDLOCK();
}

HWND NtUserSetActiveWindow(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetActiveWindow(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetActiveWindow");
    ENDRECV();
}

HWND NtUserSetCapture(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetCapture(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetCapture");
    ENDRECV();
}

WORD NtUserSetClassWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord)
{
    BEGINRECV_HWND(WORD, 0, hwnd);

    retval = _SetClassWord(
            pwnd,
            nIndex,
            wNewWord);

    TRACE("NtUserSetClassWord");
    ENDRECV_HWND();
}

HWND NtUserSetClipboardViewer(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetClipboardViewer(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetClipboardViewer");
    ENDRECV();
}

HCURSOR NtUserSetCursor(
    IN HCURSOR hCursor)
{
    PCURSOR pCursor;

    BEGINRECV(HCURSOR, NULL);

    ValidateHCURSOROPT(pCursor, hCursor);

    retval = (HCURSOR)zzzSetCursor(pCursor);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserSetCursor");
    ENDRECV();
}

HWND NtUserSetFocus(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetFocus(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetFocus");
    ENDRECV();
}

BOOL NtUserSetMenu(
    IN HWND  hwnd,
    IN HMENU hmenu,
    IN BOOL  fRedraw)
{
    PMENU pmenu;
    TL    tlpMenu;

    BEGINRECV_HWNDLOCK_ND(DWORD, 0, hwnd);

    ValidateHMENUOPT(pmenu, hmenu);

    ThreadLockWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxSetMenu(pwndND, pmenu, fRedraw);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserSetMenu");
    ENDRECV_HWNDLOCK_ND();
}

HWND NtUserSetParent(
    IN HWND hwndChild,
    IN HWND hwndNewParent)
{

    PWND pwndNewParent;
    TL tlpwndNewParent;

    BEGINRECV_HWNDLOCK_ND(HWND, NULL, hwndChild);

    if (hwndNewParent == NULL) {
        pwndNewParent = _GetDesktopWindow();
    } else if (hwndNewParent == HWND_MESSAGE) {
        pwndNewParent = _GetMessageWindow();
    } else {
        ValidateHWND(pwndNewParent, hwndNewParent);
    }

    ThreadLockWithPti(ptiCurrent, pwndNewParent, &tlpwndNewParent);

    retval = (HWND)xxxSetParent(
            pwndND,
            pwndNewParent);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwndNewParent);

    TRACE("NtUserSetParent");
    ENDRECV_HWNDLOCK_ND();
}

int NtUserSetScrollInfo(  // API SetScrollInfo
    IN HWND hwnd,
    IN int nBar,
    IN LPCSCROLLINFO pInfo,
    IN BOOL fRedraw)
{
    SCROLLINFO si;

    BEGINRECV_HWNDLOCK_ND(DWORD, 0, hwnd);

    LIMITVALUE(nBar, SB_MAX, "SetScrollInfo");

    /*
     * Probe arguments
     */
    try {
        si = ProbeAndReadScrollInfo(pInfo);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxSetScrollBar(pwndND, nBar, &si, fRedraw);

    TRACE("NtUserSetScrollInfo");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserSetSysColors(  // API SetSysColors
    IN int nCount,
    IN CONST INT *pSysColor,
    IN CONST COLORREF *pColorValues,
    IN UINT  uOptions)
{
    LPINT lpSysColors = NULL;
    LPDWORD lpSysColorValues = NULL;
    TL tlName, tlSysColors, tlSysColorValues;
    PUNICODE_STRING pProfileUserName = NULL;
    PTHREADINFO ptiCurrent;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    /*
     * Prevent restricted threads from changing global stuff
     */
    if (IS_THREAD_RESTRICTED(ptiCurrent, JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS)) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    if (nCount) {
        try {
            ProbeForReadBuffer(pSysColor, nCount, DATAALIGN);
            ProbeForReadBuffer(pColorValues, nCount, DATAALIGN);
            lpSysColors = UserAllocPoolWithQuota(nCount * sizeof(*pSysColor), TAG_COLORS);
            if (lpSysColors == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(lpSysColors, pSysColor, nCount * sizeof(*pSysColor));
            lpSysColorValues = UserAllocPoolWithQuota(nCount * sizeof(*pColorValues), TAG_COLORVALUES);
            if (lpSysColorValues == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(lpSysColorValues, pColorValues, nCount * sizeof(*pColorValues));

        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    }

    ThreadLockPool(ptiCurrent, lpSysColors, &tlSysColors);
    ThreadLockPool(ptiCurrent, lpSysColorValues, &tlSysColorValues);
    pProfileUserName = CreateProfileUserName(&tlName);
    retval = xxxSetSysColors(pProfileUserName,
                             nCount,
                             lpSysColors,
                             lpSysColorValues,
                             uOptions);
    FreeProfileUserName(pProfileUserName, &tlName);
    ThreadUnlockPool(ptiCurrent, &tlSysColorValues);
    ThreadUnlockPool(ptiCurrent, &tlSysColors);

    CLEANUPRECV();
    if (lpSysColors) {
        UserFreePool(lpSysColors);
    }
    if (lpSysColorValues) {
        UserFreePool(lpSysColorValues);
    }

    TRACE("NtUserSetSysColors");
    ENDRECV();
}

UINT_PTR NtUserSetTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN UINT wElapse,
    IN TIMERPROC pTimerFunc)
{
    PWND pwnd;

    BEGINATOMICRECV(UINT_PTR, 0);

    ValidateHWNDOPT(pwnd, hwnd);

    /*
     * We have code on the client side that assumes no CSRSS code creates
     * a timer with a timer proc, so assert that that's the case.
     */
    UserAssert(PsGetCurrentProcess() != gpepCSRSS || pTimerFunc == NULL);

    /*
     * If we let apps set a timer granularity less then 10 the app
     * spends too long processing timer messages. Some WOW apps like
     * Paradox in WinStone use zero to effectively get the minimal
     * timer value which was ~55ms in Win 3.1. We also step this
     * value up for 32 bit apps because the NT timer resolution
     * can very depending if the multimedia timers have turned up
     * the resolution. If they have NT apps that specify a low value
     * will not work properly because they will eat the CPU processing
     * WM_TIMER messages.
     */
    if (wElapse < 10) {
        wElapse = 10;
    }

    retval = _SetTimer(
            pwnd,
            nIDEvent,
            wElapse,
            (TIMERPROC_PWND)pTimerFunc);

    TRACE("NtUserSetTimer");
    ENDATOMICRECV();
}

LONG_PTR NtUserSetWindowLongPtr(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong,
    IN BOOL bAnsi)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    retval = xxxSetWindowLongPtr(pwnd, nIndex, dwNewLong, bAnsi);

    TRACE("NtUserSetWindowLongPtr");
    ENDRECV_HWNDLOCK();
}

#ifdef _WIN64
LONG NtUserSetWindowLong(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong,
    IN BOOL bAnsi)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxSetWindowLong(pwnd, nIndex, dwNewLong, bAnsi);

    TRACE("NtUserSetWindowLong");
    ENDRECV_HWNDLOCK();
}
#endif

WORD NtUserSetWindowWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord)
{
    BEGINRECV_HWND(WORD, 0, hwnd);

    retval = _SetWindowWord(pwnd, nIndex, wNewWord);

    TRACE("NtUserSetWindowWord");
    ENDRECV_HWND();
}

HHOOK NtUserSetWindowsHookAW(
    IN int nFilterType,
    IN HOOKPROC pfnFilterProc,
    IN DWORD dwFlags)
{
    BEGINRECV(HHOOK, NULL);

    retval = (HHOOK)zzzSetWindowsHookAW(nFilterType, (PROC)pfnFilterProc, dwFlags);

    TRACE("NtUserSetWindowsHookAW");
    ENDRECV();
}

BOOL NtUserShowCaret(
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = zzzShowCaret(pwnd);

    TRACE("NtUserShowCaret");
    ENDRECV();
}

BOOL NtUserShowScrollBar(
    IN HWND hwnd,
    IN int iBar,
    IN BOOL fShow)
{
    BEGINRECV_HWNDLOCK_ND(DWORD, 0, hwnd);

    LIMITVALUE(iBar, SB_MAX, "ShowScrollBar");

    retval = xxxShowScrollBar(pwndND, iBar, fShow);

    TRACE("NtUserShowScrollBar");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserShowWindowAsync(
    IN HWND hwnd,
    IN int nCmdShow)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    LIMITVALUE(nCmdShow, SW_MAX, "ShowWindowAsync");

    retval = _ShowWindowAsync(pwndND, nCmdShow, 0);

    TRACE("NtUserShowWindowAsync");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserShowWindow(
    IN HWND hwnd,
    IN int nCmdShow)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    LIMITVALUE(nCmdShow, SW_MAX, "ShowWindow");

    /*
     * Let's not allow the window to be shown/hidden once we
     * started the destruction of the window.
     */
    if (TestWF(pwndND, WFINDESTROY)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "ShowWindow: Window is being destroyed (%#p)",
                pwndND);
        MSGERROR(0);
    }

    retval = xxxShowWindow(pwndND, nCmdShow | TEST_PUDF(PUDF_ANIMATE));

    TRACE("NtUserShowWindow");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserTrackMouseEvent(  // API TrackMouseEvent
    IN OUT LPTRACKMOUSEEVENT lpTME)
{
    TRACKMOUSEEVENT tme;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        tme = ProbeAndReadTrackMouseEvent(lpTME);

        if (tme.cbSize != sizeof(tme)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "TrackMouseEvent: invalid size %lX", tme.cbSize);
            MSGERROR(0);
        }

        TESTFLAGS(tme.dwFlags, TME_VALID);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (tme.dwFlags & TME_QUERY) {
        retval = QueryTrackMouseEvent(&tme);
        try {
            RtlCopyMemory(lpTME, &tme, sizeof(tme));
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    } else {
        retval = TrackMouseEvent(&tme);
    }

    TRACE("NtUserTrackMouseEvent");
    ENDRECV();
}

BOOL NtUserTrackPopupMenuEx(  // API TrackPopupMenuEx
    IN HMENU hMenu,
    IN UINT uFlags,
    IN int x,
    IN int y,
    IN HWND hwnd,
    IN CONST TPMPARAMS *pparamst OPTIONAL)
{
    PWND pwnd;
    PMENU pmenu;
    TL tlpwnd;
    TL tlpMenu;
    PTHREADINFO ptiCurrent;
    TPMPARAMS paramst;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(uFlags, TPM_VALID);

    ValidateHMENU(pmenu, hMenu);
    ValidateHWND(pwnd, hwnd);

    ptiCurrent = PtiCurrent();
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(pparamst)) {
            paramst = ProbeAndReadPopupParams(pparamst);
            pparamst = &paramst;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }
    retval = xxxTrackPopupMenuEx(
                pmenu,
                uFlags,
                x,
                y,
                pwnd,
                pparamst);

    CLEANUPRECV();

    ThreadUnlock(&tlpMenu);
    ThreadUnlock(&tlpwnd);

    TRACE("NtUserTrackPopupMenuEx");
    ENDRECV();
}

UINT NtUserPaintMenuBar(
    IN HWND hwnd,
    IN HDC hdc,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN DWORD dwFlags)
{
    BEGINRECV_HWNDLOCK(UINT, 0, hwnd);

    /*
     * This routine should only be called for top-level windows.
     */
    if (TestwndChild(pwnd)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    TESTFLAGS(dwFlags, PMB_VALID);

    if (iLeftOffset < 0 || iRightOffset < 0 || iTopOffset < 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    retval = xxxPaintMenuBar(pwnd, hdc, iLeftOffset, iRightOffset, iTopOffset, dwFlags);

    TRACE("NtUserPaintMenuBar");
    ENDRECV_HWNDLOCK();
}

UINT NtUserCalcMenuBar(
    IN HWND hwnd,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN LPCRECT prcWnd)
{
    RECT rcWnd;

    BEGINRECV_HWNDLOCK(UINT, 0, hwnd);

    if (iLeftOffset < 0 || iRightOffset < 0 || iTopOffset < 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    try {
        if (ARGUMENT_PRESENT(prcWnd)) {
            rcWnd = ProbeAndReadRect(prcWnd);
        } else {
            CopyRect(&rcWnd, &pwnd->rcWindow);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCalcMenuBar(pwnd, iLeftOffset, iRightOffset, iTopOffset, &rcWnd);

    TRACE("NtUserCalcMenuBar");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserTranslateMessage(  // API TranslateMessage
    IN CONST MSG *lpMsg,
    IN UINT flags)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage(lpMsg);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (ValidateHwnd(msg.hwnd) == NULL) {
        MSGERROR(0);
    }

    retval = xxxTranslateMessage(
            &msg,
            flags);

    TRACE("NtUserTranslateMessage");
    ENDRECV();
}

BOOL NtUserUnhookWindowsHookEx(
    IN HHOOK hhk)
{
    PHOOK phk;

    BEGINRECV(BOOL, FALSE);

    ValidateHHOOK(phk, hhk);

    retval = zzzUnhookWindowsHookEx(
            phk);

    TRACE("NtUserUnhookWindowsHookEx");
    ENDRECV();
}

BOOL NtUserUnregisterHotKey(
    IN HWND hwnd,
    IN int id)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _UnregisterHotKey(
            pwnd,
            id);

    TRACE("NtUserUnregisterHotKey");
    ENDATOMICRECV();
}

BOOL NtUserValidateRect(  // API ValidateRect
    IN HWND hwnd,
    IN CONST RECT *lpRect OPTIONAL)
{
    PWND pwnd;
    TL tlpwnd;
    RECT rc;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lpRect)) {
        try {
            rc = ProbeAndReadRect(lpRect);
            lpRect = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxValidateRect(pwnd, (PRECT)lpRect);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserValidateRect");
    ENDRECV();
}

DWORD NtUserWaitForInputIdle(
    IN ULONG_PTR idProcess,
    IN DWORD dwMilliseconds,
    IN BOOL fSharedWow)
{
    BEGINRECV(DWORD, (DWORD)-1);

    retval = xxxWaitForInputIdle(
            idProcess,
            dwMilliseconds,
            fSharedWow);

    TRACE("NtUserWaitForInputIdle");
    ENDRECV();
}

HWND NtUserWindowFromPoint(
    IN POINT Point)
{
    BEGINRECV(HWND, NULL);

    retval = (HWND)xxxWindowFromPoint(
            Point);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserWindowFromPoint");
    ENDRECV();
}

HDC NtUserBeginPaint(  // API BeginPaint
    IN HWND hwnd,
    OUT LPPAINTSTRUCT lpPaint)
{
    PAINTSTRUCT ps;

    BEGINRECV_HWNDLOCK(HDC, NULL, hwnd);

    retval = xxxBeginPaint(pwnd, &ps);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(lpPaint, ps, PAINTSTRUCT);
    } except (StubExceptionHandler(TRUE)) {
        xxxEndPaint(pwnd, &ps);
        MSGERROR(0);
    }

    TRACE("NtUserBeginPaint");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserCreateCaret(
    IN HWND hwnd,
    IN HBITMAP hBitmap,
    IN int nWidth,
    IN int nHeight)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxCreateCaret(pwnd, hBitmap, nWidth, nHeight);

    TRACE("NtUserCreateCaret");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserEndPaint(  // API EndPaint
    IN HWND hwnd,
    IN CONST PAINTSTRUCT *lpPaint)
{
    PAINTSTRUCT ps;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        ps = ProbeAndReadPaintStruct(lpPaint);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxEndPaint(pwnd, &ps);

    TRACE("NtUserEndPaint");
    ENDRECV_HWNDLOCK();
}

int NtUserExcludeUpdateRgn(
    IN HDC hdc,
    IN HWND hwnd)
{
    BEGINRECV_HWND(int, ERROR, hwnd);

    if (hdc == NULL)
        MSGERROR(0);

    retval = _ExcludeUpdateRgn(hdc, pwnd);

    TRACE("NtUserExcludeUpdateRgn");
    ENDRECV_HWND();
}

HDC NtUserGetDC(
    IN HWND hwnd)
{
    PWND pwnd;
    BOOL bValid = TRUE;

    BEGINATOMICRECV(HDC, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_HANDLES) && pwnd == NULL) {
        PDESKTOP pdesk = PtiCurrent()->rpdesk;

        /*
         * Make sure it has access to the desktop window.
         */
        if (!ValidateHwnd(PtoH(pdesk->pDeskInfo->spwnd))) {
            bValid = FALSE;
        }
    }

    retval = _GetDC(pwnd);

    if (!bValid) {
        HRGN hrgn = CreateEmptyRgn();

        /*
         * Select a NULL visible region on this DC so that restricted
         * processes don't mess with GetDC(NULL).
         */
        GreSelectVisRgn(retval, hrgn, SVR_DELETEOLD);
    }

    TRACE("NtUserGetDC");
    ENDATOMICRECV();
}

HDC NtUserGetDCEx(
    IN HWND hwnd,
    IN HRGN hrgnClip,
    IN DWORD flags)
{
    PWND pwnd;

    BEGINATOMICRECV(HDC, NULL);

    if ((hrgnClip && !GreIsValidRegion(hrgnClip)) || flags & ~DCX_MASK) {
        RIPMSG0(RIP_ERROR, "NtUserGetDCEx passed invalid parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    ValidateHWNDOPT(pwnd, hwnd);
    if (pwnd == NULL) {
        pwnd = PtiCurrent()->rpdesk->pDeskInfo->spwnd;

        if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_HANDLES)) {
            /*
             * Make sure it has access to the desktop window.
             */
            if (!ValidateHwnd(PtoH(pwnd))) {
                RIPMSG0(RIP_WARNING,
                        "NtUserGetDCEx fails desktop window validation");
                MSGERROR(0);
            }
        }
    }

    retval = _GetDCEx(pwnd, hrgnClip, flags);

    TRACE("NtUserGetDCEx");
    ENDATOMICRECV();
}

HDC NtUserGetWindowDC(
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINATOMICRECV(HDC, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _GetWindowDC(pwnd);

    TRACE("NtUserGetWindowDC");
    ENDATOMICRECV();
}

int NtUserGetUpdateRgn(
    IN HWND hwnd,
    IN HRGN hrgn,
    IN BOOL bErase)
{
    BEGINRECV_HWNDLOCK(int, ERROR, hwnd);

    retval = xxxGetUpdateRgn(
            pwnd,
            hrgn,
            bErase);

    TRACE("NtUserGetUpdateRgn");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserRedrawWindow(  // API RedrawWindow
    IN HWND hwnd,
    IN CONST RECT *lprcUpdate OPTIONAL,
    IN HRGN hrgnUpdate,
    IN UINT flags)
{
    RECT rc;

    BEGINRECV_HWNDLOCK_OPT(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lprcUpdate)) {
        try {
            rc = ProbeAndReadRect(lprcUpdate);
            lprcUpdate = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TESTFLAGS(flags, RDW_VALIDMASK);

    retval = xxxRedrawWindow(
            pwnd,
            (PRECT)lprcUpdate,
            hrgnUpdate,
            flags);

    TRACE("NtUserRedrawWindow");
    ENDRECV_HWNDLOCK_OPT();
}

BOOL NtUserInvalidateRgn(
    IN HWND hwnd,
    IN HRGN hrgn,
    IN BOOL bErase)
{
    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    retval = xxxInvalidateRgn(
            pwnd,
            hrgn,
            bErase);

    TRACE("NtUserInvalidateRgn");
    ENDRECV_HWNDLOCK();
}

int NtUserSetWindowRgn(
    IN HWND hwnd,
    IN HRGN hrgn,
    IN BOOL bRedraw)
{
    BEGINRECV_HWNDLOCK_ND(int, 0, hwnd);

    retval = xxxSetWindowRgn(
            pwndND,
            hrgn,
            bRedraw);

    TRACE("NtUserSetWindowRgn");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserScrollDC(  // API ScrollDC
    IN HDC hdc,
    IN int dx,
    IN int dy,
    IN CONST RECT *prcScroll OPTIONAL,
    IN CONST RECT *prcClip OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT prcUpdate OPTIONAL)
{
    RECT rcScroll;
    RECT rcClip;
    RECT rcUpdate;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(prcScroll)) {
            rcScroll = ProbeAndReadRect(prcScroll);
            prcScroll = &rcScroll;
        }
        if (ARGUMENT_PRESENT(prcClip)) {
            rcClip = ProbeAndReadRect(prcClip);
            prcClip = &rcClip;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    retval = _ScrollDC(
                hdc,
                dx,
                dy,
                (PRECT)prcScroll,
                (PRECT)prcClip,
                hrgnUpdate,
                prcUpdate ? &rcUpdate : NULL);

    if (ARGUMENT_PRESENT(prcUpdate)) {
        try {
            ProbeAndWriteStructure(prcUpdate, rcUpdate, RECT);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }
    ENDRECV();
}

int NtUserInternalGetWindowText(  // private InternalGetWindowText
    IN HWND hwnd,
    OUT LPWSTR lpString,
    IN int nMaxCount)
{
    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    if (nMaxCount) {
        /*
         * Probe arguments
         */
        try {
            ProbeForWriteBuffer(lpString, nMaxCount, CHARALIGN);
           /*
            * Initialize string empty.
            */
            *lpString = TEXT('\0');
            if (pwnd->strName.Length) {
                retval = TextCopy(&pwnd->strName, lpString, nMaxCount);
            } else {
                retval = 0;
            }
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0); // private API, don't SetLastError
        }
    } else {
        MSGERROR(0);
    }

    TRACE("NtUserInternalGetWindowText");
    ENDRECV_HWND_SHARED();
}

int NtUserGetMouseMovePointsEx(  // API GetMouseMovePointsEx
    IN UINT             cbSize,
    IN CONST MOUSEMOVEPOINT *lppt,
    OUT MOUSEMOVEPOINT *lpptBuf,
    IN UINT             nBufPoints,
    IN DWORD            resolution)
{
    MOUSEMOVEPOINT mmp;
    BEGINRECV(int, -1);

    if (cbSize != sizeof(MOUSEMOVEPOINT) || nBufPoints > MAX_MOUSEPOINTS) {

        RIPERR2(ERROR_INVALID_PARAMETER, RIP_VERBOSE,
                "GetMouseMovePointsEx: invalid cbSize %d or nBufPoints %d",
                cbSize, nBufPoints);
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        mmp = ProbeAndReadStructure(lppt, MOUSEMOVEPOINT);
        ProbeForWriteBuffer(lpptBuf, nBufPoints, DATAALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * GetMouseMovePointsEx protects itself with a try block.
     * No it doesn't!
     */

    retval = _GetMouseMovePointsEx(&mmp, lpptBuf, nBufPoints, resolution);

    TRACE("NtUserGetMouseMovePointsEx");
    ENDRECV();
}

int NtUserToUnicodeEx(  // API ToUnicode/ToUnicodeEx/ToAscii/ToAsciiEx
    IN UINT wVirtKey,
    IN UINT wScanCode,
    IN CONST BYTE *lpKeyState,
    OUT LPWSTR pwszBuff,
    IN int cchBuff,
    IN UINT wFlags,
    IN HKL hKeyboardLayout)
{
    BYTE KeyState[256];
    WCHAR wcBuff[4];
    LPWSTR pwszBuffK;
    BOOL bAlloc = FALSE;
    PTHREADINFO ptiCurrent;
    TL tlInput;

    BEGINRECV(int, 0);

    if (cchBuff <= 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(lpKeyState, 256, sizeof(BYTE));
        RtlCopyMemory(KeyState, lpKeyState, 256);
        ProbeForWriteBuffer(pwszBuff, cchBuff, CHARALIGN);
        if (cchBuff < 4) {
            pwszBuffK = wcBuff;
        }else {
            pwszBuffK = UserAllocPoolWithQuota(cchBuff * sizeof(WCHAR), TAG_UNICODEBUFFER);
            if (pwszBuffK == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            bAlloc = TRUE;
            ptiCurrent = PtiCurrent();
            ThreadLockPool(ptiCurrent, pwszBuffK, &tlInput);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxToUnicodeEx(
                wVirtKey,
                wScanCode,
                KeyState,
                pwszBuffK,
                cchBuff,
                wFlags,
                hKeyboardLayout);

    try {
        RtlCopyMemory(pwszBuff, pwszBuffK, cchBuff*sizeof(WCHAR));
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    if (bAlloc) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlInput);
    }

    TRACE("NtUserToUnicodeEx");
    ENDRECV();
}

BOOL NtUserYieldTask(
    VOID)
{
    PTHREADINFO ptiCurrent;
    BOOL bBackground;

    BEGINRECV(BOOL, FALSE);

    /*
     * Make sure this process is running in the background if it is just
     * spinning.
     */
    ptiCurrent = PtiCurrent();
    try {
        ptiCurrent->pClientInfo->cSpins++;
        bBackground = ptiCurrent->pClientInfo->cSpins >= CSPINBACKGROUND;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * CheckProcessBackground see input.c for comments
     */
    if (bBackground) {
        try {
            ptiCurrent->pClientInfo->cSpins = 0;
            ptiCurrent->pClientInfo->dwTIFlags |= TIF_SPINNING;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        ptiCurrent->TIF_flags |= TIF_SPINNING;

        if (!(ptiCurrent->ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY)) {
            ptiCurrent->ppi->W32PF_Flags |= W32PF_FORCEBACKGROUNDPRIORITY;
            if (ptiCurrent->ppi == gppiWantForegroundPriority) {
                SetForegroundPriority(ptiCurrent, FALSE);
            }
        }
    }

    retval = xxxUserYield(ptiCurrent);

    TRACE("NtUserYieldTask");
    ENDRECV();
}

BOOL NtUserWaitMessage(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxWaitMessage();

    TRACE("NtUserWaitMessage");
    ENDRECV();
}


#ifdef MESSAGE_PUMP_HOOK

BOOL NtUserRealWaitMessageEx(
    IN UINT fsWakeMask,
    IN DWORD Timeout)
{
    BEGINRECV(BOOL, FALSE);
    TESTFLAGS(fsWakeMask, QS_VALID);

    if (!IsInsideMPH()) {
        RIPMSG0(RIP_WARNING, "NtUserRealWaitMessageEx: Calling MPH function on non-initialized thread");
    }

    retval = xxxRealWaitMessageEx(fsWakeMask, Timeout);

    TRACE("NtUserRealWaitMessage");
    ENDRECV();
}

#endif // MESSAGE_PUMP_HOOK


UINT NtUserLockWindowStation(
    IN HWINSTA hwinsta)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    BEGINRECV(UINT, 0);

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (!NT_SUCCESS(Status))
        MSGERROR(0);

    retval = _LockWindowStation(pwinsta);

    ObDereferenceObject(pwinsta);

    TRACE("NtUserLockWindowStation");
    ENDRECV();
}

BOOL NtUserUnlockWindowStation(
    IN HWINSTA hwinsta)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (!NT_SUCCESS(Status))
        MSGERROR(0);

    retval = _UnlockWindowStation(pwinsta);

    ObDereferenceObject(pwinsta);

    TRACE("NtUserUnlockWindowStation");
    ENDRECV();
}

UINT NtUserSetWindowStationUser(  // private SetWindowStationUser
    IN HWINSTA hwinsta,
    IN PLUID pLuidUser,
    IN PSID pSidUser OPTIONAL,
    IN DWORD cbSidUser)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;
    LUID luid;
    BEGINATOMICRECV(UINT, FALSE);

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (!NT_SUCCESS(Status))
        MSGERROR(0);

    try {
        ProbeForRead(pLuidUser, sizeof(*pLuidUser), sizeof(DWORD));
        luid = *pLuidUser;
        if (ARGUMENT_PRESENT(pSidUser)) {
            ProbeForRead(pSidUser, cbSidUser, sizeof(DWORD));
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);  // don't SetLastError for private API
    }

    /*
     * SetWindowStationUser uses pSidUser in a try block.
     */

    retval = _SetWindowStationUser(pwinsta, &luid, pSidUser, cbSidUser);

    CLEANUPRECV();

    ObDereferenceObject(pwinsta);

    TRACE("NtUserSetWindowStationUser");
    ENDATOMICRECV();
}

BOOL NtUserSetLogonNotifyWindow(
    IN HWND hwnd)
{
    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    retval = _SetLogonNotifyWindow(pwnd);

    TRACE("NtUserSetLogonNotifyWindow");
    ENDRECV_HWND();
}

BOOL NtUserSetSystemCursor(
    IN HCURSOR hcur,
    IN DWORD id)
{
    PCURSOR pcur;

    BEGINRECV(BOOL, FALSE);

    ValidateHCURSOR(pcur, hcur);

    retval = zzzSetSystemCursor(pcur, id);

    TRACE("NtUserSetSystemCursor");
    ENDRECV();
}

HCURSOR NtUserGetCursorFrameInfo(  // private GetCursorFrameInfo (Obsolete? - IanJa)
    IN HCURSOR hcur,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur)
{
    PCURSOR pcur, pcurRet;
    DWORD jifRate;
    INT ccur;

    BEGINRECV_SHARED(HCURSOR, NULL);

    ValidateHCURSOR(pcur, hcur);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteUlong(pjifRate);
        ProbeForWriteLong(pccur);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);  // don't SetLastError for private API
    }

    pcurRet = _GetCursorFrameInfo(
                pcur,
                iFrame,
                &jifRate,
                &ccur);
    if (pcurRet != NULL) {
        retval = PtoH(pcurRet);
        try {
            *pjifRate = jifRate;
            *pccur = ccur;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);  // don't SetLastError for private API
        }
    } else {
        retval = NULL;
    }

    TRACE("NtUserGetCursorFrameInfo");
    ENDRECV_SHARED();
}

BOOL NtUserSetCursorContents(
    IN HCURSOR hCursor,
    IN HCURSOR hCursorNew)
{
    PCURSOR pCursor;
    PCURSOR pCursorNew;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHCURSOR(pCursor, hCursor);
    ValidateHCURSOR(pCursorNew, hCursorNew);

    retval = _SetCursorContents(pCursor, pCursorNew);

    TRACE("NtUserSetCursorContents");
    ENDATOMICRECV();
}

HCURSOR NtUserFindExistingCursorIcon(  // Various Icon/Cursor APIs
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORFIND     pcfSearch)
{
    ATOM           atomModName;
    UNICODE_STRING strModName;
    UNICODE_STRING strResName;
    PCURSOR        pcurSrc;
    CURSORFIND     cfSearch;

    BEGINRECV_SHARED(HCURSOR, NULL);

    /*
     * Probe arguments
     */
    try {

        cfSearch = ProbeAndReadCursorFind(pcfSearch);

        ValidateHCURSOROPT(pcurSrc, cfSearch.hcur);

        strModName = ProbeAndReadUnicodeString(pstrModName);
        ProbeForReadUnicodeStringBuffer(strModName);

        strResName = ProbeAndReadUnicodeString(pstrResName);
        ProbeForReadUnicodeStringBufferOrId(strResName);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The ModName buffer is client-side, but UserFindAtom protects
     * access.
     */

    atomModName = UserFindAtom(strModName.Buffer);

    if (atomModName) {

        /*
         * The ResName buffer is client-side. FindExistincCursorIcon
         * protects access.
         */
        retval = (HCURSOR)_FindExistingCursorIcon(atomModName,
                                                  &strResName,
                                                  pcurSrc,
                                                  &cfSearch);

        retval = (HCURSOR)PtoH((PCURSOR)retval);

    } else {

        retval = 0;
    }


    TRACE("NtUserFindExistingCursorIcon");
    ENDRECV_SHARED();
}

BOOL NtUserSetCursorIconData(  // worker called by CreateIcon, CreateCursor etc.
    IN HCURSOR         hCursor,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORDATA     pData)
{
    UNICODE_STRING strModName;
    UNICODE_STRING strResName;
    PCURSOR        pCursor;
    CURSORDATA     curData;
    DWORD          cbData;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHCURSOR(pCursor, hCursor);

    /*
     * Probe arguments
     */
    try {

        strModName = ProbeAndReadUnicodeString(pstrModName);
        strResName = ProbeAndReadUnicodeString(pstrResName);

        ProbeForReadUnicodeStringBuffer(strModName);
        ProbeForReadUnicodeStringBufferOrId(strResName);

        curData = ProbeAndReadCursorData(pData);

        if (curData.CURSORF_flags & CURSORF_ACON) {
            /*
             * Avoid overflow here, or we might end up probing less.
             * MCostea #199188
             */
            if (HIWORD(curData.cpcur) | HIWORD(curData.cicur)) {
                MSGERROR(0);
            }

            /*
             * The code assumes that the memory was allocated in one chunk
             * as in CreateAniIcon(). To prevent evil apps, do this check.
             */
            if ((INT_PTR)curData.ajifRate != curData.cpcur * (INT_PTR) sizeof(HCURSOR) ||
                (INT_PTR)curData.aicur != (INT_PTR)curData.ajifRate + curData.cicur * (INT_PTR) sizeof(JIF)) {
                MSGERROR(0);
            }
            cbData = (curData.cpcur * sizeof(HCURSOR)) +
                     (curData.cicur * sizeof(JIF)) +
                     (curData.cicur * sizeof(DWORD));

        } else {
            cbData = 0;
        }
        ProbeForRead(curData.aspcur, cbData, sizeof(DWORD));

    } except (StubExceptionHandler(FALSE)) {
        /*
         * Probed parameters are USER stack variables, not supplied by the
         * application itself, so don't bother to SetLastError.
         */
        MSGERROR(0);
    }

    /*
     * SetCursorIconData guards use of the buffer addresses with try clauses.
     */
    retval = _SetCursorIconData(pCursor,
                                    &strModName,
                                    &strResName,
                                    &curData,
                                    cbData);

    TRACE("NtUserSetCursorIconData");
    ENDATOMICRECV();
}

BOOL NtUserGetMenuItemRect(  // API GetMenuItemRect
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uItem,
    OUT LPRECT lprcItem)
{
    PMENU pmenu;
    TL tlpMenu;
    RECT rcItem;

    BEGINRECV_HWNDLOCK_OPT(DWORD, 0, hwnd);

    ValidateHMENU(pmenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxGetMenuItemRect(
                pwnd,
                pmenu,
                uItem,
                &rcItem);
    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(lprcItem, rcItem, RECT);
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserGetMenuItemRect");
    ENDRECV_HWNDLOCK_OPT();
}

int NtUserMenuItemFromPoint(  // API MenuItemFromPoint
    IN HWND hwnd,
    IN HMENU hMenu,
    IN POINT ptScreen)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV_HWNDLOCK_OPT(DWORD, -1, hwnd);

    ValidateHMENU(pmenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxMenuItemFromPoint(
            pwnd,
            pmenu,
            ptScreen);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserMenuItemFromPoint");
    ENDRECV_HWNDLOCK_OPT();
}

BOOL NtUserGetCaretPos(  // API GetCaretPos
    OUT LPPOINT lpPoint)
{
    PTHREADINFO pti;
    PQ pq;
    BEGINRECV_SHARED(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForWritePoint(lpPoint);

        pti = PtiCurrentShared();
        pq = pti->pq;
        lpPoint->x = pq->caret.x;
        lpPoint->y = pq->caret.y;
        retval = TRUE;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetCaretPos");
    ENDRECV_SHARED();
}

BOOL NtUserDefSetText(
    IN HWND hwnd,
    IN PLARGE_STRING pstrText OPTIONAL)
{
    LARGE_STRING strText;

    BEGINRECV_HWND(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(pstrText)) {
        try {
            strText = ProbeAndReadLargeString(pstrText);
#if defined(_X86_)
            ProbeForRead(strText.Buffer, strText.Length, sizeof(BYTE));
#else
            ProbeForRead(strText.Buffer, strText.Length,
                    strText.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
            pstrText = &strText;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);  // WM_SETTEXT lParam
        }
    }

    /*
     * pstrText buffer is client side. DefSetText protects uses of the buffer.
     */
    retval = DefSetText(
            pwnd,
            pstrText);

    TRACE("NtUserDefSetText");
    ENDRECV_HWND();
}

NTSTATUS NtUserQueryInformationThread(
    IN     HANDLE hThread,
    IN     USERTHREADINFOCLASS ThreadInfoClass,
    IN OUT PVOID ThreadInformation,
    IN     ULONG ThreadInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL)
{
    ULONG       uReturnLength;
    TL          tlBuffer;
    PTHREADINFO ptiCurrent;
    union {
        USERTHREAD_SHUTDOWN_INFORMATION ThreadShutdownInformation;
        DWORD                           dwThreadInfo;
        WCHAR                           szThreadTaskName[32];
        USERTHREAD_WOW_INFORMATION      UserThreadWowInformation;
    } ThreadInformationUnion;
    PVOID pThreadInformation = NULL;

    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    ptiCurrent = PtiCurrent();

    /*
     * Probe all arguments.  Try block necessary even with CSRSS as
     * the calling process because it can incurr an in-page exception.
     */
    try {
        if (ARGUMENT_PRESENT(ThreadInformation)) {
            ProbeForRead(ThreadInformation, ThreadInformationLength, sizeof(WCHAR));
            if (ThreadInformationLength > sizeof(ThreadInformationUnion)) {
                pThreadInformation = UserAllocPoolWithQuota(ThreadInformationLength, TAG_SYSTEM);
                if (pThreadInformation) {
                    ThreadLockPool(ptiCurrent, pThreadInformation, &tlBuffer);
                } else {
                    ExRaiseStatus(STATUS_NO_MEMORY);
                }
            } else {
                pThreadInformation = &ThreadInformationUnion;
            }
            RtlCopyMemory(pThreadInformation, ThreadInformation, ThreadInformationLength);
        } else {
            pThreadInformation = NULL;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxQueryInformationThread(
                 hThread,
                 ThreadInfoClass,
                 pThreadInformation,
                 ThreadInformationLength,
                 (ARGUMENT_PRESENT(ReturnLength))? &uReturnLength: NULL);

    try {
        if (ARGUMENT_PRESENT(ThreadInformation)) {
            ProbeForWrite(ThreadInformation, ThreadInformationLength, sizeof(WCHAR));
            RtlCopyMemory(ThreadInformation, pThreadInformation, ThreadInformationLength);
        }
        if (ARGUMENT_PRESENT(ReturnLength)) {
            ProbeForWrite(ReturnLength, sizeof(ULONG), sizeof(ULONG));
            RtlCopyMemory(ReturnLength, &uReturnLength, sizeof(ULONG));
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    if ((pThreadInformation != &ThreadInformationUnion) && pThreadInformation) {
        ASSERT(ThreadInformationLength > sizeof(ThreadInformationUnion));
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    }

    TRACE("NtUserQueryInformationThread");
    ENDRECVCSRSS();
}

NTSTATUS NtUserSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength)
{
    union {
        USERTHREAD_FLAGS          UserThread_Flags;
        DWORD                     dwThreadInfo;
        NTSTATUS                  Status;
        USERTHREAD_USEDESKTOPINFO UserThreadDesktopInfo;
        HANDLE                    handle;
    } ThreadInformationUnion;
    PVOID pThreadInformation = &ThreadInformationUnion;

    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (ThreadInformationLength > sizeof(ThreadInformationUnion)) {
        FRE_RIPMSG2(
            RIP_ERROR,
            "ThreadInformationLength: %x is greater than union size: %x.",
            ThreadInformationLength,
            sizeof(ThreadInformationUnion));
    }

    /*
     * Probe read arguments.  Try block necessary even with CSRSS as
     * the calling process because it can incurr an in-page exception.
     */
    try {
        if (ARGUMENT_PRESENT(ThreadInformation)) {
            ProbeForRead(ThreadInformation, ThreadInformationLength, sizeof(DWORD));
            RtlCopyMemory(pThreadInformation, ThreadInformation, ThreadInformationLength);
        } else {
            pThreadInformation = NULL;
        }
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    retval = xxxSetInformationThread(
                 hThread,
                 ThreadInfoClass,
                 pThreadInformation,
                 ThreadInformationLength);

    try {
        if (ARGUMENT_PRESENT(ThreadInformation)) {
            ProbeForWrite(ThreadInformation, ThreadInformationLength, sizeof(DWORD));
            RtlCopyMemory(ThreadInformation, pThreadInformation, ThreadInformationLength);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserSetInformationThread");
    ENDRECVCSRSS();
}

NTSTATUS NtUserSetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID pProcessInformation,
    IN ULONG ProcessInformationLength)
{
    USERTHREAD_FLAGS ProcessInformation;
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe read arguments.  Try block necessary even with CSRSS as
     * the calling process because it can incurr an in-page exception.
     */
    try {
        if (ARGUMENT_PRESENT(pProcessInformation)) {
            ProbeForRead(pProcessInformation, ProcessInformationLength, sizeof(DWORD));
            RtlCopyMemory(&ProcessInformation, pProcessInformation, ProcessInformationLength);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = SetInformationProcess(
                 hProcess,
                 ProcessInfoClass,
                 ARGUMENT_PRESENT(pProcessInformation) ? &ProcessInformation : NULL,
                 ProcessInformationLength);

    TRACE("NtUserSetInformationProcess");
    ENDRECVCSRSS();
}

BOOL NtUserNotifyProcessCreate(
    IN DWORD dwProcessId,
    IN DWORD dwParentThreadId,
    IN ULONG_PTR dwData,
    IN DWORD dwFlags)
{
    extern BOOL xxxUserNotifyProcessCreate(
                    DWORD idProcess,
                    DWORD idParentThread,
                    ULONG_PTR dwData,
                    DWORD dwFlags);

    BEGINRECVCSRSS(BOOL, FALSE);

    retval = xxxUserNotifyProcessCreate(
                 dwProcessId,
                 dwParentThreadId,
                 dwData,            // Static value not a ptr.  No probing needed.
                 dwFlags);

    TRACE("NtUserNotifyProcessCreate");
    ENDRECVCSRSS();
}

NTSTATUS NtUserSoundSentry(VOID)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    retval = (_UserSoundSentryWorker() ?
            STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

    TRACE("NtUserSoundSentry");
    ENDRECV();
}

NTSTATUS NtUserTestForInteractiveUser(  // private _UserTestTokenForInteractive
    IN PLUID pluidCaller)
{
    LUID luidCaller;

    BEGINRECV_SHARED(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe arguments
     */
    try {
        luidCaller = ProbeAndReadStructure(pluidCaller, LUID);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = TestForInteractiveUser(&luidCaller);

    TRACE("NtUserTestForInteractiveUser");
    ENDRECV_SHARED();
}

BOOL NtUserSetConsoleReserveKeys(
    IN HWND hwnd,
    IN DWORD fsReserveKeys)
{
    BOOL _SetConsoleReserveKeys(PWND, DWORD);

    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    retval = _SetConsoleReserveKeys(pwnd, fsReserveKeys);

    TRACE("NtUserSetConsoleReserveKeys");
    ENDRECV_HWND();
}

VOID NtUserModifyUserStartupInfoFlags(
    IN DWORD dwMask,
    IN DWORD dwFlags)
{
    BEGINRECV_VOID();

    PpiCurrent()->usi.dwFlags = (PpiCurrent()->usi.dwFlags & ~dwMask) | (dwFlags & dwMask);

    TRACEVOID("NtUserModifyUserStartupInfoFlags");
    ENDRECV_VOID();
}

BOOL NtUserSetWindowFNID(
    IN HWND hwnd,
    IN WORD fnid)
{
    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    /*
     * Don't let apps mess with windows on other processes.
     */
    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        MSGERROR(0);
    }

    /*
     * Make sure the fnid is in the correct range.
     */
    if (fnid != FNID_CLEANEDUP_BIT) {
        if ((fnid < FNID_CONTROLSTART) || (fnid > FNID_CONTROLEND) || (GETFNID(pwnd) != 0)) {
            MSGERROR(0);
        }
    }

    /*
     * Remember what window class this window belongs to. Can't use
     * the real class because any app can call CallWindowProc()
     * directly no matter what the class is!
     */
    pwnd->fnid |= fnid;
    retval = TRUE;

    TRACE("NtUserSetWindowFNID");
    ENDRECV_HWND();
}

#define AWS_MASK (BS_TYPEMASK | BS_RIGHT | BS_RIGHTBUTTON | \
        WS_HSCROLL | WS_VSCROLL | SS_TYPEMASK)

VOID NtUserAlterWindowStyle(
    IN HWND hwnd,
    IN DWORD mask,
    IN DWORD flags)
{
    BEGINRECV_HWND_VOID(hwnd);

    if (GETPTI(pwnd)->ppi == PpiCurrent()) {

        if (mask & ~AWS_MASK) {
            RIPMSGF1(RIP_WARNING, "Bad mask 0x%x", mask);
        }

        mask &= AWS_MASK;
        pwnd->style = (pwnd->style & (~mask)) | (flags & mask);
    } else {
        RIPMSGF1(RIP_WARNING, "Current ppi doesn't own pwnd 0x%p", pwnd);
    }

    TRACEVOID("NtUserAlterWindowStyle");
    ENDRECV_HWND_VOID();
}

VOID NtUserSetThreadState(
    IN DWORD dwFlags,
    IN DWORD dwMask)
{
    PTHREADINFO ptiCurrent;
    DWORD dwOldFlags;

    if (dwFlags & ~(QF_DIALOGACTIVE)) {
        return;
    }

    BEGINRECV_VOID();

    ptiCurrent = PtiCurrent();
    dwOldFlags = ptiCurrent->pq->QF_flags;
    ptiCurrent->pq->QF_flags ^= ((dwOldFlags ^ dwFlags) & dwMask);

    TRACEVOID("NtUserSetThreadState");
    ENDRECV_VOID();
}


ULONG_PTR NtUserGetThreadState(
    IN USERTHREADSTATECLASS ThreadState)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    BEGINRECV_SHARED(ULONG_PTR, 0);

    switch (ThreadState) {
    case UserThreadStateFocusWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->pq->spwndFocus);
        break;
    case UserThreadStateActiveWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->pq->spwndActive);
        break;
    case UserThreadStateCaptureWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->pq->spwndCapture);
        break;
    case UserThreadStateDefaultImeWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->spwndDefaultIme);
        break;
    case UserThreadStateDefaultInputContext:
        retval = (ULONG_PTR)PtoH(ptiCurrent->spDefaultImc);
        break;
    case UserThreadStateImeCompatFlags:
        UserAssert(ptiCurrent->ppi != NULL);
        retval = (DWORD)(ptiCurrent->ppi->dwImeCompatFlags);
        break;
    case UserThreadStatePreviousKeyboardLayout:
        retval = (ULONG_PTR)(ptiCurrent->hklPrev);
        break;
#ifdef OBSOLETE
    case UserThreadStateIsWinlogonThread:
        /*
         * This is no longer supported, for the securty breach bug.
         * The enum value is kept for the Wow16 compatibility.
         */
#endif

    case UserThreadStateNeedsSecurity:
        /*
         * Client IMM checks if the process is winlogon to prevent switching
         * dictionaries, etc. Also, we need to check the secure desktop, for
         * some accessibility applications run on the secure desktop.
         */
        retval = (PsGetCurrentProcessId() == gpidLogon) || (ptiCurrent->rpdesk == grpdeskLogon);

        if (ptiCurrent->rpdesk == grpdeskLogon) {
            RIPMSG2(RIP_WARNING,
                    "Thread 0x%p is running on the secure desktop %p",
                    ptiCurrent,
                    grpdeskLogon);
        }

        break;
    case UserThreadStateIsConImeThread:
        UserAssert(ptiCurrent->rpdesk != NULL);
        retval = (DWORD)(PtiFromThreadId(ptiCurrent->rpdesk->dwConsoleIMEThreadId) == ptiCurrent);
        break;
    case UserThreadStateInputState:
        retval = (DWORD)_GetInputState();
        break;
    case UserThreadStateCursor:
        retval = (ULONG_PTR)PtoH(ptiCurrent->pq->spcurCurrent);
        break;
    case UserThreadStateChangeBits:
        retval = ptiCurrent->pcti->fsChangeBits;
        break;
    case UserThreadStatePeekMessage:
        /*
         * Update the last read time so that hung app painting won't occur.
         */
        SET_TIME_LAST_READ(ptiCurrent);
        retval = (DWORD)FALSE;
        break;
    case UserThreadStateExtraInfo:
        retval = ptiCurrent->pq->ExtraInfo;
        break;

    case UserThreadStateInSendMessage:
        if (ptiCurrent->psmsCurrent != NULL) {
            if (ptiCurrent->psmsCurrent->ptiSender != NULL) {
                retval = ISMEX_SEND;
            } else if (ptiCurrent->psmsCurrent->flags & (SMF_CB_REQUEST | SMF_CB_REPLY)) {
                retval = ISMEX_CALLBACK;
            } else {
                retval = ISMEX_NOTIFY;
            }

            if (ptiCurrent->psmsCurrent->flags & SMF_REPLY) {
                retval |= ISMEX_REPLIED;
            }
        } else {
            retval = ISMEX_NOSEND;
        }
        break;

    case UserThreadStateMessageTime:
        retval = ptiCurrent->timeLast;
        break;
    case UserThreadStateIsForeground:
        retval = (ptiCurrent->pq == gpqForeground);
        break;
    case UserThreadConnect:
        retval = TRUE;
        break;
    default:
        RIPMSG1(RIP_WARNING, "NtUserGetThreadState invalid ThreadState:%#x", ThreadState);
        MSGERROR(0);
    }

    ENDRECV_SHARED();
}

BOOL NtUserValidateHandleSecure(
    IN HANDLE h)
{
    BEGINRECV(BOOL, FALSE);

    retval = ValidateHandleSecure(h);

    TRACE("NtUserValidateHandleSecure");
    ENDRECV();
}

BOOL NtUserUserHandleGrantAccess( // API UserHandleGrantAccess
    IN HANDLE hUserHandle,
    IN HANDLE hJob,
    IN BOOL   bGrant)
{
    NTSTATUS  Status;
    PEJOB     Job;
    PW32JOB   pW32Job;
    DWORD     dw;
    PHE       phe;
    PULONG_PTR pgh;
    BOOL      retval;
    BOOL      errret = FALSE;

    Status = ObReferenceObjectByHandle(
                    hJob,
                    JOB_OBJECT_SET_ATTRIBUTES,
                    *PsJobType,
                    UserMode,
                    (PVOID*)&Job,
                    NULL);

    if (!NT_SUCCESS(Status)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "UserHandleGrantAccess: Invalid job handle 0x%p",
                hJob);
        return FALSE;
    }

    /*
     * Acquire the job's lock and enter the user critical section.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(PsGetJobLock(Job), TRUE);

    EnterCrit();

    /*
     * Bail out if it doesn't have UI restrictions.
     */
    if (PsGetJobUIRestrictionsClass(Job) == 0) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "UserHandleGrantAccess: job 0x%p doesn't have UI restrictions",
                hJob);
        MSGERRORCLEANUP(0);
    }

    /*
     * see if we have a W32JOB structure created for this job
     */
    pW32Job = gpJobsList;

    while (pW32Job) {
        if (pW32Job->Job == Job) {
            break;
        }
        pW32Job = pW32Job->pNext;
    }

    UserAssert(pW32Job != NULL);

    try {
        /*
         * Now, validate the 'unsecure' handle.
         */
        if (HMValidateHandle(hUserHandle, TYPE_GENERIC) == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "UserHandleGrantAccess: invalid handle 0x%p",
                    hUserHandle);

            MSGERRORCLEANUP(0);
        }

        dw = HMIndexFromHandle(hUserHandle);

        phe = &gSharedInfo.aheList[dw];

        phe->bFlags |= HANDLEF_GRANTED;

        pgh = pW32Job->pgh;

        if (bGrant) {
            /*
             * Add the handle to the process' list
             */
            if (pW32Job->ughCrt == pW32Job->ughMax) {

                if (pW32Job->ughCrt == 0) {
                    pgh = UserAllocPool(GH_SIZE * sizeof(*pgh), TAG_GRANTEDHANDLES);
                } else {
                    /*
                     * we need to grow the array
                     */
                    DWORD uBytes = (pW32Job->ughMax) * sizeof(*pgh);

                    pgh = UserReAllocPool(pgh,
                                          uBytes,
                                          uBytes + GH_SIZE * sizeof(*pgh),
                                          TAG_GRANTEDHANDLES);
                }

                if (pgh == NULL) {
                    MSGERRORCLEANUP(ERROR_NOT_ENOUGH_MEMORY);
                }

                pW32Job->pgh     = pgh;
                pW32Job->ughMax += GH_SIZE;
            }

            UserAssert(pW32Job->ughCrt < pW32Job->ughMax);

            /*
             * see if the handle is not already granted to this process
             */
            for (dw = 0; dw < pW32Job->ughCrt; dw++) {
                if (*(pgh + dw) == (ULONG_PTR)hUserHandle) {
                    break;
                }
            }

            if (dw >= pW32Job->ughCrt) {

                /*
                 * add the handle to the granted handles table
                 */
                *(pgh + pW32Job->ughCrt) = (ULONG_PTR)hUserHandle;

                (pW32Job->ughCrt)++;
            }
        } else {
            /*
             * Remove the handle from the granted list
             */
            /*
             * search for the handle in the array.
             */
            for (dw = 0; dw < pW32Job->ughCrt; dw++) {
                if (*(pgh + dw) == (ULONG_PTR)hUserHandle) {

                    /*
                     * found the handle granted to this process
                     */
                    RtlMoveMemory(pgh + dw,
                                  pgh + dw + 1,
                                  (pW32Job->ughCrt - dw - 1) * sizeof(*pgh));

                    (pW32Job->ughCrt)--;
                    break;
                }
            }
#if DBG
            if (dw >= pW32Job->ughCrt) {
                RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING,
                        "UserHandleGrantAccess(FALSE): handle not found %#p",
                        hUserHandle);
            }
#endif // DBG
        }

        retval = TRUE;

    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    LeaveCrit();
    ExReleaseResourceLite(PsGetJobLock(Job));
    KeLeaveCriticalRegion();
    ObDereferenceObject(Job);

    TRACE("NtUserUserHandleGrantAccess");

    return retval;
}

HWND NtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrNVClassName,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags,
    IN PACTIVATION_CONTEXT pActCtx)
{
    LARGE_STRING strNVClassName;
    LARGE_STRING strClassName;
    LARGE_STRING strWindowName;
    PWND pwndParent;
    PMENU pmenu;
    TL tlpwndParent;
    TL tlpMenu;
    BOOL fLockMenu = FALSE;
    PTHREADINFO ptiCurrent;

    BEGINRECV(HWND, NULL);

    if (hwndParent != HWND_MESSAGE) {
        ValidateHWNDOPT(pwndParent, hwndParent);
    } else {
        pwndParent = _GetMessageWindow();
    }

    /*
     * Win3.1 only checks for WS_CHILD before treating pmenu as an id. This
     * is a bug, because throughout the code, the real check is TestwndChild(),
     * which checks (style & (WS_CHILD | WS_POPUP)) == WS_CHILD. This is
     * because old style "iconic popup" is WS_CHILD | WS_POPUP. So... if on
     * win3.1 an app used ws_iconicpopup, menu validation would not occur
     * (could crash if hmenu != NULL). On Win32, check for the real thing -
     * but allow NULL!
     */
    ptiCurrent = PtiCurrent();
    if (((dwStyle & (WS_CHILD | WS_POPUP)) != WS_CHILD) &&
            (hmenu != NULL)) {
        ValidateHMENU(pmenu, hmenu);

        ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);
        fLockMenu = TRUE;

    } else {
        pmenu = (PMENU)hmenu;
    }

    /*
     * Mask out the new 5.0 extended style bits for apps
     * that would try to use them and we'll fail in xxxCreateWindowEx
     */
    if (GetAppCompatFlags2(VER40) & GACF2_NO50EXSTYLEBITSCW) {

#if DBG
        if (dwExStyle & ~(WS_EX_VALID40 | WS_EX_INTERNAL)) {
            RIPMSG0(RIP_WARNING, "CreateWindowEx: appcompat removed 5.0 EX bits");
        }
#endif

        dwExStyle &= (WS_EX_VALID40 | WS_EX_INTERNAL);
    }


    if ((dwExStyle & (WS_EX_ALLVALID | WS_EX_INTERNAL)) != dwExStyle) {
        RIPMSG0(RIP_WARNING, "CreateWindowEx: enforced not using private bits");

        /*
         * NOTE: Because WS_EX_ANSICREATOR is a reused bit, we actually need to
         * check for valid | internal instead of turning off the private bits.
         *
         * It is very important for us to do this because we need to ensure that
         * certain bits are not set, such as WS_EXP_COMPOSITING or
         * WS_EXP_REDIRECTED because we can fault if this bits were set without
         * properly setting up their accompanying data.
         */
        dwExStyle &= WS_EX_ALLVALID | WS_EX_INTERNAL;
    }


    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        if (IS_PTR(pstrNVClassName)) {
            strNVClassName = ProbeAndReadLargeString(pstrNVClassName);
            ProbeForRead(strNVClassName.Buffer, strNVClassName.Length,
                    sizeof(BYTE));
            pstrNVClassName = &strNVClassName;
        }
        if (IS_PTR(pstrClassName)) {
            strClassName = ProbeAndReadLargeString(pstrClassName);
            ProbeForRead(strClassName.Buffer, strClassName.Length,
                    sizeof(BYTE));
            pstrClassName = &strClassName;
        }
        if (ARGUMENT_PRESENT(pstrWindowName)) {
            strWindowName = ProbeAndReadLargeString(pstrWindowName);
            ProbeForRead(strWindowName.Buffer, strWindowName.Length,
                    sizeof(BYTE));
            pstrWindowName = &strWindowName;
        }
#else
        if (IS_PTR(pstrNVClassName)) {
            strNVClassName = ProbeAndReadLargeString(pstrNVClassName);
            ProbeForRead(strNVClassName.Buffer, strNVClassName.Length,
                    sizeof(WORD));
            pstrNVClassName = &strNVClassName;
        }
        if (IS_PTR(pstrClassName)) {
            strClassName = ProbeAndReadLargeString(pstrClassName);
            ProbeForRead(strClassName.Buffer, strClassName.Length,
                    sizeof(WORD));
            pstrClassName = &strClassName;
        }
        if (ARGUMENT_PRESENT(pstrWindowName)) {
            strWindowName = ProbeAndReadLargeString(pstrWindowName);
            ProbeForRead(strWindowName.Buffer, strWindowName.Length,
                    (strWindowName.bAnsi ? sizeof(BYTE) : sizeof(WORD)));
            pstrWindowName = &strWindowName;
        }
#endif
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    ThreadLockWithPti(ptiCurrent, pwndParent, &tlpwndParent);

    /*
     * The buffers for ClassName and WindowName are still in client space.
     */

    retval = (HWND)xxxCreateWindowEx(
            dwExStyle,
            pstrNVClassName,
            pstrClassName,
            pstrWindowName,
            dwStyle,
            x,
            y,
            nWidth,
            nHeight,
            pwndParent,
            pmenu,
            hModule,
            pParam,
            dwFlags,
            pActCtx);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwndParent);

    CLEANUPRECV();
    if (fLockMenu)
        ThreadUnlock(&tlpMenu);

    TRACE("NtUserCreateWindowEx");
    ENDRECV();
}

NTSTATUS NtUserBuildHwndList(  // worker for EnumWindows, EnumThreadWindows etc.
    IN HDESK hdesk,
    IN HWND hwndNext,
    IN BOOL fEnumChildren,
    IN DWORD idThread,
    IN UINT cHwndMax,
    OUT HWND *phwndFirst,
    OUT PUINT pcHwndNeeded)
{
    PWND pwndNext;
    PDESKTOP pdesk;
    PBWL pbwl;
    PTHREADINFO pti;
    UINT cHwndNeeded;
    UINT wFlags = BWL_ENUMLIST;
    WIN32_OPENMETHOD_PARAMETERS OpenParams;
    BEGINATOMICRECV(NTSTATUS, STATUS_INVALID_HANDLE);

    if (IS_IME_ENABLED()) {
        // special treatment of IME Window
        wFlags |= BWL_ENUMIMELAST;
    }

    /*
     * Validate prior to referencing the desktop
     */
    ValidateHWNDOPT(pwndNext, hwndNext);

    if (idThread) {
        pti = PtiFromThreadId(idThread);
        if (pti == NULL || pti->rpdesk == NULL) {
            MSGERROR(ERROR_INVALID_PARAMETER);
        }
        pwndNext = pti->rpdesk->pDeskInfo->spwnd->spwndChild;
    } else {
        pti = NULL;
    }

    if (hdesk) {
        retval = ValidateHdesk(hdesk, UserMode, DESKTOP_READOBJECTS, &pdesk);
        if (!NT_SUCCESS(retval)) {
            MSGERROR(ERROR_INVALID_HANDLE);
        }

        OpenParams.GrantedAccess = 0;
        OpenParams.HandleCount = 0;
        OpenParams.Object = pdesk;
        OpenParams.OpenReason = ObOpenHandle;
        OpenParams.Process = PsGetCurrentProcess();
        retval = MapDesktop(&OpenParams);
        if (!NT_SUCCESS(retval)) {
            errret = retval;
            MSGERROR(ERROR_INVALID_HANDLE);
        }
        pwndNext = pdesk->pDeskInfo->spwnd->spwndChild;
    } else {
        pdesk = NULL;
    }


    if (pwndNext == NULL) {
        /*
         * Windows NT Bug #262004.
         * If we have a valid desk (just no windows on it), then we need to
         * fall through. Otherwise, we'll just grab the current desktop and
         * enum its windows!
         */
        if (pdesk == NULL) {
            if (pti != NULL) {
                pwndNext = pti->rpdesk->pDeskInfo->spwnd->spwndChild;
            } else {
                pwndNext = _GetDesktopWindow()->spwndChild;
            }
        }
    } else {
        if (fEnumChildren) {
            wFlags |= BWL_ENUMCHILDREN;
            pwndNext = pwndNext->spwndChild;
        }
    }

    if ((pbwl = BuildHwndList(pwndNext, wFlags, pti)) == NULL) {
        MSGERRORCLEANUP(ERROR_NOT_ENOUGH_MEMORY);
    }

    cHwndNeeded = (UINT)(pbwl->phwndNext - pbwl->rghwnd) + 1;

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(phwndFirst, cHwndMax, sizeof(DWORD));
        ProbeForWriteUlong(pcHwndNeeded);

       /*
        * If we have enough space, copy out list of hwnds to user mode buffer.
        */
        if (cHwndNeeded <= cHwndMax) {
            RtlCopyMemory(phwndFirst, pbwl->rghwnd, cHwndNeeded * sizeof(HWND));
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_BUFFER_TOO_SMALL;
        }
        *pcHwndNeeded = cHwndNeeded;
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);  // phwndFirst/pcHwndNeeded are USER's, not app's
    }

    CLEANUPRECV();

    if (pbwl != NULL) {
        FreeHwndList(pbwl);
    }

    if (pdesk != NULL) {
        LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK4, FALSE, (ULONG_PTR)PtiCurrent());
        ObDereferenceObject(pdesk);
    }

    TRACE("NtUserBuildHwndList");
    ENDATOMICRECV();
}

NTSTATUS NtUserBuildPropList(  // worker for EnumProps etc.
    IN HWND hwnd,
    IN UINT cPropMax,
    OUT PPROPSET pPropSet,
    OUT PUINT pcPropNeeded)
{
    BEGINRECV_HWNDLOCK(NTSTATUS, STATUS_INVALID_HANDLE, hwnd);

    if (cPropMax == 0) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(pPropSet, cPropMax, sizeof(DWORD));
        ProbeForWriteUlong(pcPropNeeded);

        retval = _BuildPropList(
                pwnd,
                pPropSet,
                cPropMax,
                pcPropNeeded);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);  // pPropSet/pcPropNeed are USER's, not app's
    }

    TRACE("NtUserBuildPropList");
    ENDRECV_HWNDLOCK();
}

NTSTATUS NtUserBuildNameList(  // worker for EnumWindowStations/EnumDesktops
    IN HWINSTA hwinsta,
    IN UINT cbNameList,
    OUT PNAMELIST ccxpNameList,
    OUT PUINT pcbNeeded)
{
    UINT cbNeeded;
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(NTSTATUS, STATUS_INVALID_HANDLE);

    if (cbNameList < sizeof(NAMELIST)) {
        MSGERROR(0);
    }

    try {
        ProbeForWriteUlong(pcbNeeded);
        ProbeForWrite(ccxpNameList, cbNameList, sizeof(DWORD));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    if (hwinsta != NULL) {
        retval = ValidateHwinsta(hwinsta, UserMode, WINSTA_ENUMDESKTOPS, &pwinsta);
    } else {
        retval = STATUS_SUCCESS;
        pwinsta = NULL;
    }

    if (!NT_SUCCESS(retval)) {
        try {
            *ccxpNameList->awchNames = 0;
            ccxpNameList->cb = 1;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }

     }  else {
        retval = _BuildNameList(pwinsta, ccxpNameList, cbNameList, &cbNeeded);
        try {
            *pcbNeeded = cbNeeded;
        } except (StubExceptionHandler(FALSE)) {
            retval = STATUS_ACCESS_VIOLATION;
        }

        if (pwinsta != NULL) {
            ObDereferenceObject(pwinsta);
        }
    }


    TRACE("NtUserBuildNameList");
    ENDRECV_SHARED();
}

HKL NtUserActivateKeyboardLayout(
    IN HKL hkl,
    IN UINT Flags)
{
    BEGINRECV(HKL, NULL);

    /*
     * Prevent restricted threads from setting the keyboard layout
     * for the entire system.
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_HANDLES)) {
        MSGERROR(0);
    }

    retval = xxxActivateKeyboardLayout(_GetProcessWindowStation(NULL),
                                       hkl,
                                       Flags,
                                       NULL);

    TRACE("NtUserActivateKeyboardLayout");
    ENDRECV();
}

NTSTATUS GetSymbolicLink(
    OUT PUNICODE_STRING pLinkTarget,
    IN PCWSTR pSymbolicLink)
{
    NTSTATUS Status;
    HANDLE hLinkHandle;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING RootString;
    UNICODE_STRING RootValue;
    PVOID pRootValueBuffer = UserAllocPool(MAX_PATH * sizeof(WCHAR), TAG_KBDLAYOUT);

    if (pRootValueBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlInitUnicodeString(&RootString,
                         pSymbolicLink);

    InitializeObjectAttributes(&oa,
                               &RootString,
                               OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenSymbolicLinkObject(&hLinkHandle,
                                      GENERIC_READ,
                                      &oa);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "GetSymbolicLink: Failed to open symbolic link. Got status=%x.",
                Status);
        goto exit;
    }

    RootValue.Buffer = pRootValueBuffer;
    RootValue.Length = 0;
    RootValue.MaximumLength = (USHORT)MAX_PATH * sizeof(WCHAR);

    Status = ZwQuerySymbolicLinkObject(hLinkHandle, &RootValue, NULL);
    ZwClose(hLinkHandle);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "GetSymbolicLink: Failed to query symbolic link. Got status=%x.",
                Status);
        goto exit;
    }

    RtlCopyUnicodeString(pLinkTarget, &RootValue);

exit:
    if (pRootValueBuffer) {
        UserFreePool(pRootValueBuffer);
    }

    return Status;
}

NTSTATUS GetWindowsDirectoryDevicePath(
    OUT PUNICODE_STRING pWindir)
{
    NTSTATUS Status;
    PWCHAR pSlash = NULL, pFixUp;
    UNICODE_STRING RootValue;
    UNICODE_STRING PathValue;
    PVOID pRootValueBuffer = UserAllocPool(MAX_PATH * sizeof(WCHAR), TAG_KBDLAYOUT);
    PVOID pPathValueBuffer = UserAllocPool(MAX_PATH * sizeof(WCHAR), TAG_KBDLAYOUT);

    if ((pRootValueBuffer == NULL) || (pPathValueBuffer == NULL)) {
        Status = STATUS_NO_MEMORY;
        RIPMSGF1(RIP_WARNING,
                "Failed to allocate memory. Got status=%x.",
                 Status);
        goto exit;
    }

    RootValue.Buffer = pRootValueBuffer;
    RootValue.Length = 0;
    RootValue.MaximumLength = (USHORT)MAX_PATH * sizeof(WCHAR);

    /*
     * \SystemRoot is a SymbolicLink that will get us the name of the
     * windows install directory.  Much like %systemroot%\%windir% does.
     */
    Status = GetSymbolicLink(&RootValue, L"\\SystemRoot");
    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING,
                "Failed to query \\SystemRoot. Got status=%x.",
                 Status);
        goto exit;
    }

    /*
     * \SystemRoot returns in the form "\Device\Harddisk1\Partition1\WINDOWS".
     * We need to convert to \Device\HarddiskVolume3\WINDOWS form by converting
     * the "\Device\Harddisk1\Partition1" SymbolicLink to the needed form so we
     * can do our comparisons.
     * We will walk the string backwards masking out a slash at a time as it is
     * possible the windows directory is \WINDOWS\foo\xyz or anything the user
     * has decided to make it. It is not always 1 level deep.
     */
    PathValue.Buffer = pPathValueBuffer;
    PathValue.Length = 0;
    PathValue.MaximumLength = (USHORT)MAX_PATH * sizeof(WCHAR);

    do {
        pFixUp = pSlash;
        pSlash = wcsrchr(RootValue.Buffer, L'\\');

        if (pFixUp != NULL) {
            pFixUp[0] = L'\\';
        }

        if (pSlash) {
            pSlash[0] = L'\0';

            Status = GetSymbolicLink(&PathValue, RootValue.Buffer);

            if (NT_SUCCESS(Status)) {
                pSlash[0] = L'\\';

                RtlAppendUnicodeToString(&PathValue, pSlash);

                RtlCopyUnicodeString(pWindir, &PathValue);

                goto exit;
            }
        }
    } while (pSlash != NULL);

exit:
    if (pRootValueBuffer) {
        UserFreePool(pRootValueBuffer);
    }

    if (pPathValueBuffer) {
        UserFreePool(pPathValueBuffer);
    }

    return Status;
}

HANDLE ConvertHandleAndVerifyLoc(
    HANDLE hFile)
{
    HANDLE hSafeFile = NULL;
    NTSTATUS Status;
    PFILE_OBJECT pFileObject = NULL;
    ULONG ulRetNameLength;
    BYTE bNameBuffer[(MAX_PATH * sizeof(WCHAR)) + sizeof(OBJECT_NAME_INFORMATION)];
    POBJECT_NAME_INFORMATION pFileNameInfo = (POBJECT_NAME_INFORMATION)bNameBuffer;
    PUNICODE_STRING pNameBuffer = (PUNICODE_STRING)&bNameBuffer;
    UNICODE_STRING LinkValue;
    PVOID pLinkValueBuffer = UserAllocPool(MAX_PATH * sizeof(WCHAR), TAG_KBDLAYOUT);

    if (pLinkValueBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    if (hFile) {
        /*
         * This will get a pointer to the object, Verify that the user has
         * read access and that the object is a file handle.
         */
        Status = ObReferenceObjectByHandle(hFile,
                                           FILE_READ_DATA,
                                           *IoFileObjectType,
                                           UserMode,
                                           &pFileObject,
                                           NULL);

        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                    "Failed to convert handle %x. Got status=%x.",
                     hFile,
                     Status);
            goto exit;
        }

        /*
         * Lets get the name of the file.  The value returned is of the form
         * "\Device\HarddiskVolume3\WINDOWS\system32\kbdus.dll"
         */
        Status = ObQueryNameString(pFileObject,
                                   pFileNameInfo,
                                   sizeof(bNameBuffer),
                                   &ulRetNameLength);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                    "Failed to query info for %p. Got status=%x.",
                     pFileObject,
                     Status);
            goto exit;
        }

        LinkValue.Buffer = pLinkValueBuffer;
        LinkValue.Length = 0;
        LinkValue.MaximumLength = (USHORT)MAX_PATH * sizeof(WCHAR);

        /*
         * Now lets get the windows directory path so we can match this
         * with pFileNameInfo's value and make sure we are in the windows
         * directory.
         */
        Status = GetWindowsDirectoryDevicePath(&LinkValue);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF1(RIP_WARNING,
                    "Failed to query \\SystemRoot. Got status=%x.",
                     Status);
            goto exit;
        }

#if defined(_WIN64)
        if (PtiCurrent()->TIF_flags & TIF_WOW64) {
            RtlAppendUnicodeToString(&LinkValue, L"\\SysWOW64");
        } else
#endif
        {
            RtlAppendUnicodeToString(&LinkValue, L"\\system32");
        }

        if (_wcsnicmp(pFileNameInfo->Name.Buffer, LinkValue.Buffer, LinkValue.Length / sizeof(WCHAR))) {
            RIPMSGF1(RIP_WARNING,
                    "Specifed hFile %S is not in a secure location.",
                     pFileNameInfo->Name.Buffer);

            Status = STATUS_INVALID_PARAMETER_1;
            goto exit;
        }

        /*
         * We have passed the location check so lets go ahead and open a
         * kernel handle that we can use later to map the view.
         */
        Status = ObOpenObjectByPointer(pFileObject,
                                       OBJ_KERNEL_HANDLE,
                                       NULL,
                                       FILE_READ_DATA,
                                       *IoFileObjectType,
                                       KernelMode,
                                       &hSafeFile);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                     "Failed to get handle for %p. Got status=%x.",
                     pFileObject,
                     Status);
            goto exit;
        }
    }

    goto exit;

exit:
    if (pLinkValueBuffer != NULL) {
        UserFreePool(pLinkValueBuffer);
    }

    if (pFileObject) {
        ObDereferenceObject(pFileObject);
    }

    return hSafeFile;
}

HKL NtUserLoadKeyboardLayoutEx(
    IN HANDLE hFile,
    IN DWORD offTable,
    IN PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN HKL hkl,
    IN PUNICODE_STRING pstrKLID,
    IN UINT KbdInputLocale,
    IN UINT Flags)
{
    UNICODE_STRING strKLID;
    PWINDOWSTATION pwinsta;
    WCHAR awchKF[KL_NAMELENGTH];
    UINT chMax;
    KBDTABLE_MULTI_INTERNAL kbdTableMulti;
    HANDLE hSafeFile = NULL;
    UINT i;

    BEGINRECV(HKL, NULL);

    TESTFLAGS(Flags, KLF_VALID);

    RtlZeroMemory(&kbdTableMulti, sizeof(KBDTABLE_MULTI_INTERNAL));

    pwinsta = _GetProcessWindowStation(NULL);

    /*
     * Probe arguments
     */
    try {
        strKLID = ProbeAndReadUnicodeString(pstrKLID);
        ProbeForRead(strKLID.Buffer, strKLID.Length, CHARALIGN);
        chMax = min(sizeof(awchKF) - sizeof(WCHAR), strKLID.Length) / sizeof(WCHAR);
        wcsncpy(awchKF, strKLID.Buffer, chMax);
        awchKF[chMax] = 0;

        if (pKbdTableMulti) {
            kbdTableMulti = ProbeAndReadStructure(pKbdTableMulti, KBDTABLE_MULTI_INTERNAL);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    hSafeFile = ConvertHandleAndVerifyLoc(hFile);

    if (pKbdTableMulti && hSafeFile != NULL) {
        if (kbdTableMulti.multi.nTables >= KBDTABLE_MULTI_MAX) {
            RIPMSGF1(RIP_WARNING,
                    "pKbdTableMulti.multi.nTables too large: %x",
                    kbdTableMulti.multi.nTables);

            kbdTableMulti.multi.nTables = 0;

            MSGERRORCLEANUP(ERROR_INVALID_PARAMETER);
        } else if (kbdTableMulti.multi.nTables > 0) {
            for (i = 0; i < kbdTableMulti.multi.nTables; i++) {
                kbdTableMulti.files[i].hFile = ConvertHandleAndVerifyLoc(kbdTableMulti.files[i].hFile);
                if (kbdTableMulti.files[i].hFile == NULL) {
                    RIPMSGF2(RIP_WARNING,
                             "Failed to Convert KbdTableMulti[%x].hFile and nTables is %x.",
                             i,
                             kbdTableMulti.multi.nTables);
                    break;
                }
            }

            kbdTableMulti.multi.nTables = i;
        }
    }

    pKbdTableMulti = &kbdTableMulti;

    retval = xxxLoadKeyboardLayoutEx(pwinsta,
                                     hSafeFile,
                                     hkl,
                                     offTable,
                                     pKbdTableMulti,
                                     awchKF,
                                     KbdInputLocale,
                                     Flags);

    CLEANUPRECV();

    if (hSafeFile != NULL) {
        ZwClose(hSafeFile);

        for (i = 0; i < kbdTableMulti.multi.nTables; i++) {
            if (kbdTableMulti.files[i].hFile != NULL) {
                ZwClose(kbdTableMulti.files[i].hFile);
            }
        }
    }

    TRACE("NtUserLoadKeyboardLayoutEx");
    ENDRECV();
}

BOOL NtUserUnloadKeyboardLayout(
    IN HKL hkl)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxUnloadKeyboardLayout(
                     _GetProcessWindowStation(NULL),
                     hkl);

    TRACE("NtUserUnloadKeyboardLayout");
    ENDRECV();
}

BOOL NtUserSetSystemMenu(
    IN HWND hwnd,
    IN HMENU hmenu)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    ValidateHMENU(pmenu, hmenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval =  xxxSetSystemMenu(pwnd, pmenu);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserSetSystemMenu");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserDragDetect(
    IN HWND hwnd,
    IN POINT pt)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxDragDetect(pwnd, pt);

    TRACE("NtUserDragDetect");
    ENDRECV_HWNDLOCK();
}

UINT_PTR NtUserSetSystemTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN DWORD dwElapse,
    IN WNDPROC pTimerFunc)
{
    BEGINRECV_HWND(UINT_PTR, 0, hwnd);

    UNREFERENCED_PARAMETER(pTimerFunc);

    retval = _SetSystemTimer(pwnd,
            nIDEvent,
            dwElapse,
            NULL);

    TRACE("NtUserSetSystemTimer");
    ENDRECV_HWND();
}

BOOL NtUserQuerySendMessage(  // private QuerySendMessage
    OUT PMSG pmsg OPTIONAL)
{
    PSMS psms;
    BEGINRECV_SHARED(BOOL, FALSE);

    if ((psms = PtiCurrentShared()->psmsCurrent) == NULL) {
        MSGERROR(0);
    }

    retval = TRUE;
    if (ARGUMENT_PRESENT(pmsg)) {
        try {
            ProbeForWriteMessage(pmsg);
            pmsg->hwnd = HW(psms->spwnd);
            pmsg->message = psms->message;
            pmsg->wParam = psms->wParam;
            pmsg->lParam = psms->lParam;
            pmsg->time = psms->tSent;
            pmsg->pt.x = 0;
            pmsg->pt.y = 0;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserQuerySendMessage");
    ENDRECV_SHARED();
}

UINT NtUserSendInput(
    IN UINT    cInputs,
    IN CONST INPUT *pInputs,
    IN int     cbSize)
{
    LPINPUT pInput2 = NULL;
    PTHREADINFO ptiCurrent;
    TL tlInput;

    BEGINRECV(UINT, 0);

    if (sizeof(INPUT) != cbSize || cInputs == 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    ptiCurrent = PtiCurrent();

    /*
     * Probe arguments
     */
    try {
        ProbeForReadBuffer(pInputs, cInputs, DATAALIGN);

        pInput2 = UserAllocPoolWithQuota(cInputs * sizeof(*pInputs), TAG_SENDINPUT);
        if (pInput2 == NULL) {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }
        RtlCopyMemory(pInput2, pInputs, cInputs * sizeof(*pInputs));
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    ThreadLockPool(ptiCurrent, pInput2, &tlInput);
    retval = xxxSendInput(cInputs, pInput2);
    ThreadUnlockPool(ptiCurrent, &tlInput);
CLEANUPRECV();
    if (pInput2) {
        UserFreePool(pInput2);
    }
    TRACE("NtUserSendInput");
    ENDRECV();
}

UINT NtUserBlockInput(
    IN BOOL fBlockIt)
{
    BEGINATOMICRECV(BOOL, FALSE);
    retval = _BlockInput(fBlockIt);
    TRACE("NtUserBlockInput");
    ENDATOMICRECV();
}

BOOL NtUserImpersonateDdeClientWindow(
    IN HWND hwndClient,
    IN HWND hwndServer)
{
    PWND pwndServer;

    BEGINATOMICRECV_HWND(BOOL, FALSE, hwndClient);

    ValidateHWND(pwndServer, hwndServer);
    if (GETPTI(pwndServer) != PtiCurrent()) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        MSGERROR(0);
    }

    if (GETPWNDPPI(pwnd) == GETPWNDPPI(pwndServer)) {
        retval = TRUE;  // impersonating self is a NOOP
    } else {
        retval = _ImpersonateDdeClientWindow(pwnd, pwndServer);
    }

    TRACE("NtUserImpersonateDdeClientWindow");
    ENDATOMICRECV_HWND();
}

ULONG_PTR NtUserGetCPD(
    IN HWND hwnd,
    IN DWORD options,
    IN ULONG_PTR dwData)
{
    BEGINRECV_HWND(ULONG_PTR, 0, hwnd);

    switch (options & ~CPD_TRANSITION_TYPES) {
    case CPD_WND:
    case CPD_DIALOG:
    case CPD_WNDTOCLS:
        break;
    default:
        RIPMSG1(RIP_WARNING, "GetCPD: Invalid options %x", options);
        MSGERROR(0);
    }

    retval = GetCPD(pwnd, options, dwData);

    TRACE("NtUserGetCPD");
    ENDRECV_HWND();
}

int NtUserCopyAcceleratorTable(  // API CopyAcceleratorTableA/W
    IN HACCEL hAccelSrc,
    IN OUT LPACCEL lpAccelDst OPTIONAL,
    IN int cAccel)
{
    LPACCELTABLE pat;
    int i;
    BEGINATOMICRECV(int, 0);

    ValidateHACCEL(pat, hAccelSrc);

    if (lpAccelDst == NULL) {
        retval = pat->cAccel;
    } else {

        /*
         * Probe arguments
         */
        try {
            ProbeForWriteBuffer(lpAccelDst, cAccel, DATAALIGN);

            if (cAccel > (int)pat->cAccel)
                cAccel = pat->cAccel;

            retval = cAccel;
            for (i = 0; i < cAccel; i++) {
                RtlCopyMemory(&lpAccelDst[i], &pat->accel[i], sizeof(ACCEL));
                lpAccelDst[i].fVirt &= ~FLASTKEY;
            }
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserCopyAcceleratorTable");
    ENDATOMICRECV();
}

HWND NtUserFindWindowEx(  // API FindWindowA/W, FindWindowExA/W
    IN HWND hwndParent,
    IN HWND hwndChild,
    IN PUNICODE_STRING pstrClassName,
    IN PUNICODE_STRING pstrWindowName,
    DWORD dwType)
{
    UNICODE_STRING  strClassName;
    UNICODE_STRING  strWindowName;
    PWND            pwndParent, pwndChild;

    BEGINATOMICRECV(HWND, NULL);

    if (hwndParent != HWND_MESSAGE) {
        ValidateHWNDOPT(pwndParent, hwndParent);
    } else {
        pwndParent = _GetMessageWindow();
    }

    ValidateHWNDOPT(pwndChild,  hwndChild);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
        strWindowName = ProbeAndReadUnicodeString(pstrWindowName);
        ProbeForReadUnicodeStringBufferOrId(strClassName);
        ProbeForReadUnicodeStringBuffer(strWindowName);
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    /*
     * Use of both buffers is protected by try/except clauses in the code.
     */

    retval = (HWND)_FindWindowEx(
            pwndParent,
            pwndChild,
            strClassName.Buffer,
            strWindowName.Buffer,
            dwType);
    retval = PtoH((PVOID)retval);

    CLEANUPRECV();

    TRACE("NtUserFindWindowEx");
    ENDATOMICRECV();
}

BOOL NtUserGetClassInfoEx(  // API GetClassInfoA/W
    IN HINSTANCE hInstance OPTIONAL,
    IN PUNICODE_STRING pstrClassName,
    IN OUT LPWNDCLASSEXW lpWndClass,
    OUT LPWSTR *ppszMenuName,
    IN BOOL bAnsi)
{
    UNICODE_STRING strClassName;
    LPWSTR pszMenuName;
    WNDCLASSEXW wc;

    BEGINRECV(BOOL, FALSE);

#ifdef LAZY_CLASS_INIT
    if ((PtiCurrent()->ppi->W32PF_Flags & W32PF_CLASSESREGISTERED) == 0) {
        if (!LW_RegisterWindows()) {
            MSGERROR(ERROR_INVALID_PARAMETER);
        }
    }
#endif

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);

        /*
         * The class name may either be a string or an atom. Only
         * probe strings.
         */
        ProbeForReadUnicodeStringBufferOrId(strClassName);
        ProbeForWrite(lpWndClass, sizeof(*lpWndClass), DATAALIGN);
        ProbeForWriteUlong((PULONG)ppszMenuName);
        RtlCopyMemory(&wc, lpWndClass, sizeof(WNDCLASSEXW));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The class name buffer is client-side.
     */
    retval = _GetClassInfoEx(hInstance,
                             (LPTSTR)strClassName.Buffer,
                             &wc,
                             &pszMenuName,
                             bAnsi);
    if (retval) {
        try {
            RtlCopyMemory(lpWndClass, &wc, sizeof(WNDCLASSEXW));
            *ppszMenuName = pszMenuName;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetClassInfo");
    ENDRECV();
}

/*
 * gaFNIDtoICLS is used only in NtUserGetClassName and should be in sync with
 * the values from user.h
 * ICLS_MAX is an unused value
 */
CONST BYTE gaFNIDtoICLS[] = {
                        //  FNID-START
    ICLS_SCROLLBAR,     //  FNID_SCROLLBAR
    ICLS_ICONTITLE,     //  FNID_ICONTITLE
    ICLS_MENU,          //  FNID_MENU
    ICLS_DESKTOP,       //  FNID_DESKTOP
    ICLS_MAX,           //  FNID_DEFWINDOWPROC
    ICLS_MAX,           //  FNID_MESSAGE
    ICLS_SWITCH,        //  FNID_SWITCH
    ICLS_BUTTON,        //  FNID_BUTTON
    ICLS_COMBOBOX,      //  FNID_COMBOBOX
    ICLS_COMBOLISTBOX,  //  FNID_COMBOLISTBOX
    ICLS_DIALOG,        //  FNID_DIALOG
    ICLS_EDIT,          //  FNID_EDIT
    ICLS_LISTBOX,       //  FNID_LISTBOX
    ICLS_MDICLIENT,     //  FNID_MDICLIENT
    ICLS_STATIC,        //  FNID_STATIC
    ICLS_IME,           //  FNID_IME
    ICLS_MAX,           //  FNID_HKINLPCWPEXSTRUCT
    ICLS_MAX,           //  FNID_HKINLPCWPRETEXSTRUCT
    ICLS_MAX,           //  FNID_DEFFRAMEPROC
    ICLS_MAX,           //  FNID_DEFMDICHILDPROC
    ICLS_MAX,           //  FNID_MB_DLGPROC
    ICLS_MAX,           //  FNID_MDIACTIVATEDLGPROC
    ICLS_MAX,           //  FNID_SENDMESSAGE
    ICLS_MAX,           //  FNID_SENDMESSAGEFF
    ICLS_MAX,           //  FNID_SENDMESSAGEEX
    ICLS_MAX,           //  FNID_CALLWINDOWPROC
    ICLS_MAX,           //  FNID_SENDMESSAGEBSM
    ICLS_TOOLTIP,       //  FNID_TOOLTIP
    ICLS_GHOST,         //  FNID_GHOST
    ICLS_MAX,           //  FNID_SENDNOTIFYMESSAGE
    ICLS_MAX            //  FNID_SENDMESSAGECALLBACK
};                      //  FNID_END

int NtUserGetClassName(  // API GetClassNameA/W
    IN HWND hwnd,
    IN BOOL bReal,
    IN OUT PUNICODE_STRING pstrClassName)
{
    UNICODE_STRING strClassName;
    ATOM atom;

    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
#if defined(_X86_)
        ProbeForWrite(strClassName.Buffer, strClassName.MaximumLength,
            sizeof(BYTE));
#else
        ProbeForWrite(strClassName.Buffer, strClassName.MaximumLength,
            sizeof(WCHAR));
#endif
        atom = pwnd->pcls->atomNVClassName;

        UserAssert(ARRAY_SIZE(gaFNIDtoICLS) == FNID_END - FNID_START + 1);

        if (bReal) {
            DWORD dwFnid;
            DWORD dwClass;
            dwFnid = GETFNID(pwnd);
            if (dwFnid) {
                dwFnid -= FNID_START;
                if (dwFnid < ARRAY_SIZE(gaFNIDtoICLS)) {
                    dwClass = gaFNIDtoICLS[dwFnid];
                    if (dwClass != ICLS_MAX) {
                        atom = gpsi->atomSysClass[dwClass];
                    }
                }
            }
        }
        retval = UserGetAtomName(
            atom,
            strClassName.Buffer,
            strClassName.MaximumLength / sizeof(WCHAR));

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetClassName");
    ENDRECV_HWND_SHARED();
}

UINT NtUserGetAtomName(
    IN ATOM atom,
    IN OUT PUNICODE_STRING pstrAtomName)
{
    UNICODE_STRING strAtomName;

    BEGINRECV_SHARED(UINT, 0);

    /*
     * Probe arguments
     */
    try {
        strAtomName = ProbeAndReadUnicodeString(pstrAtomName);
#if defined(_X86_)
        ProbeForWrite(strAtomName.Buffer, strAtomName.MaximumLength,
            sizeof(BYTE));
#else
        ProbeForWrite(strAtomName.Buffer, strAtomName.MaximumLength,
            sizeof(WCHAR));
#endif
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = UserGetAtomName(
        atom,
        strAtomName.Buffer,
        strAtomName.MaximumLength / sizeof(WCHAR));

    TRACE("NtUserGetAtomName");
    ENDRECV_SHARED();
}

int NtUserGetClipboardFormatName(  // API GetclipboardFormatNameA/W
    IN UINT format,
    OUT LPWSTR lpszFormatName,
    IN UINT chMax)
{
    BEGINRECV_NOCRIT(int, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(lpszFormatName, chMax, CHARALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if ((ATOM)format < MAXINTATOM) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        /*
         * UserGetAtomName (actually RtlQueryAtomInAtomTable) protects access
         * within a try block, and sets last error appropriately.
         */
        retval = UserGetAtomName((ATOM)format, lpszFormatName, chMax);
    }

    TRACE("NtUserGetClipboardFormatName");
    ENDRECV_NOCRIT();
}

int NtUserGetKeyNameText(
    IN LONG lParam,
    OUT LPWSTR lpszKeyName,
    IN UINT chMax)
{
    BEGINRECV_SHARED(int, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(lpszKeyName, chMax, CHARALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Note -- lpszKeyName is a client-side address. GetKeyNameText
     * protects uses with try blocks, and sets last error accordingly.
     */

    retval = _GetKeyNameText(
                lParam,
                lpszKeyName,
                chMax);

    TRACE("NtUserGetKeyNameText");
    ENDRECV_SHARED();
}


BOOL NtUserGetKeyboardLayoutName(
    IN OUT PUNICODE_STRING pstrKLID)
{
    PTHREADINFO ptiCurrent;
    PKL pklActive;
    UNICODE_STRING strKLID;

    BEGINRECV_SHARED(BOOL, FALSE);

    ptiCurrent = PtiCurrentShared();
    pklActive = ptiCurrent->spklActive;

    if (pklActive == NULL) {
        MSGERROR(0);
    }
    /*
     * Probe arguments
     */
    try {
        strKLID = ProbeAndReadUnicodeString(pstrKLID);
        ProbeForWrite(strKLID.Buffer, strKLID.MaximumLength, CHARALIGN);

        if (IS_IME_KBDLAYOUT(pklActive->hkl)) {
            /*
             * IME KL may have different KL name for the same layout file.
             * Their KL name are really equivalent to HKL.
             */
            RtlIntegerToUnicodeString(DOWNCAST(ULONG, pklActive->hkl), 0x10, &strKLID);
        } else {
    #if (KL_NAMELENGTH != 8 + 1)
        #error unexpected KL_NAMELENGTH
    #endif
            if (strKLID.MaximumLength < KL_NAMELENGTH * sizeof(WCHAR) ||
                    !NT_SUCCESS(RtlIntegerToUnicode(pklActive->dwKLID, 0x10, -(KL_NAMELENGTH - 1), strKLID.Buffer))) {
                MSGERROR(ERROR_INVALID_PARAMETER);
            }
            strKLID.Length = (KL_NAMELENGTH - 1) * sizeof(WCHAR);
            /*
             * Make it NULL terminated.
             */
            strKLID.Buffer[KL_NAMELENGTH - 1] = L'\0';
        }

        retval = TRUE;

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetKeyboardLayoutName");
    ENDRECV_SHARED();
}

UINT NtUserGetKeyboardLayoutList(
    IN UINT nItems,
    OUT HKL *lpBuff)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(UINT, 0);

    /*
     * Probe arguments
     */
    try {
        if (!lpBuff) {
            nItems = 0;
        }
        ProbeForWriteBuffer(lpBuff, nItems, DATAALIGN);
        pwinsta = _GetProcessWindowStation(NULL);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Access to the client-side buffer lpBuff is protected by try/except
     * inside _GetKeyboardLayoutList()
     */
    retval = (DWORD)_GetKeyboardLayoutList(pwinsta, nItems, lpBuff);
    TRACE("NtUserGetKeyboardLayoutList");
    ENDRECV_SHARED();
}

UINT NtUserMapVirtualKeyEx(
    IN UINT uCode,
    IN UINT uMapType,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL)
{
    PKL pkl;

    BEGINRECV_SHARED(UINT, 0);

    /*
     * See if we need to convert an HKL to a PKL. MapVirtualKey passes a PKL and
     * MapVirtualKeyEx passes an HKL. The conversion must be done in the kernel.
     */
    if (bHKL) {
        pkl = HKLtoPKL(PtiCurrentShared(), (HKL)dwHKLorPKL);
    } else {
        pkl = PtiCurrentShared()->spklActive;
    }

    if (pkl == NULL) {
        retval = 0;
    } else {
        retval = InternalMapVirtualKeyEx(uCode, uMapType, pkl->spkf->pKbdTbl);
    }

    TRACE("NtUserMapVirtualKeyEx");
    ENDRECV_SHARED();
}

ATOM NtUserRegisterClassExWOW(
    IN WNDCLASSEX *lpWndClass,
    IN PUNICODE_STRING pstrClassName,
    IN PUNICODE_STRING pstrClassNameVer,
    IN PCLSMENUNAME pcmn,
    IN WORD fnid,
    IN DWORD dwFlags,
    IN LPDWORD pdwWOWstuff OPTIONAL)
{
    UNICODE_STRING strClassName;
    UNICODE_STRING strClassNameVer;
    UNICODE_STRING strMenuName;
    WNDCLASSVEREX WndClass;
    WC WowCls;
    CLSMENUNAME cmn;

    BEGINRECV(ATOM, 0);

    TESTFLAGS(dwFlags, CSF_VALID);

#ifdef LAZY_CLASS_INIT
    if ((PtiCurrent()->ppi->W32PF_Flags & W32PF_CLASSESREGISTERED) == 0) {
        if (!LW_RegisterWindows()) {
            MSGERROR(ERROR_INVALID_PARAMETER);
        }
    }
#endif

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
        strClassNameVer = ProbeAndReadUnicodeString(pstrClassNameVer);
        cmn = ProbeAndReadStructure(pcmn, CLSMENUNAME);
        strMenuName = ProbeAndReadUnicodeString(cmn.pusMenuName);
        *((LPWNDCLASSEX)(&WndClass)) = ProbeAndReadStructure(lpWndClass, WNDCLASSEX);
        ProbeForReadUnicodeStringBufferOrId(strClassName);
        ProbeForReadUnicodeStringBufferOrId(strClassNameVer);
        ProbeForReadUnicodeStringBufferOrId(strMenuName);
        if (ARGUMENT_PRESENT(pdwWOWstuff)) {
            ProbeForRead(pdwWOWstuff, sizeof(WC), sizeof(BYTE));
            RtlCopyMemory(&WowCls, pdwWOWstuff, sizeof(WC));
            pdwWOWstuff = (PDWORD)&WowCls;
        }
        WndClass.lpszClassName = strClassName.Buffer;
        WndClass.lpszClassNameVer = strClassNameVer.Buffer;
        WndClass.lpszMenuName = strMenuName.Buffer;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (WndClass.cbClsExtra < 0 || WndClass.cbWndExtra < 0 || WndClass.cbSize != sizeof(WNDCLASSEX)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    /*
     * ClassName and MenuName in WndClass are client-side pointers.
     */

    retval = _RegisterClassEx(&WndClass,
                             &cmn,
                             fnid,
                             dwFlags,
                             pdwWOWstuff);

    TRACE("NtUserRegisterClassExWOW");
    ENDRECV();
}

UINT NtUserRegisterWindowMessage(
    IN PUNICODE_STRING pstrMessage)
{
    UNICODE_STRING strMessage;

    BEGINRECV_NOCRIT(UINT, 0);

    /*
     * Probe arguments
     */
    try {
        strMessage = ProbeAndReadUnicodeString(pstrMessage);
        ProbeForReadUnicodeStringBuffer(strMessage);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The buffer is in client-side memory.
     * Rtl atom routines protect accesses to strings with their
     * own try/except blocks, UserAddAtom sets last error accordingly.
     */
    retval = UserAddAtom(
            strMessage.Buffer, FALSE);

    TRACE("NtUserRegisterWindowMessage");
    ENDRECV_NOCRIT();
}

HANDLE NtUserRemoveProp(
    IN HWND hwnd,
    IN DWORD dwProp)
{
    BEGINRECV_HWND(HANDLE, NULL, hwnd);

    retval = InternalRemoveProp(pwnd, (LPWSTR)LOWORD(dwProp), FALSE);

    TRACE("NtUserRemoveProp");
    ENDRECV_HWND();
}

BOOL NtUserSetProp(
    IN HWND hwnd,
    IN DWORD dwProp,
    IN HANDLE hData)
{
    BEGINRECV_HWND(DWORD, 0, hwnd);

    retval = InternalSetProp(pwnd,
                             (LPTSTR)LOWORD(dwProp),
                             hData,
                             HIWORD(dwProp) ? PROPF_STRING : 0);

    TRACE("NtUserSetProp");
    ENDRECV_HWND();
}

BOOL NtUserUnregisterClass(  // API UnregisterClass
    IN PUNICODE_STRING pstrClassName,
    IN HINSTANCE hInstance,
    OUT PCLSMENUNAME pcmn)
{
    UNICODE_STRING strClassName;
    CLSMENUNAME cmn;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
        ProbeForReadUnicodeStringBufferOrId(strClassName);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The buffer is in client-side memory.
     */

    retval = _UnregisterClass(
                strClassName.Buffer,
                hInstance,
                &cmn);

    try {
        ProbeAndWriteStructure(pcmn, cmn, CLSMENUNAME);
    } except (StubExceptionHandler(FALSE)) {
        // no SetLastError, since pcmn is a USER address, not the application's
    }

    TRACE("NtUserUnregisterClass");
    ENDRECV();
}

SHORT NtUserVkKeyScanEx(
    IN WCHAR cChar,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL)
{
    PKL pkl;

    BEGINRECV_SHARED(SHORT, -1);

    /*
     * See if we need to convert an HKL to a PKL. VkKeyScan passes a PKL and
     * VkKeyScanEx passes an HKL. The conversion must be done on the server side.
     */
    if (bHKL) {
        pkl = HKLtoPKL(PtiCurrentShared(), (HKL)dwHKLorPKL);
    } else {
        pkl = PtiCurrentShared()->spklActive;
    }

    if (pkl == NULL) {
        retval = (SHORT)-1;
    } else {
        retval = InternalVkKeyScanEx(cChar, pkl->spkf->pKbdTbl);
    }

    TRACE("NtUserVkKeyScanEx");
    ENDRECV_SHARED();
}

NTSTATUS
NtUserEnumDisplayDevices(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD iDevNum,
    IN OUT LPDISPLAY_DEVICEW lpDisplayDevice,
    IN DWORD dwFlags)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * We need to syncrhonize with session switching from local to remote or
     * remote to local while enumerating display settings. Use
     * UserSessionSwitchEnterCrit() to ensure mutual exclusion with session
     * switch code, but first leave the User critical section as
     * UserSessionSwitchEnterCrit() does not expect to be held by the caller.
     * On return from UserSessionSwitchEnterCrit() the critical section will be
     * held.
     */

    LeaveCrit();
    retval = UserSessionSwitchEnterCrit();
    if (retval != STATUS_SUCCESS) {
        goto exit_api;
    }

    /*
     * Update the list of devices. Do this only if connected to local console.
     * If the function returns FALSE (retry update), then we must
     * disable the current hdev, call back, and reanable the hdev.
     */
    if (!IsRemoteConnection()) {
        if (DrvUpdateGraphicsDeviceList(FALSE, FALSE, TRUE) == FALSE) {

            if (SafeDisableMDEV()) {

                DrvUpdateGraphicsDeviceList(TRUE, FALSE, TRUE);

                SafeEnableMDEV();

                /*
                 * Repaint the screen
                 */

                xxxUserResetDisplayDevice();

                /*
                 * xxxUserResetDisplayDevice may have released and reaquiered the user critical section.
                 * We need to make sure again that no session switch has started during that window.
                 */

                LeaveCrit();
                retval = UserSessionSwitchEnterCrit();
                if (retval != STATUS_SUCCESS) {
                    goto exit_api;
                }
            }
        }
    }


    /*
     * Address checking, etc., occurs in GRE.
     */

    retval = DrvEnumDisplayDevices(pstrDeviceName,
                                   gpDispInfo->pMonitorPrimary->hDev,
                                   iDevNum,
                                   lpDisplayDevice,
                                   dwFlags,
                                   UserMode);

    UserSessionSwitchLeaveCrit();
exit_api:
    EnterCrit();

    TRACE("NtUserEnumDisplayDevices");
    ENDRECV();
}

NTSTATUS
NtUserEnumDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD           iModeNum,
    OUT LPDEVMODEW     lpDevMode,
    IN  DWORD          dwFlags)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * We need to synchronize with session switching from local to remote or
     * remote to local while enumerating display settings. Use
     * UserSessionSwitchEnterCrit() to ensure mutual exclusion with session
     * switch code, but first leave the User critical section as
     * UserSessionSwitchEnterCrit() does not expect to be held by the caller.
     * On return from UserSessionSwitchEnterCrit() the critical section will be
     * held.
     *
     * Address checking, etc., occurs in GRE.
     */

    LeaveCrit();
    retval = UserSessionSwitchEnterCrit();
    if (retval != STATUS_SUCCESS) {
        goto exit_api;
    }
    retval = DrvEnumDisplaySettings(pstrDeviceName,
                                    gpDispInfo->pMonitorPrimary->hDev,
                                    iModeNum,
                                    lpDevMode,
                                    dwFlags);
    UserSessionSwitchLeaveCrit();
exit_api:
    EnterCrit();

    TRACE("NtUserEnumDisplaySettings");
    ENDRECV();
}

#ifdef PRERELEASE
PTHREADINFO gptiLastChangedDisplaySettings;
#endif

LONG
NtUserChangeDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN LPDEVMODEW pDevMode,
    IN DWORD dwFlags,
    IN PVOID lParam)
{
    BEGINRECV(LONG, DISP_CHANGE_FAILED);

    /*
     * Prevent restricted threads from changing display settings.
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_DISPLAYSETTINGS)) {
        MSGERROR(0);
    }

#ifdef PRERELEASE
    /*
     * Remember the last guy who tried to change the display settings
     * (per the request from the shell team).
     * N.b. it doesn't care if the call was succeeded or not.
     */
    gptiLastChangedDisplaySettings = PtiCurrent();
#endif

    /*
     * Address checking, etc., occurs in GRE.
     */

    retval = xxxUserChangeDisplaySettings(pstrDeviceName,
                                          pDevMode,
                                          NULL,
                                          dwFlags,
                                          lParam,
                                          UserMode);

    TRACE("NtUserChangeDisplaySettings");
    ENDRECV();
}

BOOL NtUserCallMsgFilter(  // API CallMsgFilterA/W
    IN OUT LPMSG lpMsg,
    IN int nCode)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteMessage(lpMsg);
        msg = *lpMsg;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _CallMsgFilter(
                &msg,
                nCode);
    try {
        *lpMsg = msg;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserCallMsgFilter");
    ENDRECV();
}

int NtUserDrawMenuBarTemp(  // private DrawMenuBarTemp
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HMENU hMenu,
    IN HFONT hFont)
{
    PMENU   pMenu;
    TL      tlpMenu;
    RECT    rc;


    BEGINRECV_HWNDLOCK(int, 0, hwnd);

    /*
     * Probe and capture arguments.
     */
    try {
        rc = ProbeAndReadRect(lprc);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    ValidateHMENU(pMenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pMenu, &tlpMenu);

    retval = xxxDrawMenuBarTemp(
            pwnd,
            hdc,
            &rc,
            pMenu,
            hFont);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserDrawMenuBarTemp");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserDrawCaptionTemp(  // private DrawCaptionTempA/W
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HFONT hFont,
    IN HICON hIcon,
    IN PUNICODE_STRING pstrText,
    IN UINT flags)
{
    PCURSOR         pcur;
    TL              tlpcur;
    RECT            rc;
    UNICODE_STRING  strCapture;
    PWND            pwnd;
    TL              tlpwnd;
    PTHREADINFO     ptiCurrent;
    TL tlBuffer;
    BOOL fFreeBuffer = FALSE;

    BEGINRECV(DWORD, FALSE);

    ptiCurrent = PtiCurrent();

    ValidateHWNDOPT(pwnd, hwnd);
    ValidateHCURSOROPT(pcur, hIcon);

    /*
     * Probe and capture arguments. Capturing the text is ugly,
     * but must be done because it is passed to GDI.
     */
    try {
        rc = ProbeAndReadRect(lprc);
        strCapture = ProbeAndReadUnicodeString(pstrText);
        if (strCapture.Buffer != NULL) {
            PWSTR pszCapture = strCapture.Buffer;
            ProbeForRead(strCapture.Buffer, strCapture.Length, CHARALIGN);
            strCapture.Buffer = UserAllocPoolWithQuota(strCapture.Length+sizeof(UNICODE_NULL), TAG_TEXT);
            if (strCapture.Buffer != NULL) {
                fFreeBuffer = TRUE;
                ThreadLockPool(ptiCurrent, strCapture.Buffer, &tlBuffer);
                RtlCopyMemory(strCapture.Buffer, pszCapture, strCapture.Length);
                strCapture.Buffer[strCapture.Length/sizeof(WCHAR)]=0;  // null-terminate string
                strCapture.MaximumLength = strCapture.Length+sizeof(UNICODE_NULL);
                pstrText = &strCapture;
            } else {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockWithPti(ptiCurrent, pcur, &tlpcur);

    retval = xxxDrawCaptionTemp(
            pwnd,
            hdc,
            &rc,
            hFont,
            pcur,
            strCapture.Buffer ? &strCapture : NULL,
            flags);

    ThreadUnlock(&tlpcur);
    ThreadUnlock(&tlpwnd);

    CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);

    TRACE("NtUserDrawCaptionTemp");
    ENDRECV();
}

BOOL NtUserGetKeyboardState(  // API GetKeyboardState
    OUT PBYTE pb)
{
    int i;
    PQ pq;
    BEGINRECV_SHARED(SHORT, 0)

    /*
     * Probe arguments
     */
    try {
        ProbeForWrite(pb, 256, sizeof(BYTE));

        pq = PtiCurrentShared()->pq;

        for (i = 0; i < 256; i++, pb++) {
            *pb = 0;
            if (TestKeyStateDown(pq, i))
                *pb |= 0x80;

            if (TestKeyStateToggle(pq, i))
                *pb |= 0x01;
        }
        retval = TRUE;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ENDRECV_SHARED();
}

SHORT NtUserGetKeyState(
    IN int vk)
{
    PTHREADINFO ptiCurrent;
    BEGINRECV_SHARED(SHORT, 0)

    ptiCurrent = PtiCurrentShared();
    if (ptiCurrent->pq->QF_flags & QF_UPDATEKEYSTATE) {

        /*
         * We are going to change the system state, so we
         * must have an exclusive lock
         */
        ChangeAcquireResourceType();

        /*
         * If this thread needs a key state event, give one to it. There are
         * cases where any app may be looping looking at GetKeyState(), plus
         * calling PeekMessage(). Key state events don't get created unless
         * new hardware input comes along. If the app isn't receiving hardware
         * input, it won't get the new key state. So ResyncKeyState() will
         * ensure that if the app is looping on GetKeyState(), it'll get the
         * right key state.
         */
        if (ptiCurrent->pq->QF_flags & QF_UPDATEKEYSTATE) {
            PostUpdateKeyStateEvent(ptiCurrent->pq);
        }
    }
    retval = _GetKeyState(vk);

    /*
     * Update the client side key state cache.
     */
    try {
        ptiCurrent->pClientInfo->dwKeyCache = gpsi->dwKeyCache;
        RtlCopyMemory(ptiCurrent->pClientInfo->afKeyState,
                      ptiCurrent->pq->afKeyState,
                      CBKEYCACHE);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ENDRECV_SHARED();
}

/**************************************************************************\
* NtUserQueryWindow
*
* 03-18-95 JimA         Created.
\**************************************************************************/

HANDLE NtUserQueryWindow(
    IN HWND hwnd,
    IN WINDOWINFOCLASS WindowInfo)
{
    PTHREADINFO ptiWnd;

    BEGINRECV_HWND_SHARED(HANDLE, NULL, hwnd);

    ptiWnd = GETPTI(pwnd);

    switch (WindowInfo) {
    case WindowProcess:

        /*
         * Special case console windows
         */
        if (ptiWnd->TIF_flags & TIF_CSRSSTHREAD &&
                pwnd->pcls->atomClassName == gatomConsoleClass) {
            retval = LongToHandle(_GetWindowLong(pwnd, 0));
        } else {
            retval = PsGetThreadProcessId(ptiWnd->pEThread);
        }
        break;
    case WindowThread:

        /*
         * Special case console windows
         */
        if (ptiWnd->TIF_flags & TIF_CSRSSTHREAD &&
                pwnd->pcls->atomClassName == gatomConsoleClass) {
            retval = LongToHandle(_GetWindowLong(pwnd, 4));
        } else {
            retval = GETPTIID(ptiWnd);
        }
        break;
    case WindowActiveWindow:
        retval = (HANDLE)HW(ptiWnd->pq->spwndActive);
        break;
    case WindowFocusWindow:
        retval = (HANDLE)HW(ptiWnd->pq->spwndFocus);
        break;
    case WindowIsHung:
        /*
         * If the window is a ghost window, report that the window is hung.
         */
        if ((GETFNID(pwnd) == FNID_GHOST)) {
            retval = LongToHandle(TRUE);
        } else {
            retval = LongToHandle(FHungApp(ptiWnd, CMSHUNGAPPTIMEOUT));
        }
        break;
    case WindowIsForegroundThread:
        retval = LongToHandle(ptiWnd->pq == gpqForeground);
        break;
    case WindowDefaultImeWindow:
        retval = HW(ptiWnd->spwndDefaultIme);
        break;
    case WindowDefaultInputContext:
        retval = PtoH(ptiWnd->spDefaultImc);
        break;
    default:
        RIPMSG1(RIP_WARNING,
                "QueryWindow called with invalid index 0x%x",
                WindowInfo);
        retval = (HANDLE)NULL;
        break;
    }

    ENDRECV_HWND_SHARED();
}

BOOL NtUserSBGetParms(  // API GetScrollInfo, SBM_GETSCROLLINFO
    IN HWND hwnd,
    IN int code,
    IN PSBDATA pw,
    IN OUT LPSCROLLINFO lpsi)
{
    SBDATA sbd;
    SCROLLINFO si;
    BEGINRECV_HWND_SHARED(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteScrollInfo(lpsi);

        /*
         * Probe the 4 DWORDS (MIN, MAX, PAGE, POS)
         */
        ProbeForRead(pw, sizeof(SBDATA), sizeof(DWORD));
        RtlCopyMemory(&sbd, pw, sizeof(sbd));
        RtlCopyMemory(&si, lpsi, sizeof(SCROLLINFO));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _SBGetParms(pwnd, code, &sbd, &si);
    try {
        RtlCopyMemory(lpsi, &si, sizeof(SCROLLINFO));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ENDRECV_HWND_SHARED();
}

BOOL NtUserBitBltSysBmp(
    IN HDC hdc,
    IN int xDest,
    IN int yDest,
    IN int cxDest,
    IN int cyDest,
    IN int xSrc,
    IN int ySrc,
    IN DWORD dwRop)
{
    BEGINRECV(BOOL, FALSE);

    /*
     * Note: This interface requires exclusive ownership of the User crit
     * sect in order to serialize use of HDCBITS. Only one thread at a time
     * may use a DC.
     */

    retval = GreBitBlt(hdc,
                       xDest,
                       yDest,
                       cxDest,
                       cyDest,
                       HDCBITS(),
                       xSrc,
                       ySrc,
                       dwRop,
                       0);

    ENDRECV();
}

HPALETTE NtUserSelectPalette(
    IN HDC hdc,
    IN HPALETTE hpalette,
    IN BOOL fForceBackground)
{
    BEGINRECV(HPALETTE, NULL)

    retval = _SelectPalette(hdc, hpalette, fForceBackground);

    ENDRECV();
}

/*
 * Message thunks
 */

LRESULT NtUserMessageCall(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN ULONG_PTR xParam,
    IN DWORD xpfnProc,
    IN BOOL bAnsi)
{
    BEGINRECV_HWNDLOCKFF(LRESULT, 0, hwnd, xpfnProc);

    if ((msg & ~MSGFLAG_MASK) >= WM_USER) {
        retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam);
    } else {
        retval = gapfnMessageCall[MessageTable[(msg & ~MSGFLAG_MASK)].iFunction](
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    }

    TRACE("NtUserMessageCall");
    ENDRECV_HWNDLOCKFF();
}

MESSAGECALL(DWORD)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnDWORD");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnDWORD");
    ENDRECV_MESSAGECALL();

}

MESSAGECALL(NCDESTROY)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnNCDESTROY");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnNCDESTROY");
    ENDRECV_MESSAGECALL();

}

MESSAGECALL(OPTOUTLPDWORDOPTOUTLPDWORD)
{
    DWORD dwwParam, dwlParam;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOPTOUTLPDWORDOPTOUTLPDWORD");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            (WPARAM)&dwwParam,
            (LPARAM)&dwlParam,
            xParam);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(wParam)) {
            ProbeAndWriteUlong((PULONG)wParam, dwwParam);
        }
        if (ARGUMENT_PRESENT(lParam)) {
            ProbeAndWriteUlong((PULONG)lParam, dwlParam);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);  // should messages with bad wParam/lParam SetLastError?
    }

    TRACE("fnOPTOUTLPDWORDOPTOUTLPDWORD");
    ENDRECV_MESSAGECALL();

}

MESSAGECALL(INOUTNEXTMENU)
{
    MDINEXTMENU mnm;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTNEXTMENU");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteMDINextMenu((PMDINEXTMENU)lParam);
        mnm = *(PMDINEXTMENU)lParam;

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&mnm,
                xParam);

    try {
        *(PMDINEXTMENU)lParam = mnm;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTNEXTMENU");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(DWORDOPTINLPMSG)
{
    MSG msgstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnDWORDOPTINLPMSG");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lParam)) {
            msgstruct = ProbeAndReadMessage((LPMSG)lParam);
            lParam = (LPARAM)&msgstruct;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnDWORDOPTINLPMSG");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(COPYGLOBALDATA)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnCOPYGLOBALDATA");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead((PVOID)lParam, wParam, sizeof(BYTE));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Data pointed to by lParam must be captured
     * in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnCOPYGLOBALDATA");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(COPYDATA)
{
    COPYDATASTRUCT cds;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnCOPYDATA");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lParam)) {
            cds = ProbeAndReadCopyDataStruct((PCOPYDATASTRUCT)lParam);
            if (cds.lpData)
                ProbeForRead(cds.lpData, cds.cbData, sizeof(BYTE));
            lParam = (LPARAM)&cds;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Data pointed to by cds.lpData must be captured
     * in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnCOPYDATA");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(SENTDDEMSG)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnSENTDDEMSG");

    UNREFERENCED_PARAMETER(bAnsi);

    if (xpfnProc == FNID_CALLWINDOWPROC) {
        retval = CALLPROC(xpfnProc)(pwnd,
                msg | MSGFLAG_DDE_SPECIAL_SEND,
                wParam, lParam, xParam);
    } else if ((ptiCurrent->TIF_flags & TIF_16BIT) &&
               (ptiCurrent->ptdb) &&
               (ptiCurrent->ptdb->hTaskWow)) {
        /*
         * Note that this function may modify msg by ORing in a bit in the
         * high word. This bit is ignored when thunking messages.
         * This allows the DdeTrackSendMessage() hook to be skipped - which
         * would cause an error - and instead allows this thunk to carry
         * the message all the way across.
         */
        retval = xxxDDETrackPostHook(&msg, pwnd, wParam, &lParam, TRUE);
        switch (retval) {
        case DO_POST:
            /*
             * Or in the MSGFLAG_DDE_SPECIAL_SEND so that
             * xxxSendMessageTimeout() will not pass this on to
             * xxxDdeTrackSendMsg() which would think it was evil.
             *
             * Since the SendMessage() thunks ignore the reserved bits
             * it will still get maped to the fnSENTDDEMSG callback thunk.
             */
            retval = CALLPROC(xpfnProc)(pwnd,
                    msg | MSGFLAG_DDE_SPECIAL_SEND,
                    wParam, lParam, xParam);
            break;

        case FAKE_POST:
        case FAIL_POST:
            retval = 0;
        }
    } else {
        MSGERROR(0);
    }

    TRACE("fnSENTDDEMSG");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(DDEINIT)
{
    PWND pwndFrom;
    TL tlpwndFrom;
    PDDEIMP pddei;
    PSECURITY_QUALITY_OF_SERVICE pqos;
    NTSTATUS Status;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnDDEINIT");

    UNREFERENCED_PARAMETER(bAnsi);

    ValidateHWND(pwndFrom, (HWND)wParam);
    ThreadLockAlwaysWithPti(ptiCurrent, pwndFrom, &tlpwndFrom);

    /*
     * Create temporary DDEIMP property for client window - this stays around
     * only during the initiate phase.
     */
    if ((pddei = (PDDEIMP)_GetProp(pwndFrom, PROP_DDEIMP, TRUE))
            == NULL) {
        pddei = (PDDEIMP)UserAllocPoolWithQuota(sizeof(DDEIMP), TAG_DDEd);
        if (pddei == NULL) {
            RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "fnDDEINIT: LocalAlloc failed.");
            MSGERRORCLEANUP(0);
        }
        pqos = (PSECURITY_QUALITY_OF_SERVICE)_GetProp(pwndFrom, PROP_QOS, TRUE);
        if (pqos == NULL) {
            pqos = &gqosDefault;
        }
        pddei->qos = *pqos;
        Status = SeCreateClientSecurity(PsGetCurrentThread(),
                pqos, FALSE, &pddei->ClientContext);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "SeCreateClientContext failed.");
            UserFreePool(pddei);
            MSGERRORCLEANUP(0);
        }
        pddei->cRefInit = 1;
        pddei->cRefConv = 0;
        InternalSetProp(pwndFrom, PROP_DDEIMP, pddei, PROPF_INTERNAL);
    } else {
        pddei->cRefInit++;      // cover broadcast case!
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    /*
     * Reaquire pddei incase pwndFrom was destroyed.
     */
    pddei = (PDDEIMP)_GetProp(pwndFrom, PROP_DDEIMP, TRUE);
    if (pddei != NULL) {
        /*
         * Decrement reference count from DDEImpersonate property and remove property.
         */
        pddei->cRefInit--;
        if (pddei->cRefInit == 0) {
            InternalRemoveProp(pwndFrom, PROP_DDEIMP, TRUE);
            if (pddei->cRefConv == 0) {
                SeDeleteClientSecurity(&pddei->ClientContext);
                UserFreePool(pddei);
            }
        }
    }

    CLEANUPRECV();
    ThreadUnlock(&tlpwndFrom);

    TRACE("fnDDEINIT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INPAINTCLIPBRD)
{
    PAINTSTRUCT ps;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINPAINTCLIPBRD");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ps = ProbeAndReadPaintStruct((PPAINTSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&ps,
            xParam);

    TRACE("fnINPAINTCLIPBRD");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INSIZECLIPBRD)
{
    RECT rc;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINSIZECLIPBRD");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect((PRECT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&rc,
            xParam);

    TRACE("fnINSIZECLIPBRD");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTDRAG)
{
    DROPSTRUCT ds;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTDRAG");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteDropStruct((PDROPSTRUCT)lParam);
        ds = *(PDROPSTRUCT)lParam;

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&ds,
                xParam);

    try {
        *(PDROPSTRUCT)lParam = ds;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTDRAG");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(GETDBCSTEXTLENGTHS)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnGETDBCSTEXTLENGTHS");

    UNREFERENCED_PARAMETER(lParam);

    /*
     * This is used by L/CB_GETTEXTLEN which should return -1 (L/CB_ERR)
     *  on error. If any error code path is introduced here, make sure we return the
     *  proper value.This is also used by WM_GETTEXTLEN.
     */

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            bAnsi,
            xParam);

    TRACE("fnGETDBCSTEXTLENGTHS");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPCREATESTRUCT)
{
    CREATESTRUCTEX csex;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPCREATESTRUCT");

    if (ARGUMENT_PRESENT(lParam)) {
        try {
            csex.cs = ProbeAndReadCreateStruct((LPCREATESTRUCTW)lParam);
            if (bAnsi) {
                ProbeForRead(csex.cs.lpszName, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strName,
                        (LPSTR)csex.cs.lpszName, (UINT)-1);
                if (IS_PTR(csex.cs.lpszClass)) {
                    ProbeForRead(csex.cs.lpszClass, sizeof(CHAR), sizeof(CHAR));
                    RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strClass,
                            (LPSTR)csex.cs.lpszClass, (UINT)-1);
                }
            } else {
                ProbeForRead(csex.cs.lpszName, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strName,
                        csex.cs.lpszName, (UINT)-1);
                if (IS_PTR(csex.cs.lpszClass)) {
                    ProbeForRead(csex.cs.lpszClass, sizeof(WCHAR), CHARALIGN);
                    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strClass,
                            csex.cs.lpszClass, (UINT)-1);
                }
            }
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    /*
     * Per Win95, do not allow NULL lpcreatestructs for WM_NCCREATE [51986]
     * Allowed for WM_CREATE in Win95 for ObjectVision
     */
    else if (msg == WM_NCCREATE) {
        MSGERROR(0) ;
    }

    /*
     * !!! Strings pointed to by cs.cs must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam ? (LPARAM)&csex : 0,
            xParam);

    TRACE("fnINLPCREATESTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPMDICREATESTRUCT)
{
    MDICREATESTRUCTEX mdics;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPMDICREATESTRUCT");

    /*
     * Probe arguments
     */
    try {
        mdics.mdics = ProbeAndReadMDICreateStruct((LPMDICREATESTRUCTW)lParam);

        if (bAnsi) {
            ProbeForRead(mdics.mdics.szTitle, sizeof(CHAR), sizeof(CHAR));
            RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&mdics.strTitle,
                    (LPSTR)mdics.mdics.szTitle, (UINT)-1);
            if (IS_PTR(mdics.mdics.szClass)) {
                ProbeForRead(mdics.mdics.szClass, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&mdics.strClass,
                        (LPSTR)mdics.mdics.szClass, (UINT)-1);
            } else {
                /*
                 * mdics.mdics.szClass may be Atom.
                 */
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&mdics.strClass,
                                       NULL, 0);
            }
        } else {
            ProbeForRead(mdics.mdics.szTitle, sizeof(WCHAR), CHARALIGN);
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&mdics.strTitle,
                    mdics.mdics.szTitle, (UINT)-1);
            if (IS_PTR(mdics.mdics.szClass)) {
                ProbeForRead(mdics.mdics.szClass, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&mdics.strClass,
                        mdics.mdics.szClass, (UINT)-1);
            } else {
                /*
                 * mdics.mdics.szClass may be Atom.
                 */
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&mdics.strClass,
                                       NULL, 0);
            }
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Strings pointed to by mdics must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&mdics,
            xParam);

    TRACE("fnINLPMDICREATESTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPSCROLLINFO)
{
    SCROLLINFO scrollinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPSCROLLINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteScrollInfo((LPSCROLLINFO)lParam);
        scrollinfo = *(LPSCROLLINFO)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&scrollinfo,
                xParam);

    try {
        *(LPSCROLLINFO)lParam = scrollinfo;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPSCROLLINFO");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPPOINT5)
{
    POINT5 pt5;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPPOINT5");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWritePoint5((LPPOINT5)lParam);
        pt5 = *(LPPOINT5)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&pt5,
                xParam);

    try {
        *(LPPOINT5)lParam = pt5;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPPOINT5");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINSTRING");

    /*
     * Don't allow any app to send a LB_DIR or CB_DIR with the postmsgs bit
     * set (ObjectVision does this). This is because there is actually a legal
     * case that we need to thunk of user posting a LB_DIR or CB_DIR
     * (DlgDirListHelper()). In the post case, we thunk the lParam (pointer
     * to a string) differently, and we track that post case with the
     * DDL_POSTMSGS bit. If an app sends a message with this bit, then our
     * thunking gets confused, so clear it here. Let's hope that no app
     * depends on this bit set when either of these messages are sent.
     *
     * These messages should return -1 on failure
     */
    switch (msg) {
    case LB_DIR:
    case CB_DIR:
        wParam &= ~DDL_POSTMSGS;
        /* Fall through */

    case LB_ADDFILE:
#if (LB_ERR != CB_ERR)
#error LB_ERR/CB_ERR conflict
#endif
        errret = LB_ERR;
        break;
    }

    /*
     * Probe arguments
     */
    try {
        if (bAnsi) {
            ProbeForRead((LPSTR)lParam, sizeof(CHAR), sizeof(CHAR));
            RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&str,
                    (LPSTR)lParam, (UINT)-1);
        } else {
            ProbeForRead((LPWSTR)lParam, sizeof(WCHAR), CHARALIGN);
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&str,
                    (LPWSTR)lParam, (UINT)-1);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! str.Buffer must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    TRACE("fnINSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INSTRINGNULL)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINSTRINGNULL");

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lParam)) {
        try {
            if (bAnsi) {
                ProbeForRead((LPSTR)lParam, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&str,
                        (LPSTR)lParam, (UINT)-1);
            } else {
                ProbeForRead((LPWSTR)lParam, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&str,
                        (LPWSTR)lParam, (UINT)-1);
            }
            lParam = (LPARAM)&str;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    /*
     * !!! str.Buffer must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnINSTRINGNULL");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INDEVICECHANGE)
{
    BOOL fPtr    = (BOOL)((wParam & 0x8000) == 0x8000);
    DWORD cbSize;
    PBYTE bfr = NULL;
    TL tlBuffer;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINDEVICECHANGE");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    if (fPtr && lParam) {
        struct _DEV_BROADCAST_HEADER *pHdr;
        PDEV_BROADCAST_DEVICEINTERFACE_W pInterfaceW;
        PDEV_BROADCAST_PORT_W pPortW;
        PDEV_BROADCAST_HANDLE pHandleW;
        try {
            pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;
            cbSize = ProbeAndReadUlong(&(pHdr->dbcd_size));
            if (cbSize < sizeof(*pHdr)) {
                MSGERROR(ERROR_INVALID_PARAMETER);
            }
            ProbeForRead(pHdr, cbSize, sizeof(BYTE));

            bfr = UserAllocPoolWithQuota(cbSize+2, TAG_DEVICECHANGE); // add space for trailing NULL for test
            if (bfr == NULL) {
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "fnINDEVICECHANGE: LocalAlloc failed.");
                MSGERRORCLEANUP(0);
            }

            ThreadLockPool(ptiCurrent, bfr, &tlBuffer);

            RtlCopyMemory(bfr,  (PBYTE)lParam,
                        cbSize);
            ((PWSTR)bfr)[cbSize/sizeof(WCHAR)] = 0;  // trailing null to halt wcslen scan
            lParam = (LPARAM)bfr;
            pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;
            if (pHdr->dbcd_size != cbSize) {
                MSGERRORCLEANUP(0);
            }
            switch(pHdr->dbcd_devicetype) {
            case DBT_DEVTYP_PORT:
                pPortW = (PDEV_BROADCAST_PORT_W)lParam;
                if ((1+wcslen(pPortW->dbcp_name))*sizeof(WCHAR) + FIELD_OFFSET(DEV_BROADCAST_PORT_W, dbcp_name) > cbSize) {
                    MSGERRORCLEANUP(0);
                }
                break;
            case DBT_DEVTYP_DEVICEINTERFACE:
                pInterfaceW = (PDEV_BROADCAST_DEVICEINTERFACE_W)lParam;
                if ((1+wcslen(pInterfaceW->dbcc_name))*sizeof(WCHAR) + FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_W, dbcc_name) > cbSize) {
                    MSGERRORCLEANUP(0);
                }
                break;
            case DBT_DEVTYP_HANDLE:
                pHandleW = (PDEV_BROADCAST_HANDLE)lParam;
            /*
             * Check if there is any text.
             */

                if (wParam != DBT_CUSTOMEVENT) {
                    if (FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid) > cbSize) {
                        MSGERRORCLEANUP(0);
                    }
                    break;
                }
                if (pHandleW->dbch_nameoffset < 0) {
                    if (FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data) > cbSize) {
                        MSGERRORCLEANUP(0);
                    }
                    break;
                }
                if (pHandleW->dbch_nameoffset & (CHARALIGN - 1)) {
                    ExRaiseDatatypeMisalignment();                                                            \
                }
                if ((DWORD)(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data) + pHandleW->dbch_nameoffset) > cbSize) {
                    MSGERRORCLEANUP(0);
                }
                if (FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data) + pHandleW->dbch_nameoffset +
                    (1+wcslen((LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset)))*sizeof(WCHAR) >
                    cbSize) {
                    MSGERRORCLEANUP(0);
                }
                break;

            }

        } except (StubExceptionHandler(FALSE)) {
            MSGERRORCLEANUP(0);
        }

    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    CLEANUPRECV();
    if (bfr)
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);

    TRACE("fnINDEVICECHANGE");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTNCCALCSIZE)
{
    NCCALCSIZE_PARAMS params;
    WINDOWPOS pos;
    PWINDOWPOS pposClient;
    RECT rc;
    LPARAM lParamLocal;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTNCCALCSIZE");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        if (wParam != 0) {
            ProbeForWriteNCCalcSize((LPNCCALCSIZE_PARAMS)lParam);
            params = *(LPNCCALCSIZE_PARAMS)lParam;
            ProbeForWriteWindowPos(params.lppos);
            pposClient = params.lppos;
            pos = *params.lppos;
            params.lppos = &pos;
            lParamLocal = (LPARAM)&params;
        } else {
            ProbeForWriteRect((LPRECT)lParam);
            rc = *(LPRECT)lParam;
            lParamLocal = (LPARAM)&rc;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParamLocal,
                xParam);

    try {
        if (wParam != 0) {
            *(LPNCCALCSIZE_PARAMS)lParam = params;
            ((LPNCCALCSIZE_PARAMS)lParam)->lppos = pposClient;
            *pposClient = pos;
        } else {
            *(LPRECT)lParam = rc;
        }
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTNCCALCSIZE");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTSTYLECHANGE)
{
    STYLESTRUCT ss;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTSTYLECHANGE");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteStyleStruct((LPSTYLESTRUCT)lParam);
        ss = *(LPSTYLESTRUCT)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&ss,
                xParam);

    try {
        *(LPSTYLESTRUCT)lParam = ss;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTSTYLECHANGE");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPRECT)
{
    RECT rc;

    BEGINRECV_MESSAGECALL((msg == LB_GETITEMRECT ? LB_ERR : 0));
    TRACETHUNK("fnINOUTLPRECT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteRect((PRECT)lParam);
        rc = *(PRECT)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&rc,
                xParam);

    try {
        *(PRECT)lParam = rc;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPRECT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPSCROLLINFO)
{
    SCROLLINFO scrollinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPSCROLLINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&scrollinfo,
            xParam);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure((LPSCROLLINFO)lParam, scrollinfo, SCROLLINFO);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("fnOUTLPSCROLLINFO");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPRECT)
{
    RECT rc;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPRECT");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&rc,
            xParam);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure((PRECT)lParam, rc, RECT);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("fnOUTLPRECT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPCOMPAREITEMSTRUCT)
{
    COMPAREITEMSTRUCT compareitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPCOMPAREITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        compareitemstruct = ProbeAndReadCompareItemStruct((PCOMPAREITEMSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&compareitemstruct,
            xParam);

    TRACE("fnINLPCOMPAREITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPDELETEITEMSTRUCT)
{
    DELETEITEMSTRUCT deleteitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPDELETEITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        deleteitemstruct = ProbeAndReadDeleteItemStruct((PDELETEITEMSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&deleteitemstruct,
            xParam);

    TRACE("fnINLPDELETEITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPHLPSTRUCT)
{
    HLP hlp;
    LPHLP phlp = NULL;
    TL tlBuffer;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPHLPSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        hlp = ProbeAndReadHelp((LPHLP)lParam);
        if (hlp.cbData < sizeof(HLP)) {
            MSGERROR(0);
        }
        phlp = UserAllocPoolWithQuota(hlp.cbData, TAG_SYSTEM);
        if (phlp == NULL) {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }
        ThreadLockPool(ptiCurrent, phlp, &tlBuffer);
        RtlCopyMemory(phlp, (PVOID)lParam, hlp.cbData);
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)phlp,
            xParam);

    CLEANUPRECV();
    if (phlp) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    }

    TRACE("fnINLPHLPSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPHELPINFOSTRUCT)
{
    HELPINFO helpinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPHELPINFOSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        helpinfo = ProbeAndReadHelpInfo((LPHELPINFO)lParam);
        if (helpinfo.cbSize != sizeof(HELPINFO)) {
            RIPMSG1(RIP_WARNING, "HELPINFO.cbSize %d is wrong", helpinfo.cbSize);
            MSGERROR(ERROR_INVALID_PARAMETER);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&helpinfo,
            xParam);

    TRACE("fnINLPHELPINFOSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPDRAWITEMSTRUCT)
{
    DRAWITEMSTRUCT drawitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPDRAWITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        drawitemstruct = ProbeAndReadDrawItemStruct((PDRAWITEMSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&drawitemstruct,
            xParam);

    TRACE("fnINLPDRAWITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPMEASUREITEMSTRUCT)
{
    MEASUREITEMSTRUCT measureitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPMEASUREITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteMeasureItemStruct((PMEASUREITEMSTRUCT)lParam);
        measureitemstruct = *(PMEASUREITEMSTRUCT)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&measureitemstruct,
                xParam);

    try {
        *(PMEASUREITEMSTRUCT)lParam = measureitemstruct;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPMEASUREITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTSTRING");

    /*
     * Probe all arguments
     */
    try {
        str.bAnsi = bAnsi;
        str.MaximumLength = (ULONG)wParam;
        if (!bAnsi) {
            str.MaximumLength *= sizeof(WCHAR);
        }
        str.Length = 0;
        str.Buffer = (PVOID)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! String buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * A dialog function returning FALSE means no text to copy out,
     * but an empty string also has retval == 0: put a null char in
     * pstr for the latter case.
     */
    if (!retval && wParam != 0) {
        try {
            NullTerminateString((PVOID)lParam, bAnsi);
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("fnOUTSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTDWORDINDWORD)
{
    DWORD dw;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTDWORDINDWORD");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            (WPARAM)&dw,
            lParam,
            xParam);

    /*
     * Probe wParam
     */
    try {
        ProbeAndWriteUlong((PULONG)wParam, dw);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("fnOUTDWORDINDWORD");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INCNTOUTSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINCNTOUTSTRING");

    /*
     * Probe arguments
     */
    try {
        str.bAnsi = bAnsi;
        str.MaximumLength = ProbeAndReadUshort((LPWORD)lParam);
        if (!bAnsi) {
            str.MaximumLength *= sizeof(WCHAR);
        }
        if (str.MaximumLength < sizeof(WORD)) {
            RIPMSG0(RIP_WARNING, "fnINCNTOUTSTRING buffer is too small");
            MSGERROR(0);
        }
        str.Length = 0;
        str.Buffer = (LPBYTE)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! String buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * A dialog function returning FALSE means no text to copy out,
     * but an empty string also has retval == 0: put a null char in
     * pstr for the latter case.
     */
    if (!retval) {
        try {
            NullTerminateString((PVOID)lParam, bAnsi);
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("fnINCNTOUTSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INCNTOUTSTRINGNULL)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINCNTOUTSTRINGNULL");

    /*
     * Probe arguments
     */
    try {
        if (wParam < 2) {       // This prevents a possible GP
            MSGERROR(0);
        }

        str.bAnsi = bAnsi;
        str.MaximumLength = (ULONG)wParam;
        if (!bAnsi) {
            str.MaximumLength *= sizeof(WCHAR);
        }
        str.Length = 0;
        str.Buffer = (LPBYTE)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
        *((LPWSTR)str.Buffer) = 0;    // mark incase message is not handled
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! String buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    TRACE("fnINCNTOUTSTRINGNULL");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(POUTLPINT)
{
    BEGINRECV_MESSAGECALL(LB_ERR);
    /*
     * If we use this for other messages, then that return value might not be appropriate.
     */
    UserAssert(msg == LB_GETSELITEMS);
    TRACETHUNK("fnPOUTLPINT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        ProbeForWriteBuffer((LPINT)lParam, wParam, sizeof(BYTE));
#else
        ProbeForWriteBuffer((LPINT)lParam, wParam, sizeof(INT));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnPOUTLPINT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(POPTINLPUINT)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnPOPTINLPUINT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        if (lParam)
            ProbeForReadBuffer((LPUINT)lParam, wParam, sizeof(BYTE));
#else
        if (lParam)
            ProbeForReadBuffer((LPUINT)lParam, wParam, sizeof(DWORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Data pointed to by lParam must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnPOPTINLPUINT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPWINDOWPOS)
{
    WINDOWPOS pos;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPWINDOWPOS");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteWindowPos((PWINDOWPOS)lParam);
        pos = *(PWINDOWPOS)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&pos,
                xParam);

    try {
        *(PWINDOWPOS)lParam = pos;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPWINDOWPOS");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPWINDOWPOS)
{
    WINDOWPOS pos;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPWINDOWPOS");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        pos = ProbeAndReadWindowPos((PWINDOWPOS)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&pos,
                xParam);

    TRACE("fnINLPWINDOWPOS");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLBOXSTRING)
{
    BEGINRECV_MESSAGECALL(LB_ERR);
    TRACETHUNK("fnINLBOXSTRING");

    if (!(pwnd->style & LBS_HASSTRINGS) &&
            (pwnd->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {
        retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam);
    } else if (msg == LB_FINDSTRING) {
        retval = NtUserfnINSTRINGNULL(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    } else {
        retval = NtUserfnINSTRING(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    }

    TRACE("fnINLBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLBOXSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(LB_ERR);
    TRACETHUNK("fnOUTLBOXSTRING");

    /*
     * Need to get the string length ahead of time. This isn't passed in
     * with this message. Code assumes app already knows the size of
     * the string and has passed a pointer to a buffer of adequate size.
     * To do client/server copying of this string, we need to ahead of
     * time the Unicode size of this string. We add one character because
     * GETTEXTLEN excludes the null terminator.
     */
    retval = NtUserfnGETDBCSTEXTLENGTHS(
            pwnd,
            LB_GETTEXTLEN,
            wParam,
            lParam,
            xParam,
            xpfnProc,
            /*IS_DBCS_ENABLED() &&*/ bAnsi);   // HiroYama: LATER
    if (retval == LB_ERR)
        MSGERROR(0);
    retval++;

    /*
     * Probe all arguments
     */
    try {
        str.bAnsi = bAnsi;
        if (bAnsi) {
            str.MaximumLength = (ULONG)retval;
        } else {
            str.MaximumLength = (ULONG)retval * sizeof(WCHAR);
        }
        str.Length = 0;
        str.Buffer = (PVOID)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * If the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style, then a 32-bits of application data has been obtained,
     * not a string.
     */
    if (!(pwnd->style & LBS_HASSTRINGS) &&
            (pwnd->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {
        if (bAnsi) {
            retval = sizeof(ULONG_PTR)/sizeof(CHAR);     // 4 CHARs just like win3.1
        } else {
            retval = sizeof(ULONG_PTR)/sizeof(WCHAR);    // 2 WCHARs
        }
    }

    TRACE("fnOUTLBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INCBOXSTRING)
{
    BEGINRECV_MESSAGECALL(CB_ERR);
    TRACETHUNK("fnINCBOXSTRING");

    if (!(pwnd->style & CBS_HASSTRINGS) &&
            (pwnd->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {
        retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam);
    } else if (msg == CB_FINDSTRING) {
        retval =  NtUserfnINSTRINGNULL(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    } else {
        retval = NtUserfnINSTRING(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    }

    TRACE("fnINCBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTCBOXSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(CB_ERR);
    TRACETHUNK("fnOUTCBOXSTRING");

    /*
     * Need to get the string length ahead of time. This isn't passed in
     * with this message. Code assumes app already knows the size of
     * the string and has passed a pointer to a buffer of adequate size.
     * To do client/server copying of this string, we need to ahead of
     * time the size of this string. We add one character because
     * GETTEXTLEN excludes the null terminator.
     */
    retval = NtUserfnGETDBCSTEXTLENGTHS(
            pwnd,
            CB_GETLBTEXTLEN,
            wParam,
            lParam,
            xParam,
            xpfnProc,
            /*IS_DBCS_ENABLED() &&*/ bAnsi);   // HiroYama: LATER
    if (retval == CB_ERR)
        MSGERROR(0);
    retval++;

    /*
     * Probe all arguments
     */
    try {
        str.bAnsi = bAnsi;
        if (bAnsi) {
            str.MaximumLength = (ULONG)retval;
        } else {
            str.MaximumLength = (ULONG)retval * sizeof(WCHAR);
        }
        str.Length = 0;
        str.Buffer = (PVOID)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * If the control is ownerdraw and does not have the CBS_HASSTRINGS
     * style, then a 32-bits of application data has been obtained,
     * not a string.
     */
    if (!(pwnd->style & CBS_HASSTRINGS) &&
            (pwnd->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {
        if (bAnsi) {
            retval = sizeof(ULONG_PTR)/sizeof(CHAR);     // 4 CHARs just like win3.1
        } else {
            retval = sizeof(ULONG_PTR)/sizeof(WCHAR);    // 2 WCHARs
        }
    }

    TRACE("fnOUTCBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INWPARAMCHAR)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINWPARAMCHAR");

    /*
     * The server always expects the characters to be unicode so
     * if this was generated from an ANSI routine convert it to Unicode
     */
    if (bAnsi) {
        if (msg == WM_CHARTOITEM || msg == WM_MENUCHAR) {
            WPARAM dwT = wParam & 0xFFFF;                // mask of caret pos
            RtlMBMessageWParamCharToWCS(msg, &dwT);     // convert key portion
            wParam = MAKELONG(LOWORD(dwT),HIWORD(wParam));  // rebuild pos & key wParam
        } else {
            RtlMBMessageWParamCharToWCS(msg, &wParam);
        }
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnINWPARAMCHAR");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(KERNELONLY)
{
    BEGINRECV_MESSAGECALL(0);

    TRACETHUNK("fnKERNELONLY");

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(xParam);
    UNREFERENCED_PARAMETER(xpfnProc);
    UNREFERENCED_PARAMETER(bAnsi);

    RIPMSG0(RIP_WARNING,
            "Message sent from client to kernel for a process which has only kernel side");

    retval = 0;

    TRACE("fnKERNELONLY");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(IMECONTROL)
{
    CANDIDATEFORM   CandForm;
    COMPOSITIONFORM CompForm;
    LOGFONTW        LogFontW;
    LPARAM          lData = lParam;
    PSOFTKBDDATA    pSoftKbdData = NULL;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnIMECONTROL");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * wParam range validation:
     * No need to check lower limit, 'cause we assume IMC_FIRST == 0
     * and wParam is unsigned.
     */
    #if (IMC_FIRST != 0)
    #error IMC_FIRST: unexpected value
    #endif
    if (msg != WM_IME_CONTROL || wParam > IMC_LAST) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        switch (wParam) {
        case IMC_GETCANDIDATEPOS:
            ProbeForWriteCandidateForm((PCANDIDATEFORM)lParam);
            break;

        case IMC_GETCOMPOSITIONWINDOW:
            ProbeForWriteCompositionForm((PCOMPOSITIONFORM)lParam);
            break;

        case IMC_GETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:
            ProbeForWriteLogFontW((PLOGFONTW)lParam);
            break;

        case IMC_SETCANDIDATEPOS:
            CandForm = ProbeAndReadCandidateForm((PCANDIDATEFORM)lParam);
            lData = (LPARAM)&CandForm;
            break;

        case IMC_SETCOMPOSITIONWINDOW:
            CompForm = ProbeAndReadCompositionForm((PCOMPOSITIONFORM)lParam);
            lData = (LPARAM)&CompForm;
            break;

        case IMC_SETCOMPOSITIONFONT:
            LogFontW = ProbeAndReadLogFontW((PLOGFONTW)lParam);
            lData = (LPARAM)&LogFontW;
            break;

        case IMC_SETSOFTKBDDATA:
            pSoftKbdData = ProbeAndCaptureSoftKbdData((PSOFTKBDDATA)lParam);
            if (pSoftKbdData == NULL)
                MSGERROR(0);
            lData = (LPARAM)pSoftKbdData;
            break;

        default:
            break;
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lData,
                xParam);

    CLEANUPRECV();
    if (pSoftKbdData != NULL) {
        UserFreePool(pSoftKbdData);
    }

    TRACE("fnIMECONTROL");
    ENDRECV_MESSAGECALL();
}

#ifdef LATER
MESSAGECALL(IMEREQUEST)
{
    LPARAM lData = lParam;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnIMEREQUEST");

    UNREFERENCED_PARAMETER(bAnsi);

    if (GETPTI(pwnd) != PtiCurrent()) {
        /*
         * Does not allow to send WM_IME_REQUEST to
         * the different thread.
         */
        MSGERROR(ERROR_WINDOW_OF_OTHER_THREAD);
    }

    /*
     * Probe arguments
     */
    try {
        switch (wParam) {
        case IMR_COMPOSITIONWINDOW:
            ProbeForWriteCompositionForm((PCOMPOSITIONFORM)lParam);
            break;

        case IMR_CANDIDATEWINDOW:
            ProbeForWriteCandidateForm((PCANDIDATEFORM)lParam);
            break;

        case IMR_COMPOSITIONFONT:
            ProbeForWriteLogFontW((PLOGFONTW)lParam);
            break;

        case IMR_RECONVERTSTRING:
        case IMR_DOCUMENTFEED:
            if (lParam) {
                ProbeForWriteReconvertString((LPRECONVERTSTRING)lParam);
            }
            break;

        case IMR_CONFIRMRECONVERTSTRING:
            //ProbeAndCaptureReconvertString((LPRECONVERTSTRING)lParam);
            //ProbeForWriteReconvertString((LPRECONVERTSTRING)lParam);
            ProbeForReadReconvertString((LPRECONVERTSTRING)lParam);
            break;

        case IMR_QUERYCHARPOSITION:
            ProbeForWriteImeCharPosition((LPPrivateIMECHARPOSITION)lParam);
            break;

        default:
            MSGERROR(0);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lData,
                xParam);

    CLEANUPRECV();

    TRACE("fnIMEREQUEST");
    ENDRECV_MESSAGECALL();
}
#endif

/*
 * Hook stubs
 */

LRESULT NtUserfnHkINLPCBTCREATESTRUCT(
    IN UINT msg,
    IN WPARAM wParam,
    IN LPCBT_CREATEWND pcbt,
    IN BOOL bAnsi)
{
    CBT_CREATEWND cbt;
    CREATESTRUCTEX csex;
    LPCREATESTRUCT lpcsSave;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        cbt = ProbeAndReadCBTCreateStruct(pcbt);
        ProbeForWriteCreateStruct(cbt.lpcs);
        lpcsSave = cbt.lpcs;
        csex.cs = *cbt.lpcs;
        cbt.lpcs = (LPCREATESTRUCT)&csex;
        if (bAnsi) {
            ProbeForRead(csex.cs.lpszName, sizeof(CHAR), sizeof(CHAR));
            RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strName,
                    (LPSTR)csex.cs.lpszName, (UINT)-1);
            if (IS_PTR(csex.cs.lpszClass)) {
                ProbeForRead(csex.cs.lpszClass, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strClass,
                        (LPSTR)csex.cs.lpszClass, (UINT)-1);
            }
        } else {
            ProbeForRead(csex.cs.lpszName, sizeof(WCHAR), CHARALIGN);
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strName,
                    csex.cs.lpszName, (UINT)-1);
            if (IS_PTR(csex.cs.lpszClass)) {
                ProbeForRead(csex.cs.lpszClass, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strClass,
                        csex.cs.lpszClass, (UINT)-1);
            }
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
                msg,
                wParam,
                (LPARAM)&cbt);

    try {
        pcbt->hwndInsertAfter = cbt.hwndInsertAfter;
        lpcsSave->x = cbt.lpcs->x;
        lpcsSave->y = cbt.lpcs->y;
        lpcsSave->cx = cbt.lpcs->cx;
        lpcsSave->cy = cbt.lpcs->cy;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserfnHkINLPCBTCREATESTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPRECT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPRECT lParam)
{
    RECT rc;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect((PRECT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&rc);

    TRACE("NtUserfnHkINLPRECT");
    ENDRECV_HOOKCALL();
}

#ifdef REDIRECTION

LRESULT NtUserfnHkINLPPOINT(
    IN DWORD   nCode,
    IN WPARAM  wParam,
    IN LPPOINT lParam)
{
    POINT pt;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        pt = ProbeAndReadPoint((LPPOINT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&pt);

    TRACE("NtUserfnHkINLPPOINT");
    ENDRECV_HOOKCALL();
}

/**************************************************************************\
* NtUserGetProcessRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserGetProcessRedirectionMode(
    HANDLE hProcess,
    PBOOL pbRedirectionMode)
{
    PEPROCESS Process;
    PPROCESSINFO ppi;

    BEGINRECV(BOOL, FALSE);

   if (hProcess == NtCurrentProcess()) {
        ppi = PpiCurrent();
    } else {
        NTSTATUS Status;
        Status = ObReferenceObjectByHandle(hProcess,
                                           PROCESS_QUERY_INFORMATION,
                                           *PsProcessType,
                                           UserMode,
                                           &Process,
                                           NULL);

        if (!NT_SUCCESS(Status)) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetProcessRedirectionMode: Failed with Process handle == %X, Status = %x",
                    hProcess, Status);
            MSGERROR(0);
        }

        /*
         * Make sure they are from the same session.
         */
        if (PsGetProcessSessionId(Process) != gSessionId) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetProcessRedirectionMode: Different session. Failed with Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        ppi = PpiFromProcess(Process);

        if (ppi == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetProcessRedirectionMode: Non GUI process. Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        try {
            ProbeAndWriteLong(pbRedirectionMode, ppi->dwRedirection & PF_REDIRECTED);
            ObDereferenceObject(Process);
        } except (StubExceptionHandler(TRUE)) {
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        retval = TRUE;
    }
    TRACE("NtUserGetProcessRedirectionMode");
    ENDRECV();

}

/**************************************************************************\
* NtUserSetProcessRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserSetProcessRedirectionMode(
    HANDLE hProcess,
    BOOL bRedirectionMode)
{
    PEPROCESS Process;
    PPROCESSINFO ppi;

    BEGINRECV(BOOL, FALSE);

    /*
     * A host process can not redirect itself.
     */
    if (hProcess == NtCurrentProcess()) {
        RIPERR0(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "NtUserSetProcessRedirectionMode: A process tried to change redirection mode for itself.");
        MSGERROR(0);
    } else {
        NTSTATUS Status;
        Status = ObReferenceObjectByHandle(hProcess,
                                           PROCESS_SET_INFORMATION,
                                           *PsProcessType,
                                           UserMode,
                                           &Process,
                                           NULL);
        if (!NT_SUCCESS(Status)) {
            RIPERR2(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "NtUserSetProcessRedirectionMode: Failed with Process handle == 0x%x, Status = 0x%x",
                    hProcess,
                    Status);
            MSGERROR(0);
        }

        /*
         * Cannot allow CSRSS to be redirected.
         */
        if (Process == gpepCSRSS) {
            ObDereferenceObject(Process);
            MSGERROR(ERROR_ACCESS_DENIED);
        }

        /*
         * Make sure they are from the same session.
         */
        if (PsGetProcessSessionId(Process) != gSessionId) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSetProcessRedirectionMode: Different session. Failed with Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        ppi = PpiFromProcess(Process);

        if (ppi == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSetProcessRedirectionMode: Non GUI process. Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        /*
         * Fail if the target process is a redirection host.
         */
        if (ppi-> dwRedirection & PF_REDIRECTIONHOST) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSetProcessRedirectionMode: trying to redirect a host process == %X, Status = %x",
                    hProcess, Status);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        PpiCurrent()->dwRedirection = PF_REDIRECTIONHOST;
        if (bRedirectionMode) {
            ppi->dwRedirection |= PF_REDIRECTED;
        } else {
            ppi->dwRedirection &= ~PF_REDIRECTED;
        }

        xxxSetProcessRedirectionMode(bRedirectionMode, ppi);

        ObDereferenceObject(Process);

        retval = TRUE;
    }
    TRACE("NtUserSetProcessRedirectionMode");
    ENDRECV();

}

/**************************************************************************\
* NtUserGetDesktopRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserGetDesktopRedirectionMode(
    HDESK hDesk,
    PBOOL pbRedirectionMode)
{
    PDESKTOP pDesk;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    Status = ValidateHdesk(hDesk, UserMode, DESKTOP_QUERY_INFORMATION, &pDesk);

    if (!NT_SUCCESS(Status)) {
        RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetDesktopRedirectionMode: Failed with Desktop handle == %X, Status = %x",
                hDesk, Status);
        MSGERROR(0);
    }
    try {
        ProbeAndWriteLong(pbRedirectionMode, pDesk->dwDTFlags & DF_REDIRECTED);
        ObDereferenceObject(pDesk);
    } except (StubExceptionHandler(TRUE)) {
        ObDereferenceObject(pDesk);
        MSGERROR(0);
    }

    retval = TRUE;

    TRACE("NtUserGetDesktopRedirectionMode");
    ENDRECV();
}

/**************************************************************************\
* NtUserSetDesktopRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserSetDesktopRedirectionMode(
    HDESK hDesk,
    BOOL bRedirectionMode)
{
    PDESKTOP pDesk;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    Status = ValidateHdesk(hDesk, UserMode, DESKTOP_REDIRECT, &pDesk);

    if (!NT_SUCCESS(Status)) {
        RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetDesktopRedirectionMode: Failed with Desktop handle == %X, Status = %x",
                hDesk, Status);
        MSGERROR(0);
    }

    PpiCurrent()->dwRedirection = PF_REDIRECTIONHOST;
    if (bRedirectionMode) {
        pDesk->dwDTFlags |= DF_REDIRECTED;
    } else {
        pDesk->dwDTFlags &= ~DF_REDIRECTED;
    }

    xxxSetDesktopRedirectionMode(bRedirectionMode, pDesk, PpiCurrent());

    ObDereferenceObject(pDesk);

    retval = TRUE;

    TRACE("NtUserSetDesktopRedirectionMode");
    ENDRECV();
}
#endif // REDIRECTION

LRESULT NtUserfnHkINLPMSG(
    IN int iHook,
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMSG lParam)
{
    MSG msg;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage((PMSG)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&msg);

    /*
     * If this is GetMessageHook, the hook should be
     * able to change the message, as stated in SDK document.
     */
    if (iHook == WH_GETMESSAGE) {
        try {
            *(PMSG)lParam = msg;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserfnHkINLPMSG");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPDEBUGHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPDEBUGHOOKINFO lParam)
{
    DEBUGHOOKINFO hookinfo;
    DWORD cbDbgLParam;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        hookinfo = ProbeAndReadHookInfo((PDEBUGHOOKINFO)lParam);

        cbDbgLParam = GetDebugHookLParamSize(wParam, &hookinfo);
        ProbeForRead(hookinfo.lParam, cbDbgLParam, DATAALIGN);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&hookinfo);

    TRACE("NtUserfnHkINLPDEBUGHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkOPTINLPEVENTMSG(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPEVENTMSGMSG lParam OPTIONAL)
{
    EVENTMSG event;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lParam)) {
        try {
            ProbeForWriteEvent((LPEVENTMSGMSG)lParam);
            event = *(LPEVENTMSGMSG)lParam;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)(lParam ? &event : NULL));

    if (ARGUMENT_PRESENT(lParam)) {
        try {
            *(LPEVENTMSGMSG)lParam = event;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserfnHkINLPEVENTMSG");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPMOUSEHOOKSTRUCTEX(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMOUSEHOOKSTRUCTEX lParam)
{
    MOUSEHOOKSTRUCTEX mousehook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        mousehook = ProbeAndReadMouseHook((PMOUSEHOOKSTRUCTEX)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&mousehook);

    TRACE("NtUserfnHkINLPMOUSEHOOKSTRUCTEX");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPKBDLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPKBDLLHOOKSTRUCT lParam)
{
    KBDLLHOOKSTRUCT kbdhook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        kbdhook = ProbeAndReadKbdHook((PKBDLLHOOKSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&kbdhook);

    TRACE("NtUserfnHkINLPKBDLLHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPMSLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMSLLHOOKSTRUCT lParam)
{
    MSLLHOOKSTRUCT msllhook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        msllhook = ProbeAndReadMsllHook((PMSLLHOOKSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&msllhook);

    TRACE("NtUserfnHkINLPMSLLHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}

#ifdef REDIRECTION
LRESULT NtUserfnHkINLPHTHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPHTHOOKSTRUCT lParam)
{
    HTHOOKSTRUCT hthook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        hthook = ProbeAndReadHTHook((PHTHOOKSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&hthook);

    TRACE("NtUserfnHkINLPHTHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}
#endif // REDIRECTION

LRESULT NtUserfnHkINLPCBTACTIVATESTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPCBTACTIVATESTRUCT lParam)
{
    CBTACTIVATESTRUCT cbtactivate;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        cbtactivate = ProbeAndReadCBTActivateStruct((LPCBTACTIVATESTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&cbtactivate);

    TRACE("NtUserfnHkINLPCBTACTIVATESTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserCallNextHookEx(
    int nCode,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bAnsi)
{
    BEGINRECV(LRESULT, 0);

    if (PtiCurrent()->sphkCurrent == NULL) {
        MSGERROR(0);
    }

    switch (PtiCurrent()->sphkCurrent->iHook) {
    case WH_CBT:
        /*
         * There are many different types of CBT hooks!
         */
        switch (nCode) {
        case HCBT_CLICKSKIPPED:
            goto MouseHook;
            break;

        case HCBT_CREATEWND:
            /*
             * This hook type points to a CREATESTRUCT, so we need to
             * be fancy it's thunking, because a CREATESTRUCT contains
             * a pointer to CREATEPARAMS which can be anything... so
             * funnel this through our message thunks.
             */
            retval =  NtUserfnHkINLPCBTCREATESTRUCT(
                    nCode,
                    wParam,
                    (LPCBT_CREATEWND)lParam,
                    bAnsi);
            break;

#ifdef REDIRECTION
        case HCBT_GETCURSORPOS:

            /*
             * This hook type points to a POINT structure.
             */
            retval = NtUserfnHkINLPPOINT(nCode, wParam, (LPPOINT)lParam);
            break;
#endif // REDIRECTION

        case HCBT_MOVESIZE:

            /*
             * This hook type points to a RECT structure.
             */
            retval = NtUserfnHkINLPRECT(nCode, wParam, (LPRECT)lParam);
            break;

        case HCBT_ACTIVATE:
            /*
             * This hook type points to a CBTACTIVATESTRUCT
             */
            retval = NtUserfnHkINLPCBTACTIVATESTRUCT(nCode, wParam,
                    (LPCBTACTIVATESTRUCT)lParam);
            break;

        default:
            /*
             * The rest of the cbt hooks are all dword parameters.
             */
            retval = xxxCallNextHookEx(
                    nCode,
                    wParam,
                    lParam);
            break;
        }
        break;

    case WH_FOREGROUNDIDLE:
    case WH_KEYBOARD:
    case WH_SHELL:
        /*
         * These are dword parameters and are therefore real easy.
         */
        retval = xxxCallNextHookEx(
                nCode,
                wParam,
                lParam);
        break;

    case WH_MSGFILTER:
    case WH_SYSMSGFILTER:
    case WH_GETMESSAGE:
        /*
         * These take an lpMsg as their last parameter. Since these are
         * exclusively posted parameters, and since nowhere on the server
         * do we post a message with a pointer to some other structure in
         * it, the lpMsg structure contents can all be treated verbatim.
         */
        retval = NtUserfnHkINLPMSG(PtiCurrent()->sphkCurrent->iHook, nCode, wParam, (LPMSG)lParam);
        break;

    case WH_JOURNALPLAYBACK:
    case WH_JOURNALRECORD:
        /*
         * These take an OPTIONAL lpEventMsg.
         */
        retval = NtUserfnHkOPTINLPEVENTMSG(nCode, wParam, (LPEVENTMSGMSG)lParam);
        break;

    case WH_DEBUG:
        /*
         * This takes an lpDebugHookStruct.
         */
        retval = NtUserfnHkINLPDEBUGHOOKSTRUCT(nCode, wParam, (LPDEBUGHOOKINFO)lParam);
        break;

    case WH_KEYBOARD_LL:
        /*
         * This takes an lpKbdllHookStruct.
         */
        retval = NtUserfnHkINLPKBDLLHOOKSTRUCT(nCode, wParam, (LPKBDLLHOOKSTRUCT)lParam);
        break;

    case WH_MOUSE_LL:
        /*
         * This takes an lpMsllHookStruct.
         */
        retval = NtUserfnHkINLPMSLLHOOKSTRUCT(nCode, wParam, (LPMSLLHOOKSTRUCT)lParam);
        break;

    case WH_MOUSE:
        /*
         * This takes an lpMouseHookStructEx.
         */
MouseHook:
        retval = NtUserfnHkINLPMOUSEHOOKSTRUCTEX(nCode, wParam, (LPMOUSEHOOKSTRUCTEX)lParam);
        break;

#ifdef REDIRECTION
    case WH_HITTEST:
        /*
         * This takes an lpHTHookStruct.
         */
        retval = NtUserfnHkINLPHTHOOKSTRUCT(nCode, wParam, (LPHTHOOKSTRUCT)lParam);
        break;
#endif // REDIRECTION

    default:
        RIPMSG1(RIP_WARNING, "NtUserCallNextHookEx: Invalid hook type %x",
                PtiCurrent()->sphkCurrent->iHook);
        MSGERROR(0);
    }

    TRACE("NtUserCallNextHookEx");
    ENDRECV();
}


HIMC NtUserCreateInputContext(
    IN ULONG_PTR dwClientImcData)
{
    BEGINRECV(HIMC, (HIMC)NULL);

    ValidateIMMEnabled();

    if (dwClientImcData == 0) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid hMemClientIC parameter");
        MSGERROR(0);
    }

    retval = (HIMC)CreateInputContext(dwClientImcData);

    retval = (HIMC)PtoH((PVOID)retval);

    TRACE("NtUserCreateInputContext");
    ENDRECV();
}


BOOL NtUserDestroyInputContext(
    IN HIMC hImc)
{
    PIMC pImc;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    ValidateHIMC(pImc, hImc);

    retval = DestroyInputContext(pImc);

    TRACE("NtUserDestroyInputContext");
    ENDATOMICRECV();
}


AIC_STATUS NtUserAssociateInputContext(
    IN HWND hwnd,
    IN HIMC hImc,
    IN DWORD dwFlag)
{
    PIMC pImc;

    BEGINATOMICRECV_HWND(AIC_STATUS, AIC_ERROR, hwnd);

    ValidateIMMEnabled();

    ValidateHIMCOPT(pImc, hImc);

    retval = AssociateInputContextEx(pwnd, pImc, dwFlag);

    TRACE("NtUserAssociateInputContext");
    ENDATOMICRECV_HWND();
}

BOOL NtUserUpdateInputContext(
    IN HIMC hImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue)
{
    PIMC pImc;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    ValidateHIMC(pImc, hImc);

    retval = UpdateInputContext(pImc, UpdateType, UpdateValue);

    TRACE("NtUserUpdateInputContext");
    ENDATOMICRECV();
}


ULONG_PTR NtUserQueryInputContext(
    IN HIMC hImc,
    IN INPUTCONTEXTINFOCLASS InputContextInfo)
{
    PTHREADINFO ptiImc;
    PIMC pImc;

    BEGINRECV_SHARED(ULONG_PTR, 0);

    ValidateIMMEnabled();

    ValidateHIMC(pImc, hImc);

    ptiImc = GETPTI(pImc);

    switch (InputContextInfo) {
    case InputContextProcess:
        retval = (ULONG_PTR)PsGetThreadProcessId(ptiImc->pEThread);
        break;

    case InputContextThread:
        retval = (ULONG_PTR)GETPTIID(ptiImc);
        break;

    case InputContextDefaultImeWindow:
        retval = (ULONG_PTR)HW(ptiImc->spwndDefaultIme);
        break;

    case InputContextDefaultInputContext:
        retval = (ULONG_PTR)PtoH(ptiImc->spDefaultImc);
        break;
    }

    ENDRECV_SHARED();
}

NTSTATUS NtUserBuildHimcList(  // private IMM BuildHimcList
    IN DWORD  idThread,
    IN UINT   cHimcMax,
    OUT HIMC *phimcFirst,
    OUT PUINT pcHimcNeeded)
{
    PTHREADINFO pti;
    UINT cHimcNeeded;

    BEGINATOMICRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    ValidateIMMEnabled();

    switch (idThread) {
    case 0:
        pti = PtiCurrent();
        break;
    case (DWORD)-1:
        pti = NULL;
        break;
    default:
        pti = PtiFromThreadId(idThread);
        if (pti == NULL || pti->rpdesk == NULL) {
            MSGERROR(0);
        }
        break;
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(phimcFirst, cHimcMax, sizeof(DWORD));
        ProbeForWriteUlong(pcHimcNeeded);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * phimcFirst is client-side.
     */

    cHimcNeeded = BuildHimcList(pti, cHimcMax, phimcFirst);

    if (cHimcNeeded <= cHimcMax) {
        retval = STATUS_SUCCESS;
    } else {
        retval = STATUS_BUFFER_TOO_SMALL;
    }
    try {
        *pcHimcNeeded = cHimcNeeded;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("NtUserBuildHimcList");
    ENDATOMICRECV();
}


BOOL NtUserGetImeInfoEx(  // private ImmGetImeInfoEx
    IN OUT PIMEINFOEX piiex,
    IN IMEINFOEXCLASS SearchType)
{
    IMEINFOEX iiex;
    BEGINRECV_SHARED(BOOL, FALSE);

    ValidateIMMEnabled();

    try {
        ProbeForWrite(piiex, sizeof(*piiex), sizeof(BYTE));
        RtlCopyMemory(&iiex, piiex, sizeof(IMEINFOEX));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = GetImeInfoEx(
                    _GetProcessWindowStation(NULL),
                    &iiex,
                    SearchType);

    try {
        RtlCopyMemory(piiex, &iiex, sizeof(IMEINFOEX));
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("NtUserGetImeInfoEx");
    ENDRECV_SHARED();
}


BOOL NtUserSetImeInfoEx(
    IN PIMEINFOEX piiex)
{
    IMEINFOEX iiex;
    BEGINRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(piiex, sizeof(*piiex), sizeof(BYTE));
        RtlCopyMemory(&iiex, piiex, sizeof(IMEINFOEX));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = SetImeInfoEx(
                    _GetProcessWindowStation(NULL),
                    &iiex);

    TRACE("NtUserSetImeInfoEx");
    ENDRECV();
}

BOOL NtUserGetImeHotKey(
    IN DWORD dwID,
    OUT PUINT puModifiers,
    OUT PUINT puVKey,
    OUT LPHKL phkl)
{
    UINT uModifiers;
    UINT uVKey;
    HKL hkl;
    LPHKL phklIn = NULL;
    BEGINRECV(BOOL, FALSE);

    try {
        ProbeForWriteUlong(((PULONG)puModifiers));
        ProbeForWriteUlong(((PULONG)puVKey));
        if (ARGUMENT_PRESENT(phkl)) {
            ProbeForWriteHandle((PHANDLE)phkl);
            phklIn = &hkl;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = GetImeHotKey( dwID, &uModifiers, &uVKey, phklIn);

    if (retval) {
        try {
            *puModifiers = uModifiers;
            *puVKey = uVKey;
            if (ARGUMENT_PRESENT(phkl)) {
                *phkl = *phklIn;
            }
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }
    TRACE("NtUserGetImeHotKey");
    ENDRECV();
}

BOOL NtUserSetImeHotKey(
    IN DWORD dwID,
    IN UINT  uModifiers,
    IN UINT  uVKey,
    IN HKL   hkl,
    IN DWORD dwFlags)
{
    BEGINRECV(BOOL, FALSE);

    retval = SetImeHotKey( dwID, uModifiers, uVKey, hkl, dwFlags );
    TRACE("NtUserSetImeHotKey");
    ENDRECV();
}

/*
 * Set per-window application level for IME control.
 * Used only for Korean 3.x ( both 16 bit and 32 bit)
 * applications.
 *
 * return value
 *
 *      TRUE : success
 *      FALSE: error
 */
BOOL NtUserSetAppImeLevel(
    IN HWND  hwnd,
    IN DWORD dwLevel)
{
    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    ValidateIMMEnabled();

    if ( GETPTI(pwnd)->ppi == PpiCurrent() ) {
        InternalSetProp(pwnd, PROP_IMELEVEL, LongToHandle(dwLevel), PROPF_INTERNAL | PROPF_NOPOOL);
        retval = TRUE;
    } else {
        MSGERROR(0);
    }
    TRACE("NtUserSetAppImeLevel");
    ENDRECV_HWND();
}

/*
 * Get per-window application level for IME control.
 * Used only for Korean 3.x ( both 16 bit and 32 bit)
 * applications.
 *
 * return value
 *
 *      0               : error
 *      non zero value  : level
 */
DWORD NtUserGetAppImeLevel(
    IN HWND  hwnd)
{
    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    ValidateIMMEnabled();

    if ( GETPTI(pwnd)->ppi == PtiCurrentShared()->ppi ) {
        retval = (DWORD)(ULONG_PTR)_GetProp(pwnd, PROP_IMELEVEL, TRUE);
    } else {
        MSGERROR(0);
    }
    TRACE("NtUserGetAppImeLevel");
    ENDRECV_HWND_SHARED();
}


DWORD NtUserCheckImeHotKey(
    UINT uVKey,
    LPARAM lParam)
{
    PIMEHOTKEYOBJ pImeHotKeyObj;
    BEGINRECV(DWORD, IME_INVALID_HOTKEY);

    if (gpqForeground == NULL)
        MSGERROR(0);

    ValidateIMMEnabled();

    pImeHotKeyObj = CheckImeHotKey(gpqForeground, uVKey, lParam);
    if (pImeHotKeyObj) {
        retval = pImeHotKeyObj->hk.dwHotKeyID;
    } else {
        retval = IME_INVALID_HOTKEY;
    }

    TRACE("NtUserCheckImeHotKey");
    ENDRECV();
}


/**************************************************************************\
* NtUserSetImeOwnerWindow
*
* History:
* 17-July-2001  Mohamed    Removed re-ownership code and created
                           ImeSetOwnerWindow.  Added this call for ownership
                           assignment of spwndActive to avoid cyclic
                           ownership.
\**************************************************************************/
BOOL NtUserSetImeOwnerWindow(
    IN HWND hwndIme,
    IN HWND hwndFocus)
{
    PWND pwndFocus;

    BEGINATOMICRECV_HWND(BOOL, FALSE, hwndIme);

    ValidateIMMEnabled();

    /*
     * Make sure this really is an IME window.
     */
    if (GETFNID(pwnd) != FNID_IME)
        MSGERROR(0);

    ValidateHWNDOPT(pwndFocus, hwndFocus);

    if (pwndFocus != NULL) {
        ImeSetOwnerWindow(pwnd, pwndFocus);
        ImeCheckTopmost(pwnd);
    } else {
        PTHREADINFO ptiImeWnd = GETPTI(pwnd);
        PWND pwndActive = ptiImeWnd->pq->spwndActive;

        /*
         * If pwndFocus == NULL, active window in the queue should become the
         * owner window of the IME window, except: if IME related windows
         * somehow got a focus, or the active window belongs to the other thread.
         */
        if (pwndActive == NULL || pwndActive != pwnd->spwndOwner) {
            if (pwndActive == NULL || IsWndImeRelated(pwndActive) || ptiImeWnd != GETPTI(pwndActive)) {
                /*
                 * We should avoid improper window to be an owner of IME window.
                 */
                ImeSetFutureOwner(pwnd, pwnd->spwndOwner);
            } else {
                ImeSetOwnerWindow(pwnd, pwndActive);
            }
            ImeCheckTopmost(pwnd);
        }
    }

    retval = TRUE;

    TRACE("NtUserSetImeNewOwner");
    ENDATOMICRECV_HWND();
}


VOID NtUserSetThreadLayoutHandles(
    IN HKL hklNew,
    IN HKL hklOld)
{
    PTHREADINFO ptiCurrent;
    PKL         pklNew;

    BEGINRECV_VOID();

    ptiCurrent = PtiCurrent();

    if (ptiCurrent->spklActive != NULL && ptiCurrent->spklActive->hkl != hklOld)
        MSGERROR_VOID();

    if ((pklNew = HKLtoPKL(ptiCurrent, hklNew)) == NULL)
        MSGERROR_VOID();

    /*
     * hklPrev is only used for IME, non-IME toggle hotkey.
     * The purpose we remember hklPrev is to jump from
     * non-IME keyboard layout to the most recently used
     * IME layout, or to jump from an IME layout to
     * the most recently used non-IME layout. Therefore
     * piti->hklPrev is updated only when [ IME -> non-IME ]
     * or [ non-IME -> IME ] transition is happened.
     */
    if (IS_IME_KBDLAYOUT(hklNew) ^ IS_IME_KBDLAYOUT(hklOld))
        ptiCurrent->hklPrev = hklOld;

    Lock(&ptiCurrent->spklActive, pklNew);

    TRACEVOID("NtUserSetThreadLayoutHandles");
    ENDRECV_VOID();
}

VOID NtUserNotifyIMEStatus(
    IN HWND hwnd,
    IN DWORD dwOpen,
    IN DWORD dwConversion)
{
    BEGINRECV_HWNDLOCK_VOID(hwnd);

    ValidateIMMEnabledVOID();

    xxxNotifyIMEStatus( pwnd, dwOpen, dwConversion );

    TRACEVOID("NtUserNotifyIMEStatus");
    ENDRECV_HWNDLOCK_VOID()
}

BOOL NtUserDisableThreadIme(
    IN DWORD dwThreadId)
{
    PTHREADINFO ptiCurrent, pti;

    BEGINRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    ptiCurrent = PtiCurrent();

    if (dwThreadId == -1) {
        // IME processing is disabled for all the thread in the current process
        ptiCurrent->ppi->W32PF_Flags |= W32PF_DISABLEIME;
        // destory IME stuff
        pti = ptiCurrent->ppi->ptiList;
        while (pti) {
            pti->TIF_flags |= TIF_DISABLEIME;
            if (pti->spwndDefaultIme != NULL) {
                xxxDestroyWindow(pti->spwndDefaultIme);
                // Start the search over from beginning
                // Since the ptilist may be updated
                pti = ptiCurrent->ppi->ptiList;
                continue;
            }
            pti = pti->ptiSibling;
        }
    } else {
        if (dwThreadId == 0) {
            pti = ptiCurrent;
        } else {
            pti = PtiFromThreadId(dwThreadId);
            if (pti == NULL || pti->ppi != ptiCurrent->ppi)
                MSGERROR(0);
        }
        pti->TIF_flags |= TIF_DISABLEIME;
        if (pti->spwndDefaultIme != NULL) {
            xxxDestroyWindow(pti->spwndDefaultIme);
        }
    }

    retval = TRUE;

    TRACE("NtUserDisableThreadIme");
    ENDRECV();
}


BOOL
NtUserEnumDisplayMonitors(  // API EnumDisplayMonitors
    IN HDC             hdc,
    IN LPCRECT         lprcClip,
    IN MONITORENUMPROC lpfnEnum,
    IN LPARAM          dwData)
{
    RECT    rc;
    LPRECT  lprc = (LPRECT) lprcClip;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lprc)) {
        try {
            rc = ProbeAndReadRect(lprc);
            lprc = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    retval = xxxEnumDisplayMonitors(
            hdc,
            lprc,
            lpfnEnum,
            dwData,
            FALSE);

    TRACE("NtUserEnumDisplayMonitors");
    ENDRECV();
}

#ifdef PRERELEASE
/*
 * NtUserQueryUserCounters() retrieves statistics on win32k
 *
 * QUERYUSER_TYPE_USER retrieves the handle counters
 *
 * QUERYUSER_TYPE_CS will fill the result buffer with USER critical section
 * usage data.
 */
BOOL NtUserQueryUserCounters(  // private QueryUserCounters
    IN  DWORD       dwQueryType,
    IN  LPVOID      pvIn,
    IN  DWORD       dwInSize,
    OUT LPVOID      pvResult,
    IN  DWORD       dwOutSize)
{
    PDWORD  pdwInternalIn = NULL;
    PDWORD  pdwInternalResult = NULL;

    BEGINRECV(BOOL, FALSE);

#if defined (USER_PERFORMANCE)
    if (dwQueryType == QUERYUSER_CS) {
        CSSTATISTICS* pcsData;

        if (dwOutSize != sizeof(CSSTATISTICS)) {
            MSGERROR(0);
        }

        try {
            ProbeForWrite((PDWORD)pvResult, dwOutSize, sizeof(DWORD));

            /*
             * Checking for overflow on these counters is caller responsability
             */
            pcsData = (CSSTATISTICS*)pvResult;
            pcsData->cExclusive       = gCSStatistics.cExclusive;
            pcsData->cShared          = gCSStatistics.cShared;
            pcsData->i64TimeExclusive = gCSStatistics.i64TimeExclusive;

        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
        retval = TRUE;
        MSGERROR_VOID();
    } else
#endif // USER_PERFORMANCE

    if (dwQueryType == QUERYUSER_HANDLES) {

        /*
         * Probe arguments, dwInSize should be multiple of 4
         */
        if (dwInSize & (sizeof(DWORD)-1) ||
            dwOutSize != TYPE_CTYPES*dwInSize) {

            MSGERROR(0)
        }

        try {
            ProbeForRead((PDWORD)pvIn, dwInSize, sizeof(DWORD));
            pdwInternalIn = UserAllocPoolWithQuota(dwInSize, TAG_SYSTEM);
            if (!pdwInternalIn) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(pdwInternalIn, pvIn, dwInSize);

            ProbeForWrite(pvResult, dwOutSize, sizeof(DWORD));
            pdwInternalResult = UserAllocPoolWithQuota(dwOutSize, TAG_SYSTEM);
            if (!pdwInternalResult) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }

        } except (StubExceptionHandler(FALSE)) {
                MSGERRORCLEANUP(0);
        }

        _QueryUserHandles(pdwInternalIn,
                dwInSize/sizeof(DWORD),
                (DWORD (*)[TYPE_CTYPES])pdwInternalResult);
        retval = TRUE;

        try {
            RtlCopyMemory(pvResult, pdwInternalResult, dwOutSize);

        } except (StubExceptionHandler(FALSE)) {
                MSGERRORCLEANUP(0);
        }
    } else {
        MSGERROR(0);
    }

    CLEANUPRECV();
    if (pdwInternalIn) {
        UserFreePool(pdwInternalIn);
    }

    if (pdwInternalResult) {
        UserFreePool(pdwInternalResult);
    }

    TRACE("NtUserQueryCounters");
    ENDRECV();
}
#endif


/***************************************************************************\
* NtUserINOUTGETMENUINFO
*
* History:
*  11-12-96 GerardoB - Created
\***************************************************************************/
MESSAGECALL(INOUTMENUGETOBJECT)
{
    MENUGETOBJECTINFO mgoi;
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTMENUGETOBJECT");

    UNREFERENCED_PARAMETER(bAnsi);

    try {
        /*
         * Capture now so xxxInterSendMsgEx won't have to.
         */
        mgoi = ProbeAndReadMenuGetObjectInfo((PMENUGETOBJECTINFO)lParam);

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&mgoi,
                xParam);

    try {
        *((PMENUGETOBJECTINFO)lParam) = mgoi;

    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTMENUGETOBJECT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPCOMBOBOXINFO)
{
    COMBOBOXINFO cbinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPCOMBOBOXINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteComboBoxInfo((PCOMBOBOXINFO)lParam);
        cbinfo = *(PCOMBOBOXINFO)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&cbinfo,
                xParam);

    try {
        *(PCOMBOBOXINFO)lParam = cbinfo;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnOUTLPCOMBOBOXINFO");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPSCROLLBARINFO)
{
    SCROLLBARINFO sbinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPSCROLLBARINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteScrollBarInfo((PSCROLLBARINFO)lParam);
        sbinfo = *(PSCROLLBARINFO)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&sbinfo,
                xParam);

    try {
        *(PSCROLLBARINFO)lParam = sbinfo;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnOUTLPSCROLLBARINFO");
    ENDRECV_MESSAGECALL();
}

/***************************************************************************\
* NtUserFlashWindowEx
*
* History:
*  11-16-96 MCostea - Created
\***************************************************************************/
BOOL
NtUserFlashWindowEx(  // API FlashWindowEx
    IN PFLASHWINFO pfwi)
{
    FLASHWINFO fwiInternal;
    TL tlpwnd;
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);
    DBG_THREADLOCK_START(FlashWindowEx);

    /*
     * Probe arguments
     */
    try {
        fwiInternal = ProbeAndReadStructure(pfwi, FLASHWINFO);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if ((pwnd = ValidateHwnd(fwiInternal.hwnd)) == NULL ||
        fwiInternal.cbSize != sizeof(FLASHWINFO) ||
        fwiInternal.dwFlags & ~FLASHW_VALID) {

        RIPMSG0(RIP_WARNING, "NtUserFlashWindowEx: Invalid Parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    }
    else {
        ThreadLockAlwaysWithPti(PtiCurrent(), pwnd, &tlpwnd);
        retval = xxxFlashWindow(pwnd,
                            MAKELONG(fwiInternal.dwFlags, fwiInternal.uCount),
                            fwiInternal.dwTimeout);
        ThreadUnlock(&tlpwnd);
    }

    DBG_THREADLOCK_END(FlashWindowEx);

    TRACE("NtUserFlashWindowEx");
    ENDRECV();
}

BOOL NtUserUpdateLayeredWindow(  // API UpdateLayeredWindow
    IN HWND hwnd,
    IN HDC hdcDst,
    IN POINT *pptDst,
    IN SIZE *psize,
    IN HDC hdcSrc,
    IN POINT *pptSrc,
    IN COLORREF crKey,
    IN BLENDFUNCTION *pblend,
    IN DWORD dwFlags)
{
    PWND pwnd;
    POINT ptSrc;
    SIZE size;
    POINT ptDst;
    BLENDFUNCTION blend;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWND(pwnd, hwnd);

    /*
     * Probe and validate arguments.
     */
    try {
        if (ARGUMENT_PRESENT(pptSrc)) {
            ptSrc = ProbeAndReadPoint(pptSrc);
            pptSrc = &ptSrc;
        }
        if (ARGUMENT_PRESENT(psize)) {
            size = ProbeAndReadSize(psize);
            psize = &size;
            if (psize->cx < 0 || psize->cy < 0) {
                MSGERROR(ERROR_INVALID_PARAMETER);  // this is a jump out of try!
            }
        }
        if (ARGUMENT_PRESENT(pptDst)) {
            ptDst = ProbeAndReadPoint(pptDst);
            pptDst = &ptDst;
        }

        if (ARGUMENT_PRESENT(pblend)) {
            blend = ProbeAndReadBlendfunction(pblend);
            pblend = &blend;
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (dwFlags & ~ULW_VALID) {
        RIPMSG0(RIP_WARNING, "UpdateLayeredWindow: Invalid Parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        retval = _UpdateLayeredWindow(
                pwnd,
                hdcDst,
                pptDst,
                psize,
                hdcSrc,
                pptSrc,
                crKey,
                pblend,
                dwFlags);
    }

    TRACE("NtUserUpdateLayeredWindow");
    ENDATOMICRECV();
}

BOOL NtUserGetLayeredWindowAttributes(
    IN HWND hwnd,
    OUT OPTIONAL COLORREF *pcrKey,
    OUT OPTIONAL BYTE *pbAlpha,
    OUT OPTIONAL DWORD *pdwFlags)
{
    PWND pwnd;
    COLORREF crKey;
    BYTE bAlpha;
    DWORD dwFlags;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWND(pwnd, hwnd);

    retval = _GetLayeredWindowAttributes(pwnd, &crKey, &bAlpha, &dwFlags);
    if (retval) {
        try {
            if (ARGUMENT_PRESENT(pcrKey)) {
                ProbeForWrite(pcrKey, sizeof(COLORREF), sizeof(COLORREF));
                *pcrKey = crKey;
            }

            if (ARGUMENT_PRESENT(pbAlpha)) {
                ProbeForWrite(pbAlpha, sizeof(BYTE), sizeof(BYTE));
                *pbAlpha = bAlpha;
            }

            if (ARGUMENT_PRESENT(pdwFlags)) {
                ProbeForWrite(pdwFlags, sizeof(DWORD), sizeof(DWORD));
                *pdwFlags = dwFlags & ULW_VALID;
            }
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetLayeredWindowAttributes");
    ENDATOMICRECV();
}


BOOL NtUserSetLayeredWindowAttributes(
    IN HWND hwnd,
    IN COLORREF crKey,
    IN BYTE bAlpha,
    IN DWORD dwFlags)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWND(pwnd, hwnd);

    if (dwFlags & ~LWA_VALID) {
        RIPMSG0(RIP_WARNING, "SetLayeredWindowAttributes: Invalid Parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        retval = _SetLayeredWindowAttributes(pwnd, crKey, bAlpha, dwFlags);
    }

    TRACE("NtUserSetLayeredWindowAttributes");
    ENDATOMICRECV();
}


BOOL NtUserPrintWindow(
    IN HWND hwnd,
    IN HDC hdcBlt,
    IN UINT nFlags)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);
    if ((nFlags & PW_VALID) != nFlags) {
        RIPMSG2(RIP_WARNING, "PrintWindow: Invalid Parameter nFlags=%d on HWND=0x%p", nFlags, hwnd);
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        retval = xxxPrintWindow(pwndND, hdcBlt, nFlags);
    }

    TRACE("NtUserPrintWindow");
    ENDRECV_HWNDLOCK_ND();
}


/***************************************************************************\
* GetHDevName
* Called by NtUserCallTwoParam in GetMonitorInfo to query
* gre about the HDev name
*
* 1-July-1998    MCostea      created
\***************************************************************************/
BOOL GetHDevName(HMONITOR hMon, PWCHAR pName)
{
    PMONITOR pMonitor;
    WCHAR wszName[CCHDEVICENAME];
    BOOL fResult = FALSE;

    CheckCritIn();

    pMonitor = ValidateHmonitor(hMon);
    if (!pMonitor) {
        return FALSE;
    }

    if (DrvGetHdevName(pMonitor->hDev, wszName)) {
        /*
         * Make sure it's NULL terminated.
         */
        wszName[CCHDEVICENAME - 1] = 0;
        try {
            ProbeForWrite(pName, CCHDEVICENAME * sizeof(WCHAR), sizeof(DWORD));
            RtlCopyMemory(pName, wszName, CCHDEVICENAME * sizeof(WCHAR));
        } except (StubExceptionHandler(TRUE)) {
            goto _exit;
        }
        fResult = TRUE;
    }

_exit:
    return fResult;
}


#ifdef GENERIC_INPUT
/***************************************************************************\
* NtUserGetRawInputData
* Gets the HIDDATA structure from its HRAWINPUT handle.
*
* Returns the number of bytes written to pRawInput. On error, it returns -1 and zero
* in *pcbSize. If pRawInput is NULL, it returns zero and the number of bytes need to
* receive the data in pcbSize.
*
* If pRawInput is not big enough, it return -1 and the number of bytes needed to
* receive the data in pcbSize.
*
* 25-February-2000    JasonSch       created
\***************************************************************************/

UINT NtUserGetRawInputData(
    HRAWINPUT hRawInput,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize,
    UINT cbSizeHeader)
{
    PHIDDATA pHidData;
    UINT cbOutSize, cbBufferSize;

    BEGINATOMICRECV(UINT, (UINT)-1);

    if (cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    /*
     * Get the report data contents.
     */
    pHidData = HMValidateHandle(hRawInput, TYPE_HIDDATA);
    if (pHidData == NULL) {
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "NtUserGetRawInputData: invalid handle %p", hRawInput);
        MSGERROR(0);
    }

    /*
     * Check the type of the raw input data.
     */
    switch (pHidData->rid.header.dwType) {
    case RIM_TYPEMOUSE:
    case RIM_TYPEKEYBOARD:
    case RIM_TYPEHID:
        break;
    default:
        /*
         * The handle is valid, but the internal state of the object is
         * weird.
         */
        RIPERR2(ERROR_INVALID_HANDLE,
                RIP_ERROR,
                "Invalid type 0x%x in pHidData %p",
                pHidData->rid.header.dwType,
                pHidData);
        MSGERROR(0);
    }

    /*
     * Calculate the size of the data
     */
    switch (uiCommand) {
    case RID_INPUT:
        cbOutSize = pHidData->rid.header.dwSize;
        break;
    case RID_HEADER:
        cbOutSize = sizeof pHidData->rid.header;
        break;
    default:
        MSGERROR(ERROR_INVALID_PARAMETER);
        break;
    }

#if DBG
    if (pHidData->rid.header.dwType == RIM_TYPEHID && uiCommand == RID_INPUT) {
        /*
         * TYPEHID has variable length array of report data.
         */
        TAGMSG3(DBGTAG_PNP, "NtUserGetRawInputData: pHidData=%p, dwOutSize=%x, calc'ed=%x",
                pHidData,
                cbOutSize, FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + pHidData->rid.data.hid.dwSizeHid * pHidData->rid.data.hid.dwCount);
        UserAssert(cbOutSize == FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + pHidData->rid.data.hid.dwSizeHid * pHidData->rid.data.hid.dwCount);
    }
#endif

    if (pData == NULL) {
        /*
         * The caller wants to get the required size of the buffer.
         */
        try {
            ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
            *pcbSize = cbOutSize;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        retval = 0;
    } else {
        try {
            ProbeForRead(pcbSize, sizeof(UINT), sizeof(DWORD));
            cbBufferSize = *pcbSize;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }

        if (cbBufferSize >= cbOutSize) {
            try {
                switch (uiCommand) {
                case RID_INPUT:
                    ProbeForWrite(pData, cbOutSize, sizeof(DWORD));
                    RtlCopyMemory(pData, &pHidData->rid, cbOutSize);
                    break;

                case RID_HEADER:
                    {
                        PRAWINPUTHEADER pHeader = (PRAWINPUTHEADER)pData;
                        UserAssert(cbOutSize == sizeof(RAWINPUTHEADER));
                        ProbeAndWriteStructure(pHeader, pHidData->rid.header, RAWINPUTHEADER);
                    }
                    break;

                default:
                    UserAssert(FALSE);
                    break;
                }
            } except (StubExceptionHandler(TRUE)) {
                MSGERROR(0);
            }
            retval = cbOutSize;
        } else {
            retval = errret;
            try {
                ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
                *pcbSize = cbBufferSize;
                UserSetLastError(ERROR_INSUFFICIENT_BUFFER);
            } except(StubExceptionHandler(TRUE)) {
                MSGERROR(0);
            }
        }
    }

    TRACE("NtUserGetRawInputData");
    ENDATOMICRECV();
}


UINT NtUserGetRawInputDeviceInfo(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize)
{
    PDEVICEINFO pDeviceInfo;
    UINT cbOutSize = 0;
    UINT cbBufferSize;

    BEGINATOMICRECV(DWORD, (UINT)-1);

    try {
        ProbeForRead(pcbSize, sizeof(UINT), sizeof(DWORD));
        cbBufferSize = *pcbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    EnterDeviceInfoListCrit();

    pDeviceInfo = HMValidateHandle(hDevice, TYPE_DEVICEINFO);
    if (pDeviceInfo == NULL) {
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "NtUserGetRawInputDeviceInfo: invalid handle=%p", hDevice);
        MSGERRORCLEANUP(0);
    }

    /*
     * Compute the size of the output and evaluate the uiCommand.
     */
    switch (uiCommand) {
    case RIDI_PREPARSEDDATA:
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            cbOutSize = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.DescriptorSize;
        } else {
            cbOutSize = 0;
        }
        break;
    case RIDI_DEVICENAME:
        /*
         * N.b. UNICODE_STRING counts the length by the BYTE count, not by the character count.
         * Our APIs always treat the strings by the character count. Thus, for RIDI_DEVICNAME
         * only, cbOutSize holds the character count, not the byte count, in spite of its
         * name. Confusing, but cch is the way to be consistent.
         */
        cbOutSize = pDeviceInfo->ustrName.Length / sizeof(WCHAR) + 1;   // for Null terminator
        break;

    case RIDI_DEVICEINFO:
        cbOutSize = sizeof(RID_DEVICE_INFO);
        break;

    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetRawInputDeviceInfo: invalid uiCommand=%x", uiCommand);
        MSGERRORCLEANUP(0);
        break;
    }

    if (pData == NULL) {
        /*
         * The app wants to get the required size.
         */
        try {
            ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
            *pcbSize = cbOutSize;
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
        retval = 0;
    } else {
        if (cbBufferSize >= cbOutSize) {
            try {
                ProbeForWrite(pData, cbBufferSize, sizeof(DWORD));
                switch (uiCommand) {
                case RIDI_PREPARSEDDATA:
                    if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                        RtlCopyMemory(pData, pDeviceInfo->hid.pHidDesc->pPreparsedData, cbOutSize);
                    } else {
                        UserAssert(cbOutSize == 0);
                    }
                    break;

                case RIDI_DEVICENAME:
                    UserAssert((cbOutSize -1) * sizeof(WCHAR) == pDeviceInfo->ustrName.Length);
                    RtlCopyMemory(pData, pDeviceInfo->ustrName.Buffer, pDeviceInfo->ustrName.Length);
                    ((WCHAR*)pData)[cbOutSize - 1] = 0; // make it null terminated
                    break;

                case RIDI_DEVICEINFO:
                    {
                        PRID_DEVICE_INFO prdi = (PRID_DEVICE_INFO)pData;

                        ProbeForRead(prdi, sizeof(UINT), sizeof(DWORD));
                        if (prdi->cbSize != cbOutSize) {
                            MSGERRORCLEANUP(ERROR_INVALID_PARAMETER);
                        }
                        ProbeForWrite(prdi, sizeof(RID_DEVICE_INFO), sizeof(DWORD));
                        RtlZeroMemory(prdi, sizeof(RID_DEVICE_INFO));
                        prdi->cbSize = cbOutSize;

                        switch (pDeviceInfo->type) {
                        case DEVICE_TYPE_HID:
                            prdi->dwType = RIM_TYPEHID;
                            prdi->hid.dwVendorId = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.VendorID;
                            prdi->hid.dwProductId = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.ProductID;
                            prdi->hid.dwVersionNumber = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.VersionNumber;
                            prdi->hid.usUsagePage = pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage;
                            prdi->hid.usUsage = pDeviceInfo->hid.pHidDesc->hidpCaps.Usage;
                            break;

                        case DEVICE_TYPE_MOUSE:
                            prdi->dwType = RIM_TYPEMOUSE;
                            prdi->mouse.dwId = pDeviceInfo->mouse.Attr.MouseIdentifier;
                            prdi->mouse.dwNumberOfButtons = pDeviceInfo->mouse.Attr.NumberOfButtons;
                            prdi->mouse.dwSampleRate = pDeviceInfo->mouse.Attr.SampleRate;
                            break;

                        case DEVICE_TYPE_KEYBOARD:
                            prdi->dwType = RIM_TYPEKEYBOARD;
                            prdi->keyboard.dwType = GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo);
                            prdi->keyboard.dwSubType = GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo);
                            prdi->keyboard.dwKeyboardMode = pDeviceInfo->keyboard.Attr.KeyboardMode;
                            prdi->keyboard.dwNumberOfFunctionKeys = pDeviceInfo->keyboard.Attr.NumberOfFunctionKeys;
                            prdi->keyboard.dwNumberOfIndicators = pDeviceInfo->keyboard.Attr.NumberOfIndicators;
                            prdi->keyboard.dwNumberOfKeysTotal = pDeviceInfo->keyboard.Attr.NumberOfKeysTotal;
                            break;
                        }
                    }
                    break;

                default:
                    UserAssert(FALSE);
                    break;
                }
            } except (StubExceptionHandler(TRUE)) {
                MSGERRORCLEANUP(0);
            }
            retval = cbOutSize;
        } else {
            /*
             * The buffer size is too small.
             * Returns error, storing the required size in *pcbSize.
             */
            retval = errret;
            try {
                ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
                *pcbSize = cbOutSize;
                UserSetLastError(ERROR_INSUFFICIENT_BUFFER);
            } except (StubExceptionHandler(TRUE)) {
                MSGERRORCLEANUP(0);
            }
        }
    }


    CLEANUPRECV();
    LeaveDeviceInfoListCrit();

    TRACE("NtUserGetRawInputDeviceInfo");
    ENDATOMICRECV();
}


UINT NtUserGetRawInputDeviceList(
    PRAWINPUTDEVICELIST pRawInputDeviceList,
    PUINT puiNumDevices,
    UINT cbSize)
{
    UINT nDevices = 0;
    PDEVICEINFO pDeviceInfo;

    BEGINATOMICRECV(DWORD, (UINT)-1);

    if (cbSize != sizeof(RAWINPUTDEVICELIST)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    EnterDeviceInfoListCrit();

    /*
     * Firstly, count up the number of devices
     * attached to the system.
     */
    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        ++nDevices;
    }

    if (pRawInputDeviceList == NULL) {
        /*
         * Application simply wants the number of devices.
         */
        try {
            /*
             * Store number of devices.
             */
            ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            *puiNumDevices = nDevices;
            /*
             * Set retval as 0, to indicate the API succeeded.
             */
            retval = 0;
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    } else {
        /*
         * Write out the device info list.
         */
        try {
            UINT i;

            ProbeForRead(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            if (*puiNumDevices < nDevices) {
                /*
                 * If the buffer size is not sufficient, set the required
                 * number of buffers, then return error.
                 */
                ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
                *puiNumDevices = nDevices;
                MSGERRORCLEANUP(ERROR_INSUFFICIENT_BUFFER);
            }
            ProbeForWrite(pRawInputDeviceList, sizeof(RAWINPUTDEVICELIST) * nDevices, sizeof(HANDLE));
            for (i = 0, pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext, ++i) {
                UserAssert(i < nDevices);
                pRawInputDeviceList[i].hDevice = PtoHq(pDeviceInfo);
                pRawInputDeviceList[i].dwType = pDeviceInfo->type;
            }
            UserAssert(i == nDevices);
            retval = i;
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    }

    CLEANUPRECV();
    LeaveDeviceInfoListCrit();

    TRACE("NtUserGetRawInputDeviceList");
    ENDATOMICRECV();
}


BOOL NtUserRegisterRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    UINT uiNumDevices,
    UINT cbSize)
{
    PVOID       pLocalRawInputDevices = NULL;
    TL          tlBuffer;
    PTHREADINFO ptiCurrent;

    BEGINATOMICRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();
    if (pRawInputDevices == NULL || uiNumDevices == 0 || cbSize != sizeof(RAWINPUTDEVICE)) {
        /*
         * TBD:
         * What should we do if pRawInputDevices is NULL?
         * Perhaps should start receiving all HID input?
         */
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    try {
        ProbeForReadBuffer(pRawInputDevices, uiNumDevices, sizeof(PRAWINPUTDEVICE));
        pLocalRawInputDevices = UserAllocPoolWithQuota(uiNumDevices * cbSize, TAG_SYSTEM);
        if (pLocalRawInputDevices) {
            ThreadLockPool(ptiCurrent, pLocalRawInputDevices, &tlBuffer);
            RtlCopyMemory(pLocalRawInputDevices, pRawInputDevices, uiNumDevices * cbSize);
        } else {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    retval = _RegisterRawInputDevices(pLocalRawInputDevices, uiNumDevices);

    CLEANUPRECV();

    if (pLocalRawInputDevices) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    }

    TRACE("NtUserSetRawInputDevices");
    ENDATOMICRECV();
}

UINT NtUserGetRegisteredRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    PUINT puiNumDevices,
    UINT cbSize)
{
    BEGINATOMICRECV(DWORD, (UINT)-1);

    if (cbSize != sizeof(RAWINPUTDEVICE)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    retval = _GetRegisteredRawInputDevices(pRawInputDevices, puiNumDevices);

    ENDATOMICRECV();
}

#ifdef _WIN64
# ifndef QWORD_ALIGN
# define QWORD_ALIGN(x) (((x) + 7) & ~7)
# endif
#define RI_ALIGN(x) QWORD_ALIGN(x)
#else
#define RI_ALIGN(x) DWORD_ALIGN(x)
#endif  // _Win64

UINT NtUserGetRawInputBuffer(
    PRAWINPUT pData,
    PUINT pcbSize,
#ifdef LATER
    DWORD dwFlags,
#endif
    UINT cbSizeHeader)
{
    UINT cbBytes = 0;               /* # of bytes written to the buffer   */
    UINT cbWriteSize = 0;           /* the # of bytes to write into pData */
    PQMSG pqmsg;
    PTHREADINFO ptiCurrent;
    PQ pq;
    PHIDDATA pHidData;
    UINT cbBufferSize; /* the size of the passed in buffer */
    UINT cRICount = 0; /* # of RAWINPUT structures written to the buffer */

    BEGINATOMICRECV(UINT, -1);

#ifdef LATER
    if (dwFlags != 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }
#endif

    if (cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    try {
        ProbeForRead(pcbSize, sizeof(UINT), sizeof(DWORD));
        cbBufferSize = *pcbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ptiCurrent = PtiCurrent();
    pq = ptiCurrent->pq;
    pqmsg = pq->mlInput.pqmsgRead;
    while (pqmsg) {
        // Remember the next pqmsg, for the current pqmsg may be freed in this loop
        PQMSG pqmsgNext = pqmsg->pqmsgNext;

        if (pqmsg->msg.message == WM_INPUT) {
            pHidData = HMValidateHandle((HRAWINPUT)pqmsg->msg.lParam, TYPE_HIDDATA);
            UserAssert(pHidData != NULL);

            cbWriteSize = RI_ALIGN(pHidData->rid.header.dwSize);
            if (pData == NULL || (cbBytes + cbWriteSize) > cbBufferSize) {
                break;
            }

            try {
                ProbeForWrite(pData, cbWriteSize, sizeof(DWORD));
                RtlCopyMemory(pData, &pHidData->rid, pHidData->rid.header.dwSize);
                ++cRICount;
                (PBYTE)pData += cbWriteSize;
                cbBytes += cbWriteSize;
            } except (StubExceptionHandler(TRUE)) {
                RIPMSG3(RIP_WARNING, "NtUserGetRawInputBuffer: exception: src=%p target=%p  %x bytes",
                        &pHidData->rid, pData, pHidData->rid.header.dwSize);
                MSGERROR(0);
            }

            // Update the time of the messages
            ptiCurrent->timeLast = pqmsg->msg.time;

            // Remove this msg from the queue
            DelQEntry(&pq->mlInput, pqmsg);
            FreeHidData(pHidData);
        }
        pqmsg = pqmsgNext;
    }

    /*
     * If pqmsg is NULL then we went through the entire MLIST. This will
     * only happen if we have copied all of the WM_INPUTs into the buffer or
     * there were none to begin with. Either way, there are none left. So
     * turn off QS_RAWINPUT.
     */
    if (pqmsg == NULL && pData != NULL) {
        ClearWakeBit(ptiCurrent, QS_RAWINPUT, FALSE);
    }

    if (cbBufferSize <= cbWriteSize || pData == NULL) {
        if (pData == NULL) {
            retval = 0;
        } else {
            retval = errret;
            UserSetLastError(ERROR_INSUFFICIENT_BUFFER);
        }

        try {
            ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
            *pcbSize = cbWriteSize;
        } except(StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    } else {
        // Update the last time read
        SET_TIME_LAST_READ(ptiCurrent);
        retval = cRICount;
    }

    TRACE("NtUserGetRawInputBuffer");
    ENDATOMICRECV();
}
#undef RI_ALIGN

#endif

BOOL NtUserValidateTimerCallback(
    IN ULONG_PTR pfnCallback)
{
    BEGINRECV_SHARED(BOOL, FALSE);

    retval = ValidateTimerCallback(PtiCurrentShared(), pfnCallback);

    ENDRECV_SHARED();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\palette.c ===
/**************************** Module Header ********************************\
* Module Name: palette.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Palette Handling Routines
*
* History:
* 24-May-1993 MikeKe    From win3.1
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* IsTopmostRealApp
*
* Returns true if current process is the shell process and this window
* is the first non-shell/user one we find in zorder.  If so, we consider
* him to be the "palette foreground".
*
* History:
\***************************************************************************/

BOOL IsTopmostRealApp(
    PWND pwnd)
{
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOPINFO pdeskinfo = pwnd->head.rpdesk->pDeskInfo;
    if ((pdeskinfo->spwndShell == NULL) ||
        (GETPTI(pdeskinfo->spwndShell)->pq != gpqForeground)) {

        return FALSE;
    }

    return (pwnd == NextTopWindow(ptiCurrent,
                                  NULL,
                                  NULL,
                                  NTW_IGNORETOOLWINDOW));
}

/***************************************************************************\
* _SelectPalette
*
* Selects palette into DC.  This is a wrapper to gdi where we can perform
* checks to see if it's a foreground dc.
*
* History:
\***************************************************************************/

HPALETTE _SelectPalette(
    HDC      hdc,
    HPALETTE hpal,
    BOOL     fForceBackground)
{
    PWND pwndTop;
    BOOL fBackgroundPalette = TRUE;
    PWND pwnd = NULL;
    /*
     * If we are not forcing palette into background, find out where it does
     * actually belong. Don't ever select the default palette in as a
     * foreground palette because this confuses gdi. Many apps do a
     * (oldPal = SelectPalette) (myPal); Draw; SelectObject(oldPal).
     * and we don't want to allow this to go through.
     */
    if (!fForceBackground     &&
        TEST_PUSIF(PUSIF_PALETTEDISPLAY) &&
        (hpal != GreGetStockObject(DEFAULT_PALETTE))) {

        if (pwnd = WindowFromCacheDC(hdc)) {

            PWND pwndActive;

            /*
             * don't "select" palette unless on a palette device
             */
            pwndTop = GetTopLevelWindow(pwnd);

            if (!TestWF(pwndTop, WFHASPALETTE)) {

                if (pwndTop != _GetDesktopWindow())
                    GETPTI(pwndTop)->TIF_flags |= TIF_PALETTEAWARE;

                SetWF(pwndTop, WFHASPALETTE);
            }

            /*
             * Hack-o-rama:
             * Windows get foreground use of the palette if
             *      * They are the foreground's active window
             *      * The current process is the shell and they are the
             * topmost valid non-toolwindow in the zorder.
             *
             * This makes our tray friendly on palettized displays.
             * Currently, if you run a palette app and click on the tray,
             * the palette app goes all weird.  Broderbund apps go
             * completely black.  This is because they get forced to be
             * background always, even though the shell isn't really
             * palettized.
             *
             * Note: this palette architecture isn't very good.  Apps get forced to
             * be background palette users even if the foreground thread
             * couldn't care less about the palette.  Should go by zorder
             * if so, but in a more clean way than this.
             *
             * We really only care about the tray && the background.
             * Cabinet dudes don't matter so much.
             */
            pwndActive = (gpqForeground ? gpqForeground->spwndActive : NULL);

#if 0
            if (pwndActive                                            &&
                (pwndTop != pwnd->head.rpdesk->pDeskInfo->spwndShell) &&
                ((pwndActive == pwnd) || _IsChild(pwndActive, pwnd) || IsTopmostRealApp(pwnd)) &&
                !TestWF(pwnd, WEFTOOLWINDOW)) {

                fBackgroundPalette = FALSE;
            }
#else
            if ((pwndTop != pwndTop->head.rpdesk->pDeskInfo->spwnd)      &&
                (pwndTop != pwndTop->head.rpdesk->pDeskInfo->spwndShell) &&
                (pwndActive != NULL)                                     &&
                ((pwndActive == pwnd)          ||
                    _IsChild(pwndActive, pwnd) ||
                    IsTopmostRealApp(pwnd))                              &&
                !TestWF(pwnd, WEFTOOLWINDOW)) {

                fBackgroundPalette = FALSE;
            }
#endif
        }
    }

    return GreSelectPalette(hdc, hpal, fBackgroundPalette);
}

/***************************************************************************\
* xxxRealizePalette
*
* Realizes palette to the DC.  This is a wrapper to gdi so that we can
* check for changes prior to sending notifications.
*
* History:
\***************************************************************************/

int xxxRealizePalette(
    HDC hdc)
{
    PWND           pwnd;
    DWORD          dwNumChanged;
    PWINDOWSTATION pwinsta;
    PDESKTOP       pdesk;
    TL             tlpwnd;

    dwNumChanged = GreRealizePalette(hdc);

    if (HIWORD(dwNumChanged) && IsDCCurrentPalette(hdc)) {

        pwnd = WindowFromCacheDC(hdc);

        /*
         * if there is no associated window, don't send the palette change
         * messages since this is a memory hdc.
         */
        if (pwnd != NULL) {
            /*
             * Ok, send WM_PALETTECHANGED message to everyone. The wParam
             * contains a handle to the currently active window.  Send
             * message to the desktop also, so things on the desktop bitmap
             * will paint ok.
             */
             ThreadLock(pwnd, &tlpwnd);
             xxxBroadcastPaletteChanged(pwnd, FALSE);
             ThreadUnlock(&tlpwnd);

            /*
             * Mark all other desktops as needing to send out
             * WM_PALETTECHANGED messages.
             */

            pwinsta = grpWinStaList;

            while (pwinsta != NULL) {
                pdesk = pwinsta->rpdeskList;
                while (pdesk != NULL) {
                    if (pdesk != pwnd->head.rpdesk) {
                        pdesk->dwDTFlags |= DTF_NEEDSPALETTECHANGED;
                    }
                    pdesk = pdesk->rpdeskNext;
                }
                pwinsta = pwinsta->rpwinstaNext;
            }

            GreRealizePalette(hdc);
        }
    }

    /*
     * Walk through the SPB list (the saved bitmaps under windows with the
     * CS_SAVEBITS style) discarding all bitmaps
     */
    if (HIWORD(dwNumChanged)) {
        FreeAllSpbs();
    }

    return LOWORD(dwNumChanged);
}

/***************************************************************************\
* xxxFlushPalette
*
* This resets the palette and lets the next foreground app grab the
* foreground palette.  This is called in such instances when we
* minimize a window.
*
* History:
* 31-Aug-1995  ChrisWil    Created.
\***************************************************************************/

VOID xxxFlushPalette(
    PWND pwnd)
{
    CheckLock(pwnd);
    /*
     * Broadcast the palette changed messages.
     */
    GreRealizeDefaultPalette(gpDispInfo->hdcScreen, TRUE);
    xxxBroadcastPaletteChanged(pwnd, TRUE);
}

/***************************************************************************\
* xxxBroadcastPaletteChanged
*
* RealizePalette passes FALSE for fForceDesktopso so that it does not
* cause a loop in case RealizePalette was called by the desktop window.
* In such a case we don't want to call RealizeDesktop. In all other cases
* we do want to go to RealizeDesktop to give the desktop a chance to
* reailze its palette or possibly just repaint.
*
* 04/22/97      vadimg      created
\***************************************************************************/

VOID xxxBroadcastPaletteChanged(PWND pwnd, BOOL fForceDesktop)
{
    PWND pwndDesk;
    HWND hwnd = HWq(pwnd);

    CheckLock(pwnd);

    pwndDesk = PWNDDESKTOP(pwnd);
    if (fForceDesktop || pwnd != pwndDesk) {
        TL tlpwndDesk;
        ThreadLockAlways(pwndDesk, &tlpwndDesk);
        xxxRealizeDesktop(pwndDesk);
        ThreadUnlock(&tlpwndDesk);
    }

    xxxSendNotifyMessage(PWND_BROADCAST, WM_PALETTECHANGED, (WPARAM)hwnd, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\pnp.c ===
/****************************** Module Header ******************************\
* Module Name: pnp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module tracks device interface changes so we can keep track of know how many mice and
* keyboards and mouse
* and mouse reports.
*
* History:
* 97-10-16   IanJa   Interpreted from a dream that Ken Ray had.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL gbFirstConnectionDone;

DEVICE_TEMPLATE aDeviceTemplate[DEVICE_TYPE_MAX + 1] = {
    // DEVICE_TYPE_MOUSE
    {
        sizeof(GENERIC_DEVICE_INFO)+sizeof(MOUSE_DEVICE_INFO),    // cbDeviceInfo
        &GUID_CLASS_MOUSE,                                        // pClassGUID
        PMAP_MOUCLASS_PARAMS,                                     // uiRegistrySection
        L"mouclass",                                              // pwszClassName
        DD_MOUSE_DEVICE_NAME_U L"0",                              // pwszDefDevName
        DD_MOUSE_DEVICE_NAME_U L"Legacy0",                        // pwszLegacyDevName
        IOCTL_MOUSE_QUERY_ATTRIBUTES,                             // IOCTL_Attr
        FIELD_OFFSET(DEVICEINFO, mouse.Attr),                     // offAttr
        sizeof((PDEVICEINFO)NULL)->mouse.Attr,                    // cbAttr
        FIELD_OFFSET(DEVICEINFO, mouse.Data),                     // offData
        sizeof((PDEVICEINFO)NULL)->mouse.Data,                    // cbData
        ProcessMouseInput,                                        // Reader routine
        NULL                                                      // pkeHidChange
    },
    // DEVICE_TYPE_KEYBOARD
    {
        sizeof(GENERIC_DEVICE_INFO)+sizeof(KEYBOARD_DEVICE_INFO), // cbDeviceInfo
        &GUID_CLASS_KEYBOARD,                                     // pClassGUID
        PMAP_KBDCLASS_PARAMS,                                     // uiRegistrySection
        L"kbdclass",                                              // pwszClassName
        DD_KEYBOARD_DEVICE_NAME_U L"0",                           // pwszDefDevName
        DD_KEYBOARD_DEVICE_NAME_U L"Legacy0",                     // pwszLegacyDevName
        IOCTL_KEYBOARD_QUERY_ATTRIBUTES,                          // IOCTL_Attr
        FIELD_OFFSET(DEVICEINFO, keyboard.Attr),                  // offAttr
        sizeof((PDEVICEINFO)NULL)->keyboard.Attr,                 // cbAttr
        FIELD_OFFSET(DEVICEINFO, keyboard.Data),                  // offData
        sizeof((PDEVICEINFO)NULL)->keyboard.Data,                 // cbData
        ProcessKeyboardInput,                                     // Reader routine
        NULL                                                      // pkeHidChange
    },
#ifdef GENERIC_INPUT
    // DEVICE_TYPE_HID
    {
        sizeof(GENERIC_DEVICE_INFO)+sizeof(HID_DEVICE_INFO),        // cbDeviceInfo
        &GUID_CLASS_INPUT,                                          // pClassGUID
        0,                                                          // uiRegistrySection. LATER: add real one
        L"hid",                                                     // pwszClassName
        L"",                                                        // pwszDefDevName
        L"",                                                        // pwszLegacyDevName
        0,                                                          // IOCTL_ATTR
        0,                                                          // offAttr
        0,                                                          // cbAttr
        0,                                                          // offData
        0,                                                          // cbData
        ProcessHidInput,                                            // Reader routine
        NULL,                                                       // pkeHidChange,
        DT_HID,                                                     // dwFlags
    },
#endif
    // Add new input device type template here
};

//
// We need to remember device class notification entries since we need
// them to unregister the device class notification when we disconnect
// from the console.
//

PVOID aDeviceClassNotificationEntry[DEVICE_TYPE_MAX + 1];

#ifdef DIAGNOSE_IO
NTSTATUS gKbdIoctlLEDSStatus = -1;   // last IOCTL_KEYBOARD_QUERY_INDICATORS
#endif

typedef struct _CDROM_NOTIFY {
    LIST_ENTRY                   Entry;
    ULONG                        Size;
    PVOID                        RegistrationHandle;
    ULONG                        Event;
    // Must be last field
    MOUNTMGR_DRIVE_LETTER_TARGET DeviceName;
} CDROM_NOTIFY, *PCDROM_NOTIFY;

PVOID gCDROMClassRegistrationEntry;
LIST_ENTRY gCDROMNotifyList;
LIST_ENTRY gMediaChangeList;
PFAST_MUTEX gMediaChangeMutex;
HANDLE gpEventMediaChange;

#define EVENT_CDROM_MEDIA_ARRIVAL 1
#define EVENT_CDROM_MEDIA_REMOVAL 2

/***************************************************************************\
* Win32kPnPDriverEntry
*
* This is the callback function when we call IoCreateDriver to create a
* PnP Driver Object.  In this function, we need to remember the DriverObject.
*
* Parameters:
*   DriverObject - Pointer to the driver object created by the system.
*   RegistryPath - is NULL.
*
* Return Value: STATUS_SUCCESS
*
* History:
* 10-20-97  IanJa   Taken from ntos\io\pnpinit.c
\***************************************************************************/
NTSTATUS Win32kPnPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING pustrRegistryPath)
{
    UNREFERENCED_PARAMETER(pustrRegistryPath);

    TAGMSG1(DBGTAG_PNP,
            "Win32kPnPDriverEntry(DriverObject 0x%p)",
            DriverObject);

    //
    // Squirrel away the pointer to our driver object.
    //
    gpWin32kDriverObject = DriverObject;

    return STATUS_SUCCESS;
}


/***************************************************************************\
* Initialize the global event used in notifying CSR that media has changed.
*
* History:
\***************************************************************************/
NTSTATUS InitializeMediaChange(
    HANDLE hMediaRequestEvent)
{
    NTSTATUS Status;

    if (!IsRemoteConnection()) {
        InitializeListHead(&gCDROMNotifyList);
        InitializeListHead(&gMediaChangeList);

        Status = ObReferenceObjectByHandle(hMediaRequestEvent,
                                           EVENT_ALL_ACCESS,
                                           *ExEventObjectType,
                                           KernelMode,
                                           &gpEventMediaChange,
                                           NULL);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        gMediaChangeMutex = UserAllocPoolNonPagedNS(sizeof(FAST_MUTEX), TAG_PNP);
        if (gMediaChangeMutex) {
            ExInitializeFastMutex(gMediaChangeMutex);
        } else {
            Status = STATUS_NO_MEMORY;
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    return Status;
}

VOID
CleanupMediaChange(
    VOID)
{
    if (gMediaChangeMutex) {
        UserFreePool(gMediaChangeMutex);
        gMediaChangeMutex = 0;
    }
}

__inline VOID EnterMediaCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gMediaChangeMutex);
}

__inline VOID LeaveMediaCrit(
    VOID)
{
    ExReleaseFastMutexUnsafe(gMediaChangeMutex);
    KeLeaveCriticalRegion();
}



/***************************************************************************\
* Routines to support CDROM driver letters.
*
* Execution Context:
*
* History:
\***************************************************************************/
ULONG xxxGetDeviceChangeInfo(
    VOID)
{
    UNICODE_STRING                      name;
    PFILE_OBJECT                        FileObject;
    PDEVICE_OBJECT                      DeviceObject;
    KEVENT                              event;
    PIRP                                irp;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   output;
    IO_STATUS_BLOCK                     ioStatus;
    NTSTATUS                            status;
    PCDROM_NOTIFY                       pContext;
    PTHREADINFO                         ptiCurrent;
    TL                                  tlContext;
    TL                                  tlFileObject;

    ULONG retval = 0;

    if (!(ISCSRSS())) {
        return 0;
    }

    EnterMediaCrit();
    if (!IsListEmpty(&gMediaChangeList)) {
        pContext = (PCDROM_NOTIFY)RemoveTailList(&gMediaChangeList);
    } else {
        pContext = NULL;
    }
    LeaveMediaCrit();

    if (pContext == NULL) {
        return 0;
    }

    ptiCurrent = PtiCurrent();
    ThreadLockPool(ptiCurrent, pContext, &tlContext);

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name,
                                      FILE_READ_ATTRIBUTES,
                                      &FileObject,
                                      &DeviceObject);

    if (NT_SUCCESS(status)) {
        PushW32ThreadLock(FileObject, &tlFileObject, UserDereferenceObject);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER,
                                            DeviceObject,
                                            &pContext->DeviceName,
                                            sizeof(MOUNTMGR_DRIVE_LETTER_TARGET) +
                                                pContext->DeviceName.DeviceNameLength,
                                            &output,
                                            sizeof(output),
                                            FALSE,
                                            &event,
                                            &ioStatus);
        if (irp) {
            /*
             * This IoCallDriver may block nearly for good --- the device
             * may be in the D3 state and IoCallDriver could take way
             * too long, waiting for its powering up.
             * They may not even return STATUS_PENDING.  We'd better
             * leave the critsec here.
             */
            LeaveCrit();

            status = IoCallDriver(DeviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }

            EnterCrit();

            if ((status == STATUS_SUCCESS) && (output.CurrentDriveLetter)) {
                UserAssert((output.CurrentDriveLetter - 'A') < 30);
                retval = 1 << (output.CurrentDriveLetter - 'A');

                if (pContext->Event & EVENT_CDROM_MEDIA_ARRIVAL) {
                    retval |= HMCE_ARRIVAL;
                }
            }
        }

        PopAndFreeW32ThreadLock(&tlFileObject);
    }

    //
    // Allways free the request
    //
    ThreadUnlockAndFreePool(ptiCurrent, &tlContext);

    return retval;
}

/***************************************************************************\
* Handle device notifications such as MediaChanged
*
* Execution Context:
*
* History:
\***************************************************************************/
NTSTATUS DeviceCDROMNotify(
    IN PTARGET_DEVICE_CUSTOM_NOTIFICATION Notification,
    IN PCDROM_NOTIFY pContext)
{
    PCDROM_NOTIFY pNew;

    CheckCritOut();

    if (IsRemoteConnection()) {
        return STATUS_SUCCESS;
    }

    UserAssert(pContext);

    if (IsEqualGUID(&Notification->Event, &GUID_IO_MEDIA_ARRIVAL)) {
        pContext->Event = EVENT_CDROM_MEDIA_ARRIVAL;
    } else if (IsEqualGUID(&Notification->Event, &GUID_IO_MEDIA_REMOVAL)) {
        pContext->Event = EVENT_CDROM_MEDIA_REMOVAL;
    } else if (IsEqualGUID(&Notification->Event, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {
        EnterMediaCrit();
        if (!gCDROMClassRegistrationEntry) {
            // This is being cleaned up by xxxUnregisterDeviceNotifications
            LeaveMediaCrit();
            return STATUS_SUCCESS;
        }
        RemoveEntryList(&pContext->Entry);
        LeaveMediaCrit();
        IoUnregisterPlugPlayNotification(pContext->RegistrationHandle);
        UserFreePool(pContext);
        return STATUS_SUCCESS;
    }
#ifdef AUTORUN_CURSOR
    else if (IsEqualGUID(&Notification->Event, &GUID_IO_DEVICE_BECOMING_READY)) {
        PDEVICE_EVENT_BECOMING_READY pdebr = (DEVICE_EVENT_BECOMING_READY*)Notification->CustomDataBuffer;
        ShowAutorunCursor(pdebr->Estimated100msToReady * 10);
        return STATUS_SUCCESS;
    }
#endif
    else {
        return STATUS_SUCCESS;
    }

    //
    // Process the arrival or removal.
    //
    // We must queue this otherwise we end up bugchecking on Terminal Server
    // This is due to opening a handle from within the system process which
    // requires us to do an attach process.
    //

    pNew = UserAllocPoolNonPaged(pContext->Size, TAG_PNP);
    if (pNew) {
        RtlCopyMemory(pNew, pContext, pContext->Size);

        EnterMediaCrit();
        InsertHeadList(&gMediaChangeList, &pNew->Entry);
        LeaveMediaCrit();

        KeSetEvent(gpEventMediaChange, EVENT_INCREMENT, FALSE);
    }

    return STATUS_SUCCESS;
}



/***************************************************************************\
* DeviceClassCDROMNotify
*
* This gets called when CDROM appears or disappears
*
\***************************************************************************/
NTSTATUS
DeviceClassCDROMNotify (
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION classChange,
    IN PVOID Unused
    )
{
    NTSTATUS       Status = STATUS_SUCCESS;
    PFILE_OBJECT   FileObject;
    PDEVICE_OBJECT DeviceObject;
    PCDROM_NOTIFY  pContext;
    ULONG          Size;

    UNREFERENCED_PARAMETER(Unused);

    CheckCritOut();

    /*
     * Sanity check the DeviceType, and that it matches the InterfaceClassGuid
     */
    UserAssert(IsEqualGUID(&classChange->InterfaceClassGuid, &CdRomClassGuid));

    if (IsEqualGUID(&classChange->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        Status = IoGetDeviceObjectPointer(classChange->SymbolicLinkName,
                                          FILE_READ_ATTRIBUTES,
                                          &FileObject,
                                          &DeviceObject);

        if (NT_SUCCESS(Status)) {

            Size = sizeof(CDROM_NOTIFY) + classChange->SymbolicLinkName->Length;

            pContext = (PCDROM_NOTIFY) UserAllocPool(Size, TAG_PNP);

            //
            // Register For MediaChangeNotifications on all the CDROMs.
            //

            if (pContext) {

                pContext->Size = Size;
                pContext->DeviceName.DeviceNameLength = classChange->SymbolicLinkName->Length;
                RtlCopyMemory(pContext->DeviceName.DeviceName,
                              classChange->SymbolicLinkName->Buffer,
                              pContext->DeviceName.DeviceNameLength);

                if (NT_SUCCESS(IoRegisterPlugPlayNotification (
                        EventCategoryTargetDeviceChange,
                        0,
                        FileObject,
                        gpWin32kDriverObject,
                        DeviceCDROMNotify,
                        pContext,
                        &(pContext->RegistrationHandle)))) {
                    EnterMediaCrit();
                    InsertHeadList(&gCDROMNotifyList, &pContext->Entry);
                    LeaveMediaCrit();
                } else {
                    RIPMSG2(RIP_WARNING,
                            "Failed to register CDROM Device Notification '%.*ws'.",
                            pContext->DeviceName.DeviceNameLength,
                            pContext->DeviceName.DeviceName);
                    UserFreePool(pContext);
                }
            } else {
                RIPMSG2(RIP_WARNING,
                        "Failed to allocate pool block for CDROM '%.*ws'.",
                        pContext->DeviceName.DeviceNameLength,
                        pContext->DeviceName.DeviceName);
            }

            ObDereferenceObject(FileObject);
        }
    } else if (IsEqualGUID(&classChange->Event, &GUID_DEVICE_INTERFACE_REMOVAL)) {

        //
        // Do nothing - we already remove the registration.
        //

    } else {
        RIPMSG0(RIP_ERROR, "Unrecognized Event GUID");
    }

    return STATUS_SUCCESS;
}

#ifdef TRACK_PNP_NOTIFICATION

PPNP_NOTIFICATION_RECORD gpPnpNotificationRecord;
DWORD gdwPnpNotificationRecSize = 256;

UINT giPnpSeq;
BOOL gfRecordPnpNotification = TRUE;

VOID CleanupPnpNotificationRecord(
    VOID)
{
    CheckDeviceInfoListCritIn();

    gfRecordPnpNotification = FALSE;
    if (gpPnpNotificationRecord) {
        UserFreePool(gpPnpNotificationRecord);
        gpPnpNotificationRecord = NULL;
    }
}

VOID RecordPnpNotification(
    PNP_NOTIFICATION_TYPE type,
    PDEVICEINFO pDeviceInfo,
    ULONG_PTR NotificationCode)
{
    UINT iIndex;
    UINT i = 0;
    PUNICODE_STRING pName = NULL;
    HANDLE hDeviceInfo = NULL;

    CheckDeviceInfoListCritIn();
    UserAssert(gfRecordPnpNotification);

    if (gpPnpNotificationRecord == NULL) {
        gpPnpNotificationRecord = UserAllocPoolZInit(sizeof *gpPnpNotificationRecord * gdwPnpNotificationRecSize, TAG_PNP);
    }
    if (gpPnpNotificationRecord == NULL) {
        return;
    }

    iIndex = giPnpSeq % gdwPnpNotificationRecSize;

    gpPnpNotificationRecord[iIndex].pKThread = PsGetCurrentThread();
    gpPnpNotificationRecord[iIndex].iSeq = ++giPnpSeq; // the first record is numbered as 1.
    gpPnpNotificationRecord[iIndex].type = type;
    /*
     * If there is a pathname, copy it here.
     */
    switch (type) {
    case PNP_NTF_CLASSNOTIFY:
        /*
         * pDeviceInfo is actually a pUnicodeString.
         */
        pName = (PUNICODE_STRING)pDeviceInfo;
        pDeviceInfo = NULL;
        break;
    case PNP_NTF_DEVICENOTIFY_UNLISTED:
        /*
         * pDeviceInfo is invalid, cannot be looked up.
         */
        UserAssert(pName == NULL);
        break;
    default:
        if (pDeviceInfo) {
            pName = &pDeviceInfo->ustrName;
            hDeviceInfo = PtoHq(pDeviceInfo);
        }
        break;
    }
    UserAssert(i == 0);
    if (pName) {
        for ( ; i < ARRAY_SIZE(gpPnpNotificationRecord[iIndex].szPathName) - 1 && i < (UINT)pName->Length / sizeof(WCHAR); ++i) {
            gpPnpNotificationRecord[iIndex].szPathName[i] = (UCHAR)pName->Buffer[i];
        }
    }
    gpPnpNotificationRecord[iIndex].szPathName[i] = 0;

    /*
     * Store the rest of information
     */
    gpPnpNotificationRecord[iIndex].pDeviceInfo = pDeviceInfo;
    gpPnpNotificationRecord[iIndex].hDeviceInfo = hDeviceInfo;
    gpPnpNotificationRecord[iIndex].NotificationCode = NotificationCode;

    /*
     * Store the stack trace.
     */
    RtlWalkFrameChain(gpPnpNotificationRecord[iIndex].trace,
                      ARRAY_SIZE(gpPnpNotificationRecord[iIndex].trace),
                      0);
}

#endif // TRACK_PNP_NOTIFICATION


/***************************************************************************\
* CreateDeviceInfo
*
* This creates an instance of an input device for USER.  To do this it:
*  - Allocates a DEVICEINFO struct
*  - Adds it to USER's list of input devices
*  - Initializes some of the fields
*  - Signals the input servicing thread to open and read the new device.
*
* Type - the device type (DEVICE_TYPE_MOUSE, DEVICE_TYPE_KEYBOARD)
* Name - the device name.
*        When trying to open a HYDRA client's mouse, Name is NULL.
* bFlags - some initial flags to set (eg: GDIF_NOTPNP)
*
* THIS FUNCTION IS CALLED IN THE CONTEXT OF THE KERNEL PROCESS
* so we mustn't open the mouse here, else the handle we get will not belong
* to the Win32k process.
*
* History:
* 11-26-90 DavidPe      Created.
* 01-07-98 IanJa        Plug & Play
\***************************************************************************/

PDEVICEINFO CreateDeviceInfo(DWORD DeviceType, PUNICODE_STRING pustrName, BYTE bFlags)
{
    PDEVICEINFO pDeviceInfo = NULL;

    CheckCritIn();
    BEGINATOMICCHECK();

    UserAssert(pustrName != NULL);

    TAGMSGF4(DBGTAG_PNP, "CreateDeviceInfo(%d, %.*ws, %x)", DeviceType, pustrName->Length / sizeof(WCHAR), pustrName->Buffer, bFlags);

    if (DeviceType > DEVICE_TYPE_MAX) {
        RIPMSGF1(RIP_ERROR, "Unknown DeviceType %lx", DeviceType);
    }

#if defined(PRERELEASE) && defined(CHECK_DEVICE_DUPLICATE)
    {
        PDEVICEINFO pdi;

        CheckCritIn();
        EnterDeviceInfoListCrit();
        for (pdi = gpDeviceInfoList; pdi; pdi = pdi->pNext) {
            if (wcsncmp(pustrName->Buffer, pdi->ustrName.Buffer, pdi->ustrName.Length / sizeof(WCHAR)) == 0) {
                TAGMSGF1(DBGTAG_PNP, "the new device is already in the list! %p", pdi);
                break;
            }
        }
        LeaveDeviceInfoListCrit();
    }
#endif

#ifdef GENERIC_INPUT
    pDeviceInfo = (PDEVICEINFO)HMAllocObject(NULL, NULL, (BYTE)TYPE_DEVICEINFO, (DWORD)aDeviceTemplate[DeviceType].cbDeviceInfo);
#else
    pDeviceInfo = UserAllocPoolZInit(aDeviceTemplate[DeviceType].cbDeviceInfo, TAG_PNP);
#endif

    if (pDeviceInfo == NULL) {
        RIPMSGF0(RIP_WARNING, "out of memory allocating DEVICEINFO");
        EXITATOMICCHECK();
        return NULL;
    }

    if (pustrName->Buffer != NULL) {
        pDeviceInfo->ustrName.Buffer = UserAllocPool(pustrName->Length, TAG_PNP);

        if (pDeviceInfo->ustrName.Buffer == NULL) {
            RIPMSGF2(RIP_WARNING, "Can't duplicate string %.*ws",
                    pustrName->Length / sizeof(WCHAR),
                    pustrName->Buffer);
            goto CreateFailed;
        }

        pDeviceInfo->ustrName.MaximumLength = pustrName->Length;
        RtlCopyUnicodeString(&pDeviceInfo->ustrName, pustrName);
    }

    pDeviceInfo->type = (BYTE)DeviceType;
    pDeviceInfo->bFlags |= bFlags;

    /*
     * Create this device's HidChangeCompletion event. When the RIT completes
     * a synchronous ProcessDeviceChanges() it signals the HidChangeCompletion
     * event to wake the requesting RequestDeviceChange() which is blocking on
     * the event.
     * Each device has it's own HidChangeCompletion event,
     * since multiple PnP notification may arrive  for several different
     * devices simultaneously.  (see #331320 IanJa)
     */
    pDeviceInfo->pkeHidChangeCompleted = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (pDeviceInfo->pkeHidChangeCompleted == NULL) {
        RIPMSGF0(RIP_WARNING,
                "failed to create pkeHidChangeCompleted");
        goto CreateFailed;
    }

    EnterDeviceInfoListCrit();

#ifdef TRACK_PNP_NOTIFICATION
    /*
     * Placing tracking code here may miss the failure cases above,
     * but they're pretty exceptional cases that can be safely ignored.
     */
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_CREATEDEVICEINFO, pDeviceInfo, DeviceType);
    }
#endif

#ifdef GENERIC_INPUT

    if (aDeviceTemplate[DeviceType].dwFlags & DT_HID) {
        /*
         * Create HID specific information.
         */
        pDeviceInfo->hid.pHidDesc = HidCreateDeviceInfo(pDeviceInfo);

        if (pDeviceInfo->hid.pHidDesc == NULL) {
            /*
             * Something wrong happened and we failed to
             * create the device information.
             * Or the device is not our target.
             * Should bail out anyway.
             */
            TAGMSGF0(DBGTAG_PNP, "HidCreateDeviceInfo bailed out.");
            LeaveDeviceInfoListCrit();
            goto CreateFailed;
        }
    }
#endif

    /*
     * Link it in
     */
    pDeviceInfo->pNext = gpDeviceInfoList;
    gpDeviceInfoList = pDeviceInfo;

    /*
     * Tell the RIT there is a new device so that it can open it and start
     * reading from it.  This is non-blocking (no GDIAF_PNPWAITING bit set)
     */
    RequestDeviceChange(pDeviceInfo, GDIAF_ARRIVED, TRUE);
    LeaveDeviceInfoListCrit();

    EXITATOMICCHECK();
    return pDeviceInfo;

CreateFailed:
    if (pDeviceInfo) {
        if (pDeviceInfo->ustrName.Buffer) {
            UserFreePool(pDeviceInfo->ustrName.Buffer);
        }
#ifdef GENERIC_INPUT
        if (pDeviceInfo->hid.pHidDesc) {
            FreeHidDesc(pDeviceInfo->hid.pHidDesc);
#if DBG
            pDeviceInfo->hid.pHidDesc = NULL;
#endif
        }
        if (pDeviceInfo->pkeHidChangeCompleted) {
            FreeKernelEvent(&pDeviceInfo->pkeHidChangeCompleted);
        }
        HMFreeObject(pDeviceInfo);
#else
        UserFreePool(pDeviceInfo);
#endif
    }

    ENDATOMICCHECK();
    return NULL;
}


/***************************************************************************\
* DeviceClassNotify
*
* This gets called when an input device is attached or detached.
* If this happens during initialization (for mice already connected) we
* come here by in the context of the RIT.  If hot-(un)plugging a mouse,
* then we are called on a thread from the Kernel process.
*
* History:
* 10-20-97  IanJa   Taken from some old code of KenRay's
\***************************************************************************/
NTSTATUS
DeviceClassNotify (
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION classChange,
    IN PVOID DeviceType // (context)
    )
{
    DWORD dwDeviceType;

    CheckCritOut();
    dwDeviceType = PtrToUlong( DeviceType );
    TAGMSG2(DBGTAG_PNP, "enter DeviceClassNotify(%lx, %lx)", classChange, dwDeviceType);

    /*
     * Sanity check the DeviceType, and that it matches the InterfaceClassGuid
     */
    UserAssert(dwDeviceType <= DEVICE_TYPE_MAX);
    UserAssert(IsEqualGUID(&classChange->InterfaceClassGuid, aDeviceTemplate[dwDeviceType].pClassGUID));

    if (IsRemoteConnection()) {
        return STATUS_SUCCESS;
    }

    TAGMSG3(DBGTAG_PNP | RIP_THERESMORE, " Event GUID %lx, %x, %x",
            classChange->Event.Data1,
            classChange->Event.Data2,
            classChange->Event.Data3);
    TAGMSG8(DBGTAG_PNP | RIP_THERESMORE, " %2x%2x%2x%2x%2x%2x%2x%2x",
            classChange->Event.Data4[0], classChange->Event.Data4[1],
            classChange->Event.Data4[2], classChange->Event.Data4[3],
            classChange->Event.Data4[4], classChange->Event.Data4[5],
            classChange->Event.Data4[6], classChange->Event.Data4[7]);
    TAGMSG4(DBGTAG_PNP | RIP_THERESMORE, " InterfaceClassGuid %lx, %lx, %lx, %lx",
            ((DWORD *)&(classChange->InterfaceClassGuid))[0],
            ((DWORD *)&(classChange->InterfaceClassGuid))[1],
            ((DWORD *)&(classChange->InterfaceClassGuid))[2],
            ((DWORD *)&(classChange->InterfaceClassGuid))[3]);
    TAGMSG1(DBGTAG_PNP | RIP_THERESMORE, " SymbolicLinkName %ws", classChange->SymbolicLinkName->Buffer);

    if (IsEqualGUID(&classChange->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        // A new hid device class association has arrived
        EnterCrit();
        TRACE_INIT(("DeviceClassNotify - SymbolicLinkName : %ws \n", classChange->SymbolicLinkName->Buffer));
#ifdef TRACK_PNP_NOTIFICATION
        if (gfRecordPnpNotification) {
            CheckDeviceInfoListCritOut();
            EnterDeviceInfoListCrit();
            RecordPnpNotification(PNP_NTF_CLASSNOTIFY, (PVOID)classChange->SymbolicLinkName, (ULONG_PTR)DeviceType);
            LeaveDeviceInfoListCrit();
        }
#endif
        CreateDeviceInfo(dwDeviceType, classChange->SymbolicLinkName, 0);
        LeaveCrit();
        TAGMSG0(DBGTAG_PNP, "=== CREATED ===");
    }

    return STATUS_SUCCESS;
}

/****************************************************************************\
* If a device class "all-for-one" setting (ConnectMultiplePorts) is on,
* then we just open the device the old (non-PnP) way and return TRUE.  (As a
* safety feature we also do this if gpWin32kDriverObject is NULL, because this
* driver object is needed to register for PnP device class notifications)
* Otherwise, return FALSE so we can continue and register for Arrival/Departure
* notifications.
*
* This code was originally intended to be temporary until ConnectMultiplePorts
* was finally turned off.
* But now I think we have to keep it for backward compatibility with
* drivers that filter Pointer/KeyboardClass0 and/or those that replace
* Pointer/KeyboardClass0 by putting a different name in the registry under
* System\CurrentControlSet\Services\RIT\mouclass (or kbbclass)
\****************************************************************************/
BOOL
OpenMultiplePortDevice(DWORD DeviceType)
{
    WCHAR awchDeviceName[MAX_PATH];
    UNICODE_STRING DeviceName;
    PDEVICE_TEMPLATE pDevTpl;
    PDEVICEINFO pDeviceInfo;
    PWCHAR pwchNameIndex;

    UINT uiConnectMultiplePorts = 0;

    CheckCritIn();

    if (DeviceType <= DEVICE_TYPE_MAX) {
        pDevTpl = &aDeviceTemplate[DeviceType];
    } else {
        RIPMSG1(RIP_ERROR, "OpenMultiplePortDevice(%d) - unknown type", DeviceType);
        return FALSE;
    }

    if (IsRemoteConnection()) {
        return FALSE;
    }

#ifdef GENERIC_INPUT
    if (pDevTpl->dwFlags & DT_HID) {
        /*
         * HID devices don't need multiple port
         */
        return FALSE;
    }
#endif // GENERIC_INPUT

    /*
     * Note that we don't need to FastOpenUserProfileMapping() here since
     * uiRegistrySection (PMAP_MOUCLASS_PARAMS/PMAP_KBDCLASS_PARAMS) is a
     * machine setiing, not a user setting.
     */
    FastGetProfileDwordW(NULL,
            pDevTpl->uiRegistrySection, L"ConnectMultiplePorts", 0, &uiConnectMultiplePorts, 0);

    /*
     * Open the device for read access.
     */
    if (uiConnectMultiplePorts || (gpWin32kDriverObject == NULL)) {
        /*
         * Find out if there is a name substitution in the registry.
         * Note that we don't need to FastOpenUserProfileMapping() here since
         * PMAP_INPUT is a machine setting, not a user setting.
         */
        FastGetProfileStringW(NULL,
                PMAP_INPUT,
                pDevTpl->pwszClassName,
                pDevTpl->pwszDefDevName, // if no substitution, use this default
                awchDeviceName,
                sizeof(awchDeviceName)/sizeof(WCHAR),
                0);

        RtlInitUnicodeString(&DeviceName, awchDeviceName);

        pDeviceInfo = CreateDeviceInfo(DeviceType, &DeviceName, GDIF_NOTPNP);
        if (pDeviceInfo) {
            return TRUE;
        }
    } else {
        DeviceName.Length = 0;
        DeviceName.MaximumLength = sizeof(awchDeviceName);
        DeviceName.Buffer = awchDeviceName;

        RtlAppendUnicodeToString(&DeviceName, pDevTpl->pwszLegacyDevName);
        pwchNameIndex = &DeviceName.Buffer[(DeviceName.Length / sizeof(WCHAR)) - 1];
        for (*pwchNameIndex = L'0'; *pwchNameIndex <= L'9'; (*pwchNameIndex)++) {
            CreateDeviceInfo(DeviceType, &DeviceName, GDIF_NOTPNP);
        }
    }

    return FALSE;
}

/***************************************************************************\
* RegisterCDROMNotify
*
* History:
* 08-21-00  VTan    Created
\***************************************************************************/
VOID RegisterCDROMNotify(
    VOID)
{
    UserAssert(!IsRemoteConnection());
    UserAssert(gpWin32kDriverObject != NULL);

    if (gpWin32kDriverObject != NULL) {
        IoRegisterPlugPlayNotification (
            EventCategoryDeviceInterfaceChange,
            PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
            (PVOID) &CdRomClassGuid,
            gpWin32kDriverObject,
            (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)DeviceClassCDROMNotify,
            NULL,
            &gCDROMClassRegistrationEntry);
    }
}

/***************************************************************************\
* RegisterForDeviceClassNotifications
*
* Get ready to receive notifications that a mouse or keyboard is plugged in
* or removed, then request notifications by registering for them.
*
* History:
* 10-20-97  IanJa   Taken from ntos\io\pnpinit.c
\***************************************************************************/
NTSTATUS
xxxRegisterForDeviceClassNotifications(
    VOID)
{
    IO_NOTIFICATION_EVENT_CATEGORY eventCategory;
    ULONG eventFlags;
    NTSTATUS Status;
    UNICODE_STRING ustrDriverName;
    DWORD DeviceType;

    CheckCritIn();

    TAGMSG0(DBGTAG_PNP, "enter xxxRegisterForDeviceClassNotifications()");

    /*
     * Remote hydra session indicates CreateDeviceInfo in xxxRemoteReconnect.
     */
    UserAssert(!IsRemoteConnection());

    if (!gbFirstConnectionDone) {
       if (!gbRemoteSession) {
           // Session 0
           /*
            * This must be done before devices are registered for device
            * notifications which will occur as a result of CreateDeviceInfo.
            */
           RtlInitUnicodeString(&ustrDriverName, L"\\Driver\\Win32k");
           Status = IoCreateDriver(&ustrDriverName, Win32kPnPDriverEntry);

           TAGMSG1(DBGTAG_PNP | RIP_THERESMORE, "IoCreateDriver returned status = %lx", Status);
           TAGMSG1(DBGTAG_PNP, "gpWin32kDriverObject = %lx", gpWin32kDriverObject);

           if (!NT_SUCCESS(Status)) {
               RIPMSG1(RIP_ERROR, "IoCreateDriver failed, status %lx", Status);
               Status = STATUS_SUCCESS;
           }

           UserAssert(gpWin32kDriverObject);
       } else {
           UserAssert(gpWin32kDriverObject == NULL);
           /*
            * Non-Zero session attached to the console
            */

           RtlInitUnicodeString(&ustrDriverName, L"\\Driver\\Win32k");

           //
           // Attempt to open the driver object
           //
           Status = ObReferenceObjectByName(&ustrDriverName,
                                            OBJ_CASE_INSENSITIVE,
                                            NULL,
                                            0,
                                            *IoDriverObjectType,
                                            KernelMode,
                                            NULL,
                                            &gpWin32kDriverObject);
           if (!NT_SUCCESS(Status)) {
               RIPMSG1(RIP_ERROR, "ObReferenceObjectByName failed, status %lx", Status);
               Status = STATUS_SUCCESS;
           }
           UserAssert(gpWin32kDriverObject);
       }
    }

    //
    // We are only interested in DeviceClasses changing.
    //
    eventCategory = EventCategoryDeviceInterfaceChange;

    //
    // We want to be notified for all devices that are in the system.
    // those that are know now, and those that will arive later.
    // This allows us to have one code path for adding devices, and eliminates
    // the nasty race condition.  If we were only interested in the devices
    // that exist at this one moment in time, and not future devices, we
    // would call IoGetDeviceClassAssociations.
    //
    eventFlags = PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES;


    /*
     * For all input device types:
     *  If they are Multiple Port Devices (ie: not PnP) just open them
     *  Else Register them for PnP notifications (they will be opened when the
     *       arrival notification arrives.
     * If devices are already attached, we will received immediate notification
     * during the call to IoRegisterPlugPlayNotification, so we must LeaveCrit
     * because the callback routine DeviceClassNotify expects it.
     */
    for (DeviceType = 0; DeviceType <= DEVICE_TYPE_MAX; DeviceType++) {
        if (!OpenMultiplePortDevice(DeviceType) && (gpWin32kDriverObject != NULL)) {
            /*
             * Make the registration.
             */

            TAGMSG1(DBGTAG_PNP, "Registering device type %d", DeviceType);

            LeaveCrit(); // for DeviceClassNotify
            Status = IoRegisterPlugPlayNotification (
                         eventCategory,
                         eventFlags,
                         (PVOID)aDeviceTemplate[DeviceType].pClassGUID,
                         gpWin32kDriverObject,
                         (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)DeviceClassNotify,
                         LongToPtr( DeviceType ),
                         &aDeviceClassNotificationEntry[DeviceType]);

            EnterCrit();


            TAGMSG1(DBGTAG_PNP, "Registration returned status %lx", Status);
            if (!NT_SUCCESS(Status)) {
                RIPMSG2(RIP_ERROR, "IoRegisterPlugPlayNotification(%d) failed, status %lx",
                        DeviceType, Status);
            }
        }
    }

    // Now Register for CD_ROM notifications
    LeaveCrit(); // for DeviceClassNotify

    if (!gbFirstConnectionDone && gpWin32kDriverObject != NULL) {
        if (!IsRemoteConnection()) {
            RegisterCDROMNotify();
        }

        gbFirstConnectionDone = TRUE;
    }
    EnterCrit();

    return Status;
}

/***************************************************************************\
* UnregisterDeviceClassNotifications
*
* Remove device class notification registrations.
*
* History:
* 02-28-00  Earhart  Created
\***************************************************************************/
VOID
xxxUnregisterDeviceClassNotifications(
    VOID)
{
    // Our input devices will automatically unregister themselves; we
    // need to clean up cdrom, though.
    PLIST_ENTRY   pNext;
    PCDROM_NOTIFY pContext;
    PVOID         RegistrationEntry;

    EnterMediaCrit();

    if (gCDROMClassRegistrationEntry) {
        RegistrationEntry = gCDROMClassRegistrationEntry;
        gCDROMClassRegistrationEntry = NULL;
        LeaveMediaCrit();
        IoUnregisterPlugPlayNotification(RegistrationEntry);
        EnterMediaCrit();
    }

    while (TRUE) {
        pNext = RemoveHeadList(&gCDROMNotifyList);
        if (!pNext || pNext == &gCDROMNotifyList) {
            break;
        }
        pContext = CONTAINING_RECORD(pNext, CDROM_NOTIFY, Entry);
        LeaveMediaCrit();       /* in case there's a notification pending */
        IoUnregisterPlugPlayNotification(pContext->RegistrationHandle);
        UserFreePool(pContext);
        EnterMediaCrit();
    }

    LeaveMediaCrit();
}

/***************************************************************************\
* GetKbdExId
*
* Get extended keyboard id with WMI
*
* History:
* 01-02-01  Hiroyama    Created
\***************************************************************************/
NTSTATUS GetKbdExId(
    HANDLE hDevice,
    PKEYBOARD_ID_EX pIdEx)
{
    PWNODE_SINGLE_INSTANCE pNode;
    ULONG size;
    PVOID p = NULL;
    NTSTATUS status;
    UNICODE_STRING str;

    status = IoWMIOpenBlock((LPGUID)&MSKeyboard_ExtendedID_GUID, WMIGUID_QUERY, &p);

    if (NT_SUCCESS(status)) {
        status = IoWMIHandleToInstanceName(p, hDevice, &str);
        TAGMSG2(DBGTAG_PNP, "GetKbdExId: DevName='%.*ws'",
                str.Length / sizeof(WCHAR),
                str.Buffer);

        if (NT_SUCCESS(status)) {
            // Get the size
            size = 0;
            IoWMIQuerySingleInstance(p, &str, &size, NULL);

            size += sizeof *pIdEx;
            pNode = UserAllocPoolNonPaged(size, TAG_KBDEXID);

            if (pNode) {
                status = IoWMIQuerySingleInstance(p, &str, &size, pNode);
                if (NT_SUCCESS(status)) {
                    *pIdEx = *(PKEYBOARD_ID_EX)(((PUCHAR)pNode) + pNode->DataBlockOffset);
                }

                UserFreePool(pNode);
            }

            RtlFreeUnicodeString(&str);
        }

        ObDereferenceObject(p);
    }

    return status;
}


/***************************************************************************\
* QueryDeviceInfo
*
* Query the device information.  This function is an async function,
* so be sure any buffers it uses aren't allocated on the stack!
*
* If this is an asynchronous IOCTL, perhaps we should be waiting on
* the file handle or on an event for it to succeed?
*
* This function must called by the RIT, not directly by PnP notification
* (else the handle we issue the IOCTL on will be invalid)
*
* History:
* 01-20-99 IanJa        Created.
\***************************************************************************/
NTSTATUS
QueryDeviceInfo(
    PDEVICEINFO pDeviceInfo)
{
    NTSTATUS Status;
    PDEVICE_TEMPLATE pDevTpl = &aDeviceTemplate[pDeviceInfo->type];
    KEYBOARD_ID_EX IdEx;

#ifdef GENERIC_INPUT
    UserAssert(pDeviceInfo->type != DEVICE_TYPE_HID);
#endif

#ifdef DIAGNOSE_IO
    pDeviceInfo->AttrStatus =
#endif
    Status = ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                 &pDeviceInfo->iosb,
                 pDevTpl->IOCTL_Attr,
                 NULL, 0,
                 (PVOID)((PBYTE)pDeviceInfo + pDevTpl->offAttr),
                 pDevTpl->cbAttr);

    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING, "QueryDeviceInfo(%p): IOCTL failed - Status %lx",
                pDeviceInfo, Status);
    }
    TAGMSG1(DBGTAG_PNP, "IOCTL_*_QUERY_ATTRIBUTES returns Status %lx", Status);

    if (pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) {
        if (NT_SUCCESS(GetKbdExId(pDeviceInfo->handle, &IdEx))) {
            TAGMSG4(DBGTAG_PNP, "QueryDeviceInfo: kbd (%x,%x) ExId:(%x,%x)",
                    pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type, pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype,
                    IdEx.Type, IdEx.Subtype);
            pDeviceInfo->keyboard.IdEx = IdEx;
        } else {
            // What can we do?
            pDeviceInfo->keyboard.IdEx.Type = pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type;
            pDeviceInfo->keyboard.IdEx.Subtype = pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype;
            TAGMSG3(DBGTAG_PNP, "QueryDeviceInfo: failed to get ExId for pDevice=%p, fallback to (%x,%x)",
                    pDeviceInfo, pDeviceInfo->keyboard.IdEx.Type, pDeviceInfo->keyboard.IdEx.Subtype);
        }
    }

    return Status;
}


/***************************************************************************\
* OpenDevice
*
* This function opens an input device for USER, mouse or keyboard.
*
*
* Return value
*   BOOL did the operation succeed?
*
* When trying to open a HYDRA client's mouse (or kbd?), pDeviceInfo->ustrName
* is NULL.
*
* This function must called by the RIT, not directly by PnP
* notification (that way the handle we are about to create will be in the right
* our process)
*
* History:
* 11-26-90 DavidPe      Created.
* 01-07-98 IanJa        Plug & Play
* 04-17-98 IanJa        Only open mice in RIT context.
\***************************************************************************/
BOOL OpenDevice(
    PDEVICEINFO pDeviceInfo)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    ULONG ulAccessMode = FILE_READ_DATA | SYNCHRONIZE;
    ULONG ulShareMode = FILE_SHARE_WRITE;
    UINT i;

    CheckCritIn();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));

    TAGMSG4(DBGTAG_PNP, "OpenDevice(): Opening type %d (%lx %.*ws)",
            pDeviceInfo->type, pDeviceInfo->handle, pDeviceInfo->ustrName.Length / sizeof(WCHAR), pDeviceInfo->ustrName.Buffer);

#ifdef DIAGNOSE_IO
    pDeviceInfo->OpenerProcess = PsGetCurrentProcessId();
#endif

    if (IsRemoteConnection()) {

        TRACE_INIT(("OpenDevice - Remote mode\n"));

        /*
         * For other than the console, the mouse handle is
         * set before createwinstation.
         */

        pDeviceInfo->bFlags |= GDIF_NOTPNP;

        switch (pDeviceInfo->type) {
        case DEVICE_TYPE_MOUSE:
            pDeviceInfo->handle = ghRemoteMouseChannel;
            if (ghRemoteMouseChannel == NULL) {
               return FALSE;
            }
            break;
        case DEVICE_TYPE_KEYBOARD:
            pDeviceInfo->handle = ghRemoteKeyboardChannel;
            if (ghRemoteKeyboardChannel == NULL) {
               return FALSE;
            }
            break;
        default:
            RIPMSG2(RIP_ERROR, "Unknown device type %d DeviceInfo %#p",
                    pDeviceInfo->type, pDeviceInfo);
            return FALSE;
        }
    } else {
        InitializeObjectAttributes(&ObjectAttributes, &(pDeviceInfo->ustrName), 0, NULL, NULL);

#ifdef GENERIC_INPUT
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            ulAccessMode |= FILE_WRITE_DATA;
            ulShareMode |= FILE_SHARE_READ;
        }
#endif

        // USB devices are slow, so they may not have been closed before we
        // open again here so let us delay execution for some time and try
        // to open them again. We delay 1/10th of a second for a max of 30
        // times, making a total wait time of 3 seconds.
        //
        // If we fast user switch too fast, the serial port may be in the
        // process of closing where it stalls execution. This is a rare
        // case where we may open the serial port while it is stalling
        // and get back STATUS_ACCESS_DENIED and lose the user's device.
        // In this case, we should retry the open and it should succeed
        // once the serial port has closed.

        for (i = 0; i < MAX_RETRIES_TO_OPEN; i++) {
#ifdef DIAGNOSE_IO
        pDeviceInfo->OpenStatus =
#endif
            Status = ZwCreateFile(&pDeviceInfo->handle, ulAccessMode,
                    &ObjectAttributes, &pDeviceInfo->iosb, NULL, 0, ulShareMode, FILE_OPEN_IF, 0, NULL, 0);

            if ((STATUS_SHARING_VIOLATION == Status) ||
                (Status == STATUS_ACCESS_DENIED)) {
                // Sleep for 1/10th of a second
                UserSleep(100);
            } else {
                // Device opened successfully or some other error occured
                break;
            }
        }

        TAGMSG2(DBGTAG_PNP, "ZwCreateFile returns handle %lx, Status %lx",
                pDeviceInfo->handle, Status);

        if (!NT_SUCCESS(Status)) {
            if ((pDeviceInfo->bFlags & GDIF_NOTPNP) == 0) {
                /*
                 * Don't warn about PS/2 mice: the PointerClassLegacy0 -9 and
                 * KeyboardClassLegacy0 - 9 will usually fail to be created
                 */
                RIPMSG1(RIP_WARNING, "OpenDevice: ZwCreateFile failed with Status %lx", Status);
            }
            TRACE_INIT(("OpenDevice: ZwCreateFile failed with Status %lx", Status));
            /*
             * Don't FreeDeviceInfo here because that alters gpDeviceInfoList
             * which our caller, ProcessDeviceChanges, is traversing.
             * Instead, let ProcessDeviceChanges do it.
             */
            return FALSE;
        }
    }

#ifdef GENERIC_INPUT
    /*
     * All the HID Information has been already acquired through
     * HidCreateDeviceInfo. Let's skip HID deviceinfo here.
     */
    if (pDeviceInfo->type != DEVICE_TYPE_HID) {
#endif
        Status = QueryDeviceInfo(pDeviceInfo);
#ifdef GENERIC_INPUT
    }
#endif

    return NT_SUCCESS(Status);
}

VOID CloseDevice(
    PDEVICEINFO pDeviceInfo)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    CheckCritIn();

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        CheckDeviceInfoListCritIn();
        RecordPnpNotification(PNP_NTF_CLOSEDEVICE, pDeviceInfo, pDeviceInfo->usActions);
    }
#endif // TRACK_PNP_NOTIFICATION

    TAGMSG5(DBGTAG_PNP, "CloseDevice(%p): closing type %d (%lx %.*ws)",
            pDeviceInfo,
            pDeviceInfo->type, pDeviceInfo->handle,
            pDeviceInfo->ustrName.Length / sizeof(WCHAR), pDeviceInfo->ustrName.Buffer);

    if (pDeviceInfo->handle) {
        UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

        ZwCancelIoFile(pDeviceInfo->handle, &IoStatusBlock);
        UserAssertMsg2(NT_SUCCESS(IoStatusBlock.Status), "NtCancelIoFile handle %x failed status %#x",
                 pDeviceInfo->handle, IoStatusBlock.Status);

        if (pDeviceInfo->handle == ghRemoteMouseChannel) {
           UserAssert(pDeviceInfo->type == DEVICE_TYPE_MOUSE);
           pDeviceInfo->handle = 0;
           return;
        }

        if (pDeviceInfo->handle == ghRemoteKeyboardChannel) {
           UserAssert(pDeviceInfo->type == DEVICE_TYPE_KEYBOARD);
           pDeviceInfo->handle = 0;
           return;
        }

        Status = ZwClose(pDeviceInfo->handle);
        UserAssertMsg2(NT_SUCCESS(Status), "ZwClose handle %x failed status %#x",
                pDeviceInfo->handle, Status);
        pDeviceInfo->handle = 0;
    } else {
#ifdef GENERIC_INPUT
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            /*
             * HID devices may be closed regardless the error conditions.
             */
            TAGMSG2(DBGTAG_PNP, "CloseDevice: hid: pDeviceInfo->iosb.Status=%x, ReadStatus=%x",
                    pDeviceInfo->iosb.Status, pDeviceInfo->ReadStatus);
        } else {
#endif
            /*
             * Assert the IO was cancelled or we tried to read the device
             * after the first close (which set the handle to 0 - an invalid handle)
             */
            UserAssert((pDeviceInfo->iosb.Status == STATUS_CANCELLED) ||
                       (pDeviceInfo->ReadStatus == STATUS_INVALID_HANDLE));

#ifdef GENERIC_INPUT
        }
#endif
    }
}

/*****************************************************************************\
* RegisterForDeviceChangeNotifications()
*
* Device Notifications such as QueryRemove, RemoveCancelled, RemoveComplete
* tell us what is going on with the mouse.
* To register for device notifications:
* (1) Obtain a pointer to the device object (pFileObject)
* (2) Register for target device change notifications, saving the
*     notification handle (which we will need in order to deregister)
*
* It doesn't matter too much if this fails: we just won't be able to eject the
* hardware via the UI very successfully. (We can still just yank it though).
* This will also fail if the ConnectMultiplePorts was set for this device.
*
* 1998-10-05 IanJa    Created
\*****************************************************************************/
BOOL RegisterForDeviceChangeNotifications(
    PDEVICEINFO pDeviceInfo)
{
    PFILE_OBJECT pFileObject;
    NTSTATUS Status;

    /*
     * In or Out of User critical section:
     * In when called from RIT ProcessDeviceChanges();
     * Out when called from the DeviceNotify callback
     */

    if (IsRemoteConnection()) {
        TRACE_INIT(("RegisterForDeviceChangeNotifications called for remote session\n"));
        return TRUE;
    }


    CheckCritIn();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));
    UserAssert(pDeviceInfo->handle);
    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

    if (pDeviceInfo->bFlags & GDIF_NOTPNP) {
        return TRUE;
    }
    Status = ObReferenceObjectByHandle(pDeviceInfo->handle,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID)&pFileObject,
                                       NULL);
    if (NT_SUCCESS(Status)) {
        Status = IoRegisterPlugPlayNotification (
                EventCategoryTargetDeviceChange,  // EventCategory
                0,                                // EventCategoryFlags
                (PVOID)pFileObject,               // EventCategoryData
                gpWin32kDriverObject,             // DriverObject
                // (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)
                DeviceNotify,
                (PVOID)pDeviceInfo,                       // Context
                &pDeviceInfo->NotificationEntry);
        ObDereferenceObject(pFileObject);
        if (!NT_SUCCESS(Status)) {
            // This is only OK if ConnectMultiplePorts is on (ie: not a PnP device)
            // For the record, the old RIPMSG referred NTBUG #333453.
            RIPMSG3(RIP_ERROR,
                    "IoRegisterPlugPlayNotification failed on device %.*ws, status %lx",
                    pDeviceInfo->ustrName.Length / sizeof(WCHAR),
                    pDeviceInfo->ustrName.Buffer, Status);
        }
    } else {
        // non-catastrophic error (won't be able to remove device)
        RIPMSG2(RIP_ERROR, "Can't get pFileObject from handle %lx, status %lx",
                pDeviceInfo->handle, Status);
    }

    return NT_SUCCESS(Status);
}


BOOL UnregisterForDeviceChangeNotifications(PDEVICEINFO pDeviceInfo)
{
    NTSTATUS Status;

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        CheckDeviceInfoListCritIn();
        RecordPnpNotification(PNP_NTF_UNREGISTER_NOTIFICATION, pDeviceInfo, pDeviceInfo->usActions);
    }
#endif

    CheckCritIn();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));
    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

    if (pDeviceInfo->NotificationEntry == NULL) {
        /*
         * This happens for non-PnP devices or if the earlier
         * IoRegisterPlugPlayNotification() failed.  Return now since
         * IoUnregisterPlugPlayNotification(NULL) will bluescreen.
         * And other case is also when we detach remote devices (which are
         * not PnP) when reconnecting locally.
         */
        return TRUE;
    }

    // non-PnP devices should not have any NotificationEntry:
    UserAssert((pDeviceInfo->bFlags & GDIF_NOTPNP) == 0);

    TAGMSG4(DBGTAG_PNP, "UnregisterForDeviceChangeNotifications(): type %d (%lx %.*ws)",
            pDeviceInfo->type, pDeviceInfo, pDeviceInfo->ustrName.Length / sizeof(WCHAR), pDeviceInfo->ustrName.Buffer);
    Status = IoUnregisterPlugPlayNotification(pDeviceInfo->NotificationEntry);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_ERROR,
                "IoUnregisterPlugPlayNotification failed Status = %lx, DEVICEINFO %lx",
                Status, pDeviceInfo);
        return FALSE;
    }
    pDeviceInfo->NotificationEntry = 0;
    return TRUE;
}


/***************************************************************************\
* Handle device notifications such as QueryRemove, CancelRemove etc.
*
* Execution Context:
*    when yanked:  a non-WIN32 thread.
*    via UI:       ??? (won't see this except from laptop being undocked?)
*
* History:
\***************************************************************************/
__inline USHORT GetPnpActionFromGuid(
    GUID *pEvent)
{
    USHORT usAction = 0;

    if (IsEqualGUID(pEvent, &GUID_TARGET_DEVICE_QUERY_REMOVE)) {
        TAGMSG0(DBGTAG_PNP | RIP_NONAME, "QueryRemove");
        usAction = GDIAF_QUERYREMOVE;

    } else if (IsEqualGUID(pEvent, &GUID_TARGET_DEVICE_REMOVE_CANCELLED)) {
        TAGMSG0(DBGTAG_PNP | RIP_NONAME, "RemoveCancelled");
        usAction = GDIAF_REMOVECANCELLED;

    } else if (IsEqualGUID(pEvent, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {
        TAGMSG1(DBGTAG_PNP | RIP_NONAME, "RemoveComplete (process %#x)", PsGetCurrentProcessId());
        usAction = GDIAF_DEPARTED;

    } else {
        TAGMSG4(DBGTAG_PNP | RIP_NONAME, "GUID Unknown: %lx:%lx:%lx:%x...",
                pEvent->Data1, pEvent->Data2,
                pEvent->Data3, pEvent->Data4[0]);
    }
    return usAction;
}


NTSTATUS DeviceNotify(
    IN PPLUGPLAY_NOTIFY_HDR pNotification,
    IN PDEVICEINFO pDeviceInfo)  // should the context be a kernel address?
{
    USHORT usAction;
    PDEVICEINFO pDeviceInfoTmp;

    CheckCritOut();
    CheckDeviceInfoListCritOut();

    /*
     * Check the validity of pDeviceInfo.
     */
    EnterDeviceInfoListCrit();
    for (pDeviceInfoTmp = gpDeviceInfoList; pDeviceInfoTmp; pDeviceInfoTmp = pDeviceInfoTmp->pNext) {
        if (pDeviceInfoTmp == pDeviceInfo) {
            break;
        }
    }
    if (pDeviceInfoTmp == NULL) {
        /*
         * This is an unknown device, most likely the one already freed.
         */
#ifdef TRACK_PNP_NOTIFICATION
        if (gfRecordPnpNotification) {
            RecordPnpNotification(PNP_NTF_DEVICENOTIFY_UNLISTED, pDeviceInfo, GetPnpActionFromGuid(&pNotification->Event));
        }
#endif

        RIPMSG1(RIP_ERROR, "win32k!DeviceNotify: Notification for unlisted DEVICEINFO %p, contact ntuserdt!", pDeviceInfo);

        LeaveDeviceInfoListCrit();
        /*
         * Not to prevent device removal etc.,
         * return success here.
         */
        return STATUS_SUCCESS;
    }

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_DEVICENOTIFY, pDeviceInfo, GetPnpActionFromGuid(&pNotification->Event));
    }
#endif
    LeaveDeviceInfoListCrit();

    if (IsRemoteConnection()) {
        return STATUS_SUCCESS;
    }

    TAGMSG1(DBGTAG_PNP | RIP_THERESMORE, "DeviceNotify >>> %lx", pDeviceInfo);

    UserAssert(pDeviceInfo->OpenerProcess != PsGetCurrentProcessId());
    UserAssert(pDeviceInfo->usActions == 0);

    usAction = GetPnpActionFromGuid(&pNotification->Event);
    if (usAction == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Signal the RIT to ProcessDeviceChanges()
     * Wait for completion according to the GDIAF_PNPWAITING bit
     */
    CheckCritOut();
    CheckDeviceInfoListCritOut();

    /*
     * There is small window where we can get a PnP notification for a device that
     * we just have unregister unregistered a notification for and that we are deleting
     * so for PnP notification we need to check the device is valid (still in the list
     * and not being deleted.
     */
    EnterDeviceInfoListCrit();
    pDeviceInfoTmp = gpDeviceInfoList;
    while (pDeviceInfoTmp) {
        if (pDeviceInfoTmp == pDeviceInfo ) {
            if (!(pDeviceInfo->usActions & (GDIAF_FREEME | GDIAF_DEPARTED)))  {
                KeResetEvent(gpEventPnPWainting);
                gbPnPWaiting = TRUE;
                RequestDeviceChange(pDeviceInfo, (USHORT)(usAction | GDIAF_PNPWAITING), TRUE);
                gbPnPWaiting = FALSE;
                KeSetEvent(gpEventPnPWainting, EVENT_INCREMENT, FALSE);
            }
            break;
        }
        pDeviceInfoTmp = pDeviceInfoTmp->pNext;
    }
    LeaveDeviceInfoListCrit();

    return STATUS_SUCCESS;
}


/***************************************************************************\
* StartDeviceRead
*
* This function makes an asynchronous read request to the input device driver,
* unless the device has been marked for destruction (GDIAF_FREEME)
*
* Returns:
*   The next DeviceInfo on the list if this device was freed: If the caller
*   was not already in the DeviceInfoList critical section, the this must be
*   ignored as it is not safe.
*   NULL if the read succeeded.
*
* History:
* 11-26-90 DavidPe      Created.
* 10-20-98 IanJa        Generalized for PnP input devices
\***************************************************************************/
PDEVICEINFO StartDeviceRead(
    PDEVICEINFO pDeviceInfo)
{
    PDEVICE_TEMPLATE pDevTpl;
#ifdef GENERIC_INPUT
    PVOID pBuffer;
    ULONG ulLengthToRead;
#endif

#if !defined(GENERIC_INPUT)
    pDeviceInfo->bFlags |= GDIF_READING;
#endif

    /*
     * If this device need to be freed, abandon
     * reading now and request the free.
     */
    if (pDeviceInfo->usActions & GDIAF_FREEME) {
#ifdef GENERIC_INPUT
        BEGIN_REENTERCRIT() {
#if DBG
            if (fAlreadyHadCrit) {
                CheckDeviceInfoListCritIn();
            }
#endif
#endif
            BEGIN_REENTER_DEVICEINFOLISTCRIT() {
                pDeviceInfo->bFlags &= ~GDIF_READING;
                pDeviceInfo = FreeDeviceInfo(pDeviceInfo);
            } END_REENTER_DEVICEINFOLISTCRIT();
#ifdef GENERIC_INPUT
        } END_REENTERCRIT();
#endif
        return pDeviceInfo;
    }

    if (gbExitInProgress || gbStopReadInput) {
        // Let's not post any more reads when we're trying to exit, eh?
        pDeviceInfo->bFlags &= ~GDIF_READING;
        pDeviceInfo->iosb.Status = STATUS_UNSUCCESSFUL;
        return NULL;
    }

    /*
     * Initialize in case read fails
     */
    pDeviceInfo->iosb.Status = STATUS_UNSUCCESSFUL; // catch concurrent writes?
    pDeviceInfo->iosb.Information = 0;

    pDevTpl = &aDeviceTemplate[pDeviceInfo->type];

    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

#ifdef GENERIC_INPUT
    if (pDeviceInfo->type == DEVICE_TYPE_HID) {
        UserAssert(pDeviceInfo->hid.pTLCInfo);
        if (pDeviceInfo->handle == NULL) {
            /*
             * Currently this device is not requested by anyone.
             */
            TAGMSG1(DBGTAG_PNP, "StartDeviceRead: pDevInfo=%p has been closed on demand.", pDeviceInfo);
            BEGIN_REENTER_DEVICEINFOLISTCRIT()
            if (pDeviceInfo->handle == NULL) {
                if (pDeviceInfo->bFlags & GDIF_READING) {
                    pDeviceInfo->bFlags &= ~GDIF_READING;
                    TAGMSG1(DBGTAG_PNP, "StartDeviceRead: pDevInfo=%p, bFlags has been reset.", pDeviceInfo);
                }
            }
            END_REENTER_DEVICEINFOLISTCRIT();
            return NULL;
        }

        pBuffer = pDeviceInfo->hid.pHidDesc->pInputBuffer;
        ulLengthToRead = pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength * MAXIMUM_ITEMS_READ;
    } else {
        pBuffer = (PBYTE)pDeviceInfo + pDevTpl->offData;
        ulLengthToRead = pDevTpl->cbData;
    }
#endif

    if (pDeviceInfo->handle == NULL) {
        BEGIN_REENTER_DEVICEINFOLISTCRIT() {
            /*
             * Make sure the handle is truely NULL.
             * If this is the case, perhaps this is called from APC
             * that happened at bad timing, like in the middle of
             * device removal query, when ProcessDeviceChanges completed
             * but RequestDeviceChange is not awaken for the complete event.
             * The code can olnly simply bail out once in the situation.
             */
            if (pDeviceInfo->handle == NULL) {
                pDeviceInfo->bFlags &= ~GDIF_READING;
                pDeviceInfo->ReadStatus = STATUS_INVALID_HANDLE;
            }
        } END_REENTER_DEVICEINFOLISTCRIT();
        return NULL;
    }

#ifdef GENERIC_INPUT
    pDeviceInfo->bFlags |= GDIF_READING;
#endif

    LOGTIME(pDeviceInfo->timeStartRead);

#ifdef DIAGNOSE_IO
    pDeviceInfo->nReadsOutstanding++;
#endif

    UserAssert(pDeviceInfo->handle);

    /*
     * Avoid to start reading NULL device handle.
     * This happen when the DeviceNotify receives QUERY_REMOVE
     * and the RIT finishes processing it, but RequestDeviceChange
     * has not finished its wait.
     */
#ifdef GENERIC_INPUT
    pDeviceInfo->ReadStatus = ZwReadFile(
            pDeviceInfo->handle,
            NULL,                // hReadEvent
            InputApc,            // InputApc()
            pDeviceInfo,         // ApcContext
            &pDeviceInfo->iosb,
            pBuffer,
            ulLengthToRead,
            PZERO(LARGE_INTEGER), NULL);
#else

        pDeviceInfo->ReadStatus = ZwReadFile(
                pDeviceInfo->handle,
                NULL,                // hReadEvent
                InputApc,            // InputApc()
                pDeviceInfo,         // ApcContext
                &pDeviceInfo->iosb,
                (PVOID)((PBYTE)pDeviceInfo + pDevTpl->offData),
                pDevTpl->cbData,
                PZERO(LARGE_INTEGER), NULL);
#endif

    LOGTIME(pDeviceInfo->timeEndRead);

#if DBG
    if (pDeviceInfo->bFlags & GDIF_DBGREAD) {
        TAGMSG2(DBGTAG_PNP, "ZwReadFile of Device handle %lx returned status %lx",
                pDeviceInfo->handle, pDeviceInfo->ReadStatus);
    }
#endif

    if (!NT_SUCCESS(pDeviceInfo->ReadStatus)) {
        BEGIN_REENTER_DEVICEINFOLISTCRIT() {
            /*
             * If insufficient resources, retry the read the next time the RIT
             * wakes up for the ID_TIMER event by incrementing gnRetryReadInput
             * (Cheaper than setting our own timer),
             * Else just abandon reading.
             */
            if (pDeviceInfo->ReadStatus == STATUS_INSUFFICIENT_RESOURCES) {
                if (pDeviceInfo->nRetryRead++ < MAXIMUM_READ_RETRIES) {
                    pDeviceInfo->usActions |= GDIAF_RETRYREAD;
                    gnRetryReadInput++;
                }
            } else {
                pDeviceInfo->bFlags &= ~GDIF_READING;
            }

#ifdef DIAGNOSE_IO
            pDeviceInfo->nReadsOutstanding--;
#endif
        } END_REENTER_DEVICEINFOLISTCRIT();
    } else {
        pDeviceInfo->nRetryRead = 0;
    }

    if (!gbRemoteSession && !NT_SUCCESS(pDeviceInfo->ReadStatus))
        RIPMSG2(RIP_WARNING, "StartDeviceRead %#p failed Status %#x",
                pDeviceInfo, pDeviceInfo->ReadStatus);

    return NULL;
}

#ifdef GENERIC_INPUT
/***************************************************************************\
* StopDeviceRead
*
* History:
* XX-XX-00 Hiroyama     created
\***************************************************************************/
PDEVICEINFO StopDeviceRead(
    PDEVICEINFO pDeviceInfo)
{
    IO_STATUS_BLOCK IoStatusBlock;

    TAGMSG1(DBGTAG_PNP, "StopDeviceRead(%p)", pDeviceInfo);

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);
    UserAssert(pDeviceInfo->handle);
    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

    /*
     * Stop reading this HID device.
     */
    pDeviceInfo->bFlags &= ~GDIF_READING;

    ZwCancelIoFile(pDeviceInfo->handle, &IoStatusBlock);
    UserAssertMsg2(NT_SUCCESS(IoStatusBlock.Status), "NtCancelIoFile handle %x failed status %#x",
             pDeviceInfo->handle, IoStatusBlock.Status);

    CloseDevice(pDeviceInfo);

    return NULL;
}
#endif

/***************************************************************************\
* IsKnownKeyboardType
*
* Checks if the given type/subtype is the known IDs
* History:
* XX-XX-00 Hiroyama     created
\***************************************************************************/
__inline BOOL IsKnownKeyboardType(
    DWORD dwType,
    DWORD dwSubType)
{
    switch (dwType) {
    case 4: // Generic
        if ((BYTE)dwSubType == 0xff) {
            /*
             * Bogus subtype, most likely invalid Hydra device.
             */
            return FALSE;
        }
        return TRUE;
    case 7: // Japanese
    case 8: // Korean
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

/***************************************************************************\
* IsPS2Keyboard
*
* return TRUE for the PS/2 device name
* XX-XX-00 Hiroyama     created
\***************************************************************************/
__inline BOOL IsPS2Keyboard(
    LPWSTR pwszDevice)
{
    static const WCHAR wszPS2Header[] = L"\\??\\Root#*";
    static const WCHAR wszPS2HeaderACPI[] = L"\\??\\ACPI#*";

    return wcsncmp(pwszDevice, wszPS2Header, ARRAY_SIZE(wszPS2Header) - 1) == 0 ||
        wcsncmp(pwszDevice, wszPS2HeaderACPI, ARRAY_SIZE(wszPS2HeaderACPI) - 1) == 0;
}

__inline BOOL IsRDPKeyboard(
    LPWSTR pwszDevice)
{
    static const WCHAR wszRDPHeader[] = L"\\??\\Root#RDP";

    return wcsncmp(pwszDevice, wszRDPHeader, ARRAY_SIZE(wszRDPHeader) - 1) == 0;
}

VOID ProcessDeviceChanges(
    DWORD DeviceType)
{
    PDEVICEINFO pDeviceInfo;
    USHORT usOriginalActions;
#if DBG
    volatile int nChanges = 0;
    ULONG timeStartReadPrev;
#endif

    /*
     * Reset summary information for all Mice and Keyboards
     */
    DWORD nMice = 0;
    DWORD nWheels = 0;
    DWORD nMaxButtons = 0;
    int   nKeyboards = 0;
    BOOLEAN fKeyboardIdSet = FALSE;
#ifdef GENERIC_INPUT
    int   nHid = 0;
#endif

    CheckCritIn();
    BEGINATOMICCHECK();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));

    EnterDeviceInfoListCrit();
    BEGINATOMICDEVICEINFOLISTCHECK();

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_PROCESSDEVICECHANGES, NULL, DeviceType);
    }
#endif

    if (DeviceType == DEVICE_TYPE_KEYBOARD) {
        /*
         * Set the fallback value.
         */
        gKeyboardInfo = gKeyboardDefaultInfo;
    }

    /*
     * Look for devices to Create (those which have newly arrived)
     * and for devices to Terminate (these which have just departed)
     * and for device change notifications.
     * Make sure the actions are processed in the right order in case we
     * are being asked for more than one action per device: for example,
     * we sometimes get QueryRemove followed quickly by RemoveCancelled
     * and both actions arrive here together: we should do them in the
     * correct order.
     */
    pDeviceInfo = gpDeviceInfoList;
    while (pDeviceInfo) {
        if (pDeviceInfo->type != DeviceType) {
            pDeviceInfo = pDeviceInfo->pNext;
            continue;
        }

        usOriginalActions = pDeviceInfo->usActions;
        UserAssert((usOriginalActions == 0) || (usOriginalActions & ~GDIAF_PNPWAITING));

        /*
         * Refresh Mouse:
         * We read a MOUSE_ATTRIBUTES_CHANGED flag when a PS/2 mouse
         * is plugged back in. Find out the attributes of the device.
         */
        if (pDeviceInfo->usActions & GDIAF_REFRESH_MOUSE) {
            pDeviceInfo->usActions &= ~GDIAF_REFRESH_MOUSE;

            UserAssert(pDeviceInfo->type == DEVICE_TYPE_MOUSE);
#if DBG
            nChanges++;
#endif
            TAGMSG1(DBGTAG_PNP, "QueryDeviceInfo: %lx", pDeviceInfo);
            QueryDeviceInfo(pDeviceInfo);
        }

        /*
         * QueryRemove:
         * Close the file object, but retain the DEVICEINFO struct and the
         * registration in case we later get a RemoveCancelled.
         */
        if (pDeviceInfo->usActions & GDIAF_QUERYREMOVE) {
            pDeviceInfo->usActions &= ~GDIAF_QUERYREMOVE;
#if DBG
            nChanges++;
#endif
            TAGMSG1(DBGTAG_PNP, "QueryRemove: %lx", pDeviceInfo);
            CloseDevice(pDeviceInfo);
        }

        /*
         * New device arrived or RemoveCancelled:
         * If new device, Open it, register for notifications and start reading
         * If RemoveCancelled, unregister the old notfications first
         */
        if (pDeviceInfo->usActions & (GDIAF_ARRIVED | GDIAF_REMOVECANCELLED)) {
            // Reopen the file object, (this is a new file object, of course),
            // Unregister for the old file, register with this new one.
            if (pDeviceInfo->usActions & GDIAF_REMOVECANCELLED) {
                pDeviceInfo->usActions &= ~GDIAF_REMOVECANCELLED;
#if DBG
                nChanges++;
#endif
                TAGMSG1(DBGTAG_PNP, "RemoveCancelled: %lx", pDeviceInfo);
                UnregisterForDeviceChangeNotifications(pDeviceInfo);
            }

#if DBG
            if (pDeviceInfo->usActions & GDIAF_ARRIVED) {
                nChanges++;
            }
#endif


            pDeviceInfo->usActions &= ~GDIAF_ARRIVED;
            if (OpenDevice(pDeviceInfo)) {
                PDEVICEINFO pDeviceInfoNext;

                if (!IsRemoteConnection()) {
                    RegisterForDeviceChangeNotifications(pDeviceInfo);
                }

#ifdef GENERIC_INPUT
                if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                    /*
                     * If this device is not requested, close the device now.
                     */
                    UserAssert(pDeviceInfo->handle);
                    UserAssert(pDeviceInfo->hid.pTLCInfo);

                    if (pDeviceInfo->handle && !HidTLCActive(pDeviceInfo->hid.pTLCInfo)) {
                        StopDeviceRead(pDeviceInfo);    // also closes the handle
                    }
                }
                if (!((IsRemoteConnection()) && (pDeviceInfo->usActions & GDIAF_RECONNECT)) && pDeviceInfo->handle) {
                    pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
                    if (pDeviceInfoNext) {
                        /*
                         * pDeviceInfo was freed, move onto the next
                         */
                        pDeviceInfo = pDeviceInfoNext;
                        continue;
                    }
                }

#else

                if (!((IsRemoteConnection()) && (pDeviceInfo->usActions & GDIAF_RECONNECT))) {

                    pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
                    if (pDeviceInfoNext) {
                        /*
                          * pDeviceInfo wasa freed, move onto the next
                         */
                        pDeviceInfo = pDeviceInfoNext;
                        continue;
                    }
                }
#endif
                pDeviceInfo->usActions &= ~GDIAF_RECONNECT;

            } else {
                /*
                 * If the Open failed, we free the device here, and move on to
                 * the next device.
                 * Assert to catch re-open failure upon RemoveCancelled.
                 */
#if DBG
                if ((usOriginalActions & GDIAF_ARRIVED) == 0) {
                    RIPMSG2(RIP_WARNING, "Re-Open %#p failed status %x during RemoveCancelled",
                            pDeviceInfo, pDeviceInfo->OpenStatus);
                }
#endif

#ifdef GENERIC_INPUT
                if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                    /*
                     * Some other applications may open this device
                     * exclusively. We may succeed to open it later on, so
                     * keep this deviceinfo around until it's physically
                     * detached.
                     */
                    RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: failed to open the device %p",
                            pDeviceInfo);
                } else {
#endif
                    pDeviceInfo = FreeDeviceInfo(pDeviceInfo);
                    continue;
#ifdef GENERIC_INPUT
                }
#endif
            }
        }

        /*
         * RemoveComplete:
         * Close the file object, if you have not already done so, Unregister.
         * FreeDeviceInfo here (which will actually request a free from the
         * reader or the PnP requestor thread), and move on to the next device.
         */
        if (pDeviceInfo->usActions & GDIAF_DEPARTED) {
            pDeviceInfo->usActions &= ~GDIAF_DEPARTED;
#if DBG
            nChanges++;
#endif
            TAGMSG1(DBGTAG_PNP, "RemoveComplete: %lx (process %#x)", pDeviceInfo);
            CloseDevice(pDeviceInfo);
            UnregisterForDeviceChangeNotifications(pDeviceInfo);
            pDeviceInfo = FreeDeviceInfo(pDeviceInfo);
            continue;
        }

        if (pDeviceInfo->usActions & GDIAF_IME_STATUS) {
            pDeviceInfo->usActions &= ~GDIAF_IME_STATUS;
#if DBG
            nChanges++;
#endif
            if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                if (FUJITSU_KBD_CONSOLE(pDeviceInfo->keyboard.Attr.KeyboardIdentifier) ||
                    (gbRemoteSession &&
                     FUJITSU_KBD_REMOTE(gRemoteClientKeyboardType))
                   ) {
                    /*
                     * Fill up the KEYBOARD_IME_STATUS structure.
                     */
                    ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                            &giosbKbdControl, IOCTL_KEYBOARD_SET_IME_STATUS,
                            (PVOID)&gKbdImeStatus, sizeof(gKbdImeStatus), NULL, 0);
                }
            }
        }

        if (pDeviceInfo->usActions & GDIAF_RETRYREAD) {
            PDEVICEINFO pDeviceInfoNext;
            pDeviceInfo->usActions &= ~GDIAF_RETRYREAD;
            UserAssert(pDeviceInfo->ReadStatus == STATUS_INSUFFICIENT_RESOURCES);
#if DBG
            timeStartReadPrev = pDeviceInfo->timeStartRead;
#endif
            TAGMSG2(DBGTAG_PNP, "Retry Read %#p after %lx ticks",
                    pDeviceInfo, pDeviceInfo->timeStartRead - timeStartReadPrev);
            pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
            if (pDeviceInfoNext) {
                /*
                 * pDeviceInfo wasa freed, move onto the next
                 */
                pDeviceInfo = pDeviceInfoNext;
                continue;
            }
        }

#ifdef GENERIC_INPUT
        if (pDeviceInfo->usActions & GDIAF_STARTREAD) {

            pDeviceInfo->usActions &= ~GDIAF_STARTREAD;
#if DBG
            timeStartReadPrev = pDeviceInfo->timeStartRead;
#endif
            TAGMSG1(DBGTAG_PNP, "Start Read %#p", pDeviceInfo);
            UserAssert(pDeviceInfo->handle == NULL);
            UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);
            UserAssert(HidTLCActive(pDeviceInfo->hid.pTLCInfo)); // a bit over active assert?

            if (!OpenDevice(pDeviceInfo)) {
                /*
                 * Failed to open, perhaps some other applications
                 * has opened this device exclusively.
                 * We can't do nothing more than ignoring the failure.
                 * Let's get going.
                 */
                RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: STARTREAD failed to reopen the device %p",
                       pDeviceInfo);
            } else {
                PDEVICEINFO pDeviceInfoNext;

                pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
                if (pDeviceInfoNext) {
                    /*
                     * pDeviceInfo was freed, move onto the next
                     */
                    pDeviceInfo = pDeviceInfoNext;
                    continue;
                }
            }
        }

        if (pDeviceInfo->usActions & GDIAF_STOPREAD) {

            pDeviceInfo->usActions &= ~GDIAF_STOPREAD;
            UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);
            if (pDeviceInfo->handle) {
                PDEVICEINFO pDeviceInfoNext;

                /*
                 * StopDeviceRead cancels pending I/O,
                 * and closes the device handle,
                 * but basically the deviceinfo itself keeps
                 * alive.
                 */
                pDeviceInfoNext = StopDeviceRead(pDeviceInfo);
                if (pDeviceInfoNext) {
                    /*
                     * pDeviceInfo was freed, move onto the next
                     */
                    pDeviceInfo = pDeviceInfoNext;
                }
            } else {
                RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: STOPREAD, but handle is already NULL for %p",
                        pDeviceInfo);
            }
        }
#endif

        /*
         * Gather summary information on open devices
         */
        if (pDeviceInfo->handle) {
            switch (pDeviceInfo->type) {
            case DEVICE_TYPE_MOUSE:
                UserAssert(PtiCurrentShared() == gTermIO.ptiDesktop);
                if (pDeviceInfo->usActions & GDIAF_REFRESH_MOUSE) {
                    pDeviceInfo->usActions &= ~GDIAF_REFRESH_MOUSE;
#if DBG
                    nChanges++;
#endif
                }
                nMice++;
                nMaxButtons = max(nMaxButtons, pDeviceInfo->mouse.Attr.NumberOfButtons);
                switch(pDeviceInfo->mouse.Attr.MouseIdentifier) {
                case WHEELMOUSE_I8042_HARDWARE:
                case WHEELMOUSE_SERIAL_HARDWARE:
                case WHEELMOUSE_HID_HARDWARE:
                    nWheels++;
                }
                break;

            case DEVICE_TYPE_KEYBOARD:
                UserAssert(PtiCurrentShared() == gptiRit);
                // LEDStatus held in win32k.sys and later force the new keyboard
                // to be set accordingly.
                if (pDeviceInfo->ustrName.Buffer == NULL) {
                    /*
                     * This most likely is a bogus Hydra device.
                     */
                    RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: KBD pDevInfo=%p has no name!", pDeviceInfo);
                    if (!fKeyboardIdSet) {
                        /*
                         * If keyboard id/attr is not set, try to get it from this device
                         * anyway.  If there are legit PS/2 devices after this, we'll get
                         * a chance to re-aquire more meaningful id/attr.
                         */
                        goto get_attr_anyway;
                    }
                } else {
                    NTSTATUS Status;

                    if ((!fKeyboardIdSet || IsPS2Keyboard(pDeviceInfo->ustrName.Buffer)) &&
                            !IsRDPKeyboard(pDeviceInfo->ustrName.Buffer)) {
get_attr_anyway:

#if 0
                        /*
                         * LATER: when other GI stuff in ntinput.c goes in,
                         * move this boot-time LED and type/subtype initialization to
                         * ntinput.c where the RIT is initialized.
                         */
#ifdef DIAGNOSE_IO
                        gKbdIoctlLEDSStatus =
#endif
                        Status = ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                                &giosbKbdControl, IOCTL_KEYBOARD_QUERY_INDICATORS,
                                NULL, 0,
                                (PVOID)&gklpBootTime, sizeof(gklpBootTime));
                        UserAssertMsg2(NT_SUCCESS(Status),
                                "IOCTL_KEYBOARD_QUERY_INDICATORS failed: DeviceInfo %#x, Status %#x",
                                 pDeviceInfo, Status);

                        TAGMSG1(DBGTAG_PNP, "ProcessDeviceChanges: led flag is %x", gklpBootTime.LedFlags);
#else
                        UNREFERENCED_PARAMETER(Status);
#endif  // 0

                        if (IsKnownKeyboardType(pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type,
                                                pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype)) {
                            USHORT NumberOfFunctionKeysSave = gKeyboardInfo.NumberOfFunctionKeys;

                            gKeyboardInfo = pDeviceInfo->keyboard.Attr;
                            /*
                             * Store the maximum number of function keys into gKeyboardInfo.
                             */
                            if (NumberOfFunctionKeysSave > gKeyboardInfo.NumberOfFunctionKeys) {
                                gKeyboardInfo.NumberOfFunctionKeys = NumberOfFunctionKeysSave;
                            }
                        } else {
                            RIPMSG3(RIP_WARNING, "ProcessDeviceChanges: kbd pDevInfo %p has bogus type/subtype=%x/%x",
                                    pDeviceInfo,
                                    pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type,
                                    pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype);
                        }

                        if (pDeviceInfo->ustrName.Buffer) {
                            /*
                             * If this is a legit device, remember it so that we won't
                             * try to get other non PS/2 keyboard id/attr.
                             */
                            fKeyboardIdSet = TRUE;
                        }
                    }
                }
                nKeyboards++;
                break;

#ifdef GENERIC_INPUT
            case DEVICE_TYPE_HID:
                ++nHid;
                break;
#endif

            default:
                // Add code for a new type of input device here
                RIPMSG2(RIP_ERROR, "pDeviceInfo %#p has strange type %d",
                        pDeviceInfo, pDeviceInfo->type);
                break;
            }
        }
#ifdef GENERIC_INPUT
        else if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            ++nHid;
            TAGMSG1(DBGTAG_PNP, "ProcessDeviceChanges: HID DeviceInfo %p", pDeviceInfo);
        }
#endif

        /*
         * Notify the PnP thread that a change has been completed
         */
        if (usOriginalActions & GDIAF_PNPWAITING) {
            KeSetEvent(pDeviceInfo->pkeHidChangeCompleted, EVENT_INCREMENT, FALSE);
        }

        pDeviceInfo = pDeviceInfo->pNext;
    }

    ENDATOMICDEVICEINFOLISTCHECK();
    LeaveDeviceInfoListCrit();


    switch (DeviceType) {
    case DEVICE_TYPE_MOUSE:
        /*
         * Apply summary information for Mice
         */
        if (nMice) {
            if (gnMice == 0) {
                /*
                 * We had no mouse before but we have one now: add a cursor
                 */
                SET_GTERMF(GTERMF_MOUSE);
                SYSMET(MOUSEPRESENT) = TRUE;
                SetGlobalCursorLevel(0);
                UserAssert(PpiFromProcess(gpepCSRSS)->ptiList->iCursorLevel == 0);
                UserAssert(PpiFromProcess(gpepCSRSS)->ptiList->pq->iCursorLevel == 0);
                GreMovePointer(gpDispInfo->hDev, gpsi->ptCursor.x, gpsi->ptCursor.y,
                               MP_PROCEDURAL);
            }
        } else {
            if (gnMice != 0) {
                /*
                 * We had a mouse before but we don't now: remove the cursor
                 */
                CLEAR_GTERMF(GTERMF_MOUSE);
                SYSMET(MOUSEPRESENT) = FALSE;
                SetGlobalCursorLevel(-1);
                /*
                 * Don't leave mouse buttons stuck down, clear the global button
                 * state here, otherwise weird stuff might happen.
                 * Also do this in Alt-Tab processing and zzzCancelJournalling.
                 */
#if DBG
                if (gwMouseOwnerButton)
                    RIPMSG1(RIP_WARNING,
                            "gwMouseOwnerButton=%x, being cleared forcibly\n",
                            gwMouseOwnerButton);
#endif
                gwMouseOwnerButton = 0;
            }
        }
        /*
         * Mouse button count represents the number of buttons on the mouse with
         * the most buttons.
         */
        SYSMET(CMOUSEBUTTONS) = nMaxButtons;
        SYSMET(MOUSEWHEELPRESENT) = (nWheels > 0);
        gnMice = nMice;
        break;

    case DEVICE_TYPE_KEYBOARD:
        /*
         * Apply summary information for Keyboards
         */

        if (nKeyboards > gnKeyboards) {
            /*
             * We have more keyboards, let set their LEDs properly
             */
            UpdateKeyLights(FALSE);
            /*
             * The new keyboard arrived. Tell the RIT to set
             * the repeat rate.
             */
            RequestKeyboardRateUpdate();
        }
        if ((nKeyboards != 0) && (gnKeyboards == 0)) {
            /*
             * We had no keyboard but we have one now: set the system hotkeys.
             */
            SetDebugHotKeys();
        }
        gnKeyboards = nKeyboards;
        break;

#ifdef GENERIC_INPUT
    case DEVICE_TYPE_HID:
        gnHid = nHid;
        break;
#endif

    default:
        break;
    }

    ENDATOMICCHECK();
}

/***************************************************************************\
* RequestDeviceChange()
*
* Flag the Device for the specified actions, then set its pkeHidChange to
* trigger the RIT to perform the actions.
* The current thread may not be able to do this if it is a PnP notification
* from another process.
*
* History:
* 01-20-99 IanJa        Created.
\***************************************************************************/
VOID RequestDeviceChange(
    PDEVICEINFO pDeviceInfo,
    USHORT usAction,
    BOOL fInDeviceInfoListCrit)
{
    PDEVICE_TEMPLATE pDevTpl = &aDeviceTemplate[pDeviceInfo->type];
    UserAssert(pDevTpl->pkeHidChange != NULL);
    UserAssert((usAction & GDIAF_FREEME) == 0);
    UserAssert((pDeviceInfo->usActions & GDIAF_PNPWAITING) == 0);

#if DBG
    if (pDeviceInfo->usActions != 0) {
        TAGMSG3(DBGTAG_PNP, "RequestDeviceChange(%#p, %x), but action %x pending",
                pDeviceInfo, usAction, pDeviceInfo->usActions);
    }

    /*
     * We can't ask for synchronized actions to be performed on the Device List
     * if we are holding the Device List lock or the User Critical Section:
     * ProcessDeviceChanges() requires both of these itself.
     */
    //if (usAction & GDIAF_PNPWAITING) {
    //    CheckDeviceInfoListCritOut();
    //    CheckCritOut();
    //}
#endif

    TAGMSG2(DBGTAG_PNP, "RequestDeviceChange(%p, %x)", pDeviceInfo, usAction);

    /*
     * Grab the DeviceInfoList critical section if we don't already have it
     */
    UserAssert(!fInDeviceInfoListCrit == !ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList));

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        if (!fInDeviceInfoListCrit) {
            EnterDeviceInfoListCrit();
        }
        RecordPnpNotification(PNP_NTF_REQUESTDEVICECHANGE, pDeviceInfo, usAction);
        if (!fInDeviceInfoListCrit) {
            LeaveDeviceInfoListCrit();
        }
    }
#endif

#ifdef GENERIC_INPUT
    if (!fInDeviceInfoListCrit) {
        EnterDeviceInfoListCrit();
    }
    CheckDeviceInfoListCritIn();
    pDeviceInfo->usActions |= usAction;
    if ((pDeviceInfo->usActions & (GDIAF_STARTREAD | GDIAF_STOPREAD)) == (GDIAF_STARTREAD | GDIAF_STOPREAD)) {
        pDeviceInfo->usActions &= ~(GDIAF_STARTREAD | GDIAF_STOPREAD);
    }
    if (!fInDeviceInfoListCrit) {
        LeaveDeviceInfoListCrit();
    }

#else

    if (fInDeviceInfoListCrit) {
        CheckDeviceInfoListCritIn();
        pDeviceInfo->usActions |= usAction;
    } else {
        EnterDeviceInfoListCrit();
        pDeviceInfo->usActions |= usAction;
        LeaveDeviceInfoListCrit();
    }

#endif

    if (usAction & GDIAF_PNPWAITING) {

        CheckDeviceInfoListCritIn();
        KeSetEvent(pDevTpl->pkeHidChange, EVENT_INCREMENT, FALSE);
        LeaveDeviceInfoListCrit();
        KeWaitForSingleObject(pDeviceInfo->pkeHidChangeCompleted, WrUserRequest, KernelMode, FALSE, NULL);


#ifdef GENERIC_INPUT
        BESURE_IN_USERCRIT(pDeviceInfo->usActions & GDIAF_FREEME);
#endif
        EnterDeviceInfoListCrit();
        /*
         * Assert that nothing else cleared GDIAF_PNPWAITING - only do it here.
         * Check that the action we were waiting for actually occurred.
         */
        UserAssert(pDeviceInfo->usActions & GDIAF_PNPWAITING);
        pDeviceInfo->usActions &= ~GDIAF_PNPWAITING;
        UserAssert((pDeviceInfo->usActions & usAction) == 0);
        if (pDeviceInfo->usActions & GDIAF_FREEME) {
            FreeDeviceInfo(pDeviceInfo);
        }
#ifdef GENERIC_INPUT
        LeaveDeviceInfoListCrit();
        END_IN_USERCRIT();
        EnterDeviceInfoListCrit();
#endif
    } else {
        KeSetEvent(pDevTpl->pkeHidChange, EVENT_INCREMENT, FALSE);
    }
}



/***************************************************************************\
* RemoveInputDevices()
*
* Used to detach input devices from a session. When disconnecting from a
* session that owns the local input devices we need to release them so that
* the new session that will take ownership of local console can use them
*
\***************************************************************************/
VOID RemoveInputDevices(
    VOID)
{
    PDEVICEINFO pDeviceInfo;
    ULONG DeviceType;
    NTSTATUS Status;


    /*
     * First Thing is to remove device class notification.
     */
    for (DeviceType = 0; DeviceType <= DEVICE_TYPE_MAX; DeviceType++) {
        if (aDeviceClassNotificationEntry[DeviceType] != NULL) {
            IoUnregisterPlugPlayNotification(aDeviceClassNotificationEntry[DeviceType]);
            aDeviceClassNotificationEntry[DeviceType] = NULL;
        }
    }

    /*
     * Then walk the device liste detaching mice and keyboads.
     */

    EnterDeviceInfoListCrit();
    PNP_SAFE_DEVICECRIT_IN();
    pDeviceInfo = gpDeviceInfoList;
    while (pDeviceInfo) {
#ifdef GENERIC_INPUT
        if (pDeviceInfo->usActions & (GDIAF_DEPARTED | GDIAF_FREEME)) {
            pDeviceInfo = pDeviceInfo->pNext;
            continue;
        }
#else
        if ((pDeviceInfo->type != DEVICE_TYPE_KEYBOARD && pDeviceInfo->type != DEVICE_TYPE_MOUSE) ||
            (pDeviceInfo->usActions & GDIAF_DEPARTED) ||
            (pDeviceInfo->usActions & GDIAF_FREEME) ) {
            pDeviceInfo = pDeviceInfo->pNext;
            continue;
        }
#endif
#ifdef PRERELEASE
        pDeviceInfo->fForcedDetach = TRUE;
#endif
        RequestDeviceChange(pDeviceInfo, GDIAF_DEPARTED, TRUE);
        pDeviceInfo = gpDeviceInfoList;
    }
    LeaveDeviceInfoListCrit();
}


/***************************************************************************\
* AttachInputDevices
*
* Used to Attach  input devices to  a session.
*
\***************************************************************************/
BOOL AttachInputDevices(
    BOOL bLocalDevices)
{
    UNICODE_STRING    ustrName;
    BOOL              fSuccess = TRUE;

    if (!bLocalDevices) {
        RtlInitUnicodeString(&ustrName, NULL);
        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_MOUSE, &ustrName, 0);
        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_KEYBOARD, &ustrName, 0);


        if (!fSuccess) {
            RIPMSG0(RIP_WARNING, "AttachInputDevices Failed  the creation of input devices");
        }
    } else {
        /*
         * For local devices just register Device class notification and let
         * PnP call us back.
         */
        xxxRegisterForDeviceClassNotifications();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\pool.c ===
/**************************** Module Header ********************************\
* Module Name: pool.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Pool reallocation routines
*
* History:
* 03-04-95 JimA       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

DWORD gdwPoolFlags;
DWORD gSessionPoolMask;

#ifdef POOL_INSTR

    /*
     * Globals used by RecordStackTrace
     */

    PVOID     gRecordedStackTrace[RECORD_STACK_TRACE_SIZE];
    PEPROCESS gpepRecorded;
    PETHREAD  gpetRecorded;


    DWORD gdwAllocFailIndex;        // the index of the allocation that's
                                    // going to fail

    DWORD gdwAllocsToFail = 1;      // how many allocs to fail

    DWORD gdwFreeRecords;

    /*
     * Targeted tag failures
     */
    LPDWORD gparrTagsToFail;
    SIZE_T  gdwTagsToFailCount;

    /*
     * Support to keep records of failed pool allocations
     */
    DWORD gdwFailRecords;
    DWORD gdwFailRecordCrtIndex;
    DWORD gdwFailRecordTotalFailures;

    PPOOLRECORD gparrFailRecord;

    /*
     * Support to keep records of pool free
     */
    DWORD gdwFreeRecords;
    DWORD gdwFreeRecordCrtIndex;
    DWORD gdwFreeRecordTotalFrees;

    PPOOLRECORD gparrFreeRecord;

    FAST_MUTEX* gpAllocFastMutex;   // mutex to syncronize pool allocations

    Win32AllocStats gAllocList;

    CONST char gszTailAlloc[] = "Win32kAlloc";

#define USESESSION(dwFlags) (((dwFlags & DAP_NONSESSION) != 0) ? 0 : gSessionPoolMask)

#endif

/***************************************************************************\
* Win32QueryPoolSize
*
* Returns the size of the given pool block.
*
* 08-17-2001    JasonSch        Created.
\***************************************************************************/
SIZE_T Win32QueryPoolSize(
    PVOID p)
{
    /*
     * If POOL_HEAVY_ALLOCS is not defined then the pointer is what
     * we allocated.
     */
    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        BOOLEAN notUsed;
        return ExQueryPoolBlockSize(p, &notUsed);
    } else {
        PWin32PoolHead ph;

        ph = (PWin32PoolHead)((DWORD*)p - (sizeof(Win32PoolHead) / sizeof(DWORD)));
        return ph->size;
    }
}

PVOID Win32AllocPoolWithTagZInit(SIZE_T uBytes, ULONG uTag)
{
    PVOID   pv;

    pv = Win32AllocPool(uBytes, uTag);
    if (pv) {
        RtlZeroMemory(pv, uBytes);
    }

    return pv;
}

PVOID Win32AllocPoolWithTagZInitWithPriority(SIZE_T uBytes, ULONG uTag, EX_POOL_PRIORITY priority)
{
    PVOID   pv;

    pv = Win32AllocPoolWithPriority(uBytes, uTag, priority);
    if (pv) {
        RtlZeroMemory(pv, uBytes);
    }

    return pv;
}

PVOID Win32AllocPoolWithQuotaTagZInit(SIZE_T uBytes, ULONG uTag)
{
    PVOID   pv;

    pv = Win32AllocPoolWithQuota(uBytes, uTag);
    if (pv) {
        RtlZeroMemory(pv, uBytes);
    }

    return pv;
}

PVOID UserReAllocPoolWithTag(
    PVOID pSrc,
    SIZE_T uBytesSrc,
    SIZE_T uBytes,
    ULONG iTag)
{
    PVOID pDest;

    pDest = UserAllocPool(uBytes, iTag);
    if (pDest != NULL) {

        /*
         * If the block is shrinking, don't copy too many bytes.
         */
        if (uBytesSrc > uBytes) {
            uBytesSrc = uBytes;
        }

        RtlCopyMemory(pDest, pSrc, uBytesSrc);

        UserFreePool(pSrc);
    }

    return pDest;
}

PVOID UserReAllocPoolWithQuotaTag(
    PVOID pSrc,
    SIZE_T uBytesSrc,
    SIZE_T uBytes,
    ULONG iTag)
{
    PVOID pDest;

    pDest = UserAllocPoolWithQuota(uBytes, iTag);
    if (pDest != NULL) {

        /*
         * If the block is shrinking, don't copy too many bytes.
         */
        if (uBytesSrc > uBytes)
            uBytesSrc = uBytes;

        RtlCopyMemory(pDest, pSrc, uBytesSrc);

        UserFreePool(pSrc);
    }

    return pDest;
}

/*
 * Allocation routines for rtl functions
 */

PVOID UserRtlAllocMem(
    SIZE_T uBytes)
{
    return UserAllocPool(uBytes, TAG_RTL);
}

VOID UserRtlFreeMem(
    PVOID pMem)
{
    UserFreePool(pMem);
}

#ifdef POOL_INSTR

VOID RecordStackTrace(
    VOID)
{
    RtlZeroMemory(gRecordedStackTrace, RECORD_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(gRecordedStackTrace, RECORD_STACK_TRACE_SIZE, 0);

    gpepRecorded = PsGetCurrentProcess();
    gpetRecorded = PsGetCurrentThread();
}

/***************************************************************************\
* RecordFailAllocation
*
* Records failed allocations
*
* 3-22-99 CLupu      Created.
\***************************************************************************/
VOID RecordFailAllocation(
    ULONG  tag,
    SIZE_T size)
{
    UserAssert(gdwPoolFlags & POOL_KEEP_FAIL_RECORD);

    gparrFailRecord[gdwFailRecordCrtIndex].ExtraData = LongToPtr( tag );
    gparrFailRecord[gdwFailRecordCrtIndex].size = size;

    gdwFailRecordTotalFailures++;

    RtlZeroMemory(gparrFailRecord[gdwFailRecordCrtIndex].trace,
                  RECORD_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(gparrFailRecord[gdwFailRecordCrtIndex].trace,
                      RECORD_STACK_TRACE_SIZE,
                      0);

    gdwFailRecordCrtIndex++;

    if (gdwFailRecordCrtIndex >= gdwFailRecords) {
        gdwFailRecordCrtIndex = 0;
    }
}

/***************************************************************************\
* RecordFreePool
*
* Records free pool
*
* 3-22-99 CLupu      Created.
\***************************************************************************/
VOID RecordFreePool(
    PVOID  p,
    SIZE_T size)
{
    UserAssert(gdwPoolFlags & POOL_KEEP_FREE_RECORD);

    gparrFreeRecord[gdwFreeRecordCrtIndex].ExtraData = p;
    gparrFreeRecord[gdwFreeRecordCrtIndex].size = size;

    gdwFreeRecordTotalFrees++;

    RtlZeroMemory(gparrFreeRecord[gdwFreeRecordCrtIndex].trace,
                  RECORD_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(gparrFreeRecord[gdwFreeRecordCrtIndex].trace,
                      RECORD_STACK_TRACE_SIZE,
                      0);

    gdwFreeRecordCrtIndex++;

    if (gdwFreeRecordCrtIndex >= gdwFreeRecords) {
        gdwFreeRecordCrtIndex = 0;
    }
}

/***************************************************************************\
* HeavyAllocPool
*
* This will make UserAllocPool to fail if we do not provide enough memory
* for the specified tag.
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
PVOID HeavyAllocPool(
    SIZE_T           uBytes,
    ULONG            tag,
    DWORD            dwFlags,
    EX_POOL_PRIORITY priority)
{
    PDWORD p;
    PWin32PoolHead ph;
    POOL_TYPE poolType;

    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        if (dwFlags & DAP_USEQUOTA) {
            poolType = ((dwFlags & DAP_NONPAGEDPOOL) ? USESESSION(dwFlags) | NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE
                       : gSessionPoolMask | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE);

            p = ExAllocatePoolWithQuotaTag(poolType, uBytes, tag);
        } else {
            poolType = ((dwFlags & DAP_NONPAGEDPOOL) ? USESESSION(dwFlags) | NonPagedPool
                       : gSessionPoolMask | PagedPool);

            if (dwFlags & DAP_PRIORITY) {
                p = ExAllocatePoolWithTagPriority(poolType, uBytes, tag, priority);
            } else {
                p = ExAllocatePoolWithTag(poolType, uBytes, tag);
            }

        }

        if (p != NULL && (dwFlags & DAP_ZEROINIT)) {
            RtlZeroMemory(p, uBytes);
        }

        return p;
    }

    /*
     * Check for overflow.
     */
    if (uBytes >= MAXULONG - sizeof(Win32PoolHead) - sizeof(gszTailAlloc)) {
        if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
            RecordFailAllocation(tag, 0);
        }

        return NULL;
    }

    /*
     * Acquire the mutex when we play with the list of allocations.
     */
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpAllocFastMutex);

#ifdef POOL_INSTR_API
    /*
     * Fail the allocation if the flag is set. Don't fail allocations that
     * will certainly get us to bugcheck in DBG (i.e. GLOBALTHREADLOCK).
     */
    if (gdwPoolFlags & POOL_FAIL_ALLOCS
#if DBG
        && (tag != TAG_GLOBALTHREADLOCK)
#endif
        ) {


        SIZE_T dwInd;

        for (dwInd = 0; dwInd < gdwTagsToFailCount; dwInd++) {
            if (tag == gparrTagsToFail[dwInd]) {
                break;
            }
        }

        if (dwInd < gdwTagsToFailCount) {
            if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
                RecordFailAllocation(tag, uBytes);
            }

            RIPMSG0(RIP_WARNING,
                    "Pool allocation failed because of global restriction");
            p = NULL;
            goto exit;
        }
    }
#endif

#if DBG
    if ((gdwPoolFlags & POOL_FAIL_BY_INDEX) && (tag != TAG_GLOBALTHREADLOCK)) {
        /*
         * Count the calls to HeavyAllocPool.
         */
        gdwAllocCrt++;

        if (gdwAllocCrt >= gdwAllocFailIndex &&
            gdwAllocCrt < gdwAllocFailIndex + gdwAllocsToFail) {

            RecordStackTrace();

            KdPrint(("\n--------------------------------------------------\n"));
            KdPrint((
                    "\nPool allocation %d failed because of registry settings",
                    gdwAllocCrt));
            KdPrint(("\n--------------------------------------------------\n\n"));

            if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
                RecordFailAllocation(tag, uBytes);
            }
            p = NULL;
            goto exit;
        }
    }
#endif

    /*
     * Reserve space for the header
     */
    uBytes += sizeof(Win32PoolHead);

    if (gdwPoolFlags & POOL_TAIL_CHECK) {
        uBytes += sizeof(gszTailAlloc);
    }

    if (dwFlags & DAP_USEQUOTA) {
        poolType = ((dwFlags & DAP_NONPAGEDPOOL) ? USESESSION(dwFlags) | NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE
                   : gSessionPoolMask | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE);

        p = ExAllocatePoolWithQuotaTag(poolType, uBytes, tag);
    } else {
        poolType = ((dwFlags & DAP_NONPAGEDPOOL) ? USESESSION(dwFlags)| NonPagedPool
                   : gSessionPoolMask | PagedPool);

        if (dwFlags & DAP_PRIORITY) {
            p = ExAllocatePoolWithTagPriority(poolType, uBytes, tag, priority);
        } else {
            p = ExAllocatePoolWithTag(poolType, uBytes, tag);
        }
    }

    /*
     * Return if ExAllocate... failed.
     */
    if (p == NULL) {
        if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
            uBytes -= sizeof(Win32PoolHead);

            if (gdwPoolFlags & POOL_TAIL_CHECK) {
                uBytes -= sizeof(gszTailAlloc);
            }

            RecordFailAllocation(tag, uBytes);
        }

        goto exit;
    }

    if (gdwPoolFlags & POOL_TAIL_CHECK) {
        uBytes -= sizeof(gszTailAlloc);

        RtlCopyMemory(((BYTE*)p) + uBytes, gszTailAlloc, sizeof(gszTailAlloc));
    }

    uBytes -= sizeof(Win32PoolHead);

    /*
     * Get the pointer to the header.
     */
    ph = (PWin32PoolHead)p;

    p += (sizeof(Win32PoolHead) / sizeof(DWORD));

    /*
     * Update the global allocations info.
     */
    gAllocList.dwCrtMem += uBytes;

    if (gAllocList.dwMaxMem < gAllocList.dwCrtMem) {
        gAllocList.dwMaxMem = gAllocList.dwCrtMem;
    }

    (gAllocList.dwCrtAlloc)++;

    if (gAllocList.dwMaxAlloc < gAllocList.dwCrtAlloc) {
        gAllocList.dwMaxAlloc = gAllocList.dwCrtAlloc;
    }

    /*
     * Grab the stack traces if the flags say so
     */
    if (gdwPoolFlags & POOL_CAPTURE_STACK) {
        ph->pTrace = ExAllocatePoolWithTag(gSessionPoolMask | PagedPool,
                                           POOL_ALLOC_TRACE_SIZE * sizeof(PVOID),
                                           TAG_STACK);

        if (ph->pTrace != NULL) {
            RtlZeroMemory(ph->pTrace, POOL_ALLOC_TRACE_SIZE * sizeof(PVOID));
            RtlWalkFrameChain(ph->pTrace, POOL_ALLOC_TRACE_SIZE, 0);
        }
    } else {
        ph->pTrace = NULL;
    }

    /*
     * Save the info in the header and return the pointer after the header.
     */
    ph->size = uBytes;

    /*
     * now, link it into the list for this tag (if any)
     */
    ph->pPrev = NULL;
    ph->pNext = gAllocList.pHead;

    if (gAllocList.pHead != NULL) {
        gAllocList.pHead->pPrev = ph;
    }

    gAllocList.pHead = ph;

    if (dwFlags & DAP_ZEROINIT) {
        RtlZeroMemory(p, uBytes);
    }

exit:
    /*
     * Release the mutex
     */
    ExReleaseFastMutexUnsafe(gpAllocFastMutex);
    KeLeaveCriticalRegion();

    return p;
}

/***************************************************************************\
* HeavyFreePool
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
VOID HeavyFreePool(
    PVOID p)
{
    SIZE_T         uBytes;
    PWin32PoolHead ph;

    /*
     * If POOL_HEAVY_ALLOCS is not defined
     * then the pointer is what we allocated
     */
    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        ExFreePool(p);
        return;
    }

    /*
     * Acquire the mutex when we play with the list of allocations
     */
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpAllocFastMutex);

    ph = (PWin32PoolHead)((DWORD*)p - (sizeof(Win32PoolHead) / sizeof(DWORD)));

    uBytes = ph->size;

    /*
     * Check the tail
     */
    if (gdwPoolFlags & POOL_TAIL_CHECK) {
        if (!RtlEqualMemory((BYTE*)p + uBytes, gszTailAlloc, sizeof(gszTailAlloc))) {
            RIPMSG1(RIP_ERROR, "POOL CORRUPTION for %#p", p);
        }
    }

    gAllocList.dwCrtMem -= uBytes;

    UserAssert(gAllocList.dwCrtAlloc > 0);

    (gAllocList.dwCrtAlloc)--;

    /*
     * now, remove it from the linked list
     */
    if (ph->pPrev == NULL) {
        if (ph->pNext == NULL) {

            UserAssert(gAllocList.dwCrtAlloc == 0);

            gAllocList.pHead = NULL;
        } else {
            ph->pNext->pPrev = NULL;
            gAllocList.pHead = ph->pNext;
        }
    } else {
        ph->pPrev->pNext = ph->pNext;
        if (ph->pNext != NULL) {
            ph->pNext->pPrev = ph->pPrev;
        }
    }

    /*
     * Free the stack traces
     */
    if (ph->pTrace != NULL) {
        ExFreePool(ph->pTrace);
    }

    if (gdwPoolFlags & POOL_KEEP_FREE_RECORD) {
        RecordFreePool(ph, ph->size);
    }

    ExFreePool(ph);

    /*
     * Release the mutex
     */
    ExReleaseFastMutexUnsafe(gpAllocFastMutex);
    KeLeaveCriticalRegion();
}

/***************************************************************************\
* CleanupPoolAllocations
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
VOID CleanupPoolAllocations(
    VOID)
{
    PWin32PoolHead pHead;
    PWin32PoolHead pNext;

    if (gAllocList.dwCrtAlloc != 0) {
        if (gdwPoolFlags & POOL_BREAK_FOR_LEAKS) {
            FRE_RIPMSG0(RIP_ERROR,
                        "There is still pool memory not freed in win32k.sys.\n"
                        "Use !userkdx.dpa -vs to dump it");
        }

        pHead = gAllocList.pHead;
        while (pHead != NULL) {
            pNext = pHead->pNext;

            UserFreePool(pHead + 1);

            pHead = pNext;
        }
    }
}

/***************************************************************************\
* CleanUpPoolLimitations
*
\***************************************************************************/
VOID CleanUpPoolLimitations(
    VOID)
{
    if (gpAllocFastMutex != NULL) {
        ExFreePool(gpAllocFastMutex);
        gpAllocFastMutex = NULL;
    }

    if (gparrFailRecord != NULL) {
        ExFreePool(gparrFailRecord);
        gparrFailRecord = NULL;
    }

    if (gparrFreeRecord != NULL) {
        ExFreePool(gparrFreeRecord);
        gparrFreeRecord = NULL;
    }

    if (gparrTagsToFail != NULL) {
        ExFreePool(gparrTagsToFail);
        gparrTagsToFail = NULL;
    }
}

/***************************************************************************\
* InitPoolLimitations
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
NTSTATUS InitPoolLimitations(
    VOID)
{
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              hkey;
    NTSTATUS            Status;
    WCHAR               achKeyValue[512];
    DWORD               dwData;
    ULONG               ucb;

    /*
     * Initialize a critical section structure that will be used to protect
     * all the HeavyAllocPool and HeavyFreePool calls.
     */
    gpAllocFastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(FAST_MUTEX),
                                             TAG_DEBUG);
    if (gpAllocFastMutex == NULL) {
        RIPMSG0(RIP_WARNING, "InitPoolLimitations failed to allocate mutex");
        return STATUS_NO_MEMORY;
    }

    ExInitializeFastMutex(gpAllocFastMutex);

    /*
     * Allocate from session pool only for Full TS, that is Terminal Server
     * in app server mode. For normal Server (Remote Administration) or
     * workstation don't limit to session pool.
     */
    if ((SharedUserData->SuiteMask & VER_SUITE_TERMINAL) &&
        !(SharedUserData->SuiteMask & VER_SUITE_SINGLEUSERTS)) {
        gSessionPoolMask = SESSION_POOL_MASK;

        if (gbRemoteSession) {
            gdwPoolFlags |= POOL_HEAVY_ALLOCS;
        }
    } else {
        gSessionPoolMask = 0;
    }

#if DBG
    gdwPoolFlags |= (POOL_HEAVY_ALLOCS | POOL_CAPTURE_STACK | POOL_BREAK_FOR_LEAKS);
#endif


    /*
     * Open the key containing the limits.
     */
    RtlInitUnicodeString(
            &UnicodeString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\SubSystems\\Pool");

    InitializeObjectAttributes(
            &ObjectAttributes, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = ZwOpenKey(&hkey, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {

#if DBG
        /*
         * More default settings if the Pool key doesn't exist
         */
        if (gbRemoteSession) {

            gparrFailRecord = ExAllocatePoolWithTag(PagedPool,
                                                    32 * sizeof(POOLRECORD),
                                                    TAG_DEBUG);

            if (gparrFailRecord != NULL) {
                gdwFailRecords = 32;
                gdwPoolFlags |= POOL_KEEP_FAIL_RECORD;
            }

            gparrFreeRecord = ExAllocatePoolWithTag(PagedPool,
                                                    32 * sizeof(POOLRECORD),
                                                    TAG_DEBUG);

            if (gparrFreeRecord != NULL) {
                gdwFreeRecords = 32;
                gdwPoolFlags |= POOL_KEEP_FREE_RECORD;
            }
        }
#endif

        return STATUS_SUCCESS;
    }

    if (gbRemoteSession) {
        /*
         * Break in the debugger for memory leaks?
         */
        RtlInitUnicodeString(&UnicodeString, L"BreakForPoolLeaks");

        Status = ZwQueryValueKey(
                hkey,
                &UnicodeString,
                KeyValuePartialInformation,
                achKeyValue,
                sizeof(achKeyValue),
                &ucb);

        if (NT_SUCCESS(Status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

            dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

            if (dwData != 0) {
                gdwPoolFlags |= POOL_BREAK_FOR_LEAKS;
            } else {
                gdwPoolFlags &= ~POOL_BREAK_FOR_LEAKS;
            }
        }

        /*
         * Heavy allocs/frees for remote sessions ?
         */
        RtlInitUnicodeString(&UnicodeString, L"HeavyRemoteSession");

        Status = ZwQueryValueKey(
                hkey,
                &UnicodeString,
                KeyValuePartialInformation,
                achKeyValue,
                sizeof(achKeyValue),
                &ucb);

        if (NT_SUCCESS(Status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

            dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

            if (dwData == 0) {
                gdwPoolFlags &= ~POOL_HEAVY_ALLOCS;
            }
        }
    } else {

        /*
         * Heavy allocs/frees for main session ?
         */
        RtlInitUnicodeString(&UnicodeString, L"HeavyConsoleSession");

        Status = ZwQueryValueKey(
                hkey,
                &UnicodeString,
                KeyValuePartialInformation,
                achKeyValue,
                sizeof(achKeyValue),
                &ucb);

        if (NT_SUCCESS(Status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

            dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

            if (dwData != 0) {
                gdwPoolFlags |= POOL_HEAVY_ALLOCS;
            }
        }
    }

    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        ZwClose(hkey);
        return STATUS_SUCCESS;
    }

    /*
     * Check for stack traces
     */
    RtlInitUnicodeString(&UnicodeString, L"StackTraces");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

        if (dwData == 0) {
            gdwPoolFlags &= ~POOL_CAPTURE_STACK;
        } else {
            gdwPoolFlags |= POOL_CAPTURE_STACK;
        }
    }

    /*
     * Use tail checks ?
     */
    RtlInitUnicodeString(&UnicodeString, L"UseTailString");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

        if (dwData != 0) {
            gdwPoolFlags |= POOL_TAIL_CHECK;
        }
    }

    /*
     * Keep a record of frees ? By default keep the last 32.
     */
#if DBG
    gdwFreeRecords = 32;
#endif

    RtlInitUnicodeString(&UnicodeString, L"KeepFreeRecords");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwFreeRecords = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }

    if (gdwFreeRecords != 0) {

        gparrFreeRecord = ExAllocatePoolWithTag(PagedPool,
                                                gdwFreeRecords * sizeof(POOLRECORD),
                                                TAG_DEBUG);

        if (gparrFreeRecord != NULL) {
            gdwPoolFlags |= POOL_KEEP_FREE_RECORD;
        }
    }

    /*
     * Keep a record of failed allocations ? By default keep the last 32.
     */
#if DBG
    gdwFailRecords = 32;
#endif

    RtlInitUnicodeString(&UnicodeString, L"KeepFailRecords");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwFailRecords = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }

    if (gdwFailRecords != 0) {

        gparrFailRecord = ExAllocatePoolWithTag(PagedPool,
                                                gdwFailRecords * sizeof(POOLRECORD),
                                                TAG_DEBUG);

        if (gparrFailRecord != NULL) {
            gdwPoolFlags |= POOL_KEEP_FAIL_RECORD;
        }
    }

#if DBG
    /*
     * Open the key containing the allocation that should fail.
     */
    RtlInitUnicodeString(&UnicodeString, L"AllocationIndex");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwAllocFailIndex = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }


    RtlInitUnicodeString(&UnicodeString, L"AllocationsToFail");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwAllocsToFail = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }

    if (gdwAllocFailIndex != 0 && gdwAllocsToFail > 0) {
        gdwPoolFlags |= POOL_FAIL_BY_INDEX;
    }
#endif

    ZwClose(hkey);

    return STATUS_SUCCESS;
}
#endif

#ifdef POOL_INSTR_API
BOOL _Win32PoolAllocationStats(
    LPDWORD parrTags,
    SIZE_T tagsCount,
    SIZE_T* lpdwMaxMem,
    SIZE_T* lpdwCrtMem,
    LPDWORD lpdwMaxAlloc,
    LPDWORD lpdwCrtAlloc)
{
    BOOL bRet = FALSE;

    /*
     * Do nothing if heavy allocs/frees are disabled.
     */
    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        return FALSE;
    }

    *lpdwMaxMem   = gAllocList.dwMaxMem;
    *lpdwCrtMem   = gAllocList.dwCrtMem;
    *lpdwMaxAlloc = gAllocList.dwMaxAlloc;
    *lpdwCrtAlloc = gAllocList.dwCrtAlloc;

    /*
     * Acquire the mutex when we play with the list of allocations.
     */
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpAllocFastMutex);

    if (gparrTagsToFail != NULL) {
        ExFreePool(gparrTagsToFail);
        gparrTagsToFail = NULL;
        gdwTagsToFailCount = 0;
    }

    if (tagsCount != 0) {
        gdwPoolFlags |= POOL_FAIL_ALLOCS;

        if (tagsCount > MAX_TAGS_TO_FAIL) {
            gdwTagsToFailCount = 0xFFFFFFFF;
            RIPMSG0(RIP_WARNING, "All pool allocations in WIN32K.SYS will fail.");
            bRet = TRUE;
            goto exit;
        }
    } else {
        gdwPoolFlags &= ~POOL_FAIL_ALLOCS;

        RIPMSG0(RIP_WARNING, "Pool allocations in WIN32K.SYS back to normal.");
        bRet = TRUE;
        goto exit;
    }

    gparrTagsToFail = ExAllocatePoolWithTag(PagedPool,
                                            sizeof(DWORD) * tagsCount,
                                            TAG_DEBUG);

    if (gparrTagsToFail == NULL) {
        gdwPoolFlags &= ~POOL_FAIL_ALLOCS;
        RIPMSG0(RIP_WARNING, "Pool allocations in WIN32K.SYS back to normal !");
        goto exit;
    }

    try {
        ProbeForRead(parrTags, sizeof(DWORD) * tagsCount, DATAALIGN);
        RtlCopyMemory(gparrTagsToFail, parrTags, sizeof(DWORD) * tagsCount);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          if (gparrTagsToFail != NULL) {
              ExFreePool(gparrTagsToFail);
              gparrTagsToFail = NULL;

              gdwPoolFlags &= ~POOL_FAIL_ALLOCS;
              RIPMSG0(RIP_WARNING, "Pool allocations in WIN32K.SYS back to normal.");
              goto exit;
          }
    }
    gdwTagsToFailCount = tagsCount;

    RIPMSG0(RIP_WARNING, "Specific pool allocations in WIN32K.SYS will fail.");

exit:
    /*
     * Release the mutex
     */
    ExReleaseFastMutexUnsafe(gpAllocFastMutex);
    KeLeaveCriticalRegion();

    return bRet;
}

#endif

#ifdef TRACE_MAP_VIEWS

FAST_MUTEX*   gpSectionFastMutex;
PWin32Section gpSections;

#define EnterSectionCrit()                          \
    KeEnterCriticalRegion();                        \
    ExAcquireFastMutexUnsafe(gpSectionFastMutex);

#define LeaveSectionCrit()                          \
    ExReleaseFastMutexUnsafe(gpSectionFastMutex);   \
    KeLeaveCriticalRegion();


/***************************************************************************\
* CleanUpSections
*
\***************************************************************************/
VOID CleanUpSections(
    VOID)
{
    if (gpSectionFastMutex) {
        ExFreePool(gpSectionFastMutex);
        gpSectionFastMutex = NULL;
    }
}

NTSTATUS InitSectionTrace(
    VOID)
{
    gpSectionFastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                               sizeof(FAST_MUTEX),
                                               TAG_DEBUG);

    if (gpSectionFastMutex == NULL) {
        RIPMSG0(RIP_WARNING, "InitSectionTrace failed to allocate mutex");
        return STATUS_NO_MEMORY;
    }

    ExInitializeFastMutex(gpSectionFastMutex);

    return STATUS_SUCCESS;
}

NTSTATUS _Win32CreateSection(
    PVOID*              pSectionObject,
    ACCESS_MASK         DesiredAccess,
    POBJECT_ATTRIBUTES  ObjectAttributes,
    PLARGE_INTEGER      pInputMaximumSize,
    ULONG               SectionPageProtection,
    ULONG               AllocationAttributes,
    HANDLE              FileHandle,
    PFILE_OBJECT        FileObject,
    DWORD               SectionTag)
{
    PWin32Section pSection;
    NTSTATUS      Status;

    Status = MmCreateSection(
                    pSectionObject,
                    DesiredAccess,
                    ObjectAttributes,
                    pInputMaximumSize,
                    SectionPageProtection,
                    AllocationAttributes,
                    FileHandle,
                    FileObject);

    if (NT_SUCCESS(Status)) {
        ObDeleteCapturedInsertInfo(*pSectionObject);
    } else {
        RIPMSG1(RIP_WARNING, "MmCreateSection failed with Status 0x%x.", Status);
        *pSectionObject = NULL;
        return Status;
    }

    pSection = UserAllocPoolZInit(sizeof(Win32Section), TAG_SECTION);

    if (pSection == NULL) {
        ObDereferenceObject(*pSectionObject);
        RIPMSG0(RIP_WARNING, "Failed to allocate memory for section.");
        *pSectionObject = NULL;
        return STATUS_UNSUCCESSFUL;
    }

    EnterSectionCrit();

    pSection->pNext = gpSections;
    if (gpSections != NULL) {
        UserAssert(gpSections->pPrev == NULL);
        gpSections->pPrev = pSection;
    }

    pSection->SectionObject = *pSectionObject;
    pSection->SectionSize   = *pInputMaximumSize;
    pSection->SectionTag    = SectionTag;

    gpSections = pSection;

#ifdef MAP_VIEW_STACK_TRACE
    RtlZeroMemory(pSection->trace, MAP_VIEW_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(pSection->trace, MAP_VIEW_STACK_TRACE_SIZE, 0);

#endif

    LeaveSectionCrit();

    return STATUS_SUCCESS;
}

NTSTATUS _ZwWin32CreateSection(
    PVOID*              pSectionObject,
    ACCESS_MASK         DesiredAccess,
    POBJECT_ATTRIBUTES  ObjectAttributes,
    PLARGE_INTEGER      pInputMaximumSize,
    ULONG               SectionPageProtection,
    ULONG               AllocationAttributes,
    HANDLE              FileHandle,
    PFILE_OBJECT        FileObject,
    DWORD               SectionTag)
{
    PWin32Section pSection;
    NTSTATUS      Status;
    HANDLE        SectionHandle;

    UNREFERENCED_PARAMETER(FileObject);

    Status = ZwCreateSection(
                    &SectionHandle,
                    DesiredAccess,
                    ObjectAttributes,
                    pInputMaximumSize,
                    SectionPageProtection,
                    AllocationAttributes,
                    FileHandle);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "ZwCreateSection failed with Statu %x", Status);
        *pSectionObject = NULL;
        return Status;
    }

    Status = ObReferenceObjectByHandle(
                    SectionHandle,
                    DesiredAccess,
                    *(POBJECT_TYPE *)MmSectionObjectType,
                    KernelMode,
                    pSectionObject,
                    NULL);

    ZwClose(SectionHandle);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "ObReferenceObjectByHandle failed with Status 0x%x",
                Status);
        *pSectionObject = NULL;
        return Status;
    }

    pSection = UserAllocPoolZInit(sizeof(Win32Section), TAG_SECTION);
    if (pSection == NULL) {
        ObDereferenceObject(*pSectionObject);
        RIPMSG0(RIP_WARNING, "Failed to allocate memory for section");
        *pSectionObject = NULL;
        return STATUS_UNSUCCESSFUL;
    }

    EnterSectionCrit();

    pSection->pNext = gpSections;
    if (gpSections != NULL) {
        UserAssert(gpSections->pPrev == NULL);
        gpSections->pPrev = pSection;
    }

    pSection->SectionObject = *pSectionObject;
    pSection->SectionSize   = *pInputMaximumSize;
    pSection->SectionTag    = SectionTag;

    gpSections = pSection;

#ifdef MAP_VIEW_STACK_TRACE
    RtlZeroMemory(pSection->trace, MAP_VIEW_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(pSection->trace, MAP_VIEW_STACK_TRACE_SIZE, 0);

#endif

    LeaveSectionCrit();

    return STATUS_SUCCESS;
}

VOID _Win32DestroySection(
    PVOID Section)
{
    PWin32Section ps;

    EnterSectionCrit();

    ps = gpSections;

    while (ps != NULL) {
        if (ps->SectionObject == Section) {

            /*
             * Make sure there is no view mapped for this section
             */
            if (ps->pFirstView != NULL) {
                RIPMSG1(RIP_ERROR, "Section %#p still has views", ps);
            }

            /*
             * now, remove it from the linked list of this tag
             */
            if (ps->pPrev == NULL) {

                UserAssert(ps == gpSections);

                gpSections = ps->pNext;

                if (ps->pNext != NULL) {
                    ps->pNext->pPrev = NULL;
                }
            } else {
                ps->pPrev->pNext = ps->pNext;
                if (ps->pNext != NULL) {
                    ps->pNext->pPrev = ps->pPrev;
                }
            }
            ObDereferenceObject(Section);
            UserFreePool(ps);
            LeaveSectionCrit();
            return;
        }
        ps = ps->pNext;
    }

    RIPMSG1(RIP_ERROR, "Cannot find Section %#p", Section);
    LeaveSectionCrit();
}

NTSTATUS _Win32MapViewInSessionSpace(
    PVOID   Section,
    PVOID*  pMappedBase,
    PSIZE_T pViewSize)
{
    NTSTATUS      Status;
    PWin32Section ps;
    PWin32MapView pMapView;

    /*
     * First try to map the view
     */
    Status = MmMapViewInSessionSpace(Section, pMappedBase, pViewSize);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "MmMapViewInSessionSpace failed with Status %x",
                Status);
        *pMappedBase = NULL;
        return Status;
    }

    /*
     * Now add a record for this view
     */
    pMapView = UserAllocPoolZInit(sizeof(Win32MapView), TAG_SECTION);

    if (pMapView == NULL) {
        RIPMSG0(RIP_WARNING, "_Win32MapViewInSessionSpace: Memory failure");

        MmUnmapViewInSessionSpace(*pMappedBase);
        *pMappedBase = NULL;
        return STATUS_NO_MEMORY;
    }

    pMapView->pViewBase = *pMappedBase;
    pMapView->ViewSize  = *pViewSize;

    EnterSectionCrit();

    ps = gpSections;

    while (ps != NULL) {
        if (ps->SectionObject == Section) {

            pMapView->pSection = ps;

            pMapView->pNext = ps->pFirstView;

            if (ps->pFirstView != NULL) {
                ps->pFirstView->pPrev = pMapView;
            }
            ps->pFirstView = pMapView;

#ifdef MAP_VIEW_STACK_TRACE
            RtlZeroMemory(pMapView->trace, MAP_VIEW_STACK_TRACE_SIZE * sizeof(PVOID));

            RtlWalkFrameChain(pMapView->trace, MAP_VIEW_STACK_TRACE_SIZE, 0);

#endif

            LeaveSectionCrit();
            return STATUS_SUCCESS;
        }
        ps = ps->pNext;
    }

    RIPMSG1(RIP_ERROR, "_Win32MapViewInSessionSpace: Could not find section for %#p",
            Section);

    LeaveSectionCrit();

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS _Win32UnmapViewInSessionSpace(
    PVOID MappedBase)
{
    PWin32Section ps;
    PWin32MapView pv;
    NTSTATUS      Status;

    EnterSectionCrit();

    ps = gpSections;

    while (ps != NULL) {

        pv = ps->pFirstView;

        while (pv != NULL) {

            UserAssert(pv->pSection == ps);

            if (pv->pViewBase == MappedBase) {
                /*
                 * now, remove it from the linked list
                 */
                if (pv->pPrev == NULL) {

                    UserAssert(pv == ps->pFirstView);

                    ps->pFirstView = pv->pNext;

                    if (pv->pNext != NULL) {
                        pv->pNext->pPrev = NULL;
                    }
                } else {
                    pv->pPrev->pNext = pv->pNext;
                    if (pv->pNext != NULL) {
                        pv->pNext->pPrev = pv->pPrev;
                    }
                }

                UserFreePool(pv);

                Status = MmUnmapViewInSessionSpace(MappedBase);

                LeaveSectionCrit();

                return Status;
            }
            pv = pv->pNext;
        }
        ps = ps->pNext;
    }

    RIPMSG1(RIP_ERROR,
            "_Win32UnmapViewInSessionSpace: Could not find view for 0x%p",
            MappedBase);

    LeaveSectionCrit();

    return STATUS_UNSUCCESSFUL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\precomp.h ===
/*
 * Core NT headers
 */
#define NOWINBASEINTERLOCK
#include <ntosp.h>



#include <zwapi.h>
//#include <ntdbg.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddstor.h>
#include <wdmguid.h>
#include <ntcsrmsg.h>
#include <wmistr.h>
#include <wmidata.h>


/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <stddef.h>
#include <stdio.h>


/*
 * Win32 headers
 */
#include <windef.h>
#include <wingdi.h>
#include <w32gdip.h>
#include <winerror.h>
#include <ntgdistr.h>
#include <winddi.h>
#include <w32p.h>
#include <w32err.h>
#include <gre.h>
#include <usergdi.h>
#include <ddeml.h>
#include <ddemlp.h>
#include <winuserk.h>
#include <dde.h>
#include <ddetrack.h>


/*
 * Far East specific headers
 */
#ifdef FE_IME
#include <immstruc.h>
#endif

/*
 * NtUser global headers
 */

#include <mountmgr.h>
#include <ioevent.h>

/*
 * NtUser Kernel specific headers
 */
#include <kbd.h>
#include "userk.h"
#include "access.h"
#include <conapi.h>

#include "winstaw.h"
#include <icadd.h>
#include <regapi.h>
#include <winddits.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\power.c ===
/****************************** Module Header ******************************\
* Module Name: power.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the code to implement power management.
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrmsg.h>
#include "csrmsg.h"
#include "ntddvdeo.h"

#pragma alloc_text(INIT, InitializePowerRequestList)

BOOL IsSessionSwitchBlocked();
NTSTATUS UserSessionSwitchBlock_Start();
void UserSessionSwitchBlock_End();


extern BOOL gbUserInitialized;

#define SWITCHACTION_RESETMODE      0x1
#define SWITCHACTION_REENUMERATE    0x2

LIST_ENTRY gPowerRequestList;
PFAST_MUTEX gpPowerRequestMutex;
PKEVENT gpEventPowerRequest;
ULONG   gulDelayedSwitchAction = 0;

typedef struct tagPOWERREQUEST {
    LIST_ENTRY        PowerRequestLink;
    union {
        KEVENT            Event;
        WIN32_POWEREVENT_PARAMETERS CapturedParms;
    };
    NTSTATUS          Status;
    PKWIN32_POWEREVENT_PARAMETERS Parms;
} POWERREQUEST, *PPOWERREQUEST;

PPOWERREQUEST gpPowerRequestCurrent;

__inline VOID EnterPowerCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpPowerRequestMutex);
}

__inline VOID LeavePowerCrit(
    VOID)
{
    ExReleaseFastMutexUnsafe(gpPowerRequestMutex);
    KeLeaveCriticalRegion();
}

/***************************************************************************\
* CancelPowerRequest
*
* The power request can't be satisfied because the worker thread is gone.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/
VOID
CancelPowerRequest(
    PPOWERREQUEST pPowerRequest)
{
    UserAssert(pPowerRequest != gpPowerRequestCurrent);
    pPowerRequest->Status = STATUS_UNSUCCESSFUL;

    /*
     * If it was a callout, tell the waiting thread to proceed.
     * If it was an event, there is no waiting thread but we need to
     * free the pool
     */
    if (pPowerRequest->Parms) {
        UserFreePool(pPowerRequest);
    } else {
        KeSetEvent(&pPowerRequest->Event, EVENT_INCREMENT, FALSE);
    }
}

/***************************************************************************\
* QueuePowerRequest
*
* Insert a power request into the list and wakeup CSRSS to process it.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

NTSTATUS
QueuePowerRequest(
    PKWIN32_POWEREVENT_PARAMETERS Parms)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOWERREQUEST pPowerRequest;
    TL tlPool;

    UserAssert(gpEventPowerRequest != NULL);
    UserAssert(gpPowerRequestMutex != NULL);

    /*
     * Allocate and initialize the power request.
     */
    pPowerRequest = UserAllocPoolNonPagedNS(sizeof(POWERREQUEST), TAG_POWER);
    if (pPowerRequest == NULL) {
        return STATUS_NO_MEMORY;
    }

    /*
     * If this is a callout, there are no paramaters. Initialize the event to wait on.
     * If this is an event, capture the parameters to be freed after the event
     * is dispatched.
     */
    if (Parms) {
        pPowerRequest->CapturedParms = *Parms;
        pPowerRequest->Parms = &pPowerRequest->CapturedParms;
    } else {
        KeInitializeEvent(&pPowerRequest->Event, SynchronizationEvent, FALSE);
        pPowerRequest->Parms = NULL;
    }

    /*
     * Insert the power request into the list.
     */
    EnterPowerCrit();
    if (gbNoMorePowerCallouts) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        InsertHeadList(&gPowerRequestList, &pPowerRequest->PowerRequestLink);
    }
    LeavePowerCrit();

    /*
     * if this thread is gone through attach process, or
     * If this is a system thread or a non-GUI thread, tell CSRSS to do the
     * work and wait for it to finish. Otherwise, we'll do the work ourselves.
     */
    if (NT_SUCCESS(Status)) {
        if (PsIsSystemThread(PsGetCurrentThread()) ||
            KeIsAttachedProcess() ||
            W32GetCurrentThread() == NULL) {
            KeSetEvent(gpEventPowerRequest, EVENT_INCREMENT, FALSE);
        } else {
            EnterCrit();
            ThreadLockPool(PtiCurrent(), pPowerRequest, &tlPool);
            xxxUserPowerCalloutWorker();
            ThreadUnlockPool(PtiCurrent(), &tlPool);
            LeaveCrit();
        }

        /*
         * If this is a callout, wait for it and then free the request.
         * Otherwise, it is an event, and we do not need to wait for it
         * to complete. The request will be freed after it is dequeued.
         */
        if (Parms) {
            return(STATUS_SUCCESS);
        } else {
            Status = KeWaitForSingleObject(&pPowerRequest->Event,
                                           WrUserRequest,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            if (NT_SUCCESS(Status)) {
                Status = pPowerRequest->Status;
            }
        }
    }

    /*
     * Free the power request.
     */
    UserAssert(pPowerRequest != gpPowerRequestCurrent);
    UserFreePool(pPowerRequest);

    return Status;
}

/***************************************************************************\
* UnqueuePowerRequest
*
* Remove a power request from the list.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/
PPOWERREQUEST
UnqueuePowerRequest(
    VOID)
{
    PLIST_ENTRY pEntry;
    PPOWERREQUEST pPowerRequest = NULL;

    /*
     * Remove a power request from the list.
     */
    EnterPowerCrit();
    if (!IsListEmpty(&gPowerRequestList)) {
        pEntry = RemoveTailList(&gPowerRequestList);
        pPowerRequest = CONTAINING_RECORD(pEntry, POWERREQUEST, PowerRequestLink);
    }
    LeavePowerCrit();

    return pPowerRequest;
}

/***************************************************************************\
* InitializePowerRequestList
*
* Initialize global power request list state.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/
NTSTATUS
InitializePowerRequestList(
    HANDLE hPowerRequestEvent)
{
    NTSTATUS Status;

    InitializeListHead(&gPowerRequestList);

    Status = ObReferenceObjectByHandle(hPowerRequestEvent,
                                       EVENT_ALL_ACCESS,
                                       *ExEventObjectType,
                                       KernelMode,
                                       &gpEventPowerRequest,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    gpPowerRequestMutex = UserAllocPoolNonPagedNS(sizeof(FAST_MUTEX), TAG_POWER);
    if (gpPowerRequestMutex == NULL) {
        return STATUS_NO_MEMORY;
    }
    ExInitializeFastMutex(gpPowerRequestMutex);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* CleanupPowerRequestList
*
* Cancel any pending power requests.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/
VOID
CleanupPowerRequestList(
    VOID)
{
    PPOWERREQUEST pPowerRequest;

    /*
     * Make sure no new power requests come in.
     */
    gbNoMorePowerCallouts = TRUE;

    /*
     * If we never allocated anything, there's nothing to clean up.
     */
    if (gpPowerRequestMutex == NULL) {
        return;
    }

    /*
     * Mark any pending power requests as cacelled.
     */
    while ((pPowerRequest = UnqueuePowerRequest()) != NULL) {
        CancelPowerRequest(pPowerRequest);
    }
}

/***************************************************************************\
* DeletePowerRequestList
*
* Clean up any global power request state.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/
VOID
DeletePowerRequestList(
    VOID)
{
    if (gpPowerRequestMutex) {

        /*
         * Make sure there are no pending power requests.
         */
        UserAssert(IsListEmpty(&gPowerRequestList));

        /*
         * Free the power request structures.
         */
        UserFreePool(gpPowerRequestMutex);
        gpPowerRequestMutex = NULL;
    }
}

/***************************************************************************\
* UserPowerEventCalloutWorker
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/
NTSTATUS xxxUserPowerEventCalloutWorker(
    PKWIN32_POWEREVENT_PARAMETERS Parms)
{
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    NTSTATUS Status = STATUS_SUCCESS;
    PSPOWEREVENTTYPE EventNumber = Parms->EventNumber;
    ULONG_PTR Code = Parms->Code;
    BOOL bCurrentPowerOn;
    ULONGLONG ullLastSleepTime;
    BOOL bGotLastSleepTime;


    /*
     * Make sure CSRSS is still running.
     */
    if (gbNoMorePowerCallouts) {
        return STATUS_UNSUCCESSFUL;
    }

    switch (EventNumber) {
    case PsW32FullWake:

        if (!gbRemoteSession) {
            /*
             * Let all the services know that they can resume operation.
             * There is no corresponding POWER_ACTION for this, but since this
             * is a non-query event, PowerActionNone is as good as any.
             */
            LeaveCrit();
            IoPnPDeliverServicePowerNotification(PowerActionNone,
                                                 PBT_APMRESUMESUSPEND,
                                                 0,
                                                 FALSE);
            EnterCrit();
        }

        /*
         * Let all the applications know that they can resume operation.
         * We must not send this message to a session, if it was created after machine went into sleep
         */

        /*
         * One of the side effects of NtPowerInformation is that it will
         * dispatch pending power events. So we cannot call it with the user
         * critsec held.
         *
         * Note: Same thing is done for IoPnPDeliverServicePowerNotification.
         */
        LeaveCrit();
        bGotLastSleepTime = ZwPowerInformation(LastSleepTime, NULL, 0, &ullLastSleepTime, sizeof(ULONGLONG)) == STATUS_SUCCESS;
        EnterCrit();

        if (!bGotLastSleepTime || gSessionCreationTime < ullLastSleepTime) {

            bsmParams.dwRecipients = BSM_ALLDESKTOPS;
            bsmParams.dwFlags = BSF_QUEUENOTIFYMESSAGE;
            xxxSendMessageBSM(NULL,
                              WM_POWERBROADCAST,
                              PBT_APMRESUMESUSPEND,
                              0,
                              &bsmParams);

        }
        break;

    case PsW32EventCode:
        /*
         * Post a message to winlogon, and let them put up a message box
         * or play a sound.
         */

        if (gspwndLogonNotify) {
            glinp.ptiLastWoken = GETPTI(gspwndLogonNotify);
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_POWEREVENT, (ULONG)Code);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        break;

    case PsW32PowerPolicyChanged:
        /*
         * Set video timeout value.
         */
        xxxSystemParametersInfo(SPI_SETLOWPOWERTIMEOUT, (ULONG)Code, 0, 0);
        xxxSystemParametersInfo(SPI_SETPOWEROFFTIMEOUT, (ULONG)Code, 0, 0);
        break;

    case PsW32SystemPowerState:

        if (!gbRemoteSession) {
            /*
             * Let all the services know that the power status has changed.
             * There is no corresponding POWER_ACTION for this, but since this
             * is a non-query event, PowerActionNone is as good as any.
             */
            LeaveCrit();
            IoPnPDeliverServicePowerNotification(PowerActionNone,
                                                 PBT_APMPOWERSTATUSCHANGE,
                                                 0,
                                                 FALSE);
            EnterCrit();
        }

        /*
         * Let all the applications know that the power status has changed.
         */
        bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        bsmParams.dwFlags = BSF_POSTMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_POWERBROADCAST,
                          PBT_APMPOWERSTATUSCHANGE,
                          0,
                          &bsmParams);
        break;

    case PsW32SystemTime:
        /*
         * Let all the applications know that the system time has changed.
         */
        bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        bsmParams.dwFlags = BSF_POSTMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_TIMECHANGE,
                          0,
                          0,
                          &bsmParams);
        break;

    case PsW32DisplayState:
        /*
         * Set video timeout active status.
         */
        xxxSystemParametersInfo(SPI_SETLOWPOWERACTIVE, !Code, 0, 0);
        xxxSystemParametersInfo(SPI_SETPOWEROFFACTIVE, !Code, 0, 0);
        break;

    case PsW32GdiOff:
        /*
         * At this point we will disable the display device, if no protocol switch is in progress.
         */
        if (!gfSwitchInProgress) {
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3);

            bCurrentPowerOn = DrvQueryMDEVPowerState(gpDispInfo->pmdev);
            if (bCurrentPowerOn) {
                SafeDisableMDEV();
            }
            DrvSetMDEVPowerState(gpDispInfo->pmdev, FALSE);
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        break;

    case PsW32GdiOn:
        /*
         * Call video driver to turn the display back on, if no protocol
         * switch is in progress.
         */

        if (!gfSwitchInProgress) {
            bCurrentPowerOn = DrvQueryMDEVPowerState(gpDispInfo->pmdev);
            if (!bCurrentPowerOn) {
                SafeEnableMDEV();
            }
            DrvSetMDEVPowerState(gpDispInfo->pmdev, TRUE);
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        } else {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        /*
         * Repaint the whole screen.
         */
        xxxUserResetDisplayDevice();

        if (gulDelayedSwitchAction) {
            HANDLE pdo;

            //
            // The first ACPI device is the one respond to hotkey.
            //
            PVOID PhysDisp = DrvWakeupHandler(&pdo);

            if (PhysDisp && (gulDelayedSwitchAction & SWITCHACTION_RESETMODE)) {
                UNICODE_STRING strDeviceName;
                DEVMODEW NewMode;
                ULONG bPrune;

                if (DrvDisplaySwitchHandler(PhysDisp, &strDeviceName, &NewMode, &bPrune)) {
                    /*
                     * CSRSS is not the only process to deliver power callouts.
                     */
                    bPrune = (bPrune ? 0 : CDS_RAWMODE) | CDS_TRYCLOSEST | CDS_RESET;
                    if (!ISCSRSS()) {
                        xxxUserChangeDisplaySettings(NULL,
                                                     NULL,
                                                     grpdeskRitInput,
                                                     bPrune,
                                                     0,
                                                     KernelMode);
                    } else {
                        xxxUserChangeDisplaySettings(NULL,
                                                     NULL,
                                                     NULL,
                                                     bPrune,
                                                     0,
                                                     KernelMode);
                    }
                }

                //
                // If there is a requirement to reenumerate sub-devices.
                //
                if (pdo && (gulDelayedSwitchAction & SWITCHACTION_REENUMERATE)) {
                    IoInvalidateDeviceRelations((PDEVICE_OBJECT)pdo, BusRelations);
                }
            }
        }
        gulDelayedSwitchAction = 0;

        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    return Status;
}

/***************************************************************************\
* UserPowerEventCallout
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/
NTSTATUS UserPowerEventCallout(
    PKWIN32_POWEREVENT_PARAMETERS Parms)
{
    /*
     * Make sure CSRSS is running.
     */
    if (!gbVideoInitialized || gbNoMorePowerCallouts) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(gpepCSRSS != NULL);

    /*
     * Process the power request.
     */
    return QueuePowerRequest(Parms);
}

/***************************************************************************\
* UserPowerStateCalloutWorker
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/
NTSTATUS xxxUserPowerStateCalloutWorker(
    VOID)
{
    BOOL fContinue;
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    POWER_ACTION powerOperation;
    NTSTATUS Status = STATUS_SUCCESS;
    TL tlpwnd;
    POWERSTATETASK Task = gPowerState.PowerStateTask;
    ULONGLONG ullLastSleepTime;
    BOOL bGotLastSleepTime;

    /*
     * By now we must have alrady blocked session switch, it's blocked only
     * for win32k belonging to active console session.
     */
    UserAssert(SharedUserData->ActiveConsoleId != gSessionId || IsSessionSwitchBlocked());

    /*
     * Make sure CSRSS is still running.
     */
    if (gbNoMorePowerCallouts) {
        return STATUS_UNSUCCESSFUL;
    }


    switch (Task) {

    case PowerState_Init:

        /*
         * Store the event so this thread can be promoted later.
         */

        EnterPowerCrit();
        gPowerState.pEvent = PtiCurrent()->pEventQueueServer;
        LeavePowerCrit();

        break;

    case PowerState_QueryApps:

        if (!gPowerState.fCritical) {
            /*
             * Ask the applications if we can suspend operation.
             */
            if (gPowerState.fQueryAllowed) {

                gPowerState.bsmParams.dwRecipients = BSM_ALLDESKTOPS;
                gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_FORCEIFHUNG;
                if (gPowerState.fUIAllowed) {
                    gPowerState.bsmParams.dwFlags |= BSF_ALLOWSFW;
                }

                if (gPowerState.fOverrideApps == FALSE) {
                    gPowerState.bsmParams.dwFlags |= (BSF_QUERY | BSF_NOTIMEOUTIFNOTHUNG);
                }

                fContinue = xxxSendMessageBSM(NULL,
                                              WM_POWERBROADCAST,
                                              PBT_APMQUERYSUSPEND,
                                              gPowerState.fUIAllowed,
                                              &gPowerState.bsmParams);


                if (fContinue && !gbRemoteSession) {
                    /*
                     * Ask the services if we can suspend operation.
                     * Map the power action event as needed.
                     */
                    if (gPowerState.psParams.MinSystemState == PowerSystemHibernate) {
                        powerOperation = PowerActionHibernate;
                    } else {
                        powerOperation = gPowerState.psParams.SystemAction;
                    }

                    LeaveCrit();
                    fContinue = IoPnPDeliverServicePowerNotification(
                        powerOperation,
                        PBT_APMQUERYSUSPEND,
                        gPowerState.fUIAllowed,
                        TRUE); // synchronous query
                    EnterCrit();
                }

                /*
                 * If an app or service says to abort and we're not in
                 * override apps or critical mode, return query failed.
                 */
                if (!(fContinue || gPowerState.fOverrideApps || gPowerState.fCritical)) {
                    Status = STATUS_CANCELLED;
                }
            }

        }

        break;

    case PowerState_QueryFailed:

        /*
         * Only send a suspend failed message to the applications, since pnp
         * will already have delivered the suspend failed message to services if
         * one of those aborted the query.
         */
        gPowerState.bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        gPowerState.bsmParams.dwFlags = BSF_QUEUENOTIFYMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_POWERBROADCAST,
                          PBT_APMQUERYSUSPENDFAILED,
                          0,
                          &gPowerState.bsmParams);
        EnterPowerCrit();
        gPowerState.pEvent = NULL;
        gPowerState.fInProgress = FALSE;
        LeavePowerCrit();


        break;

    case PowerState_SuspendApps:

        if (!gPowerState.fCritical) {

            if (!gbRemoteSession) {
                /*
                 * Map the power action event as needed.
                 */
                if (gPowerState.psParams.MinSystemState == PowerSystemHibernate) {
                    powerOperation = PowerActionHibernate;
                } else {
                    powerOperation = gPowerState.psParams.SystemAction;
                }

                LeaveCrit();
                IoPnPDeliverServicePowerNotification(powerOperation,
                                                     PBT_APMSUSPEND,
                                                     0,
                                                     FALSE);
                EnterCrit();
            }

            gPowerState.bsmParams.dwRecipients = BSM_ALLDESKTOPS;
            gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_FORCEIFHUNG;
            xxxSendMessageBSM(NULL,
                              WM_POWERBROADCAST,
                              PBT_APMSUSPEND,
                              0,
                              &gPowerState.bsmParams);
        }

        /*
         * Clear the event so the thread won't wake up prematurely.
         */
        EnterPowerCrit();
        gPowerState.pEvent = NULL;
        LeavePowerCrit();

        break;

    case PowerState_ShowUI:

        /*
        * if this is not session 0 show ui for sessions.
        * we shall take this ui off when we resume apps
        * For session 0 we call PowerState_NotifyWL which takes care of it.
        */

        if ((gSessionId != 0 ) && (gspwndLogonNotify != NULL)) {

            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);

            Status = (NTSTATUS)xxxSendMessage(gspwndLogonNotify,
                                              WM_LOGONNOTIFY,
                                              LOGON_SHOW_POWER_MESSAGE,
                                              (LPARAM)&gPowerState.psParams);
            ThreadUnlock(&tlpwnd);


        }

        break;


    case PowerState_NotifyWL:

        if (gspwndLogonNotify != NULL) {
            PWND pwndActive;

            if (gpqForeground && (pwndActive = gpqForeground->spwndActive) &&
                    (GetFullScreen(pwndActive) == FULLSCREEN ||
                     GetFullScreen(pwndActive) == FULLSCREENMIN)) {
                gPowerState.psParams.FullScreenMode = TRUE;
            } else {
                gPowerState.psParams.FullScreenMode = FALSE;
            }
            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
            Status = (NTSTATUS)xxxSendMessage(gspwndLogonNotify,
                                              WM_LOGONNOTIFY,
                                              LOGON_POWERSTATE,
                                              (LPARAM)&gPowerState.psParams);

            ThreadUnlock(&tlpwnd);

            if (!NT_SUCCESS(Status)) {
                /*
                 * If we failed to to this power operation, don't lock the
                 * console.
                 */
                gPowerState.psParams.Flags &= ~POWER_ACTION_LOCK_CONSOLE;
            }
        }

        break;

    case PowerState_ResumeApps:
        /*
         * If this is active console we need to lock it.
         */
        if ((gPowerState.psParams.Flags & POWER_ACTION_LOCK_CONSOLE) &&
            (gSessionId == SharedUserData->ActiveConsoleId) &&
            (gspwndLogonNotify != NULL)) {

            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);

            _PostMessage(gspwndLogonNotify,
                        WM_LOGONNOTIFY,
                        LOGON_LOCKWORKSTATION,
                        LOCK_RESUMEHIBERNATE);

            ThreadUnlock(&tlpwnd);

        }



        //
        // We dont need to remove power message, if we did not post one.
        //

        /*
         * One of the side effects of NtPowerInformation is that it will
         * dispatch pending power events. So we can not call it with the
         * user critsec held.
         *
         * Note: The same thing is done for IoPnPDeliverServicePowerNotification.
         */

        LeaveCrit();
        bGotLastSleepTime = ZwPowerInformation(LastSleepTime, NULL, 0, &ullLastSleepTime, sizeof(ULONGLONG)) == STATUS_SUCCESS;
        EnterCrit();

        if (!bGotLastSleepTime || gSessionCreationTime < ullLastSleepTime) {
            if (gSessionId != 0 && gspwndLogonNotify != NULL) {
                ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
                Status = (NTSTATUS)xxxSendMessage(gspwndLogonNotify,
                                                  WM_LOGONNOTIFY,
                                                  LOGON_REMOVE_POWER_MESSAGE,
                                                  (LPARAM)&gPowerState.psParams);

                ThreadUnlock(&tlpwnd);
            }
        }

        /*
         * The power state broadcast is over.
         */
        EnterPowerCrit();
        gPowerState.fInProgress = FALSE;
        LeavePowerCrit();

        /*
         * Tickle the input time so we don't fire up a screen saver right away
         * and remember that the monitor is on.
         */
        glinp.timeLastInputMessage = NtGetTickCount();
        glinp.dwFlags &= ~LINP_POWEROFF;

        if (!gbRemoteSession) {
            /*
             * Re-init the keyboard state.
             */
            InitKeyboardState();

            /*
             * Let all the services know that we're waking up. There is no
             * corresponding POWER_ACTION for this, but since this is a
             * non-query event, PowerActionNone is as good as any.
             */
            LeaveCrit();
            IoPnPDeliverServicePowerNotification(PowerActionNone,
                                                 PBT_APMRESUMEAUTOMATIC,
                                                 0,
                                                 FALSE);
            EnterCrit();
        }

        /*
         * Let all the applications know that we're waking up.
         */
        bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        bsmParams.dwFlags = BSF_QUEUENOTIFYMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_POWERBROADCAST,
                          PBT_APMRESUMEAUTOMATIC,
                          0,
                          &bsmParams);


        break;

    default:
        RIPMSG1(RIP_ERROR, "Unknown task 0x%x", Task);
        break;
    }

    return Status;
}

/***************************************************************************\
* UserPowerStateCallout
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/
NTSTATUS UserPowerStateCallout(
    PKWIN32_POWERSTATE_PARAMETERS Parms)
{
    POWERSTATETASK Task = Parms->PowerStateTask;
    BOOLEAN Promotion = Parms->Promotion;
    POWER_ACTION SystemAction = Parms->SystemAction;
    SYSTEM_POWER_STATE MinSystemState = Parms->MinSystemState;
    ULONG Flags = Parms->Flags;
    NTSTATUS Status;

    if (Task == PowerState_BlockSessionSwitch) {
        /*
         * Don't allow active console session switch while we are in power
         * callouts. First try to block the session switch.
         */
        return UserSessionSwitchBlock_Start();
    }

    if (Task == PowerState_UnBlockSessionSwitch) {
        UserAssert(IsSessionSwitchBlocked());
        UserSessionSwitchBlock_End();
        return STATUS_SUCCESS;
    }

    /*
     * Make sure CSRSS is running.
     */
    if (!gbVideoInitialized || gbNoMorePowerCallouts || !gspwndLogonNotify) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(gpepCSRSS != NULL);

    EnterPowerCrit();
    if (Task == PowerState_Init) {
        /*
         * Make sure we're not trying to promote a non-existent request
         * or start a new one when we're already doing it.
         */
        if ((Promotion && !gPowerState.fInProgress) ||
            (!Promotion && gPowerState.fInProgress)) {
            LeavePowerCrit();

            return STATUS_INVALID_PARAMETER;
        }

        /*
         * Save our state.
         */
        gPowerState.fInProgress = TRUE;
        gPowerState.fOverrideApps = (Flags & POWER_ACTION_OVERRIDE_APPS) != 0;
        gPowerState.fCritical = (Flags & POWER_ACTION_CRITICAL) != 0;
        gPowerState.fQueryAllowed = (Flags & POWER_ACTION_QUERY_ALLOWED) != 0;
        gPowerState.fUIAllowed = (Flags & POWER_ACTION_UI_ALLOWED) != 0;
        gPowerState.psParams.SystemAction = SystemAction;
        gPowerState.psParams.MinSystemState = MinSystemState;
        gPowerState.psParams.Flags = Flags;
        if (gPowerState.fOverrideApps) {
            gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_FORCEIFHUNG;
        }
        if (gPowerState.fCritical) {
            gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_QUERY;
        }
        if (gPowerState.pEvent) {
            KeSetEvent(gPowerState.pEvent, EVENT_INCREMENT, FALSE);
        }

    }

    gPowerState.PowerStateTask = Task;

    LeavePowerCrit();

    /*
     * If this is a promotion, we're done.
     */
    if (Promotion) {
        return STATUS_SUCCESS;
    }

    /*
     * Process the power request.
     */
    Status = QueuePowerRequest(NULL);
    if (Task == PowerState_QueryApps && !NT_SUCCESS(Status)) {
        /*
         * Query was refused.
         */
        Parms->fQueryDenied = TRUE;
    }

    return Status;
}

/***************************************************************************\
* UserPowerCalloutWorker
*
* Pull any pending power requests off the list and call the appropriate
* power callout function.
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/
VOID
xxxUserPowerCalloutWorker(
    VOID)
{
    PPOWERREQUEST pPowerRequest;
    TL tlPool;

    while ((pPowerRequest = UnqueuePowerRequest()) != NULL) {
        /*
         * Make sure the event gets signalled even if the thread dies in a
         * callback or the waiting thread might get stuck.
         */
        ThreadLockPoolCleanup(PtiCurrent(), pPowerRequest, &tlPool, CancelPowerRequest);

        /*
         * Call the appropriate power worker function.
         */
        gpPowerRequestCurrent = pPowerRequest;
        if (pPowerRequest->Parms) {
            pPowerRequest->Status = xxxUserPowerEventCalloutWorker(pPowerRequest->Parms);
        } else {
            pPowerRequest->Status = xxxUserPowerStateCalloutWorker();
        }
        gpPowerRequestCurrent = NULL;

        /*
         * If it was a callout, tell the waiting thread to proceed. If it
         * was an event, there is no waiting thread but we need to free the
         * pool.
         */
        ThreadUnlockPoolCleanup(PtiCurrent(), &tlPool);
        if (pPowerRequest->Parms) {
            UserFreePool(pPowerRequest);
        } else {
            KeSetEvent(&pPowerRequest->Event, EVENT_INCREMENT, FALSE);
        }
    }
}


/***************************************************************************\
* VideoPortCalloutThread
*
* Call the appropriate power callout function and return.
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/
VOID
VideoPortCalloutThread(
    PPOWER_INIT pInitData)
{
    NTSTATUS Status;
    PVIDEO_WIN32K_CALLBACKS_PARAMS Params = pInitData->Params;

    Params->Status = InitSystemThread(NULL);

    if (!NT_SUCCESS(Params->Status)) {
        goto RetThreadCallOut;
    }

    while (1) {
        EnterCrit();
        if (!gfSwitchInProgress) {
            break;
        } else {
            LeaveCrit();
            Status = KeWaitForSingleObject(gpevtVideoportCallout, WrUserRequest, KernelMode, FALSE, NULL);
        }
    }

    if (IsRemoteConnection()) {
        LeaveCrit();
        Params->Status = STATUS_UNSUCCESSFUL;
        goto RetThreadCallOut;
    }

    switch (Params->CalloutType) {

    case VideoWakeupCallout:
        gulDelayedSwitchAction |= SWITCHACTION_RESETMODE;

        break;

    case VideoDisplaySwitchCallout:
        {
            UNICODE_STRING   strDeviceName;
            DEVMODEW         NewMode;
            ULONG            bPrune;


            Params->Status = STATUS_SUCCESS;

            if (!DrvQueryMDEVPowerState(gpDispInfo->pmdev)) {
                gulDelayedSwitchAction |= ((Params->PhysDisp != NULL) ? SWITCHACTION_RESETMODE : 0) |
                                          ((Params->Param) ? SWITCHACTION_REENUMERATE : 0);
                break;
            }

            gulDelayedSwitchAction = 0;
            if (Params->PhysDisp != NULL) {
                if (DrvDisplaySwitchHandler(Params->PhysDisp, &strDeviceName, &NewMode, &bPrune)) {
                    DESKRESTOREDATA drdRestore;
                    drdRestore.pdeskRestore = NULL;

                    /*
                     * CSRSS is not the only process to deliver power callouts.
                     */
                    if (!ISCSRSS() ||
                        NT_SUCCESS(xxxSetCsrssThreadDesktop(grpdeskRitInput, &drdRestore))) {
                        xxxUserChangeDisplaySettings(NULL, NULL, grpdeskRitInput,
                                 ((bPrune) ? 0 : CDS_RAWMODE) | CDS_TRYCLOSEST | CDS_RESET, 0, KernelMode);

                        if (ISCSRSS()) {
                            xxxRestoreCsrssThreadDesktop(&drdRestore);
                        }
                    }
                }
            }
        }

        /*
         * If there is a requirement to reenumerate sub-devices.
         */
        if (Params->Param) {
            IoInvalidateDeviceRelations((PDEVICE_OBJECT)Params->Param, BusRelations);
        }

        break;

    case VideoChangeDisplaySettingsCallout:
        {
            DEVMODEW Devmode;
            DESKRESTOREDATA drdRestore;

            memset(&Devmode, 0, sizeof(DEVMODEW));
            Devmode.dmSize = sizeof(DEVMODEW);
            Devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
            Devmode.dmBitsPerPel = 4;
            Devmode.dmPelsWidth = 640;
            Devmode.dmPelsHeight = 480;

            drdRestore.pdeskRestore = NULL;

            /*
             * CSRSS is not the only process to deliver power callouts.
             */
            if (!ISCSRSS() ||
                NT_SUCCESS(xxxSetCsrssThreadDesktop(grpdeskRitInput, &drdRestore))) {
                xxxUserChangeDisplaySettings(NULL, &Devmode, grpdeskRitInput, CDS_RESET, NULL, KernelMode);

                if (ISCSRSS()) {
                    xxxRestoreCsrssThreadDesktop(&drdRestore);
                }
            }
        }
        break;

    case VideoFindAdapterCallout:
        if (Params->Param) {
            SafeEnableMDEV();
            xxxUserResetDisplayDevice();
        } else {
            SafeDisableMDEV();
        }

        Params->Status = STATUS_SUCCESS;
        break;

    default:
        RIPMSG1(RIP_ERROR,
                "Unknown Params->CalloutType 0x%x",
                Params->CalloutType);
        Params->Status = STATUS_UNSUCCESSFUL;
    }


    LeaveCrit();

RetThreadCallOut:
    /*
     * Signal that the Callout has been ended.
     */
    KeSetEvent(pInitData->pPowerReadyEvent, EVENT_INCREMENT, FALSE);
}


/***************************************************************************\
* VideoPortCallout
*
* History:
* 26-Jul-1998 AndreVa   Created.
\***************************************************************************/
VOID
VideoPortCallout(
    IN PVOID Params)
{
    /*
     * To make sure this is a system thread, we create a new thread.
     */
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOL fRet;
    USER_API_MSG m;
    POWER_INIT initData;

    //
    // Make sure video has been initialized.
    //
    if (!gbVideoInitialized) {
        ((PVIDEO_WIN32K_CALLBACKS_PARAMS)Params)->Status = STATUS_UNSUCCESSFUL;
        return;
    }

    //
    // Make sure the CsrApiPort has been initialized
    //

    if (!CsrApiPort) {
        ((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status = STATUS_INVALID_HANDLE;
        return;
    }

    initData.Params = Params;
    initData.pPowerReadyEvent = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (initData.pPowerReadyEvent == NULL) {
        Status = STATUS_NO_MEMORY;
        goto RetCallOut;
    }

    UserAssert(ISCSRSS());

    EnterCrit();
    fRet = InitCreateSystemThreadsMsg(&m, CST_POWER, &initData, 0, FALSE);
    LeaveCrit();

    if (fRet) {
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);

        if (NT_SUCCESS(Status)) {
            KeWaitForSingleObject(initData.pPowerReadyEvent, WrUserRequest,
                    KernelMode, FALSE, NULL);
            Status = ((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status;
        }
    }

RetCallOut:

    if (initData.pPowerReadyEvent) {
        FreeKernelEvent(&initData.pPowerReadyEvent);
    }

    ((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status = Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\profile.c ===
/****************************** Module Header ******************************\
* Module Name: profile.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code to emulate ini file mapping.
*
* History:
* 30-Nov-1993 SanfordS  Created.
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* aFastRegMap[]
*
* This array maps section ids (PMAP_) to cached registry keys and section
* addresses within the registry.  IF INI FILE MAPPING CHANGES ARE MADE,
* THIS TABLE MUST BE UPDATED.
*
* The first character of the szSection field indicates what root the
* section is in. (or locked open status)
*      M = LocalMachine
*      U = CurrentUser
*      L = Locked open - used only on M mappings.
*
* History:
\***************************************************************************/
#define PROOT_CPANEL     0
#define PROOT_ACCESS     1
#define PROOT_CURRENTM   2
#define PROOT_CURRENTU   3
#define PROOT_CONTROL    4
#define PROOT_SERVICES   5
#define PROOT_KEYBOARD   6
#define PROOT_SYSTEM     7

typedef struct tagFASTREGMAP {
    UINT idRoot;
    PCWSTR szSection;
} FASTREGMAP, *PFASTREGMAP;

CONST PCWSTR aFastRegRoot[] = {
    L"UControl Panel\\",                                    // PROOT_CPANEL
    L"UControl Panel\\Accessibility\\",                     // PROOT_ACCESS
    L"MSoftware\\Microsoft\\Windows NT\\CurrentVersion\\",  // PROOT_CURRENTM
    L"USoftware\\Microsoft\\Windows NT\\CurrentVersion\\",  // PROOT_CURRENTU
    L"MSystem\\CurrentControlSet\\Control\\",               // PROOT_CONTROL
    L"MSystem\\CurrentControlSet\\Services\\",              // PROOT_SERVICES
    L"UKeyboard Layout\\",                                  // PROOT_KEYBOARD
    L"MSystem\\",                                           // PROOT_SYSTEM   
};

CONST FASTREGMAP aFastRegMap[PMAP_LAST + 1] = {
    { PROOT_CPANEL,   L"Colors" },                            // PMAP_COLORS
    { PROOT_CPANEL,   L"Cursors" },                           // PMAP_CURSORS
    { PROOT_CURRENTM, L"Windows" },                           // PMAP_WINDOWSM
    { PROOT_CURRENTU, L"Windows" },                           // PMAP_WINDOWSU
    { PROOT_CPANEL,   L"Desktop" },                           // PMAP_DESKTOP
    { PROOT_CPANEL,   L"Icons" },                             // PMAP_ICONS
    { PROOT_CURRENTM, L"Fonts" },                             // PMAP_FONTS
    { PROOT_CURRENTU, L"TrueType" },                          // PMAP_TRUETYPE
    { PROOT_CONTROL,  L"Keyboard Layout" },                   // PMAP_KBDLAYOUT
    { PROOT_SERVICES, L"RIT" },                               // PMAP_INPUT
    { PROOT_CURRENTM, L"Compatibility" },                     // PMAP_COMPAT
    { PROOT_CONTROL,  L"Session Manager\\SubSystems" },       // PMAP_SUBSYSTEMS
    { PROOT_CPANEL,   L"Sound" },                             // PMAP_BEEP
    { PROOT_CPANEL,   L"Mouse" },                             // PMAP_MOUSE
    { PROOT_CPANEL,   L"Keyboard" },                          // PMAP_KEYBOARD
    { PROOT_ACCESS,   L"StickyKeys" },                        // PMAP_STICKYKEYS
    { PROOT_ACCESS,   L"Keyboard Response" },                 // PMAP_KEYBOARDRESPONSE
    { PROOT_ACCESS,   L"MouseKeys" },                         // PMAP_MOUSEKEYS
    { PROOT_ACCESS,   L"ToggleKeys" },                        // PMAP_TOGGLEKEYS
    { PROOT_ACCESS,   L"TimeOut" },                           // PMAP_TIMEOUT
    { PROOT_ACCESS,   L"SoundSentry" },                       // PMAP_SOUNDSENTRY
    { PROOT_ACCESS,   L"ShowSounds" },                        // PMAP_SHOWSOUNDS
    { PROOT_CURRENTM, L"AeDebug" },                           // PMAP_AEDEBUG
    { PROOT_CONTROL,  L"NetworkProvider" },                   // PMAP_NETWORK
    { PROOT_CPANEL,   L"Desktop\\WindowMetrics" },            // PMAP_METRICS
    { PROOT_KEYBOARD, L"" },                                  // PMAP_UKBDLAYOUT
    { PROOT_KEYBOARD, L"Toggle" },                            // PMAP_UKBDLAYOUTTOGGLE
    { PROOT_CURRENTM, L"Winlogon" },                          // PMAP_WINLOGON
    { PROOT_ACCESS,   L"Keyboard Preference" },               // PMAP_KEYBOARDPREF
    { PROOT_ACCESS,   L"Blind Access" },                      // PMAP_SCREENREADER
    { PROOT_ACCESS,   L"HighContrast" },                      // PMAP_HIGHCONTRAST
    { PROOT_CURRENTM, L"IME Compatibility" },                 // PMAP_IMECOMPAT
    { PROOT_CURRENTM, L"IMM" },                               // PMAP_IMM
    { PROOT_CONTROL,  L"Session Manager\\SubSystems\\Pool" }, // PMAP_POOLLIMITS
    { PROOT_CURRENTM, L"Compatibility32" },                   // PMAP_COMPAT32
    { PROOT_CURRENTM, L"WOW\\SetupPrograms" },                // PMAP_SETUPPROGRAMNAMES
    { PROOT_CPANEL,   L"Input Method" },                      // PMAP_INPUTMETHOD
    { PROOT_CURRENTM, L"Compatibility2" },                    // PMAP_COMPAT2
    { PROOT_SERVICES, L"Mouclass\\Parameters" },              // PMAP_MOUCLASS_PARAMS
    { PROOT_SERVICES, L"Kbdclass\\Parameters" },              // PMAP_KBDCLASS_PARAMS
    { PROOT_CONTROL,  L"ComputerName\\ComputerName" },        // PMAP_COMPUTERNAME
    { PROOT_CONTROL,  L"Terminal Server" },                   // PMAP_TS
    { PROOT_SYSTEM,   L"WPA\\TabletPC" },                     // PMAP_TABLETPC
    { PROOT_SYSTEM,   L"WPA\\MediaCenter" },                  // PMAP_MEDIACENTER
    { PROOT_CURRENTM, L"Windows" },                           // PMAP_TS_EXCLUDE_DESKTOP_VERSION
};

WCHAR PreviousUserStringBuf[256];
UNICODE_STRING PreviousUserString = {0, sizeof PreviousUserStringBuf, PreviousUserStringBuf};
LUID luidPrevious;

CONST WCHAR wszDefaultUser[] = L"\\Registry\\User\\.Default";
UNICODE_STRING DefaultUserString = {sizeof wszDefaultUser - sizeof(WCHAR), sizeof wszDefaultUser, (WCHAR *)wszDefaultUser};

void InitPreviousUserString(void) {
    UNICODE_STRING UserString;
    LUID           luidCaller;

    CheckCritIn();

    /*
     * Speed hack, check if luid of this process == system or previous to
     * save work.
     */
    if (NT_SUCCESS(GetProcessLuid(NULL, &luidCaller))) {

        if (RtlEqualLuid(&luidCaller, &luidPrevious)) {
            return;   // same as last time - no work.
        }
        luidPrevious = luidCaller;

        if (RtlEqualLuid(&luidCaller, &luidSystem))
            goto DefaultUser;

    } else {
        luidPrevious = RtlConvertLongToLuid(0);
    }

    /*
     * Set up current user registry base string.
     */
    if (!NT_SUCCESS(RtlFormatCurrentUserKeyPath(&UserString))) {

DefaultUser:

        RtlCopyUnicodeString(&PreviousUserString, &DefaultUserString);

    } else {
        UserAssert(sizeof(PreviousUserStringBuf) >= UserString.Length + 4);
        RtlCopyUnicodeString(&PreviousUserString, &UserString);
        RtlFreeUnicodeString(&UserString);
    }

    RtlAppendUnicodeToString(&PreviousUserString, L"\\");

}

typedef struct tagPROFILEUSERNAME {
    WCHAR awcName[MAXPROFILEBUF];
    UNICODE_STRING NameString;
} PROFILEUSERNAME, *PPROFILEUSERNAME;

PUNICODE_STRING CreateProfileUserName(TL *ptl)
{
    PPROFILEUSERNAME pMapName;

    CheckCritIn();

    pMapName = UserAllocPoolWithQuota(sizeof (PROFILEUSERNAME), TAG_PROFILEUSERNAME);
    if (!pMapName) {
        RIPMSG0(RIP_WARNING, "CreateProfileUserName: Allocation failed");
        return NULL;
    }

    ThreadLockPool(PtiCurrent(), pMapName, ptl);
    pMapName->NameString.Length = 0;
    pMapName->NameString.MaximumLength = sizeof (pMapName->awcName);
    pMapName->NameString.Buffer = pMapName->awcName;

    InitPreviousUserString();

    RtlCopyUnicodeString(&pMapName->NameString, &PreviousUserString);
    return &(pMapName->NameString);
}

void FreeProfileUserName(PUNICODE_STRING pProfileUserName,TL *ptl) {
    UNREFERENCED_PARAMETER(ptl);
    CheckCritIn();
    if (pProfileUserName) {
        ThreadUnlockAndFreePool(PtiCurrent(), ptl);
    }
}


/*****************************************************************************\
* OpenCacheKeyEx
*
* Attempts to open a cached key for a given section.  If we are calling
* for a client thread, we must check the access rights for the key after
* opening it.
*
* Returns fSuccess.
*
* Note -- param 1 can be NULL.  If the section name is a per-user registry
*         section, we ill use the first parameter if available or set up
*         and use the cached one if the first parameter is NULL.
*
* History:
* 03-Dec-1993 SanfordS  Created.
\*****************************************************************************/
HANDLE OpenCacheKeyEx(
    PUNICODE_STRING pMapName OPTIONAL,
    UINT        idSection,
    ACCESS_MASK amRequest,
    PDWORD pdwPolicyFlags
    )
{
    OBJECT_ATTRIBUTES OA;
    WCHAR             UnicodeStringBuf[256];
    WCHAR             pszSessionId[13];
    UNICODE_STRING    UnicodeString;
    LONG              Status;
    HANDLE            hKey = NULL;
    PEPROCESS         peCurrent = PsGetCurrentProcess();
    DWORD             dwPolicyFlags;

    CheckCritIn();

    UserAssert(idSection <= PMAP_LAST);

    /*
     * If we're opening the desktop or CPL\keyboard key for read access, we should be checking
     * for relevant policy.
     */
    if ((amRequest == KEY_READ) && (idSection == PMAP_DESKTOP)) {
        UserAssert(pdwPolicyFlags);
        UserAssert(!(*pdwPolicyFlags & ~POLICY_VALID));
        dwPolicyFlags = *pdwPolicyFlags;
    } else {
        /*
         * if we are here because Policy was changed and there is not POLICY_ flags set then return.
         */
        if (pdwPolicyFlags && (*pdwPolicyFlags & POLICY_ONLY)) {
            *pdwPolicyFlags = 0;
            UserAssert(FALSE);
            return NULL;
        }
        dwPolicyFlags = POLICY_NONE;
    }

TryAgain:

    UnicodeString.Length        = 0;
    UnicodeString.MaximumLength = sizeof(UnicodeStringBuf);
    UnicodeString.Buffer        = UnicodeStringBuf;


    if (dwPolicyFlags & POLICY_MACHINE) {
        dwPolicyFlags &= ~POLICY_MACHINE;
        RtlAppendUnicodeToString(&UnicodeString,
                                 L"\\Registry\\Machine\\");
        RtlAppendUnicodeToString(&UnicodeString,
                                 L"Software\\Policies\\Microsoft\\Windows\\");
    } else {
        if (aFastRegRoot[aFastRegMap[idSection].idRoot][0] == L'M') {
            RtlAppendUnicodeToString(&UnicodeString, L"\\Registry\\Machine\\");
        } else {
            if (!pMapName) {
                InitPreviousUserString();
                RtlAppendUnicodeStringToString(
                    &UnicodeString,
                    &PreviousUserString);
            } else {
                RtlAppendUnicodeStringToString(
                    &UnicodeString,
                    pMapName);
            }
        }
        if (dwPolicyFlags & POLICY_USER) {
            dwPolicyFlags &= ~POLICY_USER;
            RtlAppendUnicodeToString(&UnicodeString,
                                     L"Software\\Policies\\Microsoft\\Windows\\");
        } 
        else if (dwPolicyFlags & POLICY_REMOTE) {
            dwPolicyFlags &= ~POLICY_REMOTE;
            RtlAppendUnicodeToString(&UnicodeString,
                                     L"Remote\\");
            swprintf(pszSessionId, L"%ld\\", gSessionId);
            RtlAppendUnicodeToString(&UnicodeString, pszSessionId);
        } else {
            /*
             * if we are here because Policy was changed then do not try preferences.  
             */
            if (pdwPolicyFlags && (*pdwPolicyFlags & POLICY_ONLY)) {
                *pdwPolicyFlags = 0;
                return NULL;
            }
            dwPolicyFlags &= ~POLICY_NONE;
        }
    }

    RtlAppendUnicodeToString(&UnicodeString,
                             (PWSTR)&aFastRegRoot[aFastRegMap[idSection].idRoot][1]);

    RtlAppendUnicodeToString(&UnicodeString,
                             (PWSTR)aFastRegMap[idSection].szSection);


    /*
     * Open the key for kernel mode access
     */
    InitializeObjectAttributes(&OA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&hKey, amRequest, &OA);

    if (
        (amRequest == KEY_READ)   ||     /*
                                          * We must be able to read
                                          * our registry settings.
                                          */
        (peCurrent == gpepCSRSS)  ||
        (peCurrent == gpepInit)
             ) {

    } else {
        /*
         * Now check if the user has access to the key
         */

        if (NT_SUCCESS(Status)) {
            PVOID pKey;
            NTSTATUS Status2;
            Status2 = ObReferenceObjectByHandle(hKey,
                                        amRequest,
                                        NULL,
                                        KernelMode,
                                        &pKey,
                                        NULL);

            if (NT_SUCCESS(Status2)) {
                if (!AccessCheckObject(pKey, amRequest, UserMode, &KeyMapping)) {
                    ZwClose(hKey);
                    Status = STATUS_ACCESS_DENIED;
                }
                ObDereferenceObject(pKey);
            } else {
                ZwClose(hKey);
                Status = STATUS_ACCESS_DENIED;
            }
        }

    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        UnicodeStringBuf[UnicodeString.Length / 2] = 0;

        if (PsGetCurrentProcessId() != gpidLogon) {
            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                RIPMSG1(RIP_WARNING | RIP_THERESMORE, "OpenCacheKeyEx failed with Status = %lx key:", Status);
                RIPMSG1(RIP_WARNING | RIP_THERESMORE | RIP_NONAME | RIP_NONEWLINE, " %ws\\", UnicodeStringBuf);
            }
        }
    }
#endif

    /*
     * If we didn't succeed and we're not down to bottom of policy chain, try again.
     */
    if (!NT_SUCCESS(Status) && dwPolicyFlags) {
        goto TryAgain;
    }

    /*
     * Update policy level
     */
    if (pdwPolicyFlags) {
        *pdwPolicyFlags = dwPolicyFlags;
    }

    return (NT_SUCCESS(Status) ? hKey : NULL);
}


/*****************************************************************************\
* CheckDesktopPolicy
*
* Check if a desktop value has an associated policy.
*
* Returns TRUE if there is a policy, FALSE otherwise.
*
* History:
* 07-Feb-2000 JerrySh   Created.
\*****************************************************************************/
BOOL CheckDesktopPolicy(
    PUNICODE_STRING pProfileUserName OPTIONAL,
    PCWSTR      lpKeyName
    )
{
    WCHAR          szKey[80];
    HANDLE         hKey;
    DWORD          cbSize;
    NTSTATUS       Status;
    UNICODE_STRING UnicodeString;
    KEY_VALUE_BASIC_INFORMATION  KeyInfo;
    DWORD          dwPolicyFlags = gdwPolicyFlags & (POLICY_MACHINE | POLICY_USER);

    /*
     * If there is no policy or the caller is winlogon, let it go.
     */
    if (!dwPolicyFlags || PsGetCurrentProcessId() == gpidLogon) {
        return FALSE;
    }

    /*
     * Convert the ID to a string if we need to.
     */
    if (!IS_PTR(lpKeyName)) {
        ServerLoadString(hModuleWin, PTR_TO_ID(lpKeyName), szKey, ARRAY_SIZE(szKey));
        lpKeyName = szKey;
    }

TryAgain:

    /*
     * Try to open a key.
     */
    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               PMAP_DESKTOP,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
        return FALSE;
    }

    /*
     * See if the value exists.
     */
    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValueBasicInformation,
                             &KeyInfo,
                             sizeof(KeyInfo),
                             &cbSize);

    ZwClose(hKey);

    if (!NT_ERROR(Status)) {
        return TRUE;
    } else if (dwPolicyFlags) {
        goto TryAgain;
    } else {
        return FALSE;
    }
}


/*****************************************************************************\
* CheckDesktopPolicyChange
*
* Check if policy has changed since last time we checked.
*
* Returns TRUE if policy changed, FASLE otherwise.
*
* History:
* 07-Feb-2000 JerrySh   Created.
\*****************************************************************************/
BOOL CheckDesktopPolicyChange(
    PUNICODE_STRING pProfileUserName OPTIONAL
    )
{
    static LARGE_INTEGER  LastMachineWriteTime;
    static LARGE_INTEGER  LastUserWriteTime;
    KEY_BASIC_INFORMATION KeyInfo;
    BOOL                  bPolicyChanged = FALSE;
    HANDLE                hKey;
    DWORD                 cbSize;
    DWORD                 dwPolicyFlags;

    /*
     * Check if machine policy has changed since last time we checked.
     */
    dwPolicyFlags = POLICY_MACHINE;
    KeyInfo.LastWriteTime.QuadPart = 0;
    hKey = OpenCacheKeyEx(pProfileUserName,
                          PMAP_DESKTOP,
                          KEY_READ,
                          &dwPolicyFlags);
    if (hKey) {
        if (hKey) {
            ZwQueryKey(hKey,
                       KeyValueBasicInformation,
                       &KeyInfo,
                       sizeof(KeyInfo),
                       &cbSize);
            ZwClose(hKey);
        }
        gdwPolicyFlags |= POLICY_MACHINE;
    } else {
        gdwPolicyFlags &= ~POLICY_MACHINE;
    }
    if (LastMachineWriteTime.QuadPart != KeyInfo.LastWriteTime.QuadPart) {
        LastMachineWriteTime.QuadPart = KeyInfo.LastWriteTime.QuadPart;
        bPolicyChanged = TRUE;
    }

    /*
     * Check if user policy has changed since last time we checked.
     */
    dwPolicyFlags = POLICY_USER;
    KeyInfo.LastWriteTime.QuadPart = 0;
    hKey = OpenCacheKeyEx(pProfileUserName,
                          PMAP_DESKTOP,
                          KEY_READ,
                          &dwPolicyFlags);
    if (hKey) {
        ZwQueryKey(hKey,
                   KeyValueBasicInformation,
                   &KeyInfo,
                   sizeof(KeyInfo),
                   &cbSize);
        ZwClose(hKey);
        gdwPolicyFlags |= POLICY_USER;
    } else {
        gdwPolicyFlags &= ~POLICY_USER;
    }
    if (LastUserWriteTime.QuadPart != KeyInfo.LastWriteTime.QuadPart) {
        LastUserWriteTime.QuadPart = KeyInfo.LastWriteTime.QuadPart;
        bPolicyChanged = TRUE;
    }

    return bPolicyChanged;
}


/*****************************************************************************\
* FastGetProfileDwordW
*
* Reads a REG_DWORD type key from the registry.
*
* returns value read or default value on failure.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastGetProfileDwordW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    DWORD   dwDefault,
    PDWORD  pdwReturn,
    DWORD   dwPolicyOnly
    )
{
    HANDLE         hKey;
    DWORD          cbSize;
    DWORD          dwRet;
    LONG           Status;
    UNICODE_STRING UnicodeString;
    BYTE           Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    DWORD          dwPolicyFlags = gdwPolicyFlags | dwPolicyOnly;

    UserAssert(idSection <= PMAP_LAST);

TryAgain:

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
        RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);

        if (dwPolicyOnly & POLICY_ONLY) {
            return FALSE;
        }

        if (pdwReturn) {
            *pdwReturn = dwDefault;
        }
        return TRUE;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
                             sizeof(Buf),
                             &cbSize);

    dwRet = dwDefault;

    if (NT_SUCCESS(Status)) {

        dwRet = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);

    } else if (dwPolicyFlags) {

        ZwClose(hKey);
        goto TryAgain;

    } else if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        RIPMSG1(RIP_WARNING,
                "FastGetProfileDwordW: ObjectName not found: %ws",
                lpKeyName);
    }

    ZwClose(hKey);

    if (pdwReturn) {
        *pdwReturn = dwRet;
    }
    return TRUE;
}

/*****************************************************************************\
* FastGetProfileKeysW()
*
* Reads all key names in the given section.
*
* History:
* 15-Dec-1994 JimA      Created.
\*****************************************************************************/
DWORD FastGetProfileKeysW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpDefault,
    LPWSTR  *lpReturnedString
    )
{
    HANDLE                       hKey;
    DWORD                        cchSize;
    DWORD                        cchKey;
    LONG                         Status;
    WCHAR                        Buffer[256 + 6];
    PKEY_VALUE_BASIC_INFORMATION pKeyInfo;
    ULONG                        iValue;
    LPWSTR                       lpTmp;
    LPWSTR                       lpKeys = NULL;
    DWORD                        dwPoolSize;

    UserAssert(idSection <= PMAP_LAST);

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               NULL)) == NULL) {
        RIPMSG0(RIP_WARNING | RIP_NONAME, "");
        goto DefExit;
    }

    pKeyInfo          = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    cchSize           = 0;
    *lpReturnedString = NULL;
    iValue            = 0;

    while (TRUE) {

#if DBG
        wcscpy(Buffer + 256, L"DON'T");
#endif
        Status = ZwEnumerateValueKey(hKey,
                                     iValue,
                                     KeyValueBasicInformation,
                                     pKeyInfo,
                                     sizeof(Buffer),
                                     &cchKey);

        UserAssert(_wcsicmp(Buffer + 256, L"DON'T") == 0);

        if (Status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(Status)) {

            if (lpKeys) {
                UserFreePool(lpKeys);
                lpKeys = NULL;
            }
            goto DefExit;
        }

        UserAssert(pKeyInfo->NameLength * sizeof(WCHAR) <=
                   sizeof(Buffer) - sizeof(KEY_VALUE_BASIC_INFORMATION));

        UserAssert(cchKey <= sizeof(Buffer));

        /*
         * A key was found.  Allocate space for it.  Note that
         * NameLength is in bytes.
         */
        cchKey   = cchSize;
        cchSize += pKeyInfo->NameLength + sizeof(WCHAR);

        if (lpKeys == NULL) {

            dwPoolSize = cchSize + sizeof(WCHAR);
            lpKeys = UserAllocPoolWithQuota(dwPoolSize, TAG_PROFILE);

        } else {

            lpTmp = lpKeys;
            lpKeys = UserReAllocPoolWithQuota(lpTmp,
                                              dwPoolSize,
                                              cchSize + sizeof(WCHAR),
                                              TAG_PROFILE);

            /*
             * Free the original buffer if the allocation fails
             */
            if (lpKeys == NULL) {
                UserFreePool(lpTmp);
            }
            dwPoolSize = cchSize + sizeof(WCHAR);
        }

        /*
         * Check for out of memory.
         */
        if (lpKeys == NULL)
            goto DefExit;

        /*
         * NULL terminate the string and append it to
         * the key list.
         */
        UserAssert(pKeyInfo->NameLength < sizeof(Buffer) - sizeof(KEY_VALUE_BASIC_INFORMATION));

        RtlCopyMemory(&lpKeys[cchKey / sizeof(WCHAR)], pKeyInfo->Name, pKeyInfo->NameLength);
        lpKeys[(cchKey + pKeyInfo->NameLength) / sizeof(WCHAR)] = 0;

        iValue++;
    }

    /*
     * If no keys were found, return the default.
     */
    if (iValue == 0) {

DefExit:

        cchSize = wcslen(lpDefault)+1;
        lpKeys  = UserAllocPoolWithQuota((cchSize+1) * sizeof(WCHAR), TAG_PROFILE);

        if (lpKeys)
            wcscpy(lpKeys, lpDefault);
        else
            cchSize = 0;

    } else {

        /*
         * Turn the byte count into a char count.
         */
        cchSize /= sizeof(WCHAR);
    }

    /*
     * Make sure hKey is closed.
     */
    if (hKey)
        ZwClose(hKey);

    /*
     * Append the ending NULL.
     */
    if (lpKeys)
        lpKeys[cchSize] = 0;

    *lpReturnedString = lpKeys;

    return cchSize;
}

/*****************************************************************************\
* FastGetProfileStringW()
*
* Implements a fast version of the standard API using predefined registry
* section indecies (PMAP_) that reference lazy-opened, cached registry
* handles.  FastCloseProfileUserMapping() should be called to clean up
* cached entries when fast profile calls are completed.
*
* This api does NOT implement the NULL lpKeyName feature of the real API.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
DWORD FastGetProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   cchBuf,
    DWORD   dwPolicyOnly
    )
{
    HANDLE                         hKey = NULL;
    DWORD                          cbSize;
    LONG                           Status;
    UNICODE_STRING                 UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    DWORD                          dwPolicyFlags = gdwPolicyFlags | dwPolicyOnly;


    UserAssert(idSection <= PMAP_LAST);
    UserAssert(lpKeyName != NULL);

TryAgain:

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
#if DBG
        if (PsGetCurrentProcessId() != gpidLogon) {
            RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);
        }
#endif
        if (dwPolicyOnly & POLICY_ONLY) {
            return 0;
        }
        goto DefExit;
    }

    cbSize = (cchBuf * sizeof(WCHAR)) +
            FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
    if ((pKeyInfo = UserAllocPoolWithQuota(cbSize, TAG_PROFILE)) == NULL) {
        goto DefExit;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             pKeyInfo,
                             cbSize,
                             &cbSize);

    if (Status == STATUS_BUFFER_OVERFLOW) {
        RIPMSG0(RIP_WARNING, "FastGetProfileStringW: Buffer overflow");
        Status = STATUS_SUCCESS;
    }

    UserAssert(NT_SUCCESS(Status) || (Status == STATUS_OBJECT_NAME_NOT_FOUND));

    if (NT_SUCCESS(Status)) {

        if (pKeyInfo->DataLength >= sizeof(WCHAR)) {

            ((LPWSTR)(pKeyInfo->Data))[cchBuf - 1] = L'\0';
            wcscpy(lpReturnedString, (LPWSTR)pKeyInfo->Data);

        } else {
            /*
             * Appears to be a bug with empty strings - only first
             * byte is set to NULL. (SAS)
             */
            lpReturnedString[0] = TEXT('\0');
        }

        cchBuf = pKeyInfo->DataLength;

        UserFreePool(pKeyInfo);

        ZwClose(hKey);

        /*
         * data length includes terminating zero [bodind]
         */
        return (cchBuf / sizeof(WCHAR));

    } else if (dwPolicyFlags) {
        UserFreePool(pKeyInfo);
        ZwClose(hKey);
        goto TryAgain;
    }

    UserFreePool(pKeyInfo);

DefExit:

    /*
     * Make sure the key is closed.
     */
    if (hKey)
        ZwClose(hKey);

    /*
     * wcscopy copies terminating zero, but the length returned by
     * wcslen does not, so add 1 to be consistent with success
     * return [bodind]
     */
    if (lpDefault != NULL) {
        cchBuf = wcslen(lpDefault) + 1;
        RtlCopyMemory(lpReturnedString, lpDefault, cchBuf * sizeof(WCHAR));
        return cchBuf;
    }

    return 0;
}

/*****************************************************************************\
* FastGetProfileIntW()
*
* Implements a fast version of the standard API using predefined registry
* section indecies (PMAP_) that reference lazy-opened, cached registry
* handles.  FastCloseProfileUserMapping() should be called to clean up
* cached entries when fast profile calls are completed.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastGetProfileIntW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    UINT    nDefault,
    PUINT   puiReturn,
    DWORD   dwPolicyOnly
    )
{
    WCHAR          ValueBuf[40];
    UNICODE_STRING Value;
    UINT           ReturnValue;

    UserAssert(idSection <= PMAP_LAST);
    UserAssert(puiReturn);

    if (!FastGetProfileStringW(pProfileUserName,
                               idSection,
                               lpKeyName,
                               NULL,
                               ValueBuf,
                               sizeof(ValueBuf) / sizeof(WCHAR),
                               dwPolicyOnly
                               )) {
        if (dwPolicyOnly & POLICY_ONLY) {
            return FALSE;
        }

        *puiReturn = nDefault; 
        return TRUE;
    }

    /*
     * Convert string to int.
     */
    RtlInitUnicodeString(&Value, ValueBuf);
    RtlUnicodeStringToInteger(&Value, 10, &ReturnValue);

    *puiReturn = ReturnValue; 
    return TRUE;
}

/*****************************************************************************\
* FastWriteProfileStringW
*
* Implements a fast version of the standard API using predefined registry
* section indecies (PMAP_) that reference lazy-opened, cached registry
* handles.  FastCloseProfileUserMapping() should be called to clean up
* cached entries when fast profile calls are completed.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastWriteProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    )
{
    HANDLE         hKey;
    LONG           Status;
    UNICODE_STRING UnicodeString;

    UserAssert(idSection <= PMAP_LAST);

    /*
     * We shouldn't be writing values that are controlled by policy.
     */
    if (idSection == PMAP_DESKTOP) {
        UserAssert(!CheckDesktopPolicy(pProfileUserName, lpKeyName));
    }

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_WRITE,
                               NULL)) == NULL) {
        RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);
        return FALSE;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwSetValueKey(hKey,
                           &UnicodeString,
                           0,
                           REG_SZ,
                           (PVOID)lpString,
                           (wcslen(lpString) + 1) * sizeof(WCHAR));

    ZwClose(hKey);

    return (NT_SUCCESS(Status));
}

/*****************************************************************************\
* FastGetProfileIntFromID
*
* Just like FastGetProfileIntW except it reads the USER string table for the
* key name.
*
* History:
* 02-Dec-1993 SanfordS  Created.
* 25-Feb-1995 BradG     Added TWIPS -> Pixel conversion.
\*****************************************************************************/
BOOL FastGetProfileIntFromID(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT  idSection,
    UINT  idKey,
    int   def,
    PINT  pResult,
    DWORD dwPolicyOnly
    )
{
    int   result;
    WCHAR szKey[80];


    UserAssert(idSection <= PMAP_LAST);

    ServerLoadString(hModuleWin, idKey, szKey, ARRAY_SIZE(szKey));

    if (FastGetProfileIntW(pProfileUserName,idSection, szKey, def, &result, dwPolicyOnly)) 
    {
        /*
         * If you change the below list of STR_* make sure you make a
         * corresponding change in SetWindowMetricInt (rare.c)
         */
        switch (idKey) {
        case STR_BORDERWIDTH:
        case STR_SCROLLWIDTH:
        case STR_SCROLLHEIGHT:
        case STR_CAPTIONWIDTH:
        case STR_CAPTIONHEIGHT:
        case STR_SMCAPTIONWIDTH:
        case STR_SMCAPTIONHEIGHT:
        case STR_MENUWIDTH:
        case STR_MENUHEIGHT:
        case STR_ICONHORZSPACING:
        case STR_ICONVERTSPACING:
        case STR_MINWIDTH:
        case STR_MINHORZGAP:
        case STR_MINVERTGAP:
            /*
             * Convert any registry values stored in TWIPS back to pixels
             */
            if (result < 0)
                result = MultDiv(-result, gpsi->dmLogPixels, 72 * 20);
            break;
        }

        if (pResult) {
            *pResult = result;
        }
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************\
* FastGetProfileIntFromID
*
* Just like FastGetProfileStringW except it reads the USER string table for
* the key name.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
DWORD FastGetProfileStringFromIDW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    UINT    idKey,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   cch,
    DWORD   dwPolicyOnly
    )
{
    WCHAR szKey[80];

    UserAssert(idSection <= PMAP_LAST);

    ServerLoadString(hModuleWin, idKey, szKey, ARRAY_SIZE(szKey));

    return FastGetProfileStringW(pProfileUserName,
                                 idSection,
                                 szKey,
                                 lpDefault,
                                 lpReturnedString,
                                 cch,
                                 dwPolicyOnly);
}

/*****************************************************************************\
* FastWriteProfileValue
*
* History:
* 06/10/96 GerardoB Renamed and added uType parameter
\*****************************************************************************/
BOOL FastWriteProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    UINT    uType,
    LPBYTE  lpStruct,
    UINT    cbSizeStruct
    )
{
    HANDLE         hKey;
    LONG           Status;
    UNICODE_STRING UnicodeString;
    WCHAR          szKey[SERVERSTRINGMAXSIZE];

    UserAssert(idSection <= PMAP_LAST);

    if (!IS_PTR(lpKeyName)) {
        *szKey = (WCHAR)0;
        ServerLoadString(hModuleWin, PTR_TO_ID(lpKeyName), szKey, ARRAY_SIZE(szKey));
        UserAssert(*szKey != (WCHAR)0);
        lpKeyName = szKey;
    }

    /*
     * We shouldn't be writing values that are controlled by policy.
     */
    if (idSection == PMAP_DESKTOP) {
        UserAssert(!CheckDesktopPolicy(pProfileUserName, lpKeyName));
    }

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_WRITE,
                               NULL)) == NULL) {
        RIPMSG1(RIP_WARNING, "FastWriteProfileValue: Failed to open cache-key (%ws)", lpKeyName);
        return FALSE;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);

    Status = ZwSetValueKey(hKey,
                           &UnicodeString,
                           0,
                           uType,
                           lpStruct,
                           cbSizeStruct);
    ZwClose(hKey);

#if DBG
    if (!NT_SUCCESS(Status)) {
        RIPMSG3 (RIP_WARNING, "FastWriteProfileValue: ZwSetValueKey Failed. Status:%#lx idSection:%#lx KeyName:%s",
                 Status, idSection, UnicodeString.Buffer);
    }
#endif

    return (NT_SUCCESS(Status));
}

/*****************************************************************************\
* FastGetProfileValue
*
* If cbSizeReturn is 0, just return the size of the data
*
* History:
* 06/10/96 GerardoB Renamed
\*****************************************************************************/
DWORD FastGetProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    LPBYTE  lpDefault,
    LPBYTE  lpReturn,
    UINT    cbSizeReturn,
    DWORD   dwPolicyOnly
    )
{
    HANDLE                         hKey;
    UINT                           cbSize;
    LONG                           Status;
    UNICODE_STRING                 UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    WCHAR                          szKey[SERVERSTRINGMAXSIZE];
    KEY_VALUE_PARTIAL_INFORMATION  KeyInfo;
    DWORD                          dwPolicyFlags = gdwPolicyFlags | dwPolicyOnly;

    UserAssert(idSection <= PMAP_LAST);

    if (!IS_PTR(lpKeyName)) {
        *szKey = (WCHAR)0;
        ServerLoadString(hModuleWin, PTR_TO_ID(lpKeyName), szKey, ARRAY_SIZE(szKey));
        UserAssert(*szKey != (WCHAR)0);
        lpKeyName = szKey;
    }

TryAgain:

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
        // if hi-word of lpKeName is 0, it is a resource number not a string
        if (!IS_PTR(lpKeyName))
            RIPMSG1(RIP_WARNING, "FastGetProfileValue: Failed to open cache-key (%08x)", lpKeyName);
        else
            RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);

        if (dwPolicyOnly & POLICY_ONLY) {
            return 0;
        }
        goto DefExit;
    }

    if (cbSizeReturn == 0) {
        cbSize = sizeof(KeyInfo);
        pKeyInfo = &KeyInfo;
    } else {
        cbSize = cbSizeReturn + FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
        if ((pKeyInfo = UserAllocPoolWithQuota(cbSize, TAG_PROFILE)) == NULL) {
            goto DefExit;
        }
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);

    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             pKeyInfo,
                             cbSize,
                             &cbSize);

    if (NT_SUCCESS(Status)) {

        UserAssert(cbSizeReturn >= pKeyInfo->DataLength);

        cbSize = pKeyInfo->DataLength;
        RtlCopyMemory(lpReturn, pKeyInfo->Data, cbSize);

        if (cbSizeReturn != 0) {
            UserFreePool(pKeyInfo);
        }
        ZwClose(hKey);

        return cbSize;
    } else if ((Status == STATUS_BUFFER_OVERFLOW) && (cbSizeReturn == 0)) {
        ZwClose(hKey);
        return pKeyInfo->DataLength;
    } else if (dwPolicyFlags) {
        if (cbSizeReturn != 0) {
            UserFreePool(pKeyInfo);
        }
        ZwClose(hKey);
        goto TryAgain;
    }

#if DBG
    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        RIPMSG3 (RIP_WARNING, "FastGetProfileValue: ZwQueryValueKey Failed. Status:%#lx idSection:%#lx KeyName:%s",
                Status, idSection, UnicodeString.Buffer);
    }
#endif

    if (cbSizeReturn != 0) {
        UserFreePool(pKeyInfo);
    }

DefExit:

    if (hKey)
        ZwClose(hKey);

    if (lpDefault) {
        RtlMoveMemory(lpReturn, lpDefault, cbSizeReturn);
        return cbSizeReturn;
    }

    return 0;
}

/*****************************************************************************\
* UT_FastGetProfileIntsW
*
* Repeatedly calls FastGetProfileIntW on the given table.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastGetProfileIntsW(PUNICODE_STRING pProfileUserName OPTIONAL,
    PPROFINTINFO ppii,
    DWORD        dwPolicyOnly
    )
{
    WCHAR szKey[40];

    while (ppii->idSection != 0) {

        ServerLoadString(hModuleWin,
                             PTR_TO_ID(ppii->lpKeyName),
                             szKey,
                             ARRAY_SIZE(szKey));

        FastGetProfileIntW(pProfileUserName,
                           ppii->idSection,
                           szKey,
                           ppii->nDefault,
                           ppii->puResult,
                           dwPolicyOnly);
        ppii++;
    }

    return TRUE;
}

/***************************************************************************\
* UpdateWinIni
*
* Handles impersonation stuff and writes the given value to the registry.
*
* History:
* 28-Jun-1991 MikeHar       Ported.
* 03-Dec-1993 SanfordS      Used FastProfile calls, moved to profile.c
\***************************************************************************/
BOOL FastUpdateWinIni(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT         idSection,
    UINT         wKeyNameId,
    LPWSTR       lpszValue
    )
{
    WCHAR            szKeyName[40];
    BOOL             bResult = FALSE;

    UserAssert(idSection <= PMAP_LAST);

    ServerLoadString(hModuleWin,
                         wKeyNameId,
                         szKeyName,
                         ARRAY_SIZE(szKeyName));

    bResult = FastWriteProfileStringW(pProfileUserName,
                                          idSection, szKeyName, lpszValue);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\queue.c ===
/****************************** Module Header ******************************\
* Module Name: queue.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the low-level code for working with the Q structure.
*
* History:
* 12-02-90 DavidPe      Created.
* 02-06-91 IanJa        HWND revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID DestroyProcessesObjects(PPROCESSINFO ppi);
VOID DestroyThreadsMessages(PQ pq, PTHREADINFO pti);
NTSTATUS CheckProcessForeground(PTHREADINFO pti);
DWORD xxxPollAndWaitForSingleObject(PKEVENT pEvent, PVOID pExecObject,
                                    DWORD dwMilliseconds);

NTSTATUS InitiateShutdown(PETHREAD Thread, PULONG lpdwFlags);
NTSTATUS EndShutdown(PETHREAD Thread, NTSTATUS StatusShutdown);
VOID SetVDMCursorBounds(LPRECT lprc);
NTSTATUS InitQEntryLookaside(VOID);
VOID SetAppStarting(PPROCESSINFO ppi);

#if defined(_WIN64)
/*
 * For Win64 ask winlogon to play sounds for accessibility events
 * (IA64 machines do not have internal speakers so we have to go
 * thru the sound card).  Post a message to winlogon with an lParam
 * whose high word is ACCESS_SOUND_RANGE and low word is the index
 * of the sound to make.  If a new RITSOUND_xx macro is added then
 * winlogon has to be updated too.
 */
#define ACCESS_SOUND_RANGE 1
#endif

#pragma alloc_text(INIT, InitQEntryLookaside)

PW32PROCESS gpwpCalcFirst;

PPAGED_LOOKASIDE_LIST QLookaside;
PPAGED_LOOKASIDE_LIST QEntryLookaside;

#if DBG
VOID DebugValidateMLIST(
    PMLIST pml)
{
    int     c;
    PQMSG   pqmsg;

    /*
     * Check that the message list is properly terminated.
     */
    UserAssert(!pml->pqmsgRead || !pml->pqmsgRead->pqmsgPrev);
    UserAssert(!pml->pqmsgWriteLast || !pml->pqmsgWriteLast->pqmsgNext);

    /*
     * Check that there aren't loops in the Next list.
     */
    c = pml->cMsgs;
    UserAssert(c >= 0);
    pqmsg = pml->pqmsgRead;
    while (--c >= 0) {
        UserAssert(pqmsg);
        if (c == 0) {
            UserAssert(pqmsg == pml->pqmsgWriteLast);
        }

        pqmsg = pqmsg->pqmsgNext;
    }

    UserAssert(!pqmsg);

    /*
     * Check that there aren't loops in the Prev list.
     */
    c = pml->cMsgs;
    pqmsg = pml->pqmsgWriteLast;
    while (--c >= 0) {
        UserAssert(pqmsg);
        if (c == 0) {
            UserAssert(pqmsg == pml->pqmsgRead);
        }

        pqmsg = pqmsg->pqmsgPrev;
    }

    UserAssert(!pqmsg);
}

VOID DebugValidateMLISTandQMSG(
    PMLIST pml,
    PQMSG pqmsg)
{
    PQMSG pqmsgT;

    DebugValidateMLIST(pml);
    for (pqmsgT = pml->pqmsgRead; pqmsgT; pqmsgT = pqmsgT->pqmsgNext) {
        if (pqmsgT == pqmsg) {
            return;
        }
    }

    UserAssert(pqmsgT == pqmsg);
}

#else
#define DebugValidateMLIST(pml)
#define DebugValidateMLISTandQMSG(pml, pqmsg)
#endif

VOID
_AllowForegroundActivation(
    VOID)
{
    SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
    TAGMSG0(DBGTAG_FOREGROUND, "AllowSetForegroundWindows set PUDF.");
}

/***************************************************************************\
* xxxSetProcessInitState
*
* Set process initialization state. What state is set depends
* on whether another process is waiting on this process.
*
* 04-02-95 JimA         Created.
\***************************************************************************/
BOOL xxxSetProcessInitState(
    PEPROCESS Process,
    DWORD dwFlags)
{
    PW32PROCESS W32Process;
    NTSTATUS Status;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If the W32Process structure has not been allocated, do it now.
     */
    W32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
    if (W32Process == NULL) {
        Status = AllocateW32Process(Process);
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
        W32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
#if DBG
        /*
         * The above AllocateW32Process(Process, FALSE) won't set the
         * W32PF_PROCESSCONNECTED flag (and if it wasn't previously set),
         * make sure we're not on the gppiStarting list, because if we are,
         * we will not be removed without the W32PF_PROCESSCONNECTED bit.
         */
        if ((W32Process->W32PF_Flags & W32PF_PROCESSCONNECTED) == 0) {
            UserAssert((W32Process->W32PF_Flags & W32PF_APPSTARTING) == 0);
        }
#endif
    }

    /*
     * Defer WinEvent notifications, because the thread isn't initialized yet.
     */
    DeferWinEventNotify();
    if (dwFlags == 0) {
        if (!(W32Process->W32PF_Flags & W32PF_WOW)) {

            /*
             * Check to see if the startglass is on, and if so turn it off and update.
             */
            if (W32Process->W32PF_Flags & W32PF_STARTGLASS) {
                W32Process->W32PF_Flags &= ~W32PF_STARTGLASS;
                zzzCalcStartCursorHide(NULL, 0);
            }

            /*
             * Found it. Set the console bit and reset the wait event so any sleepers
             * wake up.
             */
            W32Process->W32PF_Flags |= W32PF_CONSOLEAPPLICATION;
            SET_PSEUDO_EVENT(&W32Process->InputIdleEvent);
        }
    } else if (!(W32Process->W32PF_Flags & W32PF_INITIALIZED)) {
        W32Process->W32PF_Flags |= W32PF_INITIALIZED;

        /*
         * Set global state to allow the new process to become
         * foreground. xxxInitProcessInfo() will set
         * W32PF_ALLOWFOREGROUNDACTIVATE when the process initializes.
         */
        SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
        TAGMSG1(DBGTAG_FOREGROUND, "xxxSetProcessInitState set PUDF. %#p", W32Process);


        /*
         * If this is the win32 server process, force off start glass feedback
         */
        if (Process == gpepCSRSS) {
            dwFlags |= STARTF_FORCEOFFFEEDBACK;
        }

        /*
         * Show the app start cursor for 2 seconds if it was requested from
         * the application.
         */
        if (dwFlags & STARTF_FORCEOFFFEEDBACK) {
            W32Process->W32PF_Flags |= W32PF_FORCEOFFFEEDBACK;
            zzzCalcStartCursorHide(NULL, 0);
        } else if (dwFlags & STARTF_FORCEONFEEDBACK) {
            zzzCalcStartCursorHide(W32Process, 2000);
        }
    }
    /*
     * Have to defer without processing, because we don't have a ptiCurrent yet
     */
    EndDeferWinEventNotifyWithoutProcessing();
    return TRUE;
}

/***************************************************************************\
* CheckAllowForeground
*
* Bug 273518 - joejo
*
* Removed this loop from xxxInitProcessInfo to allow code shareing between
* that function and xxxUserNotifyConsoleApplication. This will allow console
* windows to set foreground correctly on new process' it launches, as opposed
* it just forcing foreground.
\***************************************************************************/
BOOL CheckAllowForeground(
    PEPROCESS pep)
{
    BOOL fCreator = TRUE;
    HANDLE hpid = PsGetProcessInheritedFromUniqueProcessId(pep);
    LUID luid;
    PACCESS_TOKEN pat;
    PEPROCESS pepParent;
    PPROCESSINFO ppiParent;
    UINT uAncestors = 0;
    BOOL fAllowForeground = FALSE;
    NTSTATUS Status;

    do {
        /*
         * Get the ppi for the parent process.
         */
        Status = LockProcessByClientId(hpid, &pepParent);
        if (!NT_SUCCESS(Status)) {
            /*
             * Bug 294193 - joejo
             *
             * If this is a process that was created after it'a creator was
             * destroyed, then lets attempt to give it foreground. This is a
             * typical scenario when a stub exe trys to create another process
             * in it's place.
             */
CheckForegroundActivateRight:
            if (HasForegroundActivateRight(PsGetProcessInheritedFromUniqueProcessId(pep))) {
                fAllowForeground = TRUE;
            }
            break;
        }

        ppiParent = PpiFromProcess(pepParent);
        if (ppiParent == NULL) {
            UnlockProcess(pepParent);
            goto CheckForegroundActivateRight;
        }
        /*
         * If we're walking the parent chain,
         * stop when we get to the shell or to a process that
         * is not running on the IO winsta
         */
        if (!fCreator
                && (IsShellProcess(ppiParent)
                    || ((ppiParent->rpwinsta != NULL)
                        && (ppiParent->rpwinsta->dwWSF_Flags & WSF_NOIO)))) {

            UnlockProcess(pepParent);
            break;
        }
        fAllowForeground = CanForceForeground(ppiParent FG_HOOKLOCK_PARAM(NULL));
        if (!fAllowForeground) {
            /*
             * Bug 285639 - joejo
             *
             * If the first thread of the parent process has allow set foreground
             * than we allow the setting of the foreground.
             */
            if (ppiParent->ptiList != NULL
                && (ppiParent->ptiList->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE)) {
                    fAllowForeground = TRUE;
            }

            if (!fAllowForeground) {
                /*
                 * Let's try an ancestor (this might be a worker process).
                 */
                hpid = PsGetProcessInheritedFromUniqueProcessId(pepParent);
                /*
                 * If this is launched by a system process, let it come to
                 *  the foreground (i.e. CSRSS launching an OLE server).
                 */
                if (fCreator) {
                    fCreator = FALSE;
                    pat = PsReferencePrimaryToken(pepParent);
                    if (pat != NULL) {
                        Status = SeQueryAuthenticationIdToken(pat, &luid);
                        if (NT_SUCCESS(Status)) {
                            fAllowForeground = RtlEqualLuid(&luid, &luidSystem);
                            /*
                             * If it is a system process, give it the
                             *  permanent right so we won't have to check
                             *  its luid again
                             */
                             if (fAllowForeground) {
                                 ppiParent->W32PF_Flags |= W32PF_ALLOWSETFOREGROUND;
                             }
                        }
                        ObDereferenceObject(pat);
                    }
                }
            }
        }
        UnlockProcess(pepParent);
      /*
       * InheritedFromUniqueProcessId cannot be quite trusted because
       *  process ids get reused very often. So we just check few levels up
       */
    } while (!fAllowForeground && (uAncestors++ < 5));

    return  fAllowForeground || GiveUpForeground();
}

/***************************************************************************\
* xxxUserNotifyConsoleApplication
*
* This is called by the console init code - it tells us that the starting
* application is a console application. We want to know this for various
* reasons, one being that WinExec() doesn't wait on a starting console
* application.
*
* 09-18-91 ScottLu      Created.
* 01-12-99 JoeJo        Bug 273518
\***************************************************************************/
VOID xxxUserNotifyConsoleApplication(
    PCONSOLE_PROCESS_INFO pcpi)
{
    NTSTATUS  Status;
    PEPROCESS Process;
    BOOL retval;

    /*
     * First search for this process in our process information list.
     */

    Status = LockProcessByClientId(LongToHandle(pcpi->dwProcessID), &Process);


    if (!NT_SUCCESS(Status)) {
        RIPMSGF2(RIP_WARNING,
                 "Failed with Process ID == 0x%x, Status = 0x%x",
                 pcpi->dwProcessID,
                 Status);
        return;
    }

    retval = xxxSetProcessInitState(Process, 0);
    /*
     * Bug 273518 - joejo
     *
     * This will allow console windows to set foreground correctly on new
     * process' it launches, as opposed it just forcing foreground.
     */
    if (retval) {
        if (pcpi->dwFlags & CPI_NEWPROCESSWINDOW) {
            PPROCESSINFO ppiCurrent = PpiCurrent();
            if (CheckAllowForeground(Process)) {
                if (!(ppiCurrent->W32PF_Flags & W32PF_APPSTARTING)) {
                    SetAppStarting(ppiCurrent);
                }
                SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
                TAGMSG0(DBGTAG_FOREGROUND, "xxxUserNotifyConsoleApplication set PUDF");
                ppiCurrent->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
            }

            TAGMSG3(DBGTAG_FOREGROUND, "xxxUserNotifyConsoleApplication %s W32PF %#p-%#p",
                    ((ppiCurrent->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE) ? "set" : "NOT"),
                    ppiCurrent, PpiFromProcess(Process));
        }
    } else {
        RIPMSG1(RIP_WARNING, "xxxUserNotifyConsoleApplication - SetProcessInitState failed on %#p", Process);
    }

    UnlockProcess(Process);
}


/***************************************************************************\
* UserSetConsoleProcessWindowStation
*
* This is called by the console init code - it tells us that the starting
* application is a console application and which window station they are
* associated with. The window station pointer is stored in the EPROCESS for
* the Global atom calls to find the correct global atom table when called from
* a console application
*
\***************************************************************************/
VOID UserSetConsoleProcessWindowStation(
    DWORD idProcess,
    HWINSTA hwinsta)
{
    NTSTATUS  Status;
    PEPROCESS Process;

    /*
     * First search for this process in our process information list.
     */

    Status = LockProcessByClientId(LongToHandle(idProcess), &Process);


    if (!NT_SUCCESS(Status)) {
        RIPMSGF2(RIP_WARNING, "Failed with Process ID == 0x%x, Status = 0x%x",
                 idProcess,
                 Status);
        return;
    }

    PsSetProcessWindowStation(Process, hwinsta);

    UnlockProcess(Process);
}


/***************************************************************************\
* xxxUserNotifyProcessCreate
*
* This is a special notification that we get from the base while process data
* structures are being created, but before the process has started. We use
* this notification for startup synchronization matters (winexec, startup
* activation, type ahead, etc).
*
* This notification is called on the server thread for the client thread
* starting the process.
*
* 09-09-91 ScottLu      Created.
\***************************************************************************/

BOOL xxxUserNotifyProcessCreate(
    DWORD idProcess,
    DWORD idParentThread,
    ULONG_PTR dwData,
    DWORD dwFlags)
{
    PEPROCESS Process;
    PETHREAD Thread;
    PTHREADINFO pti;
    NTSTATUS Status;
    BOOL retval;

    CheckCritIn();


    GiveForegroundActivateRight(LongToHandle(idProcess));

    /*
     * 0x1 bit means give feedback (app start cursor).
     * 0x2 bit means this is a gui app (meaning, call CreateProcessInfo()
     *     so we get app start synchronization (WaitForInputIdle()).
     * 0x8 bit means this process is a WOW process, set W32PF_WOW. 0x1
     *     and 0x2 bits will also be set.
     * 0x4 value means this is really a shared WOW task starting
     */

    /*
     * If we want feedback, we need to create a process info structure,
     * so do it: it will be properly cleaned up.
     */
    if ((dwFlags & 0xb) != 0) {
        Status = LockProcessByClientId(LongToHandle(idProcess), &Process);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                     "Failed with Process ID == 0x%x, Status = 0x%x",
                     idProcess,
                     Status);
            return FALSE;
        }

        retval = xxxSetProcessInitState(Process, ((dwFlags & 1) ? STARTF_FORCEONFEEDBACK : STARTF_FORCEOFFFEEDBACK));
        if (!retval) {
            RIPMSG1(RIP_WARNING, "xxxUserNotifyProcessCreate - SetProcessInitState failed on %#p", Process);
        }
        if (dwFlags & 0x8) {
            PPROCESSINFO ppi;
            ppi = PsGetProcessWin32Process(Process);
            if (ppi != NULL)
                ppi->W32PF_Flags |= W32PF_WOW;
        }

        UnlockProcess(Process);

        /*
         * Find out who is starting this app. If it is a 16 bit app, allow
         * it to bring itself back to the foreground if it calls
         * SetActiveWindow() or SetFocus(). This is because this could be
         * related to OLE to DDE activation. Notes has a case where after it
         * lauches pbrush to edit an embedded bitmap, it brings up a message
         * box on top if the bitmap is read only. This message box won't appear
         * foreground unless we allow it to. This usually isn't a problem
         * because most apps don't bring up windows on top of editors
         * like this. 32 bit apps will call SetForegroundWindow().
         */
        Status = LockThreadByClientId(LongToHandle(idParentThread), &Thread);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                     "Failed with Thread ID == 0x%x, Status = 0x%x",
                     idParentThread,
                     Status);
            return FALSE;
        }

        pti = PtiFromThread(Thread);
        if (pti && (pti->TIF_flags & TIF_16BIT)) {
            pti->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND,
                    "xxxUserNotifyProcessCreate set TIF on pti 0x%p",
                    pti);
        }

        UnlockThread(Thread);
    } else if (dwFlags == 4) {
        /*
         * A WOW task is starting up. Create the WOW per thread info
         * structure here in case someone calls WaitForInputIdle
         * before the thread is created.
         */
        PWOWTHREADINFO pwti;

        /*
         * Look for a matching thread in the WOW thread info list.
         */
        for (pwti = gpwtiFirst; pwti != NULL; pwti = pwti->pwtiNext) {
            if (pwti->idTask == idProcess) {
                break;
            }
        }

        /*
         * If we didn't find one, allocate a new one and add it to
         * the head of the list.
         */
        if (pwti == NULL) {
            pwti = (PWOWTHREADINFO)UserAllocPoolWithQuota(
                    sizeof(WOWTHREADINFO), TAG_WOWTHREADINFO);
            if (pwti == NULL) {
                return FALSE;
            }
            INIT_PSEUDO_EVENT(&pwti->pIdleEvent);
            pwti->idTask = idProcess;
            pwti->pwtiNext = gpwtiFirst;
            gpwtiFirst = pwti;
        } else {
            RESET_PSEUDO_EVENT(&pwti->pIdleEvent);
        }

        pwti->idWaitObject = dwData;

        Status = LockThreadByClientId(LongToHandle(idParentThread), &Thread);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                     "Failed with Thread ID == 0x%x, Status = 0x%x",
                     idParentThread,
                     Status);
            return FALSE;
        }

        pwti->idParentProcess = HandleToUlong(PsGetThreadProcessId(Thread));
        UnlockThread(Thread);
    }

    return TRUE;
}


/***************************************************************************\
* zzzCalcStartCursorHide
*
* Calculates when to hide the startup cursor.
*
* 05-14-92 ScottLu      Created.
\***************************************************************************/
VOID zzzCalcStartCursorHide(
    PW32PROCESS pwp,
    DWORD timeAdd)
{
    DWORD timeNow = NtGetTickCount();
    PW32PROCESS pwpT;
    PW32PROCESS *ppwpT;

    if (pwp != NULL) {
        /*
         * We were passed in a timeout. Recalculate when we timeout and add
         * the pwp to the starting list.
         */
        if (!(pwp->W32PF_Flags & W32PF_STARTGLASS)) {
            /*
             * Add it to the list only if it is not already in the list.
             */
            for (pwpT = gpwpCalcFirst; pwpT != NULL; pwpT = pwpT->NextStart) {
                if (pwpT == pwp) {
                    break;
                }
            }

            if (pwpT != pwp) {
                pwp->NextStart = gpwpCalcFirst;
                gpwpCalcFirst = pwp;
            }
        }

        pwp->StartCursorHideTime = timeAdd + timeNow;
        pwp->W32PF_Flags |= W32PF_STARTGLASS;
    }

    gtimeStartCursorHide = 0;
    for (ppwpT = &gpwpCalcFirst; (pwpT = *ppwpT) != NULL;) {
        /*
         * If the app isn't starting or feedback is forced off, remove
         * it from the list so we don't look at it again.
         */
        if (!(pwpT->W32PF_Flags & W32PF_STARTGLASS) ||
                (pwpT->W32PF_Flags & W32PF_FORCEOFFFEEDBACK)) {
            *ppwpT = pwpT->NextStart;
            continue;
        }

        /*
         * Find the greatest hide cursor timeout value.
         */
        if (gtimeStartCursorHide < pwpT->StartCursorHideTime) {
            gtimeStartCursorHide = pwpT->StartCursorHideTime;
        }

        /*
         * If this app has timed out, it isn't starting anymore! Remove it
         * from the list.
         */
        if (ComputeTickDelta(timeNow, pwpT->StartCursorHideTime) > 0) {
            pwpT->W32PF_Flags &= ~W32PF_STARTGLASS;
            *ppwpT = pwpT->NextStart;
            continue;
        }

        /*
         * Step to the next pwp in the list.
         */
        ppwpT = &pwpT->NextStart;
    }

    /*
     * If the hide time is still less than the current time, then turn off
     * the app starting cursor.
     */
    if (gtimeStartCursorHide <= timeNow) {
        gtimeStartCursorHide = 0;
    }

    /*
     * Update the cursor image with the new info (doesn't do anything unless
     * the cursor is really changing).
     */
    zzzUpdateCursorImage();
}


#define QUERY_VALUE_BUFFER 80

/*
 * Install hack.
 *
 * We have a hack inherited from Chicago that allows the shell to
 * clean up registry information after a setup program runs. A
 * setup program is defined as an app with one of a list of names.
 */

PUNICODE_STRING gpastrSetupExe;    // These are initialized in the routine
int giSetupExe;                    // CreateSetupNameArray in setup.c


/***************************************************************************\
* SetAppImeCompatFlags - NOTE pstrModName->Buffer must be zero terminated.
*
*
* History:
* 07-17-97 DaveHart Split from SetAppCompatFlags -- misleadingly it also
*                   returns a BOOL indicating whether the filename is
*                   recognized as a setup program. Used by SetAppCompatFlags
*                   for 32-bit apps and zzzInitTask for 16-bit ones.
\***************************************************************************/
BOOL SetAppImeCompatFlags(
    PTHREADINFO pti,
    PUNICODE_STRING pstrModName,
    PUNICODE_STRING pstrBaseFileName)
{
    DWORD dwImeFlags = 0;
    WCHAR szHex[QUERY_VALUE_BUFFER];
    WORD wPrimaryLangID;
    LCID lcid;
    int iSetup;
    BOOL fSetup = FALSE;
    int iAppName;
    int cAppNames;
    PUNICODE_STRING rgpstrAppNames[2];
    UNICODE_STRING strHex;

    /*
     * Because can't access pClientInfo of another process
     */
    UserAssert(pti->ppi == PpiCurrent());

    /*
     * Because it is used as a zero-terminated profile key name.
     */
    UserAssert(pstrModName->Buffer[pstrModName->Length / sizeof(WCHAR)] == 0);

    if (FastGetProfileStringW(
                NULL,
                PMAP_IMECOMPAT,
                pstrModName->Buffer,
                NULL,
                szHex,
                ARRAY_SIZE(szHex),
                0)) {

        /*
         * Found some flags. Attempt to convert the hex string
         * into numeric value. Specify base 0, so
         * RtlUnicodeStringToInteger will handle the 0x format.
         */
        RtlInitUnicodeString(&strHex, szHex);
        RtlUnicodeStringToInteger(&strHex, 0, (PULONG)&dwImeFlags);
    }

    /*
     * If current layout is not IME layout, we don't need to get
     * compatible flags for IME. But now, we don't have any scheme
     * to get this flags when the keyboard layout is switched. Then
     * we get it here, even this flags are not nessesary for non-IME
     * keyboard layouts.
     */
    ZwQueryDefaultLocale(FALSE, &lcid);
    wPrimaryLangID = PRIMARYLANGID(lcid);

    if ((wPrimaryLangID == LANG_KOREAN || wPrimaryLangID == LANG_JAPANESE) &&
            (LOWORD(pti->dwExpWinVer) <= VER31)) {
        /*
         * IME compatibility flags are needed even if it's a 32 bit app.
         */
        pti->ppi->dwImeCompatFlags = dwImeFlags;
    } else {
        pti->ppi->dwImeCompatFlags = dwImeFlags & (IMECOMPAT_NOFINALIZECOMPSTR | IMECOMPAT_HYDRACLIENT);
        if (dwImeFlags & IMECOMPAT_NOFINALIZECOMPSTR) {
            RIPMSG1(RIP_WARNING, "IMECOMPAT_NOFINALIZECOMPSTR is set to ppi=%#p", pti->ppi);
        }
        if (dwImeFlags & IMECOMPAT_HYDRACLIENT) {
            RIPMSG1(RIP_WARNING, "IMECOMPAT_HYDRACLIENT is set to ppi=%#p", pti->ppi);
        }
    }


    if (gpastrSetupExe == NULL) {
        return fSetup;
    }

    rgpstrAppNames[0] = pstrModName;
    cAppNames = 1;
    if (pstrBaseFileName) {
        rgpstrAppNames[1] = pstrBaseFileName;
        cAppNames = 2;
    }

    for (iAppName = 0; iAppName < cAppNames && !fSetup; iAppName++) {
        iSetup = 0;
        while (iSetup < giSetupExe) {
            if (RtlCompareUnicodeString(rgpstrAppNames[iAppName], &(gpastrSetupExe[iSetup]), TRUE) == 0) {
                fSetup = TRUE;
                break;
            }
            iSetup++;
        }
    }

    return fSetup;
}

/***************************************************************************\
* SetAppCompatFlags
*
*
* History:
* 03-23-92 JimA     Created.
* 07-17-97 FritzS   add return for fSetup -- returns TRUE if app is a setup app.
* 09-03-97 DaveHart Split out IME, WOW doesn't use this function anymore.
* 07-14-98 MCostea  Add Compatibility2 flags
* 01-21-99 MCostea  Add DesiredOSVersion
\***************************************************************************/
BOOL SetAppCompatFlags(
    PTHREADINFO pti)
{
    DWORD dwFlags = 0;
    DWORD dwFlags2 = 0;
    WCHAR szHex[QUERY_VALUE_BUFFER];
    WCHAR szKey[90];
    WCHAR *pchStart, *pchEnd;
    DWORD cb;
    PUNICODE_STRING pstrAppName;
    UNICODE_STRING strKey;
    UNICODE_STRING strImageName;

    /*
     * Because can't access pClientInfo of another process.
     */
    UserAssert(pti->ppi == PpiCurrent());

    UserAssert(pti->ppi->ptiList);

    UserAssert(!(pti->TIF_flags & TIF_16BIT));

    /*
     * We assume here that pti was just inserted in at the head of ptiList
     */
    UserAssert(pti == pti->ppi->ptiList);

    try {
        PPEB ppeb = PsGetProcessPeb(PsGetThreadProcess(pti->pEThread));
        struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters;

        if (pti->ptiSibling) {
            pti->pClientInfo->dwCompatFlags = pti->dwCompatFlags = pti->ptiSibling->dwCompatFlags;
            pti->pClientInfo->dwCompatFlags2 = pti->dwCompatFlags2 = pti->ptiSibling->dwCompatFlags2;
            return FALSE;
        }

        /*
         * Find end of app name
         */
        if (pti->pstrAppName != NULL) {
            pstrAppName = pti->pstrAppName;
        } else {

            ProbeForRead(ppeb, sizeof(PEB), sizeof(BYTE));
            ProcessParameters = ppeb->ProcessParameters;

            ProbeForRead(ProcessParameters, sizeof(*ProcessParameters), sizeof(BYTE));
            strImageName = ProbeAndReadUnicodeString(&ProcessParameters->ImagePathName);
            ProbeForReadUnicodeStringBuffer(strImageName);
            pstrAppName = &strImageName;
        }
        pchStart = pchEnd = pstrAppName->Buffer +
                (pstrAppName->Length / sizeof(WCHAR));

        /*
         * Locate start of extension
         */
        while (TRUE) {
            if (pchEnd == pstrAppName->Buffer) {
                pchEnd = pchStart;
                break;
            }

            if (*pchEnd == TEXT('.')) {
                break;
            }

            pchEnd--;
        }

        /*
         * Locate start of filename
         */
        pchStart = pchEnd;

        while (pchStart != pstrAppName->Buffer) {
            if (*pchStart == TEXT('\\') || *pchStart == TEXT(':')) {
                pchStart++;
                break;
            }

            pchStart--;
        }

    #define MODULESUFFIXSIZE    (8 * sizeof(WCHAR))
    #define MAXMODULENAMELEN    (sizeof(szKey) - MODULESUFFIXSIZE)
        /*
         * Get a copy of the filename
         * Allow extra spaces for the 'ImageSubsystemMajorVersionMinorVersion'
         * i.e. 3.5 that will get appended at the end of the module name
         */
        cb = (DWORD)(pchEnd - pchStart) * sizeof(WCHAR);
        if (cb >= MAXMODULENAMELEN)
            cb = MAXMODULENAMELEN - sizeof(WCHAR);
        RtlCopyMemory(szKey, pchStart, cb);

        /*
         * Get the compat2 flags from the PEB. The appcompat infrastructure
         * gets the flags from the shim database.
         */
        pti->dwCompatFlags2 = ppeb->AppCompatFlagsUser.LowPart;
        pti->pClientInfo->dwCompatFlags2 = pti->dwCompatFlags2;
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        return FALSE;
    }

    szKey[(cb / sizeof(WCHAR))] = 0;
#undef MAXMODULENAMELEN

    if (FastGetProfileStringW(
                NULL,
                PMAP_COMPAT32,
                szKey,
                NULL,
                szHex,
                ARRAY_SIZE(szHex),
                0)) {

        UNICODE_STRING strHex;

        /*
         * Found some flags. Attempt to convert the hex string
         * into numeric value. Specify base 0, so
         * RtlUnicodeStringToInteger will handle the 0x format
         */
        RtlInitUnicodeString(&strHex, szHex);
        RtlUnicodeStringToInteger(&strHex, 0, (PULONG)&dwFlags);
    }

    try {
        pti->pClientInfo->dwCompatFlags = dwFlags;
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        return FALSE;
    }
    pti->dwCompatFlags = dwFlags;

    /*
     * Restore the string
     */
    szKey[(cb / sizeof(WCHAR))] = 0;
    RtlInitUnicodeString(&strKey, szKey);

    return SetAppImeCompatFlags(pti, &strKey, NULL);
}

/***************************************************************************\
* GetAppCompatFlags
*
* Compatibility flags for < Win 3.1 apps running on 3.1
*
* History:
* 04-??-92 ScottLu      Created.
* 05-04-92 DarrinM      Moved to USERRTL.DLL.
\***************************************************************************/
DWORD GetAppCompatFlags(
    PTHREADINFO pti)
{
    /*
     * GRE calls this with pti == NULL.
     */
    if (pti == NULL) {
        pti = PtiCurrentShared();
    }

    return pti->dwCompatFlags;
}

/***************************************************************************\
* GetAppCompatFlags2
*
* Compatibility flags for < wVer apps
*
* History:
* 07-01-98 MCostea      Created.
\***************************************************************************/
DWORD GetAppCompatFlags2(
    WORD wVer)
{
    return GetAppCompatFlags2ForPti(PtiCurrentShared(), wVer);
}

DWORD GetAppImeCompatFlags(
    PTHREADINFO pti)
{
    if (pti == NULL) {
        pti = PtiCurrentShared();
    }

    return pti->ppi->dwImeCompatFlags;
}

/***************************************************************************\
* CheckAppStarting
*
* This is a timer proc (see SetAppStarting) which removes ppi's from the
* starting list once their initialization time has expired.
*
* History:
* 08/26/97 GerardoB     Created
\***************************************************************************/
VOID CheckAppStarting(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    LARGE_INTEGER liStartingTimeout;
    PPROCESSINFO *pppi = &gppiStarting;

    KeQuerySystemTime(&liStartingTimeout); /* 1 unit == 100ns */
    liStartingTimeout.QuadPart -= (LONGLONG)(CMSAPPSTARTINGTIMEOUT * 10000);
    while (*pppi != NULL) {
        if (liStartingTimeout.QuadPart  > PsGetProcessCreateTimeQuadPart((*pppi)->Process)) {
            (*pppi)->W32PF_Flags &= ~(W32PF_APPSTARTING | W32PF_ALLOWFOREGROUNDACTIVATE);
            TAGMSG1(DBGTAG_FOREGROUND, "CheckAppStarting clear W32PF %#p", *pppi);
            *pppi = (*pppi)->ppiNext;
        } else {
            pppi = &(*pppi)->ppiNext;
        }
    }

    TAGMSG0(DBGTAG_FOREGROUND, "Removing all entries from ghCanActivateForegroundPIDs array");
    RtlZeroMemory(ghCanActivateForegroundPIDs, sizeof(ghCanActivateForegroundPIDs));

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
* SetAppStarting
*
* Add a process to the starting list and mark it as such. The process will
* remain in the list until it activates a window, our timer goes off or the
* process goes away, whichever happens first.
*
* History:
* 08/26/97 GerardoB     Created
\***************************************************************************/
VOID SetAppStarting(
    PPROCESSINFO ppi)
{
    static UINT_PTR guAppStartingId = 0;

    /*
     * This ppi had better not be in the list already, or we will be creating
     * a loop (as seen in stress).
     */
    UserAssert((ppi->W32PF_Flags & W32PF_APPSTARTING) == 0);

    /*
     * If we add this to the gppiStartingList without this bit set, we will
     * skip removing it from the list in DestroyProcessInfo(), but continue
     * to free it in FreeW32Process called by W32pProcessCallout.
     */
    UserAssert((ppi->W32PF_Flags & W32PF_PROCESSCONNECTED));

    ppi->W32PF_Flags |= W32PF_APPSTARTING;
    ppi->ppiNext = gppiStarting;
    gppiStarting = ppi;

    /*
     * Some system processes are initialized before the RIT has setup the master
     * timer, so check for it.
     */
    if (gptmrMaster != NULL) {
        guAppStartingId = InternalSetTimer(NULL, guAppStartingId,
                                           CMSAPPSTARTINGTIMEOUT + CMSHUNGAPPTIMEOUT,
                                           CheckAppStarting, TMRF_RIT | TMRF_ONESHOT);
    }
}

/***************************************************************************\
* ClearAppStarting
*
* Remove a process from the app starting list and clear the W32PF_APPSTARTING
* flag. No major action here, just a centralized place to take care of this.
*
* History:
* 08/26/97 GerardoB     Created
\***************************************************************************/
VOID ClearAppStarting(
    PPROCESSINFO ppi)
{
    REMOVE_FROM_LIST(PROCESSINFO, gppiStarting, ppi, ppiNext);
    ppi->W32PF_Flags &= ~W32PF_APPSTARTING;
}

/***************************************************************************\
* zzzInitTask -- called by WOW startup for each app
*
*
* History:
* 02-21-91 MikeHar  Created.
* 02-23-92 MattFe   Altered for WOW
* 09-03-97 DaveHart WOW supplies compat flags, we tell it about setup apps.
\***************************************************************************/
NTSTATUS zzzInitTask(
    UINT dwExpWinVer,
    DWORD dwAppCompatFlags,
    DWORD dwUserWOWCompatFlags,
    PUNICODE_STRING pstrModName,
    PUNICODE_STRING pstrBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize)
{
    PTHREADINFO ptiCurrent;
    PTDB ptdb;
    PPROCESSINFO ppi;
    PWOWTHREADINFO pwti;
    ULONG ProcessInfo;
    NTSTATUS Status;

    ptiCurrent = PtiCurrent();

    ppi = ptiCurrent->ppi;

    /*
     * Set the real name of the module. (Instead of 'NTVDM')
     * We've already probed pstrModName->Buffer for Length+sizeof(WCHAR) so
     * we can copy the UNICODE_NULL terminator as well.
     */
    if (ptiCurrent->pstrAppName != NULL) {
        UserFreePool(ptiCurrent->pstrAppName);
    }

    ptiCurrent->pstrAppName = NULL;

    //
    // Check the Target Process to see if this is a Wx86 process
    //
    if (ptiCurrent->ptdb) {
        /*
         * Shouldn't be called more than once on a thread.
         */
        return STATUS_ACCESS_DENIED;
    }

    Status = ZwQueryInformationProcess(NtCurrentProcess(),
                                       ProcessWx86Information,
                                       &ProcessInfo,
                                       sizeof(ProcessInfo),
                                       NULL);
    if (!NT_SUCCESS(Status) || ProcessInfo == 0) {
        return STATUS_ACCESS_DENIED;
    }

    ptiCurrent->pstrAppName = UserAllocPoolWithQuota(sizeof(UNICODE_STRING) +
            pstrModName->Length + sizeof(WCHAR), TAG_TEXT);
    if (ptiCurrent->pstrAppName != NULL) {
        ptiCurrent->pstrAppName->Buffer = (PWCHAR)(ptiCurrent->pstrAppName + 1);
        try {
            RtlCopyMemory(ptiCurrent->pstrAppName->Buffer, pstrModName->Buffer,
                    pstrModName->Length);
            ptiCurrent->pstrAppName->Buffer[pstrModName->Length / sizeof(WCHAR)] = 0;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            UserFreePool(ptiCurrent->pstrAppName);
            ptiCurrent->pstrAppName = NULL;
            return STATUS_OBJECT_NAME_INVALID;
        }
        ptiCurrent->pstrAppName->MaximumLength = pstrModName->Length + sizeof(WCHAR);
        ptiCurrent->pstrAppName->Length = pstrModName->Length;
    } else {
        return STATUS_OBJECT_NAME_INVALID;
    }

    /*
     * An app is starting!
     */
    if (!(ppi->W32PF_Flags & W32PF_APPSTARTING)) {
        SetAppStarting(ppi);
    }

    /*
     * We never want to use the ShowWindow defaulting mechanism for WOW
     * apps. If STARTF_USESHOWWINDOW was set in the client-side
     * STARTUPINFO structure, WOW has already picked it up and used
     * it for the first (command-line) app.
     */
    ppi->usi.dwFlags &= ~STARTF_USESHOWWINDOW;

    /*
     * If WOW passed us a hotkey for this app, save it for CreateWindow's use.
     */
    if (dwHotkey != 0) {
        ppi->dwHotkey = dwHotkey;
    }

    /*
     * If WOW passed us a non-default window position use it, otherwise clear it.
     */
    ppi->usi.cb = sizeof(ppi->usi);

    if (dwX == CW_USEDEFAULT || dwX == CW2_USEDEFAULT) {
        ppi->usi.dwFlags &= ~STARTF_USEPOSITION;
    } else {
        ppi->usi.dwFlags |= STARTF_USEPOSITION;
        ppi->usi.dwX = dwX;
        ppi->usi.dwY = dwY;
    }

    /*
     * If WOW passed us a non-default window size use it, otherwise clear it.
     */
    if (dwXSize == CW_USEDEFAULT || dwXSize == CW2_USEDEFAULT) {
        ppi->usi.dwFlags &= ~STARTF_USESIZE;
    } else {
        ppi->usi.dwFlags |= STARTF_USESIZE;
        ppi->usi.dwXSize = dwXSize;
        ppi->usi.dwYSize = dwYSize;
    }

    /*
     * Alloc and Link in new task into the task list
     */

    if ((ptdb = (PTDB)UserAllocPoolWithQuota(sizeof(TDB), TAG_WOWTDB)) == NULL)
        return STATUS_NO_MEMORY;

    RtlZeroMemory(ptdb, sizeof(TDB));

    ptiCurrent->ptdb = ptdb;

    /*
     * Save away the 16 bit task handle: we use this later when calling
     * wow back to close a WOW task.
     */
    ptdb->hTaskWow = LOWORD(hTaskWow);

    try {

        ptiCurrent->pClientInfo->dwCompatFlags = dwAppCompatFlags;

        UserAssert(ptiCurrent->ppi->ptiList);

        dwUserWOWCompatFlags &= COMPATFLAGS2_FORWOW;
        ptiCurrent->pClientInfo->dwCompatFlags2 = dwUserWOWCompatFlags;

        /*
         * HIWORD: != 0 if wants proportional font
         * LOWORD: Expected windows version (3.00 [300], 3.10 [30A], etc)
         */
        ptiCurrent->pClientInfo->dwExpWinVer = dwExpWinVer;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }
    ptiCurrent->dwCompatFlags = dwAppCompatFlags;
    ptiCurrent->dwCompatFlags2 = dwUserWOWCompatFlags;
    ptiCurrent->dwExpWinVer = dwExpWinVer;


    /*
     * We haven't captured pstrBaseFileName's buffer, we
     * may fault touching it in SetAppImeCompatFlags. If
     * so the IME flags have been set already and we
     * can safely assume it's not a setup app.
     */

    try {
        if (SetAppImeCompatFlags(ptiCurrent, ptiCurrent->pstrAppName,
                             pstrBaseFileName)) {
            /*
             * Flag task as a setup app.
             */
            ptdb->TDB_Flags = TDBF_SETUP;
            ppi->W32PF_Flags |= W32PF_SETUPAPP;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    /*
     * Set the flags to say this is a TIF_MEOW queues.
     */

    if (hTaskWow & HTW_ISMEOW) {
       ptiCurrent->TIF_flags |= TIF_MEOW;
    }

    ptiCurrent->TIF_flags |= TIF_16BIT | TIF_FIRSTIDLE;


    /*
     * Set the flags to say this is a 16-bit thread before attaching
     * queues.
     */

    /*
     * If this task is running in the shared WOW VDM, we handle
     * WaitForInputIdle a little differently than separate WOW
     * VDMs. This is because CreateProcess returns a real process
     * handle when you start a separate WOW VDM, so the "normal"
     * WaitForInputIdle works. For the shared WOW VDM, CreateProcess
     * returns an event handle.
     */
     ptdb->pwti = NULL;
     if (idTask) {
         ptiCurrent->TIF_flags |= TIF_SHAREDWOW;

         /*
          * Look for a matching thread in the WOW thread info list.
          */
         if (idTask != (DWORD)-1) {
             for (pwti = gpwtiFirst; pwti != NULL; pwti = pwti->pwtiNext) {
                  if (pwti->idTask == idTask) {
                      ptdb->pwti = pwti;
                      break;
                  }
             }
#if DBG
             if (pwti == NULL) {
                 RIPMSG0(RIP_WARNING, "InitTask couldn't find WOW struct\n");
             }
#endif
         }
    }

    try {
        ptiCurrent->pClientInfo->dwTIFlags |= ptiCurrent->TIF_flags;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    /*
     * We need this thread to share the queue of other win16 apps.
     * If we're journalling, all apps are sharing a queue, so we wouldn't
     * want to interrupt that - so only cause queue recalculation
     * if we aren't journalling.
     * ptdb may be freed by DestroyTask during a callback, so defer WinEvent
     * notifications until we don't need ptdb any more.
     */
    DeferWinEventNotify();
    if (!FJOURNALRECORD() && !FJOURNALPLAYBACK()) {
        zzzReattachThreads(FALSE);
    }

    /*
     * Setup the app start cursor for 5 second timeout.
     */
    zzzCalcStartCursorHide((PW32PROCESS)ppi, 5000);

    /*
     * Mark this guy and add him to the global task list so he can run.
     */
    #define NORMAL_PRIORITY_TASK 10

    /*
     * To be Compatible it super important that the new task run immediately
     * Set its priority accordingly. No other task should ever be set to
     * CREATION priority
     */
    ptdb->nPriority = NORMAL_PRIORITY_TASK;
    ptdb->pti = ptiCurrent;

    InsertTask(ppi, ptdb);
    zzzEndDeferWinEventNotify();


    /*
     * Force this new task to be the active task (WOW will ensure the
     * currently running task does a Yield which will put it into the
     * non preemptive scheduler.
     */
    ppi->pwpi->ptiScheduled = ptiCurrent;
    ppi->pwpi->CSLockCount = -1;

    EnterWowCritSect(ptiCurrent, ppi->pwpi);

    /*
     * Ensure app gets focus.
     */
    zzzShowStartGlass(10000);


    return STATUS_SUCCESS;
}

/***************************************************************************\
* zzzShowStartGlass
*
* This routine is called by WOW when first starting or when starting an
* additional WOW app.
*
* 12-07-92 ScottLu      Created.
\***************************************************************************/
VOID zzzShowStartGlass(
    DWORD dwTimeout)
{
    PPROCESSINFO ppi;

    /*
     * If this is the first call to zzzShowStartGlass(), then the
     * W32PF_ALLOWFOREGROUNDACTIVATE bit has already been set in the process
     * info - we don't want to set it again because it may have been
     * purposefully cleared when the user hit a key or mouse clicked.
     */
    ppi = PpiCurrent();
    if (ppi->W32PF_Flags & W32PF_SHOWSTARTGLASSCALLED) {
        /*
         * Allow this wow app to come to the foreground. This'll be cancelled
         * if the user mouse clicks or hits any keys.
         */
        SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
        TAGMSG0(DBGTAG_FOREGROUND, "zzzShowStartGlass set PUDF");
        ppi->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
        TAGMSG1(DBGTAG_FOREGROUND, "zzzShowStartGlass set W32PF %#p", ppi);
}
    ppi->W32PF_Flags |= W32PF_SHOWSTARTGLASSCALLED;

    /*
     * Show the start glass cursor for this much longer.
     */
    zzzCalcStartCursorHide((PW32PROCESS)ppi, dwTimeout);
}

/***************************************************************************\
* GetJournallingQueue
*
* 03/21/97  GerardoB     Created
\***************************************************************************/
PQ GetJournallingQueue(
    PTHREADINFO pti)
{
    PHOOK phook;

    /*
     * Fail if we cannot journal this thread.
     */
    if ((pti->TIF_flags & TIF_DONTJOURNALATTACH) || pti->rpdesk == NULL) {
        return NULL;
    }

    /*
     * Get the journalling hook if any.
     */
    phook = PhkFirstGlobalValid(pti, WH_JOURNALPLAYBACK);
    if (phook == NULL) {
        phook = PhkFirstGlobalValid(pti, WH_JOURNALRECORD);
    }

    /*
     * Validate fsHooks bits.
     */
    UserAssert((phook == NULL)
                ^ IsHooked(pti, (WHF_FROM_WH(WH_JOURNALPLAYBACK) | WHF_FROM_WH(WH_JOURNALRECORD))));

    /*
     * Return the queue if we found a journalling hook.
     */
    return ((phook == NULL) ? NULL : GETPTI(phook)->pq);
}

/***************************************************************************\
* ClearQueueServerEvent
*
* This function should be called when a thread needs to wait for some kind of
* input. This clears pEventQueueServer which means we won't return from the
* wait until new input of the required type arrives. Setting the wake mask
* controls what input will wake us up. WOW apps skip this since their
* scheduler controls when they wake up.
*
* History:
* 09/12/97 GerardoB     Created
\***************************************************************************/
VOID ClearQueueServerEvent(
    WORD wWakeMask)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    UserAssert(wWakeMask != 0);

    ptiCurrent->pcti->fsWakeMask = wWakeMask;
    KeClearEvent(ptiCurrent->pEventQueueServer);
}

ULONG ParseReserved(
    WCHAR *cczpReserved,
    WCHAR *pchFind)
{
    ULONG dw;
    WCHAR *cczpch, *cczpchT, ch;
    UNICODE_STRING cczuString;

    dw = 0;
    try {
        if (cczpReserved != NULL && (cczpch = wcsstr(cczpReserved, pchFind)) != NULL) {
            cczpch += wcslen(pchFind);

            cczpchT = cczpch;
            while (*cczpchT >= '0' && *cczpchT <= '9')
                cczpchT++;

            ch = *cczpchT;
            *cczpchT = 0;
            RtlInitUnicodeString(&cczuString, cczpch);
            *cczpchT = ch;

            RtlUnicodeStringToInteger(&cczuString, 0, &dw);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return 0;
    }

    return dw;
}
/*
 * Structure USER_PROCESS_PARAMETERS is used to capture all the fields that
 * we touch in RTL_USER_PROCESS_PARAMETERS (ppeb->ProcessParameters) since the
 * PEB can be trashed from the client side.
 */
typedef struct tagUSER_PROCESS_PARAMETERS {
    HANDLE StandardInput;
    HANDLE StandardOutput;
    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING DesktopInfo;     // ProcessParameters
    UNICODE_STRING ShellInfo;       // ProcessParameters
} USER_PROCESS_PARAMETERS, *PUSER_PROCESS_PARAMETERS;

/***************************************************************************\
* xxxCreateThreadInfo
*
* Allocate the main thread information structure
*
* History:
* 03-18-95 JimA         Created.
* 04-18-01 Mohamed      Modified error recovery wrt hEventQueueClient.
\***************************************************************************/
NTSTATUS xxxCreateThreadInfo(
    PETHREAD pEThread)
{
    DWORD                        dwTIFlags = 0;
    PPROCESSINFO                 ppi;
    PTHREADINFO                  ptiCurrent;
    PEPROCESS                    pEProcess = PsGetThreadProcess(pEThread);
    PUSERSTARTUPINFO             pusi;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PUSER_PROCESS_PARAMETERS     ProcessParams = NULL;
    USER_PROCESS_PARAMETERS      ProcessParamsData;
    PDESKTOP                     pdesk = NULL;
    HDESK                        hdesk = NULL;
    HWINSTA                      hwinsta;
    PQ                           pq;
    NTSTATUS                     Status;
    BOOL                         fFirstThread;
    PTEB                         pteb = NtCurrentTeb();
    TL                           tlpdesk, tlPool;
    PPEB                         ppeb;
    PVOID                        pTmpPool = NULL;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    ValidateProcessSessionId(pEProcess);

    /*
     * If CleanupResources was called for the last GUI thread then
     * we should not allow any more GUI threads
     */
    if (gbCleanedUpResources) {
        RIPMSG0(RIP_ERROR, "No more GUI threads should be created");
        return STATUS_PROCESS_IS_TERMINATING;
    }

    /*
     * Increment the number of GUI threads in the session
     */
    gdwGuiThreads++;

    if (pEProcess == gpepCSRSS) {
        dwTIFlags = TIF_CSRSSTHREAD | TIF_DONTATTACHQUEUE | TIF_DISABLEIME;
    }

    ptiCurrent = (PTHREADINFO)PsGetThreadWin32Thread(pEThread);

    ProcessParamsData.DesktopInfo.Buffer = NULL;
    ppeb = PsGetProcessPeb(pEProcess);
    try {
        /*
         * NOTE: We allocate memory for the DesktopInfo.Buffer and free it
         * later. For ShellInfo we do not since ParseReserved handles user-mode
         * pointers.
         */

        if (ppeb != NULL) {
            ProbeForRead(ppeb, sizeof(PEB), sizeof(BYTE));
            ProcessParameters = ppeb->ProcessParameters;
            ProcessParams = &ProcessParamsData;
            ProbeForRead(ProcessParameters, sizeof(RTL_USER_PROCESS_PARAMETERS), sizeof(BYTE));
            ProcessParamsData.StandardInput = ProcessParameters->StandardInput;
            ProcessParamsData.StandardOutput = ProcessParameters->StandardOutput;
            ProcessParamsData.StartingX = ProcessParameters->StartingX;
            ProcessParamsData.StartingY = ProcessParameters->StartingY;
            ProcessParamsData.CountX = ProcessParameters->CountX;
            ProcessParamsData.CountY = ProcessParameters->CountY;
            ProcessParamsData.WindowFlags = ProcessParameters->WindowFlags;
            ProcessParamsData.ShowWindowFlags = ProcessParameters->ShowWindowFlags;

            ProcessParamsData.DesktopInfo = ProbeAndReadUnicodeString(&ProcessParameters->DesktopInfo);
            if (ProcessParamsData.DesktopInfo.Length > 0) {
                PWSTR pszCapture = ProcessParamsData.DesktopInfo.Buffer;
                ProbeForReadUnicodeStringBuffer(ProcessParamsData.DesktopInfo);

                /*
                 * The pool pointer is stored in pTmpPool as well as in
                 * DesktopInfo.Buffer. The reason is that in case of corrupt
                 * user mode DesktopInfo an exception is raised which bails
                 * out of this try-except block without properly allocating
                 * the new pool. Therefore, pTmpPool is used in the check
                 * before freeing this pool.
                 */
                pTmpPool = UserAllocPoolWithQuota(ProcessParamsData.DesktopInfo.Length, TAG_TEXT2);
                ProcessParamsData.DesktopInfo.Buffer = pTmpPool;
                if (ProcessParamsData.DesktopInfo.Buffer) {
                    ThreadLockPool(ptiCurrent, ProcessParamsData.DesktopInfo.Buffer, &tlPool);
                    RtlCopyMemory(ProcessParamsData.DesktopInfo.Buffer, pszCapture, ProcessParamsData.DesktopInfo.Length);
                } else {
                    ExRaiseStatus(STATUS_NO_MEMORY);
                }
            } else {
                ProcessParamsData.DesktopInfo.Buffer = NULL;
            }

            ProcessParamsData.ShellInfo = ProbeAndReadUnicodeString(&ProcessParameters->ShellInfo);
            ProbeForReadUnicodeStringBuffer(ProcessParamsData.ShellInfo);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        Status = GetExceptionCode();
        goto CreateThreadInfoFailed;
    }

    /*
     * Locate the processinfo structure for the new thread.
     */
    ppi = PpiCurrent();

#ifdef _WIN64
    /*
     * If the process is marked as an emulated 32bit app mark the thread as
     * an emulated 32bit thread. This is to be consistent with the way WOW16
     * marks threads.
     */
    if (ppi->W32PF_Flags & W32PF_WOW64) {
        dwTIFlags |= TIF_WOW64;
    }
#endif

    /*
     * For Winlogon, only the first thread can have IME processing.
     */
    if (gpidLogon == PsGetThreadProcessId(pEThread)) {
        if (ppi->ptiList != NULL) {
            dwTIFlags |= TIF_DISABLEIME;
            RIPMSG1(RIP_VERBOSE, "WinLogon, second or other thread. pti=%#p", PsGetThreadWin32Thread(pEThread));
        }
    }

    ptiCurrent->TIF_flags = dwTIFlags;
    Lock(&ptiCurrent->spklActive, gspklBaseLayout);
    ptiCurrent->pcti      = &(ptiCurrent->cti);

    /*
     * Check if no IME processing for all threads
     * in the same process.
     */
    if (ppi->W32PF_Flags & W32PF_DISABLEIME) {
        ptiCurrent->TIF_flags |= TIF_DISABLEIME;
    }

    /*
     * Hook up this queue to this process info structure, increment
     * the count of threads using this process info structure. Set up
     * the ppi before calling SetForegroundPriority().
     */
    UserAssert(ppi != NULL);

    ptiCurrent->ppi        = ppi;
    ptiCurrent->ptiSibling = ppi->ptiList;
    ppi->ptiList    = ptiCurrent;
    ppi->cThreads++;


    if (pteb != NULL) {
        try {
            pteb->Win32ThreadInfo = ptiCurrent;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              Status = GetExceptionCode();
              goto CreateThreadInfoFailed;
        }
    }

    /*
     * Point to the client info.
     */
    if (dwTIFlags & TIF_SYSTEMTHREAD) {
        ptiCurrent->pClientInfo = UserAllocPoolWithQuota(sizeof(CLIENTINFO),
                                                  TAG_CLIENTTHREADINFO);
        if (ptiCurrent->pClientInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            goto CreateThreadInfoFailed;
        }
    } else {
        /*
         * If this is not a system thread then grab the user mode client
         * info elsewhere we use the GetClientInfo macro which looks here.
         */
        UserAssert(pteb != NULL);

        try {
            ptiCurrent->pClientInfo = ((PCLIENTINFO)((pteb)->Win32ClientInfo));
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              Status = GetExceptionCode();
              goto CreateThreadInfoFailed;
        }

        /*
         * Set the restricted flag in the thread flags if this is a secure
         * process.
         */
        if (((PW32PROCESS)ppi)->W32PF_Flags & W32PF_RESTRICTED) {
            ptiCurrent->TIF_flags |= TIF_RESTRICTED;
        }
    }


    /*
     * Create the input event.
     */
    Status = ZwCreateEvent(&ptiCurrent->hEventQueueClient,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(ptiCurrent->hEventQueueClient,
                                           EVENT_ALL_ACCESS,
                                           *ExEventObjectType,
                                           UserMode,
                                           &ptiCurrent->pEventQueueServer,
                                           NULL);
        if (NT_SUCCESS(Status)) {
            Status = ProtectHandle(ptiCurrent->hEventQueueClient, *ExEventObjectType, TRUE);
        } else if (Status != STATUS_INVALID_HANDLE) {
            ObCloseHandle(ptiCurrent->hEventQueueClient, UserMode);
        }
    }
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxCreateThreadInfo: failed a handle routine for hEventQueueClient handle, status=%08x", Status);
        ptiCurrent->hEventQueueClient = NULL;
        goto CreateThreadInfoFailed;
    }

    /*
     * Mark the process as having threads that need cleanup. See
     * DestroyProcessesObjects().
     */
    fFirstThread = !(ppi->W32PF_Flags & W32PF_THREADCONNECTED);
    ppi->W32PF_Flags |= W32PF_THREADCONNECTED;

    /*
     * If we haven't copied over our startup info yet, do it now.
     * Don't bother copying the info if we aren't going to use it.
     */
    if (ProcessParams) {

        pusi = &ppi->usi;

        if ((pusi->cb == 0) && (ProcessParams->WindowFlags != 0)) {
            pusi->cb          = sizeof(USERSTARTUPINFO);
            pusi->dwX         = ProcessParams->StartingX;
            pusi->dwY         = ProcessParams->StartingY;
            pusi->dwXSize     = ProcessParams->CountX;
            pusi->dwYSize     = ProcessParams->CountY;
            pusi->dwFlags     = ProcessParams->WindowFlags;
            pusi->wShowWindow = (WORD)ProcessParams->ShowWindowFlags;
        }

        if (fFirstThread) {

            /*
             * Set up the hot key, if there is one.
             *
             * If the STARTF_USEHOTKEY flag is given in the startup info, then
             * the hStdInput is the hotkey (new from Chicago). Otherwise, parse
             * it out in string format from the lpReserved string.
             */
            if (ProcessParams->WindowFlags & STARTF_USEHOTKEY) {
                ppi->dwHotkey = HandleToUlong(ProcessParams->StandardInput);
            } else {
                if (ProcessParams->ShellInfo.Length > 0) {
                    ppi->dwHotkey = ParseReserved(ProcessParams->ShellInfo.Buffer,
                                                  L"hotkey.");
                } else {
                    ppi->dwHotkey = 0;
                }
            }

            /*
             * Copy the monitor handle, if there is one.
             */
            UserAssert(!ppi->hMonitor);
            if (ProcessParams->WindowFlags & STARTF_HASSHELLDATA) {
                HMONITOR hMonitor;

                hMonitor = (HMONITOR)ProcessParams->StandardOutput;
                if (ValidateHmonitor(hMonitor)) {
                    ppi->hMonitor = hMonitor;
                }
            }
        }
    }

    if ((pq = AllocQueue(NULL, NULL)) == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CreateThreadInfoFailed;
    }

    /*
     * Attach the Q to the THREADINFO.
     */
    ptiCurrent->pq = pq;
    pq->ptiMouse = pq->ptiKeyboard = ptiCurrent;
    pq->cThreads++;

    /*
     * Open the windowstation and desktop. If this is a system
     * thread only use the desktop that might be stored in the teb.
     */
    UserAssert(ptiCurrent->rpdesk == NULL);
    if (!(ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD)) &&
        grpWinStaList) {

        BOOL bShutDown = FALSE;

        hdesk = xxxResolveDesktop(
                NtCurrentProcess(),
                &ProcessParams->DesktopInfo,
                &hwinsta, (ProcessParams->WindowFlags & STARTF_DESKTOPINHERIT),
                &bShutDown);
        if (hdesk == NULL) {
            if (bShutDown) {
                /*
                 * Trying to create a new process during logoff.
                 */
                ULONG_PTR adwParameters[5] = {0, 0, 0, 0, MB_DEFAULT_DESKTOP_ONLY};
                ULONG ErrorResponse;

                LeaveCrit();

                ExRaiseHardError((NTSTATUS)STATUS_DLL_INIT_FAILED_LOGOFF,
                                 ARRAY_SIZE(adwParameters),
                                 0,
                                 adwParameters,
                                 OptionOkNoWait,
                                 &ErrorResponse);

                ZwTerminateProcess(NtCurrentProcess(), STATUS_DLL_INIT_FAILED);

                EnterCrit();
            }

            Status = STATUS_DLL_INIT_FAILED;
            goto CreateThreadInfoFailed;

        } else {
            Status = _SetProcessWindowStation(hwinsta, UserMode);
            if (!NT_SUCCESS(Status)) {
                goto CreateThreadInfoFailed;
            }

            /*
             * Reference the desktop handle
             */
            Status = ObReferenceObjectByHandle(hdesk,
                                               0,
                                               *ExDesktopObjectType,
                                               KernelMode,
                                               &pdesk,
                                               NULL);
            if (!NT_SUCCESS(Status)) {
                UserAssert(pdesk == NULL);
                goto CreateThreadInfoFailed;
            }

            ThreadLockDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_CREATETHREADINFO);

            ObDereferenceObject(pdesk);

            /*
             * Map the desktop into the current process.
             */
            {
                WIN32_OPENMETHOD_PARAMETERS OpenParams;

                OpenParams.OpenReason = ObOpenHandle;
                OpenParams.Process = PsGetCurrentProcess();
                OpenParams.Object = pdesk;
                OpenParams.GrantedAccess = 0;
                OpenParams.HandleCount = 1;

                if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
                    RIPMSGF2(RIP_WARNING,
                             "Could't map pdesk %p in ppi %p",
                             pdesk,
                             PpiCurrent());
                    Status = STATUS_NO_MEMORY;
                    goto CreateThreadInfoFailed;
                }
            }

            /*
             * The first desktop is the default for all succeeding threads.
             */
            if (ppi->hdeskStartup == NULL &&
                PsGetProcessId(pEProcess) != gpidLogon) {

                LockDesktop(&ppi->rpdeskStartup, pdesk, LDL_PPI_DESKSTARTUP2, (ULONG_PTR)ppi);
                ppi->hdeskStartup = hdesk;
            }
        }
    }

    /*
     * Remember dwExpWinVer. This is used to return GetAppVer() (and
     * GetExpWinVer(NULL)).
     */
    if (PsGetProcessPeb(pEProcess) != NULL) {
        ptiCurrent->dwExpWinVer = RtlGetExpWinVer(PsGetProcessSectionBaseAddress(pEProcess));
    } else {
        ptiCurrent->dwExpWinVer = VER40;
    }

    INITCLIENTINFO(ptiCurrent);

    /*
     * Set the desktop even if it is NULL to ensure that ptiCurrent->pDeskInfo
     * is set.
     * NOTE: This adds the pti to the desktop's PtiList, but we don't yet have
     * a pti->pq. zzzRecalcThreadAttachment loops through this PtiList expects
     * a pq, so we must not leave the critsect until we have a queue.
     * zzzSetDesktop only zzz leaves the critsect if there is a pti->pq, so we
     * can BEGINATOMICCHECK to ensure this, and make sure we allocate the queue
     * before we leave the critical section.
     */
    BEGINATOMICCHECK();
    if (zzzSetDesktop(ptiCurrent, pdesk, hdesk) == FALSE) {
       EXITATOMICCHECK();
       goto CreateThreadInfoFailed;
    }
    ENDATOMICCHECK();

    /*
     * If we have a desktop and are journalling on that desktop, use
     * the journal queue, otherwise create a new queue.
     */
    if (pdesk == grpdeskRitInput) {
        UserAssert((pdesk == NULL) || (ptiCurrent->pDeskInfo == pdesk->pDeskInfo));
        UserAssert(ptiCurrent->rpdesk == pdesk);

        pq = GetJournallingQueue(ptiCurrent);
        if (pq != NULL && pq != ptiCurrent->pq) {

            DestroyThreadsMessages(ptiCurrent->pq, ptiCurrent);
            zzzDestroyQueue(ptiCurrent->pq, ptiCurrent);

            ptiCurrent->pq = pq;
            pq->cThreads++;
        }
    }

    /*
     * Remember that this is a screen saver. That way we can set its
     * priority appropriately when it is idle or when it needs to go
     * away. At first we set it to normal priority, then we set the
     * TIF_IDLESCREENSAVER bit so that when it activates it will get
     * lowered in priority.
     */
    if (ProcessParams && ProcessParams->WindowFlags & STARTF_SCREENSAVER) {
        if (fFirstThread) {
            UserAssert(gppiScreenSaver == NULL);

            /*
             * Make sure the parent's process is WinLogon, since only
             * WinLogon is allowed to use the STARTF_SCREENSAVER flag.
             */
            if (gpidLogon == 0 || PsGetProcessInheritedFromUniqueProcessId(pEProcess) != gpidLogon) {
                RIPMSG0(RIP_WARNING,"Only the Logon process can launch a screen saver.");
                ProcessParams->WindowFlags &= ~STARTF_SCREENSAVER;
                goto NotAScreenSaver;
            }

            gppiScreenSaver = ppi;
            gptSSCursor = gpsi->ptCursor;
            ppi->W32PF_Flags |= W32PF_SCREENSAVER;
        } else {
            UserAssert(ppi->W32PF_Flags & W32PF_SCREENSAVER);
        }

        SetForegroundPriority(ptiCurrent, TRUE);

        if (fFirstThread) {
            ppi->W32PF_Flags |= W32PF_IDLESCREENSAVER;
        }

        /*
         * Screen saver doesn't need any IME processing.
         */
        ptiCurrent->TIF_flags |= TIF_DISABLEIME;
    }

NotAScreenSaver:

    /*
     * Do special processing for the first thread of a process.
     */
    if (!(ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))) {

#ifndef LAZY_CLASS_INIT
        /*
         * I changed the code a while ago to unregister classes when the last
         * GUI thread is destroyed. Simply, there was too much stuff getting
         * unlocked and destroyed to guarantee that it would work on a non-GUI
         * thread. So if a process destroys its last GUI thread and then makes
         * a thread GUI later, we need to re-register the classes.
         */
        if (!(ppi->W32PF_Flags & W32PF_CLASSESREGISTERED)) {
            if (!LW_RegisterWindows()) {
                RIPMSG0(RIP_WARNING, "xxxCreateThreadInfo: LW_RegisterWindows failed");
                Status = STATUS_UNSUCCESSFUL;
                goto CreateThreadInfoFailed;
            }
        }
#endif

        if (fFirstThread) {

            /*
             * If this is an application starting (ie. not some thread of
             * the server context), enable the app-starting cursor.
             */
            DeferWinEventNotify();
            zzzCalcStartCursorHide((PW32PROCESS)PsGetProcessWin32Process(pEProcess), 5000);
            EndDeferWinEventNotifyWithoutProcessing();

            /*
             * Open the windowstation.
             */
            if (grpWinStaList && ppi->rpwinsta == NULL) {
                RIPERR0(ERROR_CAN_NOT_COMPLETE,
                        RIP_WARNING,
                        "System is not initialized");
                Status = STATUS_UNSUCCESSFUL;
                goto CreateThreadInfoFailed;
            }
        }
#ifndef LAZY_CLASS_INIT
    } else {
        /*
         * Don't register system windows until cursors and icons have been
         * loaded.
         */
        if ((SYSCUR(ARROW) != NULL) &&
                !(ppi->W32PF_Flags & W32PF_CLASSESREGISTERED)) {

            if (!LW_RegisterWindows()) {
                RIPMSG0(RIP_WARNING, "xxxCreateThreadInfo: LW_RegisterWindows failed");
                Status = STATUS_UNSUCCESSFUL;
                goto CreateThreadInfoFailed;
            }
        }
#endif
    }

    /*
     * Initialize hung timer value.
     */
    SET_TIME_LAST_READ(ptiCurrent);

    /*
     * If someone is waiting on this process propagate that info into the
     * thread info.
     */
    if (ppi->W32PF_Flags & W32PF_WAITFORINPUTIDLE) {
        ptiCurrent->TIF_flags |= TIF_WAITFORINPUTIDLE;
    }

    /*
     * Mark the thread as initialized.
     */
    ptiCurrent->TIF_flags |= TIF_GUITHREADINITIALIZED;

    /*
     * Allow the thread to come to foreground when it is created if the
     * current process is the foreground process or the last input owner.
     * This Flag is a hack to fix Bug 28502. When we click on "Map Network
     * Drive" button on the toolbar, explorer creates another thread to
     * create the dialog box. This will create the dialog in the background.
     * We are adding this fix at the request of the Shell team so that this
     * dialog comes up as foreground.
     *
     * If the process already has the foreground right, we don't give it to
     * this thread (it doesn't need it). We do this to narrow the number of
     * ways this process can force the foreground. Also, if the process is
     * starting, it already has the right unless the user has canceled it --
     * in which case we don't want to give it back.
     */
     if (!(ppi->W32PF_Flags & (W32PF_ALLOWFOREGROUNDACTIVATE | W32PF_APPSTARTING))) {
         if (((gptiForeground != NULL) && (ppi == gptiForeground->ppi))
                || ((glinp.ptiLastWoken != NULL) && (ppi == glinp.ptiLastWoken->ppi))) {

            ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxCreateThreadInfo set TIF %#p", ptiCurrent);
         }
     }

    if (IS_IME_ENABLED()) {
        /*
         * Create per-thread default input context
         */
        CreateInputContext(0);
    }

    /*
     * Call back to the client to finish initialization.
     */
    if (!(dwTIFlags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))) {
        if (SetAppCompatFlags(ptiCurrent)) {
            /*
             * Flag this process as a setup app.
             */
            ppi->W32PF_Flags |= W32PF_SETUPAPP;
        }

        Status = xxxClientThreadSetup();
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "ClientThreadSetup failed with NTSTATUS %lx", Status);
            goto CreateThreadInfoFailed;
        }
    }

    if ((NT_SUCCESS(Status) && fFirstThread) &&
        !(ppi->W32PF_Flags & W32PF_CONSOLEAPPLICATION)) {

        /*
         * Don't play the sound for console processes since we will play it
         * when the console window is created.
         */
        PlayEventSound(USER_SOUND_OPEN);
    }

    /*
     * Release desktop.
     * Some other thread might have been waiting to destroy this desktop
     * when xxxResolveDestktop got a handle to it. So let's double
     * check this now that we have called back several times after getting
     * the handle back.
     */
    if (pdesk != NULL) {
        if (pdesk->dwDTFlags & DF_DESTROYED) {
            RIPMSG1(RIP_WARNING, "xxxCreateThreadInfo: pdesk destroyed:%#p", pdesk);
            Status = STATUS_UNSUCCESSFUL;
            goto CreateThreadInfoFailed;
        }
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CREATETHREADINFO1);
    }


    if (pTmpPool != NULL) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
    }

    UserAssert(NT_SUCCESS(Status));
    return Status;

Error:
CreateThreadInfoFailed:

    RIPMSG3(RIP_WARNING, "xxxCreateThreadInfo failed: pti %#p pdesk %#p status 0x%x", ptiCurrent, pdesk, Status);

    if (pdesk != NULL) {
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CREATETHREADINFO2);
    }

    if (pTmpPool != NULL) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
    }

    xxxDestroyThreadInfo();
    return Status;
}

/***************************************************************************\
* AllocQueue
*
* Allocates the memory for a TI structure and initializes its fields.
* Each Win32 queue has it's own TI while all Win16 threads share the same
* TI.
*
* History:
* 02-21-91 MikeHar      Created.
\***************************************************************************/
PQ AllocQueue(
    PTHREADINFO ptiKeyState,    // If non-Null then use this key state.
                                // Otherwise use global AsyncKeyState.
    PQ pq)                      // Non-NULL == preallocated object.
{
    USHORT cLockCount;

    if (pq == NULL) {
        pq = ExAllocateFromPagedLookasideList(QLookaside);
        if (pq == NULL) {
            return NULL;
        }
        cLockCount = 0;
    } else {
        DebugValidateMLIST(&pq->mlInput);
        /*
         * Preserve lock count.
         */
        cLockCount = pq->cLockCount;
    }
    RtlZeroMemory(pq, sizeof(Q));
    pq->cLockCount = cLockCount;

    /*
     * This is a new queue; we need to update its key state table before
     * the first input event is put in the queue.
     * We do this by copying the current keystate table and NULLing the recent
     * down state table. If a key is really down it will be updated when
     * we get it repeats.
     *
     * He is the old way that did not work because if the first key was say an
     * alt key the Async table would be updated, then the UpdateKeyState
     * message and it would look like the alt key was PREVIOUSLY down.
     *
     * The queue will get updated when it first reads input: to allow the
     * app to query the key state before it calls GetMessage, set its initial
     * key state to the asynchronous key state.
     */
    if (ptiKeyState) {
        RtlCopyMemory(pq->afKeyState, ptiKeyState->pq->afKeyState, CBKEYSTATE);
    } else {
        RtlCopyMemory(pq->afKeyState, gafAsyncKeyState, CBKEYSTATE);
    }

    /*
     * If there isn't a mouse set iCursorLevel to -1 so the
     * mouse cursor won't be visible on the screen.
     */
    if (!TEST_GTERMF(GTERMF_MOUSE)) {
        pq->iCursorLevel--;
    }

    /*
     * While the thread is starting up ... it has the wait cursor.
     */
    LockQCursor(pq, SYSCUR(WAIT));

    DebugValidateMLIST(&pq->mlInput);
    return pq;
}

/***************************************************************************\
* FreeQueue
*
* 04-04-96 GerardoB    Created.
\***************************************************************************/
VOID FreeQueue(
    PQ pq)
{
#if DBG
    /*
     * Turn off the flag indicating that this queue is in destruction.
     * We do this in either case that we are putting this into the free
     * list, or truly destroying the handle. We use this to try and
     * track cases where someone tries to lock elements into the queue
     * structure while it's going through destuction.
     */
    pq->QF_flags &= ~QF_INDESTROY;
#endif

    UserAssert(pq != gpqForeground);
    UserAssert(pq != gpqForegroundPrev);
    UserAssert(pq != gpqCursor);

    ExFreeToPagedLookasideList(QLookaside, pq);
}

/***************************************************************************\
* FreeCachedQueues
*
* 14-Jan-98 CLupu    Created.
\***************************************************************************/
VOID FreeCachedQueues(
    VOID)
{
    if (QLookaside != NULL) {
        ExDeletePagedLookasideList(QLookaside);
        UserFreePool(QLookaside);
        QLookaside = NULL;
    }
}

/***************************************************************************\
* zzzDestroyQueue
*
*
* History:
* 05-20-91 MikeHar      Created.
\***************************************************************************/
VOID zzzDestroyQueue(
    PQ          pq,
    PTHREADINFO pti)
{
    PTHREADINFO ptiT;
    PTHREADINFO ptiAny, ptiBestMouse, ptiBestKey;
    PLIST_ENTRY pHead, pEntry;

#if DBG
    USHORT cDying = 0;
#endif

    BOOL fSetFMouseMoved = FALSE;

    DebugValidateMLIST(&pq->mlInput);

    UserAssert(pq->cThreads);
    pq->cThreads--;

    if (pq->cThreads != 0) {

        /*
         * Since we aren't going to destroy this queue, make sure
         * it isn't pointing to the THREADINFO that's going away.
         */
        if (pq->ptiSysLock == pti) {
            CheckSysLock(6, pq, NULL);
            pq->ptiSysLock = NULL;
        }

        if ((pq->ptiKeyboard == pti) || (pq->ptiMouse == pti)) {

            /*
             * Run through THREADINFOs looking for one pointing to pq.
             */
            ptiAny = NULL;
            ptiBestMouse = NULL;
            ptiBestKey = NULL;

            pHead = &pti->rpdesk->PtiList;
            for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
                ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

                /*
                 * Skip threads that are going away or belong to a
                 * different queue.
                 */
                if ((ptiT->TIF_flags & TIF_INCLEANUP) || (ptiT->pq != pq)) {
#if DBG
                    if (ptiT->pq == pq && (ptiT->TIF_flags & TIF_INCLEANUP)) {
                        cDying++;
                    }
#endif
                    continue;
                }

                ptiAny = ptiT;

                if (pti->pcti->fsWakeBits & QS_MOUSE) {
                    if (ptiT->pcti->fsWakeMask & QS_MOUSE)
                        ptiBestMouse = ptiT;
                }

                if (pti->pcti->fsWakeBits & QS_KEY) {
                    if (ptiT->pcti->fsWakeMask & QS_KEY)
                        ptiBestKey = ptiT;
                }
#ifdef GENERIC_INPUT
                if (pti->pcti->fsWakeMask & QS_RAWINPUT) {
                    if (ptiT->pcti->fsWakeMask & QS_RAWINPUT) {
                        /* For now, let's use keyboard focus to route the raw input */
                        ptiBestKey = ptiT;
                    }
                }
#endif
            }

            if (ptiBestMouse == NULL)
                ptiBestMouse = ptiAny;
            if (ptiBestKey == NULL)
                ptiBestKey = ptiAny;

            /*
             * Transfer any wake-bits to this new queue. This
             * is a common problem for QS_MOUSEMOVE which doesn't
             * get set on coalesced WM_MOUSEMOVE events, so we
             * need to make sure the new thread tries to process
             * any input waiting in the queue.
             */
            if (ptiBestMouse != NULL)
                SetWakeBit(ptiBestMouse, pti->pcti->fsWakeBits & QS_MOUSE);
            if (ptiBestKey != NULL) {
                SetWakeBit(ptiBestKey, pti->pcti->fsWakeBits & QS_KEY);
#ifdef GENERIC_INPUT
                SetWakeBit(ptiBestKey, pti->pcti->fsWakeBits & QS_RAWINPUT);
#endif
            }

            if (pq->ptiKeyboard == pti)
                pq->ptiKeyboard = ptiBestKey;

            if (pq->ptiMouse == pti)
                pq->ptiMouse = ptiBestMouse;

#if DBG
            /*
             * Bad things happen if ptiKeyboard or ptiMouse are NULL
             */
            if (pq->cThreads != cDying && (pq->ptiKeyboard == NULL || pq->ptiMouse == NULL)) {
                RIPMSG6(RIP_ERROR,
                        "pq %#p pq->cThreads %x cDying %x pti %#p ptiK %#p ptiM %#p",
                        pq, pq->cThreads, cDying, pti, pq->ptiKeyboard, pq->ptiMouse);
            }
#endif
        }

        return;
    }

    /*
     * Unlock any potentially locked globals now that we know absolutely
     * that this queue is going away.
     */
    UnlockCaptureWindow(pq);
    Unlock(&pq->spwndFocus);
    Unlock(&pq->spwndActive);
    Unlock(&pq->spwndActivePrev);
    Unlock(&pq->caret.spwnd);
    LockQCursor(pq, NULL);

#if DBG
    /*
     * Mark this queue as being in the destruction process. This is
     * cleared in FreeQueue() once we have determined it's safe to
     * place in the free-list, or destroy the handle. We use this
     * to track cases where someone will lock a cursor into the queue
     * while it's in the middle of being destroyed.
     */
    pq->QF_flags |= QF_INDESTROY;
#endif

    /*
     * Free everything else that was allocated/created by AllocQueue.
     */
    FreeMessageList(&pq->mlInput);

    /*
     * If this queue is in the foreground, set gpqForeground
     * to NULL so no input is routed. At some point we'll want
     * to do slightly more clever assignment of gpqForeground here.
     */
    if (gpqForeground == pq) {
        gpqForeground = NULL;
    }

    if (gpqForegroundPrev == pq) {
        gpqForegroundPrev = NULL;
    }

    if (gpqCursor == pq) {
        gpqCursor = NULL;
        fSetFMouseMoved = TRUE;
    }

    if (pq->cLockCount == 0) {
        FreeQueue(pq);
    }

    if (fSetFMouseMoved) {
        zzzSetFMouseMoved();
    }

}

/**************************************************************************\
* UserDeleteW32Thread
*
* This function is called when the W32THREAD reference count goes
* down to zero. So everything left around by xxxDestroyThreadInfo
* must be cleaned up here.
*
* SO VERY IMPORTANT:
* Note that this call is not in the context of the pti being cleaned up,
* in other words, pti != PtiCurrent(). So only kernel calls are allowed here.
*
* 04-01-96 GerardoB   Created
\**************************************************************************/
VOID UserDeleteW32Thread(
    PW32THREAD pW32Thread)
{
    PTHREADINFO pti = (PTHREADINFO)pW32Thread;

    BEGIN_REENTERCRIT();

    /*
     * Make sure the ref count didn't get bumped up while we were waiting.
     */
    if (pW32Thread->RefCount == 0) {

        /*
         * Events
         */
        if (pti->pEventQueueServer != NULL) {
            ObDereferenceObject(pti->pEventQueueServer);
        }
        if (pti->apEvent != NULL) {
            UserFreePool(pti->apEvent);
        }

        /*
         * App name.
         */
        if (pti->pstrAppName != NULL) {
            UserFreePool(pti->pstrAppName);
        }

        /*
         * Unlock the queues and free them if no one is using them (the
         * queues were already destroyed in DestroyThreadInfo).
         */
        if (pti->pq != NULL) {
            UserAssert(pti->pq->cLockCount);
            --(pti->pq->cLockCount);

            if (pti->pq->cLockCount == 0 && pti->pq->cThreads == 0) {
                FreeQueue(pti->pq);
            }
        }

        /*
         * zzzReattachThreads shouldn't call back while using pqAttach
         */
        UserAssert(pti->pqAttach == NULL);

        /*
         * Unlock the desktop (pti already unlinked from ptiList)
         */
        if (pti->rpdesk != NULL) {
            UnlockDesktop(&pti->rpdesk, LDU_PTI_DESK, (ULONG_PTR)pti);
        }

        /*
         * Remove the pointer to this W32Thread and free the associated memory.
         */
        PsSetThreadWin32Thread(pW32Thread->pEThread, NULL, pW32Thread);
        Win32FreePool(pW32Thread);
    }

    END_REENTERCRIT();
}

/**************************************************************************\
* UserDeleteW32Process
*
* This function is called when the W32PROCESS reference count goes
* down to zero. So everything left around by DestroyProcessInfo
* must be cleaned up here.
*
* SO VERY IMPORTANT:
* Note that this call may not be in the context of the ppi being cleaned up,
* in other words, ppi != PpiCurrent(). So only kernel calls are allowed here.
*
* 04-01-96 GerardoB   Created
\**************************************************************************/
VOID UserDeleteW32Process(
    PW32PROCESS pW32Process)
{
    PPROCESSINFO ppi = (PPROCESSINFO)pW32Process;

    BEGIN_REENTERCRIT();

    /*
     * Make sure the ref count didn't get bumped up while we were waiting.
     */
    if (pW32Process->RefCount == 0) {
        UserAssert(ppi->ptiMainThread == NULL && ppi->ptiList == NULL);

        /*
         * Grab the handle flags lock. We can't call into the object manager when
         * we have this or we might deadlock.
         */
        EnterHandleFlagsCrit();

        /*
         * Delete handle flags attribute bitmap
         */
        if (ppi->bmHandleFlags.Buffer) {
            UserFreePool(ppi->bmHandleFlags.Buffer);
            RtlInitializeBitMap(&ppi->bmHandleFlags, NULL, 0);
        }

        /*
         * Remove the pointer to this W32Process and free the associated memory.
         */
        PsSetProcessWin32Process(pW32Process->Process, NULL, pW32Process);
        Win32FreePool(pW32Process);

        /*
         * Release the handle flags lock.
         */
        LeaveHandleFlagsCrit();
    }

    END_REENTERCRIT();
}

/***************************************************************************\
* FLastGuiThread
*
* Check if this is the last GUI thread in the process.
\***************************************************************************/
__inline BOOL FLastGuiThread(
    PTHREADINFO pti)
{
    return (pti->ppi != NULL &&
            pti->ppi->ptiList == pti &&
            pti->ptiSibling == NULL);
}

/***************************************************************************\
* xxxDestroyThreadInfo
*
* Destroys a THREADINFO created by xxxCreateThreadInfo().
*
* Note that the current pti can be locked so it might be used after this
* function returns, even though the thread execution has ended.
*
* We want to stop any activity on this thread so we clean up any USER stuff
* like messages, clipboard, queue, etc and specially anything that assumes
* to be running on a Win32 thread and client side stuff. The final cleanup
* will take place in UserDeleteW32Thread.
*
* This function must not go into the user mode because the ntos data
* structures may no longer support it and it may bluescreen the system.
*
* Make all callbacks before the thread objects are destroyed. If you callback
* afterwards, new objects might be created and won't be cleaned up.
*
* History:
* 02-15-91 DarrinM      Created.
* 02-27-91 mikeke       Made it work
* 02-27-91 Mikehar      Removed queue from the global list
\***************************************************************************/
VOID xxxDestroyThreadInfo(
    VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent(), *ppti;
    PTEB pteb = NtCurrentTeb();

    UserAssert(ptiCurrent != NULL);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * We must NULL out the Win32ThreadInfo pointer. Otherwise, a thread
     * that is here due to failing to convert to GUI can call a USER
     * function, at which point they'll access this (now bogus) pointer.
     */
    if (pteb != NULL) {
        try {
            pteb->Win32ThreadInfo = NULL;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            /*
             * Do nothing. Worse case scenario, the app crashes later,
             * but that's the full extent of what we were trying to avoid.
             */
        }
    }

    /*
     * If this thread is blocking input, stop it.
     */
    if (gptiBlockInput == ptiCurrent) {
        gptiBlockInput = NULL;
    }

    /*
     * Don't mess with this ptiCurrent anymore.
     */
    ptiCurrent->TIF_flags |= (TIF_DONTATTACHQUEUE | TIF_INCLEANUP);

    /*
     * First do any preparation work: Windows need to be "patched" so that
     * their window procs point to server only windowprocs, for example.
     */
    PatchThreadWindows(ptiCurrent);

    /*
     * If this thread terminated abnormally and was tracking tell
     * GDI to hide the trackrect.
     */
    if (ptiCurrent->pmsd != NULL) {
        xxxCancelTrackingForThread(ptiCurrent);
    }

    /*
     * Unlock the pmsd window.
     */
    if (ptiCurrent->pmsd != NULL) {
        Unlock(&ptiCurrent->pmsd->spwnd);
        UserFreePool(ptiCurrent->pmsd);
        ptiCurrent->pmsd = NULL;
    }

    /*
     * Free the clipboard if owned by this thread.
     */
    {
        PWINDOWSTATION pwinsta;
        pwinsta = _GetProcessWindowStation(NULL);
        if (pwinsta != NULL) {
            if (pwinsta->ptiClipLock == ptiCurrent) {
                xxxCloseClipboard(pwinsta);
            }
            if (pwinsta->ptiDrawingClipboard == ptiCurrent) {
                pwinsta->ptiDrawingClipboard = NULL;
            }
        }
    }

    /*
     * Unlock all the objects stored in the menustate structure.
     */
    while (ptiCurrent->pMenuState != NULL) {
        PMENUSTATE pMenuState;
        PPOPUPMENU ppopupmenuRoot;

        pMenuState = ptiCurrent->pMenuState;
        ppopupmenuRoot = pMenuState->pGlobalPopupMenu;

        /*
         * If menu mode was running on this thread
         */
        if (ptiCurrent == pMenuState->ptiMenuStateOwner) {
            /*
             * The menu's going away, so anyone who's locked it
             * is SOL anyway. Windows NT Bug #375467.
             */
            pMenuState->dwLockCount = 0;

            /*
             * Close this menu.
             */
            if (pMenuState->fModelessMenu) {
                xxxEndMenuLoop(pMenuState, ppopupmenuRoot);
                xxxMNEndMenuState(TRUE);
            } else {
                pMenuState->fInsideMenuLoop = FALSE;
                ptiCurrent->pq->QF_flags &= ~QF_CAPTURELOCKED;
                xxxMNCloseHierarchy(ppopupmenuRoot, pMenuState);
                xxxMNEndMenuState(ppopupmenuRoot->fIsMenuBar || ppopupmenuRoot->fDestroyed);
            }
        } else {
            /*
             * Menu mode is running on another thread. This thread
             * must own spwndNotify which is going away soon.
             *
             * When spwndNotify is destroyed, we will clean up pMenuState
             * from this pti. So do nothing now as we'll need this
             * pMenuState at that time.
             */
            UserAssert((ppopupmenuRoot->spwndNotify != NULL)
                    && (GETPTI(ppopupmenuRoot->spwndNotify) == ptiCurrent));

            /*
             * Nested menus are not supposed to involve multiple threads.
             */
            UserAssert(pMenuState->pmnsPrev == NULL);
            break;
        }
    }

    /*
     * Unlock all the objects stored in the sbstate structure.
     */
    if (ptiCurrent->pSBTrack) {
        Unlock(&ptiCurrent->pSBTrack->spwndSB);
        Unlock(&ptiCurrent->pSBTrack->spwndSBNotify);
        Unlock(&ptiCurrent->pSBTrack->spwndTrack);
        UserFreePool(ptiCurrent->pSBTrack);
        ptiCurrent->pSBTrack = NULL;
    }

    /*
     * If this is the main input thread of this application, zero out
     * that field.
     */
    if (ptiCurrent->ppi != NULL && ptiCurrent->ppi->ptiMainThread == ptiCurrent) {
        ptiCurrent->ppi->ptiMainThread = NULL;
    }

    while (ptiCurrent->psiiList != NULL) {
        xxxDestroyThreadDDEObject(ptiCurrent, ptiCurrent->psiiList);
    }

    if (ptiCurrent->TIF_flags & TIF_PALETTEAWARE) {
        PWND pwnd;
        TL tlpwnd;

        UserAssert(ptiCurrent->rpdesk != NULL);

        pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;
        if (pwnd) {
            ThreadLock(pwnd, &tlpwnd);
            xxxFlushPalette(pwnd);
            ThreadUnlock(&tlpwnd);
        }
    }

    /*
     * If this is the last GUI thread for the process that made a temporary
     * (fullscreen) mode change, restore the mode to what's in the registry.
     */
    if (FLastGuiThread(ptiCurrent)) {
        if ((gppiFullscreen == ptiCurrent->ppi) && !gbMDEVDisabled) {
            LONG Status = xxxUserChangeDisplaySettings(NULL, NULL, NULL, 0, 0, KernelMode);
            if (gppiFullscreen == ptiCurrent->ppi) {
                RIPMSG1(RIP_WARNING, "xxxUserChangeDisplaySettings failed with status 0x%x", Status);
            }
        }
    }

#ifdef GENERIC_INPUT
    /*
     * If the raw input is specified in this process,
     * destroy thread-related objects and requests.
     * This has to be done before the window reparenting.
     */
    if (ptiCurrent->ppi && ptiCurrent->ppi->pHidTable) {
        DestroyThreadHidObjects(ptiCurrent);
    }
#endif


    /**************************************************************************\
     *
     * CLEANING THREAD OBJECTS. AVOID CALLING BACK AFTER THIS POINT.
     *
     * New objects might be created while calling back and won't be cleaned up.
     *
    \**************************************************************************/

    /*
     * This thread might have some outstanding timers. Destroy them.
     */
    DestroyThreadsTimers(ptiCurrent);

    /*
     * Free any windows hooks this thread has created.
     */
    FreeThreadsWindowHooks();

    /*
     * Cleanup any switch window info for any window switch window
     * belonging to this thread.
     */
    RemoveThreadSwitchWindowInfo(ptiCurrent);

    /*
     * Free any hwnd lists the thread was using
     */
    {
       PBWL pbwl, pbwlNext;
       for (pbwl = gpbwlList; pbwl != NULL;) {
           pbwlNext = pbwl->pbwlNext;
           if (pbwl->ptiOwner == ptiCurrent) {
               FreeHwndList(pbwl);
           }
           pbwl = pbwlNext;
       }
    }

    /*
     * Destroy all the public objects created by this thread.
     */
    DestroyThreadsHotKeys();

    DestroyThreadsObjects();

    /*
     * Free any synchronous Notifies pending for this thread and
     * free any Win Event Hooks this thread created.
     */
    FreeThreadsWinEvents(ptiCurrent);

    /*
     * Unlock the keyboard layouts here.
     */
    Unlock(&ptiCurrent->spklActive);

    /*
     * Cleanup the global resources if this is the last GUI thread for this
     * session.
     */
    if (gdwGuiThreads == 1) {
        CleanupResources();
    }


    if (FLastGuiThread(ptiCurrent)) {
        /*
         * Check if this was a setup app.
         */
        if (ptiCurrent->ppi->W32PF_Flags & W32PF_SETUPAPP) {
            PDESKTOPINFO pdeskinfo = GETDESKINFO(ptiCurrent);
            if (pdeskinfo->spwndShell) {
                _PostMessage(pdeskinfo->spwndShell, DTM_SETUPAPPRAN, 0, 0);
            }
        }

        DestroyProcessesClasses(ptiCurrent->ppi);
        ptiCurrent->ppi->W32PF_Flags &= ~(W32PF_CLASSESREGISTERED);
        try {
            LPBOOL lpClassesRegistered = ptiCurrent->pClientInfo->lpClassesRegistered;
            if (lpClassesRegistered) {
                ProbeForWrite(lpClassesRegistered, sizeof(BOOL), sizeof(DWORD));
                *lpClassesRegistered = FALSE;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }

        DestroyProcessesObjects(ptiCurrent->ppi);
    }

    /*
     * Unlock default input context.
     */
    Unlock(&ptiCurrent->spDefaultImc);

    if (ptiCurrent->pq != NULL) {
        /*
         * Remove this thread's cursor count from the queue.
         */
        ptiCurrent->pq->iCursorLevel -= ptiCurrent->iCursorLevel;

        /*
         * Have to recalc queue ownership after this thread leaves if it is
         * a member of a shared input queue.
         */
        if (ptiCurrent->pq->cThreads != 1) {
            gpdeskRecalcQueueAttach = ptiCurrent->rpdesk;
            /*
             * Because we are in thread cleanup, we won't callback due to
             * WinEvents (zzzSetFMouseMoved calls zzzUpdateCursorImage).
             */
            UserAssert(ptiCurrent->TIF_flags & TIF_INCLEANUP);
            UserAssert(gbExitInProgress == FALSE);
            zzzSetFMouseMoved();
        }
    }

    /*
     * Remove from the process' list, also.
     */
    ppti = &PpiCurrent()->ptiList;
    if (*ppti != NULL) {
        while (*ppti != ptiCurrent && (*ppti)->ptiSibling != NULL) {
            ppti = &((*ppti)->ptiSibling);
        }

        if (*ppti == ptiCurrent) {
            *ppti = ptiCurrent->ptiSibling;
            ptiCurrent->ptiSibling = NULL;
        }
    }

    {
        PDESKTOP rpdesk;
        PATTACHINFO *ppai;

        /*
         * Temporarily lock the desktop until the THREADINFO structure is
         * freed. Note that locking a NULL ptiCurrent->rpdesk is OK. Use a
         * normal lock instead of a thread lock because the lock must
         * exist past the freeing of the ptiCurrent.
         */
        rpdesk = NULL;
        LockDesktop(&rpdesk, ptiCurrent->rpdesk, LDL_FN_DESTROYTHREADINFO, (ULONG_PTR)PtiCurrent());

        /*
         * Cleanup SMS structures attached to this thread. Handles both
         * pending send and receive messages. MUST make sure we do
         * SendMsgCleanup AFTER window cleanup.
         */
        SendMsgCleanup(ptiCurrent);


        /*
         * Allow this thread to be swapped
         */
        if (ptiCurrent->cEnterCount) {
            BOOLEAN bool;

            RIPMSG1(RIP_WARNING,
                    "Thread exiting with stack locked. pti: 0x%p",
                    ptiCurrent);
            bool = KeSetKernelStackSwapEnable(TRUE);
            ptiCurrent->cEnterCount = 0;
            UserAssert(!bool);
        }

        if (ptiCurrent->ppi != NULL) {
            ptiCurrent->ppi->cThreads--;
            UserAssert(ptiCurrent->ppi->cThreads >= 0);
        }

        /*
         * If this thread is a win16 task, remove it from the scheduler.
         */
        if (ptiCurrent->TIF_flags & TIF_16BIT) {
            if ((ptiCurrent->ptdb) && (ptiCurrent->ptdb->hTaskWow != 0)) {
                _WOWCleanup(NULL, ptiCurrent->ptdb->hTaskWow);
            }
            DestroyTask(ptiCurrent->ppi, ptiCurrent);
        }

        if (ptiCurrent->hEventQueueClient != NULL) {
            NTSTATUS Status;
            Status = ProtectHandle(ptiCurrent->hEventQueueClient, *ExEventObjectType, FALSE);
            if (NT_SUCCESS(Status)) {
                ObCloseHandle(ptiCurrent->hEventQueueClient, UserMode);
            } else {
                RIPMSG1(RIP_WARNING, "xxxDestroyThreadInfo: failed to unprotect the hEventQueueClient handle, status=%08x", Status);
            }
            ptiCurrent->hEventQueueClient = NULL;
        }


        if (gspwndInternalCapture != NULL) {
            if (GETPTI(gspwndInternalCapture) == ptiCurrent) {
                Unlock(&gspwndInternalCapture);
            }
        }

        /*
         * Set gptiForeground to NULL if equal to this pti before exiting
         * this routine.
         */
        if (gptiForeground == ptiCurrent) {
            /*
             * Post these (WEF_ASYNC), since we can't make callbacks from here.
             */
            xxxWindowEvent(EVENT_OBJECT_FOCUS, NULL, OBJID_CLIENT, INDEXID_CONTAINER, WEF_ASYNC);
            xxxWindowEvent(EVENT_SYSTEM_FOREGROUND, NULL, OBJID_WINDOW, INDEXID_CONTAINER, WEF_ASYNC);

            /*
             * Call the Shell to ask it to activate its main window. This
             * will be accomplished with a PostMessage() to itself, so the
             * actual activation will take place later.
             */
            UserAssert(rpdesk != NULL);

            if (rpdesk->pDeskInfo->spwndProgman) {
                _PostMessage(rpdesk->pDeskInfo->spwndProgman, guiActivateShellWindow, 0, 0);
            }

            /*
             * Set gptiForeground to NULL because we're destroying it.
             */
            SetForegroundThread(NULL);

            /*
             * If this thread is attached to gpqForeground AND it's the
             * last thread in the queue, then zzzDestroyQueue will NULL out
             * qpqForeground. Due to journalling attaching, gptiForegrouund
             * is not always attached to gpqForeground. This is one reason
             * why we no longer NULL out gpqForeground as stated in the old
             * comment. The other reason is that there might be other threads
             * in the foreground queue so there is no need to zap it. This was
             * messing up MsTest (now called VisualTest)
             * This is the old comment:
             * "Since gpqForeground is derived from the foreground thread
             * structure, set it to NULL as well, since there now is no
             * foreground thread structure"
             *
             * qpqForeground = NULL;
             */
        }


        /*
         * If this thread got the last input event, pass ownership to another
         * thread in this process or to the foreground thread.
         */
        if (ptiCurrent == glinp.ptiLastWoken) {
            UserAssert(PpiCurrent() == ptiCurrent->ppi);
            if (ptiCurrent->ppi->ptiList != NULL) {
                UserAssert (ptiCurrent != ptiCurrent->ppi->ptiList);
                glinp.ptiLastWoken = ptiCurrent->ppi->ptiList;
            } else {
                glinp.ptiLastWoken = gptiForeground;
            }
        }

        /*
         * Make sure none of the other global thread pointers are pointing to us.
         */
        if (gptiShutdownNotify == ptiCurrent) {
            gptiShutdownNotify = NULL;
        }
        if (gptiTasklist == ptiCurrent) {
            gptiTasklist = NULL;
        }
        if (gHardErrorHandler.pti == ptiCurrent) {
            gHardErrorHandler.pti = NULL;
        }

        /*
         * Might be called from xxxCreateThreadInfo before the queue is created
         * so check for NULL queue. Lock the queues since this pti might be
         * locked. They will be unlocked in UserDeleteW32Thread
         */
        if (ptiCurrent->pq != NULL) {
            UserAssert(ptiCurrent->pq != ptiCurrent->pqAttach);
            DestroyThreadsMessages(ptiCurrent->pq, ptiCurrent);
            (ptiCurrent->pq->cLockCount)++;
            zzzDestroyQueue(ptiCurrent->pq, ptiCurrent);
        }

        /*
         * zzzReattachThreads shouldn't call back while using pqAttach
         */
        UserAssert(ptiCurrent->pqAttach == NULL);

        /*
         * Remove the pti from its pti list and reset the pointers.
         */
        if (ptiCurrent->rpdesk != NULL) {
            RemoveEntryList(&ptiCurrent->PtiLink);
            InitializeListHead(&ptiCurrent->PtiLink);
        }

        FreeMessageList(&ptiCurrent->mlPost);

        /*
         * Free any attachinfo structures pointing to this thread
         */
        ppai = &gpai;
        while ((*ppai) != NULL) {
            if ((*ppai)->pti1 == ptiCurrent || (*ppai)->pti2 == ptiCurrent) {
                PATTACHINFO paiKill = *ppai;
                *ppai = (*ppai)->paiNext;
                UserFreePool((HLOCAL)paiKill);
            } else {
                ppai = &(*ppai)->paiNext;
            }
        }

        /*
         * Change ownership of any objects that didn't get freed (because they
         * are locked or we have a bug and the object didn't get destroyed).
         */
        MarkThreadsObjects(ptiCurrent);

        /*
         * Free thread information visible from client
         */
        if (rpdesk && ptiCurrent->pcti != NULL && ptiCurrent->pcti != &(ptiCurrent->cti)) {
            DesktopFree(rpdesk, ptiCurrent->pcti);
            ptiCurrent->pcti = &(ptiCurrent->cti);
        }

        /*
         * Free the client info for system threads.
         */
        if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD && ptiCurrent->pClientInfo != NULL) {
            UserFreePool(ptiCurrent->pClientInfo);
            ptiCurrent->pClientInfo = NULL;
        }

        /*
         * Unlock the temporary desktop lock. ptiCurrent->rpdesk is still locked
         * and will be unlocked in UserDeleteW32Thread.
         */
        UnlockDesktop(&rpdesk, LDU_FN_DESTROYTHREADINFO, (ULONG_PTR)PtiCurrent());
    }

    /*
     * One more thread died.
     */
    gdwGuiThreads--;
}


/***************************************************************************\
* CleanEventMessage
*
* This routine takes a message and destroys and event message related pieces,
* which may be allocated.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/
VOID CleanEventMessage(
    PQMSG pqmsg)
{
    PASYNCSENDMSG pmsg;

    /*
     * Certain special messages on the INPUT queue have associated
     * bits of memory that need to be freed.
     */
    switch (pqmsg->dwQEvent) {
    case QEVENT_SETWINDOWPOS:
        UserFreePool((PSMWP)pqmsg->msg.wParam);
        break;

    case QEVENT_UPDATEKEYSTATE:
        UserFreePool((PBYTE)pqmsg->msg.wParam);
        break;

    case QEVENT_NOTIFYWINEVENT:
        DestroyNotify((PNOTIFY)pqmsg->msg.lParam);
        break;

    case QEVENT_ASYNCSENDMSG:
        pmsg = (PASYNCSENDMSG)pqmsg->msg.wParam;
        UserDeleteAtom((ATOM)pmsg->lParam);
        UserFreePool(pmsg);
        break;
    }
}

/***************************************************************************\
* FreeMessageList
*
* History:
* 02-27-91  mikeke      Created.
* 11-03-92  scottlu     Changed to work with MLIST structure.
\***************************************************************************/
VOID FreeMessageList(
    PMLIST pml)
{
    PQMSG pqmsg;

    DebugValidateMLIST(pml);

    while ((pqmsg = pml->pqmsgRead) != NULL) {
        CleanEventMessage(pqmsg);
        DelQEntry(pml, pqmsg);
    }

    DebugValidateMLIST(pml);
}

/***************************************************************************\
* DestroyThreadsMessages
*
* History:
* 02-21-96  jerrysh     Created.
\***************************************************************************/
VOID DestroyThreadsMessages(
    PQ pq,
    PTHREADINFO pti)
{
    PQMSG pqmsg;
    PQMSG pqmsgNext;

    DebugValidateMLIST(&pq->mlInput);

    pqmsg = pq->mlInput.pqmsgRead;
    while (pqmsg != NULL) {
        pqmsgNext = pqmsg->pqmsgNext;
        if (pqmsg->pti == pti) {
            /*
             * Make sure we don't leave any bogus references to this message
             * lying around.
             */
            if (pq->idSysPeek == (ULONG_PTR)pqmsg) {
                CheckPtiSysPeek(8, pq, 0);
                pq->idSysPeek = 0;
            }
            CleanEventMessage(pqmsg);
            DelQEntry(&pq->mlInput, pqmsg);
        }
        pqmsg = pqmsgNext;
    }

    DebugValidateMLIST(&pq->mlInput);
}

/***************************************************************************\
* InitQEntryLookaside
*
* Initializes the Q entry lookaside list. This improves Q entry locality
* by keeping Q entries in a single page
*
* 09-09-93  Markl   Created.
\***************************************************************************/
NTSTATUS
InitQEntryLookaside(
    VOID)
{
    QEntryLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                               TAG_LOOKASIDE);
    if (QEntryLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(QEntryLookaside,
                                   NULL,
                                   NULL,
                                   gSessionPoolMask,
                                   sizeof(QMSG),
                                   TAG_QMSG,
                                   16);

    QLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                          TAG_LOOKASIDE);
    if (QLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(QLookaside,
                                   NULL,
                                   NULL,
                                   gSessionPoolMask,
                                   sizeof(Q),
                                   TAG_Q,
                                   16);
    return STATUS_SUCCESS;
}

/***************************************************************************\
* AllocQEntry
*
* Allocates a message on a message list. DelQEntry deletes a message
* on a message list.
*
* 10-22-92 ScottLu      Created.
\***************************************************************************/

PQMSG AllocQEntry(
    PMLIST pml)
{
    PQMSG pqmsg;

    DebugValidateMLIST(pml);

    if (pml->cMsgs >= gUserPostMessageLimit) {
        RIPERR3(ERROR_NOT_ENOUGH_QUOTA, RIP_VERBOSE, "AllocQEntry: # of post messages exceeds the limit(%d) in pti=%#p, pml=%#p",
               gUserPostMessageLimit, W32GetCurrentThread(), pml);
        return NULL;
    }

    /*
     * Allocate a Q message structure.
     */
    if ((pqmsg = ExAllocateFromPagedLookasideList(QEntryLookaside)) == NULL) {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_VERBOSE, "AllocQEntry: allocation failed, not enough memory");
        return NULL;
    }

    RtlZeroMemory(pqmsg, sizeof(*pqmsg));

    if (pml->pqmsgWriteLast != NULL) {
        pml->pqmsgWriteLast->pqmsgNext = pqmsg;
        pqmsg->pqmsgPrev = pml->pqmsgWriteLast;
        pml->pqmsgWriteLast = pqmsg;
    } else {
        pml->pqmsgWriteLast = pml->pqmsgRead = pqmsg;
    }

    pml->cMsgs++;

    DebugValidateMLISTandQMSG(pml, pqmsg);

    return pqmsg;
}

/***************************************************************************\
* DelQEntry
*
* Simply removes a message from a message queue list.
*
* 10-20-92 ScottLu      Created.
\***************************************************************************/
VOID DelQEntry(
    PMLIST pml,
    PQMSG pqmsg)
{
    DebugValidateMLISTandQMSG(pml, pqmsg);
    UserAssert((int)pml->cMsgs > 0);
    UserAssert(pml->pqmsgRead);
    UserAssert(pml->pqmsgWriteLast);

    /*
     * Unlink this pqmsg from the message list.
     */
    if (pqmsg->pqmsgPrev != NULL)
        pqmsg->pqmsgPrev->pqmsgNext = pqmsg->pqmsgNext;

    if (pqmsg->pqmsgNext != NULL)
        pqmsg->pqmsgNext->pqmsgPrev = pqmsg->pqmsgPrev;

    /*
     * Update the read/write pointers if necessary.
     */
    if (pml->pqmsgRead == pqmsg)
        pml->pqmsgRead = pqmsg->pqmsgNext;

    if (pml->pqmsgWriteLast == pqmsg)
        pml->pqmsgWriteLast = pqmsg->pqmsgPrev;

    /*
     * Adjust the message count and free the message structure.
     */
    pml->cMsgs--;

    ExFreeToPagedLookasideList(QEntryLookaside, pqmsg);

    DebugValidateMLIST(pml);
}

/***************************************************************************\
* CheckRemoveHotkeyBit
*
* We have a special bit for the WM_HOTKEY message - QS_HOTKEY. When there
* is a WM_HOTKEY message in the queue, that bit is on. When there isn't,
* that bit is off. This checks for more than one hot key, because the one
* is about to be deleted. If there is only one, the hot key bits are cleared.
*
* 11-12-92 ScottLu      Created.
\***************************************************************************/
VOID CheckRemoveHotkeyBit(
    PTHREADINFO pti,
    PMLIST pml)
{
    PQMSG pqmsg;
    DWORD cHotkeys;

    /*
     * Remove the QS_HOTKEY bit if there is only one WM_HOTKEY message
     * in this message list.
     */
    cHotkeys = 0;
    for (pqmsg = pml->pqmsgRead; pqmsg != NULL; pqmsg = pqmsg->pqmsgNext) {
        if (pqmsg->msg.message == WM_HOTKEY)
            cHotkeys++;
    }

    /*
     * If there is 1 or fewer hot keys, remove the hotkey bits.
     */
    if (cHotkeys <= 1) {
        pti->pcti->fsWakeBits &= ~QS_HOTKEY;
        pti->pcti->fsChangeBits &= ~QS_HOTKEY;
    }
}

/***************************************************************************\
* FindQMsg
*
* Finds a qmsg that fits the filters by looping through the message list.
*
* 10-20-92 ScottLu      Created.
* 06-06-97 CLupu        added processing for WM_DDE_ACK messages
\***************************************************************************/

PQMSG FindQMsg(
    PTHREADINFO pti,
    PMLIST pml,
    PWND pwndFilter,
    UINT msgMin,
    UINT msgMax,
    BOOL bProcessAck)
{
    PWND pwnd;
    PQMSG pqmsgRead;
    PQMSG pqmsgRet = NULL;
    UINT message;

    DebugValidateMLIST(pml);

    pqmsgRead = pml->pqmsgRead;

    while (pqmsgRead != NULL) {

        /*
         * Make sure this window is valid and doesn't have the destroy
         * bit set (don't want to send it to any client side window procs
         * if destroy window has been called on it).
         */
        pwnd = RevalidateHwnd(pqmsgRead->msg.hwnd);

        if (pwnd == NULL && pqmsgRead->msg.hwnd != NULL) {
            /*
             * If we're removing a WM_HOTKEY message, we may need to
             * clear the QS_HOTKEY bit, since we have a special bit
             * for that message.
             */
            if (pqmsgRead->msg.message == WM_HOTKEY) {
                CheckRemoveHotkeyBit(pti, pml);
            }
            /*
             * If the current thread's queue is locked waiting for this message,
             *  we have to unlock it because we're eating the message. If there's
             *  no more input/messages for this thread, the thread is going to
             *  sleep; hence there might not be a next Get/PeekMessage call to
             *  unlock the queue (ie, updating pti->idLast is not enough);
             *  so we must unlock it now.
             * Win95 doesn't have this problem because their FindQMsg doesn't
             *  eat messages; they call ReadPostMessage from FreeWindow
             *  to take care of this scenario (== message for a destroyed window).
             *  We could also do this if we have some problems with this fix.
             */
            if ((pti->pq->idSysLock == (ULONG_PTR)pqmsgRead)
                    && (pti->pq->ptiSysLock == pti)) {
                /* CheckSysLock(What number?, pti->pq, NULL); */
                RIPMSG2(RIP_VERBOSE, "FindQMsg: Unlocking queue:%#p. Msg:%#lx",
                                        pti->pq, pqmsgRead->msg.message);
                pti->pq->ptiSysLock = NULL;
            }

            DelQEntry(pml, pqmsgRead);
            goto nextMsgFromPml;
        }

        /*
         * Process the WM_DDE_ACK messages if bProcessAck is set.
         */
        if (bProcessAck && (PtoH(pwndFilter) == pqmsgRead->msg.hwnd) &&
            (pqmsgRead->msg.message == (WM_DDE_ACK | MSGFLAG_DDE_MID_THUNK))) {

            PXSTATE pxs;

            pxs = (PXSTATE)HMValidateHandleNoRip((HANDLE)pqmsgRead->msg.lParam, TYPE_DDEXACT);

            if (pxs != NULL && (pxs->flags & XS_FREEPXS)) {
                FreeDdeXact(pxs);
                DelQEntry(pml, pqmsgRead);
                goto nextMsgFromPml;
            }
        }

        /*
         * Make sure this message fits both window handle and message
         * filters.
         */
        if (!CheckPwndFilter(pwnd, pwndFilter))
            goto nextMsg;

        /*
         * If this is a fixed up dde message, then turn it into a normal
         * dde message for the sake of message filtering.
         */
        message = pqmsgRead->msg.message;
        if (CheckMsgFilter(message,
                (WM_DDE_FIRST + 1) | MSGFLAG_DDE_MID_THUNK,
                WM_DDE_LAST | MSGFLAG_DDE_MID_THUNK)) {
            message = message & ~MSGFLAG_DDE_MID_THUNK;
        }

        if (!CheckMsgFilter(message, msgMin, msgMax))
            goto nextMsg;

        /*
         * Found it. If bProcessAck is set, remember this pointer and go on
         * till we finish walking the list to process all WM_DDE_ACK messages.
         */
        if (!bProcessAck) {
            DebugValidateMLIST(pml);
            return pqmsgRead;
        }

        if (pqmsgRet == NULL) {
            pqmsgRet = pqmsgRead;
        }
nextMsg:
        pqmsgRead = pqmsgRead->pqmsgNext;
        continue;

nextMsgFromPml:
        pqmsgRead = pml->pqmsgRead;
        continue;
    }

    DebugValidateMLIST(pml);
    return pqmsgRet;
}

/***************************************************************************\
* CheckQuitMessage
*
* Checks to see if a WM_QUIT message should be generated.
*
* 11-06-92 ScottLu      Created.
\***************************************************************************/
BOOL CheckQuitMessage(
    PTHREADINFO pti,
    LPMSG lpMsg,
    BOOL fRemoveMsg)
{
    /*
     * If there are no more posted messages in the queue and the app
     * has already called PostQuitMessage, then generate a quit.
     */
    if ((pti->TIF_flags & TIF_QUITPOSTED) && pti->mlPost.cMsgs == 0) {
        /*
         * If we're "removing" the quit, clear TIF_QUITPOSTED so another one
         * isn't generated.
         */
        if (fRemoveMsg) {
            pti->TIF_flags &= ~TIF_QUITPOSTED;
        }
        StoreMessage(lpMsg, NULL, WM_QUIT, (DWORD)pti->exitCode, 0, 0);
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* ReadPostMessage
*
* If queue is not empty, read message satisfying filter conditions from
* this queue to *lpMsg.
*
* 10-19-92 ScottLu      Created.
\***************************************************************************/
BOOL xxxReadPostMessage(
    PTHREADINFO pti,
    LPMSG lpMsg,
    PWND pwndFilter,
    UINT msgMin,
    UINT msgMax,
    BOOL fRemoveMsg)
{
    PQMSG pqmsg;
    PMLIST pmlPost;

    /*
     * Check to see if it is time to generate a quit message.
     */
    if (CheckQuitMessage(pti, lpMsg, fRemoveMsg)) {
        return TRUE;
    }

    /*
     * Loop through the messages in this list looking for the one that
     * fits the passed in filters.
     */
    pmlPost = &pti->mlPost;
    pqmsg = FindQMsg(pti, pmlPost, pwndFilter, msgMin, msgMax, FALSE);
    if (pqmsg == NULL) {
        /*
         * Check again for quit... FindQMsg deletes some messages
         * in some instances, so we may match the conditions
         * for quit generation here.
         */
        if (CheckQuitMessage(pti, lpMsg, fRemoveMsg)) {
            return TRUE;
        }
    } else {
        /*
         * Update the thread info fields with the info from this qmsg.
         */
        pti->timeLast = pqmsg->msg.time;
        if (!RtlEqualMemory(&pti->ptLast, &pqmsg->msg.pt, sizeof(POINT))) {
            pti->TIF_flags |= TIF_MSGPOSCHANGED;
        }
        pti->ptLast = pqmsg->msg.pt;

        pti->idLast = (ULONG_PTR)pqmsg;
        pti->pq->ExtraInfo = pqmsg->ExtraInfo;

        /*
         * Are we supposed to yank out the message? If not, stick some
         * random id into idLast so we don't unlock the input queue until we
         * pull this message from the queue.
         */
        *lpMsg = pqmsg->msg;
        if (!fRemoveMsg) {
            pti->idLast = 1;
        } else {
            /*
             * If we're removing a WM_HOTKEY message, we may need to
             * clear the QS_HOTKEY bit, since we have a special bit
             * for that message.
             */
            if (pmlPost->pqmsgRead->msg.message == WM_HOTKEY) {
                CheckRemoveHotkeyBit(pti, pmlPost);
            }


            /*
             * Since we're removing an event from the queue, we
             * need to check priority. This resets the TIF_SPINNING
             * since we're no longer spinning.
             */
            if (pti->TIF_flags & TIF_SPINNING) {
                if (!NT_SUCCESS(CheckProcessForeground(pti))) {
                    return FALSE;
                }
            }

            DelQEntry(pmlPost, pqmsg);
        }

        /*
         * See if this is a dde message that needs to be fixed up.
         */
        if (CheckMsgFilter(lpMsg->message,
                (WM_DDE_FIRST + 1) | MSGFLAG_DDE_MID_THUNK,
                WM_DDE_LAST | MSGFLAG_DDE_MID_THUNK)) {
            /*
             * Fixup the message value.
             */
            lpMsg->message &= (UINT)~MSGFLAG_DDE_MID_THUNK;

            /*
             * Call back the client to allocate the dde data for this message.
             */
            xxxDDETrackGetMessageHook(lpMsg);

            /*
             * Copy these values back into the queue if this message hasn't
             * been removed from the queue. Need to search through the
             * queue again because the pqmsg may have been removed when
             * we left the critical section above.
             */
            if (!fRemoveMsg) {
                if (pqmsg == FindQMsg(pti, pmlPost, pwndFilter, msgMin, msgMax, FALSE)) {
                    pqmsg->msg = *lpMsg;
                }
            }
        }
#if DBG
        else if (CheckMsgFilter(lpMsg->message, WM_DDE_FIRST, WM_DDE_LAST)) {
            if (fRemoveMsg) {
                TraceDdeMsg(lpMsg->message, (HWND)lpMsg->wParam, lpMsg->hwnd, MSG_RECV);
            } else {
                TraceDdeMsg(lpMsg->message, (HWND)lpMsg->wParam, lpMsg->hwnd, MSG_PEEK);
            }
        }
#endif
    }

    /*
     * If there are no posted messages available, clear the post message
     * bit so we don't go looking for them again.
     */
    if (pmlPost->cMsgs == 0 && !(pti->TIF_flags & TIF_QUITPOSTED)) {
        pti->pcti->fsWakeBits &= ~(QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
        pti->pcti->fsChangeBits &= ~QS_ALLPOSTMESSAGE;
    }

    return pqmsg != NULL;
}

#ifdef HUNGAPP_GHOSTING
/***************************************************************************\
* xxxProcessHungThreadEvent
*
* We check when a thread gets unhung when it reads the posted queue message.
*
* 6-10-99   vadimg      created
\***************************************************************************/
VOID xxxProcessHungThreadEvent(
    PWND pwnd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndGhost;
    HWND hwnd, hwndGhost;
    TL tlpwndT1, tlpwndT2;
    BOOL fUnlockGhost = FALSE;

    CheckLock(pwnd);

    /*
     * The app processed this queue message, so update time last read
     * used for hung app calculations.
     */
    SET_TIME_LAST_READ(ptiCurrent);

    pwndGhost = FindGhost(pwnd);

    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT1);

    if (pwndGhost != NULL) {
        ThreadLockAlwaysWithPti(ptiCurrent, pwndGhost, &tlpwndT2);
        fUnlockGhost = TRUE;

        /*
         * Try to set the state of the hung window to the current state of
         * the ghost window.
         */
        if (TestWF(pwndGhost, WFMAXIMIZED)) {
            xxxMinMaximize(pwnd, SW_MAXIMIZE, MINMAX_KEEPHIDDEN);
        } else if (TestWF(pwndGhost, WFMINIMIZED)) {
            xxxMinMaximize(pwnd, SW_SHOWMINNOACTIVE, MINMAX_KEEPHIDDEN);
        } else {
            DWORD dwFlags;
            PTHREADINFO pti = GETPTI(pwndGhost);

            /*
             * If the ghost is the active foreground window, allow this
             * activation to bring the hung window to the foreground.
             */
            if (pti->pq == gpqForeground && pti->pq->spwndActive == pwndGhost) {
                dwFlags = 0;
                GETPTI(pwnd)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            } else {
                dwFlags = SWP_NOACTIVATE;
            }

            /*
             * Unless the user explicitly moved or sized the ghost window,
             * Don't copy it's location and size to the unhung window.
             * See bug#s 415519 and 413418
             */
            if (!GhostSizedOrMoved(pwnd)) {
                dwFlags |= (SWP_NOMOVE | SWP_NOSIZE) ;
            }
            /*
             * This will appropriately zorder, activate, and position the
             * hung window.
             */
            xxxSetWindowPos(pwnd, pwndGhost,
                    pwndGhost->rcWindow.left, pwndGhost->rcWindow.top,
                    pwndGhost->rcWindow.right - pwndGhost->rcWindow.left,
                    pwndGhost->rcWindow.bottom - pwndGhost->rcWindow.top,
                    dwFlags);
        }
    }

    /*
     * Toggle the visible bit of the hung window and remove the ghost window
     * corresponding to this previously hung window.
     */
    if (TestWF(pwnd, WEFGHOSTMAKEVISIBLE)) {
        SetVisible(pwnd, SV_SET);
    }
    RemoveGhost(pwnd);

    /*
     * Make the shell aware again of the hung window.
     */
    hwnd = PtoHq(pwnd);
    hwndGhost = PtoH(pwndGhost);
    PostShellHookMessages(HSHELL_WINDOWREPLACING, (LPARAM)hwnd);
    PostShellHookMessages(HSHELL_WINDOWREPLACED, (LPARAM)hwndGhost);
    xxxCallHook(HSHELL_WINDOWREPLACED, (WPARAM)hwndGhost, (LPARAM)hwnd, WH_SHELL);

    /*
     * Completely invalidate the hung window, since it became visible again.
     */
    if (TestWF(pwnd, WEFGHOSTMAKEVISIBLE)) {
        xxxRedrawWindow(pwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE |
                RDW_ALLCHILDREN | RDW_FRAME);
    }
    if (fUnlockGhost) {
        ThreadUnlock(&tlpwndT2);
    }
    ThreadUnlock(&tlpwndT1);
}

#else // HUNGAPP_GHOSTING

VOID xxxProcessHungThreadEvent(
    PWND pwnd)
{
    CheckLock(pwnd);

    if (TestWF(pwnd, WFVISIBLE)) {
        RIPMSG0(RIP_WARNING, "xxxProcessHungThreadEvent: window is already visible");
    } else {
        SetVisible(pwnd, SV_SET);

        if (TestWF(pwnd, WFMINIMIZED)) {
            RIPMSG0(RIP_WARNING, "xxxProcessHungThreadEvent: window is already minmized");
        } else {
            xxxMinMaximize(pwnd, SW_SHOWMINNOACTIVE, MINMAX_KEEPHIDDEN);
        }
    }
}

#endif

#ifndef _WIN64
BEEPPROC pfnBP[] = {
    UpSiren,
    DownSiren,
    LowBeep,
    HighBeep,
    KeyClick};
#endif

/***************************************************************************\
* xxxProcessEventMessage
*
* This handles our processing for 'event' messages. We return a BOOL here
* telling the system whether or not to continue processing messages.
*
* History:
* 06-17-91 DavidPe      Created.
\***************************************************************************/
VOID xxxProcessEventMessage(
    PTHREADINFO ptiCurrent,
    PQMSG pqmsg)
{
    PWND pwnd;
    TL tlpwndT;
    TL tlMsg;
    PQ pq;

    UserAssert(IsWinEventNotifyDeferredOK());
    UserAssert(ptiCurrent == PtiCurrent());

    ThreadLockPoolCleanup(ptiCurrent, pqmsg, &tlMsg, CleanEventMessage);

    pq = ptiCurrent->pq;
    switch (pqmsg->dwQEvent) {
    case QEVENT_DESTROYWINDOW:
        /*
         * These events are posted from xxxDW_DestroyOwnedWindows
         * for owned windows that are not owned by the owner
         * window thread.
         */
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.wParam);
        if (pwnd != NULL) {
            if (!TestWF(pwnd, WFCHILD)) {
                xxxDestroyWindow(pwnd);
            } else {
                ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
                xxxFreeWindow(pwnd, &tlpwndT);
            }
        }
        break;

    case QEVENT_SHOWWINDOW:
        /*
         * These events are mainly used from within CascadeChildWindows()
         * and TileChildWindows() so that taskmgr doesn't hang while calling
         * these apis if it is trying to tile or cascade a hung application.
         */
        /* The HIWORD of lParam now has the preserved state of gfAnimate at the
         * time of the call.
         */
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.wParam);
        if (pwnd != NULL && !TestWF(pwnd, WFINDESTROY)) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxShowWindow(pwnd, (DWORD)pqmsg->msg.lParam);
            /*
             * If this is coming from an async SetWindowPlacement, update the
             *  check point settings if the window is minimized.
             */
            if ((pqmsg->msg.message & WPF_ASYNCWINDOWPLACEMENT)
                    && TestWF(pwnd, WFMINIMIZED)) {

                WPUpdateCheckPointSettings(pwnd, (UINT)pqmsg->msg.message);
            }
            ThreadUnlock(&tlpwndT);
        }
        break;

    case QEVENT_NOTIFYWINEVENT:
        UserAssert(((PNOTIFY)pqmsg->msg.lParam)->dwWEFlags & WEF_POSTED);
        UserAssert(((PNOTIFY)pqmsg->msg.lParam)->dwWEFlags & WEF_ASYNC);
        xxxProcessNotifyWinEvent((PNOTIFY)pqmsg->msg.lParam);
        break;

    case QEVENT_SETWINDOWPOS:
        /*
         * QEVENT_SETWINDOWPOS events are generated when a thread calls
         * SetWindowPos with a list of windows owned by threads other than
         * itself. This way all WINDOWPOSing on a window is done the thread
         * that owns (created) the window and we don't have any of those
         * nasty inter-thread synchronization problems.
         */
        xxxProcessSetWindowPosEvent((PSMWP)pqmsg->msg.wParam);
        break;

    case QEVENT_UPDATEKEYSTATE:
        /*
         * Update the local key state with the state from those
         * keys that have changed since the last time key state
         * was synchronized.
         */
        ProcessUpdateKeyStateEvent(pq, (PBYTE)pqmsg->msg.wParam, (PBYTE)pqmsg->msg.wParam + CBKEYSTATE);
        break;

    case QEVENT_ACTIVATE:
    {
        if (pqmsg->msg.lParam == 0) {

            /*
             * Clear any visible tracking going on in system. We
             * only bother to do this if lParam == 0 since
             * xxxSetForegroundWindow2() deals with this in the
             * other case.
             */
            xxxCancelTracking();

            /*
             * Remove the clip cursor rectangle - it is a global mode that
             * gets removed when switching. Also remove any LockWindowUpdate()
             * that's still around.
             */
            zzzClipCursor(NULL);
            LockWindowUpdate2(NULL, TRUE);

            /*
             * Reload pq because it may have changed.
             */
            pq = ptiCurrent->pq;

            /*
             * If this event didn't originate from an initializing app
             * coming to the foreground [wParam == 0] then go ahead
             * and check if there's already an active window and if so make
             * it visually active. Also make sure we're still the foreground
             * queue.
             */
            if ((pqmsg->msg.wParam != 0) && (pq->spwndActive != NULL) &&
                    (pq == gpqForeground)) {
                PWND pwndActive;

                ThreadLockAlwaysWithPti(ptiCurrent, pwndActive = pq->spwndActive, &tlpwndT);
                xxxSendMessage(pwndActive, WM_NCACTIVATE, TRUE, 0);
                xxxUpdateTray(pwndActive);
                xxxSetWindowPos(pwndActive, PWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
                ThreadUnlock(&tlpwndT);
            } else if (pq != gpqForeground) {

                /*
                 * If we're not being activated, make sure we don't become foreground.
                 */
                ptiCurrent->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "xxxProcessEventMessage clear TIF %#p", ptiCurrent);
                ptiCurrent->ppi->W32PF_Flags &= ~W32PF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "xxxProcessEventMessage clear W32PF %#p", ptiCurrent->ppi);
            }

        } else {

            pwnd = RevalidateHwnd((HWND)pqmsg->msg.lParam);
            if (pwnd == NULL)
                break;

            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);

            /*
             * If nobody is foreground, allow this app to become foreground.
             */
            if (gpqForeground == NULL) {
                xxxSetForegroundWindow2(pwnd, ptiCurrent, 0);
            } else {
                if (pwnd != pq->spwndActive) {
                    if (xxxActivateThisWindow(pwnd, (UINT)pqmsg->msg.wParam,
                            (ATW_SETFOCUS | ATW_ASYNC) |
                            ((pqmsg->msg.message & PEM_ACTIVATE_NOZORDER) ? ATW_NOZORDER : 0))) {

                        /*
                         * This event was posted by SetForegroundWindow2
                         * (i.e. pqmsg->msg.lParam != 0) so make sure
                         * mouse is on this window.
                         */
                        if (TestUP(ACTIVEWINDOWTRACKING)) {
                            zzzActiveCursorTracking(pwnd);
                        }
                    }
                } else {
                    BOOL fActive = (GETPTI(pwnd)->pq == gpqForeground);

                    xxxSendMessage(pwnd, WM_NCACTIVATE,
                            (DWORD)(fActive), 0);
                    if (fActive) {
                        xxxUpdateTray(pwnd);
                    }

                    /*
                     * Only bring the window to the top if it is becoming active.
                     */
                    if (fActive && !(pqmsg->msg.message & PEM_ACTIVATE_NOZORDER))
                        xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0,
                                SWP_NOSIZE | SWP_NOMOVE);
                }
            }

            /*
             * Check here to see if the window needs to be restored. This is a
             * hack so that we're compatible with what msmail expects out of
             * win3.1 alt-tab. msmail expects to always be active when it gets
             * asked to be restored. This will ensure that during alt-tab
             * activate.
             */
            if (pqmsg->msg.message & PEM_ACTIVATE_RESTORE) {
                if (TestWF(pwnd, WFMINIMIZED)) {
                    _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                }
            }

            ThreadUnlock(&tlpwndT);
        }

    }
        break;

    case QEVENT_DEACTIVATE:
        xxxDeactivate(ptiCurrent, (DWORD)pqmsg->msg.wParam);
        break;

    case QEVENT_CANCELMODE:
        if (pq->spwndCapture != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pq->spwndCapture, &tlpwndT);
            xxxSendMessage(pq->spwndCapture, WM_CANCELMODE, 0, 0);
            ThreadUnlock(&tlpwndT);

            /*
             * Set QS_MOUSEMOVE so any sleeping modal loops,
             * like the move/size code, will wake up and figure
             * out that it should abort.
             */
            SetWakeBit(ptiCurrent, QS_MOUSEMOVE);
        }
        break;


    case QEVENT_POSTMESSAGE:
        /*
         * This event is used in situations where we need to ensure that posted
         * messages are processed after previous QEVENT's. Normally, posting a
         * queue event and then calling postmessage will result in the posted
         * message being seen first by the app (because posted messages are
         * processed before input.) Instead we will post a QEVENT_POSTMESSAGE
         * instead of doing a postmessage directly, which will result in the
         * correct ordering of messages.
         *
         */

        if (pwnd = RevalidateHwnd((HWND)pqmsg->msg.hwnd)) {

            _PostMessage(pwnd,pqmsg->msg.message,pqmsg->msg.wParam,pqmsg->msg.lParam);
        }
        break;


    case QEVENT_ASYNCSENDMSG:
        xxxProcessAsyncSendMessage((PASYNCSENDMSG)pqmsg->msg.wParam);
        break;

    case QEVENT_HUNGTHREAD:
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.hwnd);
        if (pwnd != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxProcessHungThreadEvent(pwnd);
            ThreadUnlock(&tlpwndT);
        }
        break;

    case QEVENT_CANCELMOUSEMOVETRK: {
        /*
         * hwnd: hwndTrack. message: dwDTFlags.
         * wParam: htEx. lParam: dwDTCancel
         */
        PDESKTOP pdesk = ptiCurrent->rpdesk;
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.hwnd);
        /*
         * Let's check that the app didn't manage to restart mouse leave
         *  tracking before we had a chance to cancel it.
         */
        UserAssert(!(pqmsg->msg.message & DF_TRACKMOUSELEAVE)
                    || !(pdesk->dwDTFlags & DF_TRACKMOUSELEAVE)
                    || (PtoHq(pdesk->spwndTrack) != pqmsg->msg.hwnd)
                    || !((pdesk->htEx == HTCLIENT) ^ ((int)pqmsg->msg.wParam == HTCLIENT)));
        /*
         * If we're back tracking at the same spot, bail
         */
        if ((pdesk->dwDTFlags & DF_MOUSEMOVETRK)
                && (PtoHq(pdesk->spwndTrack) == pqmsg->msg.hwnd)
                && (pdesk->htEx == (int)pqmsg->msg.wParam)) {
            /*
             * If we're tracking mouse leave,
             */
            break;
        }
        /*
         * Don't nuke the tooltip if it has been reactivated.
         */
        if (pdesk->dwDTFlags & DF_TOOLTIPACTIVE) {
            pqmsg->msg.lParam &= ~DF_TOOLTIP;
        }
        /*
         * Cancel tracking if the window is still around
         */
        if (pwnd != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxCancelMouseMoveTracking(pqmsg->msg.message, pwnd,
                                   (int)pqmsg->msg.wParam,
                                   (DWORD)pqmsg->msg.lParam);
            ThreadUnlock(&tlpwndT);
        } else if ((pqmsg->msg.lParam & DF_TOOLTIP)
                && (pqmsg->msg.message & DF_TOOLTIPSHOWING)) {
            /*
             * The window is gone and so must be tracking.
             * Just take care of the tooltip which is still showing.
             */
            pwnd = pdesk->spwndTooltip;
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxResetTooltip((PTOOLTIPWND)pwnd);
            ThreadUnlock(&tlpwndT);
        }
    }
    break;

    case QEVENT_RITACCESSIBILITY:
        if (IsHooked(ptiCurrent, WHF_SHELL)) {
            xxxCallHook((UINT)pqmsg->msg.wParam,
                        (WPARAM)pqmsg->msg.lParam,
                        (LPARAM)0,
                        WH_SHELL);
        }

        PostShellHookMessages((UINT)pqmsg->msg.wParam, pqmsg->msg.lParam);
        break;

    case QEVENT_RITSOUND:
        /*
         * This should only happen on the desktop thread.
         */

#ifndef _WIN64

        switch(pqmsg->msg.message) {
        case RITSOUND_UPSIREN:
        case RITSOUND_DOWNSIREN:
        case RITSOUND_LOWBEEP:
        case RITSOUND_HIGHBEEP:
        case RITSOUND_KEYCLICK:
            (pfnBP[pqmsg->msg.message])();
            break;

        case RITSOUND_DOBEEP:
            switch(pqmsg->msg.wParam) {
            case RITSOUND_UPSIREN:
            case RITSOUND_DOWNSIREN:
            case RITSOUND_LOWBEEP:
            case RITSOUND_HIGHBEEP:
            case RITSOUND_KEYCLICK:
                DoBeep(pfnBP[pqmsg->msg.wParam], (DWORD)pqmsg->msg.lParam);
            }
            break;
        }

#else
        {
            UINT uCount;
            UINT uSound;

            /*
             * The above code uses UserBeep() - which doesn't do anything
             * useful on Win64. (IA64 spec doesn't include a h/w speaker.)
             *
             * Instead, we post a message to WinLogon to ask it to play a sound
             * for us using the PlaySound.
             */

            /*
             * RITSOUND_DOBEEP is used to repeat a sound n times. It is currently
             * only used to repeat UPSIREN 2 or 3 times, for stickykeys, when the
             * right shift is held down for 12 and 16 seconds.
             */

            if (pqmsg->msg.message == RITSOUND_DOBEEP) {
                uSound = (UINT) pqmsg->msg.wParam;
                uCount = (UINT) pqmsg->msg.lParam;
                if (uCount > 5) {
                    uCount = 5;
                }
            } else {
                uSound = pqmsg->msg.message;
                uCount = 1;
            }

            if (gspwndLogonNotify != NULL) {
                while(uCount--) {
                    _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                             LOGON_PLAYEVENTSOUND, MAKELPARAM(uSound, ACCESS_SOUND_RANGE));
                }
            }

            /*
             *  Since PlaySound doesn't currently flash the window if SoundSentry
             *  is active, we have to do it ourselces here.
             *  (On 32-bit, UserBeep() takes care of doing that.)
             */
             _UserSoundSentryWorker();
        }

#endif

        break;

    case QEVENT_APPCOMMAND: {
        /*
         * qevent app commands so we can post a wm_appcommand to the queue
         */
        THREADINFO  *ptiWindowOwner;
        int         cmd;
        UINT        keystate;

        /*
         * Check the appcommand's are within reasonable ranges. If they aren't
         * then we have an internal consistency error since xxxKeyEvent should
         * have generated correct ones for us.
         */
        UserAssert(pqmsg->msg.lParam >= VK_APPCOMMAND_FIRST &&
                   pqmsg->msg.lParam <= VK_APPCOMMAND_LAST);

        /*
         * We need to work out which window to send to here. Using the same
         * rules as from xxxScanSysQueue:
         * Assign the input to the focus window. If there is no focus
         * window, assign it to the active window as a SYS message.
         */
        pwnd = ptiCurrent->pq->spwndFocus;
        if (!pwnd) {
            pwnd = ptiCurrent->pq->spwndActive;
            if (!pwnd) {
                /*
                 * At the moment we will just eat the message since we can't find a foreground q
                 * This follows the method that any other app (eg hidserv) would mimic to
                 * find the window to send to.
                 */
                break;
            }
        }

        /*
         * We don't want to block on another thread since the xxxSendMessage is a synchronous call
         * so we post the message to the queue of the window owner thread
         */
        ptiWindowOwner = GETPTI(pwnd);
        if (ptiCurrent != ptiWindowOwner) {
            /*
             * Post the event message to the window who should get it
             */
            PostEventMessage(ptiWindowOwner, ptiWindowOwner->pq, QEVENT_APPCOMMAND,
                             NULL, 0, (WPARAM)0, pqmsg->msg.lParam);

            /*
             * Break out of this since we've now posted the message to a
             * different q - we don't want to deal with it here.
             */
            break;
        }

        cmd = APPCOMMAND_FIRST + ((UINT)pqmsg->msg.lParam - VK_APPCOMMAND_FIRST);
        keystate = GetMouseKeyFlags(ptiWindowOwner->pq);
        pqmsg->msg.lParam = MAKELPARAM(keystate, cmd);


        /*
         * Generate a WM_APPCOMMAND message from the keyboard keys.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
        xxxSendMessage(pwnd, WM_APPCOMMAND, (WPARAM)HWq(pwnd), pqmsg->msg.lParam);
        ThreadUnlock(&tlpwndT);

        break;
    }
    default:
        RIPMSG1(RIP_ERROR,
                "xxxProcessEventMessage: Bad dwQEvent: 0x%x",
                pqmsg->dwQEvent);
        break;
    }

    ThreadUnlockPoolCleanup(ptiCurrent, &tlMsg);
}


#define QS_TEST_AND_CLEAR (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_SENDMESSAGE)
#define QS_TEST           (QS_MOUSEBUTTON | QS_KEY)

/***************************************************************************\
* _GetInputState (API)
*
* Returns the current input state for mouse buttons or keys.
*
* History:
* 11-06-90 DavidPe      Created.
\***************************************************************************/
BOOL _GetInputState(
    VOID)
{
    if (LOWORD(_GetQueueStatus(QS_TEST_AND_CLEAR)) & QS_TEST) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#undef QS_TEST_AND_CLEAR
#undef QS_TEST

/***************************************************************************\
* _GetQueueStatus (API)
*
* Returns the changebits in the lo-word and wakebits in
* the hi-word for the current queue.
*
* History:
* 12-17-90 DavidPe      Created.
\***************************************************************************/
DWORD _GetQueueStatus(
    UINT flags)
{
    PTHREADINFO ptiCurrent;
    UINT fsChangeBits;

    ptiCurrent = PtiCurrentShared();

    flags &= (QS_ALLINPUT | QS_ALLPOSTMESSAGE | QS_TRANSFER);

    fsChangeBits = ptiCurrent->pcti->fsChangeBits;

    /*
     * Clear out the change bits the app is looking at
     * so it'll know what changed since it's last call
     * to GetQueueStatus().
     */
    ptiCurrent->pcti->fsChangeBits &= ~flags;

    /*
     * Return the current change/wake-bits.
     */
    return MAKELONG(fsChangeBits & flags,
            (ptiCurrent->pcti->fsWakeBits | ptiCurrent->pcti->fsWakeBitsJournal) & flags);
}

/***************************************************************************\
* xxxMsgWaitForMultipleObjects (API)
*
* Blocks until an 'event' satisifying dwWakeMask occurs for the
* current thread as well as all other objects specified by the other
* parameters which are the same as the base call WaitForMultipleObjects().
*
* pfnNonMsg indicates that pHandles is big enough for nCount+1 handles
* (empty slot at end, and to call pfnNonMsg for non message events).
*
* History:
* 12-17-90 DavidPe      Created.
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxMsgWaitForMultipleObjects)
#endif

DWORD xxxMsgWaitForMultipleObjects(
    DWORD nCount,
    PVOID *apObjects,
    MSGWAITCALLBACK pfnNonMsg,
    PKWAIT_BLOCK WaitBlockArray)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    NTSTATUS Status;

    ptiCurrent = PtiCurrent();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Setup the wake mask for this thread. Wait for QS_EVENT or the app won't
     * get event messages like deactivate.
     */
    ClearQueueServerEvent(QS_ALLINPUT | QS_EVENT);

    /*
     * Stuff the event handle for the current queue at the end.
     */
    apObjects[nCount] = ptiCurrent->pEventQueueServer;

    /*
     * Check to see if any input came inbetween when we
     * last checked and the NtClearEvent() call.
     */
    if (!(ptiCurrent->pcti->fsChangeBits & QS_ALLINPUT)) {

        /*
         * This app is going idle. Clear the spin count check to see
         * if we need to make this process foreground again.
         */
        if (ptiCurrent->TIF_flags & TIF_SPINNING) {
            if (!NT_SUCCESS(Status = CheckProcessForeground(ptiCurrent))) {
                return Status;
            }
        }

        try {
            ptiCurrent->pClientInfo->cSpins = 0;
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
            return GetExceptionCode();
        }

        if (ptiCurrent == gptiForeground &&
                IsHooked(ptiCurrent, WHF_FOREGROUNDIDLE)) {
            xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);
        }

        /*
         * Set the input idle event to wake up any threads waiting
         * for this thread to go into idle state.
         */
        zzzWakeInputIdle(ptiCurrent);

Again:
        LeaveCrit();

        Status = KeWaitForMultipleObjects(nCount + 1, apObjects,
                WaitAny, WrUserRequest,
                UserMode, FALSE,
                NULL, WaitBlockArray);

        EnterCrit();

        UserAssert(NT_SUCCESS(Status));

        if (Status == STATUS_WAIT_0 && pfnNonMsg != NULL) {
            /*
             * Call pfnNonMsg for the first event
             */
            pfnNonMsg(DEVICE_TYPE_MOUSE);

            /*
             * Setup again the wake mask for this thread.
             * Wait for QS_EVENT or the app won't
             * get event messages like deactivate.
             */
            ptiCurrent->pcti->fsWakeMask = QS_ALLINPUT | QS_EVENT;
            goto Again;
        }

        if (Status == (NTSTATUS)(STATUS_WAIT_0 + nCount)) {

            /*
             * Reset the input idle event to block and threads waiting
             * for this thread to go into idle state.
             */
            SleepInputIdle(ptiCurrent);
        }
    } else {
        Status = nCount;
    }

    /*
     * Clear fsWakeMask since we're no longer waiting on the queue.
     */
    ptiCurrent->pcti->fsWakeMask = 0;

    return (DWORD)Status;
}

/***************************************************************************\
* xxxSleepThread
*
* Blocks until an 'event' satisifying fsWakeMask occurs for the
* current thread.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/
BOOL xxxSleepThread(
    UINT fsWakeMask,
    DWORD Timeout,
    BOOL fInputIdle)
{
    PTHREADINFO ptiCurrent;
    LARGE_INTEGER li, *pli;
    NTSTATUS status = STATUS_SUCCESS;
    BOOL fExclusive = fsWakeMask & QS_EXCLUSIVE;
    WORD fsWakeMaskSaved;
    BOOL fRet = FALSE;

    UserAssert(IsWinEventNotifyDeferredOK());

    if (fExclusive) {
        /*
         * The exclusive bit is a 'dummy' arg, turn it off to
         * avoid any possible conflicts.
         */
        fsWakeMask = fsWakeMask & ~QS_EXCLUSIVE;
    }

    if (Timeout) {
        /*
         * Convert dwMilliseconds to a relative-time (i.e. negative)
         * LARGE_INTEGER. NT Base calls take time values in 100 nanosecond
         * units.
         */
        li.QuadPart = Int32x32To64(-10000, Timeout);
        pli = &li;
    } else {
        pli = NULL;
    }

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    fsWakeMaskSaved = ptiCurrent->pcti->fsWakeMask;

    while (TRUE) {

        /*
         * First check if the input has arrived.
         */
        if (ptiCurrent->pcti->fsChangeBits & fsWakeMask) {
            fRet = TRUE;

GetOutFromHere:
            /*
             * Restore the wake mask to what it was before we went to sleep
             * to allow possible callbacks before KeWait... but after the mask
             * has been set and also APCs from KeWait... to still be able to
             * wake up. Simply clearing the mask here if we're in such a
             * callback or in an APC means that the thread will never wake up.
             */
            ptiCurrent->pcti->fsWakeMask = fsWakeMaskSaved;

            if (fRet) {
                /*
                 * Update timeLastRead - it is used for hung app calculations.
                 * If the thread is waking up to process input, it isn't hung!
                 */
                SET_TIME_LAST_READ(ptiCurrent);
            }
            return fRet;
        }

        /*
         * Next check for SendMessages
         */
        if (!fExclusive && ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
            xxxReceiveMessages(ptiCurrent);

            /*
             * Restore the change bits we took out in PeekMessage()
             */
            ptiCurrent->pcti->fsChangeBits |= (ptiCurrent->pcti->fsWakeBits & ptiCurrent->fsChangeBitsRemoved);
            ptiCurrent->fsChangeBitsRemoved = 0;
        }

        /*
         * Check to see if some resources need expunging.
         * This will unload hook DLLs, including WinEvent ones.
         */
        if (ptiCurrent->ppi->cSysExpunge != gcSysExpunge) {
            ptiCurrent->ppi->cSysExpunge = gcSysExpunge;
            if (ptiCurrent->ppi->dwhmodLibLoadedMask & gdwSysExpungeMask)
                xxxDoSysExpunge(ptiCurrent);
        }

        /*
         * OR QS_SENDMESSAGE in since ReceiveMessage() will end up
         * trashing pq->fsWakeMask. Do the same for QS_SYSEXPUNGE.
         */
        ClearQueueServerEvent((WORD)(fsWakeMask | (fExclusive ? 0 : QS_SENDMESSAGE)));

        /*
         * If we have timed out then return our error to the caller.
         */
        if (status == STATUS_TIMEOUT) {
            RIPERR1(ERROR_TIMEOUT, RIP_VERBOSE, "SleepThread: The timeout has expired %lX", Timeout);
            UserAssert(fRet == FALSE);
            goto GetOutFromHere;
        }

        /*
         * Because we do a non-alertable wait, we know that a status
         * of STATUS_USER_APC means that the thread was terminated.
         * If we have terminated, get back to user mode.
         */
        if (status == STATUS_USER_APC) {
#if DBG
            if (ptiCurrent == gptiRit || ptiCurrent == gTermIO.ptiDesktop) {
                /*
                 * If STATUS_USER_APC is caught in the system threads,
                 * that most likely means the thread was terminated by
                 * someone inadvertently.
                 */
                RIPMSG1(RIP_WARNING, "xxxSleepThread: STATUS_USER_APC caught in the system thread pti=%p", ptiCurrent);
            }
#endif

            ClientDeliverUserApc();
            UserAssert(fRet == FALSE);
            goto GetOutFromHere;
        }

        /*
         * If this is the power state callout thread, we might need to bail
         * out early.
         */
        if (gPowerState.pEvent == ptiCurrent->pEventQueueServer) {
            if (gPowerState.fCritical) {
                UserAssert(fRet == FALSE);
                goto GetOutFromHere;
            }
        }

        UserAssert(status == STATUS_SUCCESS);
        /*
         * Check to see if any input came inbetween when we
         * last checked and the NtClearEvent() call.
         *
         * We call NtWaitForSingleObject() rather than
         * WaitForSingleObject() so we can set fAlertable
         * to TRUE and thus allow timer APCs to be processed.
         */
        if (!(ptiCurrent->pcti->fsChangeBits & ptiCurrent->pcti->fsWakeMask)) {
            /*
             * This app is going idle. Clear the spin count check to see
             * if we need to make this process foreground again.
             */
            if (fInputIdle) {
                if (ptiCurrent->TIF_flags & TIF_SPINNING) {
                    if (!NT_SUCCESS(CheckProcessForeground(ptiCurrent))) {
                        goto GetOutFromHere;
                    }
                }
                try {
                    ptiCurrent->pClientInfo->cSpins = 0;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto GetOutFromHere;
                }
            }


            if (!(ptiCurrent->TIF_flags & TIF_16BIT))  {
                if (fInputIdle && ptiCurrent == gptiForeground &&
                        IsHooked(ptiCurrent, WHF_FOREGROUNDIDLE)) {
                    xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);
                }

                /*
                 * Set the input idle event to wake up any threads waiting
                 * for this thread to go into idle state.
                 */
                if (fInputIdle) {
                    zzzWakeInputIdle(ptiCurrent);
                }

                xxxSleepTask(fInputIdle, NULL);

                LeaveCrit();
                status = KeWaitForSingleObject(ptiCurrent->pEventQueueServer,
                        WrUserRequest, UserMode, FALSE, pli);
                EnterCrit();

                /*
                 * Reset the input idle event to block and threads waiting
                 * for this thread to go into idle state.
                 */
                SleepInputIdle(ptiCurrent);

                /*
                 *  ptiCurrent is 16bit!
                 */
            } else {
                if (fInputIdle) {
                    zzzWakeInputIdle(ptiCurrent);
                }

                xxxSleepTask(fInputIdle, NULL);
            }
        }
    }
}


/***************************************************************************\
* SetWakeBit
*
* Adds the specified wake bit to specified THREADINFO and wakes its thread
* up if the bit is in its fsWakeMask.
*
* Nothing will happen in the system unless we come to this function, so be
* fast and small.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/
VOID SetWakeBit(
    PTHREADINFO pti,
    UINT wWakeBit)
{
    CheckCritIn();

    UserAssert(pti);

    /*
     * Win3.1 changes ptiKeyboard and ptiMouse accordingly if we're setting
     * those bits.
     */
    if (wWakeBit & QS_MOUSE) {
        pti->pq->ptiMouse = pti;
    }

#ifdef GENERIC_INPUT
    if (wWakeBit & (QS_KEY | QS_RAWINPUT)) {
        pti->pq->ptiKeyboard = pti;
    }
#else
    if (wWakeBit & QS_KEY) {
        pti->pq->ptiKeyboard = pti;
    }
#endif

    /*
     * OR in these bits - these bits represent what input this app has
     * (fsWakeBits), or what input has arrived since that last look
     * (fsChangeBits).
     */
    pti->pcti->fsWakeBits |= wWakeBit;
    pti->pcti->fsChangeBits |= wWakeBit;

    /*
     * Before waking, do screen saver check to see if it should
     * go away.
     */
    if ((wWakeBit & QS_INPUT)
            && (pti->ppi->W32PF_Flags & W32PF_IDLESCREENSAVER)) {
        if ((wWakeBit & QS_MOUSEMOVE)
            && (gpsi->ptCursor.x == gptSSCursor.x)
            && (gpsi->ptCursor.y == gptSSCursor.y)) {
            goto SkipScreenSaverStuff;
        }

        /*
         * Our idle screen saver needs to be given a priority boost so that it
         * can process input.
         */
        pti->ppi->W32PF_Flags &= ~W32PF_IDLESCREENSAVER;
        SetForegroundPriority(pti, TRUE);
    }

SkipScreenSaverStuff:
    if (wWakeBit & pti->pcti->fsWakeMask) {
        /*
         * Wake the Thread
         */
        if (pti->TIF_flags & TIF_16BIT) {
            pti->ptdb->nEvents++;
            gpsi->nEvents++;
            WakeWowTask(pti);
        } else {
            KeSetEvent(pti->pEventQueueServer, 2, FALSE);
        }
    }
}

/***************************************************************************\
* TransferWakeBit
*
* We have a mesasge from the system queue. If out input bit for this
* message isn't set, set ours and clear the guy whose bit was set
* because of this message.
*
* 10-22-92 ScottLu      Created.
\***************************************************************************/
VOID TransferWakeBit(
    PTHREADINFO pti,
    UINT message)
{
    PTHREADINFO ptiT;
    UINT fsMask;

    /*
     * Calculate the mask from the message range. Only interested
     * in hardware input here: mouse and keys.
     */
#ifdef GENERIC_INPUT
    fsMask = CalcWakeMask(message, message, 0) & QS_INPUT;
#else
    fsMask = CalcWakeMask(message, message, 0) & (QS_MOUSE | QS_KEY);
#endif

    /*
     * If it is set in this thread's wakebits, nothing to do.
     * Otherwise transfer them from the owner to this thread.
     */
    if (!(pti->pcti->fsWakeBits & fsMask)) {
        /*
         * Either mouse or key is set (not both). Remove this bit
         * from the thread that currently owns it, and change mouse /
         * key ownership to this thread.
         */
        if (fsMask & QS_KEY) {
            ptiT = pti->pq->ptiKeyboard;
            pti->pq->ptiKeyboard = pti;
        } else {
            ptiT = pti->pq->ptiMouse;
            pti->pq->ptiMouse = pti;
        }
        ptiT->pcti->fsWakeBits &= ~fsMask;

        /*
         * Transfer them to this thread (certainly this may be the
         * same thread for win32 threads not sharing queues).
         */
        pti->pcti->fsWakeBits |= fsMask;
        pti->pcti->fsChangeBits |= fsMask;
    }
}

/***************************************************************************\
* ClearWakeBit
*
* Clears wake bits. If fSysCheck is TRUE, this clears the input bits only
* if no messages are in the input queue. Otherwise, it clears input bits
* unconditionally.
*
* 11-05-92 ScottLu      Created.
\***************************************************************************/
VOID ClearWakeBit(
    PTHREADINFO pti,
    UINT wWakeBit,
    BOOL fSysCheck)
{
    /*
     * If fSysCheck is TRUE, clear bits only if we are not doing journal
     * playback and there are no more messages in the queue. fSysCheck
     * is TRUE if clearing because of no more input. FALSE if just
     * transfering input ownership from one thread to another.
     */
    if (fSysCheck) {
        if (pti->pq->mlInput.cMsgs != 0 || FJOURNALPLAYBACK()) {
            return;
        }
        if (pti->pq->QF_flags & QF_MOUSEMOVED) {
            wWakeBit &= ~QS_MOUSEMOVE;
        }
    }

    /*
     * Only clear the wake bits, not the change bits as well!
     */
    pti->pcti->fsWakeBits &= ~wWakeBit;
}



/***************************************************************************\
* PtiFromThreadId
*
* Returns the THREADINFO for the specified thread or NULL if thread
* doesn't exist or doesn't have a THREADINFO.
*
* History:
* 01-30-91  DavidPe     Created.
\***************************************************************************/
PTHREADINFO PtiFromThreadId(
    DWORD dwThreadId)
{
    PETHREAD pEThread;
    PTHREADINFO pti;

    if (!NT_SUCCESS(LockThreadByClientId(LongToHandle(dwThreadId), &pEThread))) {
        return NULL;
    }

    /*
     * If the thread is not terminating, look up the pti. This is
     * needed because the value returned by PtiFromThread() is
     * undefined if the thread is terminating. See PspExitThread in
     * ntos\ps\psdelete.c.
     */
    if (!PsIsThreadTerminating(pEThread)) {
        pti = PtiFromThread(pEThread);
    } else {
        pti = NULL;
    }

    /*
     * Do a sanity check on the pti to make sure it's really valid.
     */
    if (pti != NULL) {
        try {
            if (GETPTIID(pti) != LongToHandle(dwThreadId)) {
                pti = NULL;
            } else if (!(pti->TIF_flags & TIF_GUITHREADINITIALIZED)) {
                RIPMSG1(RIP_WARNING, "PtiFromThreadId: pti %#p not initialized", pti);
                pti = NULL;
            } else if (pti->TIF_flags & TIF_INCLEANUP) {
                RIPMSG1(RIP_WARNING, "PtiFromThreadId: pti %#p in cleanup", pti);
                pti = NULL;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            pti = NULL;
        }
    }

    UnlockThread(pEThread);

    return pti;
}


/***************************************************************************\
* StoreMessage
*
*
*
* History:
* 10-31-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
VOID StoreMessage(
    LPMSG pmsg,
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD time)
{
    CheckCritIn();

    pmsg->hwnd = HW(pwnd);
    pmsg->message = message;
    pmsg->wParam = wParam;
    pmsg->lParam = lParam;
    pmsg->time = (time != 0 ? time : NtGetTickCount());

    pmsg->pt = gpsi->ptCursor;
}


/***************************************************************************\
* StoreQMessage
*
* If 'time' is 0 grab the current time, if not, it means that this message
* is for an input event and eventually the mouse/keyboard hooks want to see
* the right time stamps.
*
* History:
* 02-27-91 DavidPe      Created.
* 06-15-96 CLupu        Add 'time' parameter
\***************************************************************************/
VOID StoreQMessage(
    PQMSG pqmsg,
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD time,
    DWORD dwQEvent,
    ULONG_PTR dwExtraInfo)
{
    CheckCritIn();

    pqmsg->msg.hwnd    = HW(pwnd);
    pqmsg->msg.message = message;
    pqmsg->msg.wParam  = wParam;
    pqmsg->msg.lParam  = lParam;
    pqmsg->msg.time    = (time == 0) ? NtGetTickCount() : time;

#ifdef REDIRECTION
    if (message >= WM_MOUSEFIRST && message <= WM_MOUSELAST) {
        pqmsg->msg.pt.x = LOWORD(lParam);
        pqmsg->msg.pt.y = HIWORD(lParam);
    } else {
        pqmsg->msg.pt = gpsi->ptCursor;
    }
#else
    pqmsg->msg.pt      = gpsi->ptCursor;
#endif
    pqmsg->dwQEvent    = dwQEvent;
    pqmsg->ExtraInfo   = dwExtraInfo;
}


/***************************************************************************\
* xxxInitProcessInfo
*
* This initializes the process info. Usually gets created before the
* CreateProcess() call returns (so we can synchronize with the starting
* process in several different ways).
*
* 09-18-91 ScottLu      Created.
\***************************************************************************/
NTSTATUS xxxInitProcessInfo(
    PW32PROCESS pwp)
{
    PPROCESSINFO ppi = (PPROCESSINFO)pwp;
    NTSTATUS Status;

    CheckCritIn();

    /*
     * Check if we need to initialize the process.
     */
    if (pwp->W32PF_Flags & W32PF_PROCESSCONNECTED) {
        return STATUS_ALREADY_WIN32;
    }
    pwp->W32PF_Flags |= W32PF_PROCESSCONNECTED;

#if defined(_WIN64)
    /* Tag as emulated 32bit. Flag is copied to be consistent with
     * the way WOW16 apps are tagged for win32k.
     */
    if (PsGetProcessWow64Process(pwp->Process)) {
        pwp->W32PF_Flags |= W32PF_WOW64;
    }
#endif

#ifdef GENERIC_INPUT
    UserAssert(ppi->pHidTable == NULL);
#endif

    /*
     * Mark this app as "starting" - it will be starting until its first
     * window activates.
     */
    UserVerify(xxxSetProcessInitState(pwp->Process, STARTF_FORCEOFFFEEDBACK));

    /*
     * link it into the starting processes list
     */
    SetAppStarting(ppi);
    /*
     * link it into the global processes list
     */
    ppi->ppiNextRunning = gppiList;
    gppiList = ppi;
    /*
     * If foreground activation has not been canceled and the parent process
     *  (or an ancestor) can force a foreground change, then allow this process
     *  to come to the foreground when it does its first activation.
     *
     * Bug 273518 - joejo
     *
     * This will allow console windows to set foreground correctly on new
     * process' it launches, as opposed it just forcing foreground.
     */
    if (TEST_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE) && CheckAllowForeground(pwp->Process)) {
        ppi->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
    }
    TAGMSG2(DBGTAG_FOREGROUND, "xxxInitProcessInfo %s W32PF %#p",
            ((ppi->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE) ? "set" : "NOT"),
            ppi);

    /*
     * Get the logon session id. This is used to determine which
     * windowstation to connect to and to identify attempts to
     * call hooks across security contexts.
     */
    Status = GetProcessLuid(NULL, &ppi->luidSession);
    UserAssert(NT_SUCCESS(Status));

    /*
     * Ensure that we're in sync with the expunge count
     */
    ppi->cSysExpunge = gcSysExpunge;

    /*
     * Don't perform any LPK callbacks until GDI notifies
     * us that the LPK(s) are loaded and initialized.
     */
    ppi->dwLpkEntryPoints = 0;

    return STATUS_SUCCESS;
}

/***************************************************************************\
* DestroyProcessInfo
*
* This function is executed when the last thread of a process goes
* away.
*
* SO VERY IMPORTANT:
* Note that the last thread of the process might not be a w32 thread. So do
* not make any calls here that assume a w32 pti. Do avoid any function calling
* PtiCurrent() as it probably assumes it is on a nice w32 thread.
*
* Also note that if the process is locked, the ppi is not going away; this
* simply means that execution on this process has ended. So make sure to clean
* up in a way that the ppi data is still valid (for example, if you free a
* pointer, set it to NULL).
*
* zzz Note: Not a zzz routine although it calls zzzCalcStartCursorHide() -
*           Since we can't make callbacks on a non-GUI thread, we use
*           DeferWinEventNotify() & EndDeferWinEventNotifyWithoutProcessing()
*           to prevent callbacks.
*
* 04/08/96 GerardoB     Added header
\***************************************************************************/
BOOL DestroyProcessInfo(
    PW32PROCESS pwp)
{
    PPROCESSINFO ppi = (PPROCESSINFO)pwp;
    PDESKTOPVIEW pdv, pdvNext;
    BOOL  fHadThreads;
    PPUBOBJ ppo;

    CheckCritIn();

    /*
     * Free up input idle event if it exists - wake everyone waiting on it
     * first. This object will get created sometimes even for non-windows
     * processes (usually for WinExec(), which calls WaitForInputIdle()).
     */
    CLOSE_PSEUDO_EVENT(&pwp->InputIdleEvent);

    /*
     * Check to see if the startglass is on, and if so turn it off and update.
     * DeferWinEventNotify to because we cannot process notifications for this
     * thread now (we may have no PtiCurrent, see comment above)
     */
    BEGINATOMICCHECK();
    DeferWinEventNotify();
    if (pwp->W32PF_Flags & W32PF_STARTGLASS) {
        pwp->W32PF_Flags &= ~W32PF_STARTGLASS;
        zzzCalcStartCursorHide(NULL, 0);
    }
    /*
     * This is bookkeeping - restore original notification deferral but without
     * attempting to process any deferred notifications because we have no pti.
     */
    EndDeferWinEventNotifyWithoutProcessing();
    ENDATOMICCHECK();

    /*
     * If the process never called Win32k, we're done.
     */
    if (!(pwp->W32PF_Flags & W32PF_PROCESSCONNECTED)) {
        return FALSE;
    }

#ifdef GENERIC_INPUT
    /*
     * Cleanup the HID devices this process has requested.
     */
    if (ppi->pHidTable) {
        DestroyProcessHidRequests(ppi);
    }
#endif

    /*
     * Play the Process Close sound for non-console processes
     * running on the I/O windowstation.
     */

    if ((ppi->W32PF_Flags & W32PF_IOWINSTA) &&
        !(ppi->W32PF_Flags & W32PF_CONSOLEAPPLICATION) &&
        (gspwndLogonNotify != NULL) &&
        !(ppi->rpwinsta->dwWSF_Flags & WSF_OPENLOCK)) {

        PTHREADINFO pti = GETPTI(gspwndLogonNotify);
        PQMSG pqmsg;

        if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {
            StoreQMessage(pqmsg, gspwndLogonNotify, WM_LOGONNOTIFY,
                    LOGON_PLAYEVENTSOUND, USER_SOUND_CLOSE, 0, 0, 0);

            SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
        }

    }

    /*
     * Be like WIN95.
     * If this is the shell process, then send a LOGON_RESTARTSHELL
     *  notification to the winlogon process (only if not logging off)
     */
    if (IsShellProcess(ppi)) {

        /*
         * The shell process will get killed and it's better to set this
         * in the desktop info.
         */
        ppi->rpdeskStartup->pDeskInfo->ppiShellProcess = NULL;

        /*
         * If we're not logging off, notify winlogon
         */
        if ((gspwndLogonNotify != NULL) &&
             !(ppi->rpwinsta->dwWSF_Flags & WSF_OPENLOCK)) {

            PTHREADINFO pti = GETPTI(gspwndLogonNotify);
            PQMSG pqmsg;

            if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {
                StoreQMessage(pqmsg, gspwndLogonNotify, WM_LOGONNOTIFY,
                        LOGON_RESTARTSHELL, PsGetProcessExitStatus(ppi->Process), 0, 0, 0);
                SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
            }
        }
    }

    if (ppi->cThreads) {
        RIPMSG1(RIP_ERROR,
                "Disconnect with 0x%x threads remaining",
                ppi->cThreads);
    }

    /*
     * If the app is still starting, remove it from the startup list
     */
    if (ppi->W32PF_Flags & W32PF_APPSTARTING) {
        /*
         * Bug 294193 - joejo
         *
         * Handle case when creator process exits before the child
         * process makes it to CheckAllowForeground code. This is typical with
         * stub EXEs that do nothing but create other processes.
         */
        GiveForegroundActivateRight(PsGetProcessId(ppi->Process));
        ClearAppStarting(ppi);
    }

    /*
     * remove it from the global list
     */
    REMOVE_FROM_LIST(PROCESSINFO, gppiList, ppi, ppiNextRunning);

    /*
     * If any threads ever connected, there may be DCs, classes,
     * cursors, etc. still lying around. If no threads connected
     * (which is the case for console apps), skip all of this cleanup.
     */
    fHadThreads = ppi->W32PF_Flags & W32PF_THREADCONNECTED;
    if (fHadThreads) {

        /*
         * When a process dies we need to make sure any DCE's it owns
         * and have not been deleted are cleanup up. The clean up
         * earlier may have failed if the DC was busy in GDI.
         */
        if (ppi->W32PF_Flags & W32PF_OWNDCCLEANUP) {
            DelayedDestroyCacheDC();
        }

#if DBG
        {
            PHE pheT, pheMax;

            /*
             * Loop through the table destroying all objects created by the current
             * process. All objects will get destroyed in their proper order simply
             * because of the object locking.
             */
            pheMax = &gSharedInfo.aheList[giheLast];
            for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

                /*
                 * We should have no process objects left for this process.
                 */
                UserAssertMsg0(
                        pheT->bFlags & HANDLEF_DESTROY ||
                        !(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) ||
                        (PPROCESSINFO)pheT->pOwner != ppi,
                        "We should have no process objects left for this process!");
            }
        }
#endif
    }

    if (pwp->UserHandleCount) {
        RIPMSG1(RIP_ERROR,
                "Disconnect with 0x%x User handle objects remaining",
                pwp->UserHandleCount);
    }

    /*
     * check if we need to zap PID's for DDE objects
     */
    for (ppo = gpPublicObjectList;
            ppo != NULL;
                ppo = ppo->next) {
        if (ppo->pid == pwp->W32Pid) {
            ppo->pid = OBJECT_OWNER_PUBLIC;
        }
    }


    if (gppiScreenSaver == ppi) {
        UserAssert(ppi->W32PF_Flags & W32PF_SCREENSAVER);

        gppiScreenSaver = NULL;
    }

    if (gppiForegroundOld == ppi) {
        gppiForegroundOld = NULL;
    }

    if (gppiUserApiHook == ppi) {
        _UnregisterUserApiHook();
    }

    UnlockWinSta(&ppi->rpwinsta);
    UnlockDesktop(&ppi->rpdeskStartup, LDU_PPI_DESKSTARTUP3, (ULONG_PTR)ppi);

    /*
     * Close the startup desktop handle now if it's still around. If we wait
     * until handle table cleanup time we could potentially deadlock.
     */
    if (ppi->hdeskStartup) {
        UserVerify(NT_SUCCESS(CloseProtectedHandle(ppi->hdeskStartup)));
        ppi->hdeskStartup = NULL;
    }

    /*
     * Mark the process as terminated so access checks will work.
     */
    ppi->W32PF_Flags |= W32PF_TERMINATED;

    /*
     * Cleanup wow process info struct, if any
     */
    if (ppi->pwpi) {
        PWOWPROCESSINFO pwpi = ppi->pwpi;

        ObDereferenceObject(pwpi->pEventWowExec);

        REMOVE_FROM_LIST(WOWPROCESSINFO, gpwpiFirstWow, pwpi, pwpiNext);

        UserFreePool(pwpi);
        ppi->pwpi = NULL;
    }

    /*
     * Delete desktop views. System will do unmapping.
     */
    pdv = ppi->pdvList;
    while (pdv) {
        pdvNext = pdv->pdvNext;
        UserFreePool(pdv);
        pdv = pdvNext;
    }
    ppi->pdvList = NULL;

    /*
     * Clear the SendInput/Journalling hook caller ppi
     */
    if (ppi == gppiInputProvider) {
        gppiInputProvider = NULL;
    }
    /*
     * If this ppi locked SetForegroundWindow, clean up
     */
    if (ppi == gppiLockSFW) {
        gppiLockSFW = NULL;
    }

    return fHadThreads;
}

/***************************************************************************\
* ClearWakeMask
*
\***************************************************************************/
VOID ClearWakeMask(
    VOID)
{
    PtiCurrent()->pcti->fsWakeMask = 0;
}

/***************************************************************************\
* xxxGetInputEvent
*
* Returns a duplicated event-handle that the client process can use to
* wait on input events.
*
* History:
* 05-02-91  DavidPe     Created.
\***************************************************************************/
HANDLE xxxGetInputEvent(
    DWORD dwWakeMask)
{
    PTHREADINFO ptiCurrent;
    WORD wFlags = HIWORD(dwWakeMask);
    UserAssert(IsWinEventNotifyDeferredOK());

    ptiCurrent = PtiCurrent();

    /*
     * If our wait condition is satisfied, signal the event and return.
     * (Since the wake mask could have been anything at the time the input
     *  arrived, the event might not be signaled)
     */
    if (GetInputBits(ptiCurrent->pcti, LOWORD(dwWakeMask), (wFlags & MWMO_INPUTAVAILABLE))) {
        KeSetEvent(ptiCurrent->pEventQueueServer, 2, FALSE);
        return ptiCurrent->hEventQueueClient;
    }

    /*
     * If an idle hook is set, call it.
     */
    if (ptiCurrent == gptiForeground &&
            IsHooked(ptiCurrent, WHF_FOREGROUNDIDLE)) {
        xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);
    }

    /*
     * What is the criteria for an "idle process"?
     * Answer: The first thread that calls zzzWakeInputIdle, or SleepInputIdle or...
     * Any thread that calls xxxGetInputEvent with any of the following
     * bits set in its wakemask: (sanfords)
     */
    if (dwWakeMask & (QS_POSTMESSAGE | QS_INPUT)) {
        ptiCurrent->ppi->ptiMainThread = ptiCurrent;
    }

    /*
     * When we return, this app is going to sleep. Since it is in its
     * idle mode when it goes to sleep, wake any apps waiting for this
     * app to go idle.
     */
    zzzWakeInputIdle(ptiCurrent);
    /*
     * Setup the wake mask for this thread. Wait for QS_EVENT or the app won't
     * get event messages like deactivate.
     */
    ClearQueueServerEvent((WORD)(dwWakeMask | QS_EVENT));
    /*
     * This app is going idle. Clear the spin count check to see
     * if we need to make this process foreground again.
     */
    try {
        ptiCurrent->pClientInfo->cSpins = 0;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return NULL;
    }
    if (ptiCurrent->TIF_flags & TIF_SPINNING) {
        if (!NT_SUCCESS(CheckProcessForeground(ptiCurrent))) {
            return NULL;
        }
    }

    UserAssert(ptiCurrent->pcti->fsWakeMask != 0);
    return ptiCurrent->hEventQueueClient;
}

/***************************************************************************\
* xxxWaitForInputIdle
*
* This routine waits on a particular input queue for "input idle", meaning
* it waits till that queue has no input to process.
*
* 09-13-91 ScottLu      Created.
\***************************************************************************/

DWORD xxxWaitForInputIdle(
    ULONG_PTR idProcess,
    DWORD dwMilliseconds,
    BOOL fSharedWow)
{
    PTHREADINFO ptiCurrent;
    PTHREADINFO pti;
    PEPROCESS Process;
    PW32PROCESS W32Process;
    PPROCESSINFO ppi;
    DWORD dwResult;
    NTSTATUS Status;
    TL tlProcess;

    ptiCurrent = PtiCurrent();

    /*
     * If fSharedWow is set, the client passed in a fake process
     * handle which CreateProcess returns for Win16 apps started
     * in the shared WOW VDM.
     *
     * CreateProcess returns a real process handle when you start
     * a Win16 app in a separate WOW VDM.
     */

    if (fSharedWow) {  // Waiting for a WOW task to go idle.
        PWOWTHREADINFO pwti;


        /*
         * Look for a matching thread in the WOW thread info list.
         */
        for (pwti = gpwtiFirst; pwti != NULL; pwti = pwti->pwtiNext) {
            if (pwti->idParentProcess == HandleToUlong(PsGetThreadProcessId(ptiCurrent->pEThread)) &&
                pwti->idWaitObject == idProcess) {
                break;
            }
        }

        /*
         * If we couldn't find the right thread, bail out.
         */
        if (pwti == NULL) {
            RIPMSG0(RIP_WARNING, "WaitForInputIdle couldn't find 16-bit task");
            return (DWORD)-1;
        }

        /*
         * Now wait for it to go idle and return.
         */
        dwResult = WaitOnPseudoEvent(&pwti->pIdleEvent, dwMilliseconds);
        if (dwResult == STATUS_ABANDONED) {
            dwResult = xxxPollAndWaitForSingleObject(pwti->pIdleEvent,
                                                     NULL,
                                                     dwMilliseconds);
        }
        return dwResult;

    }

    /*
     * We shouldn't get here for system threads.
     */
    UserAssert(!(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD));

    /*
     * If the app is waiting for itself to go idle, error.
     */
    if (PsGetThreadProcessId(ptiCurrent->pEThread) == (HANDLE)idProcess &&
            ptiCurrent == ptiCurrent->ppi->ptiMainThread) {
        RIPMSG0(RIP_WARNING, "WaitForInputIdle waiting on self");
        return (DWORD)-1;
    }

    /*
     * Now find the ppi structure for this process.
     */
    Status = LockProcessByClientId((HANDLE)idProcess, &Process);

    if (!NT_SUCCESS(Status))
        return (DWORD)-1;

    if (PsGetProcessExitProcessCalled(Process)) {
        UnlockProcess(Process);
        return (DWORD)-1;
    }

    W32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);

    /*
     * If we can't find that process info structure, return error.
     * Or, if this is a console application, don't wait on it.
     */
    if (W32Process == NULL || W32Process->W32PF_Flags & W32PF_CONSOLEAPPLICATION) {
        UnlockProcess(Process);
        return (DWORD)-1;
    }


    /*
     * We have to wait mark the Process as one which others are waiting on
     */
    ppi = (PPROCESSINFO)W32Process;
    ppi->W32PF_Flags |= W32PF_WAITFORINPUTIDLE;
    for (pti = ppi->ptiList; pti != NULL; pti = pti->ptiSibling) {
        pti->TIF_flags |= TIF_WAITFORINPUTIDLE;
    }

    /*
     * Thread lock the process to ensure that it will be dereferenced
     * if the thread exits.
     */
    LockW32Process(W32Process, &tlProcess);
    UnlockProcess(Process);

    dwResult = WaitOnPseudoEvent(&W32Process->InputIdleEvent, dwMilliseconds);
    if (dwResult == STATUS_ABANDONED) {
        dwResult = xxxPollAndWaitForSingleObject(W32Process->InputIdleEvent,
                                                 Process,
                                                 dwMilliseconds);
    }

    /*
     * Clear all thread TIF_WAIT bits from the process.
     */
    ppi->W32PF_Flags &= ~W32PF_WAITFORINPUTIDLE;
    for (pti = ppi->ptiList; pti != NULL; pti = pti->ptiSibling) {
        pti->TIF_flags &= ~TIF_WAITFORINPUTIDLE;
    }

    UnlockW32Process(&tlProcess);

    return dwResult;
}


#define INTERMEDIATE_TIMEOUT    (500)       // 1/2 second

/***************************************************************************\
* xxxPollAndWaitForSingleObject
*
* Sometimes we have to wait on an event but still want to periodically
* wake up and see if the client process has been terminated.
*
* dwMilliseconds is initially the total amount of time to wait and after
* each intermediate wait reflects the amount of time left to wait.
* -1 means wait indefinitely.
*
* 02-Jul-1993 johnc      Created.
\***************************************************************************/

// LATER!!! can we get rid of the Polling idea and wait additionally on
// LATER!!! the hEventServer and set that when a thread dies

DWORD xxxPollAndWaitForSingleObject(
    PKEVENT pEvent,
    PVOID pExecObject,
    DWORD dwMilliseconds)
{
    DWORD dwIntermediateMilliseconds, dwStartTickCount;
    PTHREADINFO ptiCurrent;
    UINT cEvent = 2;
    NTSTATUS Status = -1;
    LARGE_INTEGER li;
    TL tlEvent;

    ptiCurrent = PtiCurrent();

    if (ptiCurrent->apEvent == NULL) {
        ptiCurrent->apEvent = UserAllocPoolNonPaged(POLL_EVENT_CNT * sizeof(PKEVENT), TAG_EVENT);
        if (ptiCurrent->apEvent == NULL)
            return (DWORD)-1;
    }

    /*
     * Refcount the event to ensure that it won't go
     * away during the wait. By using a thread lock, the
     * event will be dereferenced if the thread exits
     * during a callback. The process pointer has already been
     * locked.
     */
    ThreadLockObject(pEvent, &tlEvent);

    /*
     * If a process was passed in, wait on it too. No need
     * to reference this because the caller has it referenced.
     */
    if (pExecObject) {
        cEvent++;
    }

    /*
     * We want to wake if there're sent messages pending
     */
    ClearQueueServerEvent(QS_SENDMESSAGE);

    /*
     * Wow Tasks MUST be descheduled while in the wait to allow
     * other tasks in the same wow scheduler to run.
     *
     * For example, 16 bit app A calls WaitForInputIdle on 32 bit app B.
     * App B starts up and tries to send a message to 16 bit app C. App C
     * will never be able to process the message unless app A yields
     * control to it, so app B will never go idle.
     */

    if (ptiCurrent->TIF_flags & TIF_16BIT) {
        xxxSleepTask(FALSE, HEVENT_REMOVEME);
        // caution: the wow task is no longer scheduled.
    }

    dwStartTickCount = NtGetTickCount();
    while (TRUE) {
        if (dwMilliseconds > INTERMEDIATE_TIMEOUT) {
            dwIntermediateMilliseconds = INTERMEDIATE_TIMEOUT;

            /*
             * If we are not waiting an infinite amount of time then subtract
             * the last loop duration from time left to wait.
             */
            if (dwMilliseconds != INFINITE) {
                DWORD dwNewTickCount = NtGetTickCount();
                DWORD dwDelta = ComputePastTickDelta(dwNewTickCount, dwStartTickCount);
                dwStartTickCount = dwNewTickCount;
                if (dwDelta < dwMilliseconds) {
                    dwMilliseconds -= dwDelta;
                } else {
                    dwMilliseconds = 0;
                }
            }
        } else {
            dwIntermediateMilliseconds = dwMilliseconds;
            dwMilliseconds = 0;
        }

        /*
         * Convert dwMilliseconds to a relative-time(i.e. negative) LARGE_INTEGER.
         * NT Base calls take time values in 100 nanosecond units.
         */
        if (dwIntermediateMilliseconds != INFINITE)
            li.QuadPart = Int32x32To64(-10000, dwIntermediateMilliseconds);

        /*
         * Load events into the wait array. Do this every time
         * through the loop in case of recursion.
         */
        ptiCurrent->apEvent[IEV_IDLE] = pEvent;
        ptiCurrent->apEvent[IEV_INPUT] = ptiCurrent->pEventQueueServer;
        ptiCurrent->apEvent[IEV_EXEC] = pExecObject;

        LeaveCrit();

        Status = KeWaitForMultipleObjects(cEvent,
                                          &ptiCurrent->apEvent[IEV_IDLE],
                                          WaitAny,
                                          WrUserRequest,
                                          UserMode,
                                          FALSE,
                                          (dwIntermediateMilliseconds == INFINITE ?
                                                  NULL : &li),
                                          NULL);

        EnterCrit();

        if (!NT_SUCCESS(Status)) {
            Status = -1;
        } else {

            /*
             * Because we do a non-alertable wait, we know that a status
             * of STATUS_USER_APC means that the thread was terminated.
             * If we have terminated, get back to user mode
             */
            if (Status == STATUS_USER_APC) {
                ClientDeliverUserApc();
                Status = -1;
            }
        }

        if (ptiCurrent->pcti->fsChangeBits & QS_SENDMESSAGE) {
            /*
             *  Wow Tasks MUST wait to be rescheduled in the wow non-premptive
             *  scheduler before doing anything which might invoke client code.
             */
            if (ptiCurrent->TIF_flags & TIF_16BIT) {
                xxxDirectedYield(DY_OLDYIELD);
            }

            xxxReceiveMessages(ptiCurrent);

            if (ptiCurrent->TIF_flags & TIF_16BIT) {
                xxxSleepTask(FALSE, HEVENT_REMOVEME);
                // caution: the wow task is no longer scheduled.
            }
        }

        /*
         * If we returned from the wait for some other reason than a timeout
         * or to receive messages we are done. If it is a timeout we are
         * only done waiting if the overall time is zero.
         */
        if (Status != STATUS_TIMEOUT && Status != 1)
            break;

        if (dwMilliseconds == 0) {
            /*
             * Fix up the return if the last poll was interupted by a message
             */
            if (Status == 1)
                Status = WAIT_TIMEOUT;
            break;
        }

    }

    /*
     * reschedule the 16 bit app
     */
    if (ptiCurrent->TIF_flags & TIF_16BIT) {
        xxxDirectedYield(DY_OLDYIELD);
    }

    /*
     * Unlock the events.
     */
    ThreadUnlockObject(&tlEvent);

    return Status;
}



/***************************************************************************\
 * WaitOnPseudoEvent
 *
 * Similar semantics to WaitForSingleObject() but works with pseudo events.
 * Could fail if creation on the fly fails.
 * Returns STATUS_ABANDONED_WAIT if caller needs to wait on the event and event is
 * created and ready to be waited on.
 *
 * This assumes the event was created with fManualReset=TRUE, fInitState=FALSE
 *
 * 10/28/93 SanfordS    Created
\***************************************************************************/
DWORD WaitOnPseudoEvent(
    HANDLE *phE,
    DWORD dwMilliseconds)
{
    HANDLE hEvent;
    NTSTATUS Status;

    CheckCritIn();
    if (*phE == PSEUDO_EVENT_OFF) {
        if (!NT_SUCCESS(ZwCreateEvent(&hEvent, EVENT_ALL_ACCESS, NULL,
                NotificationEvent, FALSE))) {
            UserAssert(!"Could not create event on the fly.");
            if (dwMilliseconds != INFINITE) {
                return STATUS_TIMEOUT;
            } else {
                return (DWORD)-1;
            }
        }
        Status = ObReferenceObjectByHandle(hEvent, EVENT_ALL_ACCESS, *ExEventObjectType,
                KernelMode, phE, NULL);
        ZwClose(hEvent);
        if (!NT_SUCCESS(Status))
            return (DWORD)-1;
    } else if (*phE == PSEUDO_EVENT_ON) {
        return STATUS_WAIT_0;
    }
    return(STATUS_ABANDONED);
}

/***************************************************************************\
* xxxSetCsrssThreadDesktop
*
* Set/clear and lock/unlock a desktop for a csrss thread
* When setting a desktop, ppdeskRestore must be valid and will receive
* the old (previous) desktop, if any; the caller is expected to restore
* this pdesk when done.
*
* When restoring a desktop, ppdeskRestore must be NULL. pdesk must have been
* previously returned by this same function (in *ppdeskRestore).
*
* History:
* 02-18-97 GerardoB     Extracted from SetInformationThread
\***************************************************************************/
NTSTATUS xxxSetCsrssThreadDesktop(PDESKTOP pdesk, PDESKRESTOREDATA pdrdRestore)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    NTSTATUS Status = STATUS_SUCCESS;
    MSG msg;

    /*
     * Only csr should come here
     */
    UserAssert(ISCSRSS());
    UserAssert(pdrdRestore);
    UserAssert(pdrdRestore->pdeskRestore == NULL);

#if 0
    /*
     * If we're in clean up, csrss worker threads should not be messing around
     */
    if (gdwHydraHint & HH_INITIATEWIN32KCLEANUP) {
        FRE_RIPMSG0(RIP_ERROR, "xxxSetCsrssThreadDesktop: HH_INITIATEWIN32KCLEANUP is set");
    }
#endif

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_WARNING, "xxxSetCsrssThreadDesktop: pdesk %#p destroyed",
                pdesk);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Lock the current desktop (set operation). Also, create and save a
     * handle to the new desktop.
     */
    pdrdRestore->pdeskRestore = ptiCurrent->rpdesk;

    if (pdrdRestore->pdeskRestore != NULL) {
        Status = ObReferenceObjectByPointer(pdrdRestore->pdeskRestore,
                                       MAXIMUM_ALLOWED,
                                       *ExDesktopObjectType,
                                       KernelMode);

        if (!NT_SUCCESS(Status)) {
            pdrdRestore->pdeskRestore = NULL;
            pdrdRestore->hdeskNew = NULL;
            return Status;
        }
        LogDesktop(pdrdRestore->pdeskRestore, LD_REF_FN_SETCSRSSTHREADDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());
    }

    Status = ObOpenObjectByPointer(
             pdesk,
             0,
             NULL,
             EVENT_ALL_ACCESS,
             NULL,
             KernelMode,
             &(pdrdRestore->hdeskNew));


    if (!NT_SUCCESS(Status)) {
        RIPNTERR2(Status, RIP_WARNING, "SetCsrssThreadDesktop, can't open handle, pdesk %#p. Status: %#x", pdesk, Status);
        if (pdrdRestore->pdeskRestore) {
            LogDesktop(pdrdRestore->pdeskRestore, LD_DEREF_FN_SETCSRSSTHREADDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdrdRestore->pdeskRestore);
            pdrdRestore->pdeskRestore = NULL;
        }
        pdrdRestore->hdeskNew = NULL;
        return Status;
    }
    /*
     * Set the new desktop, if switching
     */
    if (pdesk != ptiCurrent->rpdesk) {
        /*
         * Process any remaining messages before we leave the desktop
         */
        if (ptiCurrent->rpdesk) {
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD))
                xxxDispatchMessage(&msg);
        }

        if (!xxxSetThreadDesktop(NULL, pdesk)) {
            RIPMSG1(RIP_WARNING, "xxxSetCsrssThreadDesktop: xxxSetThreadDesktop(%#p) failed", pdesk);
            Status = STATUS_INVALID_HANDLE;
            /*
             * We're failing so deref if needed.
             */
            if (pdrdRestore->pdeskRestore != NULL) {
                LogDesktop(pdrdRestore->pdeskRestore, LD_DEREF_FN_SETCSRSSTHREADDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());
                ObDereferenceObject(pdrdRestore->pdeskRestore);
                pdrdRestore->pdeskRestore = NULL;
            }
            CloseProtectedHandle(pdrdRestore->hdeskNew);
            pdrdRestore->hdeskNew = NULL;
        }
    }


    UserAssert(NT_SUCCESS(Status));
    return Status;
}

NTSTATUS xxxRestoreCsrssThreadDesktop(PDESKRESTOREDATA pdrdRestore)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    NTSTATUS Status = STATUS_SUCCESS;
    MSG msg;

    /*
     * Only csr should come here
     */
    UserAssert(ISCSRSS());
    UserAssert(pdrdRestore);

    /*
     * Set the new desktop, if switching
     */
    if (pdrdRestore->pdeskRestore != ptiCurrent->rpdesk) {
        /*
         * Process any remaining messages before we leave the desktop
         */
        if (ptiCurrent->rpdesk) {
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD))
                xxxDispatchMessage(&msg);
        }

        if (!xxxSetThreadDesktop(NULL, pdrdRestore->pdeskRestore)) {
            FRE_RIPMSG1(RIP_ERROR, "xxxRestoreCsrssThreadDesktop: xxxRestoreThreadDesktop(%#p) failed", pdrdRestore->pdeskRestore);
            Status = STATUS_INVALID_HANDLE;
        }
    }

    /*
     * Dereference the desktop, even if failing the call.
     */
    if (pdrdRestore->pdeskRestore != NULL) {
        LogDesktop(pdrdRestore->pdeskRestore, LD_DEREF_FN_SETCSRSSTHREADDESKTOP2, FALSE, 0);
        ObDereferenceObject(pdrdRestore->pdeskRestore);
        pdrdRestore->pdeskRestore = NULL;
    }

    if (pdrdRestore->hdeskNew) {
        CloseProtectedHandle(pdrdRestore->hdeskNew);
        UserAssert(NT_SUCCESS(Status));
        pdrdRestore->hdeskNew = NULL;
    }

    return Status;
}

/***************************************************************************\
* GetTaskName
*
* Gets the application name from a thread.
\***************************************************************************/
ULONG GetTaskName(
    PTHREADINFO pti,
    PWSTR Buffer,
    ULONG BufferLength)
{
    ANSI_STRING strAppName;
    UNICODE_STRING strAppNameU;
    NTSTATUS Status;
    ULONG NameLength = 0;

    if (pti == NULL) {
        *Buffer = 0;
        return 0;
    }
    if (pti->pstrAppName != NULL) {
        NameLength = min(pti->pstrAppName->Length + sizeof(WCHAR), BufferLength);
        RtlCopyMemory(Buffer, pti->pstrAppName->Buffer, NameLength);
    } else {
        RtlInitAnsiString(&strAppName, PsGetProcessImageFileName(PsGetThreadProcess(pti->pEThread)));
        if (BufferLength < sizeof(WCHAR)) {
            NameLength = (strAppName.Length + 1) * sizeof(WCHAR);
        } else {
            strAppNameU.Buffer = Buffer;
            strAppNameU.MaximumLength = (SHORT)BufferLength - sizeof(WCHAR);
            Status = RtlAnsiStringToUnicodeString(&strAppNameU, &strAppName,
                    FALSE);
            if (NT_SUCCESS(Status))
                NameLength = strAppNameU.Length + sizeof(WCHAR);
        }
    }
    Buffer[(NameLength / sizeof(WCHAR)) - 1] = 0;

    return NameLength;
}

/***************************************************************************\
* QueryInformationThread
*
* Returns information about a thread.
*
* History:
* 03-01-95 JimA         Created.
\***************************************************************************/
NTSTATUS xxxQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
    PUSERTHREAD_SHUTDOWN_INFORMATION pShutdown;
    PUSERTHREAD_WOW_INFORMATION pWow;
    PETHREAD Thread;
    PTHREADINFO pti;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LocalReturnLength = 0;
    DWORD dwClientFlags;

    /*
     * Only allow CSRSS to make this call
     */
    UserAssert(ISCSRSS());

    Status = ObReferenceObjectByHandle(hThread,
                                        THREAD_QUERY_INFORMATION,
                                        *PsThreadType,
                                        UserMode,
                                        &Thread,
                                        NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    pti = PtiFromThread(Thread);

    switch (ThreadInfoClass) {
    case UserThreadShutdownInformation:
        LocalReturnLength = sizeof(USERTHREAD_SHUTDOWN_INFORMATION);
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_SHUTDOWN_INFORMATION));
        pShutdown = ThreadInformation;
        /*
         * Read the client flags and zero out the structure,
         *  except for pdeskRestore (which is supposed
         *  to be the last field)
         */
        dwClientFlags = pShutdown->dwFlags;
        UserAssert(FIELD_OFFSET(USERTHREAD_SHUTDOWN_INFORMATION, drdRestore)
            == (sizeof(USERTHREAD_SHUTDOWN_INFORMATION) - sizeof(DESKRESTOREDATA)));
        RtlZeroMemory(pShutdown,
            sizeof(USERTHREAD_SHUTDOWN_INFORMATION) - sizeof(DESKRESTOREDATA));

        /*
         * Return the desktop window handle if the thread
         * has a desktop and the desktop is on a visible
         * windowstation.
         */
        if (pti != NULL && pti->rpdesk != NULL &&
                !(pti->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO))
            pShutdown->hwndDesktop = HW(pti->rpdesk->pDeskInfo->spwnd);

        /*
         * Return shutdown status. Zero indicates that the thread
         * has windows and can be shut down in the normal manner.
         */
        if (PsGetThreadProcessId(Thread) == gpidLogon) {
            /*
             * Do not shutdown the logon process.
             */
            pShutdown->StatusShutdown = SHUTDOWN_KNOWN_PROCESS;
        } else if (pti == NULL || pti->rpdesk == NULL) {

            /*
             * The thread either is not a gui thread or it doesn't
             * have a desktop. Make console do the shutdown.
             */
            pShutdown->StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;
        }

        /*
         * Return flags
         */
        if (pti != NULL && pti->cWindows != 0)
            pShutdown->dwFlags |= USER_THREAD_GUI;

        /*
         * If we return the desktop window handle and the
         * app should be shut down, switch to the desktop
         *  and assign it to the shutdown worker thread.
         */
        if ((pShutdown->dwFlags & USER_THREAD_GUI) &&
                pShutdown->StatusShutdown == 0) {
            /*
             * The current csrss thread is going to
             *  make activation calls, send messages,
             *  switch video modes, etc  so we need to
             *  assign it to a dekstop
             */
            PTHREADINFO ptiCurrent = PtiCurrent();
            UserAssert(pti->rpdesk != NULL);

            if (ptiCurrent->rpdesk != pti->rpdesk) {
                /*
                 * If this thread already has a desktop,
                 *   restore the old one first.
                 *  This might happen when threads of the same
                 *  process are attached to different desktops.
                 */
                if (ptiCurrent->rpdesk != NULL) {
                    Status = xxxRestoreCsrssThreadDesktop(&pShutdown->drdRestore);
                    UserAssert(pti == PtiFromThread(Thread));
                }
                if (NT_SUCCESS(Status)) {
                    Status = xxxSetCsrssThreadDesktop(pti->rpdesk, &pShutdown->drdRestore);
                    UserAssert(pti == PtiFromThread(Thread));
                }
            }
            /*
             * If we're forcing a shutdown, then there is no need to switch
             *  since we won't send any messages or bring up the EndTask dialog
             * (We still want to have a proper rpdesk since BoostHardError might
             *   call PostThreadMessage)
             */
            if (!(dwClientFlags & WMCS_NORETRY)) {
                if (NT_SUCCESS(Status)) {
                    xxxSwitchDesktop(pti->rpdesk->rpwinstaParent, pti->rpdesk, SDF_SLOVERRIDE);
                    UserAssert(pti == PtiFromThread(Thread));
                }
            }
        }
        break;

    case UserThreadFlags:
        LocalReturnLength = sizeof(DWORD);
        if (pti == NULL) {
            Status = STATUS_INVALID_HANDLE;
        } else {
            UserAssert(ThreadInformationLength == sizeof(DWORD));
            *(LPDWORD)ThreadInformation = pti->TIF_flags;
        }
        break;

    case UserThreadTaskName:
        LocalReturnLength = GetTaskName(pti, ThreadInformation, ThreadInformationLength);
        break;

    case UserThreadWOWInformation:
        LocalReturnLength = sizeof(USERTHREAD_WOW_INFORMATION);
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_WOW_INFORMATION));
        pWow = ThreadInformation;
        RtlZeroMemory(pWow, sizeof(USERTHREAD_WOW_INFORMATION));

        /*
         * If the thread is 16-bit, Status = the exit task function
         * and task id.
         */
        if (pti && pti->TIF_flags & TIF_16BIT) {
            pWow->lpfnWowExitTask = pti->ppi->pwpi->lpfnWowExitTask;
            if (pti->ptdb) {
                pWow->hTaskWow = pti->ptdb->hTaskWow;
            } else {
                pWow->hTaskWow = 0;
            }
        }
        break;

    case UserThreadHungStatus:
        LocalReturnLength = sizeof(DWORD);
        UserAssert(ThreadInformationLength >= sizeof(DWORD));

        /*
         * Return hung status.
         */
        if (pti) {
            *(PDWORD)ThreadInformation =
                    (DWORD)FHungApp(pti, (DWORD)*(PDWORD)ThreadInformation);
        } else {
            *(PDWORD)ThreadInformation = FALSE;
        }
        break;

    default:
        Status = STATUS_INVALID_INFO_CLASS;
        RIPMSG1(RIP_ERROR, "Invalid ThreadInfoClass 0x%x", ThreadInfoClass);
        break;
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = LocalReturnLength;
    }

    UnlockThread(Thread);

    return Status;
}

/***************************************************************************\
* xxxSetInformationThread
*
* Sets information about a thread.
*
* History:
* 03-01-95 JimA         Created.
\***************************************************************************/

NTSTATUS xxxSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength)
{
    PUSERTHREAD_FLAGS pFlags;
    HANDLE hClientThread;
    DWORD dwOldFlags;
    PTHREADINFO ptiT;
    NTSTATUS Status = STATUS_SUCCESS;
    PETHREAD Thread;
    PETHREAD ThreadClient;
    PTHREADINFO pti;
    HANDLE CsrPortHandle;

    UNREFERENCED_PARAMETER(ThreadInformationLength);

    /*
     * Only allow CSRSS to make this call
     */
    UserAssert(ISCSRSS());

    Status = ObReferenceObjectByHandle(hThread,
                                        THREAD_SET_INFORMATION,
                                        *PsThreadType,
                                        UserMode,
                                        &Thread,
                                        NULL);
    if (!NT_SUCCESS(Status))
        return Status;

    pti = PtiFromThread(Thread);

    switch (ThreadInfoClass) {
    case UserThreadFlags:
        if (pti == NULL) {
            Status = STATUS_INVALID_HANDLE;
        } else {
            UserAssert(ThreadInformationLength == sizeof(USERTHREAD_FLAGS));
            pFlags = ThreadInformation;
            dwOldFlags = pti->TIF_flags;
            pti->TIF_flags ^= ((dwOldFlags ^ pFlags->dwFlags) & pFlags->dwMask);
        }
        break;

    case UserThreadHungStatus:
        if (pti == NULL) {
            Status = STATUS_INVALID_HANDLE;
        } else {

            /*
             * No arguments, simple set the last time read.
             */
            SET_TIME_LAST_READ(pti);
        }
        break;

    case UserThreadInitiateShutdown:
        UserAssert(ThreadInformationLength == sizeof(ULONG));
        Status = InitiateShutdown(Thread, (PULONG)ThreadInformation);
        break;

    case UserThreadEndShutdown:
        UserAssert(ThreadInformationLength == sizeof(NTSTATUS));
        Status = EndShutdown(Thread, *(NTSTATUS *)ThreadInformation);
        break;

    case UserThreadUseDesktop:
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_USEDESKTOPINFO));
        if (pti == NULL) {
            Status = STATUS_INVALID_HANDLE;
            break;
        }

        /*
         * If the caller provides a thread handle, then we use that
         *  thread's pdesk and return the pdesk currently used
         *  by the caller (set operation). Otherwise,
         *  we use the pdesk provided by the caller (restore operation).
         */
        hClientThread = ((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->hThread;
        if (hClientThread != NULL) {
            Status = ObReferenceObjectByHandle(hClientThread,
                                            THREAD_QUERY_INFORMATION,
                                            *PsThreadType,
                                            UserMode,
                                            &ThreadClient,
                                            NULL);
            if (!NT_SUCCESS(Status))
                break;

            ptiT = PtiFromThread(ThreadClient);
            if ((ptiT == NULL) || (ptiT->rpdesk == NULL)) {
                Status = STATUS_INVALID_HANDLE;
                goto DerefClientThread;
            }
            Status = xxxSetCsrssThreadDesktop(ptiT->rpdesk, &((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->drdRestore);
        } else {
            Status = xxxRestoreCsrssThreadDesktop(&((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->drdRestore);
        }


        if (hClientThread != NULL) {
DerefClientThread:
            ObDereferenceObject(ThreadClient);
        }
        break;

    case UserThreadUseActiveDesktop:
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_USEDESKTOPINFO));
        if (pti == NULL || grpdeskRitInput == NULL) {
            Status = STATUS_INVALID_HANDLE;
            break;
        }
        Status = xxxSetCsrssThreadDesktop(grpdeskRitInput,
                    &((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->drdRestore);
        break;

    case UserThreadCsrApiPort:

        /*
         * Only CSR can call this
         */
        if (PsGetThreadProcess(Thread) != gpepCSRSS) {
            Status = STATUS_ACCESS_DENIED;
            break;
        }

        UserAssert(ThreadInformationLength == sizeof(HANDLE));

        /*
         * Only set it once.
         */
        if (CsrApiPort != NULL)
            break;

        CsrPortHandle = *(PHANDLE)ThreadInformation;
        Status = ObReferenceObjectByHandle(
                CsrPortHandle,
                0,
                NULL, //*LpcPortObjectType,
                UserMode,
                &CsrApiPort,
                NULL);
        if (!NT_SUCCESS(Status)) {
            CsrApiPort = NULL;
            RIPMSG1(RIP_WARNING,
                    "CSR port reference failed, Status=%#lx",
                    Status);
        }

        break;

    default:
        Status = STATUS_INVALID_INFO_CLASS;
        RIPMSG1(RIP_ERROR, "Invalid ThreadInfoClass 0x%x", ThreadInfoClass);
        break;
    }

    UnlockThread(Thread);

    return Status;
}

/***************************************************************************\
* _GetProcessDefaultLayout (API)
*
* Retreives the default layout information about a process.
*
* History:
* 23-01-98 SamerA         Created.
\***************************************************************************/
BOOL _GetProcessDefaultLayout(
    OUT DWORD *pdwDefaultLayout)
{
    BOOL fSuccess = FALSE;

    /*
     * Do not allow CSRSS to make this call. This call might happen due to
     * the inheritence code. See xxxCreateWindowEx(...)
     */
    if (ISCSRSS()) {
        UserSetLastError(ERROR_INVALID_ACCESS);
        goto api_error;
    }

    try {
        ProbeForWriteUlong(pdwDefaultLayout);
        *pdwDefaultLayout = PpiCurrent()->dwLayout;
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        goto api_error;
    }

    fSuccess = TRUE;

api_error:
    return fSuccess;
}

/***************************************************************************\
* _SetProcessDefaultLayout (API)
*
* Sets the default layout information about a process.
*
* History:
* 23-01-98 SamerA         Created.
\***************************************************************************/
BOOL _SetProcessDefaultLayout(
    IN DWORD dwDefaultLayout)
{
    /*
     * Do not allow CSRSS to make this call
     */
    UserAssert(PsGetCurrentProcess() != gpepCSRSS);

    /*
     * Validate dwDefaultLayout
     */
    if (dwDefaultLayout & ~LAYOUT_ORIENTATIONMASK)
    {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Calling SetProcessDefaultLayout with invalid layout = %lX",
                dwDefaultLayout);
        return FALSE;
    }

    /*
     * Update the process default layout param
     */
    PpiCurrent()->dwLayout = dwDefaultLayout;

    return TRUE;
}

/***************************************************************************\
* SetInformationProcess
*
* Sets information about a process.
*
* History:
* 09-27-96 GerardoB         Created.
\***************************************************************************/

NTSTATUS SetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength)
{
    PUSERPROCESS_FLAGS pFlags;
    DWORD dwOldFlags;
    NTSTATUS Status = STATUS_SUCCESS;
    PEPROCESS Process;
    PPROCESSINFO ppi;

    UNREFERENCED_PARAMETER(ProcessInformationLength);

    UserAssert(ISCSRSS());

    Status = ObReferenceObjectByHandle(hProcess,
                                        PROCESS_SET_INFORMATION,
                                        *PsProcessType,
                                        UserMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ppi = PpiFromProcess(Process);

    switch (ProcessInfoClass) {
    case UserProcessFlags:
        if (ppi == NULL) {
            Status = STATUS_INVALID_HANDLE;
        } else {
            UserAssert(ProcessInformationLength == sizeof(USERPROCESS_FLAGS));
            pFlags = ProcessInformation;
            dwOldFlags = ppi->W32PF_Flags;
            ppi->W32PF_Flags ^= ((dwOldFlags ^ pFlags->dwFlags) & pFlags->dwMask);
        }
        break;

    default:
        Status = STATUS_INVALID_INFO_CLASS;
        UserAssert(FALSE);
        break;
    }

    UnlockProcess(Process);

    return Status;
}


/***************************************************************************\
* xxxSetConsoleCaretInfo
*
* Store information about the console's homegrown caret and notify any
* interested apps that it changed. We need this for accessibility.
*
* History:
* 26-May-1999 JerrySh   Created.
\***************************************************************************/
VOID xxxSetConsoleCaretInfo(
    PCONSOLE_CARET_INFO pcci)
{
    PWND pwnd;
    TL tlpwnd;

    pwnd = ValidateHwnd(pcci->hwnd);
    if (pwnd && pwnd->head.rpdesk) {
        pwnd->head.rpdesk->cciConsole = *pcci;
        ThreadLock(pwnd, &tlpwnd);
        xxxWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, pwnd, OBJID_CARET, INDEXID_CONTAINER, WEF_ASYNC);
        ThreadUnlock(&tlpwnd);
    }
}

/***************************************************************************\
* xxxConsoleControl
*
* Performs special control operations for console.
*
* History:
* 03-01-95 JimA         Created.
\***************************************************************************/
NTSTATUS xxxConsoleControl(
    IN CONSOLECONTROL ConsoleControl,
    IN PVOID ConsoleInformation,
    IN ULONG ConsoleInformationLength)
{
    PCONSOLEDESKTOPCONSOLETHREAD pDesktopConsole;
    PCONSOLEWINDOWSTATIONPROCESS pConsoleWindowStationInfo;
    PDESKTOP pdesk;
    DWORD dwThreadIdOld;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ConsoleInformationLength);
    UserAssert(ISCSRSS());

    switch (ConsoleControl) {
    case ConsoleDesktopConsoleThread:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLEDESKTOPCONSOLETHREAD));
        pDesktopConsole = (PCONSOLEDESKTOPCONSOLETHREAD)ConsoleInformation;

        Status = ObReferenceObjectByHandle(
                pDesktopConsole->hdesk,
                0,
                *ExDesktopObjectType,
                UserMode,
                &pdesk,
                NULL);
        if (!NT_SUCCESS(Status))
            return Status;

        LogDesktop(pdesk, LD_REF_FN_CONSOLECONTROL1, TRUE, (ULONG_PTR)PtiCurrent());

        dwThreadIdOld = pdesk->dwConsoleThreadId;

        if (pDesktopConsole->dwThreadId != (DWORD)-1) {
            pdesk->dwConsoleThreadId =
                    pDesktopConsole->dwThreadId;

            /*
             * Make sure that the console input thread is not starting while
             * shutting down.
             */
            if ((pDesktopConsole->dwThreadId != 0) && (gdwHydraHint & HH_INITIATEWIN32KCLEANUP)) {
                FRE_RIPMSG1(RIP_ERROR, "xxxConsoleControl: Console input thread starting during shutdown. dwThreadId: %lx",
                    pDesktopConsole->dwThreadId);
            }
        }

        pDesktopConsole->dwThreadId = dwThreadIdOld;
        LogDesktop(pdesk, LD_DEREF_FN_CONSOLECONTROL1, FALSE, (ULONG_PTR)PtiCurrent());
        ObDereferenceObject(pdesk);
        break;

    case ConsoleClassAtom:
        UserAssert(ConsoleInformationLength == sizeof(ATOM));
        gatomConsoleClass = *(ATOM *)ConsoleInformation;
        break;

    case ConsoleNotifyConsoleApplication:
        /*
         * Bug 273518 - joejo
         *
         * Adding optimization to bug fix
         */
        UserAssert(ConsoleInformationLength == sizeof(CONSOLE_PROCESS_INFO));
        xxxUserNotifyConsoleApplication((PCONSOLE_PROCESS_INFO)ConsoleInformation);
        break;

    case ConsoleSetVDMCursorBounds:
        UserAssert((ConsoleInformation == NULL) ||
            (ConsoleInformationLength == sizeof(RECT)));
        SetVDMCursorBounds(ConsoleInformation);
        break;

    case ConsolePublicPalette:
        UserAssert(ConsoleInformationLength == sizeof(HPALETTE));
        GreSetPaletteOwner(*(HPALETTE *)ConsoleInformation, OBJECT_OWNER_PUBLIC);
        break;

    case ConsoleWindowStationProcess:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLEWINDOWSTATIONPROCESS));

        pConsoleWindowStationInfo = (PCONSOLEWINDOWSTATIONPROCESS)ConsoleInformation;
        UserSetConsoleProcessWindowStation(pConsoleWindowStationInfo->dwProcessId,
                                           pConsoleWindowStationInfo->hwinsta);
        break;

#if defined(FE_IME)
    /*
     * For console IME issue
     *
     * Console IME do register thread ID in DESKTOP info.
     * So should be per desktop.
     */
    case ConsoleRegisterConsoleIME:
        {
            PCONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
            DWORD dwConsoleIMEThreadIdOld;

            UserAssert(ConsoleInformationLength == sizeof(CONSOLE_REGISTER_CONSOLEIME));

            RegConIMEInfo = (PCONSOLE_REGISTER_CONSOLEIME)ConsoleInformation;
            RegConIMEInfo->dwConsoleInputThreadId = 0;

            Status = ObReferenceObjectByHandle(
                    RegConIMEInfo->hdesk,
                    0,
                    *ExDesktopObjectType,
                    UserMode,
                    &pdesk,
                    NULL);
            if (!NT_SUCCESS(Status))
                return Status;

            LogDesktop(pdesk, LD_REF_FN_CONSOLECONTROL2, TRUE, (ULONG_PTR)PtiCurrent());

            Status = STATUS_SUCCESS;
            if (pdesk->dwConsoleThreadId)
            {
                /*
                 * Exists console input thread
                 */
                RegConIMEInfo->dwConsoleInputThreadId = pdesk->dwConsoleThreadId;

                dwConsoleIMEThreadIdOld = pdesk->dwConsoleIMEThreadId;

                if (RegConIMEInfo->dwAction != REGCONIME_QUERY) {
                    PTHREADINFO ptiConsoleIME;

                    if ((ptiConsoleIME = PtiFromThreadId(RegConIMEInfo->dwThreadId)) != NULL) {
                        if ((RegConIMEInfo->dwAction == REGCONIME_REGISTER) &&
                            !(ptiConsoleIME->TIF_flags & TIF_DONTATTACHQUEUE)) {
                            /*
                             * Register
                             */
                            ptiConsoleIME->TIF_flags |= TIF_DONTATTACHQUEUE;
                            pdesk->dwConsoleIMEThreadId = RegConIMEInfo->dwThreadId;
                        } else if ((RegConIMEInfo->dwAction == REGCONIME_UNREGISTER) &&
                                  (ptiConsoleIME->TIF_flags & TIF_DONTATTACHQUEUE)) {
                            /*
                             * Unregister
                             */
                            ptiConsoleIME->TIF_flags &= ~TIF_DONTATTACHQUEUE;
                            pdesk->dwConsoleIMEThreadId = 0;
                        } else if (RegConIMEInfo->dwAction == REGCONIME_TERMINATE) {
                            /*
                             * Terminate console IME (Logoff/Shutdown)
                             */
                            pdesk->dwConsoleIMEThreadId = 0;
                        }
                    } else if (RegConIMEInfo->dwAction == REGCONIME_TERMINATE) {
                        /*
                         * Abnormal end console IME
                         */
                        pdesk->dwConsoleIMEThreadId = 0;
                    } else {
                        Status = STATUS_ACCESS_DENIED;
                    }
                }

                RegConIMEInfo->dwThreadId = dwConsoleIMEThreadIdOld;
            }
            LogDesktop(pdesk, LD_DEREF_FN_CONSOLECONTROL2, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);
            return Status;
        }
        break;
#endif

    case ConsoleFullscreenSwitch:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLE_FULLSCREEN_SWITCH));
        xxxbFullscreenSwitch(((PCONSOLE_FULLSCREEN_SWITCH)ConsoleInformation)->bFullscreenSwitch,
                             ((PCONSOLE_FULLSCREEN_SWITCH)ConsoleInformation)->hwnd);
        break;

    case ConsoleSetCaretInfo:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLE_CARET_INFO));
        xxxSetConsoleCaretInfo((PCONSOLE_CARET_INFO)ConsoleInformation);
        break;

    default:
        RIPMSGF1(RIP_ERROR, "Invalid control class: 0x%x", ConsoleControl);
        return STATUS_INVALID_INFO_CLASS;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sbctl.c ===
/**************************** Module Header ********************************\
* Module Name: sbctl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Scroll bar internal routines
*
* History:
*   11/21/90 JimA      Created.
*   02-04-91 IanJa     Revalidaion added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

void CalcSBStuff(
    PWND pwnd,
    PSBCALC pSBCalc,
    BOOL fVert);

#define IsScrollBarControl(h) (GETFNID(h) == FNID_SCROLLBAR)

/*
 * Now it is possible to selectively Enable/Disable just one arrow of a Window
 * scroll bar; Various bits in the 7th word in the rgwScroll array indicates which
 * one of these arrows are disabled; The following masks indicate which bit of the
 * word indicates which arrow;
 */
#define WSB_HORZ_LF  0x0001  // Represents the Left arrow of the horizontal scroll bar.
#define WSB_HORZ_RT  0x0002  // Represents the Right arrow of the horizontal scroll bar.
#define WSB_VERT_UP  0x0004  // Represents the Up arrow of the vert scroll bar.
#define WSB_VERT_DN  0x0008  // Represents the Down arrow of the vert scroll bar.

#define WSB_VERT (WSB_VERT_UP | WSB_VERT_DN)
#define WSB_HORZ   (WSB_HORZ_LF | WSB_HORZ_RT)

void DrawCtlThumb(PSBWND);

/*
 * RETURN_IF_PSBTRACK_INVALID:
 * This macro tests whether the pSBTrack we have is invalid, which can happen
 * if it gets freed during a callback.
 * This protects agains the original pSBTrack being freed and no new one
 * being allocated or a new one being allocated at a different address.
 * This does not protect against the original pSBTrack being freed and a new
 * one being allocated at the same address.
 * If pSBTrack has changed, we assert that there is not already a new one
 * because we are really not expecting this.
 */
#define RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd) \
    if ((pSBTrack) != PWNDTOPSBTRACK(pwnd)) {      \
        UserAssert(PWNDTOPSBTRACK(pwnd) == NULL);  \
        return;                                    \
    }

/*
 * REEVALUATE_PSBTRACK
 * This macro just refreshes the local variable pSBTrack, in case it has
 * been changed during a callback.  After performing this operation, pSBTrack
 * should be tested to make sure it is not now NULL.
 */
#if DBG
#define REEVALUATE_PSBTRACK(pSBTrack, pwnd, str)          \
    if ((pSBTrack) != PWNDTOPSBTRACK(pwnd)) {             \
        RIPMSG3(RIP_VERBOSE,                              \
                "%s: pSBTrack changed from %#p to %#p",   \
                (str), (pSBTrack), PWNDTOPSBTRACK(pwnd)); \
    }                                                     \
    (pSBTrack) = PWNDTOPSBTRACK(pwnd)
#else
#define REEVALUATE_PSBTRACK(pSBTrack, pwnd, str)          \
    (pSBTrack) = PWNDTOPSBTRACK(pwnd)
#endif

/***************************************************************************\
* HitTestScrollBar
*
* 11/15/96      vadimg          ported from Memphis sources
\***************************************************************************/

int HitTestScrollBar(PWND pwnd, BOOL fVert, POINT pt)
{
    UINT wDisable;
    int px;
    BOOL fCtl = IsScrollBarControl(pwnd);
    SBCALC SBCalc, *pSBCalc;

    if (fCtl) {
        wDisable = ((PSBWND)pwnd)->wDisableFlags;
    } else {
        //
        // Reflect the click coordinates on the horizontal
        // scroll bar if the window is mirrored
        //
        if (TestWF(pwnd,WEFLAYOUTRTL) && !fVert) {
            pt.x = pwnd->rcWindow.right - pt.x;
        } else {
            pt.x -= pwnd->rcWindow.left;
        }

        pt.y -= pwnd->rcWindow.top;
        wDisable = GetWndSBDisableFlags(pwnd, fVert);
    }

    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return HTERROR;
    }

    if (fCtl) {
        pSBCalc = &(((PSBWND)pwnd)->SBCalc);
    } else {
        pSBCalc = &SBCalc;
        CalcSBStuff(pwnd, pSBCalc, fVert);
    }

    px = fVert ? pt.y : pt.x;

    if (px < pSBCalc->pxUpArrow) {
        if (wDisable & LTUPFLAG) {
            return HTERROR;
        }
        return HTSCROLLUP;
    } else if (px >= pSBCalc->pxDownArrow) {
        if (wDisable & RTDNFLAG) {
            return HTERROR;
        }
        return HTSCROLLDOWN;
    } else if (px < pSBCalc->pxThumbTop) {
        return HTSCROLLUPPAGE;
    } else if (px < pSBCalc->pxThumbBottom) {
        return HTSCROLLTHUMB;
    } else if (px < pSBCalc->pxDownArrow) {
        return HTSCROLLDOWNPAGE;
    }
    return HTERROR;
}

BOOL _SBGetParms(
    PWND pwnd,
    int code,
    PSBDATA pw,
    LPSCROLLINFO lpsi)
{
    PSBTRACK pSBTrack;

    pSBTrack = PWNDTOPSBTRACK(pwnd);


    if (lpsi->fMask & SIF_RANGE) {
        lpsi->nMin = pw->posMin;
        lpsi->nMax = pw->posMax;
    }

    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw->page;

    if (lpsi->fMask & SIF_POS) {
        lpsi->nPos = pw->pos;
    }

    if (lpsi->fMask & SIF_TRACKPOS)
    {
        if (pSBTrack && (pSBTrack->nBar == code) && (pSBTrack->spwndTrack == pwnd)) {
            // posNew is in the context of psbiSB's window and bar code
            lpsi->nTrackPos = pSBTrack->posNew;
        } else {
            lpsi->nTrackPos = pw->pos;
        }
    }
    return ((lpsi->fMask & SIF_ALL) ? TRUE : FALSE);
}

/***************************************************************************\
* GetWndSBDisableFlags
*
* This returns the scroll bar Disable flags of the scroll bars of a
*  given Window.
*
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

UINT GetWndSBDisableFlags(
    PWND pwnd,  // The window whose scroll bar Disable Flags are to be returned;
    BOOL fVert)  // If this is TRUE, it means Vertical scroll bar.
{
    PSBINFO pw;

    if ((pw = pwnd->pSBInfo) == NULL) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    return (fVert ? (pw->WSBflags & WSB_VERT) >> 2 : pw->WSBflags & WSB_HORZ);
}


/***************************************************************************\
*  xxxEnableSBCtlArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar Control
*
* History:
* 04-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableSBCtlArrows(
    PWND pwnd,
    UINT wArrows)
{
    UINT wOldFlags;
    UINT wNewFlags;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    wOldFlags = ((PSBWND)pwnd)->wDisableFlags; // Get the original status

    if (wArrows == ESB_ENABLE_BOTH) {      // Enable both the arrows
        ((PSBWND)pwnd)->wDisableFlags &= ~SB_DISABLE_MASK;
    } else {
        ((PSBWND)pwnd)->wDisableFlags |= wArrows;
    }

    /*
     * Check if the status has changed because of this call
     */
    if (wOldFlags == ((PSBWND)pwnd)->wDisableFlags)
        return FALSE;

    /*
     * Else, redraw the scroll bar control to reflect the new state
     */
    if (IsVisible(pwnd))
        xxxInvalidateRect(pwnd, NULL, TRUE);

    wNewFlags = ((PSBWND)pwnd)->wDisableFlags;

    /*
     * state change notifications
     */
    if ((wOldFlags & ESB_DISABLE_UP) != (wNewFlags & ESB_DISABLE_UP)) {
        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_CLIENT,
                INDEX_SCROLLBAR_UP, WEF_USEPWNDTHREAD);
    }

    if ((wOldFlags & ESB_DISABLE_DOWN) != (wNewFlags & ESB_DISABLE_DOWN)) {
        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_CLIENT,
                INDEX_SCROLLBAR_DOWN, WEF_USEPWNDTHREAD);
    }

    return TRUE;
}


/***************************************************************************\
* xxxEnableWndSBArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a Window Scroll bar(s)
*
* History:
*  4-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableWndSBArrows(
    PWND pwnd,
    UINT wSBflags,
    UINT wArrows)
{
    INT wOldFlags;
    PSBINFO pw;
    BOOL bRetValue = FALSE;
    HDC hdc;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if ((pw = pwnd->pSBInfo) != NULL) {
        wOldFlags = pw->WSBflags;
    } else {

        /*
         * Originally everything is enabled; Check to see if this function is
         * asked to disable anything; Otherwise, no change in status; So, must
         * return immediately;
         */
        if(!wArrows)
            return FALSE;          // No change in status!

        wOldFlags = 0;    // Both are originally enabled;
        if((pw = _InitPwSB(pwnd)) == NULL)  // Allocate the pSBInfo for hWnd
            return FALSE;
    }


    if((hdc = _GetWindowDC(pwnd)) == NULL)
        return FALSE;

    /*
     *  First Take care of the Horizontal Scroll bar, if one exists.
     */
    if((wSBflags == SB_HORZ) || (wSBflags == SB_BOTH)) {
        if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
            pw->WSBflags &= ~SB_DISABLE_MASK;
        else
            pw->WSBflags |= wArrows;

        /*
         * Update the display of the Horizontal Scroll Bar;
         */
        if(pw->WSBflags != wOldFlags) {
            bRetValue = TRUE;
            wOldFlags = pw->WSBflags;
            if (TestWF(pwnd, WFHPRESENT) && !TestWF(pwnd, WFMINIMIZED) &&
                    IsVisible(pwnd)) {
                xxxDrawScrollBar(pwnd, hdc, FALSE);  // Horizontal Scroll Bar.
            }
        }
        // Left button
        if ((wOldFlags & ESB_DISABLE_LEFT) != (pw->WSBflags & ESB_DISABLE_LEFT)) {
            xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_HSCROLL,
                    INDEX_SCROLLBAR_UP, WEF_USEPWNDTHREAD);
        }

        // Right button
        if ((wOldFlags & ESB_DISABLE_RIGHT) != (pw->WSBflags & ESB_DISABLE_RIGHT)) {
            xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_HSCROLL,
                    INDEX_SCROLLBAR_DOWN, WEF_USEPWNDTHREAD);
        }
    }

    /*
     *  Then take care of the Vertical Scroll bar, if one exists.
     */
    if((wSBflags == SB_VERT) || (wSBflags == SB_BOTH)) {
        if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
            pw->WSBflags &= ~(SB_DISABLE_MASK << 2);
        else
            pw->WSBflags |= (wArrows << 2);

        /*
         * Update the display of the Vertical Scroll Bar;
         */
        if(pw->WSBflags != wOldFlags) {
            bRetValue = TRUE;
            if (TestWF(pwnd, WFVPRESENT) && !TestWF(pwnd, WFMINIMIZED) &&
                    IsVisible(pwnd)) {
                xxxDrawScrollBar(pwnd, hdc, TRUE);  // Vertical Scroll Bar
            }

            // Up button
            if ((wOldFlags & (ESB_DISABLE_UP << 2)) != (pw->WSBflags & (ESB_DISABLE_UP << 2))) {
                xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_VSCROLL,
                        INDEX_SCROLLBAR_UP, WEF_USEPWNDTHREAD);
            }

            // Down button
            if ((wOldFlags & (ESB_DISABLE_DOWN << 2)) != (pw->WSBflags & (ESB_DISABLE_DOWN << 2))) {
                xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_VSCROLL,
                        INDEX_SCROLLBAR_DOWN, WEF_USEPWNDTHREAD);
            }
        }
    }

    _ReleaseDC(hdc);

    return bRetValue;
}


/***************************************************************************\
* EnableScrollBar()
*
* This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar; It could be used with Windows Scroll
*     bars as well as scroll bar controls
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableScrollBar(
    PWND pwnd,
    UINT wSBflags,  // Whether it is a Window Scroll Bar; if so, HORZ or VERT?
                    // Possible values are SB_HORZ, SB_VERT, SB_CTL or SB_BOTH
    UINT wArrows)   // Which arrows must be enabled/disabled:
                    // ESB_ENABLE_BOTH = > Enable both arrows.
                    // ESB_DISABLE_LTUP = > Disable Left/Up arrow;
                    // ESB_DISABLE_RTDN = > DIsable Right/Down arrow;
                    // ESB_DISABLE_BOTH = > Disable both the arrows;
{
#define ES_NOTHING 0
#define ES_DISABLE 1
#define ES_ENABLE  2
    UINT wOldFlags;
    UINT wEnableWindow;

    CheckLock(pwnd);

    if(wSBflags != SB_CTL) {
        return xxxEnableWndSBArrows(pwnd, wSBflags, wArrows);
    }

    /*
     *  Let us assume that we don't have to call EnableWindow
     */
    wEnableWindow = ES_NOTHING;

    wOldFlags = ((PSBWND)pwnd)->wDisableFlags & (UINT)SB_DISABLE_MASK;

    /*
     * Check if the present state of the arrows is exactly the same
     *  as what the caller wants:
     */
    if (wOldFlags == wArrows)
        return FALSE ;          // If so, nothing needs to be done;

    /*
     * Check if the caller wants to disable both the arrows
     */
    if (wArrows == ESB_DISABLE_BOTH) {
        wEnableWindow = ES_DISABLE;      // Yes! So, disable the whole SB Ctl.
    } else {

        /*
         * Check if the caller wants to enable both the arrows
         */
        if(wArrows == ESB_ENABLE_BOTH) {

            /*
             * We need to enable the SB Ctl only if it was already disabled.
             */
            if(wOldFlags == ESB_DISABLE_BOTH)
                wEnableWindow = ES_ENABLE;// EnableWindow(.., TRUE);
        } else {

            /*
             * Now, Caller wants to disable only one arrow;
             * Check if one of the arrows was already disabled and we want
             * to disable the other;If so, the whole SB Ctl will have to be
             * disabled; Check if this is the case:
             */
            if((wOldFlags | wArrows) == ESB_DISABLE_BOTH)
                wEnableWindow = ES_DISABLE;      // EnableWindow(, FALSE);
         }
    }
    if(wEnableWindow != ES_NOTHING) {

        /*
         * EnableWindow returns old state of the window; We must return
         * TRUE only if the Old state is different from new state.
         */
        if(xxxEnableWindow(pwnd, (BOOL)(wEnableWindow == ES_ENABLE))) {
            return !(TestWF(pwnd, WFDISABLED));
        } else {
            return TestWF(pwnd, WFDISABLED);
        }
    }

    return (BOOL)xxxSendMessage(pwnd, SBM_ENABLE_ARROWS, (DWORD)wArrows, 0);
#undef ES_NOTHING
#undef ES_DISABLE
#undef ES_ENABLE
}

/***************************************************************************\
*
*  DrawSize() -
*
\***************************************************************************/
void FAR DrawSize(PWND pwnd, HDC hdc, int cxFrame,int cyFrame)
{
    int     x, y;
    //HBRUSH  hbrSave;

    if (TestWF(pwnd, WEFLEFTSCROLL)) {
        x = cxFrame;
    } else {
        x = pwnd->rcWindow.right - pwnd->rcWindow.left - cxFrame - SYSMET(CXVSCROLL);
    }
    y = pwnd->rcWindow.bottom - pwnd->rcWindow.top  - cyFrame - SYSMET(CYHSCROLL);

    // If we have a scrollbar control, or the sizebox is not associated with
    // a sizeable window, draw the flat gray sizebox.  Otherwise, use the
    // sizing grip.
    if (IsScrollBarControl(pwnd))
    {
        if (TestWF(pwnd, SBFSIZEGRIP))
            goto DrawSizeGrip;
        else
            goto DrawBox;

    }
    else if (!SizeBoxHwnd(pwnd))
    {
DrawBox:
        {
            //hbrSave = GreSelectBrush(hdc, SYSHBR(3DFACE));
            //GrePatBlt(hdc, x, y, SYSMET(CXVSCROLL), SYSMET(CYHSCROLL), PATCOPY);
            //GreSelectBrush(hdc, hbrSave);

            POLYPATBLT PolyData;

            PolyData.x         = x;
            PolyData.y         = y;
            PolyData.cx        = SYSMET(CXVSCROLL);
            PolyData.cy        = SYSMET(CYHSCROLL);
            PolyData.BrClr.hbr = SYSHBR(3DFACE);

            GrePolyPatBlt(hdc,PATCOPY,&PolyData,1,PPB_BRUSH);

        }
    }
    else
    {
DrawSizeGrip:
        // Blt out the grip bitmap.
        BitBltSysBmp(hdc, x, y, TestWF(pwnd, WEFLEFTSCROLL) ? OBI_NCGRIP_L : OBI_NCGRIP);
    }
}

/***************************************************************************\
* xxxSelectColorObjects
*
*
*
* History:
\***************************************************************************/

HBRUSH xxxGetColorObjects(
    PWND pwnd,
    HDC hdc)
{
    HBRUSH hbrRet;

    CheckLock(pwnd);

    // Use the scrollbar color even if the scrollbar is disabeld.
    if (!IsScrollBarControl(pwnd))
        hbrRet = (HBRUSH)xxxDefWindowProc(pwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)HWq(pwnd));
    else {
        // B#12770 - GetControlBrush sends a WM_CTLCOLOR message to the
        // owner.  If the app doesn't process the message, DefWindowProc32
        // will always return the appropriate system brush. If the app.
        // returns an invalid object, GetControlBrush will call DWP for
        // the default brush. Thus hbrRet doesn't need any validation
        // here.
        hbrRet = xxxGetControlBrush(pwnd, hdc, WM_CTLCOLORSCROLLBAR);
    }

    return hbrRet;
}

/***************************************************************************\
*
*  DrawGroove()
*
*  Draws lines & middle of thumb groove
*  Note that pw points into prc.  Moreover, note that both pw & prc are
*  NEAR pointers, so *prc better not be on the stack.
*
\***************************************************************************/
void NEAR DrawGroove(HDC hdc, HBRUSH  hbr, LPRECT prc, BOOL fVert)
{
    if ((hbr == SYSHBR(3DHILIGHT)) || (hbr == gpsi->hbrGray))
        FillRect(hdc, prc, hbr);
    else
    {
        RECT    rc;

    // Draw sides
        CopyRect(&rc, prc);
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_FLAT |
            (fVert ? BF_LEFT | BF_RIGHT : BF_TOP | BF_BOTTOM));

    // Fill middle
        FillRect(hdc, &rc, hbr);
    }
}

/***************************************************************************\
* CalcTrackDragRect
*
* Give the rectangle for a scrollbar in pSBTrack->pSBCalc,
* calculate pSBTrack->rcTrack, the rectangle where tracking
* may occur without cancelling the thumbdrag operation.
*
\***************************************************************************/

void CalcTrackDragRect(PSBTRACK pSBTrack) {

    int     cx;
    int     cy;
    LPINT   pwX, pwY;

    //
    // Point pwX and pwY at the parts of the rectangle
    // corresponding to pSBCalc->pxLeft, pxTop, etc.
    //
    // pSBTrack->pSBCalc->pxLeft is the left edge of a vertical
    // scrollbar and the top edge of horizontal one.
    // pSBTrack->pSBCalc->pxTop is the top of a vertical
    // scrollbar and the left of horizontal one.
    // etc...
    //
    // Point pwX and pwY to the corresponding parts
    // of pSBTrack->rcTrack.
    //

    pwX = pwY = (LPINT)&pSBTrack->rcTrack;

    if (pSBTrack->fTrackVert) {
        cy = SYSMET(CYVTHUMB);
        pwY++;
    } else {
        cy = SYSMET(CXHTHUMB);
        pwX++;
    }
    /*
     * Later5.0 GerardoB: People keep complaining about this tracking region
     *  being too narrow so let's make it wider while PM decides what to do
     *  about it.
     * We also used to have some hard coded min and max values but that should
     *  depend on some metric, if at all needed.
     */
    cx = (pSBTrack->pSBCalc->pxRight - pSBTrack->pSBCalc->pxLeft) * 8;
    cy *= 2;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft - cx;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop - cy;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight + cx;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom + cy;
}

void RecalcTrackRect(PSBTRACK pSBTrack) {
    LPINT pwX, pwY;
    RECT rcSB;


    if (!pSBTrack->fCtlSB)
        CalcSBStuff(pSBTrack->spwndTrack, pSBTrack->pSBCalc, pSBTrack->fTrackVert);

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom;

    switch(pSBTrack->cmdSB) {
    case SB_LINEUP:
        *(pwY + 2) = pSBTrack->pSBCalc->pxUpArrow;
        break;
    case SB_LINEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    case SB_PAGEUP:
        *(pwY + 0) = pSBTrack->pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBTrack->pSBCalc->pxThumbTop;
        break;
    case SB_THUMBPOSITION:
        CalcTrackDragRect(pSBTrack);
        break;
    case SB_PAGEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    }

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }
}

/***************************************************************************\
* DrawThumb2
*
*
*
* History:
* 01-03-94  FritzS   Chicago changes
\***************************************************************************/

void DrawThumb2(
    PWND pwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    HBRUSH hbr,
    BOOL fVert,
    UINT wDisable)  /* Disabled flags for the scroll bar */
{
    int    *pLength;
    int    *pWidth;
    RECT   rcSB;
    PSBTRACK pSBTrack;

    //
    // Bail out if the scrollbar has an empty rect
    //
    if ((pSBCalc->pxTop >= pSBCalc->pxBottom) || (pSBCalc->pxLeft >= pSBCalc->pxRight))
        return;
    pLength = (LPINT)&rcSB;
    if (fVert)
        pWidth = pLength++;
    else
        pWidth  = pLength + 1;

    pWidth[0] = pSBCalc->pxLeft;
    pWidth[2] = pSBCalc->pxRight;

    /*
     * If both scroll bar arrows are disabled, then we should not draw
     * the thumb.  So, quit now!
     */
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) ||
        ((pSBCalc->pxDownArrow - pSBCalc->pxUpArrow) < pSBCalc->cpxThumb)) {
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxDownArrow;

        DrawGroove(hdc, hbr, &rcSB, fVert);
        return;
    }

    if (pSBCalc->pxUpArrow < pSBCalc->pxThumbTop) {
        // Fill in space above Thumb
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxThumbTop;

        DrawGroove(hdc, hbr, &rcSB, fVert);
    }

    if (pSBCalc->pxThumbBottom < pSBCalc->pxDownArrow) {
        // Fill in space below Thumb
        pLength[0] = pSBCalc->pxThumbBottom;
        pLength[2] = pSBCalc->pxDownArrow;

        DrawGroove(hdc, hbr, &rcSB, fVert);
    }

    //
    // Draw elevator
    //
    pLength[0] = pSBCalc->pxThumbTop;
    pLength[2] = pSBCalc->pxThumbBottom;

    // Not soft!
    DrawPushButton(hdc, &rcSB, 0, 0);

    /*
     * If we're tracking a page scroll, then we've obliterated the hilite.
     * We need to correct the hiliting rectangle, and rehilite it.
     */
    pSBTrack = PWNDTOPSBTRACK(pwnd);

    if (pSBTrack && (pSBTrack->cmdSB == SB_PAGEUP || pSBTrack->cmdSB == SB_PAGEDOWN) &&
            (pwnd == pSBTrack->spwndTrack) &&
            (BOOL)pSBTrack->fTrackVert == fVert) {

        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        pLength = (int *)&pSBTrack->rcTrack;

        if (fVert)
            pLength++;

        if (pSBTrack->cmdSB == SB_PAGEUP)
            pLength[2] = pSBCalc->pxThumbTop;
        else
            pLength[0] = pSBCalc->pxThumbBottom;

        if (pLength[0] < pLength[2])
            InvertRect(hdc, &pSBTrack->rcTrack);
    }
}

/***************************************************************************\
* xxxDrawSB2
*
*
*
* History:
\***************************************************************************/

void xxxDrawSB2(
    PWND pwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    BOOL fVert,
    UINT wDisable)
{

    int     cLength;
    int     cWidth;
    int     *pwX;
    int     *pwY;
    HBRUSH hbr;
    HBRUSH hbrSave;
    int cpxArrow;
    RECT    rc, rcSB;
    COLORREF crText, crBk;

    CheckLock(pwnd);

    cLength = (pSBCalc->pxBottom - pSBCalc->pxTop) / 2;
    cWidth = (pSBCalc->pxRight - pSBCalc->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0)) {
        return;
    }
    if (fVert)
        cpxArrow = SYSMET(CYVSCROLL);
    else
        cpxArrow = SYSMET(CXHSCROLL);

    /*
     * Save background and DC color, since they get changed in
     * xxxGetColorObjects. Restore before we return.
     */
    crBk = GreGetBkColor(hdc);
    crText = GreGetTextColor(hdc);

    hbr = xxxGetColorObjects(pwnd, hdc);

    if (cLength > cpxArrow)
        cLength = cpxArrow;
    pwX = (int *)&rcSB;
    pwY = pwX + 1;
    if (!fVert)
        pwX = pwY--;

    pwX[0] = pSBCalc->pxLeft;
    pwY[0] = pSBCalc->pxTop;
    pwX[2] = pSBCalc->pxRight;
    pwY[2] = pSBCalc->pxBottom;

    hbrSave = GreSelectBrush(hdc, SYSHBR(BTNTEXT));

    //
    // BOGUS
    // Draw scrollbar arrows as disabled if the scrollbar itself is
    // disabled OR if the window it is a part of is disabled?
    //
    if (fVert) {
        if ((cLength == SYSMET(CYVSCROLL)) && (cWidth == SYSMET(CXVSCROLL))) {
            BitBltSysBmp(hdc, rcSB.left, rcSB.top, (wDisable & LTUPFLAG) ? OBI_UPARROW_I : OBI_UPARROW);
            BitBltSysBmp(hdc, rcSB.left, rcSB.bottom - cLength, (wDisable & RTDNFLAG) ? OBI_DNARROW_I : OBI_DNARROW);
        } else {
            CopyRect(&rc, &rcSB);
            rc.bottom = rc.top + cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLUP | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

            rc.bottom = rcSB.bottom;
            rc.top = rcSB.bottom - cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLDOWN | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
    } else {
        if ((cLength == SYSMET(CXHSCROLL)) && (cWidth == SYSMET(CYHSCROLL))) {
            BitBltSysBmp(hdc, rcSB.left, rcSB.top, (wDisable & LTUPFLAG) ? OBI_LFARROW_I : OBI_LFARROW);
            BitBltSysBmp(hdc, rcSB.right - cLength, rcSB.top, (wDisable & RTDNFLAG) ? OBI_RGARROW_I : OBI_RGARROW);
        } else {
            CopyRect(&rc, &rcSB);
            rc.right = rc.left + cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLLEFT | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

            rc.right = rcSB.right;
            rc.left = rcSB.right - cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLRIGHT | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
    }

    hbrSave = GreSelectBrush(hdc, hbrSave);
    DrawThumb2(pwnd, pSBCalc, hdc, hbr, fVert, wDisable);
    GreSelectBrush(hdc, hbrSave);

    GreSetBkColor(hdc, crBk);
    GreSetTextColor(hdc, crText);
}

/***************************************************************************\
* zzzSetSBCaretPos
*
*
*
* History:
\***************************************************************************/

void zzzSetSBCaretPos(
    PSBWND psbwnd)
{

    if ((PWND)psbwnd == PtiCurrent()->pq->spwndFocus) {
        zzzSetCaretPos((psbwnd->fVert ? psbwnd->SBCalc.pxLeft : psbwnd->SBCalc.pxThumbTop) + SYSMET(CXEDGE),
                (psbwnd->fVert ? psbwnd->SBCalc.pxThumbTop : psbwnd->SBCalc.pxLeft) + SYSMET(CYEDGE));
    }
}

/***************************************************************************\
* CalcSBStuff2
*
*
*
* History:
\***************************************************************************/

void CalcSBStuff2(
    PSBCALC  pSBCalc,
    LPRECT lprc,
    CONST PSBDATA pw,
    BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->pos = pw->pos;
    pSBCalc->page = pw->page;
    pSBCalc->posMin = pw->posMin;
    pSBCalc->posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->posMax - pSBCalc->posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing EngMulDiv twice.
         */
        int i = EngMulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = EngMulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

}

/***************************************************************************\
* SBCtlSetup
*
*
*
* History:
\***************************************************************************/

void SBCtlSetup(
    PSBWND psbwnd)
{
    RECT rc;

    GetRect((PWND)psbwnd, &rc, GRECT_CLIENT | GRECT_CLIENTCOORDS);
    CalcSBStuff2(&psbwnd->SBCalc, &rc, (PSBDATA)&psbwnd->SBCalc, psbwnd->fVert);
}

/***************************************************************************\
* HotTrackSB
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

DWORD GetTrackFlags(int ht, BOOL fDraw)
{
    if (fDraw) {
        switch(ht) {
        case HTSCROLLUP:
        case HTSCROLLUPPAGE:
            return LTUPFLAG;

        case HTSCROLLDOWN:
        case HTSCROLLDOWNPAGE:
            return RTDNFLAG;

        case HTSCROLLTHUMB:
            return LTUPFLAG | RTDNFLAG;

        default:
            return 0;
        }
    } else {
        return 0;
    }
}

BOOL xxxHotTrackSB(PWND pwnd, int htEx, BOOL fDraw)
{
    SBCALC SBCalc;
    HDC  hdc;
    BOOL fVert = HIWORD(htEx);
    int ht = LOWORD(htEx);
    DWORD dwTrack = GetTrackFlags(ht, fDraw);

    CheckLock(pwnd);

    /*
     * xxxDrawSB2 does not callback or leave the critical section when it's
     * not a SB control and the window belongs to a different thread. It
     * calls xxxDefWindowProc which simply returns the brush color.
     */
    CalcSBStuff(pwnd, &SBCalc, fVert);
    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2(pwnd, &SBCalc, hdc, fVert, GetWndSBDisableFlags(pwnd, fVert), dwTrack);
    _ReleaseDC(hdc);
    return TRUE;
}

void xxxHotTrackSBCtl(PSBWND psbwnd, int ht, BOOL fDraw)
{
    DWORD dwTrack = GetTrackFlags(ht, fDraw);
    HDC hdc;

    CheckLock(psbwnd);

    SBCtlSetup(psbwnd);
    hdc = _GetDCEx((PWND)psbwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2((PWND)psbwnd, &psbwnd->SBCalc, hdc, psbwnd->fVert, psbwnd->wDisableFlags, dwTrack);
    _ReleaseDC(hdc);
}
#endif // COLOR_HOTTRACKING

BOOL SBSetParms(PSBDATA pw, LPSCROLLINFO lpsi, LPBOOL lpfScroll, LPLONG lplres)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (lpsi->fMask & SIF_RETURNOLDPOS)
        // save previous position
        *lplres = pw->pos;

    if (lpsi->fMask & SIF_RANGE) {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (lpsi->nMax < lpsi->nMin)
            lpsi->nMax = lpsi->nMin;

        if ((pw->posMin != lpsi->nMin) || (pw->posMax != lpsi->nMax)) {
            pw->posMin = lpsi->nMin;
            pw->posMax = lpsi->nMax;

            if (!(lpsi->fMask & SIF_PAGE)) {
                lpsi->fMask |= SIF_PAGE;
                lpsi->nPage = pw->page;
            }

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_PAGE) {
        DWORD dwMaxPage = (DWORD) abs(pw->posMax - pw->posMin) + 1;

        // Clip page to 0, posMax - posMin + 1

        if (lpsi->nPage > dwMaxPage)
            lpsi->nPage = dwMaxPage;


        if (pw->page != (int)(lpsi->nPage)) {
            pw->page = lpsi->nPage;

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_POS) {
        int iMaxPos = pw->posMax - ((pw->page) ? pw->page - 1 : 0);
        // Clip pos to posMin, posMax - (page - 1).

        if (lpsi->nPos < pw->posMin)
            lpsi->nPos = pw->posMin;
        else if (lpsi->nPos > iMaxPos)
            lpsi->nPos = iMaxPos;


        if (pw->pos != lpsi->nPos) {
            pw->pos = lpsi->nPos;
            fChanged = TRUE;
        }
    }

    if (!(lpsi->fMask & SIF_RETURNOLDPOS)) {
        // Return the new position
        *lplres = pw->pos;
    }

    /*
     * This was added by JimA as Cairo merge but will conflict
     * with the documentation for SetScrollPos
     */
/*
    else if (*lplres == pw->pos)
        *lplres = 0;
*/
    if (lpsi->fMask & SIF_RANGE) {
        if (*lpfScroll = (pw->posMin != pw->posMax))
            goto checkPage;
    } else if (lpsi->fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw->page <= (pw->posMax - pw->posMin));

    return fChanged;
}


/***************************************************************************\
* CalcSBStuff
*
*
*
* History:
\***************************************************************************/

void CalcSBStuff(
    PWND pwnd,
    PSBCALC pSBCalc,
    BOOL fVert)
{
    RECT    rcT;
    RECT    rcClient;
    int     cx, iTemp;

    //
    // Get client rectangle.  We know that scrollbars always align to the right
    // and to the bottom of the client area.
    //
    GetRect(pwnd, &rcClient, GRECT_CLIENT | GRECT_WINDOWCOORDS);
    
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        cx             = pwnd->rcWindow.right - pwnd->rcWindow.left;
        iTemp          = rcClient.left;
        rcClient.left  = cx - rcClient.right;
        rcClient.right = cx - iTemp;
    }

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(pwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = rcClient.left;
            if (TestWF(pwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = rcClient.right;
            if (TestWF(pwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = rcClient.top;
        rcT.bottom = rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = rcClient.bottom;
        if (TestWF(pwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = rcClient.left;
        rcT.right = rcClient.right;
    }

    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    if (_InitPwSB(pwnd))
        CalcSBStuff2(pSBCalc, &rcT, (fVert) ? &pwnd->pSBInfo->Vert :  &pwnd->pSBInfo->Horz, fVert);

}

/***************************************************************************\
*
*  DrawCtlThumb()
*
\***************************************************************************/
void DrawCtlThumb(PSBWND psb)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc = (HDC) _GetWindowDC((PWND) psb);

    SBCtlSetup(psb);

    hbrSave = GreSelectBrush(hdc, hbr = xxxGetColorObjects((PWND) psb, hdc));

    DrawThumb2((PWND) psb, &psb->SBCalc, hdc, hbr, psb->fVert, psb->wDisableFlags);

    GreSelectBrush(hdc, hbrSave);
    _ReleaseDC(hdc);
}


/***************************************************************************\
* xxxDrawThumb
*
*
*
* History:
\***************************************************************************/

void xxxDrawThumb(
    PWND pwnd,
    PSBCALC pSBCalc,
    BOOL fVert)
{
    HBRUSH hbr, hbrSave;
    HDC hdc;
    UINT wDisableFlags;
    SBCALC SBCalc;

    CheckLock(pwnd);

    if (!pSBCalc) pSBCalc = &SBCalc;
    hdc = (HDC)_GetWindowDC(pwnd);

    CalcSBStuff(pwnd, &SBCalc, fVert);
    wDisableFlags = GetWndSBDisableFlags(pwnd, fVert);

    hbrSave = GreSelectBrush(hdc, hbr = xxxGetColorObjects(pwnd, hdc));

    DrawThumb2(pwnd, &SBCalc, hdc, hbr, fVert, wDisableFlags);

    GreSelectBrush(hdc, hbrSave);

    /*
     * Won't hurt even if DC is already released (which happens automatically
     * if window is destroyed during xxxSelectColorObjects)
     */
    _ReleaseDC(hdc);
}

/***************************************************************************\
* xxxSetScrollBar
*
*
*
* History:
\***************************************************************************/

LONG xxxSetScrollBar(
    PWND pwnd,
    int code,
    LPSCROLLINFO lpsi,
    BOOL fRedraw)
{
    BOOL        fVert;
    PSBDATA pw;
    PSBINFO pSBInfo;
    BOOL fOldScroll;
    BOOL fScroll;
    WORD        wfScroll;
    LONG     lres;
    BOOL        fNewScroll;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (fRedraw)
        // window must be visible to redraw
        fRedraw = IsVisible(pwnd);

    if (code == SB_CTL)
#ifdef FE_SB // xxxSetScrollBar()
        // scroll bar control; send the control a message
        if(GETPTI(pwnd)->TIF_flags & TIF_16BIT) {
            //
            // If the target application is 16bit apps, we don't pass win40's message.
            // This fix for Ichitaro v6.3. It eats the message. It never forwards
            // the un-processed messages to original windows procedure via
            // CallWindowProc().
            //
            // Is this from xxxSetScrollPos() ?
            if(lpsi->fMask == (SIF_POS|SIF_RETURNOLDPOS)) {
                return (int)xxxSendMessage(pwnd, SBM_SETPOS, lpsi->nPos, fRedraw);
            // Is this from xxxSetScrollRange() ?
            } else if(lpsi->fMask == SIF_RANGE) {
                xxxSendMessage(pwnd, SBM_SETRANGE, lpsi->nMin, lpsi->nMax);
                return TRUE;
            // Others...
            } else {
                return (LONG)xxxSendMessage(pwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
            }
        } else {
            return (LONG)xxxSendMessage(pwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
        }
#else
        // scroll bar control; send the control a message
        return (LONG)xxxSendMessage(pwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
#endif // FE_SB

    fVert = (code != SB_HORZ);

    wfScroll = (fVert) ? WFVSCROLL : WFHSCROLL;

    fScroll = fOldScroll = (TestWF(pwnd, wfScroll)) ? TRUE : FALSE;

    /*
     * Don't do anything if we're setting position of a nonexistent scroll bar.
     */
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll && (pwnd->pSBInfo == NULL)) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    if (fNewScroll = !(pSBInfo = pwnd->pSBInfo)) {
        if ((pSBInfo = _InitPwSB(pwnd)) == NULL)
            return 0;
    }

    pw = (fVert) ? &(pSBInfo->Vert) : &(pSBInfo->Horz);

    if (!SBSetParms(pw, lpsi, &fScroll, &lres) && !fNewScroll) {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
            goto redrawAfterSet;

        return lres;
    }

    ClrWF(pwnd, wfScroll);

    if (fScroll)
        SetWF(pwnd, wfScroll);
    else if (!TestWF(pwnd, (WFHSCROLL | WFVSCROLL))) {
        // if neither scroll bar is set and both ranges are 0, then free up the
        // scroll info

        pSBInfo = pwnd->pSBInfo;

        if ((pSBInfo->Horz.posMin == pSBInfo->Horz.posMax) &&
            (pSBInfo->Vert.posMin == pSBInfo->Vert.posMax)) {
            DesktopFree(pwnd->head.rpdesk, (HANDLE)(pwnd->pSBInfo));
            pwnd->pSBInfo = NULL;
        }
    }

    if (lpsi->fMask & SIF_DISABLENOSCROLL) {
        if (fOldScroll) {
            SetWF(pwnd, wfScroll);
            xxxEnableWndSBArrows(pwnd, code, (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
        }
    } else if (fOldScroll ^ fScroll) {
        PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
        if (pSBTrack && (pwnd == pSBTrack->spwndTrack)) {
            pSBTrack->fTrackRecalc = TRUE;
        }
        xxxRedrawFrame(pwnd);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        return lres;
    }

    if (fScroll && fRedraw && (fVert ? TestWF(pwnd, WFVPRESENT) : TestWF(pwnd, WFHPRESENT))) {
        PSBTRACK pSBTrack;
redrawAfterSet:
        xxxWindowEvent(EVENT_OBJECT_VALUECHANGE, pwnd, (fVert ? OBJID_VSCROLL : OBJID_HSCROLL),
                INDEX_SCROLLBAR_SELF, WEF_USEPWNDTHREAD);
        
        pSBTrack = PWNDTOPSBTRACK(pwnd);
        // Bail out if the caller is trying to change the position of
        // a scrollbar that is in the middle of tracking.  We'll hose
        // TrackThumb() otherwise.

        if (pSBTrack && (pwnd == pSBTrack->spwndTrack) &&
                ((BOOL)(pSBTrack->fTrackVert) == fVert) &&
                (pSBTrack->xxxpfnSB == xxxTrackThumb)) {
            return lres;
        }

        xxxDrawThumb(pwnd, NULL, fVert);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
    }

    return lres;
}



/***************************************************************************\
* xxxDrawScrollBar
*
*
*
* History:
\***************************************************************************/

void xxxDrawScrollBar(
    PWND pwnd,
    HDC hdc,
    BOOL fVert)
{
    SBCALC SBCalc;
    PSBCALC pSBCalc;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);

    CheckLock(pwnd);
    if (pSBTrack && (pwnd == pSBTrack->spwndTrack) && (pSBTrack->fCtlSB == FALSE)
         && (fVert == (BOOL)pSBTrack->fTrackVert)) {
        pSBCalc = pSBTrack->pSBCalc;
    } else {
        pSBCalc = &SBCalc;
    }
    CalcSBStuff(pwnd, pSBCalc, fVert);

    xxxDrawSB2(pwnd, pSBCalc, hdc, fVert, GetWndSBDisableFlags(pwnd, fVert));
}

/***************************************************************************\
* SBPosFromPx
*
* Compute scroll bar position from pixel location
*
* History:
\***************************************************************************/

int SBPosFromPx(
    PSBCALC  pSBCalc,
    int px)
{
    if (px < pSBCalc->pxMin) {
        return pSBCalc->posMin;
    }
    if (px >= pSBCalc->pxMin + pSBCalc->cpx) {
        return (pSBCalc->posMax - (pSBCalc->page ? pSBCalc->page - 1 : 0));
    }
    if (pSBCalc->cpx)
        return (pSBCalc->posMin + EngMulDiv(pSBCalc->posMax - pSBCalc->posMin -
            (pSBCalc->page ? pSBCalc->page - 1 : 0),
            px - pSBCalc->pxMin, pSBCalc->cpx));
    else
        return (pSBCalc->posMin - 1);
}

/***************************************************************************\
* InvertScrollHilite
*
*
*
* History:
\***************************************************************************/

void InvertScrollHilite(
    PWND pwnd,
    PSBTRACK pSBTrack)
{
    HDC hdc;

    /*
     * Don't invert if the thumb is all the way at the top or bottom
     * or you will end up inverting the line between the arrow and the thumb.
     */
    if (!IsRectEmpty(&pSBTrack->rcTrack)) {
        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        hdc = (HDC)_GetWindowDC(pwnd);
        InvertRect(hdc, &pSBTrack->rcTrack);
        _ReleaseDC(hdc);
    }
}

/***************************************************************************\
* xxxDoScroll
*
* Sends scroll notification to the scroll bar owner
*
* History:
\***************************************************************************/

void xxxDoScroll(
    PWND pwnd,
    PWND pwndNotify,
    int cmd,
    int pos,
    BOOL fVert
)
{
    TL tlpwndNotify;

    /*
     * Special case!!!! this routine is always passed pwnds that are
     * not thread locked, so they need to be thread locked here.  The
     * callers always know that by the time DoScroll() returns,
     * pwnd and pwndNotify could be invalid.
     */
    ThreadLock(pwndNotify, &tlpwndNotify);
    xxxSendMessage(pwndNotify, (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
            MAKELONG(cmd, pos), (LPARAM)HW(pwnd));

    ThreadUnlock(&tlpwndNotify);
}

// -------------------------------------------------------------------------
//
//  CheckScrollRecalc()
//
// -------------------------------------------------------------------------
//void CheckScrollRecalc(PWND pwnd, PSBSTATE pSBState, PSBCALC pSBCalc)
//{
//    if ((pSBState->pwndCalc != pwnd) || ((pSBState->nBar != SB_CTL) && (pSBState->nBar != ((pSBState->fVertSB) ? SB_VERT : SB_HORZ))))
//    {
//        // Calculate SB stuff based on whether it's a control or in a window
//        if (pSBState->fCtlSB)
//            SBCtlSetup((PSBWND) pwnd);
//        else
//            CalcSBStuff(pwnd, pSBCalc, pSBState->fVertSB);
//    }
//}


/***************************************************************************\
* xxxMoveThumb
*
* History:
\***************************************************************************/

void xxxMoveThumb(
    PWND pwnd,
    PSBCALC  pSBCalc,
    int px)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc;
    PSBTRACK pSBTrack;

    CheckLock(pwnd);

    pSBTrack = PWNDTOPSBTRACK(pwnd);

    if ((pSBTrack == NULL) || (px == pSBTrack->pxOld))
        return;

pxReCalc:

    pSBTrack->posNew = SBPosFromPx(pSBCalc, px);

    /* Tentative position changed -- notify the guy. */
    if (pSBTrack->posNew != pSBTrack->posOld) {
        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify, SB_THUMBTRACK, pSBTrack->posNew, pSBTrack->fTrackVert
            );

        }
        // After xxxDoScroll, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxMoveThumb(1)");
        if ((pSBTrack == NULL) || (pSBTrack->xxxpfnSB == NULL))
            return;

        pSBTrack->posOld = pSBTrack->posNew;

        //
        // Anything can happen after the SendMessage above!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        //
//        CheckScrollRecalc(pwnd, pSBState, pSBCalc);
        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pSBCalc->pxMin + pSBCalc->cpx)
        {
            px = pSBCalc->pxMin + pSBCalc->cpx;
            goto pxReCalc;
        }

    }

    hdc = _GetWindowDC(pwnd);

    pSBCalc->pxThumbTop = px;
    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

    // at this point, the disable flags are always going to be 0 --
    // we're in the middle of tracking.
    hbrSave = GreSelectBrush(hdc, hbr = xxxGetColorObjects(pwnd, hdc));

    // After xxxGetColorObjects, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxMoveThumb(2)");
    if (pSBTrack == NULL) {
        RIPMSG1(RIP_ERROR, "Did we use to leak hdc %#p?", hdc) ;
        _ReleaseDC(hdc);
        return;
    }
    DrawThumb2(pwnd, pSBCalc, hdc, hbr, pSBTrack->fTrackVert, 0);
    GreSelectBrush(hdc, hbrSave);
    _ReleaseDC(hdc);

    pSBTrack->pxOld = px;
}

/***************************************************************************\
* zzzDrawInvertScrollArea
*
*
*
* History:
\***************************************************************************/

void zzzDrawInvertScrollArea(
    PWND pwnd,
    PSBTRACK pSBTrack,
    BOOL fHit,
    UINT cmd)
{
    HDC hdc;
    RECT rcTemp;
    int cx, cy;
    UINT bm;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN)) {
        // not hitting on arrow -- just invert the area and return
        InvertScrollHilite(pwnd, pSBTrack);

        if (cmd == SB_PAGEUP) {
            if (fHit)
                SetWF(pwnd, WFPAGEUPBUTTONDOWN);
            else
                ClrWF(pwnd, WFPAGEUPBUTTONDOWN);
        } else {
            if (fHit)
                SetWF(pwnd, WFPAGEDNBUTTONDOWN);
            else
                ClrWF(pwnd, WFPAGEDNBUTTONDOWN);
        }

        zzzWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd,
                (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                ((cmd == SB_PAGEUP) ? INDEX_SCROLLBAR_UPPAGE : INDEX_SCROLLBAR_DOWNPAGE),
                WEF_USEPWNDTHREAD);
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)
        return;
    }

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    CopyRect(&rcTemp, &pSBTrack->rcTrack);

    hdc = _GetWindowDC(pwnd);

    if (pSBTrack->fTrackVert) {
        cx = SYSMET(CXVSCROLL);
        cy = SYSMET(CYVSCROLL);
    } else {
        cx = SYSMET(CXHSCROLL);
        cy = SYSMET(CYHSCROLL);
    }

    if ((cx == (rcTemp.right - rcTemp.left)) &&
        (cy == (rcTemp.bottom - rcTemp.top))) {
        if (cmd == SB_LINEUP)
            bm = (pSBTrack->fTrackVert) ? OBI_UPARROW : OBI_LFARROW;
        else // SB_LINEDOWN
            bm = (pSBTrack->fTrackVert) ? OBI_DNARROW : OBI_RGARROW;

        if (fHit)
            bm += DOBI_PUSHED;

        BitBltSysBmp(hdc, rcTemp.left, rcTemp.top, bm);
    } else {
        DrawFrameControl(hdc, &rcTemp, DFC_SCROLL,
            ((pSBTrack->fTrackVert) ? DFCS_SCROLLVERT : DFCS_SCROLLHORZ) |
            ((fHit) ? DFCS_PUSHED | DFCS_FLAT : 0) |
            ((cmd == SB_LINEUP) ? DFCS_SCROLLMIN : DFCS_SCROLLMAX));
    }

    _ReleaseDC(hdc);


    if (cmd == SB_LINEUP) {
        if (fHit)
            SetWF(pwnd, WFLINEUPBUTTONDOWN);
        else
            ClrWF(pwnd, WFLINEUPBUTTONDOWN);
    } else {
        if (fHit)
            SetWF(pwnd, WFLINEDNBUTTONDOWN);
        else
            ClrWF(pwnd, WFLINEDNBUTTONDOWN);
    }

    zzzWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd,
            (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
            (cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN),
            WEF_USEPWNDTHREAD);
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)
}

/***************************************************************************\
* xxxEndScroll
*
*
*
* History:
\***************************************************************************/

void xxxEndScroll(
    PWND pwnd,
    BOOL fCancel)
{
    UINT oldcmd;
    PSBTRACK pSBTrack;
    CheckLock(pwnd);
    UserAssert(!IsWinEventNotifyDeferred());

    pSBTrack = PWNDTOPSBTRACK(pwnd);
    if (pSBTrack && PtiCurrent()->pq->spwndCapture == pwnd && pSBTrack->xxxpfnSB != NULL) {

        oldcmd = pSBTrack->cmdSB;
        pSBTrack->cmdSB = 0;
        xxxReleaseCapture();

        // After xxxReleaseCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        if (pSBTrack->xxxpfnSB == xxxTrackThumb) {

            if (fCancel) {
                pSBTrack->posOld = pSBTrack->pSBCalc->pos;
            }

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->spwndSBNotify != NULL) {
                xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                        SB_THUMBPOSITION, pSBTrack->posOld, pSBTrack->fTrackVert
                );
                // After xxxDoScroll, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
            }

            if (pSBTrack->fCtlSB) {
                DrawCtlThumb((PSBWND) pwnd);
            } else {
                xxxDrawThumb(pwnd, pSBTrack->pSBCalc, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }

        } else if (pSBTrack->xxxpfnSB == xxxTrackBox) {
            DWORD lParam;
            POINT ptMsg;

            if (pSBTrack->hTimerSB != 0) {
                _KillSystemTimer(pwnd, IDSYS_SCROLL);
                pSBTrack->hTimerSB = 0;
            }
            lParam = _GetMessagePos();
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                ptMsg.x = pwnd->rcWindow.right - GET_X_LPARAM(lParam);
            } else {
                ptMsg.x = GET_X_LPARAM(lParam) - pwnd->rcWindow.left;
            }
            ptMsg.y = GET_Y_LPARAM(lParam) - pwnd->rcWindow.top;
            if (PtInRect(&pSBTrack->rcTrack, ptMsg)) {
                zzzDrawInvertScrollArea(pwnd, pSBTrack, FALSE, oldcmd);
                // Note: after zzz, pSBTrack may no longer be valid
            }
        }

        /*
         * Always send SB_ENDSCROLL message.
         *
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */

        // After xxxDrawThumb or zzzDrawInvertScrollArea, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                    SB_ENDSCROLL, 0, pSBTrack->fTrackVert);
            // After xxxDoScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
        }

        ClrWF(pwnd, WFSCROLLBUTTONDOWN);
        ClrWF(pwnd, WFVERTSCROLLTRACK);

        xxxWindowEvent(EVENT_SYSTEM_SCROLLINGEND, pwnd,
                (pSBTrack->fCtlSB ? OBJID_CLIENT :
                        (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                INDEXID_CONTAINER, 0);
        
        // After xxxWindowEvent, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        /*
         * If this is a Scroll Bar Control, turn the caret back on.
         */
        if (pSBTrack->spwndSB != NULL) {
            zzzShowCaret(pSBTrack->spwndSB);
            // After zzz, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
        }


        pSBTrack->xxxpfnSB = NULL;

        /*
         * Unlock structure members so they are no longer holding down windows.
         */
        Unlock(&pSBTrack->spwndSB);
        Unlock(&pSBTrack->spwndSBNotify);
        Unlock(&pSBTrack->spwndTrack);
        UserFreePool(pSBTrack);
        PWNDTOPSBTRACK(pwnd) = NULL;
    }
}


/***************************************************************************\
* xxxContScroll
*
*
*
* History:
\***************************************************************************/

VOID xxxContScroll(
    PWND pwnd,
    UINT message,
    UINT_PTR ID,
    LPARAM lParam)
{
    LONG pt;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);

    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(lParam);

    if (pSBTrack == NULL)
        return;

    CheckLock(pwnd);

    pt = _GetMessagePos();

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        pt = MAKELONG(pwnd->rcWindow.right - GET_X_LPARAM(pt), GET_Y_LPARAM(pt) - pwnd->rcWindow.top);
    } else {
        pt = MAKELONG( GET_X_LPARAM(pt) - pwnd->rcWindow.left, GET_Y_LPARAM(pt) - pwnd->rcWindow.top);
    }
    xxxTrackBox(pwnd, WM_NULL, 0, pt, NULL);
    // After xxxTrackBox, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

    if (pSBTrack->fHitOld) {
        pSBTrack->hTimerSB = _SetSystemTimer(pwnd, IDSYS_SCROLL,
                gpsi->dtScroll / 8, xxxContScroll);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                    pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
            // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        }
    }

    return;
}

/***************************************************************************\
* xxxTrackBox
*
*
*
* History:
\***************************************************************************/

void xxxTrackBox(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    BOOL fHit;
    POINT ptHit;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
    int cmsTimer;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(pSBCalc);

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (pSBTrack == NULL)
        return;

    if (message != WM_NULL && HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    ptHit.x = GET_X_LPARAM(lParam);
    ptHit.y = GET_Y_LPARAM(lParam);
    fHit = PtInRect(&pSBTrack->rcTrack, ptHit);

    if (fHit != (BOOL)pSBTrack->fHitOld) {
        zzzDrawInvertScrollArea(pwnd, pSBTrack, fHit, pSBTrack->cmdSB);
        // After zzz, pSBTrack may no longer be valid
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
    }

    cmsTimer = gpsi->dtScroll / 8;

    switch (message) {
    case WM_LBUTTONUP:
        xxxEndScroll(pwnd, FALSE);
        // Note: after xxx, pSBTrack may no longer be valid
        break;

    case WM_LBUTTONDOWN:
        pSBTrack->hTimerSB = 0;
        cmsTimer = gpsi->dtScroll;

        /*
         *** FALL THRU **
         */

    case WM_MOUSEMOVE:
        if (fHit && fHit != (BOOL)pSBTrack->fHitOld) {

            /*
             * We moved back into the normal rectangle: reset timer
             */
            pSBTrack->hTimerSB = _SetSystemTimer(pwnd, IDSYS_SCROLL,
                    cmsTimer, xxxContScroll);

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->spwndSBNotify != NULL) {
                xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                        pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }
        }
    }
    // After xxxDoScroll or xxxEndScroll, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
    pSBTrack->fHitOld = fHit;
}


/***************************************************************************\
* xxxTrackThumb
*
*
*
* History:
\***************************************************************************/

void xxxTrackThumb(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    int px;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
    POINT pt;

    UNREFERENCED_PARAMETER(wParam);

    CheckLock(pwnd);

    if (HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack == NULL)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
//    CheckScrollRecalc(pwnd, pSBState, pSBCalc);
    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }


    pt.y = GET_Y_LPARAM(lParam);
    pt.x = GET_X_LPARAM(lParam);
    if (!PtInRect(&pSBTrack->rcTrack, pt))
        px = pSBCalc->pxStart;
    else {
        px = (pSBTrack->fTrackVert ? pt.y : pt.x) + pSBTrack->dpxThumb;
        if (px < pSBCalc->pxMin)
            px = pSBCalc->pxMin;
        else if (px >= pSBCalc->pxMin + pSBCalc->cpx)
            px = pSBCalc->pxMin + pSBCalc->cpx;
    }

    xxxMoveThumb(pwnd, pSBCalc, px);

    /*
     * We won't get the WM_LBUTTONUP message if we got here through
     * the scroll menu, so test the button state directly.
     */
    if (message == WM_LBUTTONUP || _GetKeyState(VK_LBUTTON) >= 0) {
        xxxEndScroll(pwnd, FALSE);
    }

}

/***************************************************************************\
* xxxSBTrackLoop
*
*
*
* History:
\***************************************************************************/

void xxxSBTrackLoop(
    PWND pwnd,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    MSG msg;
    UINT cmd;
    PTHREADINFO ptiCurrent;
    VOID (*xxxpfnSB)(PWND, UINT, WPARAM, LPARAM, PSBCALC);
    PSBTRACK pSBTrack;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    pSBTrack = PWNDTOPSBTRACK(pwnd);

    if ((pSBTrack == NULL) || (NULL == (xxxpfnSB = pSBTrack->xxxpfnSB)))
        // mode cancelled -- exit track loop
        return;

    if (pSBTrack->fTrackVert)
        SetWF(pwnd, WFVERTSCROLLTRACK);

    xxxWindowEvent(EVENT_SYSTEM_SCROLLINGSTART, pwnd,
            (pSBTrack->fCtlSB ? OBJID_CLIENT :
                    (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
            INDEXID_CONTAINER, 0);
    // Note: after xxx, pSBTrack may no longer be valid

    (*xxxpfnSB)(pwnd, WM_LBUTTONDOWN, 0, lParam, pSBCalc);
    // Note: after xxx, pSBTrack may no longer be valid

    ptiCurrent = PtiCurrent();

    while (ptiCurrent->pq->spwndCapture == pwnd) {
        if (!xxxGetMessage(&msg, NULL, 0, 0)) {
            // Note: after xxx, pSBTrack may no longer be valid
            break;
        }

        if (!_CallMsgFilter(&msg, MSGF_SCROLLBAR)) {
            cmd = msg.message;

            if (msg.hwnd == HWq(pwnd) && ((cmd >= WM_MOUSEFIRST && cmd <=
                    WM_MOUSELAST) || (cmd >= WM_KEYFIRST &&
                    cmd <= WM_KEYLAST))) {
                cmd = SystoChar(cmd, msg.lParam);

                // After xxxWindowEvent, xxxpfnSB, xxxTranslateMessage or
                // xxxDispatchMessage, re-evaluate pSBTrack.
                REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxTrackLoop");
                if ((pSBTrack == NULL) || (NULL == (xxxpfnSB = pSBTrack->xxxpfnSB)))
                    // mode cancelled -- exit track loop
                    return;

                (*xxxpfnSB)(pwnd, cmd, msg.wParam, msg.lParam, pSBCalc);
            } else {
                xxxTranslateMessage(&msg, 0);
                xxxDispatchMessage(&msg);
            }
        }
    }
}


/***************************************************************************\
* xxxSBTrackInit
*
* History:
\***************************************************************************/

void xxxSBTrackInit(
    PWND pwnd,
    LPARAM lParam,
    int curArea,
    UINT uType)
{
    int px;
    LPINT pwX;
    LPINT pwY;
    UINT wDisable;     // Scroll bar disable flags;
    SBCALC SBCalc;
    PSBCALC pSBCalc;
    RECT rcSB;
    PSBTRACK pSBTrack;

    CheckLock(pwnd);


    if (PWNDTOPSBTRACK(pwnd)) {
        RIPMSG1(RIP_WARNING, "xxxSBTrackInit: PWNDTOPSBTRACK(pwnd) == %#p",
                PWNDTOPSBTRACK(pwnd));
        return;
    }

    pSBTrack = (PSBTRACK)UserAllocPoolWithQuota(sizeof(*pSBTrack), TAG_SCROLLTRACK);
    if (pSBTrack == NULL)
        return;

    pSBTrack->hTimerSB = 0;
    pSBTrack->fHitOld = FALSE;

    pSBTrack->xxxpfnSB = xxxTrackBox;

    pSBTrack->spwndTrack = NULL;
    pSBTrack->spwndSB = NULL;
    pSBTrack->spwndSBNotify = NULL;
    Lock(&pSBTrack->spwndTrack, pwnd);
    PWNDTOPSBTRACK(pwnd) = pSBTrack;

    pSBTrack->fCtlSB = (!curArea);
    if (pSBTrack->fCtlSB) {

        /*
         * This is a scroll bar control.
         */
        Lock(&pSBTrack->spwndSB, pwnd);
        pSBTrack->fTrackVert = ((PSBWND)pwnd)->fVert;
        Lock(&pSBTrack->spwndSBNotify, pwnd->spwndParent);
        wDisable = ((PSBWND)pwnd)->wDisableFlags;
        pSBCalc = &((PSBWND)pwnd)->SBCalc;
        pSBTrack->nBar = SB_CTL;
    } else {

        /*
         * This is a scroll bar that is part of the window frame.
         */

        //
        // Mirror the window coord of the scroll bar,
        // if it is a mirrored one
        //
        if (TestWF(pwnd,WEFLAYOUTRTL)) {
            lParam = MAKELONG(
                    pwnd->rcWindow.right - GET_X_LPARAM(lParam),
                    GET_Y_LPARAM(lParam) - pwnd->rcWindow.top);
        } else {
            lParam = MAKELONG(
                    GET_X_LPARAM(lParam) - pwnd->rcWindow.left,
                    GET_Y_LPARAM(lParam) - pwnd->rcWindow.top);
        }

        Lock(&pSBTrack->spwndSBNotify, pwnd);
        Lock(&pSBTrack->spwndSB, NULL);
        pSBTrack->fTrackVert = (curArea - HTHSCROLL);
        wDisable = GetWndSBDisableFlags(pwnd, pSBTrack->fTrackVert);
        pSBCalc = &SBCalc;
        pSBTrack->nBar = (curArea - HTHSCROLL) ? SB_VERT : SB_HORZ;
    }

    pSBTrack->pSBCalc = pSBCalc;
    /*
     *  Check if the whole scroll bar is disabled
     */
    if((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        Unlock(&pSBTrack->spwndSBNotify);
        Unlock(&pSBTrack->spwndSB);
        Unlock(&pSBTrack->spwndTrack);
        UserFreePool(pSBTrack);
        PWNDTOPSBTRACK(pwnd) = NULL;
        return;  // It is a disabled scroll bar; So, do not respond.
    }

    if (!pSBTrack->fCtlSB) {
        CalcSBStuff(pwnd, pSBCalc, pSBTrack->fTrackVert);
    }

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    px = (pSBTrack->fTrackVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam));

    *(pwX + 0) = pSBCalc->pxLeft;
    *(pwY + 0) = pSBCalc->pxTop;
    *(pwX + 2) = pSBCalc->pxRight;
    *(pwY + 2) = pSBCalc->pxBottom;
    pSBTrack->cmdSB = (UINT)-1;
    if (px < pSBCalc->pxUpArrow) {

        /*
         *  The click occurred on Left/Up arrow; Check if it is disabled
         */
        if(wDisable & LTUPFLAG) {
            if(pSBTrack->fCtlSB) {   // If this is a scroll bar control,
                zzzShowCaret(pSBTrack->spwndSB);  // show the caret before returning;
                // After zzzShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
            }

            Unlock(&pSBTrack->spwndSBNotify);
            Unlock(&pSBTrack->spwndSB);
            Unlock(&pSBTrack->spwndTrack);
            UserFreePool(pSBTrack);
            PWNDTOPSBTRACK(pwnd) = NULL;
            return;         // Yes! disabled. Do not respond.
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEUP;
        *(pwY + 2) = pSBCalc->pxUpArrow;
    } else if (px >= pSBCalc->pxDownArrow) {

        /*
         * The click occurred on Right/Down arrow; Check if it is disabled
         */
        if (wDisable & RTDNFLAG) {
            if (pSBTrack->fCtlSB) {    // If this is a scroll bar control,
                zzzShowCaret(pSBTrack->spwndSB);  // show the caret before returning;
                // After zzzShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
            }

            Unlock(&pSBTrack->spwndSBNotify);
            Unlock(&pSBTrack->spwndSB);
            Unlock(&pSBTrack->spwndTrack);
            UserFreePool(pSBTrack);
            PWNDTOPSBTRACK(pwnd) = NULL;
            return;// Yes! disabled. Do not respond.
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEDOWN;
        *(pwY + 0) = pSBCalc->pxDownArrow;
    } else if (px < pSBCalc->pxThumbTop) {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pSBTrack->cmdSB = SB_PAGEUP;
        *(pwY + 0) = pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBCalc->pxThumbTop;
    } else if (px < pSBCalc->pxThumbBottom) {

DoThumbPos:
        /*
         * Elevator isn't there if there's no room.
         */
        if (pSBCalc->pxDownArrow - pSBCalc->pxUpArrow <= pSBCalc->cpxThumb) {
            Unlock(&pSBTrack->spwndSBNotify);
            Unlock(&pSBTrack->spwndSB);
            Unlock(&pSBTrack->spwndTrack);
            UserFreePool(pSBTrack);
            PWNDTOPSBTRACK(pwnd) = NULL;
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pSBTrack->cmdSB = SB_THUMBPOSITION;
        CalcTrackDragRect(pSBTrack);

        pSBTrack->xxxpfnSB = xxxTrackThumb;
        pSBTrack->pxOld = pSBCalc->pxStart = pSBCalc->pxThumbTop;
        pSBTrack->posNew = pSBTrack->posOld = pSBCalc->pos;
        pSBTrack->dpxThumb = pSBCalc->pxStart - px;

        xxxCapture(PtiCurrent(), pwnd, WINDOW_CAPTURE);
        // After xxxCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                    SB_THUMBTRACK, pSBTrack->posOld, pSBTrack->fTrackVert
            );
            // Note: after xxx, pSBTrack may no longer be valid
        }
    } else if (px < pSBCalc->pxDownArrow) {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pSBTrack->cmdSB = SB_PAGEDOWN;
        *(pwY + 0) = pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBCalc->pxDownArrow;
    }

    /*
     * If the shift key is down, we'll position the thumb directly so it's
     * centered on the click point.
     */
    if ((uType == SCROLL_DIRECT && pSBTrack->cmdSB != SB_LINEUP && pSBTrack->cmdSB != SB_LINEDOWN) ||
            (uType == SCROLL_MENU)) {
        if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pSBTrack->dpxThumb = -(pSBCalc->cpxThumb / 2);
    }

    xxxCapture(PtiCurrent(), pwnd, WINDOW_CAPTURE);
    // After xxxCapture, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }

    xxxSBTrackLoop(pwnd, lParam, pSBCalc);

    // After xxx, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxTrackLoop");
    if (pSBTrack) {
        Unlock(&pSBTrack->spwndSBNotify);
        Unlock(&pSBTrack->spwndSB);
        Unlock(&pSBTrack->spwndTrack);
        UserFreePool(pSBTrack);
        PWNDTOPSBTRACK(pwnd) = NULL;
    }
}

/***************************************************************************\
* GetScrollMenu
*
* History:
\***************************************************************************/

PMENU xxxGetScrollMenu(
    PWND pwnd,
    BOOL fVert)
{
    PMENU pMenu;
    PMENU *ppDesktopMenu;

    /*
     * Grab the menu from the desktop.  If the desktop menu
     * has not been loaded and this is not a system thread,
     * load it now.  Callbacks cannot be made from a system
     * thread or when a thread is in cleanup.
     */
    if (fVert) {
        ppDesktopMenu = &pwnd->head.rpdesk->spmenuVScroll;
    } else {
        ppDesktopMenu = &pwnd->head.rpdesk->spmenuHScroll;
    }
    pMenu = *ppDesktopMenu;
    if (pMenu == NULL && !(PtiCurrent()->TIF_flags & (TIF_SYSTEMTHREAD | TIF_INCLEANUP))) {
        UNICODE_STRING strMenuName;

        RtlInitUnicodeStringOrId(&strMenuName,
            fVert ? MAKEINTRESOURCE(ID_VSCROLLMENU) : MAKEINTRESOURCE(ID_HSCROLLMENU));
        pMenu = xxxClientLoadMenu(NULL, &strMenuName);
        LockDesktopMenu(ppDesktopMenu, pMenu);
    }

    /*
     * Return the handle to the scroll menu.
     */
    if (pMenu != NULL) {
        return _GetSubMenu(pMenu, 0);
    }

    return NULL;
}

/***************************************************************************\
* xxxDoScrollMenu
*
* History:
\***************************************************************************/

VOID
xxxDoScrollMenu(
    PWND pwndNotify,
    PWND pwndSB,
    BOOL fVert,
    LPARAM lParam)
{
    PMENU pMenu;
    SBCALC SBCalc, *pSBCalc;
    UINT cmd;
    POINT pt;
    TL tlpmenu;
    UINT wDisable;

    /*
     * Check the compatibility flag.  Word 6.0 AV's when selecting an item
     * in this menu.
     * NOTE: If this hack is to be extended for other apps we should use
     * another bit for GACF_NOSCROLLBARCTXMENU as the current one is re-used
     *  MCostea #119380
     */
    if (GetAppCompatFlags(NULL) & GACF_NOSCROLLBARCTXMENU) {
        return;
    }

    /*
     * Initialize some stuff.
     */
    POINTSTOPOINT(pt, lParam);
    if (pwndSB) {
        SBCtlSetup((PSBWND)pwndSB);
        pSBCalc = &(((PSBWND)pwndSB)->SBCalc);
        wDisable = ((PSBWND)pwndSB)->wDisableFlags;
        pt.x -= pwndSB->rcWindow.left;
        pt.y -= pwndSB->rcWindow.top;
    } else {
        pSBCalc = &SBCalc;
        CalcSBStuff(pwndNotify, pSBCalc, fVert);
        wDisable = GetWndSBDisableFlags(pwndNotify, fVert);
        pt.x -= pwndNotify->rcWindow.left;
        pt.y -= pwndNotify->rcWindow.top;
    }

    /*
     * Make sure the scrollbar isn't disabled.
     */
    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return;
    }

    /*
     * Put up a menu and scroll accordingly.
     */
    if ((pMenu = xxxGetScrollMenu(pwndNotify, fVert)) != NULL) {
        ThreadLockAlways(pMenu, &tlpmenu);
        cmd = xxxTrackPopupMenuEx(pMenu,
                                  TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                                  GET_X_LPARAM(lParam),
                                  GET_Y_LPARAM(lParam),
                                  pwndNotify,
                                  NULL);
        ThreadUnlock(&tlpmenu);
        if (cmd) {
            if ((cmd & 0x00FF) == SB_THUMBPOSITION) {
                if (pwndSB) {
                    xxxSBTrackInit(pwndSB, MAKELPARAM(pt.x, pt.y), 0, SCROLL_MENU);
                } else {
                    xxxSBTrackInit(pwndNotify, lParam, fVert ? HTVSCROLL : HTHSCROLL, SCROLL_MENU);
                }
            } else {
                xxxDoScroll(pwndSB,
                            pwndNotify,
                            cmd & 0x00FF,
                            0,
                            fVert
                );
                xxxDoScroll(pwndSB,
                            pwndNotify,
                            SB_ENDSCROLL,
                            0,
                            fVert
                );
            }
        }
    }
}

/***************************************************************************\
* xxxSBWndProc
*
* History:
* 08-15-95 jparsons Added guard against NULL lParam [51986]
\***************************************************************************/

LRESULT xxxSBWndProc(
    PSBWND psbwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LONG l;
    LONG lres;
    int cx;
    int cy;
    UINT cmd;
    UINT uSide;
    HDC hdc;
    RECT rc;
    POINT pt;
    BOOL fSizeReal;
    HBRUSH hbrSave;
    BOOL fSize;
    PAINTSTRUCT ps;
    UINT style;
    TL tlpwndParent;
    SCROLLINFO      si;
    LPSCROLLINFO    lpsi = &si;
    BOOL            fRedraw = FALSE;
    BOOL            fScroll;

    CheckLock(psbwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(((PWND)psbwnd), message, wParam, lParam, FNID_SCROLLBAR, WM_CREATE);

    style = LOBYTE(psbwnd->wnd.style);
    fSize = ((style & (SBS_SIZEBOX | SBS_SIZEGRIP)) != 0);

    switch (message) {
    case WM_CREATE:
        /*
         * Guard against lParam being NULL since the thunk allows it [51986]
         */
        if (lParam) {
            rc.right = (rc.left = ((LPCREATESTRUCT)lParam)->x) +
                    ((LPCREATESTRUCT)lParam)->cx;
            rc.bottom = (rc.top = ((LPCREATESTRUCT)lParam)->y) +
                    ((LPCREATESTRUCT)lParam)->cy;
            // This is because we can't just rev CardFile -- we should fix the
            // problem here in case anyone else happened to have some EXTRA
            // scroll styles on their scroll bar controls (jeffbog 03/21/94)
            if (!TestWF((PWND)psbwnd, WFWIN40COMPAT))
                psbwnd->wnd.style &= ~(WS_HSCROLL | WS_VSCROLL);

            if (!fSize) {
                l = PtrToLong(((LPCREATESTRUCT)lParam)->lpCreateParams);
                psbwnd->SBCalc.pos = psbwnd->SBCalc.posMin = LOWORD(l);
                psbwnd->SBCalc.posMax = HIWORD(l);
                psbwnd->fVert = ((LOBYTE(psbwnd->wnd.style) & SBS_VERT) != 0);
                psbwnd->SBCalc.page = 0;
            }

            if (psbwnd->wnd.style & WS_DISABLED)
                psbwnd->wDisableFlags = SB_DISABLE_MASK;

            if (style & (SBS_TOPALIGN | SBS_BOTTOMALIGN)) {
                if (fSize) {
                    if (style & SBS_SIZEBOXBOTTOMRIGHTALIGN) {
                        rc.left = rc.right - SYSMET(CXVSCROLL);
                        rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }

                    rc.right = rc.left + SYSMET(CXVSCROLL);
                    rc.bottom = rc.top + SYSMET(CYHSCROLL);
                } else {
                    if (style & SBS_VERT) {
                        if (style & SBS_LEFTALIGN)
                            rc.right = rc.left + SYSMET(CXVSCROLL);
                        else
                            rc.left = rc.right - SYSMET(CXVSCROLL);
                    } else {
                        if (style & SBS_TOPALIGN)
                            rc.bottom = rc.top + SYSMET(CYHSCROLL);
                        else
                            rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }
                }

                xxxMoveWindow((PWND)psbwnd, rc.left, rc.top, rc.right - rc.left,
                         rc.bottom - rc.top, FALSE);
            }
        } /* if */

        else {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                    "xxxSBWndProc - NULL lParam for WM_CREATE\n") ;
        } /* else */

        break;

    case WM_SIZE:
        if (PtiCurrent()->pq->spwndFocus != (PWND)psbwnd)
            break;

        // scroll bar has the focus -- recalc it's thumb caret size
        // no need to DeferWinEventNotify() - see xxxCreateCaret below.
        zzzDestroyCaret();

            //   |             |
            //   |  FALL THRU  |
            //   V             V

    case WM_SETFOCUS:
        SBCtlSetup(psbwnd);

        cx = (psbwnd->fVert ? psbwnd->wnd.rcWindow.right - psbwnd->wnd.rcWindow.left
                            : psbwnd->SBCalc.cpxThumb) - 2 * SYSMET(CXEDGE);
        cy = (psbwnd->fVert ? psbwnd->SBCalc.cpxThumb
                            : psbwnd->wnd.rcWindow.bottom - psbwnd->wnd.rcWindow.top) - 2 * SYSMET(CYEDGE);

        xxxCreateCaret((PWND)psbwnd, (HBITMAP)1, cx, cy);
        zzzSetSBCaretPos(psbwnd);
        zzzShowCaret((PWND)psbwnd);
        break;

    case WM_KILLFOCUS:
        zzzDestroyCaret();
        break;

    case WM_ERASEBKGND:

        /*
         * Do nothing, but don't let DefWndProc() do it either.
         * It will be erased when its painted.
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if ((hdc = (HDC)wParam) == NULL) {
            hdc = xxxBeginPaint((PWND)psbwnd, (LPPAINTSTRUCT)&ps);
        }
        if (!fSize) {
            SBCtlSetup(psbwnd);
            xxxDrawSB2((PWND)psbwnd, &psbwnd->SBCalc, hdc, psbwnd->fVert, psbwnd->wDisableFlags);
        } else {
            fSizeReal = TestWF((PWND)psbwnd, WFSIZEBOX);
            if (!fSizeReal)
                SetWF((PWND)psbwnd, WFSIZEBOX);

            DrawSize((PWND)psbwnd, hdc, 0, 0);

            if (!fSizeReal)
                ClrWF((PWND)psbwnd, WFSIZEBOX);
        }

        if (wParam == 0L)
            xxxEndPaint((PWND)psbwnd, (LPPAINTSTRUCT)&ps);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WM_CONTEXTMENU:
            ThreadLock(psbwnd->wnd.spwndParent, &tlpwndParent);
            xxxDoScrollMenu(psbwnd->wnd.spwndParent, (PWND)psbwnd, psbwnd->fVert, lParam);
            ThreadUnlock(&tlpwndParent);
        break;

    case WM_NCHITTEST:
        if (style & SBS_SIZEGRIP) {
            /*
             * If the scroll bar is RTL mirrored, then
             * mirror the hittest of the grip location.
             */
            if (TestWF((PWND)psbwnd, WEFLAYOUTRTL)) {
                return HTBOTTOMLEFT;
            } else {
                return HTBOTTOMRIGHT;
            }
        } else {
            goto DoDefault;
        }
        break;

#ifdef COLOR_HOTTRACKING
    case WM_MOUSELEAVE:
        xxxHotTrackSBCtl(psbwnd, 0, FALSE);
        psbwnd->ht = 0;
        break;

    case WM_MOUSEMOVE:
        {
            int ht;

            if (psbwnd->ht == 0) {
                TRACKMOUSEEVENT tme = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, HWq(psbwnd), 0};
                TrackMouseEvent(&tme);
            }

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            ht = HitTestScrollBar((PWND)psbwnd, psbwnd->fVert, pt);
            if (psbwnd->ht != ht) {
                xxxHotTrackSBCtl(psbwnd, ht, TRUE);
                psbwnd->ht = ht;
            }
        }
        break;
#endif // COLOR_HOTTRACKING

    case WM_LBUTTONDBLCLK:
        cmd = SC_ZOOM;
        if (fSize)
            goto postmsg;

        /*
         *** FALL THRU **
         */

    case WM_LBUTTONDOWN:
            //
            // Note that SBS_SIZEGRIP guys normally won't ever see button
            // downs.  This is because they return HTBOTTOMRIGHT to
            // WindowHitTest handling.  This will walk up the parent chain
            // to the first sizeable ancestor, bailing out at caption windows
            // of course.  That dude, if he exists, will handle the sizing
            // instead.
            //
        if (!fSize) {
            if (TestWF((PWND)psbwnd, WFTABSTOP)) {
                xxxSetFocus((PWND)psbwnd);
            }

            zzzHideCaret((PWND)psbwnd);
            SBCtlSetup(psbwnd);

            /*
             * SBCtlSetup enters SEM_SB, and xxxSBTrackInit leaves it.
             */
            xxxSBTrackInit((PWND)psbwnd, lParam, 0, (_GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            break;
        } else {
            cmd = SC_SIZE;
postmsg:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            _ClientToScreen((PWND)psbwnd, &pt);
            lParam = MAKELONG(pt.x, pt.y);

            /*
             * convert HT value into a move value.  This is bad,
             * but this is purely temporary.
             */
            if (TestWF(((PWND)psbwnd)->spwndParent,WEFLAYOUTRTL)) {
                uSide = HTBOTTOMLEFT;
            } else {
                uSide = HTBOTTOMRIGHT;
            }
            ThreadLock(((PWND)psbwnd)->spwndParent, &tlpwndParent);
            xxxSendMessage(((PWND)psbwnd)->spwndParent, WM_SYSCOMMAND,
                    (cmd | (uSide - HTSIZEFIRST + 1)), lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_KEYUP:
        switch (wParam) {
        case VK_HOME:
        case VK_END:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:

            /*
             * Send end scroll message when user up clicks on keyboard
             * scrolling.
             *
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((PWND)psbwnd, psbwnd->wnd.spwndParent,
                    SB_ENDSCROLL, 0, psbwnd->fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_HOME:
            wParam = SB_TOP;
            goto KeyScroll;

        case VK_END:
            wParam = SB_BOTTOM;
            goto KeyScroll;

        case VK_PRIOR:
            wParam = SB_PAGEUP;
            goto KeyScroll;

        case VK_NEXT:
            wParam = SB_PAGEDOWN;
            goto KeyScroll;

        case VK_LEFT:
        case VK_UP:
            wParam = SB_LINEUP;
            goto KeyScroll;

        case VK_RIGHT:
        case VK_DOWN:
            wParam = SB_LINEDOWN;
KeyScroll:

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((PWND)psbwnd, psbwnd->wnd.spwndParent, (int)wParam,
                    0, psbwnd->fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_ENABLE:
        return xxxSendMessage((PWND)psbwnd, SBM_ENABLE_ARROWS,
               (wParam ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH), 0);

    case SBM_ENABLE_ARROWS:

        /*
         * This is used to enable/disable the arrows in a SB ctrl
         */
        return (LONG)xxxEnableSBCtlArrows((PWND)psbwnd, (UINT)wParam);

    case SBM_GETPOS:
        return (LONG)psbwnd->SBCalc.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psbwnd->SBCalc.posMin;
        *((LPINT)lParam) = psbwnd->SBCalc.posMax;
        return MAKELRESULT(LOWORD(psbwnd->SBCalc.posMin), LOWORD(psbwnd->SBCalc.posMax));

    case SBM_GETSCROLLINFO:
        return (LONG)_SBGetParms((PWND)psbwnd, SB_CTL, (PSBDATA)&psbwnd->SBCalc, (LPSCROLLINFO) lParam);

    case SBM_SETRANGEREDRAW:
        fRedraw = TRUE;

    case SBM_SETRANGE:
        // Save the old values of Min and Max for return value
        si.cbSize = sizeof(si);
//        si.nMin = LOWORD(lParam);
//        si.nMax = HIWORD(lParam);
        si.nMin = (int)wParam;
        si.nMax = (int)lParam;
        si.fMask = SIF_RANGE | SIF_RETURNOLDPOS;
        goto SetInfo;

    case SBM_SETPOS:
        fRedraw = (BOOL) lParam;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS | SIF_RETURNOLDPOS;
        si.nPos  = (int)wParam;
        goto SetInfo;

    case SBM_SETSCROLLINFO:
        lpsi = (LPSCROLLINFO) lParam;
        fRedraw = (BOOL) wParam;
SetInfo:
        fScroll = TRUE;

        if (SBSetParms((PSBDATA)&psbwnd->SBCalc, lpsi, &fScroll, &lres)) {
            xxxWindowEvent(EVENT_OBJECT_VALUECHANGE, (PWND)psbwnd, OBJID_CLIENT,
                    INDEX_SCROLLBAR_SELF, WEF_USEPWNDTHREAD);
        }

        if (!fRedraw)
            return lres;


        /*
         * We must set the new position of the caret irrespective of
         * whether the window is visible or not;
         * Still, this will work only if the app has done a xxxSetScrollPos
         * with fRedraw = TRUE;
         * Fix for Bug #5188 --SANKAR-- 10-15-89
         * No need to DeferWinEventNotify since psbwnd is locked.
         */
        zzzHideCaret((PWND)psbwnd);
        SBCtlSetup(psbwnd);
        zzzSetSBCaretPos(psbwnd);

            /*
             ** The following zzzShowCaret() must be done after the DrawThumb2(),
             ** otherwise this caret will be erased by DrawThumb2() resulting
             ** in this bug:
             ** Fix for Bug #9263 --SANKAR-- 02-09-90
             *
             */

            /*
             *********** zzzShowCaret((PWND)psbwnd); ******
             */

        if (_FChildVisible((PWND)psbwnd) && fRedraw) {
            UINT    wDisable;
            HBRUSH  hbrUse;

            if (!fScroll)
                fScroll = !(lpsi->fMask & SIF_DISABLENOSCROLL);

            wDisable = (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;
            xxxEnableScrollBar((PWND) psbwnd, SB_CTL, wDisable);

            hdc = _GetWindowDC((PWND)psbwnd);
            hbrSave = GreSelectBrush(hdc, hbrUse = xxxGetColorObjects((PWND)psbwnd, hdc));

                /*
                 * Before we used to only hideshowthumb() if the mesage was
                 * not SBM_SETPOS.  I am not sure why but this case was ever
                 * needed for win 3.x but on NT it resulted in trashing the border
                 * of the scrollbar when the app called SetScrollPos() during
                 * scrollbar tracking.  - mikehar 8/26
                 */
            DrawThumb2((PWND)psbwnd, &psbwnd->SBCalc, hdc, hbrUse, psbwnd->fVert,
                         psbwnd->wDisableFlags);
            GreSelectBrush(hdc, hbrSave);
            _ReleaseDC(hdc);
        }

            /*
             * This zzzShowCaret() has been moved to this place from above
             * Fix for Bug #9263 --SANKAR-- 02-09-90
             */
        zzzShowCaret((PWND)psbwnd);
        return lres;

    case SBM_GETSCROLLBARINFO:
        return (LONG)xxxGetScrollBarInfo((PWND)psbwnd, OBJID_CLIENT, (PSCROLLBARINFO)lParam);

    default:
DoDefault:
        return xxxDefWindowProc((PWND)psbwnd, message, wParam, lParam);
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sbapi.c ===
/**************************** Module Header ********************************\
* Module Name:
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Scroll bar public APIs
*
* History:
*   11/21/90 JimA      Created.
*   01-31-91 IanJa     Revalidaion added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxShowScrollBar
*
* Shows and hides standard scroll bars or scroll bar controls. If wBar is
* SB_HORZ, SB_VERT, or SB_BOTH, pwnd is assumed to be the handle of the window
* which has the standard scroll bars as styles. If wBar is SB_CTL, pwnd is
* assumed to be the handle of the scroll bar control.
*
* It does not destroy pwnd->rgwScroll like xxxSetScrollBar() does, so that the
* app can hide a standard scroll bar and then show it, without having to reset
* the range and thumbposition.
*
* History:
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL xxxShowScrollBar(
    PWND pwnd,
    UINT wBar,      /* SB_HORZ, SB_VERT, SB_BOTH , SB_CTL */
    BOOL fShow)     /* Show or Hide. */
{
    BOOL fChanged = FALSE;
    DWORD   dwStyle;

    CheckLock(pwnd);

    switch (wBar)
    {
    case SB_CTL:
        {

            xxxShowWindow(
                    pwnd,
                    (fShow ? SHOW_OPENWINDOW : HIDE_WINDOW) | TEST_PUDF(PUDF_ANIMATE));

            return(TRUE);
        }

    case SB_HORZ:
        dwStyle = WS_HSCROLL;
        break;

    case SB_VERT:
        dwStyle = WS_VSCROLL;
        break;

    case SB_BOTH:
        dwStyle = WS_HSCROLL | WS_VSCROLL;
        break;
    }

    if (!fShow)
    {
        if (pwnd->style & dwStyle)
        {
            fChanged = TRUE;
            pwnd->style &= ~dwStyle;
        }
    } else {
        if ((pwnd->style & dwStyle) != dwStyle)
        {
            fChanged = TRUE;
            pwnd->style |= dwStyle;
        }

        /*
         * Make sure that pwsb is initialized.
         */
        if (pwnd->pSBInfo == NULL)
            _InitPwSB(pwnd);
    }

    /*
     * If the state changed, redraw the frame and force WM_NCPAINT.
     */
    if (fChanged) {

        /*
         * We always redraw even if minimized or hidden...  Otherwise, it seems
         * the scroll bars aren't properly hidden/shown when we become
         * visible
         */
        xxxRedrawFrame(pwnd);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains a random collection of support routines for the User
* API functions.  Many of these functions will be moved to more appropriate
* files once we get our act together.
*
* History:
* 10-17-90 DarrinM      Created.
* 02-06-91 IanJa        HWND revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxUpdateWindows
*
* User mode wrapper
\***************************************************************************/
BOOL xxxUpdateWindows(
    PWND pwnd,
    HRGN hrgn)
{
    CheckLock(pwnd);

    xxxUpdateThreadsWindows(PtiCurrent(), pwnd, hrgn);

    return TRUE;
}

/***************************************************************************\
* ValidateState
*
* States allowed to be set/cleared by Set/ClearWindowState. If you're
* allowing a new flag here, you must make sure it won't cause an AV
* in the kernel if someone sets it maliciously.
\***************************************************************************/

#define NUM_BYTES 16  // Window state bytes are 0 to F, explanation in user.h

CONST BYTE abValidateState[NUM_BYTES] = {
    0,      // 0
    0,      // 1
    0,      // 2
    0,      // 3
    0,      // 4
    LOBYTE(WFWIN40COMPAT),
    0,      // 6
    LOBYTE(WFNOANIMATE),
    0,      // 8
    LOBYTE(WEFEDGEMASK),
    LOBYTE(WEFSTATICEDGE),
    0,      // B
    LOBYTE(EFPASSWORD),
    LOBYTE(CBFHASSTRINGS | EFREADONLY),
    LOBYTE(WFTABSTOP | WFSYSMENU | WFVSCROLL | WFHSCROLL | WFBORDER),
    LOBYTE(WFCLIPCHILDREN)
};

BOOL ValidateState(
    DWORD dwFlags)
{
    BYTE bOffset = HIBYTE(dwFlags), bState = LOBYTE(dwFlags);

    if (bOffset > NUM_BYTES - 1) {
        return FALSE;
    } else {
        return ((bState & abValidateState[bOffset]) == bState);
    }
}

/***************************************************************************\
* Set/ClearWindowState
*
* Wrapper functions for User mode to be able to set state flags.
\***************************************************************************/
VOID SetWindowState(
    PWND pwnd,
    DWORD dwFlags)
{
    /*
     * Don't let anyone mess with someone else's window.
     */
    if (GETPTI(pwnd)->ppi == PtiCurrent()->ppi) {
        if (ValidateState(dwFlags)) {
            SetWF(pwnd, dwFlags);
        } else {
            RIPMSG1(RIP_ERROR, "SetWindowState: invalid flag 0x%x", dwFlags);
        }
    } else {
        RIPMSG1(RIP_WARNING, "SetWindowState: current ppi doesn't own pwnd %#p", pwnd);
    }
}

VOID ClearWindowState(
    PWND pwnd,
    DWORD dwFlags)
{
    /*
     * Don't let anyone mess with someone else's window.
     */
    if (GETPTI(pwnd)->ppi == PtiCurrent()->ppi) {
        if (ValidateState(dwFlags)) {
            ClrWF(pwnd, dwFlags);
        } else {
            RIPMSG1(RIP_ERROR, "SetWindowState: invalid flag 0x%x", dwFlags);
        }
    } else {
        RIPMSG1(RIP_WARNING, "ClearWindowState: current ppi doesn't own pwnd %#p", pwnd);
    }

}


/***************************************************************************\
* CheckPwndFilter
*
*
*
* History:
* 11-07-90 DarrinM      Translated Win 3.0 ASM code.
\***************************************************************************/
BOOL CheckPwndFilter(
    PWND pwnd,
    PWND pwndFilter)
{
    if ((pwndFilter == NULL) || (pwndFilter == pwnd) ||
            ((pwndFilter == (PWND)1) && (pwnd == NULL))) {
        return TRUE;
    }

    return _IsChild(pwndFilter, pwnd);
}


/***************************************************************************\
* AllocateUnicodeString
*
* History:
* 10-25-90 MikeHar      Wrote.
* 11-09-90 DarrinM      Fixed.
* 01-13-92 GregoryW     Neutralized.
* 03-05-98 FritzS       Only allocate Length+1
\***************************************************************************/
BOOL AllocateUnicodeString(
    PUNICODE_STRING pstrDst,
    PUNICODE_STRING cczpstrSrc)
{
    if (cczpstrSrc == NULL) {
        RtlInitUnicodeString(pstrDst, NULL);
        return TRUE;
    }

    pstrDst->Buffer = UserAllocPoolWithQuota(cczpstrSrc->Length+sizeof(UNICODE_NULL), TAG_TEXT);
    if (pstrDst->Buffer == NULL) {
        return FALSE;
    }

    try {
        RtlCopyMemory(pstrDst->Buffer, cczpstrSrc->Buffer, cczpstrSrc->Length);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        UserFreePool(pstrDst->Buffer);
        pstrDst->Buffer = NULL;
        return FALSE;
    }

    pstrDst->MaximumLength = cczpstrSrc->Length+sizeof(UNICODE_NULL);
    pstrDst->Length = cczpstrSrc->Length;
    pstrDst->Buffer[pstrDst->Length / sizeof(WCHAR)] = 0;

    return TRUE;
}


/***************************************************************************\
* xxxGetControlColor
*
* History:
* 02-12-92 JimA     Ported from Win31 sources
\***************************************************************************/
HBRUSH xxxGetControlColor(
    PWND pwndParent,
    PWND pwndCtl,
    HDC hdc,
    UINT message)
{
    HBRUSH hbrush;

    /*
     * If we're sending to a window of another thread, don't send this message
     * but instead call DefWindowProc().  New rule about the CTLCOLOR messages.
     * Need to do this so that we don't send an hdc owned by one thread to
     * another thread.  It is also a harmless change.
     */
    if (PpiCurrent() != GETPTI(pwndParent)->ppi) {
        return (HBRUSH)xxxDefWindowProc(pwndParent, message, (WPARAM)hdc, (LPARAM)HW(pwndCtl));
    }

    hbrush = (HBRUSH)xxxSendMessage(pwndParent, message, (WPARAM)hdc, (LPARAM)HW(pwndCtl));

    /*
     * If the brush returned from the parent is invalid, get a valid brush from
     * xxxDefWindowProc.
     */
    if (hbrush == 0 || !GreValidateServerHandle(hbrush, BRUSH_TYPE)) {
        if (hbrush != 0) {
            RIPMSG2(RIP_WARNING,
                    "Invalid HBRUSH from WM_CTLCOLOR*** msg 0x%x brush 0x%x",
                    message, hbrush);
        }

        hbrush = (HBRUSH)xxxDefWindowProc(pwndParent, message,
                (WPARAM)hdc, (LPARAM)pwndCtl);
    }

    return hbrush;
}


/***************************************************************************\
* xxxGetControlBrush
*
* <brief description>
*
* History:
* 12-10-90 IanJa   type replaced with new 32-bit message
* 01-21-91 IanJa   Prefix '_' denoting exported function (although not API)
\***************************************************************************/

HBRUSH xxxGetControlBrush(
    PWND pwnd,
    HDC hdc,
    UINT message)
{
    HBRUSH hbr;
    PWND pwndSend;
    TL tlpwndSend;

    CheckLock(pwnd);

    if ((pwndSend = (TestwndPopup(pwnd) ? pwnd->spwndOwner : pwnd->spwndParent))
         == NULL) {
        pwndSend = pwnd;
    }

    ThreadLock(pwndSend, &tlpwndSend);

    /*
     * Last parameter changes the message into a ctlcolor id.
     */
    hbr = xxxGetControlColor(pwndSend, pwnd, hdc, message);
    ThreadUnlock(&tlpwndSend);

    return hbr;
}

/***************************************************************************\
* xxxHardErrorControl
*
* Performs kernel-mode hard error support functions.
*
* History:
* 02-08-95 JimA         Created.
\***************************************************************************/
UINT xxxHardErrorControl(
    DWORD dwCmd,
    HANDLE handle,
    PDESKRESTOREDATA pdrdRestore)
{
    PTHREADINFO ptiClient, ptiCurrent = PtiCurrent();
    PDESKTOP pdesk;
    PUNICODE_STRING pstrName;
    NTSTATUS Status;
    PETHREAD Thread;
    BOOL fAllowForeground;

    /*
     * turn off BlockInput so the user can respond to the hard error popup
     */
    gptiBlockInput = NULL;

    UserAssert(ISCSRSS());

    switch (dwCmd) {
    /*
     * Code to catch Windows Bug 469607.
     */
#ifdef PRERELEASE
    case HardErrorCheckOnDesktop:
        if (ptiCurrent == gptiForeground && ptiCurrent->rpdesk == NULL) {
            FRE_RIPMSG0(RIP_ERROR,
                        "Harderror thread exiting while not on a desktop");
        }
        break;
#endif

    case HardErrorSetup:
        /*
         * Don't do it if the system has not been initialized.
         */
        if (grpdeskRitInput == NULL) {
            RIPMSG0(RIP_WARNING, "HardErrorControl: System not initialized");
            return HEC_ERROR;
        }

        /*
         * Setup caller as the hard error handler.
         */
        if (gHardErrorHandler.pti != NULL) {
            RIPMSG1(RIP_WARNING, "HardErrorControl: pti not NULL %#p", gHardErrorHandler.pti);
            return HEC_ERROR;
        }

        /*
         * Mark the handler as active.
         */
        gHardErrorHandler.pti = ptiCurrent;

        /*
         * Clear any pending quits.
         */
        ptiCurrent->TIF_flags &= ~TIF_QUITPOSTED;

        break;

    case HardErrorCleanup:

        /*
         * Remove caller as the hard error handler.
         */
        if (gHardErrorHandler.pti != ptiCurrent)  {
            return HEC_ERROR;
        }

        gHardErrorHandler.pti = NULL;
        break;

    case HardErrorAttachUser:
    case HardErrorInDefDesktop:
        /*
         * Check for exit conditions. We do not allow attaches to the
         * disconnect desktop.
         */
        if (ISTS()) {
            if ((grpdeskRitInput == NULL) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == NULL)) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == gspdeskDisconnect))) {
                return HEC_ERROR;
            }
        }

        /*
         * Only attach to a user desktop.
         */
        if (ISTS() && grpdeskRitInput == gspdeskDisconnect) {
            pstrName = POBJECT_NAME(gspdeskShouldBeForeground);
        } else {
            pstrName = POBJECT_NAME(grpdeskRitInput);
        }

        if (pstrName && (!_wcsicmp(TEXT("Winlogon"), pstrName->Buffer) ||
                !_wcsicmp(TEXT("Disconnect"), pstrName->Buffer) ||
                !_wcsicmp(TEXT("Screen-saver"), pstrName->Buffer))) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
            return HEC_WRONGDESKTOP;
        }
        if (dwCmd == HardErrorInDefDesktop) {
            /*
             * Clear any pending quits.
             */
            ptiCurrent->TIF_flags &= ~TIF_QUITPOSTED;
            return HEC_SUCCESS;
        }


        /*
         * Fall through.
         */

    case HardErrorAttach:

        /*
         * Save a pointer to and prevent destruction of the
         * current queue.  This will give us a queue to return
         * to if journalling is occuring when we tear down the
         * hard error popup.
         */
        gHardErrorHandler.pqAttach = ptiCurrent->pq;
        (ptiCurrent->pq->cLockCount)++;

        /*
         * Fall through.
         */

    case HardErrorAttachNoQueue:

        /*
         * Check for exit conditions. We do not allow attaches to the
         * disconnect desktop.
         */
        if (ISTS()) {
            if ((grpdeskRitInput == NULL) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == NULL)) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == gspdeskDisconnect))) {
                return HEC_ERROR;
            }
        }

        /*
         * Attach the handler to the current desktop.
         */
        /*
         * Don't allow an attach to the disconnected desktop, but
         * remember this for later when we detach.
         */
        gbDisconnectHardErrorAttach = FALSE;

        if (ISTS() && grpdeskRitInput == gspdeskDisconnect) {
            pdesk = gspdeskShouldBeForeground;
            gbDisconnectHardErrorAttach = TRUE;
        } else {
            pdesk = grpdeskRitInput;
        }

        UserAssert(pdesk != NULL);

        Status = xxxSetCsrssThreadDesktop(pdesk, pdrdRestore);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "HardErrorControl: HardErrorAttachNoQueue failed: 0x%x",
                    Status);
            if (dwCmd != HardErrorAttachNoQueue) {
                gHardErrorHandler.pqAttach = NULL;
                UserAssert(ptiCurrent->pq->cLockCount);
                (ptiCurrent->pq->cLockCount)--;
            }

            return HEC_ERROR;
        }

        /*
         * Make sure we actually set the pdesk in the current thread
         */
        UserAssert(ptiCurrent->rpdesk != NULL);

        /*
         * Determine if this box can come to the foreground.
         * Let it come to the foreground if it doesn't have a pti
         * (it might have just failed to load).
         */
        fAllowForeground = FALSE;
        if (handle != NULL) {
            Status = ObReferenceObjectByHandle(handle,
                                               THREAD_QUERY_INFORMATION,
                                               *PsThreadType,
                                               UserMode,
                                               &Thread,
                                               NULL);
            if (NT_SUCCESS(Status)) {
                ptiClient = PtiFromThread(Thread);
                if ((ptiClient == NULL) || CanForceForeground(ptiClient->ppi)) {
                    fAllowForeground = TRUE;
                }

                UnlockThread(Thread);
            } else {
                RIPMSGF2(RIP_WARNING,
                         "Failed to get thread (0x%p), Status: 0x%x",
                         handle,
                         Status);
            }
        }

        if (fAllowForeground) {
            ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxHardErrorControl set TIF %#lx", ptiCurrent);
        } else {
            ptiCurrent->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxHardErrorControl clear TIF %#lx", ptiCurrent);
        }

        break;

    case HardErrorDetach:

        /*
         * xxxSwitchDesktop may have sent WM_QUIT to the msgbox, so
         * ensure that the quit flag is reset.
         */
        ptiCurrent->TIF_flags &= ~TIF_QUITPOSTED;

        /*
         * We will reset the hard-error queue to the pre-allocated
         * one so if we end up looping back (i.e. from a desktop
         * switch), we will have a valid queue in case the desktop
         * was deleted.
         */
        UserAssert(gHardErrorHandler.pqAttach->cLockCount);
        (gHardErrorHandler.pqAttach->cLockCount)--;

        DeferWinEventNotify();

        BEGINATOMICCHECK();

        if (ptiCurrent->pq != gHardErrorHandler.pqAttach) {
            UserAssert(gHardErrorHandler.pqAttach->cThreads == 0);
            AllocQueue(NULL, gHardErrorHandler.pqAttach);
            gHardErrorHandler.pqAttach->cThreads++;
            zzzAttachToQueue(ptiCurrent, gHardErrorHandler.pqAttach, NULL, FALSE);
        }

        gHardErrorHandler.pqAttach = NULL;

        ENDATOMICCHECK();

        zzzEndDeferWinEventNotify();

        /*
         * Fall through.
         */

    case HardErrorDetachNoQueue:
        /*
         * Detach the handler from the desktop and return
         * status to indicate if a switch has occured.
         */
        pdesk = ptiCurrent->rpdesk;
        xxxRestoreCsrssThreadDesktop(pdrdRestore);

        if (ISTS()) {
            /*
             * The hard error message box gets a desktop switch notification,
             * so remember that we lied to him and lie (or unlie) to him again.
             * A desktop switch did occur.
             */
            if (gbDisconnectHardErrorAttach) {
               gbDisconnectHardErrorAttach = FALSE;
               return HEC_DESKTOPSWITCH;
            }
#ifdef WAY_LATER
            /*
             * This happened once and caused a trap when a KeyEvent() came in and we
             * directed it to this queue.  I think this is a MS window that we caught
             * since we use this so much for license popup's.
             */
            if (gHardErrorHandler.pqAttach == gpqForeground) {
                gpqForeground = NULL;
            }
#endif
        }

        return (pdesk != grpdeskRitInput ? HEC_DESKTOPSWITCH : HEC_SUCCESS);
    }

    return HEC_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\rare.c ===
/****************************** Module Header ******************************\
* Module Name: rare.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 06-28-91 MikeHar      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * MetricsRecalc flags
 */
#define CALC_RESIZE         0x0001
#define CALC_FRAME          0x0002
#define CALC_MINIMIZE       0x0004

/*
 * NormalizeRect flags
 */
#define NORMALIZERECT_NORMAL        0
#define NORMALIZERECT_MAXIMIZED     1
#define NORMALIZERECT_FULLSCREEN    2

/***************************************************************************\
* SnapshotMonitorRects
*
* This is called from ResetDisplay to memorize the monitor positions so
* DesktopRecalcEx will know where to move stuff.
*
* Returns the MONITORRECTS if succeeded, NULL otherwise.
*
* History:
* 09-Dec-1996 adams     Created.
\***************************************************************************/
PMONITORRECTS SnapshotMonitorRects(
    VOID)
{
    PMONITOR        pMonitor;
    PMONITORRECTS   pmr;
    PMONITORPOS     pmp;
#if DBG
    ULONG           cVisMon = 0;
#endif

    pmr = UserAllocPool(sizeof(MONITORRECTS) + sizeof(MONITORPOS) * (gpDispInfo->cMonitors - 1),
                        TAG_MONITORRECTS);

    if (!pmr) {
        RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "Out of memory in SnapshotMonitorRects");
        return NULL;
    }

    pmp = pmr->amp;
    for (pMonitor = gpDispInfo->pMonitorFirst;
         pMonitor;
         pMonitor = pMonitor->pMonitorNext) {

        if (!(pMonitor->dwMONFlags & MONF_VISIBLE)) {
            continue;
        }
#if DBG
        cVisMon++;
#endif

        CopyRect(&pmp->rcMonitor, &pMonitor->rcMonitor);
        CopyRect(&pmp->rcWork,    &pMonitor->rcWork);

        /*
         * If the device for this monitor object is not active, don't store
         * the pointer to it in the list. This way the windows on the inactive
         * monitor will be later moved to the default one.
         */
        if (HdevFromMonitor(pMonitor) == -1) {
            pmp->pMonitor = NULL;
        } else {
            pmp->pMonitor = pMonitor;
        }

        pmp++;
    }
    UserAssert(cVisMon == gpDispInfo->cMonitors);

    pmr->cMonitor = (int)(pmp - pmr->amp);

    return pmr;
}


/***************************************************************************\
* UpdateMonitorRectsSnapShot
*
* Updates a Monitor rects snapshot. Every pMonitor in MONITORPOS is checked
* to still be a valid monitor. If the pMonitor is no loger valid (deleted
* by a ChangeDisplaySettings. it is zeroed so that its windows will be
* repositioned on the primary monitor. This code is only used on by the
* reconnect in TS scenario and is there for cases that are not happening
* today: today reconnect always happens from disconnected state where we go
* from 1 monitor (the disconnected display driver) to n monitors and this
* monitor (starting in (0,0) never gets deleted because it alway matches one
* of the new n monitors (the one starting in (0,0). So this code is just in
* case of future changes.
*
* History:
\***************************************************************************/
VOID UpdateMonitorRectsSnapShot(
    PMONITORRECTS pmr)
{
    int i;
    PMONITORPOS   pmp = pmr->amp;

    for (i = 0; i < pmr->cMonitor; i++) {
        if (pmp->pMonitor != NULL) {
            if (!IsValidMonitor(pmp->pMonitor)) {
                pmp->pMonitor = NULL;
            }
        }

        pmp++;
    }
}

BOOL IsValidMonitor(
    PMONITOR pMonitor)
{
    PMONITOR pMonitorNext = gpDispInfo->pMonitorFirst;

    while (pMonitorNext != NULL) {
        if (pMonitorNext == pMonitor) {
            return TRUE;
        }

        pMonitorNext = pMonitorNext->pMonitorNext;
    }

    return FALSE;
}

/***************************************************************************\
* NormalizeRect
*
* Adjusts a window rectangle when the working area changes. This can be
* because of a tray move, with the resolution staying the same, or
* because of a dynamic resolution change, with the tray staying the same
* relatively.
*
* History:
\***************************************************************************/
PMONITOR NormalizeRect(
    LPRECT          lprcDest,
    LPRECT          lprcSrc,
    PMONITORRECTS   pmrOld,
    int             iOldMonitor,
    int             codeFullScreen,
    DWORD           style)
{
    LPCRECT     lprcOldMonitor;
    LPCRECT     lprcOldWork;
    LPRECT      lprcNewWork;
    PMONITOR    pMonitor;
    int         cxOldMonitor;
    int         cyOldMonitor;
    int         cxNewMonitor;
    int         cyNewMonitor;
    int         dxOrg, dyOrg;

    /*
     * Track the window so it stays in the same place on the same monitor.
     * If the old monitor is no longer active then pick a default.
     */
    if ((pMonitor = pmrOld->amp[iOldMonitor].pMonitor) == NULL) {
        pMonitor = GetPrimaryMonitor();
    }

    lprcOldMonitor = &pmrOld->amp[iOldMonitor].rcMonitor;
    lprcOldWork = &pmrOld->amp[iOldMonitor].rcWork;

    /*
     * If is a fullscreen app just make it fullscreen at the new location.
     */
    if (codeFullScreen != NORMALIZERECT_NORMAL) {
        LPCRECT lprcOldSnap, lprcNewSnap;

        /*
         * If it is a maximized window snap it to the work area. Otherwise
         * it is a rude app so snap it to the screen.
         */
        if (codeFullScreen == NORMALIZERECT_MAXIMIZED) {
            lprcOldSnap = lprcOldWork;
            lprcNewSnap = &pMonitor->rcWork;
        } else {
            lprcOldSnap = lprcOldMonitor;
            lprcNewSnap = &pMonitor->rcMonitor;
        }

        lprcDest->left = lprcSrc->left +
            lprcNewSnap->left - lprcOldSnap->left;

        lprcDest->top = lprcSrc->top +
            lprcNewSnap->top - lprcOldSnap->top;

        lprcDest->right = lprcSrc->right +
            lprcNewSnap->right - lprcOldSnap->right;

        lprcDest->bottom = lprcSrc->bottom +
            lprcNewSnap->bottom - lprcOldSnap->bottom;

        goto AllDone;
    }

    /*
     * Offset the window by the change in desktop origin.
     */
    dxOrg = pMonitor->rcMonitor.left - lprcOldMonitor->left;
    dyOrg = pMonitor->rcMonitor.top - lprcOldMonitor->top;

    /*
     * Calculate the change in screen size (we need it in more than one place).
     */
    cxOldMonitor = lprcOldMonitor->right - lprcOldMonitor->left;
    cyOldMonitor = lprcOldMonitor->bottom - lprcOldMonitor->top;
    cxNewMonitor = pMonitor->rcMonitor.right - pMonitor->rcMonitor.left;
    cyNewMonitor = pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top;

    /*
     * If the monitor resolution has changed (or we moved to a new monitor)
     * then factor in the size change.
     */
    if (cxNewMonitor != cxOldMonitor || cyNewMonitor != cyOldMonitor) {
        int xWnd = lprcSrc->left - lprcOldMonitor->left;
        int yWnd = lprcSrc->top - lprcOldMonitor->top;

        dxOrg += MultDiv(xWnd, cxNewMonitor - cxOldMonitor, cxOldMonitor);
        dyOrg += MultDiv(yWnd, cyNewMonitor - cyOldMonitor, cyOldMonitor);
    }

    /*
     * Compute the initial new position.
     */
    CopyOffsetRect(lprcDest, lprcSrc, dxOrg, dyOrg);
    lprcNewWork = &pMonitor->rcWork;

    /*
     * Fit horizontally.  Try to fit so that the window isn't out of the
     * working area horizontally.  Keep left edge visible always.
     */
    if (lprcDest->right > lprcNewWork->right) {
        OffsetRect(lprcDest, lprcNewWork->right - lprcDest->right, 0);
    }

    if (lprcDest->left < lprcNewWork->left) {
        OffsetRect(lprcDest, lprcNewWork->left - lprcDest->left, 0);
    }

    /*
     * Fit vertically.  Try to fit so that the window isn't out of the
     * working area vertically.  Keep top edge visible always.
     */
    if (lprcDest->bottom > lprcNewWork->bottom) {
        OffsetRect(lprcDest, 0, lprcNewWork->bottom - lprcDest->bottom);
    }

    if (lprcDest->top < lprcNewWork->top) {
        OffsetRect(lprcDest, 0, lprcNewWork->top - lprcDest->top);
    }

    /*
     * If the window is sizeable then shrink it if necessary.
     */
    if (style & WS_THICKFRAME) {
        int cSnap = 0;

        if (lprcDest->right > lprcNewWork->right) {
            lprcDest->right = lprcNewWork->right;
            cSnap++;
        }

        if (lprcDest->bottom > lprcNewWork->bottom) {
            lprcDest->bottom = lprcNewWork->bottom;
            cSnap++;
        }


        /*
         * Now make sure we didn't turn this normal window into a
         * fullscreen window. This is a complete hack but it is much
         * better than changing from 800x600 to 640x480 and ending up with
         * a bunch of fullscreen apps...
         */
        if (cSnap == 2) {
            InflateRect(lprcDest, -1, -1);
        }
    }

AllDone:
    return pMonitor;
}


#if DBG
/***************************************************************************\
* SetRipFlags
*
* Sets the debug rip flags.
*
* History:
* 16-Aug-1996 adams     Created.
\***************************************************************************/
VOID SetRipFlags(
    DWORD dwRipFlags)
{
    if (gpsi) {
        if (!(dwRipFlags & ~RIPF_VALIDUSERFLAGS)) {
            gpsi->dwRIPFlags = ((gpsi->dwRIPFlags & ~RIPF_VALIDUSERFLAGS) | dwRipFlags);
        }
    }
}

/***************************************************************************\
* SetDbgTag
*
* Sets debugging level for a tag.
*
* History:
* 16-Aug-1996 adams     Created.
\***************************************************************************/
VOID SetDbgTag(
    int tag,
    DWORD dwDBGTAGFlags)
{
    if (tag > DBGTAG_Max || tag < 0) {
        return;
    }

    if (gpsi && tag < DBGTAG_Max && !(dwDBGTAGFlags & ~DBGTAG_VALIDUSERFLAGS)) {
        COPY_FLAG(gpsi->adwDBGTAGFlags[tag], dwDBGTAGFlags, DBGTAG_VALIDUSERFLAGS);
    }
}


/***************************************************************************\
* SetDbgTagCount
*
* Sets the number of tags. This is necessary because one can use a
* userkdx.dll that was built in an enlistment with N tags, but use it against
* a system that has M tags (where N != M), which causes obvious problems.
*
* History:
* 05-Oct-2001   JasonSch    Created.
\***************************************************************************/
VOID SetDbgTagCount(
    DWORD dwCount)
{
    gpsi->dwTagCount = dwCount;
}
#endif

/***************************************************************************\
* UpdateWinIniInt
*
* History:
* 18-Apr-1994 mikeke     Created
\***************************************************************************/
BOOL UpdateWinIniInt(
    PUNICODE_STRING pProfileUserName,
    UINT idSection,
    UINT wKeyNameId,
    int value)
{
    WCHAR szTemp[40];
    WCHAR szKeyName[40];

    swprintf(szTemp, L"%d", value);

    ServerLoadString(hModuleWin,
                     wKeyNameId,
                     szKeyName,
                     ARRAY_SIZE(szKeyName));

    return FastWriteProfileStringW(pProfileUserName,
                                   idSection,
                                   szKeyName,
                                   szTemp);
}

/***************************************************************************\
* SetDesktopMetrics
*
* History:
* 31-Jan-1994 mikeke    Ported
\***************************************************************************/
VOID SetDesktopMetrics(
    VOID)
{
    LPRECT lprcWork;

    lprcWork = &GetPrimaryMonitor()->rcWork;

    SYSMET(CXFULLSCREEN) = lprcWork->right - lprcWork->left;
    SYSMET(CXMAXIMIZED) = lprcWork->right - lprcWork->left + 2 * SYSMET(CXSIZEFRAME);

    SYSMET(CYFULLSCREEN) = lprcWork->bottom - lprcWork->top - SYSMET(CYCAPTION);
    SYSMET(CYMAXIMIZED) = lprcWork->bottom - lprcWork->top + 2 * SYSMET(CYSIZEFRAME);
}

/***************************************************************************\
* xxxMetricsRecalc (Win95: MetricsRecalc)
*
* Does work to size/position all minimized or nonminimized
* windows.  Called when frame metrics or min metrics are changed.
*
* Note that you can NOT do DeferWindowPos() with this function.  SWP doesn't
* work when you do parents and children at the same time--it's only for
* peer windows.  Thus we must do SetWindowPos() for each window.
*
* History:
* 06-28-91 MikeHar      Ported.
\***************************************************************************/
VOID xxxMetricsRecalc(
    UINT wFlags,
    int  dx,
    int  dy,
    int  dyCaption,
    int  dyMenu)
{
    PHWND       phwnd;
    PWND        pwnd;
    RECT        rc;
    PCHECKPOINT pcp;
    TL          tlpwnd;
    BOOL        fResized;
    PBWL        pbwl;
    PTHREADINFO ptiCurrent;
    int         c;

    ptiCurrent = PtiCurrent();
    pbwl = BuildHwndList(GETDESKINFO(ptiCurrent)->spwnd->spwndChild,
                         BWL_ENUMLIST | BWL_ENUMCHILDREN,
                         NULL);

    if (!pbwl) {
        return;
    }

    UserAssert(*pbwl->phwndNext == (HWND) 1);
    c = (int)(pbwl->phwndNext - pbwl->rghwnd);
    for (phwnd = pbwl->rghwnd; c > 0; c--, phwnd++) {
        pwnd = RevalidateHwnd(*phwnd);
        if (!pwnd) {
            continue;
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

        fResized = FALSE;

        if ((wFlags & CALC_MINIMIZE) && TestWF(pwnd, WFMINIMIZED)) {
            /*
             * We're changing the minimized window dimensions. We need to
             * resize. Note that we do NOT move.
             */
            CopyRect(&rc, (&pwnd->rcWindow));
            rc.right += dx;
            rc.bottom += dy;

            goto PositionWnd;
        }

        /*
         * We're changing the size of the window because the sizing border
         * changed.
         */
        if ((wFlags & CALC_RESIZE) && TestWF(pwnd, WFSIZEBOX)) {
            pcp = (PCHECKPOINT)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);

            /*
             * Update maximized position to account for sizing border
             * We do this for DOS box also. This way client of max'ed windows
             * stays in same relative position.
             */
            if (pcp && (pcp->fMaxInitialized)) {
                pcp->ptMax.x -= dx;
                pcp->ptMax.y -= dy;
            }

            if (TestWF(pwnd, WFMINIMIZED)) {
                if (pcp) {
                    InflateRect(&pcp->rcNormal, dx, dy);
                }
            } else {
                CopyInflateRect(&rc, (&pwnd->rcWindow), dx, dy);
                if (TestWF(pwnd, WFCPRESENT)) {
                    rc.bottom += dyCaption;
                }
                if (TestWF(pwnd, WFMPRESENT)) {
                    rc.bottom += dyMenu;
                }

PositionWnd:
                fResized = TRUE;

                /*
                 * Remember SWP expects values in PARENT CLIENT coordinates.
                 */
                if (pwnd->spwndParent != PWNDDESKTOP(pwnd)) {
                    OffsetRect(&rc,
                               -pwnd->spwndParent->rcClient.left,
                               -pwnd->spwndParent->rcClient.top);
                }

                xxxSetWindowPos(pwnd,
                                PWND_TOP,
                                rc.left,
                                rc.top,
                                rc.right-rc.left,
                                rc.bottom-rc.top,
                                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS |
                                    SWP_FRAMECHANGED | SWP_NOREDRAW);
            }
        }

        /*
         * We're changing the nonclient widgets, so recalculate the client.
         */
        if (wFlags & CALC_FRAME) {
            /*
             * Delete any cached small icons.
             */
            if (dyCaption) {
                 xxxSendMessage(pwnd, WM_SETICON, ICON_RECREATE, 0);
            }

            if (!TestWF(pwnd, WFMINIMIZED) && !fResized) {
                CopyRect(&rc, &(pwnd->rcWindow));
                if (TestWF(pwnd, WFMPRESENT)) {
                    rc.bottom += dyMenu;
                }

                if (TestWF(pwnd, WFCPRESENT)) {
                    rc.bottom += dyCaption;

                    /*
                     * Maximized MDI child windows position their caption
                     * outside their parent's client area (negative y). If
                     * the caption has changed, they need to be repositioned.
                     */
                    if (TestWF(pwnd, WFMAXIMIZED)
                            && TestWF(pwnd, WFCHILD)
                            && (GETFNID(pwnd->spwndParent) == FNID_MDICLIENT)) {

                        xxxSetWindowPos(pwnd,
                                        PWND_TOP,
                                        rc.left - pwnd->spwndParent->rcWindow.left,
                                        rc.top - pwnd->spwndParent->rcWindow.top - dyCaption,
                                        rc.right - rc.left,
                                        rc.bottom - rc.top,
                                        SWP_NOZORDER | SWP_NOACTIVATE |
                                            SWP_FRAMECHANGED | SWP_NOREDRAW);
                        goto LoopCleanup;
                    }
                }

                xxxSetWindowPos(pwnd,
                                PWND_TOP,
                                0,
                                0,
                                rc.right-rc.left,
                                rc.bottom-rc.top,
                                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE |
                                    SWP_FRAMECHANGED | SWP_NOCOPYBITS |
                                    SWP_NOREDRAW);
            }
        }

LoopCleanup:
        ThreadUnlock(&tlpwnd);
    }

    FreeHwndList(pbwl);
}

/***************************************************************************\
* FindOldMonitor
*
* Returns the index of the monitor in "pmr" which has the greatest
* overlap with a rectangle. This function is used to determine which
* monitor a window was on after one or more monitor rectangles have
* changed.
*
* History:
* 11-Sep-1996 adams     Created.
\***************************************************************************/
int FindOldMonitor(
    LPCRECT lprc,
    PMONITORRECTS pmr)
{
    DWORD       dwClosest;
    int         iClosest, i;
    int         cxRect, cyRect;
    PMONITORPOS pmp;

    iClosest = -1;
    dwClosest = 0;

    cxRect = (lprc->right - lprc->left);
    cyRect = (lprc->bottom - lprc->top);

    for (i = 0, pmp = pmr->amp; i < pmr->cMonitor; pmp++, i++) {
        RECT rcT;

        if (IntersectRect(&rcT, lprc, &pmp->rcMonitor)) {
            DWORD dwT;

            /*
             * Convert to width/height.
             */
            rcT.right -= rcT.left;
            rcT.bottom -= rcT.top;

            /*
             * If fully enclosed, we're done.
             */
            if (rcT.right == cxRect && rcT.bottom == cyRect) {
                return i;
            }

            /*
             * Use largest area.
             */
            dwT = (DWORD)rcT.right * (DWORD)rcT.bottom;
            if (dwT > dwClosest) {
                dwClosest = dwT;
                iClosest = i;
            }
        }
    }

    return iClosest;
}


/***************************************************************************\
* xxxDesktopRecalc
*
* Moves all top-level nonpopup windows into free desktop area,
* attempting to keep them in the same position relative to the monitor
* they were on.  Also resets minimized info (so that when a window is
* subsequently minimized it will go to the correct location).
*
* History:
* 11-Sep-1996 adams     Created.
\***************************************************************************/
VOID xxxDesktopRecalc(
    PMONITORRECTS pmrOld)
{
    PWND            pwndDesktop;
    PSMWP           psmwp;
    PHWND           phwnd;
    PBWL            pbwl;
    PWND            pwnd;
    CHECKPOINT *    pcp;
    int             iOldMonitor;
    int             codeFullScreen;
    UINT            flags = SWP_NOACTIVATE | SWP_NOZORDER;


    /*
     * We never want CSRSS to position windows synchronously because it
     * might get blocked by a hung app. CSRSS needs to reposition windows
     * in the TS reconnect and disconnect path as part of changing display
     * setting to switch display drivers or to match new client resolution.
     */
    if (ISCSRSS()) {
        flags |= SWP_ASYNCWINDOWPOS;
    }

    UserVerify(pwndDesktop = _GetDesktopWindow());
    if ((pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, NULL)) == NULL) {
        return;
    }

    if ((psmwp = InternalBeginDeferWindowPos(4)) != NULL) {
        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1 && psmwp; phwnd++) {
            /*
             * Make sure this hwnd is still around.
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL ||
                TestWF(pwnd, WEFTOOLWINDOW)) {
                continue;
            }

            codeFullScreen = TestWF(pwnd, WFFULLSCREEN) ?
                                 NORMALIZERECT_FULLSCREEN : NORMALIZERECT_NORMAL;

            pcp = (PCHECKPOINT)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);
            if (pcp) {
                /*
                 * We don't need to blow away saved maximized positions
                 * anymore, since the max position is always (for top level
                 * windows) relative to the origin of the monitor's working
                 * area. And for child windows, we shouldn't do it period
                 * anyway.
                 */
                pcp->fMinInitialized = FALSE;

                /*
                 * Figure out which monitor the position was on before things
                 * got shuffled around and try to keep it on that monitor. If
                 * it was never visible on a monitor then leave it alone.
                 */
                iOldMonitor = FindOldMonitor(&pcp->rcNormal, pmrOld);
                if (iOldMonitor != (UINT)-1) {
                    NormalizeRect(&pcp->rcNormal,
                                  &pcp->rcNormal,
                                  pmrOld,
                                  iOldMonitor,
                                  codeFullScreen,
                                  pwnd->style);
                }
            }

            /*
             * Figure out which monitor the position was on before things got
             * shuffled around and try to keep it on that monitor. If it
             * was never visible on a monitor then leave it alone.
             */
            iOldMonitor = FindOldMonitor(&pwnd->rcWindow, pmrOld);
            if (iOldMonitor != -1) {
                PMONITOR pMonitorDst;
                RECT rc;

                /*
                 * Check for maximized apps that are truly maximized (as
                 * opposed to apps that manage their owm maximized rect).
                 */
                if (TestWF(pwnd, WFMAXIMIZED)) {
                    LPRECT lprcOldWork = &pmrOld->amp[iOldMonitor].rcWork;

                    if (    (pwnd->rcWindow.right - pwnd->rcWindow.left >=
                                lprcOldWork->right - lprcOldWork->left)
                            &&
                            (pwnd->rcWindow.bottom - pwnd->rcWindow.top >=
                                lprcOldWork->bottom - lprcOldWork->top)) {

                        codeFullScreen = NORMALIZERECT_MAXIMIZED;
                    }
                }

                pMonitorDst = NormalizeRect(&rc,
                                            &pwnd->rcWindow,
                                            pmrOld,
                                            iOldMonitor,
                                            codeFullScreen,
                                            pwnd->style);

                if (TestWF(pwnd, WFMAXFAKEREGIONAL)) {
                    UserAssert(pMonitorDst->hrgnMonitor);
                    pwnd->hrgnClip = pMonitorDst->hrgnMonitor;
                }


                psmwp = _DeferWindowPos(psmwp,
                                        pwnd,
                                        (PWND)HWND_TOP,
                                        rc.left,
                                        rc.top,
                                        rc.right - rc.left,
                                        rc.bottom - rc.top,
                                        flags);
            }
        }

        if (psmwp) {
            xxxEndDeferWindowPosEx(psmwp, TRUE);
        }
    }

    FreeHwndList(pbwl);
}


/***************************************************************************\
* SetWindowMetricInt
*
* History:
* 25-Feb-96 BradG       Added Pixel -> TWIPS conversion
\***************************************************************************/
BOOL SetWindowMetricInt(
    PUNICODE_STRING pProfileUserName,
    WORD wKeyNameId,
    int iIniValue)
{
    /*
     * If you change the below list of STR_* make sure you make a
     * corresponding change in FastGetProfileIntFromID.
     */
    switch (wKeyNameId) {
    case STR_BORDERWIDTH:
    case STR_SCROLLWIDTH:
    case STR_SCROLLHEIGHT:
    case STR_CAPTIONWIDTH:
    case STR_CAPTIONHEIGHT:
    case STR_SMCAPTIONWIDTH:
    case STR_SMCAPTIONHEIGHT:
    case STR_MENUWIDTH:
    case STR_MENUHEIGHT:
    case STR_ICONHORZSPACING:
    case STR_ICONVERTSPACING:
    case STR_MINWIDTH:
    case STR_MINHORZGAP:
    case STR_MINVERTGAP:
        /*
         * Always store window metrics in TWIPS
         */
        iIniValue = -MultDiv(iIniValue, 72*20, gpsi->dmLogPixels);
        break;
    }

    return UpdateWinIniInt(pProfileUserName,
                           PMAP_METRICS,
                           wKeyNameId,
                           iIniValue);
}

/***************************************************************************\
* SetWindowMetricFont
*
* History:
\***************************************************************************/
BOOL SetWindowMetricFont(
    PUNICODE_STRING pProfileUserName,
    UINT idKey,
    LPLOGFONT lplf)
{
    return FastWriteProfileValue(pProfileUserName,
                                 PMAP_METRICS,
                                 (LPWSTR)UIntToPtr(idKey),
                                 REG_BINARY,
                                 (LPBYTE)lplf,
                                 sizeof(LOGFONTW));
}


/***************************************************************************\
* SetAndDrawNCMetrics
*
* History:
\***************************************************************************/
BOOL xxxSetAndDrawNCMetrics(
    PUNICODE_STRING pProfileUserName,
    int clNewBorder,
    LPNONCLIENTMETRICS lpnc)
{
    int dl;
    int dxMinOld;
    int dyMinOld;
    int cxBorder;
    int cyBorder;
    int dyCaption;
    int dyMenu;

    dl = clNewBorder - gpsi->gclBorder;
    dxMinOld = SYSMET(CXMINIMIZED);
    dyMinOld = SYSMET(CYMINIMIZED);
    cxBorder = SYSMET(CXBORDER);
    cyBorder = SYSMET(CYBORDER);


    /*
     * Do we need to recalculate?
     */
    if (lpnc == NULL && !dl) {
        return FALSE;
    }

    if (lpnc) {
        dyCaption = (int)lpnc->iCaptionHeight - SYSMET(CYSIZE);
        dyMenu = (int)lpnc->iMenuHeight - SYSMET(CYMENUSIZE);
    } else {
        dyCaption = dyMenu = 0;
    }


    /*
     * Recalculate the system metrics.
     */
    xxxSetWindowNCMetrics(pProfileUserName, lpnc, TRUE, clNewBorder);

    /*
     * Reset our saved menu size/position info.
     */
    MenuRecalc();

    /*
     * Reset window sized, positions, frames
     */
    xxxMetricsRecalc(CALC_FRAME | (dl ? CALC_RESIZE : 0),
                     dl * cxBorder,
                     dl * cyBorder,
                     dyCaption,
                     dyMenu);

    dxMinOld = SYSMET(CXMINIMIZED) - dxMinOld;
    dyMinOld = SYSMET(CYMINIMIZED) - dyMinOld;
    if (dxMinOld || dyMinOld) {
        xxxMetricsRecalc(CALC_MINIMIZE, dxMinOld, dyMinOld, 0, 0);
    }

    xxxRedrawScreen();


    return TRUE;
}

/***************************************************************************\
* xxxSetAndDrawMinMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL xxxSetAndDrawMinMetrics(
    PUNICODE_STRING pProfileUserName,
    LPMINIMIZEDMETRICS lpmin)
{
    /*
     * Save minimized window dimensions.
     */
    int dxMinOld = SYSMET(CXMINIMIZED);
    int dyMinOld = SYSMET(CYMINIMIZED);

    SetMinMetrics(pProfileUserName,lpmin);

    /*
     * Do we need to adjust minimized size?
     */
    dxMinOld = SYSMET(CXMINIMIZED) - dxMinOld;
    dyMinOld = SYSMET(CYMINIMIZED) - dyMinOld;

    if (dxMinOld || dyMinOld) {
        xxxMetricsRecalc(CALC_MINIMIZE, dxMinOld, dyMinOld, 0, 0);
    }

    xxxRedrawScreen();

    return TRUE;
}


/***************************************************************************\
* xxxSPISetNCMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL xxxSPISetNCMetrics(
    PUNICODE_STRING pProfileUserName,
    LPNONCLIENTMETRICS lpnc,
    BOOL fAlterWinIni)
{
    BOOL fWriteAllowed = !fAlterWinIni;
    BOOL fChanged = FALSE;

    lpnc->iBorderWidth = max(lpnc->iBorderWidth, 1);
    lpnc->iBorderWidth = min(lpnc->iBorderWidth, 50);

    if (fAlterWinIni) {
        fChanged  = SetWindowMetricInt(pProfileUserName, STR_BORDERWIDTH, lpnc->iBorderWidth);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_SCROLLWIDTH, lpnc->iScrollWidth);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_SCROLLHEIGHT, lpnc->iScrollHeight);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_CAPTIONWIDTH, lpnc->iCaptionWidth);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_CAPTIONHEIGHT, lpnc->iCaptionHeight);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_SMCAPTIONWIDTH, lpnc->iSmCaptionWidth);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_SMCAPTIONHEIGHT, lpnc->iSmCaptionHeight);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_MENUWIDTH, lpnc->iMenuWidth);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_MENUHEIGHT, lpnc->iMenuHeight);

        fChanged &= SetWindowMetricFont(pProfileUserName, STR_CAPTIONFONT, &lpnc->lfCaptionFont);
        fChanged &= SetWindowMetricFont(pProfileUserName, STR_SMCAPTIONFONT, &lpnc->lfSmCaptionFont);
        fChanged &= SetWindowMetricFont(pProfileUserName, STR_MENUFONT, &lpnc->lfMenuFont);
        fChanged &= SetWindowMetricFont(pProfileUserName, STR_STATUSFONT, &lpnc->lfStatusFont);
        fChanged &= SetWindowMetricFont(pProfileUserName, STR_MESSAGEFONT, &lpnc->lfMessageFont);

        fWriteAllowed = fChanged;
    }

    if (fWriteAllowed) {
        xxxSetAndDrawNCMetrics(pProfileUserName, lpnc->iBorderWidth, lpnc);
    }

    return fChanged;
}

/***************************************************************************\
* xxxSPISetMinMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL xxxSPISetMinMetrics(
    PUNICODE_STRING pProfileUserName,
    LPMINIMIZEDMETRICS lpmin,
    BOOL fAlterWinIni)
{
    BOOL fWriteAllowed = !fAlterWinIni;
    BOOL fChanged = FALSE;

    if (fAlterWinIni) {
        fChanged  = SetWindowMetricInt(pProfileUserName, STR_MINWIDTH, lpmin->iWidth);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_MINHORZGAP, lpmin->iHorzGap);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_MINVERTGAP, lpmin->iVertGap);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_MINARRANGE, lpmin->iArrange);

        fWriteAllowed = fChanged;
    }

    if (fWriteAllowed) {
        xxxSetAndDrawMinMetrics(pProfileUserName, lpmin);
    }

    return fChanged;
}


/***************************************************************************\
* SPISetIconMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL SPISetIconMetrics(
    PUNICODE_STRING pProfileUserName,
    LPICONMETRICS lpicon,
    BOOL fAlterWinIni)
{
    BOOL fWriteAllowed = !fAlterWinIni;
    BOOL fChanged = FALSE;

    if (fAlterWinIni) {
        fChanged  = SetWindowMetricInt(pProfileUserName, STR_ICONHORZSPACING, lpicon->iHorzSpacing);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_ICONVERTSPACING, lpicon->iVertSpacing);
        fChanged &= SetWindowMetricInt(pProfileUserName, STR_ICONTITLEWRAP, lpicon->iTitleWrap);
        fChanged &= SetWindowMetricFont(pProfileUserName, STR_ICONFONT, &lpicon->lfFont);

        fWriteAllowed = fChanged;
    }

    if (fWriteAllowed) {
        SetIconMetrics(pProfileUserName,lpicon);
        xxxRedrawScreen();
    }

    return fChanged;
}


/***************************************************************************\
* SPISetIconTitleFont
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL SPISetIconTitleFont(
    PUNICODE_STRING pProfileUserName,
    LPLOGFONT lplf,
    BOOL fAlterWinIni)
{
    HFONT hfnT;
    BOOL  fWriteAllowed = !fAlterWinIni;
    BOOL  fWinIniChanged = FALSE;

    if (hfnT = CreateFontFromWinIni(pProfileUserName,lplf, STR_ICONFONT)) {
        if (fAlterWinIni) {
            if (lplf) {
                LOGFONT lf;

                GreExtGetObjectW(hfnT, sizeof(LOGFONTW), &lf);
                fWinIniChanged = SetWindowMetricFont(pProfileUserName, STR_ICONFONT, &lf);
            } else {
                /*
                 * !lParam so go back to current win.ini settings.
                 */
                fWinIniChanged = TRUE;
            }

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            if (ghIconFont) {
                GreMarkDeletableFont(ghIconFont);
                GreDeleteObject(ghIconFont);
            }

            ghIconFont = hfnT;
        } else {
            GreMarkDeletableFont(hfnT);
            GreDeleteObject(hfnT);
        }
    }

    return fWinIniChanged;
}

/***************************************************************************\
* xxxSetSPIMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL xxxSetSPIMetrics(
    PUNICODE_STRING pProfileUserName,
    DWORD wFlag,
    LPVOID lParam,
    BOOL fAlterWinIni)
{
    BOOL fWinIniChanged;

    switch (wFlag) {
    case SPI_SETANIMATION:
        if (fAlterWinIni) {
            fWinIniChanged = SetWindowMetricInt(pProfileUserName,
                                                STR_MINANIMATE,
                                                (int)((LPANIMATIONINFO)lParam)->iMinAnimate);

            if (!fWinIniChanged) {
                return FALSE;
            }
        } else {
            fWinIniChanged = FALSE;
        }

        SET_OR_CLEAR_PUDF(PUDF_ANIMATE, ((LPANIMATIONINFO)lParam)->iMinAnimate);
        return fWinIniChanged;

    case SPI_SETNONCLIENTMETRICS:
        return xxxSPISetNCMetrics(pProfileUserName, (LPNONCLIENTMETRICS)lParam, fAlterWinIni);

    case SPI_SETICONMETRICS:
        return SPISetIconMetrics(pProfileUserName, (LPICONMETRICS)lParam, fAlterWinIni);

    case SPI_SETMINIMIZEDMETRICS:
        return xxxSPISetMinMetrics(pProfileUserName, (LPMINIMIZEDMETRICS)lParam, fAlterWinIni);

    case SPI_SETICONTITLELOGFONT:
        return SPISetIconTitleFont(pProfileUserName, (LPLOGFONT)lParam, fAlterWinIni);

    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "SetSPIMetrics. Invalid wFlag: 0x%x", wFlag);
        return FALSE;
    }
}

/***************************************************************************\
* SetFilterKeys
*
* History:
* 10-12-94 JimA         Created.
\***************************************************************************/
BOOL SetFilterKeys(
    PUNICODE_STRING pProfileUserName,
    LPFILTERKEYS pFilterKeys)
{
    LPWSTR pwszd = L"%d";
    BOOL fWinIniChanged;
    WCHAR szTemp[40];

    swprintf(szTemp, pwszd, pFilterKeys->dwFlags);
    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                             PMAP_KEYBOARDRESPONSE,
                                             L"Flags",
                                             szTemp);

    swprintf(szTemp, pwszd, pFilterKeys->iWaitMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_KEYBOARDRESPONSE,
                                              L"DelayBeforeAcceptance",
                                              szTemp);

    swprintf(szTemp, pwszd, pFilterKeys->iDelayMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_KEYBOARDRESPONSE,
                                              L"AutoRepeatDelay",
                                              szTemp);

    swprintf(szTemp, pwszd, pFilterKeys->iRepeatMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_KEYBOARDRESPONSE,
                                              L"AutoRepeatRate",
                                              szTemp);

    swprintf(szTemp, pwszd, pFilterKeys->iBounceMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_KEYBOARDRESPONSE,
                                              L"BounceTime",
                                              szTemp);

    return fWinIniChanged;
}

/***************************************************************************\
* SetMouseKeys
*
* History:
* 10-12-94 JimA         Created.
\***************************************************************************/
BOOL SetMouseKeys(
    PUNICODE_STRING pProfileUserName,
    LPMOUSEKEYS  pMK)
{
    LPWSTR pwszd = L"%d";
    BOOL fWinIniChanged;
    WCHAR szTemp[40];

    swprintf(szTemp, pwszd, pMK->dwFlags);
    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                             PMAP_MOUSEKEYS,
                                             L"Flags",
                                             szTemp);

    swprintf(szTemp, pwszd, pMK->iMaxSpeed);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_MOUSEKEYS,
                                              L"MaximumSpeed",
                                              szTemp);

    swprintf(szTemp, pwszd, pMK->iTimeToMaxSpeed);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_MOUSEKEYS,
                                              L"TimeToMaximumSpeed",
                                              szTemp);

    return fWinIniChanged;
}

/***************************************************************************\
* SetSoundSentry
*
* History:
* 10-12-94 JimA         Created.
\***************************************************************************/
BOOL SetSoundSentry(
    PUNICODE_STRING pProfileUserName,
    LPSOUNDSENTRY pSS)
{
    LPWSTR pwszd = L"%d";
    BOOL fWinIniChanged;
    WCHAR szTemp[40];

    swprintf(szTemp, pwszd, pSS->dwFlags);
    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                             PMAP_SOUNDSENTRY,
                                             L"Flags",
                                             szTemp);

    swprintf(szTemp, pwszd, pSS->iFSTextEffect);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_SOUNDSENTRY,
                                              L"TextEffect",
                                              szTemp);

    swprintf(szTemp, pwszd, pSS->iWindowsEffect);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
                                              PMAP_SOUNDSENTRY,
                                              L"WindowsEffect",
                                              szTemp);

    return fWinIniChanged;
}


/***************************************************************************\
* CalculateMouseSensitivity
*
*      The resultant table looks like this...
*
*      Sens |  Sensitivity Adjustment
*       0   |  0           * SENS_SCALAR  ALGORITHM 0<=NUM<=2
*       1   |  1/32        * SENS_SCALAR   (NUM/32)*SENS_SCALAR
*       2   |  1/16        * SENS_SCALAR
*       3   |  1/8         * SENS_SCALAR  ALGORITHM 3<=NUM<=10
*       4   |  1/4  (2/8)  * SENS_SCALAR   ((NUM-2)/8)*SENS_SCALAR
*       5   |  3/8         * SENS_SCALAR
*       6   |  1/2  (4/8)  * SENS_SCALAR
*       7   |  5/8         * SENS_SCALAR
*       8   |  3/4  (6/8)  * SENS_SCALAR
*       9   |  7/8         * SENS_SCALAR
*       10  |  1           * SENS_SCALAR
*       11  |  5/4         * SENS_SCALAR  ALGORITHM NUM>=11
*       12  |  3/2  (6/4)  * SENS_SCALAR   ((NUM-6)/4)*SENS_SCALAR
*       13  |  7/4         * SENS_SCALAR
*       14  |  2    (8/4)  * SENS_SCALAR
*       15  |  9/4         * SENS_SCALAR
*       16  |  5/2  (10/4) * SENS_SCALAR
*       17  |  11/4        * SENS_SCALAR
*       18  |  3    (12/4) * SENS_SCALAR
*       19  |  13/4        * SENS_SCALAR
*       20  |  7/2  (14/4) * SENS_SCALAR
*
*     COMMENTS:  Sensitivities are constrained to be between 1 and 20.
*
* History:
* 09-27-96 jparsons     Created.
\***************************************************************************/
LONG CalculateMouseSensitivity(
    LONG lSens)
{
    LONG lSenFactor;

    if (lSens <= 2) {
       lSenFactor = lSens * 256 / 32;
    } else if (lSens >= 3 && lSens <= 10 ) {
       lSenFactor = (lSens - 2) * 256 /8;
    } else {
       lSenFactor= (lSens - 6) * 256 / 4;
    }

    return lSenFactor;
}


/***************************************************************************\
* xxxSystemParametersInfo
*
* SPI_GETBEEP:   wParam is not used. lParam is long pointer to a boolean which
*                gets true if beep on, false if beep off.
*
* SPI_SETBEEP:   wParam is a bool which sets beep on (true) or off (false).
*                lParam is not used.
*
* SPI_GETMOUSE:  wParam is not used. lParam is long pointer to an integer
*                array where rgw[0] gets xMouseThreshold, rgw[1] gets
*                yMouseThreshold, and rgw[2] gets gMouseSpeed.
*
* SPI_SETMOUSE:  wParam is not used. lParam is long pointer to an integer
*                array as described above.  User's values are set to values
*                in array.
*
* SPI_GETBORDER: wParam is not used. lParam is long pointer to an integer
*                which gets the value of clBorder (border multiplier factor).
*
* SPI_SETBORDER: wParam is an integer which sets gpsi->gclBorder.
*                lParam is not used.
*
* SPI_GETKEYBOARDDELAY: wParam is not used. lParam is a long pointer to an int
*                which gets the current keyboard repeat delay setting.
*
* SPI_SETKEYBOARDDELAY: wParam is the new keyboard delay setting.
*                lParam is not used.
*
* SPI_GETKEYBOARDSPEED: wParam is not used.  lParam is a long pointer
*                to an int which gets the current keyboard repeat
*                speed setting.
*
* SPI_SETKEYBOARDSPEED: wParam is the new keyboard speed setting.
*                lParam is not used.
*
* SPI_KANJIMENU: wParam contains:
*                    1 - Mouse accelerator
*                    2 - ASCII accelerator
*                    3 - Kana accelerator
*                lParam is not used.  The wParam value is stored in the global
*                KanjiMenu for use in accelerator displaying & searching.
*
* SPI_LANGDRIVER: wParam is not used.
*                 lParam contains a LPSTR to the new language driver filename.
*
* SPI_ICONHORIZONTALSPACING: wParam is the width in pixels of an icon cell.
*
* SPI_ICONVERTICALSPACING: wParam is the height in pixels of an icon cell.
*
* SPI_GETSCREENSAVETIMEOUT: wParam is not used
*                lParam is a pointer to an int which gets the screen saver
*                timeout value.
*
* SPI_SETSCREENSAVETIMEOUT: wParam is the time in seconds for the system
*                to be idle before screensaving.
*
* SPI_GETSCREENSAVEACTIVE: lParam is a pointer to a BOOL which gets TRUE
*                if the screensaver is active else gets false.
*
* SPI_SETSCREENSAVEACTIVE: if wParam is TRUE, screensaving is activated
*                else it is deactivated.
*
*
* SPI_SETBLOCKSENDINPUTRESETS:
* SPI_GETBLOCKSENDINPUTRESETS:
*     wParam is BOOL signifying if this is active or not.
*
* SPI_GETLOWPOWERTIMEOUT:
* SPI_GETPOWEROFFTIMEOUT: wParam is not used
*                lParam is a pointer to an int which gets the appropriate
*                power saving screen blanker timeout value.
*
* SPI_SETLOWPOWERTIMEOUT:
* SPI_SETPOWEROFFTIMEOUT: wParam is the time in seconds for the system
*                to be idle before power saving screen blanking.
*
* SPI_GETLOWPOWERACTIVE:
* SPI_GETPOWEROFFACTIVE: lParam is a pointer to a BOOL which gets TRUE
*                if the power saving screen blanker is active else gets false.
*
* SPI_SETLOWPOWERACTIVE:
* SPI_SETPOWEROFFACTIVE: if wParam is TRUE, power saving screen blanking is
*                activated else it is deactivated.
*
* SPI_GETGRIDGRANULARITY: Obsolete. Returns 1 always.
*
* SPI_SETGRIDGRANULARITY: Obsolete.  Does nothing.
*
* SPI_SETDESKWALLPAPER: wParam is not used; lParam is a long ptr to a string
*                that holds the name of the bitmap file to be used as the
*                desktop wall paper.
*
* SPI_SETDESKPATTERN: Both wParam and lParam are not used; USER will read the
*                "pattern=" from WIN.INI and make it as the current desktop
*                 pattern;
*
* SPI_GETICONTITLEWRAP: lParam is LPINT which gets 0 if wrapping if off
*                       else gets 1.
*
* SPI_SETICONTITLEWRAP: wParam specifies TRUE to turn wrapping on else false
*
* SPI_GETMENUDROPALIGNMENT: lParam is LPINT which gets 0 specifies if menus
*                 drop left aligned else 1 if drop right aligned.
*
* SPI_SETMENUDROPALIGNMENT: wParam 0 specifies if menus drop left aligned else
*                 the drop right aligned.
*
* SPI_SETDOUBLECLKWIDTH: wParam specifies the width of the rectangle
*                 within which the second click of a double click must fall
*                 for it to be registered as a double click.
*
* SPI_SETDOUBLECLKHEIGHT: wParam specifies the height of the rectangle
*                 within which the second click of a double click must fall
*                 for it to be registered as a double click.
*
* SPI_GETICONTITLELOGFONT: lParam is a pointer to a LOGFONT struct which
*                 gets the logfont for the current icon title font. wParam
*                 specifies the size of the logfont struct.
*
* SPI_SETDOUBLECLICKTIME: wParm specifies the double click time
*
* SPI_SETMOUSEBUTTONSWAP: if wParam is 1, swap mouse buttons else if wParam
*                 is 0, don't swap buttons
* SPI_SETDRAGFULLWINDOWS: wParam = fSet.
* SPI_GETDRAGFULLWINDOWS: returns fSet.
*
* SPI_GETFILTERKEYS: lParam is a pointer to a FILTERKEYS struct.  wParam
*                 specifies the size of the filterkeys struct.
*
* SPI_SETFILTERKEYS: lParam is a pointer to a FILTERKEYS struct.  wParam
*                 is not used.
*
* SPI_GETSTICKYKEYS: lParam is a pointer to a STICKYKEYS struct.  wParam
*                 specifies the size of the stickykeys struct.
*
* SPI_SETSTICKYKEYS: lParam is a pointer to a STICKYKEYS struct.  wParam
*                 is not used.
*
* SPI_GETMOUSEKEYS: lParam is a pointer to a MOUSEKEYS struct.  wParam
*                 specifies the size of the mousekeys struct.
*
* SPI_SETMOUSEKEYS: lParam is a pointer to a MOUSEKEYS struct.  wParam
*                 is not used.
*
* SPI_GETACCESSTIMEOUT: lParam is a pointer to an ACCESSTIMEOUT struct.
*                 wParam specifies the size of the accesstimeout struct.
*
* SPI_SETACCESSTIMEOUT: lParam is a pointer to a ACCESSTIMEOUT struct.
*                 wParam is not used.
*
* SPI_GETTOGGLEKEYS: lParam is a pointer to a TOGGLEKEYS struct.  wParam
*                 specifies the size of the togglekeys struct.
*
* SPI_SETTOGGLEKEYS: lParam is a pointer to a TOGGLEKEYS struct.  wParam
*                 is not used.
*
* SPI_GETKEYBOARDPREF: lParam is a pointer to a BOOL.
*                 wParam is not used.
*
* SPI_SETKEYBOARDPREF: wParam is a BOOL.
*                 lParam is not used.
*
* SPI_GETSCREENREADER: lParam is a pointer to a BOOL.
*                 wParam is not used.
*
* SPI_SETSCREENREADER: wParam is a BOOL.
*                 lParam is not used.
*
* SPI_GETSHOWSOUNDS: lParam is a pointer to a SHOWSOUNDS struct.  wParam
*                 specifies the size of the showsounds struct.
*
* SPI_SETSHOWSOUNDS: lParam is a pointer to a SHOWSOUNDS struct.  wParam
*                 is not used.
*
* SPI_GETNONCLIENTMETRICS: lParam is a pointer to a NONCLIENTMETRICSW struct.
*                 wPAram is not used.
*
* SPI_GETSNAPTODEFBUTTON: lParam is a pointer to a BOOL which gets TRUE
*                if the snap to default push button is active else gets false.
*
* SPI_SETSNAPTODEFBUTTON: if wParam is TRUE, dialog boxes will snap the mouse
*                pointer to the default push button when created.
*
* SPI_GETFONTSMOOTHING:
*     wParam is unused
*     lParam is LPINT for boolean fFontSmoothing
*
* SPI_SETFONTSMOOTHING:
*     wParam is INT for boolean fFontSmoothing
*
* SPI_GETWHEELSCROLLLINES: lParam is a pointer to a ULONG to receive the
*                 suggested number of lines to scroll when the wheel is
*                 rotated. wParam is unused.
*
* SPI_SETWHEELSCROLLLINES: wParam is a ULONG containing the suggested number
*                 of lines to scroll when the wheel is rotated. lParam is
*                 unused.
*
* SPI_SETSCREENSAVERRUNNING / SPI_SCREENSAVERRUNNING: not supported on NT.
* SPI_GETSCREENSAVERRUNNING: wParam - Not used. lParam a pointer to a BOOL which
*                 will receive TRUE is a screen saver is running or FALSE otherwise.
*
* SPI_SETSHOWIMEUI wParam is TRUE or FALSE
* SPI_GETSHOWIMEUI neither wParam or lParam used
*
* History:
* 06-28-91      MikeHar     Ported.
* 12-8-93       SanfordS    Added SPI_SET/GETDRAGFULLWINDOWS
* 20-May-1996   adams       Added SPI_SET/GETWHEELSCROLLLINES
* 02-Feb-2002   MMcCr       Added SPI_SET/GETBLOCKSENDINPUTRESETS
\***************************************************************************/
BOOL xxxSystemParametersInfo(
    UINT wFlag,
    DWORD wParam,
    PVOID lParam,
    UINT flags)
{
    PPROCESSINFO         ppi = PpiCurrent();
    LPWSTR               pwszd = L"%d";
    WCHAR                szSection[40];
    WCHAR                szTemp[40];
    WCHAR                szPat[MAX_PATH];
    BOOL                 fWinIniChanged = FALSE;
    BOOL                 fAlterWinIni = ((flags & SPIF_UPDATEINIFILE) != 0);
    BOOL                 fSendWinIniChange = ((flags & SPIF_SENDCHANGE) != 0);
    BOOL                 fWriteAllowed = !fAlterWinIni;
    ACCESS_MASK          amRequest;
    LARGE_UNICODE_STRING strSection;
    int                  *piTimeOut;
    int                  iResID;
    TL tlName;
    PUNICODE_STRING pProfileUserName = NULL;

    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * CONSIDER(adams): Many of the SPI_GET* could be implemented
     * on the client side (SnapTo, WheelScrollLines, etc.).
     */

    /*
     * Features not implemented.
     */
    switch (wFlag) {
        case SPI_TIMEOUTS:
        case SPI_KANJIMENU:
        case SPI_LANGDRIVER:
        case SPI_UNUSED39:
        case SPI_UNUSED40:
        case SPI_SETPENWINDOWS:

        case SPI_GETWINDOWSEXTENSION:
        case SPI_SETSCREENSAVERRUNNING:     // same as SPI_SCREENSAVERRUNNING

        case SPI_GETSERIALKEYS:
        case SPI_SETSERIALKEYS:
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "SPI_ 0x%lx parameter not supported", wFlag);

            return FALSE;
    }


    /*
     * Perform access check. Always grant access to CSR.
     */
    if (ppi->Process != gpepCSRSS) {
        switch (wFlag) {
        case SPI_SETBEEP:
        case SPI_SETMOUSE:
        case SPI_SETBORDER:
        case SPI_SETKEYBOARDSPEED:
        case SPI_SETDEFAULTINPUTLANG:
        case SPI_SETSCREENSAVETIMEOUT:
        case SPI_SETSCREENSAVEACTIVE:
        case SPI_SETBLOCKSENDINPUTRESETS:
        case SPI_SETLOWPOWERTIMEOUT:
        case SPI_SETPOWEROFFTIMEOUT:
        case SPI_SETLOWPOWERACTIVE:
        case SPI_SETPOWEROFFACTIVE:
        case SPI_SETGRIDGRANULARITY:
        case SPI_SETDESKWALLPAPER:
        case SPI_SETDESKPATTERN:
        case SPI_SETKEYBOARDDELAY:
        case SPI_SETICONTITLEWRAP:
        case SPI_SETMENUDROPALIGNMENT:
        case SPI_SETDOUBLECLKWIDTH:
        case SPI_SETDOUBLECLKHEIGHT:
        case SPI_SETDOUBLECLICKTIME:
        case SPI_SETMOUSEBUTTONSWAP:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETFASTTASKSWITCH:
        case SPI_SETFILTERKEYS:
        case SPI_SETTOGGLEKEYS:
        case SPI_SETMOUSEKEYS:
        case SPI_SETSHOWSOUNDS:
        case SPI_SETSTICKYKEYS:
        case SPI_SETACCESSTIMEOUT:
        case SPI_SETSOUNDSENTRY:
        case SPI_SETKEYBOARDPREF:
        case SPI_SETSCREENREADER:
        case SPI_SETSNAPTODEFBUTTON:
        case SPI_SETANIMATION:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETICONMETRICS:
        case SPI_SETMINIMIZEDMETRICS:
        case SPI_SETWORKAREA:

        case SPI_SETFONTSMOOTHING:
        case SPI_SETMOUSEHOVERWIDTH:
        case SPI_SETMOUSEHOVERHEIGHT:
        case SPI_SETMOUSEHOVERTIME:
        case SPI_SETWHEELSCROLLLINES:
        case SPI_SETMENUSHOWDELAY:
        case SPI_SETHIGHCONTRAST:
        case SPI_SETDRAGFULLWINDOWS:
        case SPI_SETDRAGWIDTH:
        case SPI_SETDRAGHEIGHT:
        case SPI_SETCURSORS:
        case SPI_SETICONS:
        case SPI_SETLANGTOGGLE:
            amRequest = WINSTA_WRITEATTRIBUTES;
            break;

        case SPI_ICONHORIZONTALSPACING:
        case SPI_ICONVERTICALSPACING:
            if (IS_PTR(lParam)) {
                amRequest = WINSTA_READATTRIBUTES;
            } else if (wParam) {
                amRequest = WINSTA_WRITEATTRIBUTES;
            } else {
                return TRUE;
            }
            break;

        default:
            if ((wFlag & SPIF_RANGETYPEMASK) && (wFlag & SPIF_SET)) {
                amRequest = WINSTA_WRITEATTRIBUTES;
            } else {
                amRequest = WINSTA_READATTRIBUTES;
            }
            break;
        }

        if (amRequest == WINSTA_READATTRIBUTES) {
            RETURN_IF_ACCESS_DENIED(ppi->amwinsta, amRequest, FALSE);
        } else {
            UserAssert(amRequest == WINSTA_WRITEATTRIBUTES);
            if (!CheckWinstaWriteAttributesAccess()) {
                return FALSE;
            }
        }

        /*
         * If we're reading, then set the write flag to ensure that the
         * return value will be TRUE.
         */
        if (amRequest == WINSTA_READATTRIBUTES) {
            fWriteAllowed = TRUE;
        }
    } else {
        fWriteAllowed = TRUE;
    }

    /*
     * Make sure the section buffer is terminated.
     */
    szSection[0] = 0;

    switch (wFlag) {
    case SPI_GETBEEP:
        (*(BOOL *)lParam) = TEST_BOOL_PUDF(PUDF_BEEP);
        break;

    case SPI_SETBEEP:
        if (fAlterWinIni) {
            ServerLoadString(hModuleWin,
                             (wParam ? STR_BEEPYES : STR_BEEPNO),
                             (LPWSTR)szTemp,
                             10);

            fWinIniChanged = FastUpdateWinIni(NULL,
                                              PMAP_BEEP,
                                              STR_BEEP,
                                              szTemp);

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SET_OR_CLEAR_PUDF(PUDF_BEEP, wParam);
        }

        break;


    case SPI_SETMOUSESPEED:
        if (((LONG_PTR) lParam < MOUSE_SENSITIVITY_MIN) || ((LONG_PTR) lParam > MOUSE_SENSITIVITY_MAX)) {
            return FALSE;
        }

        if (fAlterWinIni) {
            swprintf(szTemp, pwszd, lParam);
            fWinIniChanged = FastUpdateWinIni(NULL,
                                              PMAP_MOUSE,
                                              STR_MOUSESENSITIVITY,
                                              szTemp);

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            gMouseSensitivity = PtrToLong(lParam);
            gMouseSensitivityFactor = CalculateMouseSensitivity(PtrToLong(lParam));

#ifdef SUBPIXEL_MOUSE
            ResetMouseAccelerationCurves();
#endif // SUBPIXEL_MOUSE
        }
        break;

    case SPI_GETMOUSESPEED:
        *((LPINT)lParam) = gMouseSensitivity;
        break;

    case SPI_SETMOUSETRAILS:
        if (fAlterWinIni) {
            swprintf(szTemp, pwszd, wParam);
            fWinIniChanged = FastUpdateWinIni(NULL,
                                              PMAP_MOUSE,
                                              STR_MOUSETRAILS,
                                              szTemp);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SetMouseTrails(wParam);
        }
        break;

    case SPI_GETMOUSETRAILS:
        *((LPINT)lParam) = gMouseTrails ? gMouseTrails + 1 : gMouseTrails;
        break;

    case SPI_GETMOUSE:
        ((LPINT)lParam)[0] = gMouseThresh1;
        ((LPINT)lParam)[1] = gMouseThresh2;
        ((LPINT)lParam)[2] = gMouseSpeed;
        break;

    case SPI_SETMOUSE:
        if (fAlterWinIni) {
            BOOL bWritten1, bWritten2, bWritten3;

            pProfileUserName = CreateProfileUserName(&tlName);
            bWritten1 = UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH1, ((LPINT)lParam)[0]);
            bWritten2 = UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH2, ((LPINT)lParam)[1]);
            bWritten3 = UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSESPEED,   ((LPINT)lParam)[2]);
            if (bWritten1 && bWritten2 && bWritten3) {
                fWinIniChanged = TRUE;
            } else {
                /*
                 * Attempt to backout any changes.
                 */
                if (bWritten1) {
                    UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH1, gMouseThresh1);
                }
                if (bWritten2) {
                    UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH2, gMouseThresh2);
                }
                if (bWritten3) {
                    UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSESPEED,   gMouseSpeed);
                }
            }
            fWriteAllowed = fWinIniChanged;
            FreeProfileUserName(pProfileUserName, &tlName);
        }

        if (fWriteAllowed) {
            gMouseThresh1 = ((LPINT)lParam)[0];
            gMouseThresh2 = ((LPINT)lParam)[1];
            gMouseSpeed = ((LPINT)lParam)[2];
        }
        break;

    case SPI_GETSNAPTODEFBUTTON:
        (*(LPBOOL)lParam) = TEST_BOOL_PUSIF(PUSIF_SNAPTO);
        break;

    case SPI_SETSNAPTODEFBUTTON:
        wParam = (wParam != 0);

        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_SNAPTO, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SET_OR_CLEAR_PUSIF(PUSIF_SNAPTO, wParam);
        }

        break;

    case SPI_GETBORDER:
        (*(LPINT)lParam) = gpsi->gclBorder;
        break;

    case SPI_SETBORDER:
        wParam = max((int)wParam, 1);
        wParam = min(wParam, 50);

        if (wParam == gpsi->gclBorder) {
            /*
             * If border size doesn't change, don't waste time.
             */
            break;
        }

        pProfileUserName = CreateProfileUserName(&tlName);

        if (fAlterWinIni) {
            fWinIniChanged = SetWindowMetricInt(pProfileUserName, STR_BORDERWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            xxxSetAndDrawNCMetrics(pProfileUserName, wParam, NULL);

            /*
             * Nice magic number of 3. So if the border is set to 1, there
             * are actualy 4 pixels in the border.
             */
            bSetDevDragWidth(gpDispInfo->hDev, gpsi->gclBorder + BORDER_EXTRA);
        }

        FreeProfileUserName(pProfileUserName, &tlName);
        break;

    case SPI_GETFONTSMOOTHING:
        (*(LPINT)lParam) = !!(GreGetFontEnumeration() & FE_AA_ON);
        break;

    case SPI_SETFONTSMOOTHING:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_FONTSMOOTHING)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }

        wParam = (wParam ? FE_AA_ON : 0);
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, STR_FONTSMOOTHING, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            GreSetFontEnumeration(wParam | FE_SET_AA);
        }
        break;

    case SPI_GETKEYBOARDSPEED:
        (*(int *)lParam) = (gnKeyboardSpeed & KSPEED_MASK);
        break;

    case SPI_SETKEYBOARDSPEED:
        /*
         * Limit the range to max value; SetKeyboardRate takes both speed
         * and delay.
         */
        if (wParam > KSPEED_MASK) {           // KSPEED_MASK == KSPEED_MAX
            wParam = KSPEED_MASK;
        }

        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_KEYBOARD, STR_KEYSPEED, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            gnKeyboardSpeed = (gnKeyboardSpeed & ~KSPEED_MASK) | wParam;
            SetKeyboardRate(gnKeyboardSpeed);
        }
        break;

    case SPI_GETKEYBOARDDELAY:
        (*(int *)lParam) = (gnKeyboardSpeed & KDELAY_MASK) >> KDELAY_SHIFT;
        break;

    case SPI_SETKEYBOARDDELAY:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_KEYBOARD, STR_KEYDELAY, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gnKeyboardSpeed = (gnKeyboardSpeed & ~KDELAY_MASK) | (wParam << KDELAY_SHIFT);
            SetKeyboardRate(gnKeyboardSpeed);
        }
        break;

    case SPI_SETLANGTOGGLE:

        /*
         * wParam unused, lParam unused. Simply reread the registry setting.
         */
        return GetKbdLangSwitch(NULL);

        break;

    case SPI_GETDEFAULTINPUTLANG:
        /*
         * wParam unused. lParam is a pointer to buffer to store hkl.
         */
        UserAssert(gspklBaseLayout != NULL);
        (*(HKL *)lParam) = gspklBaseLayout->hkl;
        break;

    case SPI_SETDEFAULTINPUTLANG: {
        PKL pkl;
        /*
         * wParam unused. lParam is new language of hkl (depending on
         * whether the hiword is set).
         */
        pkl = HKLtoPKL(PtiCurrent(), *(HKL *)lParam);
        if (pkl == NULL) {
            return FALSE;
        }
        if (fWriteAllowed) {
            Lock(&gspklBaseLayout, pkl);
        }
        break;
    }

    case SPI_ICONHORIZONTALSPACING:
        if (IS_PTR(lParam)) {
            *(LPINT)lParam = SYSMET(CXICONSPACING);
        } else if (wParam) {

            /*
             * Make sure icon spacing is reasonable.
             */
            wParam = max(wParam, (DWORD)SYSMET(CXICON));

            if (fAlterWinIni) {
                fWinIniChanged = SetWindowMetricInt(NULL, STR_ICONHORZSPACING, wParam );
                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {
                SYSMET(CXICONSPACING) = (UINT)wParam;
            }
        }
        break;

    case SPI_ICONVERTICALSPACING:
        if (IS_PTR(lParam)) {
            *(LPINT)lParam = SYSMET(CYICONSPACING);
        } else if (wParam) {
            wParam = max(wParam, (DWORD)SYSMET(CYICON));

            if (fAlterWinIni) {
                fWinIniChanged = SetWindowMetricInt(NULL, STR_ICONVERTSPACING, wParam);
                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {
                SYSMET(CYICONSPACING) = (UINT)wParam;
            }
        }
        break;

    case SPI_GETSCREENSAVETIMEOUT:
        piTimeOut = &giScreenSaveTimeOutMs;
        goto HandleGetTimeouts;

    case SPI_GETLOWPOWERTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        piTimeOut = &giLowPowerTimeOutMs;
        goto HandleGetTimeouts;

    case SPI_GETPOWEROFFTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        piTimeOut = &giPowerOffTimeOutMs;

HandleGetTimeouts:
        /*
         * If the screen saver is disabled, store this fact as a negative
         * time out value (we give the Control Panel the absolute value
         * of the screen saver time out). We store this in milliseconds.
         */
        if (*piTimeOut < 0) {
            (*(int *)lParam) = -*piTimeOut / 1000;
        } else {
            (*(int *)lParam) = *piTimeOut / 1000;
        }
        break;

    case SPI_SETSCREENSAVETIMEOUT:
        piTimeOut = &giScreenSaveTimeOutMs;
        iResID = STR_SCREENSAVETIMEOUT;
        goto HandleSetTimeouts;

    case SPI_SETLOWPOWERTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        piTimeOut = &giLowPowerTimeOutMs;
        iResID = STR_LOWPOWERTIMEOUT;
        goto HandleSetTimeouts;

    case SPI_SETPOWEROFFTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        piTimeOut = &giPowerOffTimeOutMs;
        iResID = STR_POWEROFFTIMEOUT;

HandleSetTimeouts:
        if (gfSwitchInProgress) {
            return FALSE;
        }

        /*
         * Maintain the screen save active/inactive state when setting the
         * time out value. Timeout value is given in seconds but stored
         * in milliseconds
         */
        if (CheckDesktopPolicy(NULL, (PCWSTR)IntToPtr(iResID))) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, iResID, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
                // Call video driver here to exit power down mode.
                // KdPrint(("Exit video power down mode\n"));
                DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
            }
            glinp.dwFlags &= ~LINP_INPUTTIMEOUTS;
            if (!gbBlockSendInputResets) {
                glinp.timeLastInputMessage = NtGetTickCount();
            }

            if (*piTimeOut < 0) {
                *piTimeOut = -((int)wParam);
            } else {
                *piTimeOut = wParam;
            }
            *piTimeOut *= 1000;
        }
        break;

    case SPI_GETBLOCKSENDINPUTRESETS:
        (*(BOOL *)lParam) = (gbBlockSendInputResets != 0);
        break;

    case SPI_GETSCREENSAVEACTIVE:
        (*(BOOL *)lParam) = (giScreenSaveTimeOutMs > 0);
        break;

    case SPI_GETLOWPOWERACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        (*(BOOL *)lParam) = (giLowPowerTimeOutMs > 0);
        break;

    case SPI_GETPOWEROFFACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        (*(BOOL *)lParam) = (giPowerOffTimeOutMs > 0);
        break;

    case SPI_SETSCREENSAVEACTIVE:
        piTimeOut = &giScreenSaveTimeOutMs;
        iResID = STR_SCREENSAVEACTIVE;
        goto HandleSetActive;

    case SPI_SETLOWPOWERACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        piTimeOut = &giLowPowerTimeOutMs;
        iResID = STR_LOWPOWERACTIVE;
        goto HandleSetActive;

    case SPI_SETPOWEROFFACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        piTimeOut = &giPowerOffTimeOutMs;
        iResID = STR_POWEROFFACTIVE;

HandleSetActive:
        if (gfSwitchInProgress) {
            return FALSE;
        }

        wParam = (wParam != 0);

        if (CheckDesktopPolicy(NULL, (PCWSTR)IntToPtr(iResID))) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, iResID, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
                // Call video driver here to exit power down mode.
                // KdPrint(("Exit video power down mode\n"));
                DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
            }
            glinp.dwFlags &= ~LINP_INPUTTIMEOUTS;

            if (!gbBlockSendInputResets) {
                glinp.timeLastInputMessage = NtGetTickCount();
            }

            if ((*piTimeOut < 0 && wParam) ||
                (*piTimeOut >= 0 && !wParam)) {
                *piTimeOut = -*piTimeOut;
            }
        }
        break;

    case SPI_SETBLOCKSENDINPUTRESETS:
            wParam = (wParam != 0);
            if (CheckDesktopPolicy(NULL, (PCWSTR)IntToPtr(STR_BLOCKSENDINPUTRESETS))) {
                fAlterWinIni = FALSE;
                fWriteAllowed = FALSE;
            }
            if (fAlterWinIni) {
                fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, STR_BLOCKSENDINPUTRESETS, wParam);
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                gbBlockSendInputResets = wParam;
            }
            break;

    case SPI_SETDESKWALLPAPER:
        pProfileUserName = CreateProfileUserName(&tlName);
        if (CheckDesktopPolicy(pProfileUserName, (PCWSTR)STR_DTBITMAP)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }

        if (fAlterWinIni) {
            if (wParam != (WPARAM)-1) {
                /*
                 * Save current wallpaper in case of failure.
                 *
                 * Unlike the rest of the per-user settings that got updated
                 * in xxxUpdatePerUserSystemParameters, the wallpaper is
                 * being updated via a direct call to SystemParametersInfo
                 * from UpdatePerUserSystemParameters. Force remote settings
                 * check in this case.
                 */
                FastGetProfileStringFromIDW(pProfileUserName,
                                            PMAP_DESKTOP,
                                            STR_DTBITMAP,
                                            TEXT(""),
                                            szPat,
                                            ARRAY_SIZE(szPat),
                                            POLICY_REMOTE);

                fWinIniChanged = FastUpdateWinIni(pProfileUserName,
                                                  PMAP_DESKTOP,
                                                  STR_DTBITMAP,
                                                  (LPWSTR)lParam);

                fWriteAllowed = fWinIniChanged;
            } else {
                fWriteAllowed = TRUE;
            }
        }

        if (fWriteAllowed) {
            if (xxxSetDeskWallpaper(pProfileUserName,(LPWSTR)lParam)) {
                if (grpdeskRitInput) {
                    xxxInternalInvalidate(grpdeskRitInput->pDeskInfo->spwnd,
                                          HRGN_FULL,
                                          RDW_INVALIDATE |
                                              RDW_ERASE |
                                              RDW_FRAME |
                                              RDW_ALLCHILDREN);
                }
            } else if (fAlterWinIni && (wParam != 0xFFFFFFFF)) {
                /*
                 * Backout any change to win.ini.
                 */
                FastUpdateWinIni(pProfileUserName,PMAP_DESKTOP, STR_DTBITMAP, szPat);
                fWinIniChanged = FALSE;
                fWriteAllowed = fWinIniChanged;
            } else if (!fAlterWinIni) {
                /*
                 * Bug 304109 - joejo
                 * Make sure we return a 0 retval if we didn't do anything!
                 */
                fWinIniChanged = FALSE;
                fWriteAllowed = fWinIniChanged;
            }
        }
        FreeProfileUserName(pProfileUserName, &tlName);
        break;

    case SPI_GETDESKWALLPAPER:
        /*
         * Get the string from the gobal var, not the registry, as it's
         * more current.
         */
        if (gpszWall != NULL) {
            /*
             * Copy the global wallpaper name ONLY if noni-null.
             */
            wcscpy(lParam, gpszWall);
        } else {
            /*
             * Null out the string so no garbage can corrupt the user's
             * buffer.
             */
            (*(LPWSTR)lParam) = (WCHAR)0;
        }
        break;

    case SPI_SETDESKPATTERN: {
            BOOL fRet;

            if (wParam == -1 && lParam != 0) {
                return FALSE;
            }

            pProfileUserName = CreateProfileUserName(&tlName);
            if (CheckDesktopPolicy(pProfileUserName, (PCWSTR)STR_DESKPATTERN)) {
                fAlterWinIni = FALSE;
                fWriteAllowed = FALSE;
            }

            if (fAlterWinIni && wParam != -1) {
                /*
                 * Save the current pattern in case of failure.
                 */
                FastGetProfileStringFromIDW(pProfileUserName,
                                            PMAP_DESKTOP,
                                            STR_DESKPATTERN,
                                            TEXT(""),
                                            szPat,
                                            ARRAY_SIZE(szPat),
                                            0);

                fWinIniChanged = FastUpdateWinIni(pProfileUserName,
                                                  PMAP_DESKTOP,
                                                  STR_DESKPATTERN,
                                                  (LPWSTR)lParam);

                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {
                fRet = xxxSetDeskPattern(pProfileUserName,
                                         wParam == -1 ? (LPWSTR)-1 : (LPWSTR)lParam,
                                         FALSE);

                if (!fRet) {
                    /*
                     * Back out any change to win.ini.
                     */
                    if (fAlterWinIni && wParam != -1) {
                        FastUpdateWinIni(pProfileUserName,
                                         PMAP_DESKTOP,
                                         STR_DESKPATTERN,
                                         szPat);
                    }

                    FreeProfileUserName(pProfileUserName, &tlName);
                    return FALSE;
                }
            }
        }
        FreeProfileUserName(pProfileUserName, &tlName);
        break;

    case SPI_GETICONTITLEWRAP:
        *((int *)lParam) = TEST_BOOL_PUDF(PUDF_ICONTITLEWRAP);
        break;

    case SPI_SETICONTITLEWRAP:
        wParam = (wParam != 0);
        if (fAlterWinIni) {
            fWinIniChanged = SetWindowMetricInt(NULL, STR_ICONTITLEWRAP, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SET_OR_CLEAR_PUDF(PUDF_ICONTITLEWRAP, wParam);
            xxxMetricsRecalc(CALC_FRAME, 0, 0, 0, 0);
        }
        break;

    case SPI_SETDRAGWIDTH:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_DRAGWIDTH)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_DRAGWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CXDRAG) = wParam;
        }
        break;

    case SPI_SETDRAGHEIGHT:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_DRAGHEIGHT)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_DRAGHEIGHT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CYDRAG) = wParam;
        }
        break;

    case SPI_GETMENUDROPALIGNMENT:
        (*(int *)lParam) = (SYSMET(MENUDROPALIGNMENT));
        break;

    case SPI_SETMENUDROPALIGNMENT:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_WINDOWSU, STR_MENUDROPALIGNMENT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(MENUDROPALIGNMENT) = (BOOL)(wParam != 0);
        }
        break;

    case SPI_SETDOUBLECLKWIDTH:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_DOUBLECLICKWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CXDOUBLECLK) = wParam;
        }
        break;

    case SPI_SETDOUBLECLKHEIGHT:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_DOUBLECLICKHEIGHT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CYDOUBLECLK) = wParam;
        }
        break;

    case SPI_GETICONTITLELOGFONT:
        GreExtGetObjectW(ghIconFont, sizeof(LOGFONTW), lParam);
        break;

    case SPI_SETICONTITLELOGFONT:
    {
        if (lParam != NULL) {
            if (wParam != sizeof(LOGFONTW)) {
                return FALSE;
            }
        } else if (wParam) {
            return FALSE;
        }

        pProfileUserName = CreateProfileUserName(&tlName);
        fWinIniChanged = xxxSetSPIMetrics(pProfileUserName, wFlag, lParam, fAlterWinIni);
        FreeProfileUserName(pProfileUserName, &tlName);
        if (fAlterWinIni) {
            fWriteAllowed = fWinIniChanged;
        }
        break;
    }

    case SPI_SETDOUBLECLICKTIME:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_MOUSE, STR_DBLCLKSPEED, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            _SetDoubleClickTime((UINT)wParam);
        }
        break;

    case SPI_GETANIMATION: {
        LPANIMATIONINFO lpai = (LPANIMATIONINFO) lParam;

        if (lpai == NULL || wParam != sizeof(ANIMATIONINFO)) {
            return FALSE;
        }

        lpai->cbSize        = sizeof(ANIMATIONINFO);
        lpai->iMinAnimate   = TEST_BOOL_PUDF(PUDF_ANIMATE);

        break;
    }

    case SPI_GETNONCLIENTMETRICS: {
        LPNONCLIENTMETRICS lpnc = (LPNONCLIENTMETRICS) lParam;
        if (lpnc == NULL) {
            return FALSE;
        }

        GetWindowNCMetrics(lpnc);
        break;
    }

    case SPI_GETMINIMIZEDMETRICS: {
        LPMINIMIZEDMETRICS lpmin = (LPMINIMIZEDMETRICS)lParam;

        lpmin->cbSize    = sizeof(MINIMIZEDMETRICS);

        lpmin->iWidth    = SYSMET(CXMINIMIZED) - 2 * SYSMET(CXFIXEDFRAME);
        lpmin->iHorzGap  = SYSMET(CXMINSPACING) - SYSMET(CXMINIMIZED);
        lpmin->iVertGap  = SYSMET(CYMINSPACING) - SYSMET(CYMINIMIZED);
        lpmin->iArrange  = SYSMET(ARRANGE);

        break;
    }

    case SPI_GETICONMETRICS: {
        LPICONMETRICS lpicon = (LPICONMETRICS)lParam;

        lpicon->cbSize          = sizeof(ICONMETRICS);

        lpicon->iHorzSpacing    = SYSMET(CXICONSPACING);
        lpicon->iVertSpacing    = SYSMET(CYICONSPACING);
        lpicon->iTitleWrap      = TEST_BOOL_PUDF(PUDF_ICONTITLEWRAP);
        GreExtGetObjectW(ghIconFont, sizeof(LOGFONTW), &(lpicon->lfFont));

        break;
    }

    case SPI_SETANIMATION:
    case SPI_SETNONCLIENTMETRICS:
    case SPI_SETICONMETRICS:
    case SPI_SETMINIMIZEDMETRICS:
    {
        fWinIniChanged = xxxSetSPIMetrics(NULL, wFlag, lParam, fAlterWinIni);
        if (fAlterWinIni) {
            fWriteAllowed = fWinIniChanged;
        }
        ServerLoadString(hModuleWin, STR_METRICS, szSection, ARRAY_SIZE(szSection));
        break;
    }
    case SPI_SETMOUSEBUTTONSWAP:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_SWAPBUTTONS, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            _SwapMouseButton((wParam != 0));
        }
        break;

    case SPI_GETFASTTASKSWITCH:
        *((PINT)lParam) = TRUE;    // Do the work so we don't anger anybody.

    case SPI_SETFASTTASKSWITCH:
        RIPMSG0(RIP_WARNING,"SPI_SETFASTTASKSWITCH and SPI_GETFASTTASKSWITCH are obsolete actions.");
        break;

    case SPI_GETWORKAREA:
        CopyRect((LPRECT)lParam, &GetPrimaryMonitor()->rcWork);
        break;

    case SPI_SETWORKAREA:
    {
        RECT        rcNewWork;
        LPRECT      lprcNewWork;
        PMONITOR    pMonitorWork;

        lprcNewWork = (LPRECT)lParam;

        /*
         * Validate Rectangle.
         */
        if (lprcNewWork != NULL &&
            (lprcNewWork->right < lprcNewWork->left ||
                lprcNewWork->bottom < lprcNewWork->top)) {

            RIPMSG0(RIP_WARNING, "Bad work rectangle passed to SystemParametersInfo(SPI_SETWORKAREA, ...)\n");
            return FALSE;
        }

        /*
         * Figure out which monitor has the working area.
         */
        if (!lprcNewWork) {
            pMonitorWork = GetPrimaryMonitor();
            lprcNewWork = &pMonitorWork->rcMonitor;
        } else {
            pMonitorWork = _MonitorFromRect(lprcNewWork, MONITOR_DEFAULTTOPRIMARY);
        }


        /*
         * Get new working area, clipped to monitor of course.
         */
        if (!IntersectRect(&rcNewWork, lprcNewWork, &pMonitorWork->rcMonitor) ||
            !EqualRect(&rcNewWork, lprcNewWork))
        {
            /*
             * Complain.
             */
            RIPERR4(
                    ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Bad work rectangle passed to SystemParametersInfo(SPI_SETWORKAREA, ...) %d, %d, %d, %d",
                    lprcNewWork->left, lprcNewWork->top, lprcNewWork->right, lprcNewWork->bottom);
            return FALSE;
        }

        if (!EqualRect(&pMonitorWork->rcWork, &rcNewWork)) {
            PMONITORRECTS   pmr;

            /*
             * If we are going to reposition windows, remember the old
             * monitor positions for xxxDesktopRecalc.
             */
            if (wParam) {
                pmr = SnapshotMonitorRects();
                if (!pmr) {
                    return FALSE;
                }
            }

            pMonitorWork->rcWork = rcNewWork;
            if (pMonitorWork == GetPrimaryMonitor()) {
                SetDesktopMetrics();
            }

            /*
             * Reposition windows.
             */
            if (wParam) {
                TL tlPool;

                ThreadLockPool(PtiCurrent(), pmr, &tlPool);
                xxxDesktopRecalc(pmr);
                ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
            }

            fWinIniChanged = TRUE;
        }

        fWriteAllowed = TRUE;
        break;
    }

    case SPI_SETDRAGFULLWINDOWS:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_DRAGFULLWINDOWS)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        wParam = (wParam == 1);
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_DRAGFULLWINDOWS, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SET_OR_CLEAR_PUDF(PUDF_DRAGFULLWINDOWS, wParam);
        }
        break;

    case SPI_GETDRAGFULLWINDOWS:
        *((PINT)lParam) = TEST_BOOL_PUDF(PUDF_DRAGFULLWINDOWS);
        break;

    case SPI_GETFILTERKEYS:
        {
            LPFILTERKEYS pFK = (LPFILTERKEYS)lParam;
            int cbSkip = sizeof(gFilterKeys.cbSize);

            if (wParam != 0 && wParam != sizeof(FILTERKEYS)) {
                return FALSE;
            }

            if (!pFK || pFK->cbSize != sizeof(FILTERKEYS)) {
                return FALSE;
            }

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pFK + cbSkip),
                          (LPVOID)((LPBYTE)&gFilterKeys + cbSkip),
                          pFK->cbSize - cbSkip);
        }
        break;

    case SPI_SETFILTERKEYS:
        {
            LPFILTERKEYS pFK = (LPFILTERKEYS)lParam;

            if (wParam != 0 && wParam != sizeof(FILTERKEYS)) {
                return FALSE;
            }

            if (!pFK || pFK->cbSize != sizeof(FILTERKEYS)) {
                return FALSE;
            }

            /*
             * SlowKeys and BounceKeys cannot both be active simultaneously
             */
            if (pFK->iWaitMSec && pFK->iBounceMSec) {
                return FALSE;
            }

            /*
             * Do some parameter validation. We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pFK->dwFlags & FKF_VALID) != pFK->dwFlags) {
                return FALSE;
            }

            /*
             * FKF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(FilterKeys, FKF_AVAILABLE)) {
                pFK->dwFlags |= FKF_AVAILABLE;
            } else {
                pFK->dwFlags &= ~FKF_AVAILABLE;
            }

            if (pFK->iWaitMSec > 20000   ||
                pFK->iDelayMSec > 20000  ||
                pFK->iRepeatMSec > 20000 ||
                pFK->iBounceMSec > 20000) {
                return FALSE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                fWinIniChanged = SetFilterKeys(pProfileUserName, pFK);
                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {
                    /*
                     * Back out any changes to win.ini.
                     */
                    SetFilterKeys(pProfileUserName, &gFilterKeys);
                }

                FreeProfileUserName(pProfileUserName, &tlName);
            }

            if (fWriteAllowed) {
                RtlCopyMemory(&gFilterKeys, pFK, pFK->cbSize);

                /*
                 * Don't allow user to change cbSize field.
                 */
                gFilterKeys.cbSize = sizeof(FILTERKEYS);

                if (!TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)) {
                    StopFilterKeysTimers();
                }
                SetAccessEnabledFlag();
                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_ACCESSIBILITYSTATE,
                                ACCESS_FILTERKEYS,
                                0,
                                WH_SHELL);
                }
                PostShellHookMessages(HSHELL_ACCESSIBILITYSTATE, ACCESS_FILTERKEYS);
            }
        }
        break;

    case SPI_GETSTICKYKEYS:
        {
            LPSTICKYKEYS pSK = (LPSTICKYKEYS)lParam;
            int cbSkip = sizeof(gStickyKeys.cbSize);

            if (wParam != 0 && wParam != sizeof(STICKYKEYS)) {
                return FALSE;
            }

            if (!pSK || pSK->cbSize != sizeof(STICKYKEYS)) {
                return FALSE;
            }

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pSK + cbSkip),
                          (LPVOID)((LPBYTE)&gStickyKeys + cbSkip),
                          pSK->cbSize - cbSkip);

            pSK->dwFlags &= ~SKF_STATEINFO;
            pSK->dwFlags |= (gLatchBits&0xff) <<24;

#if SKF_LALTLATCHED != 0x10000000
#error SKF_LALTLATCHED value is incorrect
#endif
#if SKF_LCTLLATCHED != 0x04000000
#error SKF_LCTLLATCHED value is incorrect
#endif
#if SKF_LSHIFTLATCHED != 0x01000000
#error SKF_LSHIFTLATCHED value is incorrect
#endif
#if SKF_RALTLATCHED  !=  0x20000000
#error SKF_RALTLATCHED value is incorrect
#endif
#if  SKF_RCTLLATCHED != 0x08000000
#error SKF_RCTLLATCHED value is incorrect
#endif
#if SKF_RSHIFTLATCHED != 0x02000000
#error SKF_RSHIFTLATCHED value is incorrect
#endif
            pSK->dwFlags |= (gLockBits&0xff) <<16;
#if SKF_LALTLOCKED != 0x00100000
#error SKF_LALTLOCKED value is incorrect
#endif
#if SKF_LCTLLOCKED != 0x00040000
#error SKF_LCTLLOCKED value is incorrect
#endif
#if SKF_LSHIFTLOCKED != 0x00010000
#error SKF_LSHIFTLOCKED value is incorrect
#endif
#if SKF_RALTLOCKED  != 0x00200000
#error SKF_RALTLOCKED value is incorrect
#endif
#if SKF_RCTLLOCKED != 0x00080000
#error SKF_RCTLLOCKED value is incorrect
#endif
#if SKF_RSHIFTLOCKED != 0x00020000
#error SKF_RSHIFTLOCKED value is incorrect
#endif

        }

        break;

    case SPI_SETSTICKYKEYS:
        {
            LPSTICKYKEYS pSK = (LPSTICKYKEYS)lParam;
            BOOL fWasOn;

            fWasOn = TEST_BOOL_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
            if (wParam != 0 && wParam != sizeof(STICKYKEYS)) {
                return FALSE;
            }

            if (!pSK || pSK->cbSize != sizeof(STICKYKEYS)) {
                return FALSE;
            }

            /*
             * Do some parameter validation. We will fail on unsupported and
             * undefined bits being set.
             *
             * Don't penalize them for using data from SPI_GETSTICKYKEYS,
             * though.
             */
            pSK->dwFlags &= ~SKF_STATEINFO;
            if ((pSK->dwFlags & SKF_VALID) != pSK->dwFlags) {
                return FALSE;
            }

            /*
             * SKF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(StickyKeys, SKF_AVAILABLE)) {
                pSK->dwFlags |= SKF_AVAILABLE;
            } else {
                pSK->dwFlags &= ~SKF_AVAILABLE;
            }

            if (fAlterWinIni) {
                swprintf(szTemp, pwszd, pSK->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(NULL,
                                                         PMAP_STICKYKEYS,
                                                         L"Flags",
                                                         szTemp);
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gStickyKeys, pSK, pSK->cbSize);

                /*
                 * Don't allow user to change cbSize field.
                 */
                gStickyKeys.cbSize = sizeof(STICKYKEYS);
                if (!TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) && fWasOn) {
                    xxxTurnOffStickyKeys();
                }

                SetAccessEnabledFlag();
                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_ACCESSIBILITYSTATE,
                                ACCESS_STICKYKEYS,
                                0,
                                WH_SHELL);
                }
                PostShellHookMessages(HSHELL_ACCESSIBILITYSTATE, ACCESS_STICKYKEYS);
            }
        }
        break;

    case SPI_GETTOGGLEKEYS:
        {
            LPTOGGLEKEYS pTK = (LPTOGGLEKEYS)lParam;
            int cbSkip = sizeof(gToggleKeys.cbSize);

            if (wParam != 0 && wParam != sizeof(TOGGLEKEYS)) {
                return FALSE;
            }

            if (!pTK || pTK->cbSize != sizeof(TOGGLEKEYS)) {
                return FALSE;
            }

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pTK + cbSkip),
                          (LPVOID)((LPBYTE)&gToggleKeys + cbSkip),
                          pTK->cbSize - cbSkip);
        }
        break;

    case SPI_SETTOGGLEKEYS:
        {
            LPTOGGLEKEYS pTK = (LPTOGGLEKEYS)lParam;

            if (wParam != 0 && wParam != sizeof(TOGGLEKEYS)) {
                return FALSE;
            }

            if (!pTK || pTK->cbSize != sizeof(TOGGLEKEYS)) {
                return FALSE;
            }

            /*
             * Do some parameter validation. We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pTK->dwFlags & TKF_VALID) != pTK->dwFlags) {
                return FALSE;
            }

            /*
             * TKF_AVAILABLE can't be set via API. Use registry value.
             */
            if (TEST_ACCESSFLAG(ToggleKeys, TKF_AVAILABLE)) {
                pTK->dwFlags |= TKF_AVAILABLE;
            } else {
                pTK->dwFlags &= ~TKF_AVAILABLE;
            }

            if (fAlterWinIni) {
                swprintf(szTemp, pwszd, pTK->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(NULL,
                                                         PMAP_TOGGLEKEYS,
                                                         L"Flags",
                                                         szTemp);
                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {
                RtlCopyMemory(&gToggleKeys, pTK, pTK->cbSize);

                /*
                 * Don't allow user to change cbSize field.
                 */
                gToggleKeys.cbSize = sizeof(TOGGLEKEYS);

                SetAccessEnabledFlag();
            }
        }
        break;

    case SPI_GETMOUSEKEYS:
        {
            LPMOUSEKEYS pMK = (LPMOUSEKEYS)lParam;
            int cbSkip = sizeof(gMouseKeys.cbSize);

            if (wParam != 0 && wParam != sizeof(MOUSEKEYS)) {
                return FALSE;
            }

            if (!pMK || pMK->cbSize != sizeof(MOUSEKEYS)) {
                return FALSE;
            }

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pMK + cbSkip),
                          (LPVOID)((LPBYTE)&gMouseKeys + cbSkip),
                          pMK->cbSize - cbSkip);


            pMK->dwFlags &= ~MKF_STATEINFO;
            if (gbMKMouseMode) {
                pMK->dwFlags |= MKF_MOUSEMODE;
            }

            pMK->dwFlags |= (gwMKButtonState & 3) << 24;
#if MOUSE_BUTTON_LEFT != 0x01
#error MOUSE_BUTTON_LEFT value is incorrect
#endif
#if MOUSE_BUTTON_RIGHT != 0x02
#error MOUSE_BUTTON_RIGHT value is incorrect
#endif
#if MKF_LEFTBUTTONDOWN != 0x01000000
#error MKF_LEFTBUTTONDOWN value is incorrect
#endif
#if MKF_RIGHTBUTTONDOWN != 0x02000000
#error MKF_RIGHTBUTTONDOWN value is incorrect
#endif

            pMK->dwFlags |= (gwMKCurrentButton & 3)<< 28;
#if MKF_LEFTBUTTONSEL != 0x10000000
#error MKF_LEFTBUTTONSEL value is incorrect
#endif
#if MKF_RIGHTBUTTONSEL != 0x20000000
#error MKF_RIGHTBUTTONSEL value is incorrect
#endif
        }
        break;

    case SPI_SETMOUSEKEYS:
        {
            LPMOUSEKEYS pMK = (LPMOUSEKEYS)lParam;

            if (wParam != 0 && wParam != sizeof(MOUSEKEYS)) {
                return FALSE;
            }

            if (!pMK || pMK->cbSize != sizeof(MOUSEKEYS)) {
                return FALSE;
            }

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             *
             * Don't penalize them for using data from SPI_GETMOUSEKEYS.
             */
            pMK->dwFlags &= ~MKF_STATEINFO;
            if ((pMK->dwFlags & MKF_VALID) != pMK->dwFlags) {
                return FALSE;
            }

            /*
             * MKF_AVAILABLE can't be set via API. Use registry value.
             */
            if (TEST_ACCESSFLAG(MouseKeys, MKF_AVAILABLE)) {
                pMK->dwFlags |= MKF_AVAILABLE;
            } else {
                pMK->dwFlags &= ~MKF_AVAILABLE;
            }

            if (pMK->iMaxSpeed < MAXSPEED_MIN || pMK->iMaxSpeed > MAXSPEED_MAX) {
                return FALSE;
            }

            if (pMK->iTimeToMaxSpeed < TIMETOMAXSPEED_MIN || pMK->iTimeToMaxSpeed > TIMETOMAXSPEED_MAX) {
                return FALSE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                fWinIniChanged = SetMouseKeys(pProfileUserName, pMK);
                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {
                    /*
                     * Back out any changes to win.ini.
                     */
                    SetMouseKeys(pProfileUserName, &gMouseKeys);
                }

                FreeProfileUserName(pProfileUserName, &tlName);
            }

            if (fWriteAllowed) {
                RtlCopyMemory(&gMouseKeys, pMK, pMK->cbSize);
                /*
                 * Don't allow user to change cbSize field.
                 */
                gMouseKeys.cbSize = sizeof(MOUSEKEYS);

                CalculateMouseTable();

                if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
                    if ((TestAsyncKeyStateToggle(gNumLockVk) != 0) ^
                        (TEST_ACCESSFLAG(MouseKeys, MKF_REPLACENUMBERS) != 0)) {
                        gbMKMouseMode = TRUE;
                    } else {
                        gbMKMouseMode = FALSE;
                    }
                    MKShowMouseCursor();
                } else {
                    MKHideMouseCursor();
                }

                SetAccessEnabledFlag();

                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_ACCESSIBILITYSTATE,
                                ACCESS_MOUSEKEYS,
                                0,
                                WH_SHELL);
                }
                PostShellHookMessages(HSHELL_ACCESSIBILITYSTATE, ACCESS_MOUSEKEYS);
            }
        }
        break;

    case SPI_GETHIGHCONTRAST:
        {
            LPHIGHCONTRAST pHC = (LPHIGHCONTRAST)lParam;

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */

            pHC->dwFlags = gHighContrast.dwFlags;

            /*
             * A hostile app could deallocate the memory using a second thread,
             * so shelter the copy with a try.
             */
            try {
                RtlCopyMemory(pHC->lpszDefaultScheme, gHighContrastDefaultScheme, MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
        }

        break;

    case SPI_SETHIGHCONTRAST:
        {
            LPINTERNALSETHIGHCONTRAST pHC = (LPINTERNALSETHIGHCONTRAST)lParam;
            WCHAR wcDefaultScheme[MAX_SCHEME_NAME_SIZE];

            if (pHC->usDefaultScheme.Length >= MAX_SCHEME_NAME_SIZE*sizeof(WCHAR)) {
                return FALSE;
            }

            if (pHC->usDefaultScheme.Buffer) {
                /*
                 * Only set the scheme if the user specifies a scheme. An
                 * empty buffer is ignored. We do the copy here so that we
                 * don't need to put a try/except around the
                 * WriteProfileString code.
                 */

                try {
                    RtlCopyMemory(wcDefaultScheme, pHC->usDefaultScheme.Buffer, pHC->usDefaultScheme.Length);
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    return FALSE;
                }
            }
            wcDefaultScheme[pHC->usDefaultScheme.Length / sizeof(WCHAR)] = 0;

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                swprintf(szTemp, pwszd, pHC->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                        PMAP_HIGHCONTRAST,
                        L"Flags",
                        szTemp
                        );

                fWriteAllowed = fWinIniChanged;

                /*
                 * Note -- we do not write anything if there is no default
                 * scheme from the app. This is consistent with Win95/Win98
                 * behavior.
                 */
                if (pHC->usDefaultScheme.Buffer) {
                    fWinIniChanged |= FastWriteProfileStringW(pProfileUserName,
                                                              PMAP_HIGHCONTRAST,
                                                              TEXT("High Contrast Scheme"),
                                                              wcDefaultScheme);
                }

                FreeProfileUserName(pProfileUserName, &tlName);
            }

            if (fWriteAllowed) {
                DWORD dwFlagsOld = gHighContrast.dwFlags;
                LPARAM lp = fAlterWinIni ? 0 : ACCESS_HIGHCONTRASTNOREG;

#if (ACCESS_HIGHCONTRASTNOREG | ACCESS_HIGHCONTRASTOFF) != ACCESS_HIGHCONTRASTOFFNOREG
#error ACCESS_HIGHCONTRASTOFF value is incorrect
#endif
#if (ACCESS_HIGHCONTRASTNOREG | ACCESS_HIGHCONTRASTON) != ACCESS_HIGHCONTRASTONNOREG
#error ACCESS_HIGHCONTRASTON value is incorrect
#endif
#if (ACCESS_HIGHCONTRASTNOREG | ACCESS_HIGHCONTRASTCHANGE) != ACCESS_HIGHCONTRASTCHANGENOREG
#error ACCESS_HIGHCONTRASTCHANGE value is incorrect
#endif

                /*
                 * If a NULL is specified in the lpszDefaultScheme, then it
                 * is not changed. This is consistent with Win95/Win98
                 * behavior.
                 */
                if (pHC->usDefaultScheme.Buffer) {
                    wcscpy(gHighContrastDefaultScheme, wcDefaultScheme);
                }

                gHighContrast.dwFlags = pHC->dwFlags;

                SetAccessEnabledFlag();

                /*
                 * Now, post message to turn high contrast on or off.
                 */
                if (pHC->dwFlags & HCF_HIGHCONTRASTON) {
                    _PostMessage(gspwndLogonNotify,
                                 WM_LOGONNOTIFY,
                                 LOGON_ACCESSNOTIFY,
                                 (dwFlagsOld & HCF_HIGHCONTRASTON) ?
                                     (ACCESS_HIGHCONTRASTCHANGE | lp) :
                                     (ACCESS_HIGHCONTRASTON | lp));
                } else {
                    _PostMessage(gspwndLogonNotify,
                                 WM_LOGONNOTIFY,
                                 LOGON_ACCESSNOTIFY,
                                 ACCESS_HIGHCONTRASTOFF | lp);
                }

            }

            break;
        }

    case SPI_GETACCESSTIMEOUT:
        {
            LPACCESSTIMEOUT pTO = (LPACCESSTIMEOUT)lParam;
            int cbSkip = sizeof(gAccessTimeOut.cbSize);

            if (wParam != 0 && wParam != sizeof(ACCESSTIMEOUT)) {
                return FALSE;
            }

            if (!pTO || pTO->cbSize != sizeof(ACCESSTIMEOUT)) {
                return FALSE;
            }

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pTO + cbSkip),
                          (LPVOID)((LPBYTE)&gAccessTimeOut + cbSkip),
                          pTO->cbSize - cbSkip);
        }
        break;

    case SPI_SETACCESSTIMEOUT:
        {
            LPACCESSTIMEOUT pTO = (LPACCESSTIMEOUT)lParam;

            if (wParam != 0 && wParam != sizeof(ACCESSTIMEOUT)) {
                return FALSE;
            }

            if (!pTO || pTO->cbSize != sizeof(ACCESSTIMEOUT)) {
                return FALSE;
            }

            /*
             * Do some parameter validation. We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pTO->dwFlags & ATF_VALID) != pTO->dwFlags) {
                return FALSE;
            }

            if (pTO->iTimeOutMSec > 3600000) {
                return FALSE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                swprintf(szTemp, pwszd, pTO->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                                         PMAP_TIMEOUT,
                                                         L"Flags",
                                                         szTemp);

                swprintf(szTemp, pwszd, pTO->iTimeOutMSec);
                fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                                         PMAP_TIMEOUT,
                                                         L"TimeToWait",
                                                         szTemp);

                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {
                    /*
                     * Back out any changes to win.ini.
                     */
                    swprintf(szTemp, pwszd, gAccessTimeOut.dwFlags);
                    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                                             PMAP_TIMEOUT,
                                                             L"Flags",
                                                             szTemp);

                    swprintf(szTemp, pwszd, gAccessTimeOut.iTimeOutMSec);
                    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                                                             PMAP_TIMEOUT,
                                                             L"TimeToWait",
                                                             szTemp);
                }

                FreeProfileUserName(pProfileUserName, &tlName);
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gAccessTimeOut, pTO, pTO->cbSize);

                /*
                 * Don't allow user to change cbSize field.
                 */
                gAccessTimeOut.cbSize = sizeof(ACCESSTIMEOUT);

                SetAccessEnabledFlag();

                AccessTimeOutReset();
            }
        }
        break;

    case SPI_SETSHOWSOUNDS:
        if (fAlterWinIni) {
            swprintf(szTemp, pwszd, (wParam == 1));
            fWinIniChanged = FastWriteProfileStringW(NULL,
                                                     PMAP_SHOWSOUNDS,
                                                     L"On",
                                                     szTemp);

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SET_OR_CLEAR_ACCF(ACCF_SHOWSOUNDSON, wParam == 1);
            SetAccessEnabledFlag();

            /*
             * Update the System Metrics Info.
             */
            SYSMET(SHOWSOUNDS) = TEST_BOOL_ACCF(ACCF_SHOWSOUNDSON);
        }
        break;

    case SPI_GETSHOWSOUNDS: {
            PINT pint = (int *)lParam;

            *pint = TEST_BOOL_ACCF(ACCF_SHOWSOUNDSON);
        }
        break;

    case SPI_GETKEYBOARDPREF:
        {
            PBOOL pfKeyboardPref = (PBOOL)lParam;

            *pfKeyboardPref = TEST_BOOL_ACCF(ACCF_KEYBOARDPREF);
        }
        break;

    case SPI_SETKEYBOARDPREF:
        {
            BOOL fKeyboardPref = (BOOL)wParam;

            if (fAlterWinIni) {
                fWinIniChanged = FastWriteProfileStringW(NULL,
                                                         PMAP_KEYBOARDPREF,
                                                         L"On",
                                                         fKeyboardPref ? L"1" : L"0");

                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {
                SET_OR_CLEAR_ACCF(ACCF_KEYBOARDPREF, wParam);
            }
        }
        break;

    case SPI_GETSCREENREADER:
        {
            PBOOL pfScreenReader = (PBOOL)lParam;

            *pfScreenReader = TEST_BOOL_ACCF(ACCF_SCREENREADER);
        }
        break;

    case SPI_SETSCREENREADER:
        {
            BOOL fScreenReader = (BOOL)wParam;

            if (fAlterWinIni) {
                fWinIniChanged = FastWriteProfileStringW(NULL,
                                                         PMAP_SCREENREADER,
                                                         L"On",
                                                         fScreenReader ? L"1" : L"0");
                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {
                SET_OR_CLEAR_ACCF(ACCF_SCREENREADER, wParam);
            }
        }
        break;

    case SPI_GETSOUNDSENTRY:
        {
            LPSOUNDSENTRY pSS = (LPSOUNDSENTRY)lParam;
            int cbSkip = sizeof(gSoundSentry.cbSize);

            if (wParam != 0 && wParam != sizeof(SOUNDSENTRY)) {
                return FALSE;
            }

            if (!pSS || pSS->cbSize != sizeof(SOUNDSENTRY)) {
                return FALSE;
            }

            /*
             * In the future we may support multiple sizes of this data
             * structure. Don't change the cbSize field of the data
             * structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pSS + cbSkip),
                          (LPVOID)((LPBYTE)&gSoundSentry + cbSkip),
                          pSS->cbSize - cbSkip);
        }
        break;

    case SPI_SETSOUNDSENTRY:
        {
            LPSOUNDSENTRY pSS = (LPSOUNDSENTRY)lParam;

            if (wParam != 0 && wParam != sizeof(SOUNDSENTRY)) {
                return FALSE;
            }

            if (!pSS || pSS->cbSize != sizeof(SOUNDSENTRY)) {
                return FALSE;
            }

            /*
             * Do some parameter validation. We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pSS->dwFlags & SSF_VALID) != pSS->dwFlags) {
                return FALSE;
            }

            /*
             * We don't support SSWF_CUSTOM.
             */
            if (pSS->iWindowsEffect > SSWF_DISPLAY) {
                return FALSE;
            }

            /*
             * No support for non-windows apps.
             */
            if (pSS->iFSTextEffect != SSTF_NONE) {
                return FALSE;
            }
            if (pSS->iFSGrafEffect != SSGF_NONE) {
                return FALSE;
            }

            /*
             * SSF_AVAILABLE can't be set via API. Use registry value.
             */
            if (TEST_ACCESSFLAG(SoundSentry, SSF_AVAILABLE)) {
                pSS->dwFlags |= SSF_AVAILABLE;
            } else {
                pSS->dwFlags &= ~SSF_AVAILABLE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                fWinIniChanged = SetSoundSentry(pProfileUserName, pSS);
                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {

                    /*
                     * Back out any changes to win.ini
                     */
                    SetSoundSentry(pProfileUserName, &gSoundSentry);
                }
                FreeProfileUserName(pProfileUserName, &tlName);
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gSoundSentry, pSS, pSS->cbSize);

                /*
                 * Don't allow user to change cbSize field.
                 */
                gSoundSentry.cbSize = sizeof(SOUNDSENTRY);

                SetAccessEnabledFlag();
            }
        }
        break;

    case SPI_SETCURSORS:
            pProfileUserName = CreateProfileUserName(&tlName);
            xxxUpdateSystemCursorsFromRegistry(pProfileUserName);
            FreeProfileUserName(pProfileUserName, &tlName);

            break;

    case SPI_SETICONS:
            pProfileUserName = CreateProfileUserName(&tlName);
            xxxUpdateSystemIconsFromRegistry(pProfileUserName);
            FreeProfileUserName(pProfileUserName, &tlName);

            break;

    case SPI_GETMOUSEHOVERWIDTH:
        *((UINT *)lParam) = gcxMouseHover;
        break;

    case SPI_SETMOUSEHOVERWIDTH:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_MOUSEHOVERWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gcxMouseHover = wParam;
        }
        break;

    case SPI_GETMOUSEHOVERHEIGHT:
        *((UINT *)lParam) = gcyMouseHover;
        break;

    case SPI_SETMOUSEHOVERHEIGHT:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_MOUSEHOVERHEIGHT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gcyMouseHover = wParam;
        }
        break;

    case SPI_GETMOUSEHOVERTIME:
        *((UINT *)lParam) = gdtMouseHover;
        break;

    case SPI_SETMOUSEHOVERTIME:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_MOUSEHOVERTIME, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gdtMouseHover = wParam;
        }
        break;

    case SPI_GETWHEELSCROLLLINES:
        (*(LPDWORD)lParam) = gpsi->ucWheelScrollLines;
        break;

    case SPI_SETWHEELSCROLLLINES:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_WHEELSCROLLLINES)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_WHEELSCROLLLINES, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed)
            gpsi->ucWheelScrollLines = (UINT)wParam;
        break;

    case SPI_GETMENUSHOWDELAY:
        (*(LPDWORD)lParam) = gdtMNDropDown;
        break;

    case SPI_SETMENUSHOWDELAY:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_MENUSHOWDELAY)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_MENUSHOWDELAY, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed)
            gdtMNDropDown = wParam;
        break;

    case SPI_GETSCREENSAVERRUNNING:
        (*(LPBOOL)lParam) = gppiScreenSaver != NULL;
        break;

    case SPI_SETSHOWIMEUI:
        return xxxSetIMEShowStatus(!!wParam);

    case SPI_GETSHOWIMEUI:
        (*(LPBOOL)lParam) = _GetIMEShowStatus();
        break;

    default:

#define ppvi (UPDWORDPointer(wFlag))
#define uDataRead ((UINT)fWinIniChanged)

        if (wFlag < SPI_MAX) {
            RIPERR1(ERROR_INVALID_SPI_VALUE,
                    RIP_WARNING,
                    "xxxSystemParamtersInfo: Invalid SPI_: 0x%x",
                    wFlag);
            return FALSE;
        }

        UserAssert(wFlag & SPIF_RANGETYPEMASK);

        if (!(wFlag & SPIF_SET)) {

            if ((wFlag & SPIF_RANGETYPEMASK) == SPIF_BOOL) {
                BOOL fDisable, fDisableValue;

                UserAssert(UPIsBOOLRange(wFlag));
                /*
                 * Handle settings that can be disabled by additional conditions.
                 */
                fDisable = fDisableValue = FALSE;
                if (wFlag < SPI_GETUIEFFECTS) {
                    if (!TestUP(UIEFFECTS)) {
                        switch (wFlag) {
                        case SPI_GETACTIVEWNDTRKZORDER:
                        case SPI_GETACTIVEWINDOWTRACKING:
#ifdef MOUSE_IP
                        case SPI_GETMOUSESONAR:
#endif
                        case SPI_GETMOUSECLICKLOCK:
                            break;

                        case SPI_GETKEYBOARDCUES:
                            fDisableValue = TRUE;
                            /* Fall Through */

                        default:
                            fDisable = TRUE;
                            break;
                        }
                    } else {
                        switch (wFlag) {
                        case SPI_GETKEYBOARDCUES:
                            if (TEST_BOOL_ACCF(ACCF_KEYBOARDPREF)) {
                                fDisableValue = TRUE;
                                fDisable = TRUE;
                            }
                            break;

                        case SPI_GETGRADIENTCAPTIONS:
                        case SPI_GETSELECTIONFADE:
                        case SPI_GETMENUFADE:
                        case SPI_GETTOOLTIPFADE:
                        case SPI_GETCURSORSHADOW:
                            if (gbDisableAlpha) {
                                fDisable = TRUE;
                            }
                            break;
                        }
                    }
                }
                
                /*
                 * Give them the disabled value or read the actual one.
                 */
                if (fDisable) {
                    *((BOOL *)lParam) = fDisableValue;
                } else if (wFlag == SPI_GETUIEFFECTS && IsRemoteConnection()) {
                    /*
                     * Fix for 689707.
                     * In remote connections, lie about the SPI_GETUIEFFECTS.
                     * We look at a certain subset of the uieffects array.
                     * If all the subset bits are off, 
                     * we return FALSE, otherwise TRUE.
                     */
                     *((BOOL *)lParam) = !!(TestUP(CURSORSHADOW) |
                                         TestUP(MENUANIMATION) |
                                         TestUP(MENUFADE) |
                                         TestUP(TOOLTIPANIMATION) |
                                         TestUP(TOOLTIPFADE) |  
                                         TestUP(COMBOBOXANIMATION) |  
                                         TestUP(LISTBOXSMOOTHSCROLLING));
                } else {
                    *((BOOL *)lParam) = !!TestUPBOOL(gpdwCPUserPreferencesMask, wFlag);
                }
            } else {
                UserAssert(UPIsDWORDRange(wFlag));
                *((DWORD *)lParam) = UPDWORDValue(wFlag);
                switch(wFlag) {
                    case SPI_GETFONTSMOOTHINGCONTRAST:
                        /*
                         * If the contrast value was never set by the user,
                         * we will return the default value from the display
                         * driver
                         */
                        if (*((DWORD *)lParam) == 0) {
                            *((DWORD *)lParam) = GreGetFontContrast();
                        }
                        break;
                    default:
                        break;
                }
            }
        } else {
            pProfileUserName = CreateProfileUserName(&tlName);

            if ((wFlag & SPIF_RANGETYPEMASK) == SPIF_BOOL) {
                DWORD pdwValue [SPI_BOOLMASKDWORDSIZE];

                UserAssert(UPIsBOOLRange(wFlag));
                UserAssert(sizeof(pdwValue) == sizeof(gpdwCPUserPreferencesMask));

                if (gpviCPUserPreferences->uSection == PMAP_DESKTOP) {
                    if (CheckDesktopPolicy(pProfileUserName, gpviCPUserPreferences->pwszKeyName)) {
                        fAlterWinIni = FALSE;
                        fWriteAllowed = FALSE;
                    }
                }
                if (fAlterWinIni) {
                    /*
                     * We only need to set/clear the bit passed in, however,
                     * we write the whole bit mask to the registry. Since
                     * the info in gpdwCPUserPreferencesMask might not match
                     * what it is in the registry, we need to read the
                     * registry before we write to it.
                     */
                    uDataRead = FastGetProfileValue(pProfileUserName,
                                                    gpviCPUserPreferences->uSection,
                                                    gpviCPUserPreferences->pwszKeyName,
                                                    NULL,
                                                    (LPBYTE)pdwValue,
                                                    sizeof(pdwValue),
                                                    0);

                    /*
                     * If some bits are not in the registry, get them from
                     * gpdwCPUserPreferencesMask.
                     */
                    UserAssert(uDataRead <= sizeof(gpdwCPUserPreferencesMask));
                    RtlCopyMemory(pdwValue + uDataRead,
                                  gpdwCPUserPreferencesMask + uDataRead,
                                  sizeof(gpdwCPUserPreferencesMask) - uDataRead);

                    /*
                     * Set/Clear the new state and write it.
                     */
                    if (lParam) {
                        SetUPBOOL(pdwValue, wFlag);
                    } else {
                        ClearUPBOOL(pdwValue, wFlag);
                    }

                    fWinIniChanged = FastWriteProfileValue(pProfileUserName,
                                                           gpviCPUserPreferences->uSection,
                                                           gpviCPUserPreferences->pwszKeyName,
                                                           REG_BINARY,
                                                           (LPBYTE)pdwValue,
                                                           sizeof(pdwValue));

                    fWriteAllowed = fWinIniChanged;
                }

                if (fWriteAllowed) {
                    if (lParam) {
                        SetUPBOOL(gpdwCPUserPreferencesMask, wFlag);
                    } else {
                        ClearUPBOOL(gpdwCPUserPreferencesMask, wFlag);
                    }

                    /*
                     * Propagate gpsi flags.
                     */
                    switch (wFlag) {
                    case SPI_SETUIEFFECTS:
                        PropagetUPBOOLTogpsi(UIEFFECTS);
                        SetPointer(TRUE);

                        /*
                         * Fall through.
                         */

                    case SPI_SETGRADIENTCAPTIONS:
                        CreateBitmapStrip();
                        xxxRedrawScreen();
                        break;

                    case SPI_SETCOMBOBOXANIMATION:
                        PropagetUPBOOLTogpsi(COMBOBOXANIMATION);
                        break;

                    case SPI_SETLISTBOXSMOOTHSCROLLING:
                        PropagetUPBOOLTogpsi(LISTBOXSMOOTHSCROLLING);
                        break;

                    case SPI_SETKEYBOARDCUES:
                        PropagetUPBOOLTogpsi(KEYBOARDCUES);
                        break;

                    case SPI_SETCURSORSHADOW:
                        SetPointer(TRUE);
                        break;

                    case SPI_SETFLATMENU:
                        xxxRedrawScreen();
                        break;

                    }
                }
            } else {

                UserAssert(UPIsDWORDRange(wFlag));

                if (ppvi->uSection == PMAP_DESKTOP) {
                    if (CheckDesktopPolicy(pProfileUserName, ppvi->pwszKeyName)) {
                        fAlterWinIni = FALSE;
                        fWriteAllowed = FALSE;
                    }
                }
                if (fAlterWinIni) {
                    fWinIniChanged = FastWriteProfileValue(pProfileUserName,
                                                           ppvi->uSection,
                                                           ppvi->pwszKeyName,
                                                           REG_DWORD,
                                                           (LPBYTE)&lParam,
                                                           sizeof(DWORD));

                    fWriteAllowed = fWinIniChanged;
                }

                if (fWriteAllowed) {
                    ppvi->dwValue = PtrToUlong(lParam);

                    switch(wFlag) {
                    case SPI_SETCARETWIDTH:
                        gpsi->uCaretWidth = ppvi->dwValue;
                        break;

                    case SPI_SETFOCUSBORDERWIDTH:
                        if (ppvi->dwValue) {
                            SYSMET(CXFOCUSBORDER) = ppvi->dwValue;
                        }
                        break;

                    case SPI_SETFOCUSBORDERHEIGHT:
                        if (ppvi->dwValue) {
                            SYSMET(CYFOCUSBORDER) = ppvi->dwValue;
                        }
                        break;

                    case SPI_SETFONTSMOOTHINGTYPE:
                        GreSetFontEnumeration((ppvi->dwValue & FE_FONTSMOOTHINGCLEARTYPE) ? FE_CT_ON | FE_SET_CT : FE_SET_CT);
                        break;
                    case SPI_SETFONTSMOOTHINGCONTRAST:
                        GreSetFontContrast(ppvi->dwValue);
                        break;
                    case SPI_SETFONTSMOOTHINGORIENTATION:
                        GreSetLCDOrientation(ppvi->dwValue);
                        break;
                    default:
                        break;
                    }
                }
            }

            FreeProfileUserName(pProfileUserName, &tlName);
        }

        break;
#undef ppvi
#undef uDataRead
    }


    if (fWinIniChanged && fSendWinIniChange) {
        ULONG_PTR dwResult;

        RtlInitLargeUnicodeString(&strSection, szSection, (UINT)-1);
        xxxSendMessageTimeout(PWND_BROADCAST,
                              WM_SETTINGCHANGE,
                              wFlag,
                              (LPARAM)&strSection,
                              SMTO_NORMAL,
                              100,
                              &dwResult);
    }

    return fWriteAllowed;
}

/***************************************************************************\
* _RegisterShellHookWindow
*
* History:
\***************************************************************************/
BOOL _RegisterShellHookWindow(
    PWND pwnd)
{
    PDESKTOPINFO pdeskinfo;

    if (pwnd->head.rpdesk == NULL) {
        return FALSE;
    }

    pdeskinfo = pwnd->head.rpdesk->pDeskInfo;

    /*
     * Add pwnd to the desktop's Volatile Window Pointer List (VWPL) of
     * ShellHook windows. If this call initializes the VWPL, set the
     * (re)allocation threshhold to 2 PWNDs (we know we never have more than
     * 2 windows in this list anyway)
     */
    if (VWPLAdd(&(pdeskinfo->pvwplShellHook), pwnd, 2)) {
        SetWF(pwnd, WFSHELLHOOKWND);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* _DeregisterShellHookWindow
*
* History:
\***************************************************************************/
BOOL _DeregisterShellHookWindow(
    PWND pwnd)
{
    PDESKTOPINFO pdeskinfo;

    if (pwnd->head.rpdesk == NULL) {
        return FALSE;
    }

    pdeskinfo = pwnd->head.rpdesk->pDeskInfo;

    if (VWPLRemove(&(pdeskinfo->pvwplShellHook), pwnd)) {
        ClrWF(pwnd, WFSHELLHOOKWND);
    }

    return TRUE;
}

/***************************************************************************\
* xxxSendMinRectMessages
*
* History:
\***************************************************************************/
BOOL xxxSendMinRectMessages(
    PWND pwnd,
    RECT *lpRect)
{
    BOOL fRet = FALSE;
    HWND hwnd = HW(pwnd);
    PTHREADINFO pti = PtiCurrent();
    PDESKTOPINFO pdeskinfo;
    DWORD nPwndShellHook;
    PWND pwndShellHook;

    if (IsHooked(pti, WHF_SHELL)) {
        xxxCallHook(HSHELL_GETMINRECT, (WPARAM)hwnd, (LPARAM)lpRect, WH_SHELL);
        fRet = TRUE;
    }

    pdeskinfo = GETDESKINFO(pti);
    if (pdeskinfo->pvwplShellHook == NULL) {
        return fRet;
    }

    nPwndShellHook = 0;
    pwndShellHook = NULL;
    while (pwndShellHook = VWPLNext(pdeskinfo->pvwplShellHook, pwndShellHook, &nPwndShellHook)) {
        TL tlpwnd;
        ULONG_PTR dwRes;

        ThreadLock(pwndShellHook, &tlpwnd);
        if (xxxSendMessageTimeout(pwndShellHook, WM_KLUDGEMINRECT, (WPARAM)(hwnd), (LPARAM)lpRect,
            SMTO_NORMAL, 100, &dwRes))
            fRet = TRUE;

        /*
         * pdeskinfo->pvwplShellHook may have been realloced to a different
         * location and size during the WM_KLUDGEMINRECT callback.
         */
        ThreadUnlock(&tlpwnd);
    }
    return fRet;
}

/***************************************************************************\
* PostShellHookMessages
*
* History:
\***************************************************************************/
VOID PostShellHookMessages(
    UINT message,
    LPARAM lParam)
{
    PDESKTOPINFO pdeskinfo = GETDESKINFO(PtiCurrent());
    DWORD nPwndShellHook;
    PWND pwndShellHook;

    nPwndShellHook = 0;
    pwndShellHook = NULL;

    /*
     * We want to allow anyone who's listening for these WM_APPCOMMAND
     * messages to be able to take the foreground. I.E., pressing mail will
     * launch outlook AND bring it to the foreground. We set the token to
     * null so anyone can steal the foreground - else it isn't clear who
     * should have the right to steal it - only one person gets the right.
     * We let them fight it out to decide who gets foreground if more than
     * one listener will try make a foreground change.
     */
    if (HSHELL_APPCOMMAND == message) {
        TAGMSG0(DBGTAG_FOREGROUND,
                "PostShellHookMessages cleared last input token - open foreground.");

        glinp.ptiLastWoken = NULL;
    }

    /*
     * Loop through all the windows registered to listen for shell hooks and
     * post the message to them.
     */
    while (pwndShellHook = VWPLNext(pdeskinfo->pvwplShellHook, pwndShellHook, &nPwndShellHook)) {
        if (pwndShellHook == pdeskinfo->spwndProgman) {
            switch (message) {
            case HSHELL_WINDOWCREATED:
                _PostMessage(pwndShellHook, gpsi->uiShellMsg, guiOtherWindowCreated, lParam);
                break;
            case HSHELL_WINDOWDESTROYED:
                _PostMessage(pwndShellHook, gpsi->uiShellMsg, guiOtherWindowDestroyed, lParam);
                break;
            }
        } else {
            _PostMessage(pwndShellHook, gpsi->uiShellMsg, message, lParam);
        }
    }

}

/***************************************************************************\
* _ResetDblClk
*
* History:
\***************************************************************************/
VOID _ResetDblClk(
    VOID)
{
    PtiCurrent()->pq->timeDblClk = 0L;
}

/***************************************************************************\
* SetMsgBox
*
* History:
\***************************************************************************/
VOID SetMsgBox(
    PWND pwnd)
{
    pwnd->head.rpdesk->pDeskInfo->cntMBox++;
    SetWF(pwnd, WFMSGBOX);
}

/***************************************************************************\
* xxxSimulateShiftF10
*
* This routine is called to convert a WM_CONTEXTHELP message back to a
* SHIFT-F10 sequence for old applications. It is called from the default
* window procedure.
*
* History:
* 22-Aug-95 BradG       Ported from Win95 (rare.asm)
\***************************************************************************/
VOID xxxSimulateShiftF10(
    VOID)
{
        /*
     *  VK_SHIFT down
     */
    xxxKeyEvent(VK_LSHIFT, 0x2A | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);

    /*
     *  VK_F10 down
     */
    xxxKeyEvent(VK_F10, 0x44 | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);

    /*
     *  VK_F10 up
     */
    xxxKeyEvent(VK_F10 | KBDBREAK, 0x44 | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);

    /*
     *  VK_SHIFT up
     */
    xxxKeyEvent(VK_LSHIFT | KBDBREAK, 0x2A | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);
}

/*
 * VWPL (Volatile Window Pointer List) Implementation details.
 * ===========================================================
 * Volatile Window Pointer Lists are used to keep a list of windows that we want
 * to send messages to, where the list may get altered during each of those send
 * message callbacks.
 *
 * The list is volatile in that it can change its size, contents and location
 * while we continue to traverse the list.
 *
 * Examples of use:
 * - hungapp redraw code in hungapp.c
 * - xxxSendMinRectMessages stuff in rare.c
 *
 * Members of the VWPL struct:
 * cPwnd
 *   The number of pwnds in the list, not including NULLs
 * cElem
 *   The size of the list, including NULLs.
 * cThreshhold
 *   When growing, the number of extra spaces to add to the list.
 *   When (cElem - cPwnd) > cThreshhold, that's when we reallocate to shrink.
 * apwnd[]
 *   An array of pwnds.
 *   The array may have some empty slots, but they will all be at the end.
 *
 * VWPL Internal Invariants:
 * - no pwnd appears more than once.
 * - cPwnd <= cElem
 * - number of unused slots (cElem - cPwnd) < cThreshhold
 * - all unused slots are at the end of the aPwnd[] array
 *
 * Restrictions on use of VWPLs:
 * - NULL pwnd is not allowed (except in unused slots)
 * - all pwnds in the list must be valid: pwnds must be explicitly removed from
 *   the list in their xxxFreeWindow.
 */

#if DBG_VWPL
BOOL DbgCheckVWPL(
    PVWPL pvwpl)
{
    DWORD ixPwnd;

    if (!pvwpl) {
        return TRUE;
    }

    UserAssert(pvwpl->cElem >= pvwpl->cPwnd);

    /*
     * Check that cElem is not too big.
     */
    UserAssert(pvwpl->cElem < 1000);

    /*
     * Check that the pwnds are all in the first cPwnd slots.
     */
    for (ixPwnd = 0; ixPwnd < pvwpl->cPwnd; ixPwnd++) {
        UserAssert(pvwpl->aPwnd[ixPwnd] != NULL);
    }

#if ZERO_INIT_VWPL
    /*
     * Check that the NULLs are all in the last few slots.
     */
    for (ixPwnd = pvwpl->cPwnd; ixPwnd < pvwpl->cElem; ixPwnd++) {
        UserAssert(pvwpl->aPwnd[ixPwnd] == NULL);
    }
#endif

    /*
     * Check that no pwnds appears twice.
     */
    for (ixPwnd = 0; ixPwnd < pvwpl->cPwnd; ixPwnd++) {
        DWORD ix2;
        for (ix2 = ixPwnd + 1; ix2 < pvwpl->cPwnd; ix2++) {
            UserAssert(pvwpl->aPwnd[ixPwnd] != pvwpl->aPwnd[ix2]);
        }
    }
}
#else
#define DbgCheckVWPL(foo)
#endif

/*****************************************************************************\
* VWPLAdd
*
* Adds a pwnd to a VWPL (Volatile Window Pointer List). Allocates or
* reallocates memory as required.
*
* History:
* 98-01-30 IanJa   Created.
\*****************************************************************************/
BOOL VWPLAdd(
    PVWPL *ppvwpl,
    PWND pwnd,
    DWORD dwThreshhold)
{
    PVWPL pvwpl;
    DWORD ixPwnd;

    TAGMSG2(DBGTAG_VWPL, "VWPL %#p + %#p", *ppvwpl, pwnd);
    UserAssert(pwnd);

    if (*ppvwpl == NULL) {
        /*
         * Initialize the VWPL.
         */
        UserAssert(dwThreshhold >= 2); // could be 1, but that would be silly
        pvwpl = (PVWPL)UserAllocPool(sizeof(VWPL) + (sizeof(PWND) * dwThreshhold),
                                     TAG_VWPL);
        if (pvwpl == NULL) {
            RIPMSG1(RIP_WARNING,
                    "VWPLAdd fail to allocate initial %lx",
                    sizeof(VWPL) + (sizeof(PWND) * dwThreshhold));
            DbgCheckVWPL(*ppvwpl);
            return FALSE;
        }
        pvwpl->cElem = dwThreshhold;
        pvwpl->cThreshhold = dwThreshhold;
#if ZERO_INIT_VWPL
        RtlZeroMemory(&(pvwpl->aPwnd[0]), (sizeof(PWND) * dwThreshhold));
#endif
        pvwpl->cPwnd = 0;
        *ppvwpl = pvwpl;
        ixPwnd = 0;
        goto AddPwnd;
    } else {
        pvwpl = *ppvwpl;
        for (ixPwnd = 0; ixPwnd < pvwpl->cElem; ixPwnd++) {
            if (pwnd == pvwpl->aPwnd[ixPwnd]) {
                DbgCheckVWPL(*ppvwpl);
                return FALSE; // callers require FALSE this case
            }
        }

        if (pvwpl->cPwnd >= pvwpl->cElem ) {
            /*
             * Didn't find it already there, and no space so grow the VWPL.
             */
            DWORD dwSize;
            DWORD dwSizeNew;

            dwSize = sizeof(VWPL) + (sizeof(PWND) * pvwpl->cElem);
            dwSizeNew = dwSize + (sizeof(PWND) * pvwpl->cThreshhold);
            pvwpl = (PVWPL)UserReAllocPool(pvwpl, dwSize, dwSizeNew, TAG_VWPL);
            if (pvwpl == NULL) {
                RIPMSG2(RIP_WARNING,
                        "VWPLAdd fail to reallocate %lx to %lx", dwSize, dwSizeNew);
                DbgCheckVWPL(*ppvwpl);
                return FALSE;
            }
#if ZERO_INIT_VWPL
            RtlZeroMemory(&(pvwpl->aPwnd[pvwpl->cPwnd]), (sizeof(PWND) * dwThreshhold));
#endif
            pvwpl->cElem += pvwpl->cThreshhold;
            *ppvwpl = pvwpl;
        }
    }

AddPwnd:
    ixPwnd = pvwpl->cPwnd;
    pvwpl->aPwnd[ixPwnd] = pwnd;
    pvwpl->cPwnd++;
    DbgCheckVWPL(*ppvwpl);
    return TRUE;
}

/*****************************************************************************\
* VWPLRemove
*
* Removes a pwnd from a VWPL list of pwnds. Reallocates memory as required.
*
* Returns FALSE if the pwnd was not found.
*
* History:
* 98-01-30 IanJa   Created.
\*****************************************************************************/
BOOL VWPLRemove(
    PVWPL *ppvwpl,
    PWND pwnd)
{
    PVWPL pvwpl = *ppvwpl;
    DWORD ixPwnd;

    TAGMSG2(DBGTAG_VWPL, "VWPL %#p - %#p", *ppvwpl, pwnd);
    UserAssert(pwnd);

    if (!pvwpl) {
        return FALSE;
    }

    for (ixPwnd = 0; ixPwnd < pvwpl->cElem; ixPwnd++) {
        if (pwnd == pvwpl->aPwnd[ixPwnd]) {
            goto PwndIsFound;
        }
    }
    DbgCheckVWPL(*ppvwpl);
    return FALSE;

PwndIsFound:
    pvwpl->aPwnd[ixPwnd] = NULL;
    pvwpl->cPwnd--;

    if (pvwpl->cPwnd == 0) {
        UserFreePool(pvwpl);
        *ppvwpl = NULL;
        return TRUE;
    }

    /*
     * Compact the VWPL to keep all the empty slots at the end. If these
     * free slots exceeds the threshhold, realloc to shrink. It doesn't
     * matter that we change the order.
     */
    pvwpl->aPwnd[ixPwnd] = pvwpl->aPwnd[pvwpl->cPwnd];
#if ZERO_INIT_VWPL
    pvwpl->aPwnd[pvwpl->cPwnd] = NULL;
#endif


    if ((pvwpl->cElem - pvwpl->cPwnd) >= pvwpl->cThreshhold) {
        DWORD dwSize;
        DWORD dwSizeNew;

        dwSize = sizeof(VWPL) + (sizeof(PWND) * pvwpl->cElem);
        dwSizeNew = sizeof(VWPL) + (sizeof(PWND) * pvwpl->cPwnd);
        pvwpl = (PVWPL)UserReAllocPool(pvwpl, dwSize, dwSizeNew, TAG_VWPL);
        if (pvwpl == NULL) {
            RIPMSG2(RIP_WARNING,
                    "VWPLRemove fail to reallocate %lx to %lx",
                    dwSize, dwSizeNew);
            DbgCheckVWPL(*ppvwpl);
            return TRUE;
        }
        pvwpl->cElem = pvwpl->cPwnd;
        *ppvwpl = pvwpl;
    }

    DbgCheckVWPL(*ppvwpl);
    return TRUE;
}

/*****************************************************************************\
* VWPLNext
*
* Returns the next pwnd from a VWPL (Volatile Window Pointer List).
*
* Setting *pnPrev to 0 will return the first pwnd in the VWPL, and gets a new
* value in *pnPrev which is to be used in a subsequent call to VWPLNext to
* obtain the next pwnd.
* Returns NULL when the last pwnd has been obtained, and sets *pnPrev back to 0
*
* History:
* 98-01-30 IanJa   Created.
\*****************************************************************************/
PWND VWPLNext(
    PVWPL pvwpl,
    PWND pwndPrev,
    DWORD *pnPrev)
{
    DbgCheckVWPL(pvwpl);

    if (!pvwpl) {
        TAGMSG1(DBGTAG_VWPL, "VWPL %#p => NULL (empty)", pvwpl);
        return NULL;
    }

    if (*pnPrev >= pvwpl->cPwnd) {
        goto NoMorePwnds;
    }

    /*
     * If our previous pwnd is still there, advance to the next slot
     * (else it has gone, so return the one now occupying its slot).
     */
    if (pvwpl->aPwnd[*pnPrev] == pwndPrev) {
        (*pnPrev)++;
    }

    if (*pnPrev < pvwpl->cPwnd) {
        UserAssert(pvwpl->aPwnd[*pnPrev] != pwndPrev);
        TAGMSG2(DBGTAG_VWPL, "VWPL %#p => %#p", pvwpl, pvwpl->aPwnd[*pnPrev]);
        return pvwpl->aPwnd[*pnPrev];
    }

    /*
     * We came to the end.
     */
NoMorePwnds:
    TAGMSG1(DBGTAG_VWPL, "VWPL 0x%p => NULL (end)", pvwpl);
    *pnPrev = 0;
    return NULL;
}


/*****************************************************************************\
* RestoreMonitorsAndWindowsRects
*
* Restore a windows sizes and positions previously captured in a WMSNAPSHOT
* structure. Capture happens when disconnecting from local console and
* restore happens when connecting back to local console.
\*****************************************************************************/
NTSTATUS RestoreMonitorsAndWindowsRects(
    VOID)
{
    PMONITORRECTS pmr;
    int i;
    int j;
    BOOL bFound;
    PSMWP psmwp;
    PWND pwnd;
    NTSTATUS Status;
    PWPSNAPSHOT pwps = NULL;

    /*
     * Don't do anything if not multimon.
     */
    if (!IsMultimon()) {
        return STATUS_SUCCESS;
    }

    /*
     * Nothing to do if we don't currently have captured monitors or
     * windows snapshots.
     */
    if (gwms.pmr == NULL || gwms.pwps == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    /*
     * Get Current monitors layout.
     */
    pmr = SnapshotMonitorRects();
    if (pmr == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * make sure monitors we captured are still there.
     */

    Status = STATUS_SUCCESS;
    for (i = 0; i < gwms.pmr->cMonitor; i++) {
        bFound = FALSE;
        for (j = 0; j < pmr->cMonitor; j++) {
            if (EqualRect(&gwms.pmr->amp[i].rcMonitor, &pmr->amp[j].rcMonitor)) {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
    }
    UserFreePool(pmr);

    /*
     * Position Windows now.
     */
    if (NT_SUCCESS(Status)) {
        if ((psmwp = InternalBeginDeferWindowPos(4)) != NULL) {
            for (i = 0, pwps = gwms.pwps; (i < gwms.cWindows) && (psmwp != NULL) ; i++, pwps++) {
                /*
                 * Make sure this hwnd is still here.
                 */
                if ((pwnd = RevalidateHwnd(pwps->hwnd)) == NULL ||
                    TestWF(pwnd, WEFTOOLWINDOW)) {
                    continue;
                }

                psmwp = _DeferWindowPos(psmwp,
                                        pwnd,
                                        (PWND)HWND_TOP,
                                        pwps->rcWindow.left,
                                        pwps->rcWindow.top,
                                        pwps->rcWindow.right - pwps->rcWindow.left,
                                        pwps->rcWindow.bottom - pwps->rcWindow.top,
                                        SWP_NOACTIVATE | SWP_NOZORDER);
            }

            if (psmwp != NULL) {
                xxxEndDeferWindowPosEx(psmwp, TRUE);
            } else{
                Status = STATUS_NO_MEMORY;
            }
        }
    }
Exit:
    CleanupMonitorsAndWindowsSnapShot();

    return Status;
}

/*****************************************************************************\
* SnapShotMonitorsAndWindowsRects
*
* Captures windows sizes and positions in a WMSNAPSHOT structure. Capture
* happens when disconnecting from local console.
\*****************************************************************************/
NTSTATUS SnapShotMonitorsAndWindowsRects(
    VOID)

{
    /*
     * First, cleanup anything left over from previous captures.
     */
    if (gwms.pmr != NULL || gwms.pwps != NULL) {
        CleanupMonitorsAndWindowsSnapShot();
    }

    /*
     * Get a snaphot of current monitors configuration.
     */
    if ((gwms.pmr = SnapshotMonitorRects()) == NULL) {
        return STATUS_NO_MEMORY;
    }

    /*
     * Get a snaphsot of windows positions.
     */
    if ((gwms.pwps = SnapshotWindowRects(&gwms.cWindows)) == NULL) {
        CleanupMonitorsAndWindowsSnapShot();
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}


/*****************************************************************************\
* CleanupMonitorsAndWindowsSnapShot
*
* Frees memory allocated to capture windows sizes and positions a WMSNAPSHOT
* structure.
\*****************************************************************************/
VOID CleanupMonitorsAndWindowsSnapShot(
    VOID)
{
    PWPSNAPSHOT pwps =  gwms.pwps;

    if (gwms.pmr != NULL) {
        UserFreePool(gwms.pmr);
        gwms.pmr = NULL;
    }

    if (pwps != NULL) {
        UserFreePool(gwms.pwps);
        gwms.pwps = NULL;
    }

    gwms.cWindows = 0;
}


/*****************************************************************************\
* SnapshotWindowRects
*
* Allocates memory to capture window sizes and positions in a WMSNAPSHOT
* structure.
\*****************************************************************************/
PWPSNAPSHOT SnapshotWindowRects(
    int *pnWindows)
{
    PWND            pwndDesktop;
    PHWND           phwnd;
    PBWL            pbwl;
    PWND            pwnd;
    int             nWindows = 0;
    PWPSNAPSHOT     pwps = NULL;
    PWPSNAPSHOT     pReturnedpwps = NULL;

    /*
     * Initialize captured windows count.
     */

    *pnWindows = 0;

    /*
     * Build a list of top windows.
     */

    UserVerify(pwndDesktop = _GetDesktopWindow());
    if ((pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, NULL)) == NULL) {
        return NULL;
    }

    /*
     * Count maximum captured windows to allocate WPSNAPSHOT array.
     */
    phwnd = pbwl->rghwnd;
    while (*phwnd != (HWND)1) {
        nWindows++;
        phwnd++;
    }

    if (nWindows != 0) {
        pwps = UserAllocPoolWithQuotaZInit(sizeof(WPSNAPSHOT) * nWindows, TAG_SWP);
    }

    if (pwps == NULL) {
        FreeHwndList(pbwl);
        return NULL;
    }
    pReturnedpwps = pwps;


    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        /*
         * Make sure this hwnd is still around.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL || TestWF(pwnd, WEFTOOLWINDOW) ) {
            continue;
        }

        pwps->hwnd = *phwnd;
        CopyRect(&pwps->rcWindow, &pwnd->rcWindow);
        (*pnWindows)++;
        pwps++;

    }

    if (*pnWindows != 0) {
        return pReturnedpwps;
    }  else {
        UserFreePool(pReturnedpwps);
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\scrollw.c ===
/****************************** Module Header ******************************\
* Module Name: scrollw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Window and DC scrolling routines.
*
* History:
* 18-Jul-1991 DarrinM   Recreated from Win 3.1 source.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Problems so far:
 * DCs not at origin (0, 0)
 * funny coordinate systems
 */

/***************************************************************************\
* GetTrueClipRgn
*
* Get copy of true clip region and its bounds.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int GetTrueClipRgn(
    HDC  hdc,
    HRGN hrgnClip)
{
    POINT pt;
    int   code;

    code = GreCopyVisRgn(hdc, hrgnClip);

    /*
     * NOTE!!! The global ghrgnScrl2 is used in this routine!
     */
    GreGetDCOrg(hdc, &pt);

    if (GreGetRandomRgn(hdc, ghrgnScrl2, 1)) {
        GreOffsetRgn(ghrgnScrl2, pt.x, pt.y);
        code = IntersectRgn(hrgnClip, hrgnClip, ghrgnScrl2);
    }

    /*
     * Finally convert the result to DC coordinates
     */
    GreOffsetRgn(hrgnClip, -pt.x, -pt.y);

    return code;
}

/***************************************************************************\
* InternalScrollDC
*
* This function requires all input parameters in device coordinates
* (NOT screen!)
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int InternalScrollDC(
    HDC    hdc,
    int    dx,
    int    dy,
    RECT   *prcSrc,
    RECT   *prcClip,
    HRGN   hrgnInvalid,
    HRGN   hrgnUpdate,
    LPRECT prcUpdate,
    BOOL   fLogUnits)
{
    RECT  rcVis;
    RECT  rcSrc;
    RECT  rcClip;
    RECT  rcUnclippedSrc;
    RECT  rcDst;
    RECT  rcUpdate;
    RECT  rcValid;
    BOOL  fSrcNotEmpty;
    BOOL  fHaveVisRgn;
    POINT rgpt[2];
    int   dxLog;
    int   dyLog;
    int   wClip;
    int   wClipValid;
    BOOL  bMirroredDC=FALSE;

    fHaveVisRgn = FALSE;

    /*
     * Enter a critical region to ensure that no one changes visrgns
     * or update regions while we scroll bits around.
     */
    GreLockDisplay(gpDispInfo->hDev);

    if ((wClip = GreGetClipBox(hdc, &rcVis, TRUE)) == ERROR) {

ErrorExit:

        GreUnlockDisplay(gpDispInfo->hDev);
        return ERROR;
    }

    CopyRect(&rcSrc, (prcSrc) ? prcSrc : &rcVis);
    if (prcClip) {
        CopyRect(&rcClip, prcClip);
    }

    dxLog = dx;
    dyLog = dy;

    if (fLogUnits) {

        /*
         * Convert input parameters to device coordinates
         */
        GreLPtoDP(hdc, (LPPOINT)&rcVis, 2);
        GreLPtoDP(hdc, (LPPOINT)&rcSrc, 2);

        //
        // Since this is a mirrored DC, then the resulting
        // device coord will be flowing from right to left
        // (i.e. rc.right < rc.left) so they should be flipped.
        // [samera]
        //
        if (GreGetLayout(hdc) & LAYOUT_RTL) {
            int iTemp   = rcVis.left;
            rcVis.left  = rcVis.right;
            rcVis.right = iTemp;

            iTemp       = rcSrc.left;
            rcSrc.left  = rcSrc.right;
            rcSrc.right = iTemp;

            bMirroredDC = TRUE;
        }

        if (prcClip) {
            GreLPtoDP(hdc, (LPPOINT)&rcClip, 2);

            //
            // Since this is a mirrored DC, then the resulting
            // device coord will be flowing from right to left
            // (i.e. rc.right < rc.left) so they should be flipped.
            // [samera]
            //
            if (bMirroredDC) {
                int iTemp    = rcClip.left;
                rcClip.left  = rcClip.right;
                rcClip.right = iTemp;
            }
        }

        /*
         * The delta values must be treated as a vector from
         * the point (0, 0) to (dx, dy).  Scale it as such, then
         * compute the difference.  This handles flipped coordinate systems.
         */
        rgpt[0].x = rgpt[0].y = 0;
        rgpt[1].x = dx;
        rgpt[1].y = dy;

        GreLPtoDP(hdc, rgpt, 2);

        dx = rgpt[1].x - rgpt[0].x;
        dy = rgpt[1].y - rgpt[0].y;
    }

    switch (wClip) {
    case NULLREGION:

NullExit:

        if (hrgnUpdate && !SetEmptyRgn(hrgnUpdate))
            goto ErrorExit;

        if (prcUpdate) {
            SetRectEmpty(prcUpdate);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
        return NULLREGION;

    case COMPLEXREGION:
        GetTrueClipRgn(hdc, ghrgnScrlVis);
        fHaveVisRgn = TRUE;
        break;
    }

    /*
     * First compute the source and destination rectangles.
     *
     * rcDst = Offset(rcSrc, dx, dy)
     */
    rcDst.left   = rcSrc.left   + dx;
    rcDst.right  = rcSrc.right  + dx;
    rcDst.top    = rcSrc.top    + dy;
    rcDst.bottom = rcSrc.bottom + dy;

    /*
     * If necessary, intersect with caller-supplied clip rect.
     */
    if (prcClip) {

        if ((wClip == SIMPLEREGION) &&
            ((hrgnInvalid == NULL) || (hrgnInvalid == HRGN_FULL))) {

            /*
             * Simple clip region: just a rect intersection
             */
            if (!IntersectRect(&rcVis, &rcVis, &rcClip))
                goto NullExit;

        } else {

            if (!fHaveVisRgn) {

                if (GetTrueClipRgn(hdc, ghrgnScrlVis) == ERROR)
                    goto ErrorExit;

                fHaveVisRgn = TRUE;
            }

            SetRectRgnIndirect(ghrgnScrl1, &rcClip);
            wClip = IntersectRgn(ghrgnScrlVis, ghrgnScrl1, ghrgnScrlVis);
            switch (wClip) {
            case ERROR:
                goto ErrorExit;

            case NULLREGION:
                goto NullExit;

            case SIMPLEREGION:

                /*
                 * If the clipped region is simple, we're back in fat
                 * rect city.
                 */
                GreGetRgnBox(ghrgnScrlVis, &rcVis);
                break;

            case COMPLEXREGION:
                break;
            }
        }
    }

    /*
     * Time for basic scrolling area calculations:
     *
     * Dst    = Offset(Src, dx, dy) & Vis
     * Src    = Src & Vis
     * Valid  = Offset(Src, dx, dy) & Dst
     * Valid  = Valid & Invalid & Offset(Invalid, dx, dy)
     * Update = (Src | Dst) - Valid
     *
     * If the vis region is simple, then we know that the valid region
     * will be rectangular.
     *
     * The rectangular calculation case can only deal with
     * ghrgnInvalid == NULL or (HRGN)1: the region case is handled the hard way.
     */
    if ((wClip == SIMPLEREGION) &&
            ((hrgnInvalid == NULL) || (hrgnInvalid == HRGN_FULL))) {

        /*
         * Save a copy of this for update rect calc optimization.
         */
        CopyRect(&rcUnclippedSrc, &rcSrc);

        /*
         * Dst = Offset(Src, dx, dy) & Vis.
         */
        IntersectRect(&rcDst, &rcDst, &rcVis);

        /*
         * Src = Src & Vis.
         */
        fSrcNotEmpty = IntersectRect(&rcSrc, &rcSrc, &rcVis);

        /*
         * Valid = Offset(Src, dx, dy) & Dst.
         */
        if (hrgnInvalid == HRGN_FULL) {
            SetRectEmpty(&rcValid);
        } else {

            rcValid.left   = rcSrc.left   + dx;
            rcValid.right  = rcSrc.right  + dx;
            rcValid.top    = rcSrc.top    + dy;
            rcValid.bottom = rcSrc.bottom + dy;

            IntersectRect(&rcValid, &rcValid, &rcDst);
        }

        /*
         * Now calculate the update area.
         *
         * There are two cases where the result will be a rectangle:
         *
         * 1) The source rectangle lies completely within the visrgn,
         *    and the source and destination don't overlap.  In this
         *    case the update region is equal to the source rect.
         *
         * 2) The clipped source rectangle is empty, in which case
         *    the update region is equal to the clipped dest rect.
         *
         * 3) We're scrolling in one dimension only, and the source
         *    and destination DO overlap.  In this case we can use
         *    UnionRect() and SubtractRect() to do the area arithmetic.
         */
        if (!fSrcNotEmpty) {

            /*
             * Clipped source is empty.  Update area is the clipped dest.
             */
            CopyRect(&rcUpdate, &rcDst);
            goto RectUpdate;

        } else if (IntersectRect(&rcUpdate, &rcSrc, &rcDst)) {

            /*
             * They overlap.  If we're scrolling in one dimension only
             * then we can use rect arithmetic...
             */
            if (dx == 0 || dy == 0) {

                UnionRect(&rcUpdate, &rcSrc, &rcDst);
                SubtractRect(&rcUpdate, &rcUpdate, &rcValid);
                goto RectUpdate;
            }

        } else if (EqualRect(&rcSrc, &rcUnclippedSrc)) {

            /*
             * They don't overlap, and the source lies completely
             * within the visible region.  Update region is the source.
             */
            CopyRect(&rcUpdate, &rcSrc);
RectUpdate:
            if (prcUpdate) {
                CopyRect(prcUpdate, &rcUpdate);
            }

            if (hrgnUpdate && !SetRectRgnIndirect(hrgnUpdate, &rcUpdate)) {
                goto ErrorExit;
            }

            wClip = SIMPLEREGION;
            if (rcUpdate.left >= rcUpdate.right ||
                rcUpdate.top >= rcUpdate.bottom)

                wClip = NULLREGION;

            goto DoRectBlt;
        }

        /*
         * The update region isn't rectangular.  Need to do our
         * area calculations with region calls.  Skip all this
         * if the caller doesn't care about the update region.
         *
         * If he wants a rectangle but no region, use ghrgnScrl2 as a temp.
         */
        if (hrgnUpdate == NULL && prcUpdate) {
            hrgnUpdate = ghrgnScrl2;
        }

        if (hrgnUpdate != NULL) {

            /*
             * hrgnUpdateCalc = (rcSrc | rcDst) - rcBltDst
             */
            SetRectRgnIndirect(ghrgnScrl1, &rcSrc);
            SetRectRgnIndirect(hrgnUpdate, &rcDst);
            if (UnionRgn(hrgnUpdate, hrgnUpdate, ghrgnScrl1) == ERROR)
                goto ErrorExit;

            SetRectRgnIndirect(ghrgnScrl1, &rcValid);
            wClip = SubtractRgn(hrgnUpdate, hrgnUpdate, ghrgnScrl1);
            if (wClip == ERROR)
                goto ErrorExit;

            if (prcUpdate) {
                GreGetRgnBox(hrgnUpdate, prcUpdate);
            }
        }

DoRectBlt:

        /*
         * If the valid rectangle's not empty, then copy those bits...
         */
        if (rcValid.left < rcValid.right && rcValid.top < rcValid.bottom) {

            /*
             * If the DC is in a funny map mode, then be sure to map from
             * device to logical coordinates for BLT call...
             */
            if (fLogUnits)
                GreDPtoLP(hdc, (LPPOINT)&rcValid, 2);

            GreBitBlt(hdc,
                      rcValid.left,
                      rcValid.top,
                      rcValid.right - rcValid.left,
                      rcValid.bottom - rcValid.top,
                      hdc,
                      rcValid.left - dxLog,
                      rcValid.top - dyLog,
                      SRCCOPY,
                      0);
        }

    } else {

        /*
         * Get the true visrgn if we haven't already.
         */
        if (!fHaveVisRgn) {

            if (GetTrueClipRgn(hdc, ghrgnScrlVis) == ERROR)
                goto ErrorExit;

            fHaveVisRgn = TRUE;
        }

        /*
         * The visrgn is not empty.  Need to do all our calculations
         * with regions.
         *
         * hrgnSrc = hrgnSrc & ghrgnScrlVis
         */
        SetRectRgnIndirect(ghrgnScrlSrc, &rcSrc);
        if (IntersectRgn(ghrgnScrlSrc, ghrgnScrlSrc, ghrgnScrlVis) == ERROR)
            goto ErrorExit;

        /*
         * hrgnDst = hrgnDst & ghrgnScrlVis
         */
        SetRectRgnIndirect(ghrgnScrlDst, &rcDst);
        if (IntersectRgn(ghrgnScrlDst, ghrgnScrlDst, ghrgnScrlVis) == ERROR)
            goto ErrorExit;

        /*
         * Now compute the valid region:
         *
         * Valid = Offset(Src, dx, dy) & Dst.
         * Valid = Valid & Invalid & Offset(Invalid, dx, dy)
         *
         * If hrgnInvalid is (HRGN)1, then the valid area is empty.
         */
        wClipValid = NULLREGION;
        if (hrgnInvalid != HRGN_FULL) {

            /*
             * Valid = Offset(Src, dx, dy) & Dst
             */
            if (CopyRgn(ghrgnScrlValid, ghrgnScrlSrc) == ERROR)
                goto ErrorExit;

            GreOffsetRgn(ghrgnScrlValid, dx, dy);
            wClipValid = IntersectRgn(ghrgnScrlValid,
                                      ghrgnScrlValid,
                                      ghrgnScrlDst);

            /*
             * Valid = Valid - Invalid - Offset(Invalid, dx, dy)
             * We need bother only if hrgnInvalid is a real region.
             */
            if (hrgnInvalid > HRGN_FULL) {

                if (wClipValid != ERROR && wClipValid != NULLREGION) {
                    POINT pt;

                    GetDCOrgOnScreen(hdc, &pt);

                    /*
                     * hrgnInvalid is in screen coordinates: map to dc coords
                     */
                    CopyRgn(ghrgnScrl2, hrgnInvalid);
                    GreOffsetRgn(ghrgnScrl2, -pt.x, -pt.y);

                    wClipValid = SubtractRgn(ghrgnScrlValid,
                                             ghrgnScrlValid,
                                             ghrgnScrl2);
                }

                if (wClipValid != ERROR && wClipValid != NULLREGION) {
                    GreOffsetRgn(ghrgnScrl2, dx, dy);

                    wClipValid = SubtractRgn(ghrgnScrlValid,
                                             ghrgnScrlValid,
                                             ghrgnScrl2);
                }
            }

            if (wClipValid == ERROR)
                goto ErrorExit;
        }

        /*
         * If he wants a rectangle but no region, use ghrgnScrl2 as a temp.
         */
        if (hrgnUpdate == NULL && prcUpdate) {
            hrgnUpdate = ghrgnScrl2;
        }

        if (hrgnUpdate != NULL) {

            /*
             * Update = (Src | Dst) - Valid.
             */
            wClip = UnionRgn(hrgnUpdate, ghrgnScrlDst, ghrgnScrlSrc);
            if (wClip == ERROR)
                goto ErrorExit;

            if (wClipValid != NULLREGION) {
                wClip = SubtractRgn(hrgnUpdate, hrgnUpdate, ghrgnScrlValid);
            }

            if (prcUpdate) {
                GreGetRgnBox(hrgnUpdate, prcUpdate);
            }
        }

        if (wClipValid != NULLREGION) {

            #ifdef LATER

                /*
                 * don't use the visrgn here
                 */
                HRGN hrgnSaveVis = CreateEmptyRgn();
                if (hrgnSaveVis != NULL) {

                    BOOL fClipped;

                    fClipped = (GreGetRandomRgn(hdc, hrgnSaveVis, 1) == 1);
                    GreExtSelectClipRgn(hdc, ghrgnScrlValid, RGN_COPY);

                    /*
                     * If the DC is in a funny map mode, then be sure to
                     * map from device to logical coordinates for BLT call...
                     */
                    if (fLogUnits)
                        GreDPtoLP(hdc, (LPPOINT)&rcDst, 2);

                    /*
                     * Gdi can take along time to process this call if
                     * it's a printer DC
                     */
                    GreBitBlt(hdc,
                              rcDst.left,
                              rcDst.top,
                              rcDst.right - rcDst.left,
                              rcDst.bottom - rcDst.top,
                              hdc,
                              rcDst.left - dxLog,
                              rcDst.top - dyLog,
                              SRCCOPY,
                              0);

                    GreExtSelectClipRgn(hdc,
                                        (fClipped ? hrgnSaveVis : NULL),
                                        RGN_COPY);

                    GreDeleteObject(hrgnSaveVis);
                }

            #else

                /*
                 * Visrgn is expected in DC surface coordinates: offset
                 * as appropriate.
                 */
                POINT pt;
                GreGetDCOrg(hdc, &pt);

                GreOffsetRgn(ghrgnScrlValid, pt.x, pt.y);

                /*
                 * Select in the temporary vis rgn, saving the old
                 */

                GreSelectVisRgn(hdc, ghrgnScrlValid, SVR_SWAP);

                /*
                 * If the DC is in a funny map mode, then be sure to map from
                 * device to logical coordinates for BLT call...
                 */
                if (fLogUnits)
                    GreDPtoLP(hdc, (LPPOINT)&rcDst, 2);

                /*
                 * Gdi can take along time to process this call if it's
                 * a printer DC.
                 */
                GreBitBlt(hdc,
                          rcDst.left,
                          rcDst.top,
                          rcDst.right - rcDst.left,
                          rcDst.bottom - rcDst.top,
                          hdc,
                          rcDst.left - dxLog,
                          rcDst.top - dyLog,
                          SRCCOPY,
                          0);

                /*
                 * Restore the old vis rgn, leaving ghrgnScrlValid with
                 * a valid rgn
                 */
                GreSelectVisRgn(hdc, ghrgnScrlValid, SVR_SWAP);

            #endif
        }
    }

    /*
     * If necessary, convert the resultant update rect back
     * to logical coordinates.
     */
    if (fLogUnits && prcUpdate) {
        GreDPtoLP(hdc, (LPPOINT)prcUpdate, 2);
    }

    GreUnlockDisplay(gpDispInfo->hDev);

    return wClip;
}

/***************************************************************************\
* _ScrollDC (API)
*
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL _ScrollDC(
    HDC    hdc,
    int    dx,
    int    dy,
    LPRECT prcSrc,
    LPRECT prcClip,
    HRGN   hrgnUpdate,
    LPRECT prcUpdate)
{
    RECT rcSrc;
    RECT rcSpb;
    PWND pwnd;
    HRGN hrgnInvalid;
    BOOL fRet;

    /*
     * ScrollDC does not scroll update region. Under WinNT, an app calling
     * GetUpdateRgn() then ScrollDC() then InvalidateRgn() will not get
     * any new update region that happened between the Get and Scroll. Under
     * Win3.1, that was not a problem because no other app ran during this
     * time. So pass hrgnInvalid - this will affect the hrgnUpdate and
     * prcUpdate values being returned from ScrollDC with the update region.
     */
    hrgnInvalid = NULL;
    if ((pwnd = FastWindowFromDC(hdc)) != NULL) {

        hrgnInvalid = pwnd->hrgnUpdate;

        if (hrgnInvalid == HRGN_FULL) {

            /*
             * This is a fix for winhell, a performance testing app
             * written by some guy working for a windows magazine.
             * this app scrolls it's window while it is completely
             * invalid.  We normaly won't scroll invalid bits but
             * but we make the exception here
             */
            hrgnInvalid = NULL;
        }
    }

    fRet = InternalScrollDC(hdc,
                            dx,
                            dy,
                            prcSrc,
                            prcClip,
                            hrgnInvalid,
                            hrgnUpdate,
                            prcUpdate,
                            TRUE) != ERROR;

    /*
     * InternalScrollDC() only scrolls those areas inside the visible region.
     * This means it does no operations on parts of the window if the window
     * isn't visible. This means SPBs don't get properly invalidated. This
     * could be seen by starting a dir, then moving another window with the
     * mouse (and keeping the mouse down until the dir finished). The
     * screen is remembered with an SPB, and the dir window doesn't get
     * properly invalidated because of this.
     */
    if (pwnd != NULL && AnySpbs()) {

        if (prcSrc) {

            rcSrc = *prcSrc;
            OffsetRect(&rcSrc, pwnd->rcClient.left, pwnd->rcClient.top);

            rcSpb = rcSrc;
            OffsetRect(&rcSpb, dx, dy);
            UnionRect(&rcSpb, &rcSpb, &rcSrc);

        } else {
            rcSpb = pwnd->rcClient;
        }

        SpbCheckRect(pwnd, &rcSpb, 0);
    }

    return fRet;
}

/***************************************************************************\
* ScrollWindowEx (API)
*
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
int xxxScrollWindowEx(
    PWND    pwnd,
    int    dx,
    int    dy,
    RECT   *prcScroll,
    RECT   *prcClip,
    HRGN   hrgnUpdate,
    LPRECT prcUpdate,
    DWORD  flags)
{
    INT    code;
    HDC    hdc;
    int    dxDev;
    int    dyDev;
    RECT   rcSrcDev;
    RECT   rcSpb, rcSrc;
    DWORD  flagsDCX;
    BOOL   fHideCaret;
    BOOL   fRcScroll = (prcScroll != NULL);
    BOOL   fInvisible = FALSE;
    PCARET pcaret;
    POINT  pt;
    TL     tlpwndChild;
    HRGN   hrgnInvalid;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());


    if (pwnd == NULL)
        pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;       // pwndDesktop

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        dx = -dx;

        MirrorRegion(pwnd, hrgnUpdate, TRUE);

        if(prcScroll) {
            MirrorClientRect(pwnd, prcScroll);
        }

        if (prcClip) {
            MirrorClientRect(pwnd, prcClip);
        }
    }

    /*
     * If nothing's moving, nothing to do.
     */
    if ((dx | dy) == 0 ) {

        goto DoNothing;

    } else if (!IsVisible(pwnd)) {

        /* We want to offset our children if we're not minimized.  IsVisible()
         * will return FALSE if we're minimized, invisible, or the child of
         * a minimized/invisible ancestore.
         */
        if (!TestWF(pwnd, WFMINIMIZED) &&
          (flags & SW_SCROLLCHILDREN) &&
          !fRcScroll) {

            fInvisible = TRUE;
            flags &= ~SW_INVALIDATE;
        }

DoNothing:

        if (hrgnUpdate) {
            SetEmptyRgn(hrgnUpdate);
        }

        if (prcUpdate) {
            SetRectEmpty(prcUpdate);
        }

        if (!fInvisible)
            return NULLREGION;
    }

    /*
     * Hide the caret.
     */
    fHideCaret = FALSE;

    if (!fInvisible) {
        pcaret = &ptiCurrent->pq->caret;
        if (pcaret->spwnd != NULL && _IsDescendant(pcaret->spwnd, pwnd)) {
            fHideCaret = TRUE;
            zzzInternalHideCaret();
        }
    }

    /*
     * If scrollwindow, and window is clipchildren, use a cache entry.
     * Otherwise, always use a
     *
     * Determine what kind of DC we'll be needing.  If the DCX_CACHE bit
     * isn't set, it means that we'll be operating in logical coordinates.
     */
    if (flags & SW_SCROLLWINDOW) {

        /*
         *  ScrollWindow() call: use the cache if not OWNDC or CLASSDC.
         */
        flagsDCX = DCX_USESTYLE;
        if (!TestCF(pwnd, CFOWNDC) && !TestCF(pwnd, CFCLASSDC))
            flagsDCX |= DCX_CACHE;

        /*
         * If SW_SCROLLCHILDREN (i.e., lprcScroll == NULL) and CLIPCHILDREN,
         * then use the cache and don't clip children.
         * This is screwy, but 3.0 backward compatible.
         */
        if ((flags & SW_SCROLLCHILDREN) && TestWF(pwnd, WFCLIPCHILDREN))
            flagsDCX |= DCX_NOCLIPCHILDREN | DCX_CACHE;

    } else {

        /*
         * ScrollWindowEx() call: always use the cache
         */
        flagsDCX = DCX_USESTYLE | DCX_CACHE;

        /*
         * if SW_SCROLLCHILDREN, always use noclipchildren.
         */
        if (flags & SW_SCROLLCHILDREN)
            flagsDCX |= DCX_NOCLIPCHILDREN;
    }

    flagsDCX |= DCX_NOMIRROR;
    hdc = _GetDCEx(pwnd, NULL, flagsDCX);

    if (flags & SW_INVALIDATE) {

        /*
         * Get device origin while DC is valid, for later offsetting
         */
        GetDCOrgOnScreen(hdc, &pt);

        /*
         * If the user didn't give us a region to use, use ghrgnSW.
         */
        if (hrgnUpdate == NULL)
            hrgnUpdate = ghrgnSW;
    }

    /*
     * The DC will be in some logical coordinate system if OWNDC or CLASSDC.
     */
    if (!fRcScroll) {
        prcScroll = &rcSrc;

        /*
         * IMPORTANT:
         * We have to use CopyOffsetRect() here because GetClientRect() gives
         * unreliable results for minimized windows.  3.1 dudes get told that
         * their client is non-empty, for compatibility reasons.
         */
        GetRect(pwnd, &rcSrc, GRECT_CLIENT | GRECT_CLIENTCOORDS);

        /*
         * If the DC might be a screwy one, then map the
         * rect to logical units.
         */
        if (!(flagsDCX & DCX_CACHE))
            GreDPtoLP(hdc, (LPPOINT)&rcSrc, 2);
    }

    /*
     * If the DC is in logical coordinates, map *prcScroll and dx, dy
     * to device units for use later.
     */
    dxDev = dx;
    dyDev = dy;
    rcSrcDev = *prcScroll;

    if (!(flagsDCX & DCX_CACHE)) {

        POINT rgpt[2];

        GreLPtoDP(hdc, (POINT FAR*)&rcSrcDev, 2);

        /*
         * The delta values must be treated as a vector from
         * the point (0, 0) to (dx, dy).  Scale it as such, then
         * compute the difference.  This handles flipped coordinate systems.
         */
        rgpt[0].x = rgpt[0].y = 0;
        rgpt[1].x = dx;
        rgpt[1].y = dy;

        GreLPtoDP(hdc, rgpt, 2);

        dxDev = rgpt[1].x - rgpt[0].x;
        dyDev = rgpt[1].y - rgpt[0].y;
    }

    if (fInvisible)
        code = NULLREGION;
    else {
        hrgnInvalid = pwnd->hrgnUpdate;
        if ((flags & SW_SCROLLWINDOW) && !TestWF(pwnd, WFWIN31COMPAT)) {
            /*
             * 3.0 Backward compatibility hack:
             * The following incorrect code is what 3.0 used to do, and
             * there are apps such as Finale and Scrapbook+ that have worked
             * around this bug in ways that don't work with the "correct" code.
             */
            if (pwnd->hrgnUpdate > HRGN_FULL) {
                RECT rc;

                GreGetRgnBox(pwnd->hrgnUpdate, &rc);
                OffsetRect(&rc,
                           dxDev - pwnd->rcClient.left,
                           dyDev - pwnd->rcClient.top);

                xxxRedrawWindow(pwnd,
                                &rc, NULL,
                                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            }
            hrgnInvalid = NULL;
        }

        code = InternalScrollDC(hdc,
                                dx,
                                dy,
                                prcScroll,
                                prcClip,
                                hrgnInvalid,
                                hrgnUpdate,
                                prcUpdate,
                                !(flagsDCX & DCX_CACHE));
        if (prcUpdate && TestWF(pwnd, WEFLAYOUTRTL)) {
            MirrorClientRect(pwnd, prcUpdate);
        }
    }

    /*
     * Release the hdc we used.
     */
    _ReleaseDC(hdc);

    /*
     * Check the union of the src and dst rectangle against any SPBs.
     * We do this because the window
     * might be completely obscured by some window with an SPB, but
     * since we're completely covered no BitBlt call will be made
     * to accumulate bounds in that area.
     */
    if (!fInvisible && AnySpbs()) {

        if (fRcScroll) {
            if (pwnd == PWNDDESKTOP(pwnd)) {
                rcSrc = rcSrcDev;
            } else {
                CopyOffsetRect(
                        &rcSrc,
                        &rcSrcDev,
                        pwnd->rcClient.left,
                        pwnd->rcClient.top);
            }

            rcSpb = rcSrc;
            OffsetRect(&rcSpb, dxDev, dyDev);
            UnionRect(&rcSpb, &rcSpb, &rcSrc);

        } else {

            /*
             * Use the entire client area.
             */
            rcSpb = pwnd->rcClient;
        }

        SpbCheckRect(pwnd, &rcSpb, 0);
    }

    /*
     * If this guy wants to scroll his children, go at it.  Only scroll those
     * children intersecting prcScroll.  Then invalidate any vis rgns
     * calculated for these child windows.
     */
    if (flags & SW_SCROLLCHILDREN) {

        RECT rc;

        /*
         * If this window has the caret then offset it if:
         * a) The whole window is scrolling
         * b) The rectangle scrolled contains the caret rectangle
         */
        if (!fInvisible && (pwnd == pcaret->spwnd)) {

            if (fRcScroll)
                SetRect(&rc,
                        pcaret->x,
                        pcaret->y,
                        pcaret->x + pcaret->cx,
                        pcaret->y + pcaret->cy);

            if (!fRcScroll || IntersectRect(&rc, &rc, &rcSrcDev)) {
                pcaret->x += dxDev;
                pcaret->y += dyDev;
            }
        }

        if (fRcScroll) {

            /*
             * Create a copy of prcScroll and map to absolute coordinates...
             */
            if (pwnd == PWNDDESKTOP(pwnd)) {
                CopyRect(&rc, &rcSrcDev);
            } else {
                CopyOffsetRect(
                        &rc,
                        &rcSrcDev,
                        pwnd->rcClient.left,
                        pwnd->rcClient.top);
            }
        }

        if (pwnd->spwndChild) {

            OffsetChildren(pwnd,
                           dxDev,
                           dyDev,
                           (fRcScroll ? (LPRECT)&rc : NULL));

            /*
             * If we're clipchildren, then shuffling our children
             * will affect our client visrgn (but not our window visrgn).
             * Otherwise, only our children's
             * visrgns were affected by the scroll.
             * No need to DeferWinEventNotify() judging by xxxInternalInvalidate() below
             */
            zzzInvalidateDCCache(pwnd,
                              TestWF(pwnd, WFCLIPCHILDREN) ?
                                  IDC_CLIENTONLY : IDC_CHILDRENONLY);

        }
    }

    if (flags & SW_INVALIDATE) {

        /*
         * If the caller supplied a region, invalidate using a copy,
         * because InternalInvalidate may trash the passed-in region.
         */
        if (hrgnUpdate != ghrgnSW)
            CopyRgn(ghrgnSW, hrgnUpdate);

        /*
         * Make ghrgnSW screen-relative before invalidation...
         */
        GreOffsetRgn(ghrgnSW, pt.x, pt.y);

        xxxInternalInvalidate(
                pwnd,
                ghrgnSW,
                (flags & SW_ERASE) ?
                    (RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE) :
                    (RDW_INVALIDATE | RDW_ALLCHILDREN));
    }

    /*
     * Send child move messages if needed.
     */
    if (flags & SW_SCROLLCHILDREN) {

        PWND pwndChild;
        RECT rc;
        RECT rcScrolledChildren;

        /*
         * NOTE: the following code will send MOVE messages
         * to windows that didn't move but were in the source rectangle.
         * This is not a big deal, and definitely not worth fixing.
         */
        if (fRcScroll) {
            if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
                CopyOffsetRect(&rcScrolledChildren, &rcSrcDev, dxDev, dyDev);
            } else {
                CopyOffsetRect(
                        &rcScrolledChildren,
                        &rcSrcDev,
                        dxDev + pwnd->spwndParent->rcClient.left,
                        dyDev + pwnd->spwndParent->rcClient.top);
            }
        }

        ThreadLockNever(&tlpwndChild);
        pwndChild = pwnd->spwndChild;
        while (pwndChild != NULL) {

            if (    !fRcScroll ||
                    IntersectRect(&rc, &rcScrolledChildren, &pwndChild->rcWindow)) {

                /*
                 * NOTE: Win 3.0 and below passed wParam == TRUE here.
                 * This was not documented or used, so it was changed
                 * to be consistent with the documentation.
                 */
                ThreadLockExchangeAlways(pwndChild, &tlpwndChild);
                xxxSendMessage(
                        pwndChild,
                        WM_MOVE,
                        0,
                        (pwnd == PWNDDESKTOP(pwnd)) ?
                            MAKELONG(pwndChild->rcClient.left, pwndChild->rcClient.top) :
                            MAKELONG(pwndChild->rcClient.left - pwnd->rcClient.left,
                                     pwndChild->rcClient.top - pwnd->rcClient.top));
            }

            pwndChild = pwndChild->spwndNext;
        }

        ThreadUnlock(&tlpwndChild);
    }

    if (fHideCaret) {

        /*
         * Show the caret again.
         */
        zzzInternalShowCaret();
    }

    /*
     * Return the region code.
     */
    return code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\security.c ===
/**************************** Module Header ********************************\
* Module Name: security.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Securable Object Routines
*
* History:
* 12-31-90 JimA       Created.
* 04-14-92 RichardW   Changed ACE_HEADER
\***************************************************************************/

#define _SECURITY 1
#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(INIT, InitSecurity)

/*
 * General security stuff
 */
PSECURITY_DESCRIPTOR gpsdInitWinSta;

PRIVILEGE_SET psTcb = { 1, PRIVILEGE_SET_ALL_NECESSARY,
    { SE_TCB_PRIVILEGE, 0 }
};

/***************************************************************************\
* AllocAce
*
* Allocates and initializes an ACE list.
*
* History:
* 04-25-91 JimA         Created.
\***************************************************************************/

PACCESS_ALLOWED_ACE AllocAce(
    PACCESS_ALLOWED_ACE pace,
    BYTE bType,
    BYTE bFlags,
    ACCESS_MASK am,
    PSID psid,
    LPDWORD lpdwLength)
{
    PACCESS_ALLOWED_ACE paceNew;
    DWORD iEnd;
    DWORD dwLength, dwLengthSid;

    /*
     * Allocate space for the ACE.
     */
    dwLengthSid = RtlLengthSid(psid);
    dwLength = dwLengthSid + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
    if (pace == NULL) {
        iEnd = 0;
        pace = UserAllocPoolWithQuota(dwLength, TAG_SECURITY);
        if (pace == NULL)
            return NULL;
    } else {
        iEnd = *lpdwLength;
        paceNew = UserAllocPoolWithQuota(iEnd + dwLength, TAG_SECURITY);
        if (paceNew == NULL)
            return NULL;
        RtlCopyMemory(paceNew, pace, iEnd);
        UserFreePool(pace);
        pace = paceNew;
    }
    *lpdwLength = dwLength + iEnd;

    /*
     * Insert the new ACE.
     */
    paceNew = (PACCESS_ALLOWED_ACE)((PBYTE)pace + iEnd);
    paceNew->Header.AceType = bType;
    paceNew->Header.AceSize = (USHORT)dwLength;
    paceNew->Header.AceFlags = bFlags;
    paceNew->Mask = am;
    RtlCopySid(dwLengthSid, &paceNew->SidStart, psid);
    return pace;
}

/***************************************************************************\
* CreateSecurityDescriptor
*
* Allocates and initializes a security descriptor.
*
* History:
* 04-25-91 JimA         Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR CreateSecurityDescriptor(
    PACCESS_ALLOWED_ACE paceList,
    DWORD cbAce,
    BOOLEAN fDaclDefaulted)
{
    PSECURITY_DESCRIPTOR psd;
    PACL pacl;
    NTSTATUS Status;

    /*
     * Allocate the security descriptor
     */
    psd = (PSECURITY_DESCRIPTOR)UserAllocPoolWithQuota(
            cbAce + sizeof(ACL) + SECURITY_DESCRIPTOR_MIN_LENGTH,
            TAG_SECURITY);
    if (psd == NULL)
        return NULL;
    RtlCreateSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);

    /*
     * Initialize the ACL
     */
    pacl = (PACL)((PBYTE)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);
    Status = RtlCreateAcl(pacl, sizeof(ACL) + cbAce, ACL_REVISION);
    if (NT_SUCCESS(Status)) {

        /*
         * Add the ACEs to the ACL.
         */
        Status = RtlAddAce(pacl, ACL_REVISION, MAXULONG, paceList, cbAce);
        if (NT_SUCCESS(Status)) {

            /*
             * Initialize the SD
             */
            Status = RtlSetDaclSecurityDescriptor(psd, (BOOLEAN)TRUE,
                    pacl, fDaclDefaulted);
            RtlSetSaclSecurityDescriptor(psd, (BOOLEAN)FALSE, NULL,
                    (BOOLEAN)FALSE);
            RtlSetOwnerSecurityDescriptor(psd, NULL, (BOOLEAN)FALSE);
            RtlSetGroupSecurityDescriptor(psd, NULL, (BOOLEAN)FALSE);
        }
    }

    if (!NT_SUCCESS(Status)) {
        UserFreePool(psd);
        return NULL;
    }

    return psd;
}

/***************************************************************************\
* InitSecurity
*
* Initialize global security information.
*
* History:
* 01-29-91 JimA         Created.
\***************************************************************************/

BOOL InitSecurity(
    VOID)
{
    PACCESS_ALLOWED_ACE paceList = NULL, pace;
    DWORD dwLength;

    /*
     * Create ACE list.
     */
    paceList = AllocAce(NULL,
            ACCESS_ALLOWED_ACE_TYPE,
            CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            WinStaMapping.GenericAll,
            SeExports->SeWorldSid,
            &dwLength);
    if (paceList == NULL)
        return FALSE;

    pace = AllocAce(paceList,
            ACCESS_ALLOWED_ACE_TYPE,
            CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            WinStaMapping.GenericAll,
            SeExports->SeRestrictedSid,
            &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE,
            GENERIC_ALL, SeExports->SeWorldSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE,
            GENERIC_ALL, SeExports->SeRestrictedSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            0, DIRECTORY_QUERY | DIRECTORY_CREATE_OBJECT,
            SeExports->SeAliasAdminsSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            0, DIRECTORY_TRAVERSE, SeExports->SeWorldSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            0, DIRECTORY_TRAVERSE, SeExports->SeRestrictedSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    /*
     * Create the SD
     */
    gpsdInitWinSta = CreateSecurityDescriptor(paceList, dwLength, FALSE);
    UserFreePool(paceList);

    if (gpsdInitWinSta == NULL) {
        RIPMSG0(RIP_WARNING, "Initial windowstation security was not created!");
    }

    return (BOOL)(gpsdInitWinSta != NULL);
}


/***************************************************************************\
* TestForInteractiveUser
*
* Returns STATUS_SUCCESS if the LUID passed represents an
* interactiveUser user logged on by winlogon, otherwise FALSE
*
* History:
* 03-08-95 JimA         Created.
\***************************************************************************/

NTSTATUS
TestForInteractiveUser(
    PLUID pluidCaller
    )
{
    PWINDOWSTATION pwinsta;

    UserAssert(grpWinStaList != NULL);

    /*
     * !!!
     *
     * This relies on the fact that there is only ONE interactive
     * windowstation and that it is the first one in the list.
     * If multiple windowstations are ever supported
     * a lookup will have to be done here.
     */
    pwinsta = grpWinStaList;

    /*
     * Compare it with the id of the logged on user.
     */
    if (RtlEqualLuid(pluidCaller, &pwinsta->luidUser))
        return STATUS_SUCCESS;
    else
        return STATUS_ACCESS_DENIED;
}



/***************************************************************************\
* _UserTestForWinStaAccess
*
* Returns STATUS_SUCCESS if the current user has GENERIC_EXECUTE access on
* WindowStation pstrWinSta
*
*
* History:
* 06-05-96  Created     SalimC
* 01-02-02  Modified    Mohamed    Changed pstrWinSta to be a kernel mode address
*                                  and later copied to a dynamically allocated
*                                  user mode address.
\***************************************************************************/
NTSTATUS
_UserTestForWinStaAccess(
    PUNICODE_STRING pstrWinSta,
    BOOL fInherit
    )
{
    PTOKEN_STATISTICS   pStats;
    ULONG               BytesRequired;
    PWINDOWSTATION      pwinsta;
    HWINSTA             hwsta = NULL;
    POBJECT_ATTRIBUTES  pObjAttr = NULL;
    PUNICODE_STRING     pstrStatic;
    NTSTATUS            Status =  STATUS_SUCCESS;
    SIZE_T              cbObjA;
    UNICODE_STRING      strDefWinSta;
    HANDLE              htoken;
    BOOLEAN             fDefWinSta;

    CheckCritIn();

    /*
     * If we are testing against Default WindowStation (WinSta0) retreive
     * pwinsta from the top of the grpwinstaList instead of doing an
     * _OpenWindowStation.
     *
     * NOTE: This relies on the fact that there is only ONE interactive
     * windowstation and that it is the first one in the list. If multiple
     * windowstations are ever supported a lookup will have to be done
     * instead.
     */
    RtlInitUnicodeString(&strDefWinSta, DEFAULT_WINSTA);
    fDefWinSta = RtlEqualUnicodeString(pstrWinSta, &strDefWinSta, TRUE);

    if (fDefWinSta) {
        if (!NT_SUCCESS(Status = OpenEffectiveToken(&htoken))) {
            return Status;
        }

        Status = ZwQueryInformationToken(htoken,
                                         TokenStatistics,
                                         NULL,
                                         0,
                                         &BytesRequired);

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            ZwClose(htoken);
            return Status;
        }

        //
        // Allocate space for the user info
        //

        pStats = (PTOKEN_STATISTICS)UserAllocPoolWithQuota(BytesRequired, TAG_SECURITY);
        if (pStats == NULL) {
            Status = STATUS_NO_MEMORY;
            ZwClose(htoken);
            return Status;
        }

        //
        // Read in the user info
        //

        Status = ZwQueryInformationToken(htoken,
                                         TokenStatistics,
                                         pStats,
                                         BytesRequired,
                                         &BytesRequired);
        if (!NT_SUCCESS(Status)) {
            ZwClose(htoken);
            UserFreePool(pStats);
            return Status;
        }

        /*
         * Make sure that current process has access to this window station
         */
        Status = STATUS_ACCESS_DENIED;

        if (grpWinStaList != NULL) {

            /*
             * !!!
             *
             * This relies on the fact that there is only ONE interactive
             * windowstation and that it is the first one in the list.
             * If multiple windowstations are ever supported
             * a lookup will have to be done here.
             */
            pwinsta = grpWinStaList;

            /*
             * For now we will just do the user luid test till we figure out
             * what fInherit means for a Multi-User system
             */
            if (fInherit) {
                if ( (RtlEqualLuid(&pStats->AuthenticationId, &pwinsta->luidUser)) ||
                     (RtlEqualLuid(&pStats->AuthenticationId, &luidSystem)) ||
                     (AccessCheckObject(pwinsta, GENERIC_EXECUTE, UserMode, &WinStaMapping)) )  {
                   Status = STATUS_SUCCESS;
                }
            } else {
                /* Bug 42905. Service Controller clears the flag
                 * ScStartupInfo.dwFlags &= (~STARTF_DESKTOPINHERIT) to make services
                 * running under the context of system non-interactive. Hence if fInherit
                 * is false don't do the SystemLuid and AccessCheckObject tests.
                 */

                if (RtlEqualLuid(&pStats->AuthenticationId, &pwinsta->luidUser)) {
                   Status = STATUS_SUCCESS;
                }
            }
        }

        ZwClose(htoken);
        UserFreePool(pStats);
        return Status;
    }

    /*
     * Since we don't have a pointer to the WindowStation Object we will do
     * a _OpenWindowStation() to make sure we have the desired access.
     */
    cbObjA = sizeof(*pObjAttr) + sizeof(*pstrStatic) + STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
    Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
            &pObjAttr, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
    pstrStatic = (PUNICODE_STRING)((PBYTE)pObjAttr + sizeof(*pObjAttr));

    if (NT_SUCCESS(Status)) {

        /*
         * Note -- the string must be in client-space or the address
         * validation in _OpenWindowStation will fail.
         */
        try {
            pstrStatic->Length = 0;
            pstrStatic->MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
            pstrStatic->Buffer = (PWSTR)((PBYTE)pstrStatic + sizeof(*pstrStatic));
            RtlCopyUnicodeString(pstrStatic, pstrWinSta);
            InitializeObjectAttributes(pObjAttr,
                                       pstrStatic,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }

        if (NT_SUCCESS(Status)) {
            /*
             * In order to be able to verify access rights, we will pass
             * UserMode for KPROCESSOR_MODE. Passing KernelMode would bypass
             * all security checks. As a side-effect, hwsta is created
             * as a UserMode handle and is not a trusted/protected handle.
             */
            hwsta = _OpenWindowStation(pObjAttr, GENERIC_EXECUTE, UserMode);
        }
    } else {
        return Status;
    }

    if (pObjAttr != NULL) {
        ZwFreeVirtualMemory(NtCurrentProcess(), &pObjAttr, &cbObjA, MEM_RELEASE);
    }

    if (!hwsta) {
        return STATUS_ACCESS_DENIED;
    }

    Status = ObCloseHandle(hwsta, UserMode);

    UserAssert(NT_SUCCESS(Status));
    return Status;
}
/***************************************************************************\
* CheckGrantedAccess
*
* Confirms all requested accesses are granted and sets error status.
*
* History:
* 06-26-95 JimA       Created.
\***************************************************************************/

BOOL CheckGrantedAccess(
    ACCESS_MASK amGranted,
    ACCESS_MASK amRequest)
{

    /*
     * Check the granted access.
     */
    if (!RtlAreAllAccessesGranted(amGranted, amRequest)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* CheckWinstaWriteAttributesAccess
*
* Checks if the current process has WINSTA_WRITEATTRIBUTES access
* to its windowstation, and whether that windowstation is an
* interactive windowstation.
*
* History:
* 06-Jun-1996 adams     Created.
\***************************************************************************/
BOOL CheckWinstaWriteAttributesAccess(
    VOID)
{
    PPROCESSINFO ppiCurrent = PpiCurrent();

    /*
     * winlogon has rights to all windowstations.
     */
    if (PsGetCurrentProcessId() == gpidLogon)
        return TRUE;

    if (!(ppiCurrent->W32PF_Flags & W32PF_IOWINSTA)) {
        RIPERR0(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION,
                RIP_WARNING,
                "Operation invalid on a non-interactive WindowStation.");

        return FALSE;
    }

    if (!RtlAreAllAccessesGranted(ppiCurrent->amwinsta, WINSTA_WRITEATTRIBUTES)) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "WINSTA_WRITEATTRIBUTES access to WindowStation denied.");

        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* AccessCheckObject
*
* Performs an access check on an object
*
* History:
* 12-31-90 JimA       Created.
\***************************************************************************/

BOOL AccessCheckObject(
    PVOID pobj,
    ACCESS_MASK amRequest,
    KPROCESSOR_MODE AccessMode,
    CONST GENERIC_MAPPING *pGenericMapping)
{
    NTSTATUS Status;
    ACCESS_STATE AccessState;
    BOOLEAN fAccessGranted;
    AUX_ACCESS_DATA AuxData;
    BOOLEAN bMutexLocked = (pGenericMapping == (&KeyMapping));
    /*
     * Due to a resource problem in the object manager, we must pass in a TRUE
     * when checking access for registry keys, even if we do not explicitly have
     * the object type mutex.  If we do not, we can get into a deadlock situation with this mutex
     * and the CmpRegistry lock.
     */

    SeCreateAccessState(&AccessState, &AuxData, amRequest, (PGENERIC_MAPPING)pGenericMapping);
    fAccessGranted = ObCheckObjectAccess(
            pobj,
            &AccessState,
            bMutexLocked,
            AccessMode,
            &Status);
    SeDeleteAccessState(&AccessState);
    return (BOOL)(fAccessGranted == TRUE);
}

/***************************************************************************\
* IsPrivileged
*
* Check to see if the client has the specified privileges
*
* History:
* 01-02-91 JimA       Created.
\***************************************************************************/

BOOL IsPrivileged(
    PPRIVILEGE_SET ppSet)
{
    SECURITY_SUBJECT_CONTEXT Context;
    BOOLEAN bHeld;

    SeCaptureSubjectContext(&Context);
    SeLockSubjectContext(&Context);

    bHeld = SePrivilegeCheck(ppSet, &Context, UserMode);
    SePrivilegeObjectAuditAlarm(NULL, &Context, 0, ppSet, bHeld, UserMode);

    SeUnlockSubjectContext(&Context);
    SeReleaseSubjectContext(&Context);

    if (!bHeld)
        RIPERR0(ERROR_PRIVILEGE_NOT_HELD, RIP_VERBOSE, "");

    /*
     * Return result of privilege check
     */
    return (BOOL)bHeld;
}

/***************************************************************************\
* _GetUserObjectInformation (API)
*
* Gets information about a secure USER object
*
* History:
* 04-25-94 JimA       Created.
\***************************************************************************/

BOOL _GetUserObjectInformation(
    HANDLE h,
    int nIndex,
    PVOID ccxpvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded)
{
    PUSEROBJECTFLAGS puof;
    BOOL fSuccess = TRUE;
    PVOID pObject;
    POBJECT_HEADER pHead;
    DWORD dwLengthNeeded = 0;
    OBJECT_HANDLE_INFORMATION ohi;
    PUNICODE_STRING pstrInfo;
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;
    ACCESS_MASK amDesiredAccess = 0;

    /*
     * Validate the object and get a pointer with whatever 
     * access is granted.
     */
    Status = ObReferenceObjectByHandle(
            h,
            0,
            NULL,
            UserMode,
            &pObject,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
        return FALSE;
    }

    /*
     * Determine the correct access mask given the object type.
     */
    pHead = OBJECT_TO_OBJECT_HEADER(pObject);
    if (pHead->Type == *ExWindowStationObjectType) {
        amDesiredAccess = WINSTA_READATTRIBUTES;
    } else if (pHead->Type == *ExDesktopObjectType) {
        amDesiredAccess = DESKTOP_READOBJECTS;
    }

    ObDereferenceObject(pObject);
    if (!amDesiredAccess) {
        RIPERR0(ERROR_INVALID_FUNCTION, RIP_WARNING, "Object is not a USER object");
        return FALSE;
    }

    /*
     * Re-open the object with the proper access.
     */
    Status = ObReferenceObjectByHandle(
            h,
            amDesiredAccess,
            NULL,
            UserMode,
            &pObject,
            &ohi);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
        return FALSE;
    }

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_REF_FN_GETUSEROBJECTINFORMATION, TRUE, (ULONG_PTR)PtiCurrentShared());
    }
#endif

    try {
        switch (nIndex) {
        case UOI_FLAGS:
            dwLengthNeeded = sizeof(USEROBJECTFLAGS);
            if (nLength < sizeof(USEROBJECTFLAGS)) {
                RIPERR0(ERROR_INSUFFICIENT_BUFFER, RIP_VERBOSE, "");
                fSuccess = FALSE;
                break;
            }
            puof = ccxpvInfo;
            puof->fInherit = (ohi.HandleAttributes & OBJ_INHERIT) ? TRUE : FALSE;
            puof->fReserved = 0;
            puof->dwFlags = 0;
            if (pHead->Type == *ExDesktopObjectType) {
                if (CheckHandleFlag(NULL, ((PDESKTOP)pObject)->dwSessionId, h, HF_DESKTOPHOOK)) {
                    puof->dwFlags |= DF_ALLOWOTHERACCOUNTHOOK;
                }
            } else {
                if (!(((PWINDOWSTATION)pObject)->dwWSF_Flags & WSF_NOIO))
                    puof->dwFlags |= WSF_VISIBLE;
            }
            break;

        case UOI_NAME:
            pstrInfo = POBJECT_NAME(pObject);
            goto docopy;

        case UOI_TYPE:
            pstrInfo = &pHead->Type->Name;
docopy:
            if (pstrInfo) {
                dwLengthNeeded = pstrInfo->Length + sizeof(WCHAR);
                if (dwLengthNeeded > nLength) {
                    RIPERR0(ERROR_INSUFFICIENT_BUFFER, RIP_VERBOSE, "");
                    fSuccess = FALSE;
                    break;
                }
                RtlCopyMemory(ccxpvInfo, pstrInfo->Buffer, pstrInfo->Length);
                *(PWCHAR)((PBYTE)ccxpvInfo + pstrInfo->Length) = 0;
            } else {
                dwLengthNeeded = 0;
            }
            break;

        case UOI_USER_SID:
            if (pHead->Type == *ExWindowStationObjectType)
                pwinsta = pObject;
            else
                pwinsta = ((PDESKTOP)pObject)->rpwinstaParent;
            if (pwinsta->psidUser == NULL) {
                dwLengthNeeded = 0;
            } else {
                dwLengthNeeded = RtlLengthSid(pwinsta->psidUser);
                if (dwLengthNeeded > nLength) {
                    RIPERR0(ERROR_INSUFFICIENT_BUFFER, RIP_VERBOSE, "");
                    fSuccess = FALSE;
                    break;
                }
                RtlCopyMemory(ccxpvInfo, pwinsta->psidUser, dwLengthNeeded);
            }
            break;

        default:
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            fSuccess = FALSE;
            break;
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        fSuccess = FALSE;
    }

    *lpnLengthNeeded = dwLengthNeeded;

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_DEREF_FN_GETUSEROBJECTINFORMATION, FALSE, (ULONG_PTR)PtiCurrentShared());
    }
#endif

    ObDereferenceObject(pObject);

    return fSuccess;
}

/***************************************************************************\
* _SetUserObjectInformation (API)
*
* Sets information about a secure USER object
*
* History:
* 04-25-94 JimA       Created.
\***************************************************************************/

BOOL _SetUserObjectInformation(
    HANDLE h,
    int nIndex,
    PVOID ccxpvInfo,
    DWORD nLength)
{
    PUSEROBJECTFLAGS puof;
    BOOL fSuccess = TRUE;
    PVOID pObject;
    POBJECT_HEADER pHead;
    DWORD dwLengthNeeded = 0;
    OBJECT_HANDLE_INFORMATION ohi;
    OBJECT_HANDLE_FLAG_INFORMATION ofi;
    NTSTATUS Status;
    ACCESS_MASK amDesiredAccess = 0;

    /*
     * Validate the object and get a pointer with whatever 
     * access is granted.
     */
    Status = ObReferenceObjectByHandle(
            h,
            0,
            NULL,
            UserMode,
            &pObject,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
        return FALSE;
    }

    /*
     * Determine the correct access mask given the object type.
     */
    pHead = OBJECT_TO_OBJECT_HEADER(pObject);
    if (pHead->Type == *ExWindowStationObjectType) {
        amDesiredAccess = WINSTA_WRITEATTRIBUTES;
    } else if (pHead->Type == *ExDesktopObjectType) {
        amDesiredAccess = DESKTOP_WRITEOBJECTS;
    }

    ObDereferenceObject(pObject);
    if (!amDesiredAccess) {
        RIPERR0(ERROR_INVALID_FUNCTION, RIP_WARNING, "Object is not a USER object");
        return FALSE;
    }

    /*
     * Re-open the object with the proper access.
     */
    Status = ObReferenceObjectByHandle(
            h,
            amDesiredAccess,
            NULL,
            UserMode,
            &pObject,
            &ohi);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
        return FALSE;
    }

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_REF_FN_SETUSEROBJECTINFORMATION, TRUE, (ULONG_PTR)PtiCurrent());
    }
#endif

    try {
        switch (nIndex) {
        case UOI_FLAGS:
            if (nLength < sizeof(USEROBJECTFLAGS)) {
                RIPERR0(ERROR_INVALID_DATA, RIP_VERBOSE, "");
             